{
    "patch": "import org.apache.commons.math3.analysis.UnivariateFunction;\nimport org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver;\nimport org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils;\nimport org.apache.commons.math3.exception.MaxIterationsExceededException;\nimport org.apache.commons.math3.exception.NoBracketingException;\n\npublic class MySolver extends BaseAbstractUnivariateSolver<UnivariateFunction> {\n\n    public final static double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n\n    public MySolver() {\n        super(DEFAULT_ABSOLUTE_ACCURACY);\n    }\n\n    public MySolver(final double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n\n    public MySolver(final double relativeAccuracy,\n                    final double absoluteAccuracy) {\n        super(relativeAccuracy, absoluteAccuracy);\n    }\n\n    public MySolver(final double relativeAccuracy,\n                    final double absoluteAccuracy,\n                    final double functionValueAccuracy) {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n    }\n    \n    @Override\n    protected double doSolve() throws MaxIterationsExceededException, NoBracketingException {\n        double min = getMin();\n        double max = getMax();\n        \n        clearResult();\n        verifyInterval(min, max);\n\n        double ret = Double.NaN;\n        \n        double yMin = computeObjectiveValue(min);\n        double yMax = computeObjectiveValue(max);\n        \n        // verify bracketing\n        double sign = yMin * yMax;\n        if (sign > 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n                ret = min;\n                setResult(ret, 0);\n                return ret;\n            }\n            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n                ret = max;\n                setResult(ret, 0);\n                return ret;\n            }\n\n            // neither value is close to zero and min and max do not bracket root.\n            throw new NoBracketingException(min, max, yMin, yMax);\n        } else if (sign < 0) {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        } else {\n            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n                ret = min;\n                setResult(ret, 0);\n                return ret;\n            }\n            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n                ret = max;\n                setResult(ret, 0);\n                return ret;\n            }\n\n            // sign == 0\n            ret = min;\n            setResult(ret, 0);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the value of the objective function.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     */\n    @Override\n    protected double computeObjectiveValue(double point) {\n        incrementEvaluationCount();\n        return getFunctionValue().value(point);\n    }\n    \n    /**\n     * Solve for a root.\n     *\n     * @param x0 Initial point.\n     * @param y0 function value at x0 (ignored).\n     * @param x1 Bracket point.\n     * @param y1 function value at x1 (ignored).\n     * @param x2 Bracket point.\n     * @param y2 function value at x2 (ignored).\n     * @return the value where the function is zero.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws NoBracketingException if the function cannot be bracketed.\n     */\n    protected double solve(double x0, double y0,\n                           double x1, double y1,\n                           double x2, double y2)\n        throws NoBracketingException {\n        final double absoluteAccuracy = getAbsoluteAccuracy();\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n\n        // tolerance for termination\n        final double ftol = 1e-10;\n        \n        // Miller's algorithm requires that at least one endpoint be the root\n        if (Math.abs(y0) <= Math.abs(y1)) {\n            // swap\n            double tmp1 = x0;\n            x0 = x1;\n            x1 = tmp1;\n            \n            double tmp2 = y0;\n            y0 = y1;\n            y1 = tmp2;\n        }\n        if (Math.abs(y2) <= Math.abs(y1)) {\n            // swap\n            double tmp1 = x2;\n            x2 = x1;\n            x1 = tmp1;\n            \n            double tmp2 = y2;\n            y2 = y1;\n            y1 = tmp2;\n        }\n\n        // Miller's algorithm starts with x0 as root: verify that before\n        // doing anything else\n        if ((y0 < 0) && (y2 > 0) || (y0 > 0) && (",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..513cd4552 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,34 +122,152 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver;\n+import org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils;\n+import org.apache.commons.math3.exception.MaxIterationsExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+\n+public class MySolver extends BaseAbstractUnivariateSolver<UnivariateFunction> {\n+\n+    public final static double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n+    public MySolver() {\n+        super(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+\n+    public MySolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+\n+    public MySolver(final double relativeAccuracy,\n+                    final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+\n+    public MySolver(final double relativeAccuracy,\n+                    final double absoluteAccuracy,\n+                    final double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+    \n+    @Override\n+    protected double doSolve() throws MaxIterationsExceededException, NoBracketingException {\n+        double min = getMin();\n+        double max = getMax();\n         \n         clearResult();\n         verifyInterval(min, max);\n-        \n+\n         double ret = Double.NaN;\n         \n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n+        double yMin = computeObjectiveValue(min);\n+        double yMax = computeObjectiveValue(max);\n         \n-        // Verify bracketing\n+        // verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n+        if (sign > 0) {\n             // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n+                ret = min;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n+                ret = max;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new NoBracketingException(min, max, yMin, yMax);\n+        } else if (sign < 0) {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n+        } else {\n+            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n+                ret = min;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n+                ret = max;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+\n+            // sign == 0\n+            ret = min;\n+            setResult(ret, 0);\n         }\n \n         return ret;\n     }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the value of the objective function.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    @Override\n+    protected double computeObjectiveValue(double point) {\n+        incrementEvaluationCount();\n+        return getFunctionValue().value(point);\n+    }\n+    \n+    /**\n+     * Solve for a root.\n+     *\n+     * @param x0 Initial point.\n+     * @param y0 function value at x0 (ignored).\n+     * @param x1 Bracket point.\n+     * @param y1 function value at x1 (ignored).\n+     * @param x2 Bracket point.\n+     * @param y2 function value at x2 (ignored).\n+     * @return the value where the function is zero.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     * @throws NoBracketingException if the function cannot be bracketed.\n+     */\n+    protected double solve(double x0, double y0,\n+                           double x1, double y1,\n+                           double x2, double y2)\n+        throws NoBracketingException {\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        // tolerance for termination\n+        final double ftol = 1e-10;\n+        \n+        // Miller's algorithm requires that at least one endpoint be the root\n+        if (Math.abs(y0) <= Math.abs(y1)) {\n+            // swap\n+            double tmp1 = x0;\n+            x0 = x1;\n+            x1 = tmp1;\n+            \n+            double tmp2 = y0;\n+            y0 = y1;\n+            y1 = tmp2;\n+        }\n+        if (Math.abs(y2) <= Math.abs(y1)) {\n+            // swap\n+            double tmp1 = x2;\n+            x2 = x1;\n+            x1 = tmp1;\n+            \n+            double tmp2 = y2;\n+            y2 = y1;\n+            y1 = tmp2;\n+        }\n+\n+        // Miller's algorithm starts with x0 as root: verify that before\n+        // doing anything else\n+        if ((y0 < 0) && (y2 > 0) || (y0 > 0) && (\n         \n     /**\n      * Find a zero starting search according to the three provided points.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}