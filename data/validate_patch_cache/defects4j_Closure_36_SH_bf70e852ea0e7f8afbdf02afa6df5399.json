{
    "patch": "          if (convention.isSingletonGetterMethod(value)\n              && reference.getParent().isCall()\n              && reference.getNode() == reference.getParent().getFirstChild()) {\n            return false;\n          }\n        }\n\n        return canMoveAggressively(value) ||\n            canMoveModerately(initialization, reference);\n    }\n\n    private boolean canMoveAggressively(Node n) {\n      CodingConvention convention = compiler.getCodingConvention();\n      String type = convention.describeType(n);\n      if (\"RegExp\".equals(type)) {\n        return false;\n      }\n      if (n.isName() || type == null) {\n        return true;\n      }\n      if (n.isCall()) {\n        Node callee = n.getFirstChild();\n        if (callee.isName() && convention.isFunctionSignatureRepeated(callee.getString())) {\n          return false;\n        }\n\n        // Pretend we can inline all the arguments.\n        for (Node parameter : NodeUtil.getArgumentsAsIterable(n)) {\n          if (!canMoveAggressively(parameter)) {\n            return false;\n          }\n        }\n        return true;\n      }\n      return false;\n    }\n\n    private boolean canMoveModerately(Reference from, Reference to) {\n      return NodeUtil.mayBeString(from.getNode())\n          && from.getNext() == to;\n    }\n  };\n}\n\nprivate boolean isValidDeclaration(Reference declaration) {\n  return declaration.getSymbol() != null\n      && declaration.getSymbol().getDeclaration() == declaration.getNode();\n}\n\nprivate boolean isValidInitialization(Reference initialization) {\n  return initialization != null\n      && initialization.getBasicBlock() != null\n      && !initialization.getBasicBlock().isLessThan(cfg.getEntry().getBlock());\n}\n\nprivate boolean isValidReference(Reference reference) {\n  return reference != null\n      && reference.getBasicBlock() != null\n      && !reference.getBasicBlock().isGreaterThan(cfg.getExit().getBlock());\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..885bfceb 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,66 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+          if (convention.isSingletonGetterMethod(value)\n+              && reference.getParent().isCall()\n+              && reference.getNode() == reference.getParent().getFirstChild()) {\n+            return false;\n+          }\n+        }\n+\n+        return canMoveAggressively(value) ||\n+            canMoveModerately(initialization, reference);\n+    }\n+\n+    private boolean canMoveAggressively(Node n) {\n+      CodingConvention convention = compiler.getCodingConvention();\n+      String type = convention.describeType(n);\n+      if (\"RegExp\".equals(type)) {\n+        return false;\n+      }\n+      if (n.isName() || type == null) {\n+        return true;\n+      }\n+      if (n.isCall()) {\n+        Node callee = n.getFirstChild();\n+        if (callee.isName() && convention.isFunctionSignatureRepeated(callee.getString())) {\n+          return false;\n+        }\n+\n+        // Pretend we can inline all the arguments.\n+        for (Node parameter : NodeUtil.getArgumentsAsIterable(n)) {\n+          if (!canMoveAggressively(parameter)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+      }\n+      return false;\n+    }\n+\n+    private boolean canMoveModerately(Reference from, Reference to) {\n+      return NodeUtil.mayBeString(from.getNode())\n+          && from.getNext() == to;\n+    }\n+  };\n+}\n+\n+private boolean isValidDeclaration(Reference declaration) {\n+  return declaration.getSymbol() != null\n+      && declaration.getSymbol().getDeclaration() == declaration.getNode();\n+}\n+\n+private boolean isValidInitialization(Reference initialization) {\n+  return initialization != null\n+      && initialization.getBasicBlock() != null\n+      && !initialization.getBasicBlock().isLessThan(cfg.getEntry().getBlock());\n+}\n+\n+private boolean isValidReference(Reference reference) {\n+  return reference != null\n+      && reference.getBasicBlock() != null\n+      && !reference.getBasicBlock().isGreaterThan(cfg.getExit().getBlock());\n+}\n         }\n       }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}