{
    "patch": "// Check if the sources need to be re-ordered.\nif (options.dependencyOptions.needsManagement() && options.closurePass) {\n    inputs = sortInputs(inputs, options.dependencyOptions);\n    for (CompilerInput input : inputs) {\n        process(externsRoot, input);\n        process(jsRoot, input);\n    }\n} else {\n    for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        if (n == null) continue;\n        // Annotate the nodes in the tree with information from the input file.\n        if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\n            SourceInformationAnnotator annotator = new SourceInformationAnnotator(\n                    input.getName(), options.devMode != DevMode.OFF);\n            NodeTraversal.traverse(this, n, annotator);\n        }\n        if (isIdeMode) {\n            // Verify the correctness of the AST before proceeding in IDE mode.\n            sanityCheck();\n        }\n        jsRoot.addChildToBack(n);\n    }\n    if (options.googInherits && !inputs.isEmpty()) {\n        Node last = inputs.get(inputs.size() - 1).getAstRoot(this);\n        if (!NodeUtil.isCallTo(last.getFirstChild(), \"goog.inherits\")) {\n            report(JSError.make(MISSING_GOOG_INHERITS_ERROR, \"The last input file must have a call to goog.inherits()\"));\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..5905730e 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,36 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+// Check if the sources need to be re-ordered.\n+if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+    inputs = sortInputs(inputs, options.dependencyOptions);\n+    for (CompilerInput input : inputs) {\n+        process(externsRoot, input);\n+        process(jsRoot, input);\n+    }\n+} else {\n+    for (CompilerInput input : inputs) {\n+        Node n = input.getAstRoot(this);\n+        if (n == null) continue;\n+        // Annotate the nodes in the tree with information from the input file.\n+        if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\n+            SourceInformationAnnotator annotator = new SourceInformationAnnotator(\n+                    input.getName(), options.devMode != DevMode.OFF);\n+            NodeTraversal.traverse(this, n, annotator);\n+        }\n+        if (isIdeMode) {\n+            // Verify the correctness of the AST before proceeding in IDE mode.\n+            sanityCheck();\n+        }\n+        jsRoot.addChildToBack(n);\n+    }\n+    if (options.googInherits && !inputs.isEmpty()) {\n+        Node last = inputs.get(inputs.size() - 1).getAstRoot(this);\n+        if (!NodeUtil.isCallTo(last.getFirstChild(), \"goog.inherits\")) {\n+            report(JSError.make(MISSING_GOOG_INHERITS_ERROR, \"The last input file must have a call to goog.inherits()\"));\n+        }\n+    }\n+}\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}