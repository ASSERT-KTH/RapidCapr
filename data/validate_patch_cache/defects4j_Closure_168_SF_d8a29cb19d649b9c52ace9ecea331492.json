{
    "patch": "public class FirstOrderFunctionAnalyzer extends AbstractPostOrderCallback implements CompilerPass {\n\n  private static final DiagnosticType MULTIPLE_VAR_DEF =\n      DiagnosticType.warning(\n          \"JSC_MULTIPLE_VAR_DEF\",\n          \"Variable ''{0}'' shadows a variable declared in the outer scope.\");\n\n  private final Map<Node, VarData> data;\n  private final AbstractCompiler compiler;\n\n  public FirstOrderFunctionAnalyzer(AbstractCompiler compiler) {\n    this.data = new LinkedHashMap<>();\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, new EnterExitCallback() {\n      @Override\n      public void enterScope(NodeTraversal t) {\n        Scope scope = t.getScope();\n        if (!scope.isFunctionBlockScope()) {\n          // Don't create data for function blocks, only for functions.\n          return;\n        }\n        // Use Map#putIfAbsent to avoid creating redundant data.\n        data.putIfAbsent(t.getScopeRoot(), new VarData());\n      }\n\n      @Override\n      public void exitScope(NodeTraversal t) {}\n    });\n\n    NodeTraversal.traverse(compiler, root, new FirstOrderFunctionAnalyzer(compiler));\n\n    for (Map.Entry<Node, VarData> entry : data.entrySet()) {\n      Node fnRoot = entry.getKey();\n      VarData varData = entry.getValue();\n      if (varData.containsFunctionWithName(\"catch\")) {\n        continue; // Avoid catching parse errors generated by the Flow parser\n      }\n      if (fnRoot.getJSDocInfo() != null && fnRoot.getJSDocInfo().isConstructor()) {\n        continue; // Ignore ES6 class constructors\n      }\n      check(fnRoot, varData, compiler);\n    }\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n      return;\n    }\n\n    if (n.isReturn() && n.getFirstChild() != null) {\n      data.get(t.getScopeRoot()).recordNonEmptyReturn();\n    }\n\n    if (t.getScopeDepth() <= 2) {\n      // The first-order function analyzer looks at two types of variables:\n      //\n      // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n      //\n      // 2) Local variables that are assigned more than once.\n      //\n      // We treat all global variables as escaped by default, so there's\n      // no reason to do this extra computation for them.\n      return;\n    }\n\n    if (n.isName() && NodeUtil.isLValue(n) &&\n        // Be careful of bleeding functions, which create variables\n        // in the inner scope, not the scope where the name appears.\n        !NodeUtil.isBleedingFunctionName(n)) {\n      String name = n.getString();\n      Scope scope = t.getScope();\n      Var var = scope.getVar(name);\n      if (var != null) {\n        Scope ownerScope = var.getScope();\n        if (ownerScope.isLocal()) {\n          data.get(ownerScope.getRootNode()).recordAssignedName(name);\n        }\n\n        if (scope != ownerScope && ownerScope.isLocal()) {\n          data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n        }\n      }\n    } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n        NodeUtil.isLValue(n)) {\n      String name = NodeUtil.getRootOfQualifiedName(n).getString();\n      Scope scope = t.getScope();\n      Var var = scope.getVar(name);\n      if (var != null) {\n        Scope ownerScope = var.getScope();\n        if (scope != ownerScope && ownerScope.isLocal()) {\n          data.get(ownerScope.getRootNode())\n              .recordEscapedQualifiedName(n.getQualifiedName());\n        }\n      }\n    }\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node node) {\n    if (!node.isName() || t.getScope().isGlobal()) {\n      return;\n    }\n\n    String name = node.getString();\n    Var var = t.getScope().getVar(name);\n    if (var == null || !var.isLocal()) {\n      return;\n    }\n\n    Scope.VarSymbol varSymbol = t.getScope().getVarSymbol(name);\n    if (varSymbol == null || !varSymbol.isVar()) {\n      return;\n    }\n\n    Node parent = node.getParent();\n    if (!NodeUtil.isNameDeclaration(parent) || NodeUtil.isEnhancedFor(parent.getParent())) {\n      return;\n    }\n\n    Node value = node.getFirstChild();\n    Node grandparent = parent.getParent();\n    if (value != null && value.isFunction() && grandparent.isBlock()) {\n      // Handle function declarations:\n      // - A variable declaration with a function RHS that appears in a block scope\n      //   creates a new variable in that scope.\n      // - A variable declaration with a function RHS that appears outside a block\n      //   scope shadows the global variable of the same name.\n      createDataForFunctionScope(value, t.getScope(), t.getScopeRoot());\n    } else if (NodeUtil.isNameDeclaration(grandparent) && grandparent.hasOneChild()) {\n      // Handle variable declarations:\n      // - A variable declaration in a block scope has no effect on parent scopes.\n      // - A variable declaration outside of a block scope shadows the parent variable.\n      Node rhs = parent.getLastChild();\n      if (rhs != null) {\n        // Record a new assigned name if a value is provided.\n        data.get(t.getScopeRoot()).recordAssignedName(node.getString());\n      }\n      return;\n    } else {\n      // Handle other forms of variable assignments:\n      // - All variable assignments shadow the parent variable.\n      data.get(t.getScopeRoot()).recordMultipleVarDefs(node, parent);\n    }\n\n    if (varSymbol.isDefined()) {\n      // Ignore all variables that have already been defined.\n      return;\n    }\n\n    Node varNode = node.getFirstChild();\n    if (varNode == null) {\n      // Bail if there's no assigned value.\n      return;\n    }\n\n    if (varNode.isFunction()) {\n      // Ignore function declarations.\n      return;\n    }\n\n    if (t.getScopeDepth() <= 2) {\n      // Treat variable assignments in function blocks as escaped variables to avoid raising false\n      // alerts on common idioms like `function foo() { var x = ...; return function() { ... }; }`.\n      return;\n    }\n\n    data.get(t.getScopeRoot()).recordAssignedName(node.getString());\n  }\n\n  private void createDataForFunctionScope(Node fnNode, Scope parentScope, Node fnRoot) {\n    checkState(fnNode.isFunction(), \"unexpected variable value: %s\", fnNode);\n\n    VarData varData = data.get(fnRoot);\n    if (varData == null) {\n      varData = new VarData();\n      data.put(fnRoot, varData);\n    }\n\n    Scope fnScope = parentScope.getClosestHoistScope().addChildScope(fnNode);\n    for (Var v : fnScope.getVarIterable()) {\n      if (v.isLocal()) {\n        varData.recordShadowedName(v.getName());\n      }\n    }\n  }\n\n  private void check(Node fnNode, VarData varData, AbstractCompiler compiler) {\n    // Check for multiple var defs and shadowed names.\n    for (VarInfo varInfo : varData.getInheritedVarInfo()) {\n      if (varData.hasAssignedName(varInfo.name)) {\n        continue; // Ignore assigned names to skip false positives.\n      }\n\n      String rootName = varInfo.name.contains(\".\") ? varInfo.name.split(\"\\\\.\")[0] : varInfo.name;\n      Scope.VarSymbol varSymbol = fnNode.getScope().getVarSymbol(rootName);\n      if (varSymbol == null) {\n        if (varInfo.type == VarType.ASSIGNED_NON_LOCAL &&\n            !varData.isEscapedVarName(varInfo.name)) {\n          // If the variable is assigned in a nested scope and never escapes that scope,\n          // we consider it intentional and don't report a warning.\n          continue;\n        }\n\n        String msg = varInfo.type == VarType.MULTIPLE_DEF\n            ? MULTIPLE_VAR_DEF.format(varInfo.name)\n            : \"Variable '\" + varInfo.name + \"' is shadowed by another variable.\";\n        compiler.report(JSError.make(fnNode, MULTIPLE_VAR_DEF));\n      } else if (varInfo.type == VarType.ASSIGNED_NON_LOCAL) {\n        // Check that variables assigned in block scopes are not redeclared.\n        Var var = varSymbol.getScope().getVar(varInfo.name);\n        if (var != null && !var.isArguments()) {\n          compiler.report(JSError.make(fnNode, MULTIPLE_VAR_DEF));\n        }\n      }\n    }\n\n    // Note: the preferred way to pass information out of the traverse() methods is to mutate\n    // instance variables like `data`.\n  }\n\n  private enum VarType {\n    MULTIPLY_DECLARED, // Var declared multiple times in this scope.\n    DECLARED_NON_LOCAL, // Var defined in enclosing scope but used in this scope.\n    ASSIGNED_NON_LOCAL, // Like `DECLARED_NON_LOCAL`, but var is also assigned in this scope.\n  }\n\n  private static class VarInfo {\n    final String name;\n    final VarType type;\n\n    VarInfo(String name, VarType type) {\n      this.name = name;\n      this.type = type;\n    }\n  }\n\n  private static class VarData {\n\n    /** Variables defined or assigned in this scope or nested scopes. */\n    private final Set<String> assignedNames = new HashSet<>();\n\n    /** Shadowed variables defined in enclosing scopes. */\n    private final Set<String> shadowedNames = new HashSet<>();\n\n    /** Names of variables that \"escape\" this scope (reassigned or accessed in lower scopes). */\n    private final Set<String> escapedVarNames = new HashSet<>();\n\n    /** Properties of variables that \"escape\" this scope (reassigned or accessed in lower scopes). */\n    private final Set<String> escapedQualifiedNames = new HashSet<>();\n\n    private final Set<String> allFunctionNames = new HashSet<>();\n\n    void recordAssignedName(String name) {\n      assignedNames.add(name);\n    }\n\n    void recordMultipleVarDefs(Node nameNode, Node parentNode) {\n      for (Node next = nameNode.getNext(); next != null; next = next.getNext()) {\n        if (next.isName() && next.getString().equals(nameNode.getString())) {\n          JSError error = JSError.make(parentNode, MULTIPLE_VAR_DEF);\n          throw new RuntimeException(error.toString());\n        }\n      }\n    }\n\n    void recordShadowedName(String name) {\n      // Don't record global variables or already-shadowed variables\n      if (!escapedVarNames.contains(name) && !allFunctionNames.contains(name) &&\n          shadowedNames.add(name)) {\n        // Add the escaped var even in the presence of a shadowed var.\n        // The analysis will generate an error about the shadowed var.\n        escapedVarNames.remove(name);\n        escapedQualifiedNames.removeIf(prop -> prop.startsWith(name));\n      }\n    }\n\n    void recordEscapedVarName(String name) {\n      // Don't record shadowed variables\n      if (!shadowedNames.contains(name)) {\n        escapedVarNames.add(name);\n      }\n    }\n\n    void recordEscapedQualifiedName(String qualifiedName) {\n      escapedQualifiedNames.add(qualifiedName);\n    }\n\n    void recordFunctionName(String name) {\n      allFunctionNames.add(name);\n    }\n\n    boolean containsFunctionWithName(String name) {\n      return allFunctionNames.contains(name);\n    }\n\n    boolean hasAssignedName(String name) {\n      return assignedNames.contains(name);\n    }\n\n    boolean isEscapedVarName(String name) {\n      return escapedVarNames.contains(name);\n    }\n\n    Iterable<VarInfo> getInheritedVarInfo() {\n      Iterable<Scope.VarSymbol> vars = Iterables.concat(\n          asList(Scope.VarSymbol.values()), asList(Scope.VarSymbol.NUMBER_SPECIAL_VALUES),\n          singleton(allFunctionNames));\n      return () -> vars.iterator()\n          .flatMap(varSymbol -> varSymbol.getIterableScope())\n          .map(Var::getNameNode)\n          .filter(node -> node != null && node.isName())\n          .map(Node::getString)\n          .filter(name -> !allFunctionNames.contains(name))\n          .map(name -> new VarInfo(name, getVarType(name)))\n          .iterator();\n    }\n\n    private VarType getVarType(String name) {\n      if (assignedNames.contains(name)) {\n        // If a non-local var is assigned within this scope or a lower scope,\n        // we error out when we encounter the varInfo during the post-order walk.\n        return shado",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..910e6800 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1983,59 +1983,333 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.put(n, new AstFunctionContents(n));\n       }\n     }\n+public class FirstOrderFunctionAnalyzer extends AbstractPostOrderCallback implements CompilerPass {\n \n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (t.inGlobalScope()) {\n-        return;\n+  private static final DiagnosticType MULTIPLE_VAR_DEF =\n+      DiagnosticType.warning(\n+          \"JSC_MULTIPLE_VAR_DEF\",\n+          \"Variable ''{0}'' shadows a variable declared in the outer scope.\");\n+\n+  private final Map<Node, VarData> data;\n+  private final AbstractCompiler compiler;\n+\n+  public FirstOrderFunctionAnalyzer(AbstractCompiler compiler) {\n+    this.data = new LinkedHashMap<>();\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, new EnterExitCallback() {\n+      @Override\n+      public void enterScope(NodeTraversal t) {\n+        Scope scope = t.getScope();\n+        if (!scope.isFunctionBlockScope()) {\n+          // Don't create data for function blocks, only for functions.\n+          return;\n+        }\n+        // Use Map#putIfAbsent to avoid creating redundant data.\n+        data.putIfAbsent(t.getScopeRoot(), new VarData());\n       }\n \n-      if (n.isReturn() && n.getFirstChild() != null) {\n-        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n+      @Override\n+      public void exitScope(NodeTraversal t) {}\n+    });\n+\n+    NodeTraversal.traverse(compiler, root, new FirstOrderFunctionAnalyzer(compiler));\n+\n+    for (Map.Entry<Node, VarData> entry : data.entrySet()) {\n+      Node fnRoot = entry.getKey();\n+      VarData varData = entry.getValue();\n+      if (varData.containsFunctionWithName(\"catch\")) {\n+        continue; // Avoid catching parse errors generated by the Flow parser\n       }\n+      if (fnRoot.getJSDocInfo() != null && fnRoot.getJSDocInfo().isConstructor()) {\n+        continue; // Ignore ES6 class constructors\n+      }\n+      check(fnRoot, varData, compiler);\n+    }\n+  }\n \n-      if (t.getScopeDepth() <= 2) {\n-        // The first-order function analyzer looks at two types of variables:\n-        //\n-        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n-        //\n-        // 2) Local variables that are assigned more than once.\n-        //\n-        // We treat all global variables as escaped by default, so there's\n-        // no reason to do this extra computation for them.\n-        return;\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (t.inGlobalScope()) {\n+      return;\n+    }\n+\n+    if (n.isReturn() && n.getFirstChild() != null) {\n+      data.get(t.getScopeRoot()).recordNonEmptyReturn();\n+    }\n+\n+    if (t.getScopeDepth() <= 2) {\n+      // The first-order function analyzer looks at two types of variables:\n+      //\n+      // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n+      //\n+      // 2) Local variables that are assigned more than once.\n+      //\n+      // We treat all global variables as escaped by default, so there's\n+      // no reason to do this extra computation for them.\n+      return;\n+    }\n+\n+    if (n.isName() && NodeUtil.isLValue(n) &&\n+        // Be careful of bleeding functions, which create variables\n+        // in the inner scope, not the scope where the name appears.\n+        !NodeUtil.isBleedingFunctionName(n)) {\n+      String name = n.getString();\n+      Scope scope = t.getScope();\n+      Var var = scope.getVar(name);\n+      if (var != null) {\n+        Scope ownerScope = var.getScope();\n+        if (ownerScope.isLocal()) {\n+          data.get(ownerScope.getRootNode()).recordAssignedName(name);\n+        }\n+\n+        if (scope != ownerScope && ownerScope.isLocal()) {\n+          data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n+        }\n       }\n+    } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n+        NodeUtil.isLValue(n)) {\n+      String name = NodeUtil.getRootOfQualifiedName(n).getString();\n+      Scope scope = t.getScope();\n+      Var var = scope.getVar(name);\n+      if (var != null) {\n+        Scope ownerScope = var.getScope();\n+        if (scope != ownerScope && ownerScope.isLocal()) {\n+          data.get(ownerScope.getRootNode())\n+              .recordEscapedQualifiedName(n.getQualifiedName());\n+        }\n+      }\n+    }\n+  }\n \n-      if (n.isName() && NodeUtil.isLValue(n) &&\n-          // Be careful of bleeding functions, which create variables\n-          // in the inner scope, not the scope where the name appears.\n-          !NodeUtil.isBleedingFunctionName(n)) {\n-        String name = n.getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n-          }\n+  @Override\n+  public void visit(NodeTraversal t, Node node) {\n+    if (!node.isName() || t.getScope().isGlobal()) {\n+      return;\n+    }\n \n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n-          }\n+    String name = node.getString();\n+    Var var = t.getScope().getVar(name);\n+    if (var == null || !var.isLocal()) {\n+      return;\n+    }\n+\n+    Scope.VarSymbol varSymbol = t.getScope().getVarSymbol(name);\n+    if (varSymbol == null || !varSymbol.isVar()) {\n+      return;\n+    }\n+\n+    Node parent = node.getParent();\n+    if (!NodeUtil.isNameDeclaration(parent) || NodeUtil.isEnhancedFor(parent.getParent())) {\n+      return;\n+    }\n+\n+    Node value = node.getFirstChild();\n+    Node grandparent = parent.getParent();\n+    if (value != null && value.isFunction() && grandparent.isBlock()) {\n+      // Handle function declarations:\n+      // - A variable declaration with a function RHS that appears in a block scope\n+      //   creates a new variable in that scope.\n+      // - A variable declaration with a function RHS that appears outside a block\n+      //   scope shadows the global variable of the same name.\n+      createDataForFunctionScope(value, t.getScope(), t.getScopeRoot());\n+    } else if (NodeUtil.isNameDeclaration(grandparent) && grandparent.hasOneChild()) {\n+      // Handle variable declarations:\n+      // - A variable declaration in a block scope has no effect on parent scopes.\n+      // - A variable declaration outside of a block scope shadows the parent variable.\n+      Node rhs = parent.getLastChild();\n+      if (rhs != null) {\n+        // Record a new assigned name if a value is provided.\n+        data.get(t.getScopeRoot()).recordAssignedName(node.getString());\n+      }\n+      return;\n+    } else {\n+      // Handle other forms of variable assignments:\n+      // - All variable assignments shadow the parent variable.\n+      data.get(t.getScopeRoot()).recordMultipleVarDefs(node, parent);\n+    }\n+\n+    if (varSymbol.isDefined()) {\n+      // Ignore all variables that have already been defined.\n+      return;\n+    }\n+\n+    Node varNode = node.getFirstChild();\n+    if (varNode == null) {\n+      // Bail if there's no assigned value.\n+      return;\n+    }\n+\n+    if (varNode.isFunction()) {\n+      // Ignore function declarations.\n+      return;\n+    }\n+\n+    if (t.getScopeDepth() <= 2) {\n+      // Treat variable assignments in function blocks as escaped variables to avoid raising false\n+      // alerts on common idioms like `function foo() { var x = ...; return function() { ... }; }`.\n+      return;\n+    }\n+\n+    data.get(t.getScopeRoot()).recordAssignedName(node.getString());\n+  }\n+\n+  private void createDataForFunctionScope(Node fnNode, Scope parentScope, Node fnRoot) {\n+    checkState(fnNode.isFunction(), \"unexpected variable value: %s\", fnNode);\n+\n+    VarData varData = data.get(fnRoot);\n+    if (varData == null) {\n+      varData = new VarData();\n+      data.put(fnRoot, varData);\n+    }\n+\n+    Scope fnScope = parentScope.getClosestHoistScope().addChildScope(fnNode);\n+    for (Var v : fnScope.getVarIterable()) {\n+      if (v.isLocal()) {\n+        varData.recordShadowedName(v.getName());\n+      }\n+    }\n+  }\n+\n+  private void check(Node fnNode, VarData varData, AbstractCompiler compiler) {\n+    // Check for multiple var defs and shadowed names.\n+    for (VarInfo varInfo : varData.getInheritedVarInfo()) {\n+      if (varData.hasAssignedName(varInfo.name)) {\n+        continue; // Ignore assigned names to skip false positives.\n+      }\n+\n+      String rootName = varInfo.name.contains(\".\") ? varInfo.name.split(\"\\\\.\")[0] : varInfo.name;\n+      Scope.VarSymbol varSymbol = fnNode.getScope().getVarSymbol(rootName);\n+      if (varSymbol == null) {\n+        if (varInfo.type == VarType.ASSIGNED_NON_LOCAL &&\n+            !varData.isEscapedVarName(varInfo.name)) {\n+          // If the variable is assigned in a nested scope and never escapes that scope,\n+          // we consider it intentional and don't report a warning.\n+          continue;\n         }\n-      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n-          NodeUtil.isLValue(n)) {\n-        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode())\n-                .recordEscapedQualifiedName(n.getQualifiedName());\n-          }\n+\n+        String msg = varInfo.type == VarType.MULTIPLE_DEF\n+            ? MULTIPLE_VAR_DEF.format(varInfo.name)\n+            : \"Variable '\" + varInfo.name + \"' is shadowed by another variable.\";\n+        compiler.report(JSError.make(fnNode, MULTIPLE_VAR_DEF));\n+      } else if (varInfo.type == VarType.ASSIGNED_NON_LOCAL) {\n+        // Check that variables assigned in block scopes are not redeclared.\n+        Var var = varSymbol.getScope().getVar(varInfo.name);\n+        if (var != null && !var.isArguments()) {\n+          compiler.report(JSError.make(fnNode, MULTIPLE_VAR_DEF));\n+        }\n+      }\n+    }\n+\n+    // Note: the preferred way to pass information out of the traverse() methods is to mutate\n+    // instance variables like `data`.\n+  }\n+\n+  private enum VarType {\n+    MULTIPLY_DECLARED, // Var declared multiple times in this scope.\n+    DECLARED_NON_LOCAL, // Var defined in enclosing scope but used in this scope.\n+    ASSIGNED_NON_LOCAL, // Like `DECLARED_NON_LOCAL`, but var is also assigned in this scope.\n+  }\n+\n+  private static class VarInfo {\n+    final String name;\n+    final VarType type;\n+\n+    VarInfo(String name, VarType type) {\n+      this.name = name;\n+      this.type = type;\n+    }\n+  }\n+\n+  private static class VarData {\n+\n+    /** Variables defined or assigned in this scope or nested scopes. */\n+    private final Set<String> assignedNames = new HashSet<>();\n+\n+    /** Shadowed variables defined in enclosing scopes. */\n+    private final Set<String> shadowedNames = new HashSet<>();\n+\n+    /** Names of variables that \"escape\" this scope (reassigned or accessed in lower scopes). */\n+    private final Set<String> escapedVarNames = new HashSet<>();\n+\n+    /** Properties of variables that \"escape\" this scope (reassigned or accessed in lower scopes). */\n+    private final Set<String> escapedQualifiedNames = new HashSet<>();\n+\n+    private final Set<String> allFunctionNames = new HashSet<>();\n+\n+    void recordAssignedName(String name) {\n+      assignedNames.add(name);\n+    }\n+\n+    void recordMultipleVarDefs(Node nameNode, Node parentNode) {\n+      for (Node next = nameNode.getNext(); next != null; next = next.getNext()) {\n+        if (next.isName() && next.getString().equals(nameNode.getString())) {\n+          JSError error = JSError.make(parentNode, MULTIPLE_VAR_DEF);\n+          throw new RuntimeException(error.toString());\n         }\n       }\n     }\n+\n+    void recordShadowedName(String name) {\n+      // Don't record global variables or already-shadowed variables\n+      if (!escapedVarNames.contains(name) && !allFunctionNames.contains(name) &&\n+          shadowedNames.add(name)) {\n+        // Add the escaped var even in the presence of a shadowed var.\n+        // The analysis will generate an error about the shadowed var.\n+        escapedVarNames.remove(name);\n+        escapedQualifiedNames.removeIf(prop -> prop.startsWith(name));\n+      }\n+    }\n+\n+    void recordEscapedVarName(String name) {\n+      // Don't record shadowed variables\n+      if (!shadowedNames.contains(name)) {\n+        escapedVarNames.add(name);\n+      }\n+    }\n+\n+    void recordEscapedQualifiedName(String qualifiedName) {\n+      escapedQualifiedNames.add(qualifiedName);\n+    }\n+\n+    void recordFunctionName(String name) {\n+      allFunctionNames.add(name);\n+    }\n+\n+    boolean containsFunctionWithName(String name) {\n+      return allFunctionNames.contains(name);\n+    }\n+\n+    boolean hasAssignedName(String name) {\n+      return assignedNames.contains(name);\n+    }\n+\n+    boolean isEscapedVarName(String name) {\n+      return escapedVarNames.contains(name);\n+    }\n+\n+    Iterable<VarInfo> getInheritedVarInfo() {\n+      Iterable<Scope.VarSymbol> vars = Iterables.concat(\n+          asList(Scope.VarSymbol.values()), asList(Scope.VarSymbol.NUMBER_SPECIAL_VALUES),\n+          singleton(allFunctionNames));\n+      return () -> vars.iterator()\n+          .flatMap(varSymbol -> varSymbol.getIterableScope())\n+          .map(Var::getNameNode)\n+          .filter(node -> node != null && node.isName())\n+          .map(Node::getString)\n+          .filter(name -> !allFunctionNames.contains(name))\n+          .map(name -> new VarInfo(name, getVarType(name)))\n+          .iterator();\n+    }\n+\n+    private VarType getVarType(String name) {\n+      if (assignedNames.contains(name)) {\n+        // If a non-local var is assigned within this scope or a lower scope,\n+        // we error out when we encounter the varInfo during the post-order walk.\n+        return shado\n   }\n \n   private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}