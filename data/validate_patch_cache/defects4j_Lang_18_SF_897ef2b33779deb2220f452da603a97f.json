{
    "patch": "public class SimpleDateFormat {\n    private String mPattern;\n    private Locale mLocale = Locale.getDefault();\n\n    public SimpleDateFormat() {\n        this(\"M/d/yy h:mm a\");\n    }\n\n    public SimpleDateFormat(String pattern) {\n        mPattern = pattern;\n    }\n\n    public String format(Date date) {\n        Calendar cal = Calendar.getInstance();\n        cal.setTime(date);\n        return format(cal);\n    }\n\n    public synchronized StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n        if (obj instanceof Date) {\n            String result = format((Date) obj);\n            toAppendTo.append(result);\n            return toAppendTo;\n        }\n        throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\n    }\n\n    public AttributedCharacterIterator formatToCharacterIterator(Object obj) {\n        throw new UnsupportedOperationException();\n    }\n\n    public Date parse(String source) throws ParseException {\n        ParsePosition pos = new ParsePosition(0);\n        Date result = parse(source, pos);\n        if (pos.getIndex() == 0) {\n            throw new ParseException(\"Unparseable date: \\\"\" + source + \"\\\"\", pos.getErrorIndex());\n        }\n        return result;\n    }\n\n    public synchronized Object parseObject(String source, ParsePosition pos) {\n        try {\n            return parse(source, pos);\n        } catch (ParseException e) {\n            return null;\n        }\n    }\n\n    public synchronized Date parse(String source, ParsePosition pos) {\n        try {\n            List<Rule> rules = parsePattern();\n            Calendar cal = Calendar.getInstance();\n            cal.clear();\n\n            int index = pos.getIndex();\n            int len = source.length();\n\n            for (Rule rule : rules) {\n                index = rule.parse(source, index, cal);\n            }\n\n            pos.setIndex(index);\n            return cal.getTime();\n        } catch (IllegalArgumentException e) {\n            pos.setErrorIndex(0);\n            return null;\n        }\n    }\n\n    public String toPattern() {\n        return mPattern;\n    }\n\n    public void applyPattern(String pattern) {\n        mPattern = pattern;\n    }\n\n    public DateFormatSymbols getDateFormatSymbols() {\n        return new DateFormatSymbols(mLocale);\n    }\n\n    public Locale getLocale() {\n        return mLocale;\n    }\n\n    public void setDateFormatSymbols(DateFormatSymbols value) {\n        mLocale = Locale.getDefault();\n    }\n\n    public void setLocale(Locale value) {\n        mLocale = value;\n    }\n\n    protected List<Rule> parsePattern() {\n        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n        List<Rule> rules = new ArrayList",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e0433239..fd12519f 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -460,129 +460,103 @@ public class FastDateFormat extends Format {\n      * @return a {@code List} of Rule objects\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    protected List<Rule> parsePattern() {\n-        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n-        List<Rule> rules = new ArrayList<Rule>();\n-\n-        String[] ERAs = symbols.getEras();\n-        String[] months = symbols.getMonths();\n-        String[] shortMonths = symbols.getShortMonths();\n-        String[] weekdays = symbols.getWeekdays();\n-        String[] shortWeekdays = symbols.getShortWeekdays();\n-        String[] AmPmStrings = symbols.getAmPmStrings();\n-\n-        int length = mPattern.length();\n-        int[] indexRef = new int[1];\n-\n-        for (int i = 0; i < length; i++) {\n-            indexRef[0] = i;\n-            String token = parseToken(mPattern, indexRef);\n-            i = indexRef[0];\n-\n-            int tokenLen = token.length();\n-            if (tokenLen == 0) {\n-                break;\n-            }\n+public class SimpleDateFormat {\n+    private String mPattern;\n+    private Locale mLocale = Locale.getDefault();\n \n-            Rule rule;\n-            char c = token.charAt(0);\n+    public SimpleDateFormat() {\n+        this(\"M/d/yy h:mm a\");\n+    }\n \n-            switch (c) {\n-            case 'G': // era designator (text)\n-                rule = new TextField(Calendar.ERA, ERAs);\n-                break;\n-            case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n-                }\n-                break;\n-            case 'M': // month in year (text and number)\n-                if (tokenLen >= 4) {\n-                    rule = new TextField(Calendar.MONTH, months);\n-                } else if (tokenLen == 3) {\n-                    rule = new TextField(Calendar.MONTH, shortMonths);\n-                } else if (tokenLen == 2) {\n-                    rule = TwoDigitMonthField.INSTANCE;\n-                } else {\n-                    rule = UnpaddedMonthField.INSTANCE;\n-                }\n-                break;\n-            case 'd': // day in month (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n-                break;\n-            case 'h': // hour in am/pm (number, 1..12)\n-                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n-                break;\n-            case 'H': // hour in day (number, 0..23)\n-                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n-                break;\n-            case 'm': // minute in hour (number)\n-                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n-                break;\n-            case 's': // second in minute (number)\n-                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n-                break;\n-            case 'S': // millisecond (number)\n-                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n-                break;\n-            case 'E': // day in week (text)\n-                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n-                break;\n-            case 'D': // day in year (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n-                break;\n-            case 'F': // day of week in month (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n-                break;\n-            case 'w': // week in year (number)\n-                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n-                break;\n-            case 'W': // week in month (number)\n-                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n-                break;\n-            case 'a': // am/pm marker (text)\n-                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n-                break;\n-            case 'k': // hour in day (1..24)\n-                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n-                break;\n-            case 'K': // hour in am/pm (0..11)\n-                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n-                break;\n-            case 'z': // time zone (text)\n-                if (tokenLen >= 4) {\n-                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n-                } else {\n-                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n-                }\n-                break;\n-            case 'Z': // time zone (value)\n-                if (tokenLen == 1) {\n-                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n-                } else {\n-                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n-                }\n-                break;\n-            case '\\'': // literal text\n-                String sub = token.substring(1);\n-                if (sub.length() == 1) {\n-                    rule = new CharacterLiteral(sub.charAt(0));\n-                } else {\n-                    rule = new StringLiteral(sub);\n-                }\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n+    public SimpleDateFormat(String pattern) {\n+        mPattern = pattern;\n+    }\n+\n+    public String format(Date date) {\n+        Calendar cal = Calendar.getInstance();\n+        cal.setTime(date);\n+        return format(cal);\n+    }\n+\n+    public synchronized StringBuffer format(Object obj, StringBuffer toAppendTo, FieldPosition pos) {\n+        if (obj instanceof Date) {\n+            String result = format((Date) obj);\n+            toAppendTo.append(result);\n+            return toAppendTo;\n+        }\n+        throw new IllegalArgumentException(\"Cannot format given Object as a Date\");\n+    }\n+\n+    public AttributedCharacterIterator formatToCharacterIterator(Object obj) {\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public Date parse(String source) throws ParseException {\n+        ParsePosition pos = new ParsePosition(0);\n+        Date result = parse(source, pos);\n+        if (pos.getIndex() == 0) {\n+            throw new ParseException(\"Unparseable date: \\\"\" + source + \"\\\"\", pos.getErrorIndex());\n+        }\n+        return result;\n+    }\n+\n+    public synchronized Object parseObject(String source, ParsePosition pos) {\n+        try {\n+            return parse(source, pos);\n+        } catch (ParseException e) {\n+            return null;\n+        }\n+    }\n+\n+    public synchronized Date parse(String source, ParsePosition pos) {\n+        try {\n+            List<Rule> rules = parsePattern();\n+            Calendar cal = Calendar.getInstance();\n+            cal.clear();\n+\n+            int index = pos.getIndex();\n+            int len = source.length();\n+\n+            for (Rule rule : rules) {\n+                index = rule.parse(source, index, cal);\n             }\n \n-            rules.add(rule);\n+            pos.setIndex(index);\n+            return cal.getTime();\n+        } catch (IllegalArgumentException e) {\n+            pos.setErrorIndex(0);\n+            return null;\n         }\n+    }\n+\n+    public String toPattern() {\n+        return mPattern;\n+    }\n+\n+    public void applyPattern(String pattern) {\n+        mPattern = pattern;\n+    }\n \n-        return rules;\n+    public DateFormatSymbols getDateFormatSymbols() {\n+        return new DateFormatSymbols(mLocale);\n     }\n \n+    public Locale getLocale() {\n+        return mLocale;\n+    }\n+\n+    public void setDateFormatSymbols(DateFormatSymbols value) {\n+        mLocale = Locale.getDefault();\n+    }\n+\n+    public void setLocale(Locale value) {\n+        mLocale = value;\n+    }\n+\n+    protected List<Rule> parsePattern() {\n+        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n+        List<Rule> rules = new ArrayList\n+\n     /**\n      * <p>Performs the parsing of tokens.</p>\n      *",
    "result_reason": "error: '(' or '[' expected",
    "test_result": "ERROR"
}