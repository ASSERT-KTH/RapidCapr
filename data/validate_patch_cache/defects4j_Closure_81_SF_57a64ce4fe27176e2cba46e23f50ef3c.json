{
    "patch": "private static class TransformDispatcher implements NodeTransformer, TypeSafeDispatcher {\n\n  private static final ImmutableSet<Integer> ALLOWED_DIRECTIVE_TYPES =\n      ImmutableSet.of(Token.LITERAL_INCLUDE, Token.LITERAL_VAR, Token.LITERAL_CONST);\n\n  private static final ImmutableSet<Integer> EXPR_VOID_TYPES =\n      ImmutableSet.of(Token.BLOCK, Token.EXPR_VOID);\n\n  private final AstRoot astRoot;\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n  private final CodingConvention codingConvention;\n  private final SourceMapping sourceMapping;\n  private final RhinoErrorReporter rhinoErrorReporter;\n\n  TransformDispatcher(\n      AstRoot astRoot,\n      ErrorReporter errorReporter,\n      String sourceName,\n      CodingConvention codingConvention,\n      RhinoErrorReporter rhinoErrorReporter) {\n    checkNotNull(astRoot, \"astRoot cannot be null\");\n    checkNotNull(errorReporter, \"errorReporter cannot be null\");\n    checkNotNull(sourceName, \"sourceName cannot be null\");\n    checkNotNull(codingConvention, \"codingConvention cannot be null\");\n    checkNotNull(rhinoErrorReporter, \"rhinoErrorReporter cannot be null\");\n\n    this.astRoot = astRoot;\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n    this.codingConvention = codingConvention;\n    this.sourceMapping = new SourceMapping(sourceName);\n    this.rhinoErrorReporter = rhinoErrorReporter;\n  }\n\n  private SourcePosition getNodePosition(AstNode n) {\n    return sourceMapping.newPosition(\n        n.getLineno(), position2column(n.getAbsolutePosition()), n.getLength());\n  }\n\n  private RhinoErrorReporter.ErrorType toCompilerError(ErrorReporter.MessageType type) {\n    switch (type) {\n      case ERROR:\n      case INTERNAL_ERROR:\n        return RhinoErrorReporter.ErrorType.syntaxError;\n      case WARNING:\n        return RhinoErrorReporter.ErrorType.warning;\n      default:\n        throw new IllegalArgumentException(\"unsupported ErrorMessage type: \" + type);\n    }\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n      n.getFirstChild().getType() == Token.STRING &&\n      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getFirstChild().getType());\n  }\n\n  @Override\n  public Node process(AstNode node) {\n    try {\n      return (Node) node.visit(this);\n    } catch (UnsupportedOperationException ex) {\n      errorReporter.error(\n          convertErrorMessage(ex.getMessage()),\n          sourceName,\n          node.getLineno(),\n          getNodePosition(node));\n      return new Node(Token.EMPTY);\n    }\n  }\n\n  @Override\n  public Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  @Override\n  public Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(),\n          getNodePosition(clauseNode.getCatchCondition()));\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  public Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  public Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n  }\n\n  @Override\n  public Node processElementGet(ElementGet getNode) {\n    return newNode(Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n  }\n\n  @Override\n  public Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  public Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  public Node processForInLoop(ForInLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getIterator()),\n        transform(loopNode.getIteratedObject()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processForLoop(ForLoop loopNode) {\n    Node node =\n        newNode(\n            Token.FOR,\n            transform(loopNode.getInitializer()),\n            transform(loopNode.getCondition()),\n            transform(loopNode.getIncrement()));\n    node.addChildToBack(transformBlock(loopNode.getBody()));\n    return node;\n  }\n\n  @Override\n  public Node processFunctionCall(FunctionCall callNode) {\n    Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget()));\n    for (AstNode child : callNode.getArguments()) {\n      node.addChildToBack(transform(child));\n    }\n\n    int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n    node.setLineno(callNode.getLineno());\n    node.setCharno(position2charno(leftParamPos));\n    return node;\n  }\n\n  @Override\n  public Node processFunctionNode(FunctionNode functionNode) {\n    Name name = functionNode.getFunctionName();\n    boolean isUnnamedFunction = false;\n\n    if (name == null) {\n      name = new Name();\n      name.setIdentifier(\"\");\n      isUnnamedFunction = true;\n    }\n\n    Node node = newNode(Token.FUNCTION);\n    Node newName = transform(name);\n\n    if (isUnnamedFunction) {\n      int fnLineNo = functionNode.getLineno();\n      newName.setLineno(fnLineNo);\n      newName.setCharno(position2charno(functionNode.getRelativeFunctionIndex()));\n    }\n\n    node.addChildToBack(newName);\n    Node lp = newNode(Token.LP);\n\n    // The left paren should be on the same line as the function name.\n    lp.setLineno(newName.getLineno());\n    lp.setCharno(newName.getCharno() + 1);\n\n    for (AstNode param : functionNode.getParams()) {\n      lp.addChildToBack(transform(param));\n    }\n\n    node.addChildToBack(lp);\n\n    Node bodyNode = transform(functionNode.getBody());\n    parseDirectives(bodyNode);\n    node.addChildToBack(bodyNode);\n\n    return node;\n  }\n\n  @Override\n  public Node processInfixExpression(InfixExpression exprNode) {\n    int type = exprNode.getOperator();\n    if (in(type, Token.OR, Token.AND)) {\n      Node node = newNode(type, transform(exprNode.getLeft()), transform(exprNode.getRight()));\n      if (type == Token.OR && isLiteralValue(exprNode.getLeft(), true)) {\n        // The left hand side of an || expression if it is an object or array literal\n        // can be considered a declaration for the rest of the containing block, since\n        // (according to the spec) it will be evaluated every time.  This is important\n        // for flow control analysis of 'use strict' functions.\n        makeDeclaration(exprNode.getLeft(), node);\n      }\n      return node;\n    } else {\n      return newNode(\n          type,\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()),\n          getNodePosition(exprNode));\n    }\n  }\n\n  @Override\n  public Node processKeywordLiteral(KeywordLiteral literalNode) {\n    return newNode(literalNode.getType());\n  }\n\n  @Override\n  public Node processName(Name nameNode) {\n    String name = nameNode.getIdentifier();\n    if (name.equals(\"undefined\")) {\n      return newNode(Token.EMPTY);\n    }\n    if (name.equals(\"NaN\")) {\n      return newNode(Token.NUMBER, Double.toString(Double.NaN));\n    }\n    if (name.equals(\"Infinity\")) {\n      return newNode(Token.NUMBER, Double.toString(Double.POSITIVE_INFINITY));\n    }\n    Scope.Var var = varForName(name);\n    if (var == null || !var.isArguments()) {\n      if (!codingConvention.isExported(name)) {\n        name = codingConvention.applyObfuscate(name);\n      }\n    }\n    return new Node(Token.NAME, Node.newString(name));\n  }\n\n  @Override\n  public Node processNewExpression(NewExpression callNode) {\n    Node node = newNode(Token.NEW, transform(callNode.getTarget()));\n    for (AstNode child : callNode.getArguments()) {\n      node.addChildToBack(transform(child));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processNumber(NumberLiteral numberNode) {\n    return newNode(Token.NUMBER, Node.newString(numberNode.getNumber()));\n  }\n\n  @Override\n  public Node processObjectLiteral(ObjectLiteral objectNode) {\n    Node result = newNode(Token.OBJECTLIT);\n    for (ObjectProperty property : objectNode.getElements()) {\n      AstNode left = property.getLeft();\n      Node newLeft = transform(left);\n      // Normalize GETELEM nodes. e.g. { 1: \"A\" }  -> { \"1\": \"A\" }\n      if (left instanceof ElementGet) {\n        newLeft.setType(Token.STRING);\n      }\n      Node newValue;\n      AstNode right = property.getRight();\n      if (right.getType() == Token.FUNCTION) {\n        FunctionNode functionNode = (FunctionNode) right;\n        functionNode.setFunctionName(ne",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..c6ed3074 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -384,182 +384,309 @@ public class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+private static class TransformDispatcher implements NodeTransformer, TypeSafeDispatcher {\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+  private static final ImmutableSet<Integer> ALLOWED_DIRECTIVE_TYPES =\n+      ImmutableSet.of(Token.LITERAL_INCLUDE, Token.LITERAL_VAR, Token.LITERAL_CONST);\n \n-      int nType = n.getType();\n-      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n-          n.getFirstChild().getType() == Token.STRING &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  private static final ImmutableSet<Integer> EXPR_VOID_TYPES =\n+      ImmutableSet.of(Token.BLOCK, Token.EXPR_VOID);\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+  private final AstRoot astRoot;\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+  private final CodingConvention codingConvention;\n+  private final SourceMapping sourceMapping;\n+  private final RhinoErrorReporter rhinoErrorReporter;\n+\n+  TransformDispatcher(\n+      AstRoot astRoot,\n+      ErrorReporter errorReporter,\n+      String sourceName,\n+      CodingConvention codingConvention,\n+      RhinoErrorReporter rhinoErrorReporter) {\n+    checkNotNull(astRoot, \"astRoot cannot be null\");\n+    checkNotNull(errorReporter, \"errorReporter cannot be null\");\n+    checkNotNull(sourceName, \"sourceName cannot be null\");\n+    checkNotNull(codingConvention, \"codingConvention cannot be null\");\n+    checkNotNull(rhinoErrorReporter, \"rhinoErrorReporter cannot be null\");\n+\n+    this.astRoot = astRoot;\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+    this.codingConvention = codingConvention;\n+    this.sourceMapping = new SourceMapping(sourceName);\n+    this.rhinoErrorReporter = rhinoErrorReporter;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+  private SourcePosition getNodePosition(AstNode n) {\n+    return sourceMapping.newPosition(\n+        n.getLineno(), position2column(n.getAbsolutePosition()), n.getLength());\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  private RhinoErrorReporter.ErrorType toCompilerError(ErrorReporter.MessageType type) {\n+    switch (type) {\n+      case ERROR:\n+      case INTERNAL_ERROR:\n+        return RhinoErrorReporter.ErrorType.syntaxError;\n+      case WARNING:\n+        return RhinoErrorReporter.ErrorType.warning;\n+      default:\n+        throw new IllegalArgumentException(\"unsupported ErrorMessage type: \" + type);\n     }\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    int nType = n.getType();\n+    return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n+      n.getFirstChild().getType() == Token.STRING &&\n+      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getFirstChild().getType());\n+  }\n+\n+  @Override\n+  public Node process(AstNode node) {\n+    try {\n+      return (Node) node.visit(this);\n+    } catch (UnsupportedOperationException ex) {\n+      errorReporter.error(\n+          convertErrorMessage(ex.getMessage()),\n+          sourceName,\n+          node.getLineno(),\n+          getNodePosition(node));\n+      return new Node(Token.EMPTY);\n     }\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  @Override\n+  public Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  @Override\n+  public Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  public Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(),\n+          getNodePosition(clauseNode.getCatchCondition()));\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  public Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  public Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  public Node processElementGet(ElementGet getNode) {\n+    return newNode(Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  public Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processForInLoop(ForInLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getIterator()),\n+        transform(loopNode.getIteratedObject()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processForLoop(ForLoop loopNode) {\n+    Node node =\n+        newNode(\n+            Token.FOR,\n+            transform(loopNode.getInitializer()),\n+            transform(loopNode.getCondition()),\n+            transform(loopNode.getIncrement()));\n+    node.addChildToBack(transformBlock(loopNode.getBody()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processFunctionCall(FunctionCall callNode) {\n+    Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget()));\n+    for (AstNode child : callNode.getArguments()) {\n+      node.addChildToBack(transform(child));\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n+    node.setLineno(callNode.getLineno());\n+    node.setCharno(position2charno(leftParamPos));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processFunctionNode(FunctionNode functionNode) {\n+    Name name = functionNode.getFunctionName();\n+    boolean isUnnamedFunction = false;\n+\n+    if (name == null) {\n+      name = new Name();\n+      name.setIdentifier(\"\");\n+      isUnnamedFunction = true;\n     }\n \n-    @Override\n-    Node processForLoop(ForLoop loopNode) {\n-      Node node = newNode(\n-          Token.FOR,\n-          transform(loopNode.getInitializer()),\n-          transform(loopNode.getCondition()),\n-          transform(loopNode.getIncrement()));\n-      node.addChildToBack(transformBlock(loopNode.getBody()));\n-      return node;\n+    Node node = newNode(Token.FUNCTION);\n+    Node newName = transform(name);\n+\n+    if (isUnnamedFunction) {\n+      int fnLineNo = functionNode.getLineno();\n+      newName.setLineno(fnLineNo);\n+      newName.setCharno(position2charno(functionNode.getRelativeFunctionIndex()));\n     }\n \n-    @Override\n-    Node processFunctionCall(FunctionCall callNode) {\n-      Node node = newNode(transformTokenType(callNode.getType()),\n-                           transform(callNode.getTarget()));\n-      for (AstNode child : callNode.getArguments()) {\n-        node.addChildToBack(transform(child));\n-      }\n+    node.addChildToBack(newName);\n+    Node lp = newNode(Token.LP);\n \n-      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n-      node.setLineno(callNode.getLineno());\n-      node.setCharno(position2charno(leftParamPos));\n-      return node;\n+    // The left paren should be on the same line as the function name.\n+    lp.setLineno(newName.getLineno());\n+    lp.setCharno(newName.getCharno() + 1);\n+\n+    for (AstNode param : functionNode.getParams()) {\n+      lp.addChildToBack(transform(param));\n     }\n \n-    @Override\n-    Node processFunctionNode(FunctionNode functionNode) {\n-      Name name = functionNode.getFunctionName();\n-      Boolean isUnnamedFunction = false;\n-      if (name == null) {\n-        name = new Name();\n-        name.setIdentifier(\"\");\n-        isUnnamedFunction = true;\n-      }\n-      Node node = newNode(Token.FUNCTION);\n-      Node newName = transform(name);\n-      if (isUnnamedFunction) {\n-        // Old Rhino tagged the empty name node with the line number of the\n-        // declaration.\n-        newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() +\n-            functionNode.getLp();\n-        newName.setCharno(position2charno(lpColumn));\n-      }\n+    node.addChildToBack(lp);\n \n-      node.addChildToBack(newName);\n-      Node lp = newNode(Token.LP);\n-      // The left paren's complicated because it's not represented by an\n-      // AstNode, so there's nothing that has the actual line number that it\n-      // appeared on.  We know the paren has to appear on the same line as the\n-      // function name (or else a semicolon will be inserted.)  If there's no\n-      // function name, assume the paren was on the same line as the function.\n-      // TODO(bowdidge): Mark line number of paren correctly.\n-      Name fnName = functionNode.getFunctionName();\n-      if (fnName != null) {\n-        lp.setLineno(fnName.getLineno());\n-      } else {\n-        lp.setLineno(functionNode.getLineno());\n+    Node bodyNode = transform(functionNode.getBody());\n+    parseDirectives(bodyNode);\n+    node.addChildToBack(bodyNode);\n+\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processInfixExpression(InfixExpression exprNode) {\n+    int type = exprNode.getOperator();\n+    if (in(type, Token.OR, Token.AND)) {\n+      Node node = newNode(type, transform(exprNode.getLeft()), transform(exprNode.getRight()));\n+      if (type == Token.OR && isLiteralValue(exprNode.getLeft(), true)) {\n+        // The left hand side of an || expression if it is an object or array literal\n+        // can be considered a declaration for the rest of the containing block, since\n+        // (according to the spec) it will be evaluated every time.  This is important\n+        // for flow control analysis of 'use strict' functions.\n+        makeDeclaration(exprNode.getLeft(), node);\n       }\n-      int lparenCharno = functionNode.getLp() +\n-          functionNode.getAbsolutePosition();\n+      return node;\n+    } else {\n+      return newNode(\n+          type,\n+          transform(exprNode.getLeft()),\n+          transform(exprNode.getRight()),\n+          getNodePosition(exprNode));\n+    }\n+  }\n \n-      lp.setCharno(position2charno(lparenCharno));\n-      for (AstNode param : functionNode.getParams()) {\n-        lp.addChildToBack(transform(param));\n+  @Override\n+  public Node processKeywordLiteral(KeywordLiteral literalNode) {\n+    return newNode(literalNode.getType());\n+  }\n+\n+  @Override\n+  public Node processName(Name nameNode) {\n+    String name = nameNode.getIdentifier();\n+    if (name.equals(\"undefined\")) {\n+      return newNode(Token.EMPTY);\n+    }\n+    if (name.equals(\"NaN\")) {\n+      return newNode(Token.NUMBER, Double.toString(Double.NaN));\n+    }\n+    if (name.equals(\"Infinity\")) {\n+      return newNode(Token.NUMBER, Double.toString(Double.POSITIVE_INFINITY));\n+    }\n+    Scope.Var var = varForName(name);\n+    if (var == null || !var.isArguments()) {\n+      if (!codingConvention.isExported(name)) {\n+        name = codingConvention.applyObfuscate(name);\n       }\n-      node.addChildToBack(lp);\n+    }\n+    return new Node(Token.NAME, Node.newString(name));\n+  }\n \n-      Node bodyNode = transform(functionNode.getBody());\n-      parseDirectives(bodyNode);\n-      node.addChildToBack(bodyNode);\n-     return node;\n+  @Override\n+  public Node processNewExpression(NewExpression callNode) {\n+    Node node = newNode(Token.NEW, transform(callNode.getTarget()));\n+    for (AstNode child : callNode.getArguments()) {\n+      node.addChildToBack(transform(child));\n     }\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processNumber(NumberLiteral numberNode) {\n+    return newNode(Token.NUMBER, Node.newString(numberNode.getNumber()));\n+  }\n+\n+  @Override\n+  public Node processObjectLiteral(ObjectLiteral objectNode) {\n+    Node result = newNode(Token.OBJECTLIT);\n+    for (ObjectProperty property : objectNode.getElements()) {\n+      AstNode left = property.getLeft();\n+      Node newLeft = transform(left);\n+      // Normalize GETELEM nodes. e.g. { 1: \"A\" }  -> { \"1\": \"A\" }\n+      if (left instanceof ElementGet) {\n+        newLeft.setType(Token.STRING);\n+      }\n+      Node newValue;\n+      AstNode right = property.getRight();\n+      if (right.getType() == Token.FUNCTION) {\n+        FunctionNode functionNode = (FunctionNode) right;\n+        functionNode.setFunctionName(ne\n \n     @Override\n     Node processIfStatement(IfStatement statementNode) {",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}