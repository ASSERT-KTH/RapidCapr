{
    "patch": "default:\n  // If we're given an outputCharsetEncoder, then check if the character can be\n  // represented in this character set.\n  if (outputCharsetEncoder != null) {\n    if (outputCharsetEncoder.canEncode(c)) {\n      sb.append(c);\n    } else {\n      // Unicode-escape the character.\n      appendHexJavaScriptRepresentation(sb, c);\n    }\n  } else {\n    // No charsetEncoder provided - pass straight printable ascii characters through,\n    // escape newline and tab, and escape any non-printable ascii as hex escape sequence\n    if (c >= 32 && c <= 126) {     // printable ascii\n      sb.append(c);\n    } else if (c == '\\n') {\n      sb.append(\"\\\\n\");\n    } else if (c == '\\t') {\n      sb.append(\"\\\\t\");\n    } else if (c > 0 && c <= 31 || c == 127) {  // non-printable ascii\n      appendHexJavaScriptRepresentation(sb, c);\n    } else {  // no",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..620c2599 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -985,77 +985,28 @@ class CodeGenerator {\n   }\n \n   /** Helper to escape javascript string as well as regular expression */\n-  static String strEscape(String s, char quote,\n-                          String doublequoteEscape,\n-                          String singlequoteEscape,\n-                          String backslashEscape,\n-                          CharsetEncoder outputCharsetEncoder) {\n-    StringBuilder sb = new StringBuilder(s.length() + 2);\n-    sb.append(quote);\n-    for (int i = 0; i < s.length(); i++) {\n-      char c = s.charAt(i);\n-      switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n-        case '\\n': sb.append(\"\\\\n\"); break;\n-        case '\\r': sb.append(\"\\\\r\"); break;\n-        case '\\t': sb.append(\"\\\\t\"); break;\n-        case '\\\\': sb.append(backslashEscape); break;\n-        case '\\\"': sb.append(doublequoteEscape); break;\n-        case '\\'': sb.append(singlequoteEscape); break;\n-        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n-          if (i >= 2 &&\n-              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n-               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n-            sb.append(\"\\\\>\");\n-          } else {\n-            sb.append(c);\n-          }\n-          break;\n-        case '<':\n-          // Break </script into <\\/script\n-          final String END_SCRIPT = \"/script\";\n-\n-          // Break <!-- into <\\!--\n-          final String START_COMMENT = \"!--\";\n-\n-          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n-                              END_SCRIPT.length())) {\n-            sb.append(\"<\\\\\");\n-          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n-                                     START_COMMENT.length())) {\n-            sb.append(\"<\\\\\");\n-          } else {\n-            sb.append(c);\n-          }\n-          break;\n-        default:\n-          // If we're given an outputCharsetEncoder, then check if the\n-          //  character can be represented in this character set.\n-          if (outputCharsetEncoder != null) {\n-            if (outputCharsetEncoder.canEncode(c)) {\n-              sb.append(c);\n-            } else {\n-              // Unicode-escape the character.\n-              appendHexJavaScriptRepresentation(sb, c);\n-            }\n-          } else {\n-            // No charsetEncoder provided - pass straight latin characters\n-            // through, and escape the rest.  Doing the explicit character\n-            // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n-              sb.append(c);\n-            } else {\n-              // Other characters can be misinterpreted by some js parsers,\n-              // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n-              appendHexJavaScriptRepresentation(sb, c);\n-            }\n-          }\n-      }\n+default:\n+  // If we're given an outputCharsetEncoder, then check if the character can be\n+  // represented in this character set.\n+  if (outputCharsetEncoder != null) {\n+    if (outputCharsetEncoder.canEncode(c)) {\n+      sb.append(c);\n+    } else {\n+      // Unicode-escape the character.\n+      appendHexJavaScriptRepresentation(sb, c);\n     }\n-    sb.append(quote);\n-    return sb.toString();\n-  }\n+  } else {\n+    // No charsetEncoder provided - pass straight printable ascii characters through,\n+    // escape newline and tab, and escape any non-printable ascii as hex escape sequence\n+    if (c >= 32 && c <= 126) {     // printable ascii\n+      sb.append(c);\n+    } else if (c == '\\n') {\n+      sb.append(\"\\\\n\");\n+    } else if (c == '\\t') {\n+      sb.append(\"\\\\t\");\n+    } else if (c > 0 && c <= 31 || c == 127) {  // non-printable ascii\n+      appendHexJavaScriptRepresentation(sb, c);\n+    } else {  // no\n \n   static String identifierEscape(String s) {\n     // First check if escaping is needed at all -- in most cases it isn't.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}