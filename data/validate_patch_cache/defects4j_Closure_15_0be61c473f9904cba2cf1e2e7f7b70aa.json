{
    "patch": "        if (n.isExprResult()) {\n          n = n.getFirstChild();\n        }\n\n        if (n.isAssign() &&\n            !n.getFirstChild().isQualifiedName()) {\n          n = n.getLastChild();\n        }\n\n        if (n.isName()) {\n          Var var = getScope().getVar(n.getString());\n          Scope.VarInfo varInfo = getScope().getVarInfo(var);\n\n          // if the varInfo is null, it means that the variable is declared\n          // somewhere outside of the current scope and we are ignoring\n          // that case\n          if (varInfo != null && !varInfo.isInferred()) {\n            // check if the variable is assigned multiple times in the current\n            // scope, which can happen in case there are multiple assignments\n            // to the variable (e.g. `var x = 0; x = x + 1;`)\n            Node parent = n.getParent();\n            if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == n &&\n                varInfo.getScopeList().size() == 1) {\n              String varName = n.getString();\n              for (Node siblingIter = n.getNext();\n                  siblingIter != null;\n                  siblingIter = siblingIter.getNext()) {\n                if (siblingIter.isName() && siblingIter.getString().equals(varName)) {\n                  return false;\n                }\n              }\n            }\n\n            return true;\n          }\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex a8e92fcc..6982a846 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,6 +99,43 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n+        if (n.isExprResult()) {\n+          n = n.getFirstChild();\n+        }\n+\n+        if (n.isAssign() &&\n+            !n.getFirstChild().isQualifiedName()) {\n+          n = n.getLastChild();\n+        }\n+\n+        if (n.isName()) {\n+          Var var = getScope().getVar(n.getString());\n+          Scope.VarInfo varInfo = getScope().getVarInfo(var);\n+\n+          // if the varInfo is null, it means that the variable is declared\n+          // somewhere outside of the current scope and we are ignoring\n+          // that case\n+          if (varInfo != null && !varInfo.isInferred()) {\n+            // check if the variable is assigned multiple times in the current\n+            // scope, which can happen in case there are multiple assignments\n+            // to the variable (e.g. `var x = 0; x = x + 1;`)\n+            Node parent = n.getParent();\n+            if (NodeUtil.isAssignmentOp(parent) &&\n+                parent.getFirstChild() == n &&\n+                varInfo.getScopeList().size() == 1) {\n+              String varName = n.getString();\n+              for (Node siblingIter = n.getNext();\n+                  siblingIter != null;\n+                  siblingIter = siblingIter.getNext()) {\n+                if (siblingIter.isName() && siblingIter.getString().equals(varName)) {\n+                  return false;\n+                }\n+              }\n+            }\n+\n+            return true;\n+          }\n+        }\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}