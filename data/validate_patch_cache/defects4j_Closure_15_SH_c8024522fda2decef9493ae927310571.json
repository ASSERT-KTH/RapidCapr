{
    "patch": "if (n.isFunction()) {\n   return false; //skip functions, since they don't have side-effects themselves\n}\nPredicate<Node> canBeSideEffected = new Predicate<Node>() {\n   @Override\n   public boolean apply(Node node) {\n       if (NodeUtil.isImmutableValue(node)) {\n           return false;\n       }\n       if (node.isCall() || node.isNew()) {\n           if (NodeUtil.nodeTypeMayHaveSideEffects(node)) {\n               return true;\n           }\n           if (NodeUtil.functionCallHasSideEffects(node)) {\n             return true;\n           }\n           if (NodeUtil.constructorCallHasSideEffects(node)) {\n               return true;\n           }\n       } else {\n           return NodeUtil.mayHaveSideEffects(node, compiler);\n       }\n       return false;\n   }\n };\n FindSideEffectCalls finder = new FindSideEffectCalls(compiler, canBeSideEffected);\n NodeTraversal.traverse(compiler, n, finder);\n return finder.hasFoundSideEffects();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex a8e92fcc..baeb4ebd 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,6 +99,34 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n+if (n.isFunction()) {\n+   return false; //skip functions, since they don't have side-effects themselves\n+}\n+Predicate<Node> canBeSideEffected = new Predicate<Node>() {\n+   @Override\n+   public boolean apply(Node node) {\n+       if (NodeUtil.isImmutableValue(node)) {\n+           return false;\n+       }\n+       if (node.isCall() || node.isNew()) {\n+           if (NodeUtil.nodeTypeMayHaveSideEffects(node)) {\n+               return true;\n+           }\n+           if (NodeUtil.functionCallHasSideEffects(node)) {\n+             return true;\n+           }\n+           if (NodeUtil.constructorCallHasSideEffects(node)) {\n+               return true;\n+           }\n+       } else {\n+           return NodeUtil.mayHaveSideEffects(node, compiler);\n+       }\n+       return false;\n+   }\n+ };\n+ FindSideEffectCalls finder = new FindSideEffectCalls(compiler, canBeSideEffected);\n+ NodeTraversal.traverse(compiler, n, finder);\n+ return finder.hasFoundSideEffects();\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {",
    "result_reason": "error: non-static variable compiler cannot be referenced from a static context",
    "test_result": "ERROR"
}