{
    "patch": "import com.google.javascript.jscomp.*;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\n/**\n * Annotates what names are assigned within a given function, and which\n * escaped. The analysis is first-order: it only tracks names in the scope of the\n * function being analyzed, not in scopes of functions being called. We use this\n * to identify which parameters get assigned values.\n */\npublic class FirstOrderFunctionAnalyzer implements ScopedCallback, HotSwapCompilerPass {\n  private final AbstractCompiler compiler;\n  private final Map<Node, FunctionNames> data = new HashMap<>();\n\n  /**\n   * Data model for first-order analysis of a single function.\n   */\n  private static class FunctionNames {\n    private boolean escaped = false;\n    private boolean hasNonEmptyReturn = false;\n    private final Map<String, Boolean> assignedNames = new HashMap<>();\n    private final Map<String, Boolean> escapedVarNames = new HashMap<>();\n    private final Map<String, Boolean> escapedQualifiedNames = new HashMap<>();\n\n    boolean hasDeclaredName(String name) {\n      return assignedNames.containsKey(name);\n    }\n\n    boolean hasEscapedVar(String name) {\n      return escapedVarNames.containsKey(name);\n    }\n\n    boolean hasAssignedName(String name) {\n      return assignedNames.getOrDefault(name, false);\n    }\n\n    boolean hasEscapedQualifiedName(String name) {\n      return escapedQualifiedNames.getOrDefault(name, false);\n    }\n\n    void recordEscapedVarName(String name) {\n      escapedVarNames.put(name, true);\n      escaped = true;\n    }\n\n    void recordNonEmptyReturn() {\n      hasNonEmptyReturn = true;\n    }\n\n    void recordAssignedName(String name) {\n      assignedNames.put(name, true);\n    }\n\n    void recordEscapedQualifiedName(String name) {\n      escapedQualifiedNames.put(name, true);\n      escaped = true;\n    }\n\n    boolean hasEscaped() { return escaped; }\n    boolean hasNonEmptyReturn() { return hasNonEmptyReturn; }\n  }\n\n  public FirstOrderFunctionAnalyzer(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverseEs6(compiler, root, this);\n  }\n\n  @Override\n  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n    NodeTraversal.traverseEs6(compiler, scriptRoot, this);\n  }\n\n  @Override\n  public void enterScope(NodeTraversal t) {\n    Node root = t.getScopeRoot();\n\n    // Not an IIFE.\n    if (!NodeUtil.isFunctionExpression(root) &&\n        !NodeUtil.isFunctionDeclaration(root)) {\n      return;\n    }\n\n    // Don't bother analyzing certain function patterns.\n    if (NodeUtil.getFnNameNode(root) != null) {\n      return;\n    }\n\n    if (data.containsKey(root)) {\n      return;\n    }\n\n    data.put(root, new FunctionNames());\n  }\n\n  @Override\n  public void exitScope(NodeTraversal t) {\n    Node root = t.getScopeRoot();\n\n    if (!data.containsKey(root)) {\n      return;\n    }\n\n    CompilerInput input = compiler.getInput(root.getInputId());\n    String inputName = input == null ? null : input.getName();\n\n    FunctionNames fn = data.get(root);\n    if (fn.hasEscaped()) {\n      compiler.report(\n          JSError.make(\n              inputName,\n              root,\n              DiagnosticType.WARNING,\n              \"Function parameter or local variable never assigned, \"\n              + \"and never appears in a `return` statement or assigned to a \"\n              + \"property of `this`\"));\n    }\n  }\n\n  @Override public void visit(NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n      return;\n    }\n\n    if (n.isReturn() && n.getFirstChild() != null) {\n      data.get(t.getScopeRoot()).recordNonEmptyReturn();\n    }\n\n    if (t.getScopeDepth() <= 2) {\n      // The first-order function analyzer looks at two types of variables:\n      //\n      // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n      //\n      // 2) Local variables that are assigned more than once.\n      //\n      // We treat all global variables as escaped by default, so there's\n      // no reason to do this extra computation for them.\n      return;\n    }\n\n    if (n.isName() && NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) {\n      String name = n.getString();\n      Scope scope = t.getScope();\n      Var var = scope.getVar(name);\n\n      if (var != null) {\n        Scope ownerScope = var.getScope();\n\n        // Fix the bug: check if the owner scope is the global scope and if the variable is declared\n        // in the function body, in which case it should not be marked as escaped\n        if (ownerScope.isGlobal() && var.getParentNode().isBlockScope()) {\n          return;\n        }\n\n        if (ownerScope.isLocal()) {\n          data.get(ownerScope.getRootNode()).recordAssignedName(name);\n        }\n\n        if (scope != ownerScope && ownerScope.isLocal()) {\n          data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n        }\n      }\n    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n      String name = NodeUtil.getRootOfQualifiedName(n).getString();\n      Scope scope = t.getScope();\n      Var var = scope.getVar(name);\n      if (var != null) {\n        Scope ownerScope = var.getScope();\n        if (scope != ownerScope && ownerScope.isLocal()) {\n          data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\n        }\n      }\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..7adfbfdd 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1983,60 +1983,186 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.put(n, new AstFunctionContents(n));\n       }\n     }\n+import com.google.javascript.jscomp.*;\n \n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (t.inGlobalScope()) {\n-        return;\n-      }\n+import java.util.HashMap;\n+import java.util.Map;\n \n-      if (n.isReturn() && n.getFirstChild() != null) {\n-        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n-      }\n+/**\n+ * Annotates what names are assigned within a given function, and which\n+ * escaped. The analysis is first-order: it only tracks names in the scope of the\n+ * function being analyzed, not in scopes of functions being called. We use this\n+ * to identify which parameters get assigned values.\n+ */\n+public class FirstOrderFunctionAnalyzer implements ScopedCallback, HotSwapCompilerPass {\n+  private final AbstractCompiler compiler;\n+  private final Map<Node, FunctionNames> data = new HashMap<>();\n \n-      if (t.getScopeDepth() <= 2) {\n-        // The first-order function analyzer looks at two types of variables:\n-        //\n-        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n-        //\n-        // 2) Local variables that are assigned more than once.\n-        //\n-        // We treat all global variables as escaped by default, so there's\n-        // no reason to do this extra computation for them.\n-        return;\n-      }\n+  /**\n+   * Data model for first-order analysis of a single function.\n+   */\n+  private static class FunctionNames {\n+    private boolean escaped = false;\n+    private boolean hasNonEmptyReturn = false;\n+    private final Map<String, Boolean> assignedNames = new HashMap<>();\n+    private final Map<String, Boolean> escapedVarNames = new HashMap<>();\n+    private final Map<String, Boolean> escapedQualifiedNames = new HashMap<>();\n+\n+    boolean hasDeclaredName(String name) {\n+      return assignedNames.containsKey(name);\n+    }\n \n-      if (n.isName() && NodeUtil.isLValue(n) &&\n-          // Be careful of bleeding functions, which create variables\n-          // in the inner scope, not the scope where the name appears.\n-          !NodeUtil.isBleedingFunctionName(n)) {\n-        String name = n.getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n-          }\n+    boolean hasEscapedVar(String name) {\n+      return escapedVarNames.containsKey(name);\n+    }\n \n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n-          }\n+    boolean hasAssignedName(String name) {\n+      return assignedNames.getOrDefault(name, false);\n+    }\n+\n+    boolean hasEscapedQualifiedName(String name) {\n+      return escapedQualifiedNames.getOrDefault(name, false);\n+    }\n+\n+    void recordEscapedVarName(String name) {\n+      escapedVarNames.put(name, true);\n+      escaped = true;\n+    }\n+\n+    void recordNonEmptyReturn() {\n+      hasNonEmptyReturn = true;\n+    }\n+\n+    void recordAssignedName(String name) {\n+      assignedNames.put(name, true);\n+    }\n+\n+    void recordEscapedQualifiedName(String name) {\n+      escapedQualifiedNames.put(name, true);\n+      escaped = true;\n+    }\n+\n+    boolean hasEscaped() { return escaped; }\n+    boolean hasNonEmptyReturn() { return hasNonEmptyReturn; }\n+  }\n+\n+  public FirstOrderFunctionAnalyzer(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverseEs6(compiler, root, this);\n+  }\n+\n+  @Override\n+  public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+    NodeTraversal.traverseEs6(compiler, scriptRoot, this);\n+  }\n+\n+  @Override\n+  public void enterScope(NodeTraversal t) {\n+    Node root = t.getScopeRoot();\n+\n+    // Not an IIFE.\n+    if (!NodeUtil.isFunctionExpression(root) &&\n+        !NodeUtil.isFunctionDeclaration(root)) {\n+      return;\n+    }\n+\n+    // Don't bother analyzing certain function patterns.\n+    if (NodeUtil.getFnNameNode(root) != null) {\n+      return;\n+    }\n+\n+    if (data.containsKey(root)) {\n+      return;\n+    }\n+\n+    data.put(root, new FunctionNames());\n+  }\n+\n+  @Override\n+  public void exitScope(NodeTraversal t) {\n+    Node root = t.getScopeRoot();\n+\n+    if (!data.containsKey(root)) {\n+      return;\n+    }\n+\n+    CompilerInput input = compiler.getInput(root.getInputId());\n+    String inputName = input == null ? null : input.getName();\n+\n+    FunctionNames fn = data.get(root);\n+    if (fn.hasEscaped()) {\n+      compiler.report(\n+          JSError.make(\n+              inputName,\n+              root,\n+              DiagnosticType.WARNING,\n+              \"Function parameter or local variable never assigned, \"\n+              + \"and never appears in a `return` statement or assigned to a \"\n+              + \"property of `this`\"));\n+    }\n+  }\n+\n+  @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (t.inGlobalScope()) {\n+      return;\n+    }\n+\n+    if (n.isReturn() && n.getFirstChild() != null) {\n+      data.get(t.getScopeRoot()).recordNonEmptyReturn();\n+    }\n+\n+    if (t.getScopeDepth() <= 2) {\n+      // The first-order function analyzer looks at two types of variables:\n+      //\n+      // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n+      //\n+      // 2) Local variables that are assigned more than once.\n+      //\n+      // We treat all global variables as escaped by default, so there's\n+      // no reason to do this extra computation for them.\n+      return;\n+    }\n+\n+    if (n.isName() && NodeUtil.isLValue(n) && !NodeUtil.isBleedingFunctionName(n)) {\n+      String name = n.getString();\n+      Scope scope = t.getScope();\n+      Var var = scope.getVar(name);\n+\n+      if (var != null) {\n+        Scope ownerScope = var.getScope();\n+\n+        // Fix the bug: check if the owner scope is the global scope and if the variable is declared\n+        // in the function body, in which case it should not be marked as escaped\n+        if (ownerScope.isGlobal() && var.getParentNode().isBlockScope()) {\n+          return;\n         }\n-      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n-          NodeUtil.isLValue(n)) {\n-        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode())\n-                .recordEscapedQualifiedName(n.getQualifiedName());\n-          }\n+\n+        if (ownerScope.isLocal()) {\n+          data.get(ownerScope.getRootNode()).recordAssignedName(name);\n+        }\n+\n+        if (scope != ownerScope && ownerScope.isLocal()) {\n+          data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n+        }\n+      }\n+    } else if (n.isGetProp() && n.isUnscopedQualifiedName() && NodeUtil.isLValue(n)) {\n+      String name = NodeUtil.getRootOfQualifiedName(n).getString();\n+      Scope scope = t.getScope();\n+      Var var = scope.getVar(name);\n+      if (var != null) {\n+        Scope ownerScope = var.getScope();\n+        if (scope != ownerScope && ownerScope.isLocal()) {\n+          data.get(ownerScope.getRootNode()).recordEscapedQualifiedName(n.getQualifiedName());\n         }\n       }\n     }\n   }\n+}\n+  }\n \n   private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {\n     if (n == null) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}