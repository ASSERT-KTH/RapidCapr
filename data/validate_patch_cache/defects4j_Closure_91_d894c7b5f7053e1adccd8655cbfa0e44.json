{
    "patch": "      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.OBJECTLIT:\n            Node objectLhs = parent.getParent();\n            Node maybeCallNode = parent.getFirstChild();\n            boolean isFunctionCall = false;\n\n            // Check if the property value is a function call\n            if (maybeCallNode.getType() == Token.CALL) {\n              isFunctionCall = true;\n            } else if (maybeCallNode.getType() == Token.NAME) {\n              Var var = t.getScope().getVar(maybeCallNode.getString());\n              if (var != null && var.getInitialValue() != null &&\n                  var.getInitialValue().getType() == Token.CALL) {\n                isFunctionCall = true;\n              }\n            }\n            if (isFunctionCall) {\n              JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(parent);\n              if (jsdoc != null && jsdoc.hasDeclaredType() && jsdoc.getDeclaredType().isGeneric()) {\n                return false;\n              }\n              if (NodeUtil.isPrototypeAssignment(objectLhs)) {\n                return false;\n              }\n            }\n            break;\n          case Token.GETPROP:\n            // Don't traverse getters/setters. They will be traversed automatically\n            // through the GETPROP node.\n            Node maybeFunc = parent.getNext();\n            if (maybeFunc != null && maybeFunc.getType() == Token.FUNCTION) {\n              return false;\n            }\n            break;\n          default:\n            // Don't traverse children of other nodes.\n            return false;\n        }\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..c74da1dc 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,46 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      if (parent != null) {\n+        switch (parent.getType()) {\n+          case Token.OBJECTLIT:\n+            Node objectLhs = parent.getParent();\n+            Node maybeCallNode = parent.getFirstChild();\n+            boolean isFunctionCall = false;\n+\n+            // Check if the property value is a function call\n+            if (maybeCallNode.getType() == Token.CALL) {\n+              isFunctionCall = true;\n+            } else if (maybeCallNode.getType() == Token.NAME) {\n+              Var var = t.getScope().getVar(maybeCallNode.getString());\n+              if (var != null && var.getInitialValue() != null &&\n+                  var.getInitialValue().getType() == Token.CALL) {\n+                isFunctionCall = true;\n+              }\n+            }\n+            if (isFunctionCall) {\n+              JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(parent);\n+              if (jsdoc != null && jsdoc.hasDeclaredType() && jsdoc.getDeclaredType().isGeneric()) {\n+                return false;\n+              }\n+              if (NodeUtil.isPrototypeAssignment(objectLhs)) {\n+                return false;\n+              }\n+            }\n+            break;\n+          case Token.GETPROP:\n+            // Don't traverse getters/setters. They will be traversed automatically\n+            // through the GETPROP node.\n+            Node maybeFunc = parent.getNext();\n+            if (maybeFunc != null && maybeFunc.getType() == Token.FUNCTION) {\n+              return false;\n+            }\n+            break;\n+          default:\n+            // Don't traverse children of other nodes.\n+            return false;\n+        }\n+      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}