{
    "patch": "  private JSType getLeastCommonSubtypeHelper(JSType that) {\n    checkNotNull(that);\n    if (this.equals(that)) {\n      return this;\n    }\n    if (this instanceof UnknownType || that instanceof UnknownType) {\n      return UNKNOWN;\n    }\n    if (this instanceof NoType || that instanceof NoType) {\n      return getNativeType(JSTypeNative.NO_TYPE);\n    }\n    if (this == BOTTOM) {\n      return that;\n    }\n    if (that == BOTTOM) {\n      return this;\n    }\n    if (this instanceof UnionType) {\n      return ((UnionType) this).getLeastCommonSubtypeHelperWithUnionType(that);\n    } else if (that instanceof UnionType) {\n      return ((UnionType) that).getLeastCommonSubtypeHelperWithUnionType(this);\n    } else if (this.isNumber() && that.isNumber()) {\n      return getNativeType(JSTypeNative.NUMBER_TYPE);\n    } else if (this.isBoolean() && that.isBoolean()) {\n      return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n    } else if (this.isString() && that.isString()) {\n      return getNativeType(JSTypeNative.STRING_TYPE);\n    } else if (this.isStructuralInterface() || that.isStructuralInterface()\n        || this.isStruct() || that.isStruct()) {\n      return getNativeType(JSTypeNative.OBJECT_TYPE);\n    } else if (this.isEnumElementType() && that.isEnumElementType()\n        && this.equals(that.getEnumeratedTypeOfEnumElement())\n        && that.equals(this.getEnumeratedTypeOfEnumElement())) {\n      return this;\n    }\n    // We're supposed to only be called if there's a common subtype, but this can happen\n    return getNativeType(JSTypeNative.OBJECT_TYPE);\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex a9c9a0ae..dfccecd0 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -288,7 +288,44 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+  private JSType getLeastCommonSubtypeHelper(JSType that) {\n+    checkNotNull(that);\n+    if (this.equals(that)) {\n+      return this;\n+    }\n+    if (this instanceof UnknownType || that instanceof UnknownType) {\n+      return UNKNOWN;\n+    }\n+    if (this instanceof NoType || that instanceof NoType) {\n+      return getNativeType(JSTypeNative.NO_TYPE);\n+    }\n+    if (this == BOTTOM) {\n+      return that;\n+    }\n+    if (that == BOTTOM) {\n+      return this;\n+    }\n+    if (this instanceof UnionType) {\n+      return ((UnionType) this).getLeastCommonSubtypeHelperWithUnionType(that);\n+    } else if (that instanceof UnionType) {\n+      return ((UnionType) that).getLeastCommonSubtypeHelperWithUnionType(this);\n+    } else if (this.isNumber() && that.isNumber()) {\n+      return getNativeType(JSTypeNative.NUMBER_TYPE);\n+    } else if (this.isBoolean() && that.isBoolean()) {\n+      return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n+    } else if (this.isString() && that.isString()) {\n+      return getNativeType(JSTypeNative.STRING_TYPE);\n+    } else if (this.isStructuralInterface() || that.isStructuralInterface()\n+        || this.isStruct() || that.isStruct()) {\n+      return getNativeType(JSTypeNative.OBJECT_TYPE);\n+    } else if (this.isEnumElementType() && that.isEnumElementType()\n+        && this.equals(that.getEnumeratedTypeOfEnumElement())\n+        && that.equals(this.getEnumeratedTypeOfEnumElement())) {\n+      return this;\n+    }\n+    // We're supposed to only be called if there's a common subtype, but this can happen\n+    return getNativeType(JSTypeNative.OBJECT_TYPE);\n+  }\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}