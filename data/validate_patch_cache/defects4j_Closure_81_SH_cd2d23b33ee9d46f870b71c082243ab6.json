{
    "patch": "    @Override\n    Node processWhileLoop(WhileLoop loopNode) {\n      return newNode(\n          Token.WHILE,\n          transform(loopNode.getCondition()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    Node processWithStatement(WithStatement node) {\n      errorReporter.warning(\n          \"With statements are not supported\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n      return transform(node.getStatements());\n    }\n\n    private Node transformVariableDefinition(VariableDeclaration decl) {\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer child : decl) {\n        if (child.getTarget() instanceof Name) {\n          Node target = transform(child.getTarget());\n          target.putProp(Node.IS_NAMESPACE, \"true\");\n          Node value = null;\n          if (child.getInitializer() != null) {\n            value = transform(child.getInitializer());\n          } else {\n            value = newNode(Token.NAME);\n            value.setString(\"\");\n          }\n          node.addChildToBack(newNode(Token.NAME, target, value));\n        }\n      }\n      return node;\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..895051cb 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,6 +514,42 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+    @Override\n+    Node processWhileLoop(WhileLoop loopNode) {\n+      return newNode(\n+          Token.WHILE,\n+          transform(loopNode.getCondition()),\n+          transformBlock(loopNode.getBody()));\n+    }\n+\n+    @Override\n+    Node processWithStatement(WithStatement node) {\n+      errorReporter.warning(\n+          \"With statements are not supported\",\n+          sourceName,\n+          node.getLineno(), \"\", 0);\n+      return transform(node.getStatements());\n+    }\n+\n+    private Node transformVariableDefinition(VariableDeclaration decl) {\n+      Node node = newNode(Token.VAR);\n+      for (VariableInitializer child : decl) {\n+        if (child.getTarget() instanceof Name) {\n+          Node target = transform(child.getTarget());\n+          target.putProp(Node.IS_NAMESPACE, \"true\");\n+          Node value = null;\n+          if (child.getInitializer() != null) {\n+            value = transform(child.getInitializer());\n+          } else {\n+            value = newNode(Token.NAME);\n+            value.setString(\"\");\n+          }\n+          node.addChildToBack(newNode(Token.NAME, target, value));\n+        }\n+      }\n+      return node;\n+    }\n+  }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}