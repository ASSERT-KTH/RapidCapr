{
    "patch": "public class IRFactory extends Decompiler {\n\n  private ErrorReporter errorReporter;\n  private String sourceName;\n  private static final Set<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\", \"use asm\", \"use strict asm\");\n\n  public IRFactory(DecompilerContext context) {\n    super(context);\n    errorReporter = DefaultErrorReporter.forContext(context);\n    sourceName = context.getInputName();\n  }\n\n  public Node transform(AstNode parse) {\n    TransformDispatcher transformDispatcher = new TransformDispatcher();\n    return transformDispatcher.transform(parse);\n  }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n        n.getFirstChild().isString() &&\n        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  @Override\n  Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  @Override\n  Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  @Override\n  Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  @Override\n  Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  Node processForInLoop(ForInLoop loopNode) {\n    AstNode iterator = loopNode.getIterator();\n    AstNode iteratedObject = loopNode.getIteratedObject();\n    if (iterator.getType() != Token.LET && iterator.getType() != Token.VAR) {\n      errorReporter.error(\n          \"for..in loops must have a loop variable\",\n          sourceName,\n          loopNode.getLineno(), \"\", 0);\n    }\n\n    Node loopNodeBlock = transformBlock(loopNode.getBody());\n\n    // The for..in AST returns an EXPRESSION node, so this makes sure there is a FOR.\n    Node forNode = newNode(Token.FOR);\n\n    // The first child is either the loop variable identifier or the initializer, if the\n    // for..in optional initializer is used.\n    Node firstChild = null;\n    if (iterator instanceof VariableDeclaration) {\n      AstNode varName = ((VariableDeclaration) iterator).getFirstChild();\n      firstChild = newNode(Token.VAR, transform(varName));\n    } else {\n      firstChild = transform(iterator);\n    }\n    forNode.addChildToBack(firstChild);\n\n    // The second child is the object to be looped over.\n    forNode.addChildToBack(transform(iteratedObject));\n\n    // The loop block is added last.\n    forNode.addChildToBack(loopNodeBlock);\n\n    return forNode;\n  }\n\n  @Override\n  Node processForLoop(ForLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getInitializer()),\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  Node processFunction(FunctionNode functionNode) {\n    ImmutableList.Builder<Node> parameters = ImmutableList.builder();\n    Parameter[] params = functionNode.getParams();\n    for (Parameter param : params) {\n      parameters.add(transform(param));\n    }\n\n    Node functionBody = transform(functionNode.getBody());\n\n    Node functionNodeNew;\n\n    if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n      functionNodeNew = newNode(Token.FUNCTION, functionNode.getFunctionName());\n    } else {\n      Node functionName = newString(functionNode.getName());\n      functionName.setType(Token.NAME);\n      functionNodeNew = newNode(Token.FUNCTION, functionName);\n    }\n\n    if (functionNode.getLineno() >= 0) {\n      functionNodeNew.setLineno(functionNode.getLineno());\n    }\n\n    functionNodeNew.putProp(Node.FUNCTION_ARGUMENTS_PROP, parameters.build());\n\n    if (functionNode.isExpressionClosure()) {\n      functionNodeNew.putBooleanProp(Node.EXPRESSION_CLOSURE_FLAG, true);\n    }\n\n    if (functionNode.isArrowFunction()) {\n      functionNodeNew.putBooleanProp(Node.ARROW_FN, true);\n    }\n\n    if (functionNode.isGenerator()) {\n      functionNodeNew.putBooleanProp(Node.GENERATOR_FN, true);\n    }\n\n    if (functionNode.isAsync()) {\n      functionNodeNew.putBooleanProp(Node.ASYNC_FN, true);\n    }\n\n    functionNodeNew.addChildToBack(functionBody);\n\n    return functionNodeNew;\n  }\n\n  @Override\n  Node processIfStatement(IfStatement ifNode) {\n    Node conditionNode = transform(ifNode.getCondition());\n\n    Node ifBlock = transformBlock(ifNode.getThenPart());\n\n    Node elseBlock = null;\n    if (ifNode.getElsePart() != null) {\n      elseBlock = transformBlock(ifNode.getElsePart());\n    }\n\n    return newNode(Token.IF, conditionNode, ifBlock, elseBlock);\n  }\n\n  private class TransformDispatcher implements TypeSafeDispatcher {\n\n    @Override\n    public Node processArrayComprehension(ArrayComprehension node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processArrayLiteral(ArrayLiteral node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processAstRoot(AstRoot node) {\n      Node program = newNode(Token.SCRIPT);\n      program.setStaticSourceFile(sourceName);\n\n      for (AstNode child : node) {\n        program.addChildToBack(transform(child));\n      }\n\n      return program;\n    }\n\n    @Override\n    public Node processAssignment(Assignment node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processBlock(Block node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processBlockStatement(BlockStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processBreakStatement(BreakStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processCaseClause(CaseClause node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processCatchClause(CatchClause node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processComment(Comment node) {\n      return newNode(Token.EMPTY);\n    }\n\n    @Override\n    public Node processCondExpr(ConditionalExpression node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processContinueStatement(ContinueStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processDataProperty(DataProperty node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processDebuggerStatement(DebuggerStatement node) {\n      return newNode(Token.DEBUGGER);\n    }\n\n    @Override\n    public Node processDefaultXmlNamespace(DefaultXmlNamespace node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processDoLoop(DoLoop node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processElementGet(ElementGet node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processEmptyExpression(EmptyExpression node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processEmptyStatement(EmptyStatement node) {\n      return newNode(Token.EMPTY);\n    }\n\n    @Override\n    public Node processExpressionStatement(ExpressionStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processForInLoop(ForInLoop node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processForLoop(ForLoop node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processFunctionCall(FunctionCall node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processFunctionNode(FunctionNode node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processGeneratorExpression(GeneratorExpression node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processGetProp(GetPropNode node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processIfStatement(IfStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processInfixExpression(InfixExpression node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processKeywordLiteral(KeywordLiteral node) {\n      return newNode(transformTokenType(node.getType()));\n    }\n\n    @Override\n    public Node processLabel(Label node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processLabeledStatement(LabeledStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processLetNode(LetNode node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processLetStatement(LetStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processName(Name node) {\n      return newString(node.getIdentifier());\n    }\n\n    @Override\n    public Node processNewExpression(NewExpression node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processNumber(NumberLiteral node) {\n      Node n = newNode(Token.NUMBER);\n      n.setDouble(node.getNumber());\n      return n;\n    }\n\n    @Override\n    public Node processObjectLiteral(ObjectLiteral node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processObjectProperty(ObjectProperty node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processParenthesizedExpression(ParenthesizedExpression node) {\n      return newNode(Token.LP, transform(node.getExpression()), Token.RP);\n    }\n\n    @Override\n    public Node processPropertyGet(PropertyGet node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processRegExp(RawSyntax node, int position) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processReturnStatement(ReturnStatement node) {\n      Node n = newNode(Token.RETURN);\n      if (node.getReturnValue() != null) {\n        n.addChildToBack(transform(node.getReturnValue()));\n      }\n      return n;\n    }\n\n    @Override\n    public Node processScript(ScriptNode node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processString(StringLiteral node) {\n      return newString(node.getValue());\n    }\n\n    @Override\n    public Node processSwitchCase(SwitchCase node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processSwitchStatement(SwitchStatement node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processThrowStatement(ThrowStatement node) {\n      return newNode(Token.THROW, transform(node.getExpression()));\n    }\n\n    @Override\n    public Node processTryCatchFinally(TryCatchFinally node) {\n      throw new UnsupportedOperationException();\n    }\n\n    @Override\n    public Node processUnary(UnaryExpression node) {\n      return newNode(\n          transformTokenType(node.getType()), transform(node.getChild()));\n    }\n\n    @Override\n    public Node processVariableDeclaration(VariableDeclaration node) {\n      Node declNode;\n      if (node.getType() == Token.CONST) {\n        declNode = newNode(Token.CONST);\n      } else {\n        declNode = newNode(Token.VA",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..bfdaeeca 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -472,108 +472,500 @@ class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+public class IRFactory extends Decompiler {\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+  private ErrorReporter errorReporter;\n+  private String sourceName;\n+  private static final Set<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\", \"use asm\", \"use strict asm\");\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  public IRFactory(DecompilerContext context) {\n+    super(context);\n+    errorReporter = DefaultErrorReporter.forContext(context);\n+    sourceName = context.getInputName();\n+  }\n+\n+  public Node transform(AstNode parse) {\n+    TransformDispatcher transformDispatcher = new TransformDispatcher();\n+    return transformDispatcher.transform(parse);\n+  }\n+\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+        n.getFirstChild().isString() &&\n+        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  @Override\n+  Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  @Override\n+  Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processForInLoop(ForInLoop loopNode) {\n+    AstNode iterator = loopNode.getIterator();\n+    AstNode iteratedObject = loopNode.getIteratedObject();\n+    if (iterator.getType() != Token.LET && iterator.getType() != Token.VAR) {\n+      errorReporter.error(\n+          \"for..in loops must have a loop variable\",\n+          sourceName,\n+          loopNode.getLineno(), \"\", 0);\n     }\n \n+    Node loopNodeBlock = transformBlock(loopNode.getBody());\n+\n+    // The for..in AST returns an EXPRESSION node, so this makes sure there is a FOR.\n+    Node forNode = newNode(Token.FOR);\n+\n+    // The first child is either the loop variable identifier or the initializer, if the\n+    // for..in optional initializer is used.\n+    Node firstChild = null;\n+    if (iterator instanceof VariableDeclaration) {\n+      AstNode varName = ((VariableDeclaration) iterator).getFirstChild();\n+      firstChild = newNode(Token.VAR, transform(varName));\n+    } else {\n+      firstChild = transform(iterator);\n+    }\n+    forNode.addChildToBack(firstChild);\n+\n+    // The second child is the object to be looped over.\n+    forNode.addChildToBack(transform(iteratedObject));\n+\n+    // The loop block is added last.\n+    forNode.addChildToBack(loopNodeBlock);\n+\n+    return forNode;\n+  }\n+\n+  @Override\n+  Node processForLoop(ForLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getInitializer()),\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  Node processFunction(FunctionNode functionNode) {\n+    ImmutableList.Builder<Node> parameters = ImmutableList.builder();\n+    Parameter[] params = functionNode.getParams();\n+    for (Parameter param : params) {\n+      parameters.add(transform(param));\n+    }\n+\n+    Node functionBody = transform(functionNode.getBody());\n+\n+    Node functionNodeNew;\n+\n+    if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n+      functionNodeNew = newNode(Token.FUNCTION, functionNode.getFunctionName());\n+    } else {\n+      Node functionName = newString(functionNode.getName());\n+      functionName.setType(Token.NAME);\n+      functionNodeNew = newNode(Token.FUNCTION, functionName);\n+    }\n+\n+    if (functionNode.getLineno() >= 0) {\n+      functionNodeNew.setLineno(functionNode.getLineno());\n+    }\n+\n+    functionNodeNew.putProp(Node.FUNCTION_ARGUMENTS_PROP, parameters.build());\n+\n+    if (functionNode.isExpressionClosure()) {\n+      functionNodeNew.putBooleanProp(Node.EXPRESSION_CLOSURE_FLAG, true);\n+    }\n+\n+    if (functionNode.isArrowFunction()) {\n+      functionNodeNew.putBooleanProp(Node.ARROW_FN, true);\n+    }\n+\n+    if (functionNode.isGenerator()) {\n+      functionNodeNew.putBooleanProp(Node.GENERATOR_FN, true);\n+    }\n+\n+    if (functionNode.isAsync()) {\n+      functionNodeNew.putBooleanProp(Node.ASYNC_FN, true);\n+    }\n+\n+    functionNodeNew.addChildToBack(functionBody);\n+\n+    return functionNodeNew;\n+  }\n+\n+  @Override\n+  Node processIfStatement(IfStatement ifNode) {\n+    Node conditionNode = transform(ifNode.getCondition());\n+\n+    Node ifBlock = transformBlock(ifNode.getThenPart());\n+\n+    Node elseBlock = null;\n+    if (ifNode.getElsePart() != null) {\n+      elseBlock = transformBlock(ifNode.getElsePart());\n+    }\n+\n+    return newNode(Token.IF, conditionNode, ifBlock, elseBlock);\n+  }\n+\n+  private class TransformDispatcher implements TypeSafeDispatcher {\n+\n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node processArrayComprehension(ArrayComprehension node) {\n+      throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node processArrayLiteral(ArrayLiteral node) {\n+      throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    public Node processAstRoot(AstRoot node) {\n+      Node program = newNode(Token.SCRIPT);\n+      program.setStaticSourceFile(sourceName);\n+\n+      for (AstNode child : node) {\n+        program.addChildToBack(transform(child));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+\n+      return program;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public Node processAssignment(Assignment node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processBlock(Block node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processBlockStatement(BlockStatement node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processBreakStatement(BreakStatement node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processCaseClause(CaseClause node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processCatchClause(CatchClause node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processComment(Comment node) {\n+      return newNode(Token.EMPTY);\n+    }\n+\n+    @Override\n+    public Node processCondExpr(ConditionalExpression node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processContinueStatement(ContinueStatement node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processDataProperty(DataProperty node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processDebuggerStatement(DebuggerStatement node) {\n+      return newNode(Token.DEBUGGER);\n+    }\n+\n+    @Override\n+    public Node processDefaultXmlNamespace(DefaultXmlNamespace node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processDoLoop(DoLoop node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processElementGet(ElementGet node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processEmptyExpression(EmptyExpression node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processEmptyStatement(EmptyStatement node) {\n+      return newNode(Token.EMPTY);\n+    }\n+\n+    @Override\n+    public Node processExpressionStatement(ExpressionStatement node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processForInLoop(ForInLoop node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processForLoop(ForLoop node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processFunctionCall(FunctionCall node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processFunctionNode(FunctionNode node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processGeneratorExpression(GeneratorExpression node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processGetProp(GetPropNode node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processIfStatement(IfStatement node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processInfixExpression(InfixExpression node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processKeywordLiteral(KeywordLiteral node) {\n+      return newNode(transformTokenType(node.getType()));\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public Node processLabel(Label node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processLabeledStatement(LabeledStatement node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processLetNode(LetNode node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processLetStatement(LetStatement node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processName(Name node) {\n+      return newString(node.getIdentifier());\n+    }\n+\n+    @Override\n+    public Node processNewExpression(NewExpression node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processNumber(NumberLiteral node) {\n+      Node n = newNode(Token.NUMBER);\n+      n.setDouble(node.getNumber());\n+      return n;\n+    }\n+\n+    @Override\n+    public Node processObjectLiteral(ObjectLiteral node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processObjectProperty(ObjectProperty node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processParenthesizedExpression(ParenthesizedExpression node) {\n+      return newNode(Token.LP, transform(node.getExpression()), Token.RP);\n+    }\n+\n+    @Override\n+    public Node processPropertyGet(PropertyGet node) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processRegExp(RawSyntax node, int position) {\n+      throw new UnsupportedOperationException();\n+    }\n+\n+    @Override\n+    public Node processReturnStatement(ReturnStatement node) {\n+      Node n = newNode(Token.RETURN);\n+      if (node.getReturnValue() != null) {\n+        n.addChildToBack(transform(node.getReturnValue()));\n       }\n-      return node;\n+      return n;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node processScript(ScriptNode node) {\n+      throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node processString(StringLiteral node) {\n+      return newString(node.getValue());\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node processSwitchCase(SwitchCase node) {\n+      throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node processSwitchStatement(SwitchStatement node) {\n+      throw new UnsupportedOperationException();\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node processThrowStatement(ThrowStatement node) {\n+      return newNode(Token.THROW, transform(node.getExpression()));\n+    }\n+\n+    @Override\n+    public Node processTryCatchFinally(TryCatchFinally node) {\n+      throw new UnsupportedOperationException();\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n+    @Override\n+    public Node processUnary(UnaryExpression node) {\n       return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+          transformTokenType(node.getType()), transform(node.getChild()));\n     }\n \n+    @Override\n+    public Node processVariableDeclaration(VariableDeclaration node) {\n+      Node declNode;\n+      if (node.getType() == Token.CONST) {\n+        declNode = newNode(Token.CONST);\n+      } else {\n+        declNode = newNode(Token.VA\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}