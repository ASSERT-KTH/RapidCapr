{
    "patch": "        } else {\n            Node callNode = n.getParent();\n            if (callNode != null) {\n                // The rhs of the assignment is the caller, so it's used by the\n                // context. Don't associate it w/ the lhs.\n                // FYI: this fixes only the specific case where the assignment is the\n                // caller expression, but it could be nested deeper in the caller and\n                // we would still get a bug.\n                // See testAssignWithCall2 for an example of this.\n                Node lhsNode = n.getFirstChild();\n                if (lhsNode.isName() && lhsNode.getString().equals(callNode.getFirstChild().getString())) {\n                    recordDepScope(callNode, ns);\n                } else {\n                    recordDepScope(recordNode, ns);\n                }\n            } else {\n                recordDepScope(recordNode, ns);\n            }\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 0fc5ae8f..c0a70c51 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -576,6 +576,24 @@ final class NameAnalyzer implements CompilerPass {\n             recordDepScope(nameNode, ns);\n           }\n         } else {\n+            Node callNode = n.getParent();\n+            if (callNode != null) {\n+                // The rhs of the assignment is the caller, so it's used by the\n+                // context. Don't associate it w/ the lhs.\n+                // FYI: this fixes only the specific case where the assignment is the\n+                // caller expression, but it could be nested deeper in the caller and\n+                // we would still get a bug.\n+                // See testAssignWithCall2 for an example of this.\n+                Node lhsNode = n.getFirstChild();\n+                if (lhsNode.isName() && lhsNode.getString().equals(callNode.getFirstChild().getString())) {\n+                    recordDepScope(callNode, ns);\n+                } else {\n+                    recordDepScope(recordNode, ns);\n+                }\n+            } else {\n+                recordDepScope(recordNode, ns);\n+            }\n+        }\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}