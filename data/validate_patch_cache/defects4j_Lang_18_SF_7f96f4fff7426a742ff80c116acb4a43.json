{
    "patch": "    private static DateComponents parseDateTimeString(String dateTimeString) {\n        // Initialize time zone to GMT.\n        TimeZone timeZone = TimeZone.getTimeZone(\"GMT\");\n        int year = 0, month = 1, day = 1, hour = 0, minute = 0, second = 0;\n        int timeZoneOffsetIndex;\n        if ((timeZoneOffsetIndex = dateTimeString.indexOf('Z')) != -1\n            || (timeZoneOffsetIndex = dateTimeString.indexOf('+')) != -1\n            || (timeZoneOffsetIndex = dateTimeString.indexOf('-')) != -1) {\n            String timeZoneString = dateTimeString.substring(timeZoneOffsetIndex);\n            dateTimeString = dateTimeString.substring(0, timeZoneOffsetIndex);\n\n            // ISO-8601 time zone string: [+-]HH:mm\n            timeZone = TimeZone.getTimeZone(\"GMT\" + timeZoneString);\n        }\n\n        String[] parts = dateTimeString.split(\"[T ]\");\n        if (parts.length >= 1) {\n            String[] dateParts = parts[0].split(\"-\");\n            if (dateParts.length >= 3) {\n                year = Integer.valueOf(dateParts[0]);\n                month = Integer.valueOf(dateParts[1]);\n                day = Integer.valueOf(dateParts[2]);\n            } else {\n                throw new IllegalArgumentException(\"Invalid date format: \" + parts[0]);\n            }\n        }\n        if (parts.length >= 2) {\n            String[] timeParts = parts[1].split(\":\");\n            if (timeParts.length >= 3) {\n                hour = Integer.valueOf(timeParts[0]);\n                minute = Integer.valueOf(timeParts[1]);\n                int secondIndex = timeParts[2].indexOf('.');\n                if (secondIndex != -1) {\n                    // Handle fractional seconds.\n                    second = Integer.valueOf(timeParts[2].substring(0, secondIndex));\n                } else if (timeParts[2].length() > 0) {\n                    second = Integer.valueOf(timeParts[2]);\n                }\n            } else {\n                throw new IllegalArgumentException(\"Invalid time format: \" + parts[1]);\n            }\n        }\n        return new DateComponents(year, month, day, hour, minute, second, timeZone);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\nindex e0433239..deaaf685 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateFormat.java\n@@ -460,127 +460,49 @@ public class FastDateFormat extends Format {\n      * @return a {@code List} of Rule objects\n      * @throws IllegalArgumentException if pattern is invalid\n      */\n-    protected List<Rule> parsePattern() {\n-        DateFormatSymbols symbols = new DateFormatSymbols(mLocale);\n-        List<Rule> rules = new ArrayList<Rule>();\n-\n-        String[] ERAs = symbols.getEras();\n-        String[] months = symbols.getMonths();\n-        String[] shortMonths = symbols.getShortMonths();\n-        String[] weekdays = symbols.getWeekdays();\n-        String[] shortWeekdays = symbols.getShortWeekdays();\n-        String[] AmPmStrings = symbols.getAmPmStrings();\n-\n-        int length = mPattern.length();\n-        int[] indexRef = new int[1];\n-\n-        for (int i = 0; i < length; i++) {\n-            indexRef[0] = i;\n-            String token = parseToken(mPattern, indexRef);\n-            i = indexRef[0];\n-\n-            int tokenLen = token.length();\n-            if (tokenLen == 0) {\n-                break;\n-            }\n-\n-            Rule rule;\n-            char c = token.charAt(0);\n+    private static DateComponents parseDateTimeString(String dateTimeString) {\n+        // Initialize time zone to GMT.\n+        TimeZone timeZone = TimeZone.getTimeZone(\"GMT\");\n+        int year = 0, month = 1, day = 1, hour = 0, minute = 0, second = 0;\n+        int timeZoneOffsetIndex;\n+        if ((timeZoneOffsetIndex = dateTimeString.indexOf('Z')) != -1\n+            || (timeZoneOffsetIndex = dateTimeString.indexOf('+')) != -1\n+            || (timeZoneOffsetIndex = dateTimeString.indexOf('-')) != -1) {\n+            String timeZoneString = dateTimeString.substring(timeZoneOffsetIndex);\n+            dateTimeString = dateTimeString.substring(0, timeZoneOffsetIndex);\n+\n+            // ISO-8601 time zone string: [+-]HH:mm\n+            timeZone = TimeZone.getTimeZone(\"GMT\" + timeZoneString);\n+        }\n \n-            switch (c) {\n-            case 'G': // era designator (text)\n-                rule = new TextField(Calendar.ERA, ERAs);\n-                break;\n-            case 'y': // year (number)\n-                if (tokenLen >= 4) {\n-                    rule = selectNumberRule(Calendar.YEAR, tokenLen);\n-                } else {\n-                    rule = TwoDigitYearField.INSTANCE;\n-                }\n-                break;\n-            case 'M': // month in year (text and number)\n-                if (tokenLen >= 4) {\n-                    rule = new TextField(Calendar.MONTH, months);\n-                } else if (tokenLen == 3) {\n-                    rule = new TextField(Calendar.MONTH, shortMonths);\n-                } else if (tokenLen == 2) {\n-                    rule = TwoDigitMonthField.INSTANCE;\n-                } else {\n-                    rule = UnpaddedMonthField.INSTANCE;\n-                }\n-                break;\n-            case 'd': // day in month (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_MONTH, tokenLen);\n-                break;\n-            case 'h': // hour in am/pm (number, 1..12)\n-                rule = new TwelveHourField(selectNumberRule(Calendar.HOUR, tokenLen));\n-                break;\n-            case 'H': // hour in day (number, 0..23)\n-                rule = selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen);\n-                break;\n-            case 'm': // minute in hour (number)\n-                rule = selectNumberRule(Calendar.MINUTE, tokenLen);\n-                break;\n-            case 's': // second in minute (number)\n-                rule = selectNumberRule(Calendar.SECOND, tokenLen);\n-                break;\n-            case 'S': // millisecond (number)\n-                rule = selectNumberRule(Calendar.MILLISECOND, tokenLen);\n-                break;\n-            case 'E': // day in week (text)\n-                rule = new TextField(Calendar.DAY_OF_WEEK, tokenLen < 4 ? shortWeekdays : weekdays);\n-                break;\n-            case 'D': // day in year (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_YEAR, tokenLen);\n-                break;\n-            case 'F': // day of week in month (number)\n-                rule = selectNumberRule(Calendar.DAY_OF_WEEK_IN_MONTH, tokenLen);\n-                break;\n-            case 'w': // week in year (number)\n-                rule = selectNumberRule(Calendar.WEEK_OF_YEAR, tokenLen);\n-                break;\n-            case 'W': // week in month (number)\n-                rule = selectNumberRule(Calendar.WEEK_OF_MONTH, tokenLen);\n-                break;\n-            case 'a': // am/pm marker (text)\n-                rule = new TextField(Calendar.AM_PM, AmPmStrings);\n-                break;\n-            case 'k': // hour in day (1..24)\n-                rule = new TwentyFourHourField(selectNumberRule(Calendar.HOUR_OF_DAY, tokenLen));\n-                break;\n-            case 'K': // hour in am/pm (0..11)\n-                rule = selectNumberRule(Calendar.HOUR, tokenLen);\n-                break;\n-            case 'z': // time zone (text)\n-                if (tokenLen >= 4) {\n-                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.LONG);\n-                } else {\n-                    rule = new TimeZoneNameRule(mTimeZone, mLocale, TimeZone.SHORT);\n-                }\n-                break;\n-            case 'Z': // time zone (value)\n-                if (tokenLen == 1) {\n-                    rule = TimeZoneNumberRule.INSTANCE_NO_COLON;\n-                } else {\n-                    rule = TimeZoneNumberRule.INSTANCE_COLON;\n-                }\n-                break;\n-            case '\\'': // literal text\n-                String sub = token.substring(1);\n-                if (sub.length() == 1) {\n-                    rule = new CharacterLiteral(sub.charAt(0));\n-                } else {\n-                    rule = new StringLiteral(sub);\n+        String[] parts = dateTimeString.split(\"[T ]\");\n+        if (parts.length >= 1) {\n+            String[] dateParts = parts[0].split(\"-\");\n+            if (dateParts.length >= 3) {\n+                year = Integer.valueOf(dateParts[0]);\n+                month = Integer.valueOf(dateParts[1]);\n+                day = Integer.valueOf(dateParts[2]);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid date format: \" + parts[0]);\n+            }\n+        }\n+        if (parts.length >= 2) {\n+            String[] timeParts = parts[1].split(\":\");\n+            if (timeParts.length >= 3) {\n+                hour = Integer.valueOf(timeParts[0]);\n+                minute = Integer.valueOf(timeParts[1]);\n+                int secondIndex = timeParts[2].indexOf('.');\n+                if (secondIndex != -1) {\n+                    // Handle fractional seconds.\n+                    second = Integer.valueOf(timeParts[2].substring(0, secondIndex));\n+                } else if (timeParts[2].length() > 0) {\n+                    second = Integer.valueOf(timeParts[2]);\n                 }\n-                break;\n-            default:\n-                throw new IllegalArgumentException(\"Illegal pattern component: \" + token);\n+            } else {\n+                throw new IllegalArgumentException(\"Invalid time format: \" + parts[1]);\n             }\n-\n-            rules.add(rule);\n         }\n-\n-        return rules;\n+        return new DateComponents(year, month, day, hour, minute, second, timeZone);\n     }\n \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}