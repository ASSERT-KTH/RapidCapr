{
    "patch": "    public int getOffsetFromLocal(long instantLocal) {\n        final long intervalStart = instantLocal - maxOffset;\n        final long intervalEnd = instantLocal + maxOffset;\n\n        // Find the last transition before the interval.\n        final long lastTransition = previousTransition(intervalStart);\n        // Find the first transition after the interval.\n        final long nextTransition = nextTransition(intervalEnd);\n\n        if (lastTransition == nextTransition) {\n            // There is no such interval.\n            // Thus, the given local time is invalid or overlap.\n            final DateTimeZoneBuilder.Recurrence recurrence\n                    = findRecurrence(lastTransition);\n            if (recurrence == null) {\n                throw new IllegalArgumentException(\n                        \"The datetime zone has no transitions\" +\n                            \" that contain the specified local\" +\n                            \" datetime (milliseconds from epoch).\");\n            }\n\n            return offsetOfEpochSec(recurrence.getWallOffset());\n        }\n\n        // The offsets of the first and last transitions in the interval.\n        final int offsetBefore = offsetOfEpochSec(getTransition(lastTransition).getWallOffset());\n        final int offsetAfter = offsetOfEpochSec(getTransition(nextTransition).getWallOffset());\n        final int diff = offsetAfter - offsetBefore;\n\n        // Get the earliest point that could be in the interval.\n        final long candidate = lastTransition + (long) offsetBefore;\n        if (candidate >= intervalStart) {\n            return offsetBefore;\n        }\n\n        final long nextCandidate = nextTransition + (long) offsetAfter;\n        // If there are two candidates then 2 transitions inside the interval.\n        // This happens with overlapping intervals, which is also considered\n        // invalid.\n        if (nextCandidate <= intervalEnd) {\n            throw new IllegalArgumentException(\n                    \"The datetime zone has overlapping\" +\n                    \" transitions that contain the specified\" +\n                    \" local datetime (milliseconds from epoch).\");\n        }\n\n        long millisBefore = candidate;\n        long millisAfter = nextTransition + (long) offsetAfter;\n        int offset;\n        if ((millisAfter - instantLocal) < (instantLocal - millisBefore)) {\n            offset = offsetAfter;\n        } else {\n            millisBefore = lastTransition + (long) offsetBefore;\n            offset = offsetBefore;\n        }\n\n        // Find any further transitions.\n        while (true) {\n            if (millisAfter > instantLocal) {\n                break;\n            }\n\n            final long nextMillisBefore = millisAfter;\n            final int nextOffsetBefore = offsetAfter;\n            final long nextTransitionTime = nextTransition(nextMillisBefore);\n            if (nextTransitionTime == nextMillisBefore) {\n                // There is a discontinuity (gap or overlap) at the next\n                // transition. We don't know which side of it generates the\n                // right answer, so we error out.\n                throw new IllegalArgumentException(\n                        \"The datetime zone has a discontinuity\" +\n                                \" (gap or overlap) starting at the\" +\n                                \" specified local datetime (milliseconds\" +\n                                \" from epoch).\");\n            }\n\n            final int nextOffsetAfter = offsetOfEpochSec(\n                    getTransition(nextTransitionTime).getWallOffset());\n            millisAfter = nextTransitionTime + (long) nextOffsetAfter;\n            if ((millisAfter - instantLocal) >= (instantLocal - nextMillisBefore)) {\n                break;\n            }\n\n            millisBefore = nextMillisBefore;\n            offsetBefore = nextOffsetBefore;\n            offsetAfter = nextOffsetAfter;\n            offset = offsetAfter;\n        }\n\n        // Return the final candidate.\n        if (offset < 0) {\n            final long prevTransition = previousTransition(instantLocal);\n            if (prevTransition >= millisBefore) {\n                final int prevOffset = offsetOfEpochSec(\n                        getTransition(prevTransition).getWallOffset());\n                if (prevOffset <= 0) {\n                    offset = prevOffset;\n                }\n            }\n        } else if (offset > 0) {\n            final long nextTransitionTime = nextTransition(instantLocal);\n            if (nextTransitionTime <= millisAfter) {\n                final int nextOffset = offsetOfEpochSec(\n                        getTransition(nextTransitionTime).getWallOffset());\n                if (nextOffset > 0) {\n                    offset = nextOffset;\n                }\n            }\n        }\n        return offset;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 855cad05..605adf32 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -878,36 +878,115 @@ public abstract class DateTimeZone implements Serializable {\n      * @return the millisecond offset to subtract from local time to get UTC time\n      */\n     public int getOffsetFromLocal(long instantLocal) {\n-        // get the offset at instantLocal (first estimate)\n-        final int offsetLocal = getOffset(instantLocal);\n-        // adjust instantLocal using the estimate and recalc the offset\n-        final long instantAdjusted = instantLocal - offsetLocal;\n-        final int offsetAdjusted = getOffset(instantAdjusted);\n-        // if the offsets differ, we must be near a DST boundary\n-        if (offsetLocal != offsetAdjusted) {\n-            // we need to ensure that time is always after the DST gap\n-            // this happens naturally for positive offsets, but not for negative\n-            if ((offsetLocal - offsetAdjusted) < 0) {\n-                // if we just return offsetAdjusted then the time is pushed\n-                // back before the transition, whereas it should be\n-                // on or after the transition\n-                long nextLocal = nextTransition(instantAdjusted);\n-                long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n-                if (nextLocal != nextAdjusted) {\n-                    return offsetLocal;\n+        final long intervalStart = instantLocal - maxOffset;\n+        final long intervalEnd = instantLocal + maxOffset;\n+\n+        // Find the last transition before the interval.\n+        final long lastTransition = previousTransition(intervalStart);\n+        // Find the first transition after the interval.\n+        final long nextTransition = nextTransition(intervalEnd);\n+\n+        if (lastTransition == nextTransition) {\n+            // There is no such interval.\n+            // Thus, the given local time is invalid or overlap.\n+            final DateTimeZoneBuilder.Recurrence recurrence\n+                    = findRecurrence(lastTransition);\n+            if (recurrence == null) {\n+                throw new IllegalArgumentException(\n+                        \"The datetime zone has no transitions\" +\n+                            \" that contain the specified local\" +\n+                            \" datetime (milliseconds from epoch).\");\n+            }\n+\n+            return offsetOfEpochSec(recurrence.getWallOffset());\n+        }\n+\n+        // The offsets of the first and last transitions in the interval.\n+        final int offsetBefore = offsetOfEpochSec(getTransition(lastTransition).getWallOffset());\n+        final int offsetAfter = offsetOfEpochSec(getTransition(nextTransition).getWallOffset());\n+        final int diff = offsetAfter - offsetBefore;\n+\n+        // Get the earliest point that could be in the interval.\n+        final long candidate = lastTransition + (long) offsetBefore;\n+        if (candidate >= intervalStart) {\n+            return offsetBefore;\n+        }\n+\n+        final long nextCandidate = nextTransition + (long) offsetAfter;\n+        // If there are two candidates then 2 transitions inside the interval.\n+        // This happens with overlapping intervals, which is also considered\n+        // invalid.\n+        if (nextCandidate <= intervalEnd) {\n+            throw new IllegalArgumentException(\n+                    \"The datetime zone has overlapping\" +\n+                    \" transitions that contain the specified\" +\n+                    \" local datetime (milliseconds from epoch).\");\n+        }\n+\n+        long millisBefore = candidate;\n+        long millisAfter = nextTransition + (long) offsetAfter;\n+        int offset;\n+        if ((millisAfter - instantLocal) < (instantLocal - millisBefore)) {\n+            offset = offsetAfter;\n+        } else {\n+            millisBefore = lastTransition + (long) offsetBefore;\n+            offset = offsetBefore;\n+        }\n+\n+        // Find any further transitions.\n+        while (true) {\n+            if (millisAfter > instantLocal) {\n+                break;\n+            }\n+\n+            final long nextMillisBefore = millisAfter;\n+            final int nextOffsetBefore = offsetAfter;\n+            final long nextTransitionTime = nextTransition(nextMillisBefore);\n+            if (nextTransitionTime == nextMillisBefore) {\n+                // There is a discontinuity (gap or overlap) at the next\n+                // transition. We don't know which side of it generates the\n+                // right answer, so we error out.\n+                throw new IllegalArgumentException(\n+                        \"The datetime zone has a discontinuity\" +\n+                                \" (gap or overlap) starting at the\" +\n+                                \" specified local datetime (milliseconds\" +\n+                                \" from epoch).\");\n+            }\n+\n+            final int nextOffsetAfter = offsetOfEpochSec(\n+                    getTransition(nextTransitionTime).getWallOffset());\n+            millisAfter = nextTransitionTime + (long) nextOffsetAfter;\n+            if ((millisAfter - instantLocal) >= (instantLocal - nextMillisBefore)) {\n+                break;\n+            }\n+\n+            millisBefore = nextMillisBefore;\n+            offsetBefore = nextOffsetBefore;\n+            offsetAfter = nextOffsetAfter;\n+            offset = offsetAfter;\n+        }\n+\n+        // Return the final candidate.\n+        if (offset < 0) {\n+            final long prevTransition = previousTransition(instantLocal);\n+            if (prevTransition >= millisBefore) {\n+                final int prevOffset = offsetOfEpochSec(\n+                        getTransition(prevTransition).getWallOffset());\n+                if (prevOffset <= 0) {\n+                    offset = prevOffset;\n                 }\n             }\n-        } else if (offsetLocal > 0) {\n-            long prev = previousTransition(instantAdjusted);\n-            if (prev < instantAdjusted) {\n-                int offsetPrev = getOffset(prev);\n-                int diff = offsetPrev - offsetLocal;\n-                if (instantAdjusted - prev <= diff) {\n-                    return offsetPrev;\n+        } else if (offset > 0) {\n+            final long nextTransitionTime = nextTransition(instantLocal);\n+            if (nextTransitionTime <= millisAfter) {\n+                final int nextOffset = offsetOfEpochSec(\n+                        getTransition(nextTransitionTime).getWallOffset());\n+                if (nextOffset > 0) {\n+                    offset = nextOffset;\n                 }\n             }\n         }\n-        return offsetAdjusted;\n+        return offset;\n     }\n \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}