{
    "patch": "private static class TransformDispatcher extends TypeSafeDispatcher {\n\n    private String sourceName;\n    private ErrorReporter errorReporter;\n\n    private TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n      this.errorReporter = errorReporter;\n      this.sourceName = sourceName;\n    }\n\n    private Node processGeneric(AstNode node) {\n      int nodeType = node.getType();\n      Node transformedNode = newNode(transformTokenType(nodeType));\n      transformedNode.setLineno(node.getLineno());\n      transformedNode.setCharno(node.getCharno());\n\n      for (Node child : transformChildren(node)) {\n        transformedNode.addChildToBack(child);\n      }\n      return transformedNode;\n    }\n\n    @Override\n    Node processArrayType(ArrayLiteral node) {\n      Node arrayNode = newNode(Token.ARRAYLIT);\n      for (AstNode element : node.getElements()) {\n        if (element.getType() != Token.COMMA) {\n          arrayNode.addChildToBack(transform(element));\n        }\n      }\n      arrayNode.setLineno(node.getLineno());\n      return arrayNode;\n    }\n\n    @Override\n    Node processAssign(Assignment node) {\n      int assignType = node.getType();\n      Node transformedNode = newNode(transformTokenType(assignType));\n      Node leftChild = transform(node.getLeft());\n      Node rightChild = transform(node.getRight());\n\n      transformedNode.setLineno(node.getLineno());\n      if (leftChild.getType() == Token.GETELEM) {\n        // Special case that ensures GETELEM has only two children.\n        transformedNode.addChildToBack(\n            newNode(\n                Token.SETELEM,\n                leftChild.getFirstChild(),\n                leftChild.getLastChild(),\n                rightChild));\n      } else {\n        transformedNode.addChildToBack(leftChild);\n        transformedNode.addChildToBack(rightChild);\n      }\n      return transformedNode;\n    }\n\n    @Override\n    Node processBinaryOperation(InfixExpression node) {\n      int nodeType = node.getType();\n\n      if (nodeType == Token.OR || nodeType == Token.AND) {\n        Node transformedNode = processLogicalAndOr(nodeType, node.getLeft(), node.getRight());\n        transformedNode.setLineno(node.getLineno());\n        return transformedNode;\n      } else {\n        Node transformedNode = newNode(transformTokenType(nodeType));\n        transformedNode.setLineno(node.getLineno());\n        transformedNode.addChildToBack(transform(node.getLeft()));\n        transformedNode.addChildToBack(transform(node.getRight()));\n        return transformedNode;\n      }\n    }\n\n    @Override\n    Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n\n    private Node processLogicalAndOr(int nodeType, AstNode left, AstNode right) {\n      Node transformedNode = newNode(transformTokenType(nodeType));\n      transformedNode.setLineno(left.getLineno());\n      transformedNode.addChildToBack(transform(left));\n      transformedNode.addChildToBack(transform(right));\n      return transformedNode;\n    }\n\n    @Override\n    Node processBreakStatement(BreakStatement statementNode) {\n      Node node = newNode(Token.BREAK);\n      if (statementNode.getBreakLabel() != null) {\n        Node labelName = transform(statementNode.getBreakLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            \"Catch clauses are not supported\",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(),\n            \"\",\n            0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    private Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n          Token.HOOK,\n          transform(exprNode.getTestExpression()),\n          transform(exprNode.getTrueExpression()),\n          transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = transform(statementNode.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n          Token.DO,\n          transformBlock(loopNode.getBody()),\n          transform(loopNode.getCondition()));\n    }\n\n    @Override\n    Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }\n\n    @Override\n    Node processEmptyExpression(EmptyExpression exprNode) {\n      Node node = newNode(Token.EMPTY);\n      return node;\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n\n    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    Node processForLoop(ForLoop loopNode) {\n      Node node = newNode(\n          Token.FOR,\n          transform(loopNode.getInitializer()),\n          transform(loopNode.getCondition()),\n          transform(loopNode.getIncrement()));\n      node.addChildToBack(transformBlock(loopNode.getBody()));\n      return node;\n    }\n\n    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      node.setLineno(callNode.getLineno());\n      int leftParamPos = callNode.getPosition() + callNode.getLength() - callNode.getArgs().getPosition();\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        name = new Name();\n        name.setIdentifier(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getFunctionType().getLength() + functionNode.getParent().getPosition() + 1;\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n\n      Node lp = newNode(Token.LP);\n\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n\n      int lparenCharno = functionNode.getParamCount() > 0 ?\n          functionNode.getParam(0).getAbsolutePosition() :\n          functionNode.getFunctionType().getAbsolutePosition() + functionNode.getFunctionType().getLength() + 1;\n      lp.setCharno(position2charno(lparenCharno));\n\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n     return node;\n    }\n\n    @Override\n    Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(Token.IF, transform(statementNode.getCondition()));\n      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n      AstNode elsePart = statementNode.getElsePart();\n      if (elsePart != null) {\n        if (elsePart instanceof Block) {\n          node.addChildToBack(transform(elsePart));\n        } else {\n          node.addChildToBack(newNode(Token.BLOCK, transform(elsePart)));\n        }\n      }\n      return node;\n    }\n\n    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n      return processBinaryOperation(exprNode);\n    }\n\n    @Override\n    Node processKeywordLiteral(KeywordLiteral node) {\n      // Note: should always be BOOLEAN or NULL.\n      return newNode(transformTokenType(node.getType()));\n    }\n\n    @Override\n    Node processName(Name name) {\n      Node newNode;\n      if (name.getIdentifier().equals(\"undefined\")) {\n        newNode = newNode(Token.VOID);\n      } else {\n        newNode = newNode(Token.NAME, name.getIdentifier());\n      }\n      newNode.setLineno(name.getLineno());\n      return newNode;\n    }\n\n    @Override\n    Node processNewExpression(NewExpression callNode) {\n      Node node = newNode(Token.NEW, transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        if (child.getType() == Token.COMMA) {\n          node.addChildToBack(newNode(Token.EMPTY));\n        } else {\n          node.addChildToBack(transform(child));\n        }\n      }\n      int leftParamPos = callNode.getPosition() + callNode.getLength() - callNode.getArgs().getPosition();\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }\n\n    @Override\n    Node processNumber(NumberLiteral node) {\n      Node newNode = newNode(Token.NUMBER);\n      newNode.setDouble(node.getNumber());\n      newNode.setLineno(node.getLineno());\n      return newNode;\n    }\n\n    @Override\n    Node processObjectLiteral(ObjectLiteral node) {\n      Node objectNode = newNode(Token.OBJECTLIT);\n      for (ObjectProperty property : node.getElements()) {\n        Node key = transform(property.getLeft());\n        if (property.isGetter()) {\n          Node tmp = new Node(Token.GETTER_DEF);\n          tmp.addChildToBack(key);\n          tmp.addChildToBack(transform(property.getRight()));\n          objectNode.addChildToBack(tmp);\n        } else if (property.isSetter()) {\n          Node tmp = new Node(Token.SETTER_DEF);\n          tmp.addChildToBack(key);\n          tmp.addChildToBack(transform(property.getRight()));\n          objectNode.addChildToBack(tmp);\n        } else {\n          objectNode.addChildToBack(newNode(Token.COLON, key, transform(property.getRight())));\n        }\n      }\n      objectNode.setLineno(node.getLineno());\n      return objectNode;\n    }\n\n    @Override\n    Node processParenthesizedExpression(ParenthesizedExpression node) {\n      Node transformedNode = newNode(Token.PARENTHESES);\n      transformedNode.setLineno(node.getLineno());\n      transformedNode.addChildToBack(transform(node.getExpression()));\n      return transformedNode;\n    }\n\n    @Override\n    Node processPropertyGet(PropertyGet node) {\n      return newNode(\n          node.isElision() ? Token.EMPTY : Token.GETPROP,\n          transform(node.getTarget()),\n          newNode(Token.STRING, node.getProperty().getIdentifier()));\n  ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..aca41ffb 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -384,14 +384,78 @@ public class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+private static class TransformDispatcher extends TypeSafeDispatcher {\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+    private String sourceName;\n+    private ErrorReporter errorReporter;\n \n-      int nType = n.getType();\n-      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n-          n.getFirstChild().getType() == Token.STRING &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    private TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+      this.errorReporter = errorReporter;\n+      this.sourceName = sourceName;\n+    }\n+\n+    private Node processGeneric(AstNode node) {\n+      int nodeType = node.getType();\n+      Node transformedNode = newNode(transformTokenType(nodeType));\n+      transformedNode.setLineno(node.getLineno());\n+      transformedNode.setCharno(node.getCharno());\n+\n+      for (Node child : transformChildren(node)) {\n+        transformedNode.addChildToBack(child);\n+      }\n+      return transformedNode;\n+    }\n+\n+    @Override\n+    Node processArrayType(ArrayLiteral node) {\n+      Node arrayNode = newNode(Token.ARRAYLIT);\n+      for (AstNode element : node.getElements()) {\n+        if (element.getType() != Token.COMMA) {\n+          arrayNode.addChildToBack(transform(element));\n+        }\n+      }\n+      arrayNode.setLineno(node.getLineno());\n+      return arrayNode;\n+    }\n+\n+    @Override\n+    Node processAssign(Assignment node) {\n+      int assignType = node.getType();\n+      Node transformedNode = newNode(transformTokenType(assignType));\n+      Node leftChild = transform(node.getLeft());\n+      Node rightChild = transform(node.getRight());\n+\n+      transformedNode.setLineno(node.getLineno());\n+      if (leftChild.getType() == Token.GETELEM) {\n+        // Special case that ensures GETELEM has only two children.\n+        transformedNode.addChildToBack(\n+            newNode(\n+                Token.SETELEM,\n+                leftChild.getFirstChild(),\n+                leftChild.getLastChild(),\n+                rightChild));\n+      } else {\n+        transformedNode.addChildToBack(leftChild);\n+        transformedNode.addChildToBack(rightChild);\n+      }\n+      return transformedNode;\n+    }\n+\n+    @Override\n+    Node processBinaryOperation(InfixExpression node) {\n+      int nodeType = node.getType();\n+\n+      if (nodeType == Token.OR || nodeType == Token.AND) {\n+        Node transformedNode = processLogicalAndOr(nodeType, node.getLeft(), node.getRight());\n+        transformedNode.setLineno(node.getLineno());\n+        return transformedNode;\n+      } else {\n+        Node transformedNode = newNode(transformTokenType(nodeType));\n+        transformedNode.setLineno(node.getLineno());\n+        transformedNode.addChildToBack(transform(node.getLeft()));\n+        transformedNode.addChildToBack(transform(node.getRight()));\n+        return transformedNode;\n+      }\n     }\n \n     @Override\n@@ -399,6 +463,14 @@ public class IRFactory {\n       return processGeneric(blockNode);\n     }\n \n+    private Node processLogicalAndOr(int nodeType, AstNode left, AstNode right) {\n+      Node transformedNode = newNode(transformTokenType(nodeType));\n+      transformedNode.setLineno(left.getLineno());\n+      transformedNode.addChildToBack(transform(left));\n+      transformedNode.addChildToBack(transform(right));\n+      return transformedNode;\n+    }\n+\n     @Override\n     Node processBreakStatement(BreakStatement statementNode) {\n       Node node = newNode(Token.BREAK);\n@@ -419,14 +491,15 @@ public class IRFactory {\n         errorReporter.error(\n             \"Catch clauses are not supported\",\n             sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+            clauseNode.getCatchCondition().getLineno(),\n+            \"\",\n+            0);\n       }\n       node.addChildToBack(transformBlock(clauseNode.getBody()));\n       return node;\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+    private Node processConditionalExpression(ConditionalExpression exprNode) {\n       return newNode(\n           Token.HOOK,\n           transform(exprNode.getTestExpression()),\n@@ -497,14 +570,13 @@ public class IRFactory {\n \n     @Override\n     Node processFunctionCall(FunctionCall callNode) {\n-      Node node = newNode(transformTokenType(callNode.getType()),\n-                           transform(callNode.getTarget()));\n+      Node node = newNode(transformTokenType(callNode.getType()), transform(callNode.getTarget()));\n       for (AstNode child : callNode.getArguments()) {\n         node.addChildToBack(transform(child));\n       }\n \n-      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n       node.setLineno(callNode.getLineno());\n+      int leftParamPos = callNode.getPosition() + callNode.getLength() - callNode.getArgs().getPosition();\n       node.setCharno(position2charno(leftParamPos));\n       return node;\n     }\n@@ -521,35 +593,27 @@ public class IRFactory {\n       Node node = newNode(Token.FUNCTION);\n       Node newName = transform(name);\n       if (isUnnamedFunction) {\n-        // Old Rhino tagged the empty name node with the line number of the\n-        // declaration.\n         newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() +\n-            functionNode.getLp();\n+        int lpColumn = functionNode.getFunctionType().getLength() + functionNode.getParent().getPosition() + 1;\n         newName.setCharno(position2charno(lpColumn));\n       }\n \n       node.addChildToBack(newName);\n+\n       Node lp = newNode(Token.LP);\n-      // The left paren's complicated because it's not represented by an\n-      // AstNode, so there's nothing that has the actual line number that it\n-      // appeared on.  We know the paren has to appear on the same line as the\n-      // function name (or else a semicolon will be inserted.)  If there's no\n-      // function name, assume the paren was on the same line as the function.\n-      // TODO(bowdidge): Mark line number of paren correctly.\n+\n       Name fnName = functionNode.getFunctionName();\n       if (fnName != null) {\n         lp.setLineno(fnName.getLineno());\n       } else {\n         lp.setLineno(functionNode.getLineno());\n       }\n-      int lparenCharno = functionNode.getLp() +\n-          functionNode.getAbsolutePosition();\n \n+      int lparenCharno = functionNode.getParamCount() > 0 ?\n+          functionNode.getParam(0).getAbsolutePosition() :\n+          functionNode.getFunctionType().getAbsolutePosition() + functionNode.getFunctionType().getLength() + 1;\n       lp.setCharno(position2charno(lparenCharno));\n+\n       for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n       }\n@@ -561,6 +625,106 @@ public class IRFactory {\n      return node;\n     }\n \n+    @Override\n+    Node processIfStatement(IfStatement statementNode) {\n+      Node node = newNode(Token.IF, transform(statementNode.getCondition()));\n+      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n+      AstNode elsePart = statementNode.getElsePart();\n+      if (elsePart != null) {\n+        if (elsePart instanceof Block) {\n+          node.addChildToBack(transform(elsePart));\n+        } else {\n+          node.addChildToBack(newNode(Token.BLOCK, transform(elsePart)));\n+        }\n+      }\n+      return node;\n+    }\n+\n+    @Override\n+    Node processInfixExpression(InfixExpression exprNode) {\n+      return processBinaryOperation(exprNode);\n+    }\n+\n+    @Override\n+    Node processKeywordLiteral(KeywordLiteral node) {\n+      // Note: should always be BOOLEAN or NULL.\n+      return newNode(transformTokenType(node.getType()));\n+    }\n+\n+    @Override\n+    Node processName(Name name) {\n+      Node newNode;\n+      if (name.getIdentifier().equals(\"undefined\")) {\n+        newNode = newNode(Token.VOID);\n+      } else {\n+        newNode = newNode(Token.NAME, name.getIdentifier());\n+      }\n+      newNode.setLineno(name.getLineno());\n+      return newNode;\n+    }\n+\n+    @Override\n+    Node processNewExpression(NewExpression callNode) {\n+      Node node = newNode(Token.NEW, transform(callNode.getTarget()));\n+      for (AstNode child : callNode.getArguments()) {\n+        if (child.getType() == Token.COMMA) {\n+          node.addChildToBack(newNode(Token.EMPTY));\n+        } else {\n+          node.addChildToBack(transform(child));\n+        }\n+      }\n+      int leftParamPos = callNode.getPosition() + callNode.getLength() - callNode.getArgs().getPosition();\n+      node.setCharno(position2charno(leftParamPos));\n+      return node;\n+    }\n+\n+    @Override\n+    Node processNumber(NumberLiteral node) {\n+      Node newNode = newNode(Token.NUMBER);\n+      newNode.setDouble(node.getNumber());\n+      newNode.setLineno(node.getLineno());\n+      return newNode;\n+    }\n+\n+    @Override\n+    Node processObjectLiteral(ObjectLiteral node) {\n+      Node objectNode = newNode(Token.OBJECTLIT);\n+      for (ObjectProperty property : node.getElements()) {\n+        Node key = transform(property.getLeft());\n+        if (property.isGetter()) {\n+          Node tmp = new Node(Token.GETTER_DEF);\n+          tmp.addChildToBack(key);\n+          tmp.addChildToBack(transform(property.getRight()));\n+          objectNode.addChildToBack(tmp);\n+        } else if (property.isSetter()) {\n+          Node tmp = new Node(Token.SETTER_DEF);\n+          tmp.addChildToBack(key);\n+          tmp.addChildToBack(transform(property.getRight()));\n+          objectNode.addChildToBack(tmp);\n+        } else {\n+          objectNode.addChildToBack(newNode(Token.COLON, key, transform(property.getRight())));\n+        }\n+      }\n+      objectNode.setLineno(node.getLineno());\n+      return objectNode;\n+    }\n+\n+    @Override\n+    Node processParenthesizedExpression(ParenthesizedExpression node) {\n+      Node transformedNode = newNode(Token.PARENTHESES);\n+      transformedNode.setLineno(node.getLineno());\n+      transformedNode.addChildToBack(transform(node.getExpression()));\n+      return transformedNode;\n+    }\n+\n+    @Override\n+    Node processPropertyGet(PropertyGet node) {\n+      return newNode(\n+          node.isElision() ? Token.EMPTY : Token.GETPROP,\n+          transform(node.getTarget()),\n+          newNode(Token.STRING, node.getProperty().getIdentifier()));\n+  \n+\n     @Override\n     Node processIfStatement(IfStatement statementNode) {\n       Node node = newNode(Token.IF);",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}