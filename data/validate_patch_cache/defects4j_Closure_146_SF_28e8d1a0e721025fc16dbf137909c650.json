{
    "patch": "public class TypePair {\n  private final JSType typeA;\n  private final JSType typeB;\n\n  public TypePair(JSType typeA, JSType typeB) {\n    this.typeA = typeA;\n    this.typeB = typeB;\n  }\n\n  public TypePair canonicalize() {\n    if (this.typeA == null && this.typeB == null) {\n      return this;\n    }\n\n    if (this.typeA != null && this.typeB != null) {\n      int cmp = this.typeA.compareTo(this.typeB);\n      if (cmp < 0) {\n        return new TypePair(this.typeB, this.typeA);\n      } else if (cmp > 0) {\n        return this;\n      } else if (this.typeA.isStructurallyEquivalentTo(this.typeB)) {\n        return new TypePair(this.typeB, this.typeA);\n      } else {\n        return this;\n      }\n    }\n\n    return this;\n  }\n\n  public JSType getTypeA() {\n    return typeA;\n  }\n\n  public JSType getTypeB() {\n    return typeB;\n  }\n\n  public boolean contains(JSType t) {\n    return (typeA != null && typeA.equals(t)) || (typeB != null && typeB.equals(t));\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex aa8c7bc9..1420ea12 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -693,27 +693,49 @@ public abstract class JSType implements Serializable {\n    *         element. The returned pair is never {@code null} even though its\n    *         components may be {@code null}\n    */\n-  public TypePair getTypesUnderInequality(JSType that) {\n-    // unions types\n-    if (that instanceof UnionType) {\n-      TypePair p = that.getTypesUnderInequality(this);\n-      return new TypePair(p.typeB, p.typeA);\n-    }\n+public class TypePair {\n+  private final JSType typeA;\n+  private final JSType typeB;\n \n-    // other types\n-    switch (this.testForEquality(that)) {\n-      case TRUE:\n-        return new TypePair(null, null);\n+  public TypePair(JSType typeA, JSType typeB) {\n+    this.typeA = typeA;\n+    this.typeB = typeB;\n+  }\n \n-      case FALSE:\n-      case UNKNOWN:\n-        return new TypePair(this, that);\n+  public TypePair canonicalize() {\n+    if (this.typeA == null && this.typeB == null) {\n+      return this;\n     }\n \n-    // switch case is exhaustive\n-    throw new IllegalStateException();\n+    if (this.typeA != null && this.typeB != null) {\n+      int cmp = this.typeA.compareTo(this.typeB);\n+      if (cmp < 0) {\n+        return new TypePair(this.typeB, this.typeA);\n+      } else if (cmp > 0) {\n+        return this;\n+      } else if (this.typeA.isStructurallyEquivalentTo(this.typeB)) {\n+        return new TypePair(this.typeB, this.typeA);\n+      } else {\n+        return this;\n+      }\n+    }\n+\n+    return this;\n   }\n \n+  public JSType getTypeA() {\n+    return typeA;\n+  }\n+\n+  public JSType getTypeB() {\n+    return typeB;\n+  }\n+\n+  public boolean contains(JSType t) {\n+    return (typeA != null && typeA.equals(t)) || (typeB != null && typeB.equals(t));\n+  }\n+}\n+\n   /**\n    * Computes the subset of {@code this} and {@code that} types under shallow\n    * equality.",
    "result_reason": "error: class JSType.TypePair is already defined in class JSType",
    "test_result": "ERROR"
}