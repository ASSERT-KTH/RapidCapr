{
    "patch": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n    double a;\n    double b;\n    if (lo < hi) {\n      a = lo;\n      b = hi;\n    } else {\n      a = hi;\n      b = lo;\n    }\n\n    double x = mid;\n    double v = x;\n    double w = x;\n    double d = 0;\n    double e = 0;\n    double fx = computeObjectiveValue(x);\n    if (!isMinim) {\n      fx = -fx;\n    }\n    double fv = fx;\n    double fw = fx;\n\n    UnivariatePointValuePair previous = null;\n    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n    double previousSlope = Double.NaN;\n    double slope = Double.NaN;\n\n    int iter = 0;\n    while (true) {\n\n      final double m = 0.5 * (a + b);\n      final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n      final double tol2 = 2 * tol1;\n\n      // Stopping criterion.\n      final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n      if (!stop) {\n        double p = 0;\n        double q = 0;\n        double r = 0;\n        double u = 0;\n\n        if (FastMath.abs(e) > tol1) { // Fit parabola.\n          r = (x - w) * (fx - fv);\n          q = (x - v) * (fx - fw);\n          p = (x - v) * q - (x - w) * r;\n          q = 2 * (q - r);\n\n          if (q > 0) {\n            p = -p;\n          } else {\n            q = -q;\n          }\n\n          r = e;\n          e = d;\n\n          if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n            // Parabolic interpolation step.\n            d = p / q;\n            u = x + d;\n\n            // f must not be evaluated too close to a or b.\n            if (u - a < tol2 || b - u < tol2) {\n              if (x <= m) {\n                d = tol1;\n              } else {\n                d = -tol1;\n              }\n            }\n          } else {\n            // Golden section step.\n            if (x < m) {\n              e = b - x;\n            } else {\n              e = a - x;\n            }\n            d = goldenSection * e;\n          }\n        } else {\n          // Golden section step.\n          if (x < m) {\n            e = b - x;\n          } else {\n            e = a - x;\n          }\n          d = goldenSection * e;\n        }\n\n        // Update by at least \"tol1\".\n        if (FastMath.abs(d) < tol1) {\n          if (d >= 0) {\n            u = x + tol1;\n          } else {\n            u = x - tol1;\n          }\n        } else {\n          u = x + d;\n        }\n\n        double fu = computeObjectiveValue(u);\n        if (!isMinim) {\n          fu = -fu;\n        }\n\n        previous = current;\n        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n\n        if (checker != null) {\n          if (checker.converged(iter, previous, current)) {\n            return current;\n          }\n        }\n\n        if (iter == 0) {\n          // Set previousSlope and slope.\n          slope = (fu - fx) / (u - x);\n        } else {\n          // Previous step size.\n          double step = u - x;\n\n          // Compute current slope.\n          previousSlope = slope;\n          slope = (fu - fx) / step;\n\n          // Update a, b, v, w and x.\n          if (slope * previousSlope <= 0) {\n            // Slope signs switch.\n            // Reset interpolants.\n            v = x;\n            fv = fx;\n            w = u;\n            fw = fu;\n          } else if (FastMath.abs(slope) < FastMath.abs(previousSlope)) {\n            // Slope decreases.\n            // Replace oldest interpolant.\n            v = w;\n            fv = fw;\n            w = u;\n            fw = fu;\n          } else {\n            // Slope increases.\n            // Replace newest interpolant.\n            v = x;\n            fv = fx;\n          }\n        }\n\n        if (isMinim) {\n          if (fu < fx) {\n            b = u;\n          } else {\n            a = x;\n          }\n        } else {\n          if (fu > fx) {\n            b = u;\n          } else {\n            a = x;\n          }\n        }\n\n        // Update x and fx.\n        if (fu < fx) {\n          w = x;\n          fw = fx;\n          x = u;\n          fx = fu;\n        } else {\n          if (u < x) {\n            a = u;\n          } else {\n            b = u;\n          }\n          if (fu < fw || FastMath.abs(w - x) < tol1) {\n            v = w;\n            fv = fw;\n            w = u;\n            fw = fu;\n          } else if (fu < fv || FastMath.abs(v - x) < tol1 || FastMath.abs(v - w) < tol1) {\n            v = u;\n            fv = fu;\n          }\n        }\n\n      } else {\n        return current;\n      }\n\n      ++iter;\n    }\n  } ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex b6ce68ef3..c85de6957 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -106,169 +106,208 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariatePointValuePair doOptimize() {\n-        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n-        final double lo = getMin();\n-        final double mid = getStartValue();\n-        final double hi = getMax();\n-\n-        // Optional additional convergence criteria.\n-        final ConvergenceChecker<UnivariatePointValuePair> checker\n-            = getConvergenceChecker();\n-\n-        double a;\n-        double b;\n-        if (lo < hi) {\n-            a = lo;\n-            b = hi;\n+protected UnivariatePointValuePair doOptimize() {\n+    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n+    final double lo = getMin();\n+    final double mid = getStartValue();\n+    final double hi = getMax();\n+\n+    // Optional additional convergence criteria.\n+    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n+\n+    double a;\n+    double b;\n+    if (lo < hi) {\n+      a = lo;\n+      b = hi;\n+    } else {\n+      a = hi;\n+      b = lo;\n+    }\n+\n+    double x = mid;\n+    double v = x;\n+    double w = x;\n+    double d = 0;\n+    double e = 0;\n+    double fx = computeObjectiveValue(x);\n+    if (!isMinim) {\n+      fx = -fx;\n+    }\n+    double fv = fx;\n+    double fw = fx;\n+\n+    UnivariatePointValuePair previous = null;\n+    UnivariatePointValuePair current = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+\n+    double previousSlope = Double.NaN;\n+    double slope = Double.NaN;\n+\n+    int iter = 0;\n+    while (true) {\n+\n+      final double m = 0.5 * (a + b);\n+      final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n+      final double tol2 = 2 * tol1;\n+\n+      // Stopping criterion.\n+      final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n+      if (!stop) {\n+        double p = 0;\n+        double q = 0;\n+        double r = 0;\n+        double u = 0;\n+\n+        if (FastMath.abs(e) > tol1) { // Fit parabola.\n+          r = (x - w) * (fx - fv);\n+          q = (x - v) * (fx - fw);\n+          p = (x - v) * q - (x - w) * r;\n+          q = 2 * (q - r);\n+\n+          if (q > 0) {\n+            p = -p;\n+          } else {\n+            q = -q;\n+          }\n+\n+          r = e;\n+          e = d;\n+\n+          if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n+            // Parabolic interpolation step.\n+            d = p / q;\n+            u = x + d;\n+\n+            // f must not be evaluated too close to a or b.\n+            if (u - a < tol2 || b - u < tol2) {\n+              if (x <= m) {\n+                d = tol1;\n+              } else {\n+                d = -tol1;\n+              }\n+            }\n+          } else {\n+            // Golden section step.\n+            if (x < m) {\n+              e = b - x;\n+            } else {\n+              e = a - x;\n+            }\n+            d = goldenSection * e;\n+          }\n         } else {\n-            a = hi;\n-            b = lo;\n+          // Golden section step.\n+          if (x < m) {\n+            e = b - x;\n+          } else {\n+            e = a - x;\n+          }\n+          d = goldenSection * e;\n         }\n \n-        double x = mid;\n-        double v = x;\n-        double w = x;\n-        double d = 0;\n-        double e = 0;\n-        double fx = computeObjectiveValue(x);\n+        // Update by at least \"tol1\".\n+        if (FastMath.abs(d) < tol1) {\n+          if (d >= 0) {\n+            u = x + tol1;\n+          } else {\n+            u = x - tol1;\n+          }\n+        } else {\n+          u = x + d;\n+        }\n+\n+        double fu = computeObjectiveValue(u);\n         if (!isMinim) {\n-            fx = -fx;\n+          fu = -fu;\n         }\n-        double fv = fx;\n-        double fw = fx;\n-\n-        UnivariatePointValuePair previous = null;\n-        UnivariatePointValuePair current\n-            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-\n-        int iter = 0;\n-        while (true) {\n-            final double m = 0.5 * (a + b);\n-            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n-            final double tol2 = 2 * tol1;\n-\n-            // Default stopping criterion.\n-            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n-            if (!stop) {\n-                double p = 0;\n-                double q = 0;\n-                double r = 0;\n-                double u = 0;\n-\n-                if (FastMath.abs(e) > tol1) { // Fit parabola.\n-                    r = (x - w) * (fx - fv);\n-                    q = (x - v) * (fx - fw);\n-                    p = (x - v) * q - (x - w) * r;\n-                    q = 2 * (q - r);\n-\n-                    if (q > 0) {\n-                        p = -p;\n-                    } else {\n-                        q = -q;\n-                    }\n-\n-                    r = e;\n-                    e = d;\n-\n-                    if (p > q * (a - x) &&\n-                        p < q * (b - x) &&\n-                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n-                        // Parabolic interpolation step.\n-                        d = p / q;\n-                        u = x + d;\n-\n-                        // f must not be evaluated too close to a or b.\n-                        if (u - a < tol2 || b - u < tol2) {\n-                            if (x <= m) {\n-                                d = tol1;\n-                            } else {\n-                                d = -tol1;\n-                            }\n-                        }\n-                    } else {\n-                        // Golden section step.\n-                        if (x < m) {\n-                            e = b - x;\n-                        } else {\n-                            e = a - x;\n-                        }\n-                        d = GOLDEN_SECTION * e;\n-                    }\n-                } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n-                }\n-\n-                // Update by at least \"tol1\".\n-                if (FastMath.abs(d) < tol1) {\n-                    if (d >= 0) {\n-                        u = x + tol1;\n-                    } else {\n-                        u = x - tol1;\n-                    }\n-                } else {\n-                    u = x + d;\n-                }\n-\n-                double fu = computeObjectiveValue(u);\n-                if (!isMinim) {\n-                    fu = -fu;\n-                }\n-\n-                // User-defined convergence checker.\n-                previous = current;\n-                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n-\n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return current;\n-                    }\n-                }\n-\n-                // Update a, b, v, w and x.\n-                if (fu <= fx) {\n-                    if (u < x) {\n-                        b = x;\n-                    } else {\n-                        a = x;\n-                    }\n-                    v = w;\n-                    fv = fw;\n-                    w = x;\n-                    fw = fx;\n-                    x = u;\n-                    fx = fu;\n-                } else {\n-                    if (u < x) {\n-                        a = u;\n-                    } else {\n-                        b = u;\n-                    }\n-                    if (fu <= fw ||\n-                        Precision.equals(w, x)) {\n-                        v = w;\n-                        fv = fw;\n-                        w = u;\n-                        fw = fu;\n-                    } else if (fu <= fv ||\n-                               Precision.equals(v, x) ||\n-                               Precision.equals(v, w)) {\n-                        v = u;\n-                        fv = fu;\n-                    }\n-                }\n-            } else { // Default termination (Brent's criterion).\n-                return current;\n-            }\n-            ++iter;\n+\n+        previous = current;\n+        current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+\n+        if (checker != null) {\n+          if (checker.converged(iter, previous, current)) {\n+            return current;\n+          }\n+        }\n+\n+        if (iter == 0) {\n+          // Set previousSlope and slope.\n+          slope = (fu - fx) / (u - x);\n+        } else {\n+          // Previous step size.\n+          double step = u - x;\n+\n+          // Compute current slope.\n+          previousSlope = slope;\n+          slope = (fu - fx) / step;\n+\n+          // Update a, b, v, w and x.\n+          if (slope * previousSlope <= 0) {\n+            // Slope signs switch.\n+            // Reset interpolants.\n+            v = x;\n+            fv = fx;\n+            w = u;\n+            fw = fu;\n+          } else if (FastMath.abs(slope) < FastMath.abs(previousSlope)) {\n+            // Slope decreases.\n+            // Replace oldest interpolant.\n+            v = w;\n+            fv = fw;\n+            w = u;\n+            fw = fu;\n+          } else {\n+            // Slope increases.\n+            // Replace newest interpolant.\n+            v = x;\n+            fv = fx;\n+          }\n         }\n+\n+        if (isMinim) {\n+          if (fu < fx) {\n+            b = u;\n+          } else {\n+            a = x;\n+          }\n+        } else {\n+          if (fu > fx) {\n+            b = u;\n+          } else {\n+            a = x;\n+          }\n+        }\n+\n+        // Update x and fx.\n+        if (fu < fx) {\n+          w = x;\n+          fw = fx;\n+          x = u;\n+          fx = fu;\n+        } else {\n+          if (u < x) {\n+            a = u;\n+          } else {\n+            b = u;\n+          }\n+          if (fu < fw || FastMath.abs(w - x) < tol1) {\n+            v = w;\n+            fv = fw;\n+            w = u;\n+            fw = fu;\n+          } else if (fu < fv || FastMath.abs(v - x) < tol1 || FastMath.abs(v - w) < tol1) {\n+            v = u;\n+            fv = fu;\n+          }\n+        }\n+\n+      } else {\n+        return current;\n+      }\n+\n+      ++iter;\n     }\n+  } \n \n     /**\n      * Selects the best of two points.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}