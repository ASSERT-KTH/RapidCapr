{
    "patch": "        }\n      }\n\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }\n\n    private boolean isSingletonGetter(Node value, Reference reference) {\n      Node parent = reference.getParent();\n      if (parent.isCall()) {\n        parent = parent.getParent();\n      }\n      if (parent.isGetProp()) {\n        PropertyInfo propInfo = reference.getScope().getProperty((Node) parent.getLastChild());\n        return isSingletonGetterMethodInfo(propInfo, value);\n      }\n      return false;\n    }\n\n    private boolean isSingletonGetterMethodInfo(PropertyInfo propInfo, Node value) {\n      return propInfo != null\n          && propInfo.isMethodDefinition()\n          && isSingletonGetterFunction(value);\n    }\n\n    private boolean isSingletonGetterFunction(Node value) {\n      Preconditions.checkArgument(value.isFunction());\n      if (value.getChildCount() != 1) {\n        return false;\n      }\n      Node body = value.getLastChild();\n      if (!body.isBlock()) {\n        return false;\n      }\n      controlFlowAnalysis.process(null, value, body);\n      return controlFlowAnalysis.isSingleExitPointFunction();\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..b7714f36 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -579,6 +579,43 @@ class InlineVariables implements CompilerPass {\n           canMoveModerately(initialization, reference);\n     }\n \n+    private boolean isSingletonGetter(Node value, Reference reference) {\n+      Node parent = reference.getParent();\n+      if (parent.isCall()) {\n+        parent = parent.getParent();\n+      }\n+      if (parent.isGetProp()) {\n+        PropertyInfo propInfo = reference.getScope().getProperty((Node) parent.getLastChild());\n+        return isSingletonGetterMethodInfo(propInfo, value);\n+      }\n+      return false;\n+    }\n+\n+    private boolean isSingletonGetterMethodInfo(PropertyInfo propInfo, Node value) {\n+      return propInfo != null\n+          && propInfo.isMethodDefinition()\n+          && isSingletonGetterFunction(value);\n+    }\n+\n+    private boolean isSingletonGetterFunction(Node value) {\n+      Preconditions.checkArgument(value.isFunction());\n+      if (value.getChildCount() != 1) {\n+        return false;\n+      }\n+      Node body = value.getLastChild();\n+      if (!body.isBlock()) {\n+        return false;\n+      }\n+      controlFlowAnalysis.process(null, value, body);\n+      return controlFlowAnalysis.isSingleExitPointFunction();\n+    }\n+        }\n+      }\n+\n+      return canMoveAggressively(value) ||\n+          canMoveModerately(initialization, reference);\n+    }\n+\n     /**\n      * If the value is a literal, we can cross more boundaries to inline it.\n      */",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}