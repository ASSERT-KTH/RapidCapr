{
    "patch": "            case Token.CASE:\n            case Token.DEFAULT_CASE:\n              // After the body of a CASE, the control goes to the body of the next\n              // case, without having to go to the case condition.\n              if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                  return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                  return parent.getNext().getFirstChild();\n                } else {\n                  throw new RuntimeException(\"Not reachable\");\n                }\n              } else {\n                return computeFollowNode(fromNode, parent, cfa);\n              }\n          }\n          break;\n        case Token.FUNCTION: // Skip function declarations.\n          return computeFollowNode(fromNode, parent, cfa);\n        default:\n          break;\n      }\n\n      if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n      } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..953f04ab 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,36 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+            case Token.CASE:\n+            case Token.DEFAULT_CASE:\n+              // After the body of a CASE, the control goes to the body of the next\n+              // case, without having to go to the case condition.\n+              if (parent.getNext() != null) {\n+                if (parent.getNext().isCase()) {\n+                  return parent.getNext().getFirstChild().getNext();\n+                } else if (parent.getNext().isDefaultCase()) {\n+                  return parent.getNext().getFirstChild();\n+                } else {\n+                  throw new RuntimeException(\"Not reachable\");\n+                }\n+              } else {\n+                return computeFollowNode(fromNode, parent, cfa);\n+              }\n+          }\n+          break;\n+        case Token.FUNCTION: // Skip function declarations.\n+          return computeFollowNode(fromNode, parent, cfa);\n+        default:\n+          break;\n+      }\n+\n+      if (nextSibling != null) {\n+        return computeFallThrough(nextSibling);\n+      } else {\n+        // If there are no more siblings, control is transferred up the AST.\n+        return computeFollowNode(fromNode, parent, cfa);\n+      }\n+    }\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: orphaned case",
    "test_result": "ERROR"
}