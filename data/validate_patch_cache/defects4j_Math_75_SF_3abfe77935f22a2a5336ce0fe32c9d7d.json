{
    "patch": "private Dfp multiplyFast(final int y) {\n    Dfp result = new Dfp(this);\n    Dfp t1 = new Dfp(this);\n\n    boolean special = false;\n\n    result.exp += y;\n\n    if (result.exp < -150000) {\n        result = result.roundingError();\n        t1 = t1.roundingError();\n        special = true;\n    }\n\n    if (isNaN() || Double.isNaN(y)) {\n        return newInstance(Double.NaN);\n    }\n\n    if (y == 0) {\n        return newInstance(Double.POSITIVE_INFINITY).getZero();\n    }\n\n    if (result.mant[0] == 0 && result.exp != 0) {\n        t1.exp = result.exp;\n        return t1;\n    }\n\n    if (mant[mant.length - 1] == 0 && exp != 0) {\n        t1.mant[t1.mant.length - 1] = Dfp.INTEGER_MASK;\n        t1.exp = exp;\n        t1.sign = sign;\n        return t1;\n    }\n\n    long rh;\n    long k = 0;\n\n    for (int i = 0; i < result.mant.length; i++) {\n        rh = ((long) mant[i] * (long) y) + k;\n        t1.mant[i] = (int) (rh & Dfp.INTEGER_MASK);\n        k = rh >>> 32;\n    }\n\n    if (special) {\n        t1 = t1.roundingError();\n    } else if (k != 0) {\n        result = result.extend();\n        result.mant[0] = (int) k;\n        t1 = result;\n    } else {\n        t1 = result;\n    }\n\n    t1.sign = sign == ((Dfp) one()).sign ? 1 : -1;\n\n    return t1;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d72883..36f13af98 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -299,10 +299,64 @@ public class Frequency implements Serializable {\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n-    public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+private Dfp multiplyFast(final int y) {\n+    Dfp result = new Dfp(this);\n+    Dfp t1 = new Dfp(this);\n+\n+    boolean special = false;\n+\n+    result.exp += y;\n+\n+    if (result.exp < -150000) {\n+        result = result.roundingError();\n+        t1 = t1.roundingError();\n+        special = true;\n+    }\n+\n+    if (isNaN() || Double.isNaN(y)) {\n+        return newInstance(Double.NaN);\n+    }\n+\n+    if (y == 0) {\n+        return newInstance(Double.POSITIVE_INFINITY).getZero();\n+    }\n+\n+    if (result.mant[0] == 0 && result.exp != 0) {\n+        t1.exp = result.exp;\n+        return t1;\n     }\n \n+    if (mant[mant.length - 1] == 0 && exp != 0) {\n+        t1.mant[t1.mant.length - 1] = Dfp.INTEGER_MASK;\n+        t1.exp = exp;\n+        t1.sign = sign;\n+        return t1;\n+    }\n+\n+    long rh;\n+    long k = 0;\n+\n+    for (int i = 0; i < result.mant.length; i++) {\n+        rh = ((long) mant[i] * (long) y) + k;\n+        t1.mant[i] = (int) (rh & Dfp.INTEGER_MASK);\n+        k = rh >>> 32;\n+    }\n+\n+    if (special) {\n+        t1 = t1.roundingError();\n+    } else if (k != 0) {\n+        result = result.extend();\n+        result.mant[0] = (int) k;\n+        t1 = result;\n+    } else {\n+        t1 = result;\n+    }\n+\n+    t1.sign = sign == ((Dfp) one()).sign ? 1 : -1;\n+\n+    return t1;\n+}\n+\n     /**\n      * Returns the percentage of values that are equal to v\n      * (as a proportion between 0 and 1).",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}