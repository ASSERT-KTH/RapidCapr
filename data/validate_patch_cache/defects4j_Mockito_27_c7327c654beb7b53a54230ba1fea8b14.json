{
    "patch": "public <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, \n            (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    \n    if (mock instanceof Factory) {\n        ((Factory) mock).setCallback(0, newFilter);\n    } else if (Mockito.mockingDetails(mock).isUsingConstructor()) {\n        Field field = null;\n        try {\n            field = mock.getClass().getDeclaredField(\"CGLIB$CALLBACK_0\");\n        } catch (NoSuchFieldException e) {\n            throw new IllegalArgumentException(\"mock object is not generated by CGLIB\");\n        }\n        field.setAccessible(true);\n        Callback[] callbacks = ((Callback[]) getFieldValue(field, \"callbacks\"));\n        int index = getFirstIndexOfType(callbacks, MethodInterceptorFilter.class);\n        if (index == -1) {\n            throw new IllegalArgumentException(\"mock object does not have a MethodInterceptorFilter configured\");\n        }\n        callbacks[index] = newFilter;\n        setFieldValue(field, \"callbacks\", callbacks);\n    } else {\n        throw new IllegalArgumentException(\"mock object is not an instance of Factory or constructed using Mockito.mock(Class<?>)\");\n    }\n}\n\nprivate static Object getFieldValue(Field field, String fieldName) {\n    try {\n        return field.get(field.getName().equals(fieldName) ? null : field.getType().newInstance());\n    } catch (Exception e) {\n        throw new AssertionError(e);\n    }\n}\n\nprivate static void setFieldValue(Field field, String fieldName, Object value) {\n    try {\n        field.set(field.getName().equals(fieldName) ? null : field.getType().newInstance(), value);\n    } catch (Exception e) {\n        throw new AssertionError(e);\n    }\n}\n\nprivate static int getFirstIndexOfType(Object[] array, Class<?> clazz) {\n    for (int i = 0; i < array.length; i++) {\n        if (clazz.isInstance(array[i])) {\n            return i;\n        }\n    }\n    return -1;\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..440fe5869 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,58 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+public <T> void resetMock(T mock) {\n+    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n+    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n+    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, \n+            (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+    \n+    if (mock instanceof Factory) {\n+        ((Factory) mock).setCallback(0, newFilter);\n+    } else if (Mockito.mockingDetails(mock).isUsingConstructor()) {\n+        Field field = null;\n+        try {\n+            field = mock.getClass().getDeclaredField(\"CGLIB$CALLBACK_0\");\n+        } catch (NoSuchFieldException e) {\n+            throw new IllegalArgumentException(\"mock object is not generated by CGLIB\");\n+        }\n+        field.setAccessible(true);\n+        Callback[] callbacks = ((Callback[]) getFieldValue(field, \"callbacks\"));\n+        int index = getFirstIndexOfType(callbacks, MethodInterceptorFilter.class);\n+        if (index == -1) {\n+            throw new IllegalArgumentException(\"mock object does not have a MethodInterceptorFilter configured\");\n+        }\n+        callbacks[index] = newFilter;\n+        setFieldValue(field, \"callbacks\", callbacks);\n+    } else {\n+        throw new IllegalArgumentException(\"mock object is not an instance of Factory or constructed using Mockito.mock(Class<?>)\");\n+    }\n+}\n+\n+private static Object getFieldValue(Field field, String fieldName) {\n+    try {\n+        return field.get(field.getName().equals(fieldName) ? null : field.getType().newInstance());\n+    } catch (Exception e) {\n+        throw new AssertionError(e);\n+    }\n+}\n+\n+private static void setFieldValue(Field field, String fieldName, Object value) {\n+    try {\n+        field.set(field.getName().equals(fieldName) ? null : field.getType().newInstance(), value);\n+    } catch (Exception e) {\n+        throw new AssertionError(e);\n+    }\n+}\n+\n+private static int getFirstIndexOfType(Object[] array, Class<?> clazz) {\n+    for (int i = 0; i < array.length; i++) {\n+        if (clazz.isInstance(array[i])) {\n+            return i;\n+        }\n+    }\n+    return -1;\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}