{
    "patch": "public class MyIRFactory extends TransformTreeScanner<Node> {\n  //...\n\n  @Override\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(Token.EXPR_RESULT);\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  Node processWhileLoop(WhileLoop loopNode) {\n    return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n  }\n\n  @Override\n  Node processForLoop(ForLoop loopNode) {\n    Node newNode = null;\n    // Transform the parts of the for-loop statement\n    if (loopNode.getInitializer() != null) {\n      // If there's more than one expression, combine them with COMMA\n      if (loopNode.getInitializer() instanceof ExpressionList) {\n        newNode = processExpressionList((ExpressionList) loopNode.getInitializer());\n        newNode.setType(Token.COMMA);\n      } else {\n        newNode = transform(loopNode.getInitializer());\n      }\n    } else {\n      // No initializer, placeholder of an EMPTY statement\n      newNode = newNode(Token.EMPTY);\n    }\n\n    return newNode(\n        Token.FOR,\n        newNode,\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  Node processForInLoop(ForInLoop loopNode) {\n    AstNode iterator = loopNode.getIterator();\n\n    if (!(iterator instanceof Var)) {\n      errorReporter.error(\n          \"For-in loop variable must be a single variable\",\n          sourceName,\n          iterator.getLineno(),\n          \"\",\n          0);\n    }\n\n    return newNode(\n        Token.FOR,\n        transform(iterator),\n        transform(loopNode.getIteratedObject()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  Node processSwitchCase(SwitchCase caseNode) {\n    Node newNode = null;\n    if (caseNode.getExpression() != null) {\n      newNode = newNode(Token.CASE, transform(caseNode.getExpression()));\n    } else {\n      newNode = newNode(Token.DEFAULT);\n    }\n\n    return addChildToBack(newNode, transform(caseNode.getStatements()));\n  }\n\n  @SuppressWarnings(\"deprecation\")\n  @Override\n  Node processTry(TryStatement tryNode) {\n    Node tryBlock = transformBlock(tryNode.getTryBlock());\n    Node finallyBlock = tryNode.getFinallyBlock() == null ? null : transformBlock(tryNode.getFinallyBlock());\n\n    // Add a block around tryNode.catchClauses in order to generate semicolons correctly.\n    Node catchBlock = transform(tryNode.getCatchClauses());\n\n    // catchBlock can be null if there were no catch clauses.\n    if (catchBlock != null) {\n      if (catchBlock.getType() == Token.BLOCK) {\n        catchBlock.detachFromParent();\n        for (Node n = catchBlock.getFirstChild(); n != null; n = n.getNext()) {\n          if (n.getType() == Token.EMPTY) {\n            n.detachFromParent();\n          }\n        }\n      } else {\n        catchBlock.setType(Token.BLOCK);\n        Node last = null;\n        for (Node n = catchBlock; n != null; n = n.getNext()) {\n          if (n.getType() == Token.EMPTY) {\n            n.detachFromParent();\n          } else {\n            if (last != null) {\n              last.setNext(n);\n              n.setPrevious(last);\n            }\n            last = n;\n          }\n        }\n        catchBlock.setFirstChild(last);\n      }\n      if (finallyBlock != null) {\n        newNode(Token.TRY, tryBlock, catchBlock).addChildToBack(finallyBlock);\n      } else {\n        newNode(Token.TRY, tryBlock, catchBlock);\n      }\n    } else {\n      if (finallyBlock != null) {\n        return newNode(Token.TRY, tryBlock, finallyBlock);\n      } else {\n        return newNode(Token.TRY, tryBlock);\n      }\n    }\n\n    return lastAddedNode;\n  }\n\n  //...\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..16d1aa9e 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -472,107 +472,135 @@ class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+public class MyIRFactory extends TransformTreeScanner<Node> {\n+  //...\n+\n+  @Override\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(Token.EXPR_RESULT);\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n-\n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  @Override\n+  Node processWhileLoop(WhileLoop loopNode) {\n+    return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+  @Override\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  @Override\n+  Node processForLoop(ForLoop loopNode) {\n+    Node newNode = null;\n+    // Transform the parts of the for-loop statement\n+    if (loopNode.getInitializer() != null) {\n+      // If there's more than one expression, combine them with COMMA\n+      if (loopNode.getInitializer() instanceof ExpressionList) {\n+        newNode = processExpressionList((ExpressionList) loopNode.getInitializer());\n+        newNode.setType(Token.COMMA);\n+      } else {\n+        newNode = transform(loopNode.getInitializer());\n       }\n-      return node;\n+    } else {\n+      // No initializer, placeholder of an EMPTY statement\n+      newNode = newNode(Token.EMPTY);\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n+    return newNode(\n+        Token.FOR,\n+        newNode,\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement()),\n+        transformBlock(loopNode.getBody()));\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+  @Override\n+  Node processForInLoop(ForInLoop loopNode) {\n+    AstNode iterator = loopNode.getIterator();\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    if (!(iterator instanceof Var)) {\n+      errorReporter.error(\n+          \"For-in loop variable must be a single variable\",\n+          sourceName,\n+          iterator.getLineno(),\n+          \"\",\n+          0);\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+    return newNode(\n+        Token.FOR,\n+        transform(iterator),\n+        transform(loopNode.getIteratedObject()),\n+        transformBlock(loopNode.getBody()));\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  Node processSwitchCase(SwitchCase caseNode) {\n+    Node newNode = null;\n+    if (caseNode.getExpression() != null) {\n+      newNode = newNode(Token.CASE, transform(caseNode.getExpression()));\n+    } else {\n+      newNode = newNode(Token.DEFAULT);\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+    return addChildToBack(newNode, transform(caseNode.getStatements()));\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @SuppressWarnings(\"deprecation\")\n+  @Override\n+  Node processTry(TryStatement tryNode) {\n+    Node tryBlock = transformBlock(tryNode.getTryBlock());\n+    Node finallyBlock = tryNode.getFinallyBlock() == null ? null : transformBlock(tryNode.getFinallyBlock());\n+\n+    // Add a block around tryNode.catchClauses in order to generate semicolons correctly.\n+    Node catchBlock = transform(tryNode.getCatchClauses());\n+\n+    // catchBlock can be null if there were no catch clauses.\n+    if (catchBlock != null) {\n+      if (catchBlock.getType() == Token.BLOCK) {\n+        catchBlock.detachFromParent();\n+        for (Node n = catchBlock.getFirstChild(); n != null; n = n.getNext()) {\n+          if (n.getType() == Token.EMPTY) {\n+            n.detachFromParent();\n+          }\n+        }\n+      } else {\n+        catchBlock.setType(Token.BLOCK);\n+        Node last = null;\n+        for (Node n = catchBlock; n != null; n = n.getNext()) {\n+          if (n.getType() == Token.EMPTY) {\n+            n.detachFromParent();\n+          } else {\n+            if (last != null) {\n+              last.setNext(n);\n+              n.setPrevious(last);\n+            }\n+            last = n;\n+          }\n+        }\n+        catchBlock.setFirstChild(last);\n+      }\n+      if (finallyBlock != null) {\n+        newNode(Token.TRY, tryBlock, catchBlock).addChildToBack(finallyBlock);\n+      } else {\n+        newNode(Token.TRY, tryBlock, catchBlock);\n+      }\n+    } else {\n+      if (finallyBlock != null) {\n+        return newNode(Token.TRY, tryBlock, finallyBlock);\n+      } else {\n+        return newNode(Token.TRY, tryBlock);\n+      }\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    return lastAddedNode;\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+  //...\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}