{
    "patch": "import java.io.IOException;\nimport java.io.Writer;\nimport java.util.BitSet;\n\npublic class StringEscapeUtils {\n\n    private static final BitSet CSV_SPECIAL_CHARS = new BitSet();\n    private static final char CSV_DELIMITER = ',';\n    private static final String CSV_QUOTE_STR = \"\\\"\";\n    private static final char[] CSV_QUOTE = CSV_QUOTE_STR.toCharArray();\n    private static final String CSV_QUOTE_ESCAPED_STR = CSV_QUOTE_STR + CSV_QUOTE_STR;\n    private static final char[] CSV_QUOTE_ESCAPED = CSV_QUOTE_ESCAPED_STR.toCharArray();\n    private static final String[] CSV_SEARCH_CHARS = new String[128];\n\n    static {\n        CSV_SPECIAL_CHARS.set(0, CSV_DELIMITER + 1);\n        CSV_SPECIAL_CHARS.set('\\n');\n        CSV_SPECIAL_CHARS.set('\\r');\n        CSV_SEARCH_CHARS['\\n'] = \"\\\\n\";\n        CSV_SEARCH_CHARS['\\r'] = \"\\\\r\";\n        CSV_SEARCH_CHARS[CSV_DELIMITER] = CSV_DELIMITER + \"\";\n        CSV_SEARCH_CHARS['\"'] = CSV_QUOTE_ESCAPED_STR;\n    }\n\n    public static String escapeCsv(String input) {\n        if (input == null) {\n            return null;\n        }\n        int length = input.length();\n        if (length == 0 || !containsSpecialCharacters(input)) {\n            return input;\n        }\n        int upTo = 0;\n        StringBuilder sb = new StringBuilder(length * 2);\n        sb.append(CSV_QUOTE);\n        for (int i = 0; i < length; i++) {\n            char c = input.charAt(i);\n            String escaped = c < 128 ? CSV_SEARCH_CHARS[c] : null;\n            if (escaped == null && (c < Character.MIN_HIGH_SURROGATE || c > Character.MAX_LOW_SURROGATE)) {\n                continue;\n            }\n            if (i > upTo) {\n                sb.append(input, upTo, i);\n            }\n            upTo = i + 1;\n            if (escaped == null) {\n                appendHexified(c, sb);\n            } else {\n                sb.append(escaped);\n            }\n        }\n        if (upTo < length) {\n            sb.append(input, upTo, length);\n        }\n        sb.append(CSV_QUOTE);\n        return sb.toString();\n    }\n\n    private static boolean containsSpecialCharacters(CharSequence input) {\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (c < CSV_SEARCH_CHARS.length && CSV_SPECIAL_CHARS.get(c)) {\n                return true;\n            }\n            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private static void appendHexified(char c, StringBuilder sb) {\n        sb.append(\"\\\\u\");\n        String hex = Integer.toHexString(c);\n        int pad = 4 - hex.length();\n        for (int i = 0; i < pad; i++) {\n            sb.append('0');\n        }\n        sb.append(hex);\n    }\n\n    public static String unescapeCsv(String input) {\n        if (input == null) {\n            return null;\n        }\n        int length = input.length();\n        if (length == 0 || input.indexOf('\\\\') == -1) {\n            return input;\n        }\n        StringBuilder sb = new StringBuilder(length);\n        StringBuilder hex = new StringBuilder(4);\n        boolean unicodeMode = false;\n        char last = 0;\n        for (int i = 0; i < length; i++) {\n            char c = input.charAt(i);\n            if (unicodeMode) {\n                hex.append(c);\n                if (hex.length() == 4) {\n                    appendUnicode(hex, sb);\n                    hex.setLength(0);\n                    unicodeMode = false;\n                }\n            } else if (c == '\\\\') {\n                sb.append(input, last, i);\n                last = i + 1;\n                if (last >= length) {\n                    break;\n                }\n                char next = input.charAt(last);\n                if (next == 'u') {\n                    unicodeMode = true;\n                } else {\n                    sb.append(unescapeCsvChar(next));\n                    last++;\n                }\n            } else {\n                last = i;\n            }\n        }\n        if (last != length) {\n            sb.append(input.substring(last));\n        }\n        return sb.toString();\n    }\n\n    private static void appendUnicode(StringBuilder hex, StringBuilder sb) {\n        try {\n            int codepoint = Integer.parseInt(hex.toString(), 16);\n            sb.append(Character.toChars(codepoint));\n        } catch (NumberFormatException nfe) {\n            sb.append(\"\\\\u\").append(hex);\n        }\n    }\n\n    private static char unescapeCsvChar(char c) {\n        switch (c) {\n            case '\"':\n                return '\"';\n            case '\\'':\n            case '\\\\':\n            case '/':\n                return c;\n            case 'b':\n                return '\\b';\n            case 'f':\n                return '\\f';\n            case 'n':\n                return '\\n';\n            case 'r':\n                return '\\r';\n            case 't':\n                return '\\t';\n            default:\n                return c;\n        }\n    }\n\n    public final void translate(CharSequence input, Writer out) throws IOException {\n        if (out == null) {\n            throw new IllegalArgumentException(\"The Writer must not be null\");\n        }\n        if (input == null) {\n            return;\n        }\n        int pos = 0;\n        int len = input.length();\n        while (pos < len) {\n            int consumed = translate(input, pos, out);\n            if (consumed == 0) {\n                char[] c = Character.toChars(Character.codePointAt(input, pos));\n                out.write(c);\n                pos+= c.length;\n                continue;\n            }\n            for (int pt = 0; pt < consumed; pt++) {\n                pos += Character.charCount(Character.codePointAt(input, pos));\n            }\n        }\n    }\n    \n    \n    public static class CharSequenceTranslator {\n\n        public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n        public CharSequence translate(final CharSequence input) {\n            if (input == null) {\n                return null;\n            }\n            try {\n                final StringBuilder writer = new StringBuilder(input.length() * 2);\n                translate(input, writer);\n                return writer.toString();\n            } catch (final IOException ioe) {\n                throw new RuntimeException(ioe);\n            }\n        }\n\n        public abstract void translate(final CharSequence input, final Appendable out) throws IOException;\n\n        static class CsvEscaper extends CharSequenceTranslator {\n\n            @Override\n            public void translate(final CharSequence input, final Appendable out) throws IOException {\n                out.append(StringEscapeUtils.escapeCsv(input.toString()));\n            }\n        }\n    }\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010eaf..bb9cfba2 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -72,6 +72,163 @@ public abstract class CharSequenceTranslator {\n      * @param out Writer to translate the text to\n      * @throws IOException if and only if the Writer produces an IOException\n      */\n+import java.io.IOException;\n+import java.io.Writer;\n+import java.util.BitSet;\n+\n+public class StringEscapeUtils {\n+\n+    private static final BitSet CSV_SPECIAL_CHARS = new BitSet();\n+    private static final char CSV_DELIMITER = ',';\n+    private static final String CSV_QUOTE_STR = \"\\\"\";\n+    private static final char[] CSV_QUOTE = CSV_QUOTE_STR.toCharArray();\n+    private static final String CSV_QUOTE_ESCAPED_STR = CSV_QUOTE_STR + CSV_QUOTE_STR;\n+    private static final char[] CSV_QUOTE_ESCAPED = CSV_QUOTE_ESCAPED_STR.toCharArray();\n+    private static final String[] CSV_SEARCH_CHARS = new String[128];\n+\n+    static {\n+        CSV_SPECIAL_CHARS.set(0, CSV_DELIMITER + 1);\n+        CSV_SPECIAL_CHARS.set('\\n');\n+        CSV_SPECIAL_CHARS.set('\\r');\n+        CSV_SEARCH_CHARS['\\n'] = \"\\\\n\";\n+        CSV_SEARCH_CHARS['\\r'] = \"\\\\r\";\n+        CSV_SEARCH_CHARS[CSV_DELIMITER] = CSV_DELIMITER + \"\";\n+        CSV_SEARCH_CHARS['\"'] = CSV_QUOTE_ESCAPED_STR;\n+    }\n+\n+    public static String escapeCsv(String input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        int length = input.length();\n+        if (length == 0 || !containsSpecialCharacters(input)) {\n+            return input;\n+        }\n+        int upTo = 0;\n+        StringBuilder sb = new StringBuilder(length * 2);\n+        sb.append(CSV_QUOTE);\n+        for (int i = 0; i < length; i++) {\n+            char c = input.charAt(i);\n+            String escaped = c < 128 ? CSV_SEARCH_CHARS[c] : null;\n+            if (escaped == null && (c < Character.MIN_HIGH_SURROGATE || c > Character.MAX_LOW_SURROGATE)) {\n+                continue;\n+            }\n+            if (i > upTo) {\n+                sb.append(input, upTo, i);\n+            }\n+            upTo = i + 1;\n+            if (escaped == null) {\n+                appendHexified(c, sb);\n+            } else {\n+                sb.append(escaped);\n+            }\n+        }\n+        if (upTo < length) {\n+            sb.append(input, upTo, length);\n+        }\n+        sb.append(CSV_QUOTE);\n+        return sb.toString();\n+    }\n+\n+    private static boolean containsSpecialCharacters(CharSequence input) {\n+        for (int i = 0; i < input.length(); i++) {\n+            char c = input.charAt(i);\n+            if (c < CSV_SEARCH_CHARS.length && CSV_SPECIAL_CHARS.get(c)) {\n+                return true;\n+            }\n+            if (c >= Character.MIN_HIGH_SURROGATE && c <= Character.MAX_LOW_SURROGATE) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    private static void appendHexified(char c, StringBuilder sb) {\n+        sb.append(\"\\\\u\");\n+        String hex = Integer.toHexString(c);\n+        int pad = 4 - hex.length();\n+        for (int i = 0; i < pad; i++) {\n+            sb.append('0');\n+        }\n+        sb.append(hex);\n+    }\n+\n+    public static String unescapeCsv(String input) {\n+        if (input == null) {\n+            return null;\n+        }\n+        int length = input.length();\n+        if (length == 0 || input.indexOf('\\\\') == -1) {\n+            return input;\n+        }\n+        StringBuilder sb = new StringBuilder(length);\n+        StringBuilder hex = new StringBuilder(4);\n+        boolean unicodeMode = false;\n+        char last = 0;\n+        for (int i = 0; i < length; i++) {\n+            char c = input.charAt(i);\n+            if (unicodeMode) {\n+                hex.append(c);\n+                if (hex.length() == 4) {\n+                    appendUnicode(hex, sb);\n+                    hex.setLength(0);\n+                    unicodeMode = false;\n+                }\n+            } else if (c == '\\\\') {\n+                sb.append(input, last, i);\n+                last = i + 1;\n+                if (last >= length) {\n+                    break;\n+                }\n+                char next = input.charAt(last);\n+                if (next == 'u') {\n+                    unicodeMode = true;\n+                } else {\n+                    sb.append(unescapeCsvChar(next));\n+                    last++;\n+                }\n+            } else {\n+                last = i;\n+            }\n+        }\n+        if (last != length) {\n+            sb.append(input.substring(last));\n+        }\n+        return sb.toString();\n+    }\n+\n+    private static void appendUnicode(StringBuilder hex, StringBuilder sb) {\n+        try {\n+            int codepoint = Integer.parseInt(hex.toString(), 16);\n+            sb.append(Character.toChars(codepoint));\n+        } catch (NumberFormatException nfe) {\n+            sb.append(\"\\\\u\").append(hex);\n+        }\n+    }\n+\n+    private static char unescapeCsvChar(char c) {\n+        switch (c) {\n+            case '\"':\n+                return '\"';\n+            case '\\'':\n+            case '\\\\':\n+            case '/':\n+                return c;\n+            case 'b':\n+                return '\\b';\n+            case 'f':\n+                return '\\f';\n+            case 'n':\n+                return '\\n';\n+            case 'r':\n+                return '\\r';\n+            case 't':\n+                return '\\t';\n+            default:\n+                return c;\n+        }\n+    }\n+\n     public final void translate(CharSequence input, Writer out) throws IOException {\n         if (out == null) {\n             throw new IllegalArgumentException(\"The Writer must not be null\");\n@@ -89,13 +246,42 @@ public abstract class CharSequenceTranslator {\n                 pos+= c.length;\n                 continue;\n             }\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n                 pos += Character.charCount(Character.codePointAt(input, pos));\n             }\n         }\n     }\n+    \n+    \n+    public static class CharSequenceTranslator {\n+\n+        public static final CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n+\n+        public CharSequence translate(final CharSequence input) {\n+            if (input == null) {\n+                return null;\n+            }\n+            try {\n+                final StringBuilder writer = new StringBuilder(input.length() * 2);\n+                translate(input, writer);\n+                return writer.toString();\n+            } catch (final IOException ioe) {\n+                throw new RuntimeException(ioe);\n+            }\n+        }\n+\n+        public abstract void translate(final CharSequence input, final Appendable out) throws IOException;\n+\n+        static class CsvEscaper extends CharSequenceTranslator {\n+\n+            @Override\n+            public void translate(final CharSequence input, final Appendable out) throws IOException {\n+                out.append(StringEscapeUtils.escapeCsv(input.toString()));\n+            }\n+        }\n+    }\n+\n+}\n \n     /**\n      * Helper method to create a merger of this translator with another set of ",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}