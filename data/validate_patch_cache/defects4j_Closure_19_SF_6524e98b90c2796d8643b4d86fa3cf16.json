{
    "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  switch (node.getType()) {\n    case Token.NAME:\n      scope.inferSlotType(node.getString(), type);\n      break;\n\n    case Token.GETPROP:\n      String qualifiedName = node.getQualifiedName();\n      if (qualifiedName == null) {\n        throw new IllegalArgumentException(\"Cannot declare a null qualified name\");\n      }\n\n      JSType origType = node.getJSType();\n      if (origType == null) {\n        origType = getNativeType(UNKNOWN_TYPE);\n      }\n\n      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n      break;\n\n    case Token.THIS:\n      // Skip over any references to \"this\" since they aren't currently modeled in the CFG.\n      break;\n\n    default:\n      // Throw an exception if we encounter an unexpected node type to help with debugging.\n      throw new IllegalArgumentException(\"Unexpected node type in declareNameInScope: \" + node.getType());\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..33c6afa6 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,28 +154,35 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n-    switch (node.getType()) {\n-      case Token.NAME:\n-        scope.inferSlotType(node.getString(), type);\n-        break;\n+protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+  switch (node.getType()) {\n+    case Token.NAME:\n+      scope.inferSlotType(node.getString(), type);\n+      break;\n \n-      case Token.GETPROP:\n-        String qualifiedName = node.getQualifiedName();\n-        Preconditions.checkNotNull(qualifiedName);\n+    case Token.GETPROP:\n+      String qualifiedName = node.getQualifiedName();\n+      if (qualifiedName == null) {\n+        throw new IllegalArgumentException(\"Cannot declare a null qualified name\");\n+      }\n \n-        JSType origType = node.getJSType();\n-        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n-        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n-        break;\n+      JSType origType = node.getJSType();\n+      if (origType == null) {\n+        origType = getNativeType(UNKNOWN_TYPE);\n+      }\n \n-        // \"this\" references aren't currently modeled in the CFG.\n+      scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+      break;\n \n-      default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n-    }\n+    case Token.THIS:\n+      // Skip over any references to \"this\" since they aren't currently modeled in the CFG.\n+      break;\n+\n+    default:\n+      // Throw an exception if we encounter an unexpected node type to help with debugging.\n+      throw new IllegalArgumentException(\"Unexpected node type in declareNameInScope: \" + node.getType());\n   }\n+}\n \n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)",
    "result_reason": "all tests passed",
    "test_result": "PASS"
}