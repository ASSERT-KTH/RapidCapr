{
    "patch": "import org.apache.commons.math3.exception.MaxIterationsExceededException;\nimport org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\nimport org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\nimport org.apache.commons.math3.optim.univariate.BrentOptimizer;\nimport org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\nimport org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Precision;\n\npublic class MyOptimizer extends MultivariateOptimizer {\n    /** Golden section. */\n    private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n\n    /**\n     * Build a simplex from a starting point and a step.\n     *\n     * @param startPoint First point used to build the simplex.\n     * @param step Coordinates of the steps along each dimension.\n     * @return a simplex built from carefully chosen points\n     */\n    private static AbstractSimplex buildInitialSimplex(final double[] startPoint,\n                final double step) {\n        final int n = startPoint.length;\n        final double[][] tableau = new double[n + 1][n];\n        for (int i = 0; i < n; i++) {\n            tableau[0][i] = startPoint[i];\n        }\n\n        final double[] unitCoefficients = new double[n];\n        for (int i = 0; i < n; i++) {\n            unitCoefficients[i] = step;\n            final double[] target = new double[n];\n            target[i] = step;\n            tableau[i + 1] = startPoint.clone();\n            tableau[i + 1][i] += step;\n        }\n\n        return new NelderMeadSimplex(tableau);\n    }\n\n    /**\n     * Construct a simplex from a starting point and a bound on the variable step sizes.\n     *\n     * @param startPoint First point used to build the simplex.\n     * @param absoluteStepBound Coordinates of the maximum step in each dimension.\n     * @return a simplex built from carefully chosen points\n     */\n    private static AbstractSimplex buildBoundedSimplex(final double[] startPoint,\n                                                       final double[] absoluteStepBound) {\n        final int n = startPoint.length;\n        final double[][] tableau = new double[n + 1][n];\n        for (int i = 0; i < n; i++) {\n            tableau[0][i] = startPoint[i];\n        }\n\n        final double[] unitCoefficients = new double[n];\n        for (int i = 0; i < n; i++) {\n            unitCoefficients[i] = absoluteStepBound[i];\n            final double[] target = new double[n];\n            target[i] = absoluteStepBound[i];\n            tableau[i + 1] = startPoint.clone();\n            tableau[i + 1][i] += absoluteStepBound[i];\n        }\n\n        return new NelderMeadSimplex(tableau);\n    }\n\n    /**\n     * Use the simplex algorithm to find the minimum of a function.\n     *\n     * @param f Objective function.\n     * @param x0 Starting point.\n     * @return the point/value pair giving the minimum value of the function.\n     */\n    public UnivariatePointValuePair minimize(final UnivariateObjectiveFunction f,\n                                                final double x0)\n        throws MaxIterationsExceededException {\n        final BrentOptimizer opt = new BrentOptimizer(getRelativeThreshold(), getAbsoluteThreshold());\n        return opt.optimize(new ObjectiveFunction(x -> f.value(x)), GoalType.MINIMIZE, x0);\n    }\n\n    /**\n     * Use the simplex algorithm to find the minimum of a function.\n     *\n     * @param f Objective function.\n     * @param x0 Starting point.\n     * @return the point/value pair giving the minimum value of the function.\n     */\n    public UnivariatePointValuePair maximize(final UnivariateObjectiveFunction f,\n                                                final double x0)\n        throws MaxIterationsExceededException {\n        final BrentOptimizer opt = new BrentOptimizer(getRelativeThreshold(), getAbsoluteThreshold());\n        return opt.optimize(new ObjectiveFunction(x -> -f.value(x)), GoalType.MAXIMIZE, x0);\n    }\n\n    /**\n     * Use the simplex algorithm to find the minimum of a function.\n     *\n     * @param f Objective function.\n     * @param x0 Starting point.\n     * @param step Initial step size.\n     * @return the point/value pair giving the minimum value of the function.\n     */\n    public UnivariatePointValuePair minimize(final UnivariateObjectiveFunction f,\n                                           final double x0,\n                                           final double step) {\n        final AbstractSimplex simplex = buildInitialSimplex(new double[] { x0 }, step);\n        return optimizeInternal(simplex, new ObjectiveFunction(x -> f.value(x[0])),\n                                 GoalType.MINIMIZE, new double[] { x0 }, 0).getPoint();\n    }\n\n    /**\n     * Use the simplex algorithm to find the minimum of a function.\n     *\n     * @param f Objective function.\n     * @param x0 Starting point.\n     * @param absoluteStepBound Bound on the maximum step size.\n     * @return the point/value pair giving the minimum value of the function.\n     */\n    public UnivariatePointValuePair minimize(final UnivariateObjectiveFunction f,\n                                           final double x0,\n                                           final double absoluteStepBound) {\n        final double[] absStep = new double[] { absoluteStepBound };\n        final AbstractSimplex simplex = buildBoundedSimplex(new double[] { x0 }, absStep);\n        return optimizeInternal(simplex, new ObjectiveFunction(x -> f.value(x[0])),\n                                 GoalType.MINIMIZE, new double[] { x0 }, 0).getPoint();\n    }\n\n    /**\n     * Use the simplex algorithm to find the minimum of a function.\n     *\n     * @param startPoint Starting point.\n     * @param f Objective function.\n     * @return the point/value pair giving the minimum value of the function.\n     */\n    public UnivariatePointValuePair minimize(final double startPoint,\n                                           final UnivariateObjectiveFunction f) {\n        return minimize(f, startPoint, 0.1 * startPoint);\n    }\n\n    /**\n     * Use the simplex algorithm to optimize a function.\n     *\n     * @param f Objective function.\n     * @param startPoint Starting point.\n     * @return the point/value pair giving the minimum value of the function.\n     */\n    @Override\n    protected PointValuePair optimizeInternal(final ObjectiveFunction f,\n                                           final GoalType goalType,\n                                           final AbstractSimplex simplex,\n                                           final double[] startPoint)\n        throws MaxIterationsExceededException {\n        return optimizeInternal(simplex, f, goalType, startPoint, 0);\n    }\n\n    /**\n     * Use the simplex algorithm to optimize a function.\n     *\n     * @param f Objective function.\n     * @param startPoint Starting point.\n     * @param maxEval Maximum number of evaluations.\n     * @return the point/value pair giving the minimum value of the function.\n     */\n    public PointValuePair optimizeInternal(final ObjectiveFunction f,\n                                        final GoalTyp",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex b6ce68ef3..c234a99eb 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -106,170 +106,177 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariatePointValuePair doOptimize() {\n-        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n-        final double lo = getMin();\n-        final double mid = getStartValue();\n-        final double hi = getMax();\n+import org.apache.commons.math3.exception.MaxIterationsExceededException;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n+import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\n+import org.apache.commons.math3.optim.univariate.BrentOptimizer;\n+import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\n+import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n \n-        // Optional additional convergence criteria.\n-        final ConvergenceChecker<UnivariatePointValuePair> checker\n-            = getConvergenceChecker();\n+public class MyOptimizer extends MultivariateOptimizer {\n+    /** Golden section. */\n+    private static final double GOLDEN_SECTION = 0.5 * (3 - FastMath.sqrt(5));\n \n-        double a;\n-        double b;\n-        if (lo < hi) {\n-            a = lo;\n-            b = hi;\n-        } else {\n-            a = hi;\n-            b = lo;\n+    /**\n+     * Build a simplex from a starting point and a step.\n+     *\n+     * @param startPoint First point used to build the simplex.\n+     * @param step Coordinates of the steps along each dimension.\n+     * @return a simplex built from carefully chosen points\n+     */\n+    private static AbstractSimplex buildInitialSimplex(final double[] startPoint,\n+                final double step) {\n+        final int n = startPoint.length;\n+        final double[][] tableau = new double[n + 1][n];\n+        for (int i = 0; i < n; i++) {\n+            tableau[0][i] = startPoint[i];\n         }\n \n-        double x = mid;\n-        double v = x;\n-        double w = x;\n-        double d = 0;\n-        double e = 0;\n-        double fx = computeObjectiveValue(x);\n-        if (!isMinim) {\n-            fx = -fx;\n+        final double[] unitCoefficients = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            unitCoefficients[i] = step;\n+            final double[] target = new double[n];\n+            target[i] = step;\n+            tableau[i + 1] = startPoint.clone();\n+            tableau[i + 1][i] += step;\n         }\n-        double fv = fx;\n-        double fw = fx;\n-\n-        UnivariatePointValuePair previous = null;\n-        UnivariatePointValuePair current\n-            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-\n-        int iter = 0;\n-        while (true) {\n-            final double m = 0.5 * (a + b);\n-            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n-            final double tol2 = 2 * tol1;\n \n-            // Default stopping criterion.\n-            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n-            if (!stop) {\n-                double p = 0;\n-                double q = 0;\n-                double r = 0;\n-                double u = 0;\n-\n-                if (FastMath.abs(e) > tol1) { // Fit parabola.\n-                    r = (x - w) * (fx - fv);\n-                    q = (x - v) * (fx - fw);\n-                    p = (x - v) * q - (x - w) * r;\n-                    q = 2 * (q - r);\n+        return new NelderMeadSimplex(tableau);\n+    }\n \n-                    if (q > 0) {\n-                        p = -p;\n-                    } else {\n-                        q = -q;\n-                    }\n+    /**\n+     * Construct a simplex from a starting point and a bound on the variable step sizes.\n+     *\n+     * @param startPoint First point used to build the simplex.\n+     * @param absoluteStepBound Coordinates of the maximum step in each dimension.\n+     * @return a simplex built from carefully chosen points\n+     */\n+    private static AbstractSimplex buildBoundedSimplex(final double[] startPoint,\n+                                                       final double[] absoluteStepBound) {\n+        final int n = startPoint.length;\n+        final double[][] tableau = new double[n + 1][n];\n+        for (int i = 0; i < n; i++) {\n+            tableau[0][i] = startPoint[i];\n+        }\n \n-                    r = e;\n-                    e = d;\n+        final double[] unitCoefficients = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            unitCoefficients[i] = absoluteStepBound[i];\n+            final double[] target = new double[n];\n+            target[i] = absoluteStepBound[i];\n+            tableau[i + 1] = startPoint.clone();\n+            tableau[i + 1][i] += absoluteStepBound[i];\n+        }\n \n-                    if (p > q * (a - x) &&\n-                        p < q * (b - x) &&\n-                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n-                        // Parabolic interpolation step.\n-                        d = p / q;\n-                        u = x + d;\n+        return new NelderMeadSimplex(tableau);\n+    }\n \n-                        // f must not be evaluated too close to a or b.\n-                        if (u - a < tol2 || b - u < tol2) {\n-                            if (x <= m) {\n-                                d = tol1;\n-                            } else {\n-                                d = -tol1;\n-                            }\n-                        }\n-                    } else {\n-                        // Golden section step.\n-                        if (x < m) {\n-                            e = b - x;\n-                        } else {\n-                            e = a - x;\n-                        }\n-                        d = GOLDEN_SECTION * e;\n-                    }\n-                } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n-                }\n+    /**\n+     * Use the simplex algorithm to find the minimum of a function.\n+     *\n+     * @param f Objective function.\n+     * @param x0 Starting point.\n+     * @return the point/value pair giving the minimum value of the function.\n+     */\n+    public UnivariatePointValuePair minimize(final UnivariateObjectiveFunction f,\n+                                                final double x0)\n+        throws MaxIterationsExceededException {\n+        final BrentOptimizer opt = new BrentOptimizer(getRelativeThreshold(), getAbsoluteThreshold());\n+        return opt.optimize(new ObjectiveFunction(x -> f.value(x)), GoalType.MINIMIZE, x0);\n+    }\n \n-                // Update by at least \"tol1\".\n-                if (FastMath.abs(d) < tol1) {\n-                    if (d >= 0) {\n-                        u = x + tol1;\n-                    } else {\n-                        u = x - tol1;\n-                    }\n-                } else {\n-                    u = x + d;\n-                }\n+    /**\n+     * Use the simplex algorithm to find the minimum of a function.\n+     *\n+     * @param f Objective function.\n+     * @param x0 Starting point.\n+     * @return the point/value pair giving the minimum value of the function.\n+     */\n+    public UnivariatePointValuePair maximize(final UnivariateObjectiveFunction f,\n+                                                final double x0)\n+        throws MaxIterationsExceededException {\n+        final BrentOptimizer opt = new BrentOptimizer(getRelativeThreshold(), getAbsoluteThreshold());\n+        return opt.optimize(new ObjectiveFunction(x -> -f.value(x)), GoalType.MAXIMIZE, x0);\n+    }\n \n-                double fu = computeObjectiveValue(u);\n-                if (!isMinim) {\n-                    fu = -fu;\n-                }\n+    /**\n+     * Use the simplex algorithm to find the minimum of a function.\n+     *\n+     * @param f Objective function.\n+     * @param x0 Starting point.\n+     * @param step Initial step size.\n+     * @return the point/value pair giving the minimum value of the function.\n+     */\n+    public UnivariatePointValuePair minimize(final UnivariateObjectiveFunction f,\n+                                           final double x0,\n+                                           final double step) {\n+        final AbstractSimplex simplex = buildInitialSimplex(new double[] { x0 }, step);\n+        return optimizeInternal(simplex, new ObjectiveFunction(x -> f.value(x[0])),\n+                                 GoalType.MINIMIZE, new double[] { x0 }, 0).getPoint();\n+    }\n \n-                // User-defined convergence checker.\n-                previous = current;\n-                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+    /**\n+     * Use the simplex algorithm to find the minimum of a function.\n+     *\n+     * @param f Objective function.\n+     * @param x0 Starting point.\n+     * @param absoluteStepBound Bound on the maximum step size.\n+     * @return the point/value pair giving the minimum value of the function.\n+     */\n+    public UnivariatePointValuePair minimize(final UnivariateObjectiveFunction f,\n+                                           final double x0,\n+                                           final double absoluteStepBound) {\n+        final double[] absStep = new double[] { absoluteStepBound };\n+        final AbstractSimplex simplex = buildBoundedSimplex(new double[] { x0 }, absStep);\n+        return optimizeInternal(simplex, new ObjectiveFunction(x -> f.value(x[0])),\n+                                 GoalType.MINIMIZE, new double[] { x0 }, 0).getPoint();\n+    }\n \n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return current;\n-                    }\n-                }\n+    /**\n+     * Use the simplex algorithm to find the minimum of a function.\n+     *\n+     * @param startPoint Starting point.\n+     * @param f Objective function.\n+     * @return the point/value pair giving the minimum value of the function.\n+     */\n+    public UnivariatePointValuePair minimize(final double startPoint,\n+                                           final UnivariateObjectiveFunction f) {\n+        return minimize(f, startPoint, 0.1 * startPoint);\n+    }\n \n-                // Update a, b, v, w and x.\n-                if (fu <= fx) {\n-                    if (u < x) {\n-                        b = x;\n-                    } else {\n-                        a = x;\n-                    }\n-                    v = w;\n-                    fv = fw;\n-                    w = x;\n-                    fw = fx;\n-                    x = u;\n-                    fx = fu;\n-                } else {\n-                    if (u < x) {\n-                        a = u;\n-                    } else {\n-                        b = u;\n-                    }\n-                    if (fu <= fw ||\n-                        Precision.equals(w, x)) {\n-                        v = w;\n-                        fv = fw;\n-                        w = u;\n-                        fw = fu;\n-                    } else if (fu <= fv ||\n-                               Precision.equals(v, x) ||\n-                               Precision.equals(v, w)) {\n-                        v = u;\n-                        fv = fu;\n-                    }\n-                }\n-            } else { // Default termination (Brent's criterion).\n-                return current;\n-            }\n-            ++iter;\n-        }\n+    /**\n+     * Use the simplex algorithm to optimize a function.\n+     *\n+     * @param f Objective function.\n+     * @param startPoint Starting point.\n+     * @return the point/value pair giving the minimum value of the function.\n+     */\n+    @Override\n+    protected PointValuePair optimizeInternal(final ObjectiveFunction f,\n+                                           final GoalType goalType,\n+                                           final AbstractSimplex simplex,\n+                                           final double[] startPoint)\n+        throws MaxIterationsExceededException {\n+        return optimizeInternal(simplex, f, goalType, startPoint, 0);\n     }\n \n+    /**\n+     * Use the simplex algorithm to optimize a function.\n+     *\n+     * @param f Objective function.\n+     * @param startPoint Starting point.\n+     * @param maxEval Maximum number of evaluations.\n+     * @return the point/value pair giving the minimum value of the function.\n+     */\n+    public PointValuePair optimizeInternal(final ObjectiveFunction f,\n+                                        final GoalTyp\n+\n     /**\n      * Selects the best of two points.\n      *",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}