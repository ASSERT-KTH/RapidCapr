{
    "patch": "          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n          if (parent.getParent().isDelProp()) {\n            return false;\n          }\n          \n          if (parent.isQualifiedName() || parent.isName()) {\n            String propertyName = parent.getLastChild().getString();\n            if (!validProperties.contains(propertyName)) {\n              if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                validProperties.add(propertyName);\n              } else {\n                return false;\n              }\n            }\n          }\n\n          // Only simple accessor that directly access a property of\n          // a bare identifier are allowed.\n          // i.e. (obj | this).x\n          boolean isAllowableGettingProp = true;\n          if (parent.isGetProp()) {\n            if (parent.getFirstChild() != name) {\n              isAllowableGettingProp = false;\n            } else if (gramps == null) {\n              isAllowableGettingProp = parent != getRoot().getLastChild()\n                  && parent.getParent().isAssign()\n                  && parent.getPrevious() == null;\n            } else if (gramps.isGetProp()) {\n              isAllowableGettingProp = false;\n            } else if (gramps.isAssign()) {\n              Node assignParent = gramps.getParent();\n              isAllowableGettingProp = !assignParent.isExprResult()\n                  && (assignParent.isVar() || assignParent.isLet() || assignParent.isConst());\n            }\n          } else if (parent.isName()) {\n            if (gramps == null) {\n              isAllowableGettingProp = false;\n            } else if (gramps.isGetElem()) {\n              isAllowableGettingProp = false;\n            } else if (gramps.isAssign()) {\n              Node assignParent = gramps.getParent();\n              isAllowableGettingProp = !assignParent.isExprResult()\n                  && (assignParent.isVar() || assignParent.isLet() || assignParent.isConst());\n            }\n          }\n          if (!isAllowableGettingProp) {\n            return false;\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..2660a8f5 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,55 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+          // Deleting a property has different semantics from deleting\n+          // a variable, so deleted properties should not be inlined.\n+          if (parent.getParent().isDelProp()) {\n+            return false;\n+          }\n+          \n+          if (parent.isQualifiedName() || parent.isName()) {\n+            String propertyName = parent.getLastChild().getString();\n+            if (!validProperties.contains(propertyName)) {\n+              if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n+                validProperties.add(propertyName);\n+              } else {\n+                return false;\n+              }\n+            }\n+          }\n+\n+          // Only simple accessor that directly access a property of\n+          // a bare identifier are allowed.\n+          // i.e. (obj | this).x\n+          boolean isAllowableGettingProp = true;\n+          if (parent.isGetProp()) {\n+            if (parent.getFirstChild() != name) {\n+              isAllowableGettingProp = false;\n+            } else if (gramps == null) {\n+              isAllowableGettingProp = parent != getRoot().getLastChild()\n+                  && parent.getParent().isAssign()\n+                  && parent.getPrevious() == null;\n+            } else if (gramps.isGetProp()) {\n+              isAllowableGettingProp = false;\n+            } else if (gramps.isAssign()) {\n+              Node assignParent = gramps.getParent();\n+              isAllowableGettingProp = !assignParent.isExprResult()\n+                  && (assignParent.isVar() || assignParent.isLet() || assignParent.isConst());\n+            }\n+          } else if (parent.isName()) {\n+            if (gramps == null) {\n+              isAllowableGettingProp = false;\n+            } else if (gramps.isGetElem()) {\n+              isAllowableGettingProp = false;\n+            } else if (gramps.isAssign()) {\n+              Node assignParent = gramps.getParent();\n+              isAllowableGettingProp = !assignParent.isExprResult()\n+                  && (assignParent.isVar() || assignParent.isLet() || assignParent.isConst());\n+            }\n+          }\n+          if (!isAllowableGettingProp) {\n+            return false;\n+          }\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}