{
    "patch": "public class DfpTool {\n    private final static int RADIX = 10000;\n    private final static int[] TEN_POWER = {1, 10, 100, 1000};\n    private final static int ROUND_UP = 0;\n    private final static int ROUND_DOWN = 1;\n    private final static int ROUND_HALF_UP = 2;\n    private final static int ROUND_HALF_DOWN = 3;\n    private final static int ROUND_HALF_EVEN = 4;\n    private Dfp value;\n    \n    public DfpTool(int precision) {\n        value = new Dfp(precision);\n    }\n\n    public void setValue(Dfp x) {\n        value = x;\n    }\n\n    public void setZero() {\n        value = newInstance(0.0);\n    }\n\n    public void setOne() {\n        value = newInstance(1.0);\n    }\n\n    public void setMinusOne() {\n        value = newInstance(-1.0);\n    }\n\n    public void setNaN() {\n        value = newInstance(Double.NaN);\n    }\n\n    public void setInfinity() {\n        value = newInstance(Double.POSITIVE_INFINITY);\n    }\n\n    public void setNegInfinity() {\n        value = newInstance(Double.NEGATIVE_INFINITY);\n    }\n\n    public void setE() {\n        value = newInstance(Math.E);\n    }\n\n    public void setPi() {\n        value = newInstance(Math.PI);\n    }\n\n    public void setInternalValue(int x) {\n        value = newInstance(x);\n    }\n\n    public void setInternalValue(String s) {\n        value = newInstance(s);\n    }\n\n    public void setInternalValue(double x) {\n        value = newInstance(x);\n    }\n\n    public Dfp newInstance(double x) {\n        return new Dfp(x);\n    }\n\n    public Dfp newInstance(int x) {\n        return new Dfp(x);\n    }\n\n    public Dfp newInstance(String s) {\n        return new Dfp(s);\n    }\n\n    public String toString() {\n        return value.toString();\n    }\n\n    public boolean lessThan(Dfp x) {\n        return value.lessThan(x);\n    }\n\n    public boolean greaterThan(Dfp x) {\n        return value.greaterThan(x);\n    }\n\n    public boolean equals(Dfp x) {\n        return value.equals(x);\n    }\n\n    public boolean isNaN() {\n        return value.isNaN();\n    }\n\n    public boolean isQuietNaN() {\n        return value.isNaN() && value.getField().getQuietNan().equals(value);\n    }\n\n    public boolean isInfinite() {\n        return value.isInfinite();\n    }\n\n    public boolean isPositive() {\n        return value.greaterThan(newInstance(0.0));\n    }\n\n    public boolean isNegative() {\n        return value.lessThan(newInstance(0.0));\n    }\n\n    public boolean isZero() {\n        return value.equals(newInstance(0.0));\n    }\n\n    public Dfp negate() {\n        return value.negate();\n    }\n\n    public Dfp add(Dfp x) {\n        return value.add(x);\n    }\n\n    public Dfp subtract(Dfp x) {\n        return value.subtract(x);\n    }\n\n    public Dfp multiply(Dfp x) {\n        Dfp result;\n        if (isNaN(value) || isNaN(x)) {\n            result = newInstance(Double.NaN);\n        } else if (isInfinite() || x.isInfinite()) {\n            if (isInfinite() && x.isInfinite()) {\n                if (isNegative() == x.isNegative()) {\n                    result = newInstance(Double.POSITIVE_INFINITY);\n                } else {\n                    result = newInstance(Double.NEGATIVE_INFINITY);\n                }\n            } else {\n                result = newInstance(Double.POSITIVE_INFINITY);\n            }\n        } else {\n            result = value.multiply(x);\n        }\n        return result;\n    }\n\n    public Dfp multiply(final int x) {\n        Dfp result;\n        if (x >= 0 && x < RADIX) {\n            result = value.multiply(TEN_POWER[x % 4]);\n            result = result.multiply(newInstance(x / 4));\n        } else {\n            result = value.multiply(newInstance(x));\n        }\n        if (isNaN(result)) {\n            return newInstance(result.getField().getZero());\n        } else {\n            return result;\n        }\n    }\n\n    public Dfp divide(Dfp x) {\n        return value.divide(x);\n    }\n\n    public int signum() {\n        return value.signum();\n    }\n\n    public int ieeeFloor() {\n        return value.floor().intValue();\n    }\n\n    public int ieeeCeil() {\n        return value.ceil().intValue();\n    }\n\n    public int ieeeRound() {\n        return value.round().intValue();\n    }\n\n    public int getRoundingMode() {\n        int mode = value.getField().getRoundingMode();\n        switch(mode) {\n            case BigDecimal.ROUND_CEILING: \n                return ROUND_UP;\n            case BigDecimal.ROUND_FLOOR: \n                return ROUND_DOWN;\n            case BigDecimal.ROUND_HALF_UP: \n                return ROUND_HALF_UP;\n            case BigDecimal.ROUND_HALF_DOWN: \n                return ROUND_HALF_DOWN;\n            case BigDecimal.ROUND_HALF_EVEN: \n                return ROUND_HALF_EVEN;\n        }\n        return mode;\n    }\n\n    public void setRoundingMode(int mode) {\n        switch(mode) {\n            case ROUND_UP: \n                value.getField().setRoundingMode(BigDecimal.ROUND_CEILING);\n                break;\n            case ROUND_DOWN:\n                value.getField().setRoundingMode(BigDecimal.ROUND_FLOOR);\n                break;\n            case ROUND_HALF_UP:\n                value.getField().setRoundingMode(BigDecimal.ROUND_HALF_UP);\n                break;\n            case ROUND_HALF_DOWN:\n                value.getField().setRoundingMode(BigDecimal.ROUND_HALF_DOWN);\n                break;\n            case ROUND_HALF_EVEN:\n                value.getField().setRoundingMode(BigDecimal.ROUND_HALF_EVEN);\n                break;\n            default:\n                value.getField().setRoundingMode(mode);\n        }\n    }\n\n    public int intValue() {\n        return value.intValue();\n    }\n\n    public long longValue() {\n        return value.longValue();\n    }\n\n    public double doubleValue() {\n        return value.doubleValue();\n    }\n\n    public Dfp max(Dfp x) {\n        if (lessThan(x)) {\n            return x;\n        } else {\n            return value;\n        }\n    }\n\n    public Dfp min(Dfp x) {\n        if (lessThan(x)) {\n            return value;\n        } else {\n            return x;\n        }\n    }\n\n    public Dfp rint() {\n        return value.rint();\n    }\n\n    public Dfp exp() {\n        return value.exp();\n    }\n\n    public Dfp log() {\n        return value.log();\n    }\n\n    public Dfp log10() {\n        return value.log10();\n    }\n\n    public Dfp pow(int y) {\n        return value.pow(y);\n    }\n\n    public Dfp pow(Dfp y) {\n        return value.pow(y);\n    }\n\n    public Dfp sqrt() {\n        return value.sqrt();\n    }\n\n    public Dfp sin() {\n        return value.sin();\n    }\n\n    public Dfp cos() {\n        return value.cos();\n    }\n\n    public Dfp tan() {\n        return value.tan();\n    }\n\n    public Dfp asin() {\n        return value.asin();\n    }\n\n    public Dfp acos() {\n        return value.acos();\n    }\n\n    public Dfp atan() {\n        return value.atan();\n    }\n\n    public Dfp atan2(Dfp x) {\n        return value.atan2(x);\n    }\n\n    public Dfp sinh() {\n        return value.sinh();\n    }\n\n    public Dfp cosh() {\n        return value.cosh();\n    }\n\n    public Dfp tanh() {\n        return value.tanh();\n    }\n\n    public Dfp round(int roundingMode) {\n        return value.round(new MathContext(value.getRadix(), roundingMode));\n    }\n\n    public double percentageValue() {\n        Dfp product = multiply(newInstance(100));\n        if (product.isNaN()) {\n            return Double.NaN;\n        } else {\n            return product.doubleValue();\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/fraction/Fraction.java b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\nindex f84218ebd..fc41f5365 100644\n--- a/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n+++ b/src/main/java/org/apache/commons/math3/fraction/Fraction.java\n@@ -593,9 +593,335 @@ public class Fraction\n      *\n      * @return the fraction percentage as a <tt>double</tt>.\n      */\n+public class DfpTool {\n+    private final static int RADIX = 10000;\n+    private final static int[] TEN_POWER = {1, 10, 100, 1000};\n+    private final static int ROUND_UP = 0;\n+    private final static int ROUND_DOWN = 1;\n+    private final static int ROUND_HALF_UP = 2;\n+    private final static int ROUND_HALF_DOWN = 3;\n+    private final static int ROUND_HALF_EVEN = 4;\n+    private Dfp value;\n+    \n+    public DfpTool(int precision) {\n+        value = new Dfp(precision);\n+    }\n+\n+    public void setValue(Dfp x) {\n+        value = x;\n+    }\n+\n+    public void setZero() {\n+        value = newInstance(0.0);\n+    }\n+\n+    public void setOne() {\n+        value = newInstance(1.0);\n+    }\n+\n+    public void setMinusOne() {\n+        value = newInstance(-1.0);\n+    }\n+\n+    public void setNaN() {\n+        value = newInstance(Double.NaN);\n+    }\n+\n+    public void setInfinity() {\n+        value = newInstance(Double.POSITIVE_INFINITY);\n+    }\n+\n+    public void setNegInfinity() {\n+        value = newInstance(Double.NEGATIVE_INFINITY);\n+    }\n+\n+    public void setE() {\n+        value = newInstance(Math.E);\n+    }\n+\n+    public void setPi() {\n+        value = newInstance(Math.PI);\n+    }\n+\n+    public void setInternalValue(int x) {\n+        value = newInstance(x);\n+    }\n+\n+    public void setInternalValue(String s) {\n+        value = newInstance(s);\n+    }\n+\n+    public void setInternalValue(double x) {\n+        value = newInstance(x);\n+    }\n+\n+    public Dfp newInstance(double x) {\n+        return new Dfp(x);\n+    }\n+\n+    public Dfp newInstance(int x) {\n+        return new Dfp(x);\n+    }\n+\n+    public Dfp newInstance(String s) {\n+        return new Dfp(s);\n+    }\n+\n+    public String toString() {\n+        return value.toString();\n+    }\n+\n+    public boolean lessThan(Dfp x) {\n+        return value.lessThan(x);\n+    }\n+\n+    public boolean greaterThan(Dfp x) {\n+        return value.greaterThan(x);\n+    }\n+\n+    public boolean equals(Dfp x) {\n+        return value.equals(x);\n+    }\n+\n+    public boolean isNaN() {\n+        return value.isNaN();\n+    }\n+\n+    public boolean isQuietNaN() {\n+        return value.isNaN() && value.getField().getQuietNan().equals(value);\n+    }\n+\n+    public boolean isInfinite() {\n+        return value.isInfinite();\n+    }\n+\n+    public boolean isPositive() {\n+        return value.greaterThan(newInstance(0.0));\n+    }\n+\n+    public boolean isNegative() {\n+        return value.lessThan(newInstance(0.0));\n+    }\n+\n+    public boolean isZero() {\n+        return value.equals(newInstance(0.0));\n+    }\n+\n+    public Dfp negate() {\n+        return value.negate();\n+    }\n+\n+    public Dfp add(Dfp x) {\n+        return value.add(x);\n+    }\n+\n+    public Dfp subtract(Dfp x) {\n+        return value.subtract(x);\n+    }\n+\n+    public Dfp multiply(Dfp x) {\n+        Dfp result;\n+        if (isNaN(value) || isNaN(x)) {\n+            result = newInstance(Double.NaN);\n+        } else if (isInfinite() || x.isInfinite()) {\n+            if (isInfinite() && x.isInfinite()) {\n+                if (isNegative() == x.isNegative()) {\n+                    result = newInstance(Double.POSITIVE_INFINITY);\n+                } else {\n+                    result = newInstance(Double.NEGATIVE_INFINITY);\n+                }\n+            } else {\n+                result = newInstance(Double.POSITIVE_INFINITY);\n+            }\n+        } else {\n+            result = value.multiply(x);\n+        }\n+        return result;\n+    }\n+\n+    public Dfp multiply(final int x) {\n+        Dfp result;\n+        if (x >= 0 && x < RADIX) {\n+            result = value.multiply(TEN_POWER[x % 4]);\n+            result = result.multiply(newInstance(x / 4));\n+        } else {\n+            result = value.multiply(newInstance(x));\n+        }\n+        if (isNaN(result)) {\n+            return newInstance(result.getField().getZero());\n+        } else {\n+            return result;\n+        }\n+    }\n+\n+    public Dfp divide(Dfp x) {\n+        return value.divide(x);\n+    }\n+\n+    public int signum() {\n+        return value.signum();\n+    }\n+\n+    public int ieeeFloor() {\n+        return value.floor().intValue();\n+    }\n+\n+    public int ieeeCeil() {\n+        return value.ceil().intValue();\n+    }\n+\n+    public int ieeeRound() {\n+        return value.round().intValue();\n+    }\n+\n+    public int getRoundingMode() {\n+        int mode = value.getField().getRoundingMode();\n+        switch(mode) {\n+            case BigDecimal.ROUND_CEILING: \n+                return ROUND_UP;\n+            case BigDecimal.ROUND_FLOOR: \n+                return ROUND_DOWN;\n+            case BigDecimal.ROUND_HALF_UP: \n+                return ROUND_HALF_UP;\n+            case BigDecimal.ROUND_HALF_DOWN: \n+                return ROUND_HALF_DOWN;\n+            case BigDecimal.ROUND_HALF_EVEN: \n+                return ROUND_HALF_EVEN;\n+        }\n+        return mode;\n+    }\n+\n+    public void setRoundingMode(int mode) {\n+        switch(mode) {\n+            case ROUND_UP: \n+                value.getField().setRoundingMode(BigDecimal.ROUND_CEILING);\n+                break;\n+            case ROUND_DOWN:\n+                value.getField().setRoundingMode(BigDecimal.ROUND_FLOOR);\n+                break;\n+            case ROUND_HALF_UP:\n+                value.getField().setRoundingMode(BigDecimal.ROUND_HALF_UP);\n+                break;\n+            case ROUND_HALF_DOWN:\n+                value.getField().setRoundingMode(BigDecimal.ROUND_HALF_DOWN);\n+                break;\n+            case ROUND_HALF_EVEN:\n+                value.getField().setRoundingMode(BigDecimal.ROUND_HALF_EVEN);\n+                break;\n+            default:\n+                value.getField().setRoundingMode(mode);\n+        }\n+    }\n+\n+    public int intValue() {\n+        return value.intValue();\n+    }\n+\n+    public long longValue() {\n+        return value.longValue();\n+    }\n+\n+    public double doubleValue() {\n+        return value.doubleValue();\n+    }\n+\n+    public Dfp max(Dfp x) {\n+        if (lessThan(x)) {\n+            return x;\n+        } else {\n+            return value;\n+        }\n+    }\n+\n+    public Dfp min(Dfp x) {\n+        if (lessThan(x)) {\n+            return value;\n+        } else {\n+            return x;\n+        }\n+    }\n+\n+    public Dfp rint() {\n+        return value.rint();\n+    }\n+\n+    public Dfp exp() {\n+        return value.exp();\n+    }\n+\n+    public Dfp log() {\n+        return value.log();\n+    }\n+\n+    public Dfp log10() {\n+        return value.log10();\n+    }\n+\n+    public Dfp pow(int y) {\n+        return value.pow(y);\n+    }\n+\n+    public Dfp pow(Dfp y) {\n+        return value.pow(y);\n+    }\n+\n+    public Dfp sqrt() {\n+        return value.sqrt();\n+    }\n+\n+    public Dfp sin() {\n+        return value.sin();\n+    }\n+\n+    public Dfp cos() {\n+        return value.cos();\n+    }\n+\n+    public Dfp tan() {\n+        return value.tan();\n+    }\n+\n+    public Dfp asin() {\n+        return value.asin();\n+    }\n+\n+    public Dfp acos() {\n+        return value.acos();\n+    }\n+\n+    public Dfp atan() {\n+        return value.atan();\n+    }\n+\n+    public Dfp atan2(Dfp x) {\n+        return value.atan2(x);\n+    }\n+\n+    public Dfp sinh() {\n+        return value.sinh();\n+    }\n+\n+    public Dfp cosh() {\n+        return value.cosh();\n+    }\n+\n+    public Dfp tanh() {\n+        return value.tanh();\n+    }\n+\n+    public Dfp round(int roundingMode) {\n+        return value.round(new MathContext(value.getRadix(), roundingMode));\n+    }\n+\n     public double percentageValue() {\n-        return multiply(100).doubleValue();\n+        Dfp product = multiply(newInstance(100));\n+        if (product.isNaN()) {\n+            return Double.NaN;\n+        } else {\n+            return product.doubleValue();\n+        }\n     }\n+}\n \n     /**\n      * <p>Creates a {@code Fraction} instance with the 2 parts",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}