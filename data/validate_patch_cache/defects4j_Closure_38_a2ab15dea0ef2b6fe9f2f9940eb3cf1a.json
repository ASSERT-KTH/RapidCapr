{
    "patch": "void addNumber(double x) {\n    if (x == 0 && !Double.doubleToRawLongBits(x) < 0) {\n      add(\"0.0\");\n      return;\n    }\n\n    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n    // x--4 (which is a syntax error).\n    char prev = getLastChar();\n    boolean negativeZero = isNegativeZero(x);\n    if (x < 0 && prev == '-') {\n      add(\"(\");\n      addOp(Token.MINUS_UNARY);\n      addNumber(-x);\n      add(\")\");\n      return;\n    } else if (negativeZero) {\n      add(\"-0.0\");\n      return;\n    } else if (Double.isNaN(x)) {\n      add(\"NaN\");\n      return;\n    } else if (Double.isInfinite(x)) {\n      if (x < 0) {\n        add(\"-\");\n      }\n      add(\"Infinity\");\n      return;\n    }\n\n    // Disassemble the double as sign, exponent, mantissa\n    long bits = Double.doubleToRawLongBits(x);\n    boolean negative = (bits >>> 63) != 0;\n    int exponent = (int) ((bits >>> 52) & 0x7ffL);\n    long mantissa = bits & 0xfffffffffffffL;\n\n    if (exponent == 0 && mantissa == 0) {\n      add(\"0.0\");\n      return;\n    }\n\n    if (exponent == 0) {\n      // Denormal number -- renormalize it\n      while ((mantissa & (1L << 52)) == 0) {\n        mantissa <<= 1;\n        exponent--;\n      }\n      exponent++;\n      mantissa &= ~ (1L << 52);\n    } else {\n      mantissa |= (1L << 52);\n    }\n\n    // Find number of digits in exponent\n    String expstr;\n    if (exponent < 0) {\n      expstr = \"e-\" + String.format(\"%02d\", -exponent);\n    } else {\n      expstr = \"e+\" + String.format(\"%02d\", exponent);\n    }\n\n    // Convert mantissa to a string\n    // Convert to octal first, because it's easy to extract 3 bits from each octal digit\n    StringBuilder octal = new StringBuilder();\n    BigInteger bigmantissa = BigInteger.valueOf(mantissa);\n    while (bigmantissa != BigInteger.ZERO) {\n      BigInteger[] qr = bigmantissa.divideAndRemainder(BigInteger.valueOf(8));\n      bigmantissa = qr[0];\n      int val = qr[1].intValue();\n      octal.append((char) ('0' + val));\n    }\n\n    // Convert the octal string to a decimal string\n    StringBuilder decimal = new StringBuilder();\n    int octlen = octal.length();\n    int idx = octlen - 1;\n    int[] decimalDigits = new int[16*octlen];\n    int decimalLen = 0;\n    int[] decimalRounding = null;\n    boolean roundingDown = false;\n    int decimalPoint = 16*octlen;\n    while (idx >= 0 || decimalPoint >= -14) {\n      // Extract three bits from the octal string, starting from the right (LSB)\n      int val = (idx >= 0) ? octal.charAt(idx--) - '0' : 0;\n      int highBit = val & 4;\n      int midBit = val & 2;\n      int lowBit = val & 1;\n\n      // Multiply by 8\n      int carry = 0;\n      for (int i = decimalLen - 1; i >= 0; i--) {\n        int newdigit = decimalDigits[i] * 8 + carry;\n        carry = newdigit / 10;\n        decimalDigits[i] = newdigit % 10;\n      }\n      if (carry != 0) {\n        decimalDigits[0] = carry;\n        decimalLen++;\n      }\n\n      // Multiply the current number by 2 and add the next bit\n      carry = 0;\n      for (int i = 0; i < decimalLen; i++) {\n        int newdigit = decimalDigits[i] * 2 + carry;\n        if (newdigit >= 10) {\n          carry = 1;\n          newdigit = newdigit - 10;\n        } else {\n          carry = 0;\n        }\n        decimalDigits[i] = newdigit;\n      }\n      if (carry != 0) {\n        decimalDigits[decimalLen++] = 1;\n      }\n\n      // Add the bits from the octal digit, starting from the left (MSB)\n      if (highBit != 0) {\n        carry = 0;\n        for (int i = decimalLen - 1; i >= 0; i--) {\n          int newdigit = decimalDigits[i] + carry;\n          if (newdigit >= 10) {\n            carry = 1;\n            newdigit = newdigit - 10;\n          } else {\n            carry = 0;\n          }\n          decimalDigits[i] = newdigit;\n        }\n        if (carry != 0) {\n          decimalDigits[0] = 1;\n          decimalLen++;\n        }\n      }\n      if (midBit != 0) {\n        if (decimalPoint == 16*octlen) {\n          decimalPoint = decimalLen;\n        }\n        if (decimalRounding == null && lowBit != 0) {\n          decimalRounding = new int[decimalLen];\n          for (int i = 0; i < decimalLen; i++) {\n            decimalRounding[i] = decimalDigits[i];\n          }\n          roundingDown = true;\n        }\n      }\n    }\n\n    if (decimalRounding != null && (roundingDown ||\n        (decimalDigits[decimalPoint-1] & 1) != 0)) {\n      // We need to round up, so add 1 to the rounding digits and propagate the carry\n      int carry = 1;\n      for (int i = decimalLen - 1; i >= 0; i--) {\n        int digit = decimalRounding[i] + carry;\n        if (digit == 10) {\n          digit = 0;\n        } else {\n          carry = 0;\n        }\n        decimalRounding[i] = digit;\n      }\n      if (carry != 0) {\n        // We've carried all the way to the first digit\n        decimalDigits[0]++;\n        if (decimalDigits[0] == 10) {\n          // We need to add an extra digit at the front\n          decimalDigits[0] = 1;\n          for (int i = decimalLen - 1; i >= 0; i--) {\n            decimalDigits[i+1] = decimalDigits[i];\n          }\n          decimalLen++;\n          decimalPoint++;\n        }\n      }\n    }\n\n    // Convert the decimal to a string\n    if (decimalPoint >= 0) {\n      // Add digits after the decimal point\n      if (decimalRounding != null) {\n        decimalDigits = decimalRounding;\n        decimalLen = decimalRounding.length;\n      }\n      if (decimalPoint == decimalLen) {\n        decimal.append(\"0\");\n      }\n      for (int i = decimalLen - 1; i >= decimalPoint; i--) {\n        decimal.append((char) ('0' + decimalDigits[i]));\n      }\n      decimal.append(\".\");\n      if (decimalPoint == 0) {\n        decimal.append(\"0\");\n      }\n      for (int i = decimalPoint - 1; i >= 0; i--) {\n        decimal.append((char) ('0' + decimalDigits[i]));\n      }\n    } else {\n      // Add leading zeros and an optional decimal point\n      decimal.append(\"0.\");\n      for (int i = 0; i < -decimalPoint; i++) {\n        decimal.append(\"0\");\n      }\n      if (decimalRounding != null) {\n        decimalDigits = decimalRounding;\n        decimalLen = decimalRounding.length;\n      }\n      for (int i = decimalLen - 1; i >= 0; i--) {\n        decimal.append((char) ('0' + decimalDigits[i]));\n      }\n    }\n    add(negative ? \"-\" : \"\");\n    add(decimal.toString());\n    add(expstr);\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeConsumer.java b/src/com/google/javascript/jscomp/CodeConsumer.java\nindex 4381487c..426b5223 100644\n--- a/src/com/google/javascript/jscomp/CodeConsumer.java\n+++ b/src/com/google/javascript/jscomp/CodeConsumer.java\n@@ -236,13 +236,225 @@ abstract class CodeConsumer {\n       maybeCutLine();\n     }\n   }\n-\n   void addNumber(double x) {\n     // This is not pretty printing. This is to prevent misparsing of x- -4 as\n     // x--4 (which is a syntax error).\n     char prev = getLastChar();\n     boolean negativeZero = isNegativeZero(x);\n+void addNumber(double x) {\n+    if (x == 0 && !Double.doubleToRawLongBits(x) < 0) {\n+      add(\"0.0\");\n+      return;\n+    }\n+\n+    // This is not pretty printing. This is to prevent misparsing of x- -4 as\n+    // x--4 (which is a syntax error).\n+    char prev = getLastChar();\n+    boolean negativeZero = isNegativeZero(x);\n     if (x < 0 && prev == '-') {\n+      add(\"(\");\n+      addOp(Token.MINUS_UNARY);\n+      addNumber(-x);\n+      add(\")\");\n+      return;\n+    } else if (negativeZero) {\n+      add(\"-0.0\");\n+      return;\n+    } else if (Double.isNaN(x)) {\n+      add(\"NaN\");\n+      return;\n+    } else if (Double.isInfinite(x)) {\n+      if (x < 0) {\n+        add(\"-\");\n+      }\n+      add(\"Infinity\");\n+      return;\n+    }\n+\n+    // Disassemble the double as sign, exponent, mantissa\n+    long bits = Double.doubleToRawLongBits(x);\n+    boolean negative = (bits >>> 63) != 0;\n+    int exponent = (int) ((bits >>> 52) & 0x7ffL);\n+    long mantissa = bits & 0xfffffffffffffL;\n+\n+    if (exponent == 0 && mantissa == 0) {\n+      add(\"0.0\");\n+      return;\n+    }\n+\n+    if (exponent == 0) {\n+      // Denormal number -- renormalize it\n+      while ((mantissa & (1L << 52)) == 0) {\n+        mantissa <<= 1;\n+        exponent--;\n+      }\n+      exponent++;\n+      mantissa &= ~ (1L << 52);\n+    } else {\n+      mantissa |= (1L << 52);\n+    }\n+\n+    // Find number of digits in exponent\n+    String expstr;\n+    if (exponent < 0) {\n+      expstr = \"e-\" + String.format(\"%02d\", -exponent);\n+    } else {\n+      expstr = \"e+\" + String.format(\"%02d\", exponent);\n+    }\n+\n+    // Convert mantissa to a string\n+    // Convert to octal first, because it's easy to extract 3 bits from each octal digit\n+    StringBuilder octal = new StringBuilder();\n+    BigInteger bigmantissa = BigInteger.valueOf(mantissa);\n+    while (bigmantissa != BigInteger.ZERO) {\n+      BigInteger[] qr = bigmantissa.divideAndRemainder(BigInteger.valueOf(8));\n+      bigmantissa = qr[0];\n+      int val = qr[1].intValue();\n+      octal.append((char) ('0' + val));\n+    }\n+\n+    // Convert the octal string to a decimal string\n+    StringBuilder decimal = new StringBuilder();\n+    int octlen = octal.length();\n+    int idx = octlen - 1;\n+    int[] decimalDigits = new int[16*octlen];\n+    int decimalLen = 0;\n+    int[] decimalRounding = null;\n+    boolean roundingDown = false;\n+    int decimalPoint = 16*octlen;\n+    while (idx >= 0 || decimalPoint >= -14) {\n+      // Extract three bits from the octal string, starting from the right (LSB)\n+      int val = (idx >= 0) ? octal.charAt(idx--) - '0' : 0;\n+      int highBit = val & 4;\n+      int midBit = val & 2;\n+      int lowBit = val & 1;\n+\n+      // Multiply by 8\n+      int carry = 0;\n+      for (int i = decimalLen - 1; i >= 0; i--) {\n+        int newdigit = decimalDigits[i] * 8 + carry;\n+        carry = newdigit / 10;\n+        decimalDigits[i] = newdigit % 10;\n+      }\n+      if (carry != 0) {\n+        decimalDigits[0] = carry;\n+        decimalLen++;\n+      }\n+\n+      // Multiply the current number by 2 and add the next bit\n+      carry = 0;\n+      for (int i = 0; i < decimalLen; i++) {\n+        int newdigit = decimalDigits[i] * 2 + carry;\n+        if (newdigit >= 10) {\n+          carry = 1;\n+          newdigit = newdigit - 10;\n+        } else {\n+          carry = 0;\n+        }\n+        decimalDigits[i] = newdigit;\n+      }\n+      if (carry != 0) {\n+        decimalDigits[decimalLen++] = 1;\n+      }\n+\n+      // Add the bits from the octal digit, starting from the left (MSB)\n+      if (highBit != 0) {\n+        carry = 0;\n+        for (int i = decimalLen - 1; i >= 0; i--) {\n+          int newdigit = decimalDigits[i] + carry;\n+          if (newdigit >= 10) {\n+            carry = 1;\n+            newdigit = newdigit - 10;\n+          } else {\n+            carry = 0;\n+          }\n+          decimalDigits[i] = newdigit;\n+        }\n+        if (carry != 0) {\n+          decimalDigits[0] = 1;\n+          decimalLen++;\n+        }\n+      }\n+      if (midBit != 0) {\n+        if (decimalPoint == 16*octlen) {\n+          decimalPoint = decimalLen;\n+        }\n+        if (decimalRounding == null && lowBit != 0) {\n+          decimalRounding = new int[decimalLen];\n+          for (int i = 0; i < decimalLen; i++) {\n+            decimalRounding[i] = decimalDigits[i];\n+          }\n+          roundingDown = true;\n+        }\n+      }\n+    }\n+\n+    if (decimalRounding != null && (roundingDown ||\n+        (decimalDigits[decimalPoint-1] & 1) != 0)) {\n+      // We need to round up, so add 1 to the rounding digits and propagate the carry\n+      int carry = 1;\n+      for (int i = decimalLen - 1; i >= 0; i--) {\n+        int digit = decimalRounding[i] + carry;\n+        if (digit == 10) {\n+          digit = 0;\n+        } else {\n+          carry = 0;\n+        }\n+        decimalRounding[i] = digit;\n+      }\n+      if (carry != 0) {\n+        // We've carried all the way to the first digit\n+        decimalDigits[0]++;\n+        if (decimalDigits[0] == 10) {\n+          // We need to add an extra digit at the front\n+          decimalDigits[0] = 1;\n+          for (int i = decimalLen - 1; i >= 0; i--) {\n+            decimalDigits[i+1] = decimalDigits[i];\n+          }\n+          decimalLen++;\n+          decimalPoint++;\n+        }\n+      }\n+    }\n+\n+    // Convert the decimal to a string\n+    if (decimalPoint >= 0) {\n+      // Add digits after the decimal point\n+      if (decimalRounding != null) {\n+        decimalDigits = decimalRounding;\n+        decimalLen = decimalRounding.length;\n+      }\n+      if (decimalPoint == decimalLen) {\n+        decimal.append(\"0\");\n+      }\n+      for (int i = decimalLen - 1; i >= decimalPoint; i--) {\n+        decimal.append((char) ('0' + decimalDigits[i]));\n+      }\n+      decimal.append(\".\");\n+      if (decimalPoint == 0) {\n+        decimal.append(\"0\");\n+      }\n+      for (int i = decimalPoint - 1; i >= 0; i--) {\n+        decimal.append((char) ('0' + decimalDigits[i]));\n+      }\n+    } else {\n+      // Add leading zeros and an optional decimal point\n+      decimal.append(\"0.\");\n+      for (int i = 0; i < -decimalPoint; i++) {\n+        decimal.append(\"0\");\n+      }\n+      if (decimalRounding != null) {\n+        decimalDigits = decimalRounding;\n+        decimalLen = decimalRounding.length;\n+      }\n+      for (int i = decimalLen - 1; i >= 0; i--) {\n+        decimal.append((char) ('0' + decimalDigits[i]));\n+      }\n+    }\n+    add(negative ? \"-\" : \"\");\n+    add(decimal.toString());\n+    add(expstr);\n+  }\n       add(\" \");\n     }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}