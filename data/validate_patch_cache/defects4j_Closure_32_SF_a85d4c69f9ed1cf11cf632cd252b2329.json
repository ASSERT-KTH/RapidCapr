{
    "patch": "private Node rewriteExtends(Node classNode) {\n  Node extendsNode = NodeUtil.getFirstPropMatchingKey(classNode, Token.EXTENDS);\n\n  if (extendsNode == null) {\n    return classNode;\n  }\n\n  Node superClassExpression = extendsNode.getLastChild();\n  if (superClassExpression == null) {\n    return classNode;\n  }\n\n  Node block = NodeUtil.getEnclosingBlock(superClassExpression);\n  if (block == null) {\n    return classNode;\n  }\n\n  Node enclosingFunction = NodeUtil.getEnclosingFunction(block);\n  if (enclosingFunction == null || !enclosingFunction.isArrowFunction()) {\n    return classNode;\n  }\n\n  Node enclosingBlock = NodeUtil.getEnclosingBlock(classNode);\n  List<Node> superCalls = NodeUtil.findAllSuperCalls(enclosingBlock);\n  if (superCalls.isEmpty()) {\n    return classNode;\n  }\n\n  Node firstSuperCall = superCalls.get(0);\n  int insertionPoint = classNode.getIndexOfChild(firstSuperCall.getParent().getParent());\n  if (insertionPoint == -1) {\n    return classNode;\n  }\n\n  Node newDeclaration = classNode.cloneNode();\n  newDeclaration.putBooleanProp(Node.CONSTANT_NAME, false);\n\n  Node superCallArgList = firstSuperCall.getLastChild();\n  if (superClassExpression.isName()) {\n    String superClass = superClassExpression.getQualifiedName();\n    Node thisDotCall =\n        NodeUtil.newQName(firstSuperCall.getLineno(), firstSuperCall.getCharno(), \"this.call\");\n    Node newSuperCall = new Node(Token.NEW, new Node(Token.FUNCTION, thisDotCall));\n    newSuperCall.putBooleanProp(Node.NEW_TARGET, true);\n\n    Node fn = newSuperCall.getLastChild();\n\n    Node superMethod = new Node(Token.MEMBER_FUNCTION_DEF, NodeUtil.newQNameToken(\"super\", block));\n    superMethod.addChildToFront(\n        new Node(Token.PARAM_LIST, Node.newString(Token.NAME, \"args\").setName(\"args\")));\n    superMethod.putBooleanProp(Node.COMPUTED_PROP, true);\n    fn.addChildToFront(superMethod);\n    fn.addChildToFront(new Node(Token.THIS));\n    fn.addChildToBack(new Node(Token.BLOCK));\n\n    for (Node call : superCalls) {\n      Node superPropAccess =\n          NodeUtil.newQName(\n              call.getLineno(),\n              call.getCharno(),\n              getSuperMethodName(call.getParent(), superClass));\n\n      Node callSite = NodeUtil.newQName(call.getLineno(), call.getCharno(), \"call\");\n\n      Node superCall =\n          new Node(Token.CALL, new Node(Token.GETPROP, newSuperCall, superPropAccess));\n      superCall.addChildToBack(new Node(Token.THIS));\n      superCall.addChildToBack(\n          new Node(Token.GETELEM, new Node(Token.NAME, \"args\"), call.getParent().getLastChild()));\n      superCall.addChildToBack(thisDotCall.cloneTree());\n      fn.getLastChild().addChildToBack(superCall);\n      call.replaceWith(new Node(Token.CALL, new Node(Token.GETPROP, superCall, callSite), superCallArgList));\n    }\n\n    newDeclaration.removeChild(extendsNode); // Remove the EXTENDS clause\n    newDeclaration.addChildToFront(new Node(Token.CALL, newSuperCall, superCallArgList));\n  } else {\n    // Rewrite the extends clause\n    Node superClassDef =\n        new Node(\n            Token.FUNCTION,\n            superClassExpression.detach(),\n            new Node(Token.PARAM_LIST),\n            new Node(Token.BLOCK));\n\n    superClassDef.getLastChild().addChildToFront(\n        new Node(Token.RETURN, superClassExpression.cloneTree()));\n\n    Node createDelegate =\n        IR.call(\n            IR.getprop(IR.name(\"goog$inherits\"), IR.string(\"_unused\")),\n            IR.name(newDeclaration.getFirstChild().getQualifiedName()));\n\n    newDeclaration.getFirstChild().getLastChild().addChildToFront(superClassDef);\n    newDeclaration.getFirstChild().getLastChild().addChildToBack(createDelegate);\n\n    // Replace all super calls with the new syntax\n    for (Node call : superCalls) {\n      Node newSuperCall =\n          IR.call(\n              IR.getprop(IR.name(\"Object\"), IR.string(\"getPrototypeOf\")),\n              IR.name(\"constructor\"),\n              superCallArgList.cloneNode());\n\n      call.replaceWith(newSuperCall);\n    }\n  }\n\n  // Insert new class declaration into a new function, and insert the\n  // function before the declaring function.\n  Node enclosingFunctionBlock = enclosingFunction.getLastChild();\n  Node declarationParent = classNode.getParent();\n\n  Node newFunction =\n      NodeUtil.getEnclosingFunction(enclosingFunctionBlock.getParent()).cloneNode();\n  Node newBlock = new Node(Token.BLOCK).addChildrenToFront(newDeclaration);\n  newFunction.getLastChild().addChildToBack(newBlock);\n\n  newFunction\n      .getFirstChild()\n      .replaceChild(\n          enclosingFunctionBlock,\n          enclosingFunctionBlock.cloneNode().addChildrenToFront(newFunction.getLastChild()));\n\n  declarationParent.addChildBefore(newFunction, enclosingFunctionBlock.getParent());\n\n  // Remove the old class declaration.\n  declarationParent.removeChild(classNode);\n\n  return newDeclaration;\n}\n\n// Helper function to generate a unique name for the super method\nprivate String getSuperMethodName(Node callNode, String superClass) {\n  String functionName = NodeUtil.getNearestFunctionName(callNode);\n  int uniqueId = callNode.hashCode();\n  return String.format(\"%s$s%s$super\", superClass.replace('.', '$'), functionName, uniqueId);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex f6a64007..cf1a6142 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1326,107 +1326,144 @@ public final class JsDocInfoParser {\n    * @return The extraction information.\n    */\n   @SuppressWarnings(\"fallthrough\")\n-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n-                                                      WhitespaceOption option) {\n+private Node rewriteExtends(Node classNode) {\n+  Node extendsNode = NodeUtil.getFirstPropMatchingKey(classNode, Token.EXTENDS);\n \n-    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n-        token == JsDocToken.EOF) {\n-      return new ExtractionInfo(\"\", token);\n-    }\n+  if (extendsNode == null) {\n+    return classNode;\n+  }\n \n-    stream.update();\n-    int startLineno = stream.getLineno();\n-    int startCharno = stream.getCharno() + 1;\n+  Node superClassExpression = extendsNode.getLastChild();\n+  if (superClassExpression == null) {\n+    return classNode;\n+  }\n \n-    // Read the content from the first line.\n-    String line = stream.getRemainingJSDocLine();\n-    if (option != WhitespaceOption.PRESERVE) {\n-      line = line.trim();\n-    }\n+  Node block = NodeUtil.getEnclosingBlock(superClassExpression);\n+  if (block == null) {\n+    return classNode;\n+  }\n \n-    StringBuilder builder = new StringBuilder();\n-    builder.append(line);\n+  Node enclosingFunction = NodeUtil.getEnclosingFunction(block);\n+  if (enclosingFunction == null || !enclosingFunction.isArrowFunction()) {\n+    return classNode;\n+  }\n \n-    state = State.SEARCHING_ANNOTATION;\n-    token = next();\n+  Node enclosingBlock = NodeUtil.getEnclosingBlock(classNode);\n+  List<Node> superCalls = NodeUtil.findAllSuperCalls(enclosingBlock);\n+  if (superCalls.isEmpty()) {\n+    return classNode;\n+  }\n \n-    boolean ignoreStar = false;\n+  Node firstSuperCall = superCalls.get(0);\n+  int insertionPoint = classNode.getIndexOfChild(firstSuperCall.getParent().getParent());\n+  if (insertionPoint == -1) {\n+    return classNode;\n+  }\n \n-    // Track the start of the line to count whitespace that\n-    // the tokenizer skipped. Because this case is rare, it's easier\n-    // to do this here than in the tokenizer.\n+  Node newDeclaration = classNode.cloneNode();\n+  newDeclaration.putBooleanProp(Node.CONSTANT_NAME, false);\n \n-    do {\n-      switch (token) {\n-        case STAR:\n-          if (ignoreStar) {\n-            // Mark the position after the star as the new start of the line.\n-          } else {\n-            // The star is part of the comment.\n-            if (builder.length() > 0) {\n-              builder.append(' ');\n-            }\n+  Node superCallArgList = firstSuperCall.getLastChild();\n+  if (superClassExpression.isName()) {\n+    String superClass = superClassExpression.getQualifiedName();\n+    Node thisDotCall =\n+        NodeUtil.newQName(firstSuperCall.getLineno(), firstSuperCall.getCharno(), \"this.call\");\n+    Node newSuperCall = new Node(Token.NEW, new Node(Token.FUNCTION, thisDotCall));\n+    newSuperCall.putBooleanProp(Node.NEW_TARGET, true);\n \n-            builder.append('*');\n-          }\n+    Node fn = newSuperCall.getLastChild();\n \n-          token = next();\n-          continue;\n+    Node superMethod = new Node(Token.MEMBER_FUNCTION_DEF, NodeUtil.newQNameToken(\"super\", block));\n+    superMethod.addChildToFront(\n+        new Node(Token.PARAM_LIST, Node.newString(Token.NAME, \"args\").setName(\"args\")));\n+    superMethod.putBooleanProp(Node.COMPUTED_PROP, true);\n+    fn.addChildToFront(superMethod);\n+    fn.addChildToFront(new Node(Token.THIS));\n+    fn.addChildToBack(new Node(Token.BLOCK));\n \n-        case EOL:\n-          if (option != WhitespaceOption.SINGLE_LINE) {\n-            builder.append(\"\\n\");\n-          }\n+    for (Node call : superCalls) {\n+      Node superPropAccess =\n+          NodeUtil.newQName(\n+              call.getLineno(),\n+              call.getCharno(),\n+              getSuperMethodName(call.getParent(), superClass));\n \n-          ignoreStar = true;\n-          token = next();\n-          continue;\n-\n-        default:\n-          ignoreStar = false;\n-          state = State.SEARCHING_ANNOTATION;\n+      Node callSite = NodeUtil.newQName(call.getLineno(), call.getCharno(), \"call\");\n \n-              // All tokens must be separated by a space.\n-\n-          if (token == JsDocToken.EOC ||\n-              token == JsDocToken.EOF ||\n-              // When we're capturing a license block, annotations\n-              // in the block are ok.\n-              (token == JsDocToken.ANNOTATION &&\n-               option != WhitespaceOption.PRESERVE)) {\n-            String multilineText = builder.toString();\n+      Node superCall =\n+          new Node(Token.CALL, new Node(Token.GETPROP, newSuperCall, superPropAccess));\n+      superCall.addChildToBack(new Node(Token.THIS));\n+      superCall.addChildToBack(\n+          new Node(Token.GETELEM, new Node(Token.NAME, \"args\"), call.getParent().getLastChild()));\n+      superCall.addChildToBack(thisDotCall.cloneTree());\n+      fn.getLastChild().addChildToBack(superCall);\n+      call.replaceWith(new Node(Token.CALL, new Node(Token.GETPROP, superCall, callSite), superCallArgList));\n+    }\n \n-            if (option != WhitespaceOption.PRESERVE) {\n-              multilineText = multilineText.trim();\n-            }\n+    newDeclaration.removeChild(extendsNode); // Remove the EXTENDS clause\n+    newDeclaration.addChildToFront(new Node(Token.CALL, newSuperCall, superCallArgList));\n+  } else {\n+    // Rewrite the extends clause\n+    Node superClassDef =\n+        new Node(\n+            Token.FUNCTION,\n+            superClassExpression.detach(),\n+            new Node(Token.PARAM_LIST),\n+            new Node(Token.BLOCK));\n+\n+    superClassDef.getLastChild().addChildToFront(\n+        new Node(Token.RETURN, superClassExpression.cloneTree()));\n+\n+    Node createDelegate =\n+        IR.call(\n+            IR.getprop(IR.name(\"goog$inherits\"), IR.string(\"_unused\")),\n+            IR.name(newDeclaration.getFirstChild().getQualifiedName()));\n+\n+    newDeclaration.getFirstChild().getLastChild().addChildToFront(superClassDef);\n+    newDeclaration.getFirstChild().getLastChild().addChildToBack(createDelegate);\n+\n+    // Replace all super calls with the new syntax\n+    for (Node call : superCalls) {\n+      Node newSuperCall =\n+          IR.call(\n+              IR.getprop(IR.name(\"Object\"), IR.string(\"getPrototypeOf\")),\n+              IR.name(\"constructor\"),\n+              superCallArgList.cloneNode());\n+\n+      call.replaceWith(newSuperCall);\n+    }\n+  }\n \n-            int endLineno = stream.getLineno();\n-            int endCharno = stream.getCharno();\n+  // Insert new class declaration into a new function, and insert the\n+  // function before the declaring function.\n+  Node enclosingFunctionBlock = enclosingFunction.getLastChild();\n+  Node declarationParent = classNode.getParent();\n \n-            if (multilineText.length() > 0) {\n-              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n-                  endLineno, endCharno);\n-            }\n+  Node newFunction =\n+      NodeUtil.getEnclosingFunction(enclosingFunctionBlock.getParent()).cloneNode();\n+  Node newBlock = new Node(Token.BLOCK).addChildrenToFront(newDeclaration);\n+  newFunction.getLastChild().addChildToBack(newBlock);\n \n-            return new ExtractionInfo(multilineText, token);\n-          }\n+  newFunction\n+      .getFirstChild()\n+      .replaceChild(\n+          enclosingFunctionBlock,\n+          enclosingFunctionBlock.cloneNode().addChildrenToFront(newFunction.getLastChild()));\n \n-          if (builder.length() > 0) {\n-            builder.append(' ');\n-          }\n-          builder.append(toString(token));\n+  declarationParent.addChildBefore(newFunction, enclosingFunctionBlock.getParent());\n \n-          line = stream.getRemainingJSDocLine();\n+  // Remove the old class declaration.\n+  declarationParent.removeChild(classNode);\n \n-          if (option != WhitespaceOption.PRESERVE) {\n-            line = trimEnd(line);\n-          }\n+  return newDeclaration;\n+}\n \n-          builder.append(line);\n-          token = next();\n-      }\n-    } while (true);\n-  }\n+// Helper function to generate a unique name for the super method\n+private String getSuperMethodName(Node callNode, String superClass) {\n+  String functionName = NodeUtil.getNearestFunctionName(callNode);\n+  int uniqueId = callNode.hashCode();\n+  return String.format(\"%s$s%s$super\", superClass.replace('.', '$'), functionName, uniqueId);\n+}\n \n \n   /**",
    "result_reason": "error: method extractMultilineTextualBlock in class JsDocInfoParser cannot be applied to given types;",
    "test_result": "ERROR"
}