{
    "patch": "private void tryMinimizeIfBlockExits(Node trueBlock,\n                                      Node falseBlock,\n                                      Node parentIfNode,\n                                      int exitType,\n                                      String labelName) {\n\n    Label parentLabel = null;\n    if (NodeUtil.isLabelName(parentIfNode.getFirstChild(), labelName)) {\n      // If the node is a label, get the parent node\n      parentLabel = NodeUtil.getEnclosingLabel(parentIfNode);\n      parentIfNode = NodeUtil.getFunctionBody(parentLabel.getParent());\n      trueBlock = parentLabel;\n    }\n\n    // Assume \"if (condition) { trueBlock } else { falseBlock }\"\n\n    // Just a single 'exit' in the true block.\n    if (matchingExitNode(trueBlock, exitType, labelName) &&\n        !matchingExitNode(falseBlock, exitType, labelName)) {\n      // Example, \"if (blah) { return x } else { ... }\"\n      String statement = trueBlock.getLastChild().getFirstChild().toString();\n      // Add '!' if appropriate.\n      boolean assertCondition = !NodeUtil.isBooleanValue(parentIfNode.getFirstChild());\n      addConditionalStatement(parentIfNode, statement, assertCondition);\n      NodeUtil.removeChild(trueBlock.getParent(), trueBlock);\n      return;\n    }\n\n    // Just a single 'exit' in the false block.\n    if (matchingExitNode(falseBlock, exitType, labelName) &&\n        !matchingExitNode(trueBlock, exitType, labelName)) {\n      // Example, \"if (blah) { ... } else { return x }\"\n      String statement = falseBlock.getLastChild().getFirstChild().toString();\n      // Add '!' if appropriate.\n      boolean assertCondition = NodeUtil.isBooleanValue(parentIfNode.getFirstChild());\n      addConditionalStatement(parentIfNode, statement, assertCondition);\n      NodeUtil.removeChild(falseBlock.getParent(), falseBlock);\n      return;\n    }\n\n    if (allPathsReturnOrThrow(trueBlock, exitType, labelName) &&\n        allPathsReturnOrThrow(falseBlock, exitType, labelName)) {\n      // Example, \"if (blah) { return a } else { return b }\"\n      // If both true and false blocks eventually lead to a 'return', replace the entire\n      // if-else block with that return to minimize the nesting depth.\n      Node newReturn = null;\n      if (NodeUtil.isNameDeclaration(parentIfNode.getParent())) {\n        // If the return is the only statement in a var/let/const declaration,\n        // do not remove the if-statement. This is to avoid a bug in Edge 44 and below.\n        // See https://github.com/google/closure-compiler/issues/2747 for details.\n        Node parent = parentIfNode.getParent();\n        while (parent.getParent() != null) {\n          parent = parent.getParent();\n        }\n\n        if (parent.isScript() || parent.isBlock()) {\n          newReturn = NodeUtil.newReturn(\n              parentIfNode.getOwnerDocument(), parent.getFirstChild().detach());\n        } else {\n          // Should not happen.\n          newReturn = null;\n        }\n      } else {\n        newReturn =\n            NodeUtil.newReturn(\n                parentIfNode.getOwnerDocument(),\n                parentIfNode.isNormalBlock() ? parentIfNode.detachChildren() : IR.block(parentIfNode.detachChildren()));\n      }\n\n      NodeUtil.replaceNode(parentIfNode, newReturn);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    if (allPathsReturnOrThrow(trueBlock, exitType, labelName)) {\n      // Example, \"if (blah) { return a } else { some_stmt }\"\n      // Remove the entire false block if empty (but no need if it contains a comment).\n      if (falseBlock.hasOneChild() && !falseBlock.getFirstChild().isComment()) {\n        NodeUtil.removeChild(parentIfNode, falseBlock);\n      }\n\n      // Insert \"if (!blah) { some_stmt }\" before the true block.\n      if (!NodeUtil.isEmptyBlock(falseBlock)) {\n        Node inverseCondition =\n            IR.not(parentIfNode.getFirstChild().detach()).srcref(parentIfNode);\n        Node newIf =\n            IR.ifNode(inverseCondition, falseBlock)\n                .useSourceInfoIfMissingFromForTree(parentIfNode)\n                .srcrefTree(parentIfNode);\n        NodeUtil.insertAfter(newIf, parentIfNode);\n        compiler.reportCodeChange();\n      }\n      return;\n    }\n\n    if (allPathsReturnOrThrow(falseBlock, exitType, labelName)) {\n      // Example, \"if (blah) { some_stmt } else { return a }\"\n      // Remove the entire true block if empty (but no need if it contains a comment).\n      if (trueBlock.hasOneChild() && !trueBlock.getFirstChild().isComment()) {\n        NodeUtil.removeChild(parentIfNode, trueBlock);\n      }\n\n      // Insert \"if (blah) { some_stmt }\" before the false block.\n      if (!NodeUtil.isEmptyBlock(trueBlock)) {\n        Node newIf = IR.ifNode(parentIfNode.getFirstChild().detach(), trueBlock)\n                         .useSourceInfoIfMissingFromForTree(parentIfNode)\n                         .srcrefTree(parentIfNode);\n        NodeUtil.insertAfter(newIf, parentIfNode);\n        compiler.reportCodeChange();\n      }\n      return;\n    }\n\n    if (falseBlock.hasOneChild() && !falseBlock.getFirstChild().isBlock()) {\n      // The y block is a single statement. Convert to block.\n      falseBlock.addChildrenToFront(IR.block(falseBlock.getFirstChild()));\n    }\n    boolean tReturn = allPathsReturnOrThrow(trueBlock, exitType, labelName);\n    boolean fReturn = allPathsReturnOrThrow(falseBlock, exitType, labelName);\n\n    if (tReturn && fReturn) {\n      // Example, \"if (blah) { return a } else { return b }\"\n      return;\n    }\n\n    if (tReturn) {\n      // Example, \"if (blah) { return a } else { some_stmt }\"\n      NodeUtil.removeChild(parentIfNode, falseBlock);\n      return;\n    }\n\n    if (fReturn) {\n      // Example, \"if (blah) { some_stmt } else { return b }\"\n      NodeUtil.removeChild(parentIfNode, trueBlock);\n      return;\n    }\n\n    // If both blocks are non-returning, then there is nothing to do.\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..7c09ed37 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -103,101 +103,144 @@ class MinimizeExitPoints\n    *   null otherwise.\n    * @nullable labelName non-null only for breaks within labels.\n    */\n-  void tryMinimizeExits(Node n, int exitType, String labelName) {\n+private void tryMinimizeIfBlockExits(Node trueBlock,\n+                                      Node falseBlock,\n+                                      Node parentIfNode,\n+                                      int exitType,\n+                                      String labelName) {\n \n-    // Just an 'exit'.\n-    if (matchingExitNode(n, exitType, labelName)) {\n-      NodeUtil.removeChild(n.getParent(), n);\n-      compiler.reportCodeChange();\n+    Label parentLabel = null;\n+    if (NodeUtil.isLabelName(parentIfNode.getFirstChild(), labelName)) {\n+      // If the node is a label, get the parent node\n+      parentLabel = NodeUtil.getEnclosingLabel(parentIfNode);\n+      parentIfNode = NodeUtil.getFunctionBody(parentLabel.getParent());\n+      trueBlock = parentLabel;\n+    }\n+\n+    // Assume \"if (condition) { trueBlock } else { falseBlock }\"\n+\n+    // Just a single 'exit' in the true block.\n+    if (matchingExitNode(trueBlock, exitType, labelName) &&\n+        !matchingExitNode(falseBlock, exitType, labelName)) {\n+      // Example, \"if (blah) { return x } else { ... }\"\n+      String statement = trueBlock.getLastChild().getFirstChild().toString();\n+      // Add '!' if appropriate.\n+      boolean assertCondition = !NodeUtil.isBooleanValue(parentIfNode.getFirstChild());\n+      addConditionalStatement(parentIfNode, statement, assertCondition);\n+      NodeUtil.removeChild(trueBlock.getParent(), trueBlock);\n       return;\n     }\n \n-    // Just an 'if'.\n-    if (n.isIf()) {\n-      Node ifBlock = n.getFirstChild().getNext();\n-      tryMinimizeExits(ifBlock, exitType, labelName);\n-      Node elseBlock = ifBlock.getNext();\n-      if (elseBlock != null) {\n-        tryMinimizeExits(elseBlock, exitType, labelName);\n-      }\n+    // Just a single 'exit' in the false block.\n+    if (matchingExitNode(falseBlock, exitType, labelName) &&\n+        !matchingExitNode(trueBlock, exitType, labelName)) {\n+      // Example, \"if (blah) { ... } else { return x }\"\n+      String statement = falseBlock.getLastChild().getFirstChild().toString();\n+      // Add '!' if appropriate.\n+      boolean assertCondition = NodeUtil.isBooleanValue(parentIfNode.getFirstChild());\n+      addConditionalStatement(parentIfNode, statement, assertCondition);\n+      NodeUtil.removeChild(falseBlock.getParent(), falseBlock);\n       return;\n     }\n \n-    // Just a 'try/catch/finally'.\n-    if (n.isTry()) {\n-      Node tryBlock = n.getFirstChild();\n-      tryMinimizeExits(tryBlock, exitType, labelName);\n-      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-        Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n-      }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+    if (allPathsReturnOrThrow(trueBlock, exitType, labelName) &&\n+        allPathsReturnOrThrow(falseBlock, exitType, labelName)) {\n+      // Example, \"if (blah) { return a } else { return b }\"\n+      // If both true and false blocks eventually lead to a 'return', replace the entire\n+      // if-else block with that return to minimize the nesting depth.\n+      Node newReturn = null;\n+      if (NodeUtil.isNameDeclaration(parentIfNode.getParent())) {\n+        // If the return is the only statement in a var/let/const declaration,\n+        // do not remove the if-statement. This is to avoid a bug in Edge 44 and below.\n+        // See https://github.com/google/closure-compiler/issues/2747 for details.\n+        Node parent = parentIfNode.getParent();\n+        while (parent.getParent() != null) {\n+          parent = parent.getParent();\n+        }\n+\n+        if (parent.isScript() || parent.isBlock()) {\n+          newReturn = NodeUtil.newReturn(\n+              parentIfNode.getOwnerDocument(), parent.getFirstChild().detach());\n+        } else {\n+          // Should not happen.\n+          newReturn = null;\n+        }\n+      } else {\n+        newReturn =\n+            NodeUtil.newReturn(\n+                parentIfNode.getOwnerDocument(),\n+                parentIfNode.isNormalBlock() ? parentIfNode.detachChildren() : IR.block(parentIfNode.detachChildren()));\n       }\n-    }\n \n-    // Just a 'label'.\n-    if (n.isLabel()) {\n-      Node labelBlock = n.getLastChild();\n-      tryMinimizeExits(labelBlock, exitType, labelName);\n+      NodeUtil.replaceNode(parentIfNode, newReturn);\n+      compiler.reportCodeChange();\n+      return;\n     }\n \n-    // TODO(johnlenz): The last case of SWITCH statement?\n+    if (allPathsReturnOrThrow(trueBlock, exitType, labelName)) {\n+      // Example, \"if (blah) { return a } else { some_stmt }\"\n+      // Remove the entire false block if empty (but no need if it contains a comment).\n+      if (falseBlock.hasOneChild() && !falseBlock.getFirstChild().isComment()) {\n+        NodeUtil.removeChild(parentIfNode, falseBlock);\n+      }\n \n-    // The rest assumes a block with at least one child, bail on anything else.\n-    if (!n.isBlock() || n.getLastChild() == null) {\n+      // Insert \"if (!blah) { some_stmt }\" before the true block.\n+      if (!NodeUtil.isEmptyBlock(falseBlock)) {\n+        Node inverseCondition =\n+            IR.not(parentIfNode.getFirstChild().detach()).srcref(parentIfNode);\n+        Node newIf =\n+            IR.ifNode(inverseCondition, falseBlock)\n+                .useSourceInfoIfMissingFromForTree(parentIfNode)\n+                .srcrefTree(parentIfNode);\n+        NodeUtil.insertAfter(newIf, parentIfNode);\n+        compiler.reportCodeChange();\n+      }\n       return;\n     }\n \n-    // Multiple if-exits can be converted in a single pass.\n-    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-\n-      // An 'if' block to process below.\n-      if (c.isIf()) {\n-        Node ifTree = c;\n-        Node trueBlock, falseBlock;\n-\n-        // First, the true condition block.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n-\n-        // Now the else block.\n-        // The if blocks may have changed, get them again.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n-        }\n+    if (allPathsReturnOrThrow(falseBlock, exitType, labelName)) {\n+      // Example, \"if (blah) { some_stmt } else { return a }\"\n+      // Remove the entire true block if empty (but no need if it contains a comment).\n+      if (trueBlock.hasOneChild() && !trueBlock.getFirstChild().isComment()) {\n+        NodeUtil.removeChild(parentIfNode, trueBlock);\n       }\n \n-      if (c == n.getLastChild()) {\n-        break;\n+      // Insert \"if (blah) { some_stmt }\" before the false block.\n+      if (!NodeUtil.isEmptyBlock(trueBlock)) {\n+        Node newIf = IR.ifNode(parentIfNode.getFirstChild().detach(), trueBlock)\n+                         .useSourceInfoIfMissingFromForTree(parentIfNode)\n+                         .srcrefTree(parentIfNode);\n+        NodeUtil.insertAfter(newIf, parentIfNode);\n+        compiler.reportCodeChange();\n       }\n+      return;\n     }\n \n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n-        break;\n-      }\n+    if (falseBlock.hasOneChild() && !falseBlock.getFirstChild().isBlock()) {\n+      // The y block is a single statement. Convert to block.\n+      falseBlock.addChildrenToFront(IR.block(falseBlock.getFirstChild()));\n+    }\n+    boolean tReturn = allPathsReturnOrThrow(trueBlock, exitType, labelName);\n+    boolean fReturn = allPathsReturnOrThrow(falseBlock, exitType, labelName);\n+\n+    if (tReturn && fReturn) {\n+      // Example, \"if (blah) { return a } else { return b }\"\n+      return;\n     }\n+\n+    if (tReturn) {\n+      // Example, \"if (blah) { return a } else { some_stmt }\"\n+      NodeUtil.removeChild(parentIfNode, falseBlock);\n+      return;\n+    }\n+\n+    if (fReturn) {\n+      // Example, \"if (blah) { some_stmt } else { return b }\"\n+      NodeUtil.removeChild(parentIfNode, trueBlock);\n+      return;\n+    }\n+\n+    // If both blocks are non-returning, then there is nothing to do.\n   }\n \n   /**",
    "result_reason": "error: method tryMinimizeIfBlockExits(Node,Node,Node,int,String) is already defined in class MinimizeExitPoints",
    "test_result": "ERROR"
}