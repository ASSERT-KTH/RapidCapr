{
    "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    double yInitial = f.value(initial);\n\n    if (!isBracketing(yMin, yMax)) {\n        throw new IllegalArgumentException(\"Interval does not bracket root: [\" + min + \", \" + max + \"]\");\n    }\n\n    if (yInitial == 0.0) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    double x = initial;\n    double y = yInitial;\n    double w = y;\n    double v = y;\n    double d = 0;\n    double e = 0;\n\n    for (int i = 0; i < maximalIterationCount; i++) {\n        double m = 0.5 * (min + max);\n        double tol1 = relativeAccuracy * Math.abs(x) + absoluteAccuracy;\n        double tol2 = 2 * tol1;\n\n        if (Math.abs(x - m) <= tol2 - 0.5 * (max - min)) {\n            setResult(x, i);\n            return result;\n        }\n\n        if (Math.abs(e) > tol1) {\n            double r = (x - w) * (y - v);\n            double p = (x - v) * y - (x - y) * v;\n            double q = (x - w) * y - (x - y) * w;\n            double sgn = Math.signum(p) + Math.signum(q);\n\n            if (sgn != 0.0) {\n                double a = Math.abs(p);\n                double b = Math.abs(q);\n                double t = a > b ? p / q : q / p;\n                double u = r + t;\n\n                if (x - u >= min && x - u <= max && u - w < 2 * e) {\n                    d = t;\n                    e = x - u;\n                    continue;\n                }\n            }\n        }\n\n        d = 0.5 * (max - min);\n        e = d;\n\n        if (diffEqualsTol(x, m, relativeAccuracy, absoluteAccuracy)) {\n            double s = Math.signum(x - m);\n            d = s * tol1;\n            e = d;\n        }\n\n        double xm = x + d;\n        double ym = f.value(xm);\n\n        if (diffEqualsTol(y, ym, relativeAccuracy, absoluteAccuracy)) {\n            double s = Math.signum(y);\n            setResult(xm, i);\n            return result;\n        }\n\n        if (diffEqualsTol(w, x, relativeAccuracy, absoluteAccuracy) ||\n                diffEqualsTol(y, ym, relativeAccuracy, absoluteAccuracy) ||\n                i == maximalIterationCount - 1) {\n            double sgn = Math.signum(yInitial) + Math.signum(ym);\n            if (sgn == 0.0) {\n                w = x;\n                v = y;\n                x = xm;\n                y = ym;\n                setResult(x, i);\n                return result;\n            } else if (Math.abs(yInitial) < Math.abs(ym)) {\n                w = xm;\n                v = ym;\n            } else {\n                v = yInitial;\n                w = x;\n                x = xm;\n                y = ym;\n            }\n            continue;\n        }\n\n        if (diffEqualsTol(y, yMin, relativeAccuracy, absoluteAccuracy) &&\n                diffEqualsTol(ym, yMin, relativeAccuracy, absoluteAccuracy)) {\n            max = xm;\n            continue;\n        }\n\n        if (diffEqualsTol(y, yMax, relativeAccuracy, absoluteAccuracy) &&\n                diffEqualsTol(ym, yMax, relativeAccuracy, absoluteAccuracy)) {\n            min = xm;\n            continue;\n        }\n\n        if (ym * y < 0) {\n            max = xm;\n            yMax = ym;\n        } else {\n            min = xm;\n            yMin = ym;\n        }\n    }\n\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}\n\nprivate boolean isBracketing(double yMin, double yMax) {\n    return yMin * yMax <= 0.0;\n}\n\nprivate boolean diffEqualsTol(double a, double b, double relativeTol, double absoluteTol) {\n    return Math.abs(a - b) <= (relativeTol * Math.abs(a) + absoluteTol);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..f14bf5d07 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,50 +95,135 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n+public double solve(final UnivariateRealFunction f,\n+                    final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+    clearResult();\n+\n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n+    double yInitial = f.value(initial);\n+\n+    if (!isBracketing(yMin, yMax)) {\n+        throw new IllegalArgumentException(\"Interval does not bracket root: [\" + min + \", \" + max + \"]\");\n+    }\n+\n+    if (yInitial == 0.0) {\n+        setResult(initial, 0);\n+        return result;\n+    }\n+\n+    double x = initial;\n+    double y = yInitial;\n+    double w = y;\n+    double v = y;\n+    double d = 0;\n+    double e = 0;\n \n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n+    for (int i = 0; i < maximalIterationCount; i++) {\n+        double m = 0.5 * (min + max);\n+        double tol1 = relativeAccuracy * Math.abs(x) + absoluteAccuracy;\n+        double tol2 = 2 * tol1;\n+\n+        if (Math.abs(x - m) <= tol2 - 0.5 * (max - min)) {\n+            setResult(x, i);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n+        if (Math.abs(e) > tol1) {\n+            double r = (x - w) * (y - v);\n+            double p = (x - v) * y - (x - y) * v;\n+            double q = (x - w) * y - (x - y) * w;\n+            double sgn = Math.signum(p) + Math.signum(q);\n+\n+            if (sgn != 0.0) {\n+                double a = Math.abs(p);\n+                double b = Math.abs(q);\n+                double t = a > b ? p / q : q / p;\n+                double u = r + t;\n+\n+                if (x - u >= min && x - u <= max && u - w < 2 * e) {\n+                    d = t;\n+                    e = x - u;\n+                    continue;\n+                }\n+            }\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+        d = 0.5 * (max - min);\n+        e = d;\n+\n+        if (diffEqualsTol(x, m, relativeAccuracy, absoluteAccuracy)) {\n+            double s = Math.signum(x - m);\n+            d = s * tol1;\n+            e = d;\n         }\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+        double xm = x + d;\n+        double ym = f.value(xm);\n+\n+        if (diffEqualsTol(y, ym, relativeAccuracy, absoluteAccuracy)) {\n+            double s = Math.signum(y);\n+            setResult(xm, i);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        if (diffEqualsTol(w, x, relativeAccuracy, absoluteAccuracy) ||\n+                diffEqualsTol(y, ym, relativeAccuracy, absoluteAccuracy) ||\n+                i == maximalIterationCount - 1) {\n+            double sgn = Math.signum(yInitial) + Math.signum(ym);\n+            if (sgn == 0.0) {\n+                w = x;\n+                v = y;\n+                x = xm;\n+                y = ym;\n+                setResult(x, i);\n+                return result;\n+            } else if (Math.abs(yInitial) < Math.abs(ym)) {\n+                w = xm;\n+                v = ym;\n+            } else {\n+                v = yInitial;\n+                w = x;\n+                x = xm;\n+                y = ym;\n+            }\n+            continue;\n         }\n \n+        if (diffEqualsTol(y, yMin, relativeAccuracy, absoluteAccuracy) &&\n+                diffEqualsTol(ym, yMin, relativeAccuracy, absoluteAccuracy)) {\n+            max = xm;\n+            continue;\n+        }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        if (diffEqualsTol(y, yMax, relativeAccuracy, absoluteAccuracy) &&\n+                diffEqualsTol(ym, yMax, relativeAccuracy, absoluteAccuracy)) {\n+            min = xm;\n+            continue;\n+        }\n \n+        if (ym * y < 0) {\n+            max = xm;\n+            yMax = ym;\n+        } else {\n+            min = xm;\n+            yMin = ym;\n+        }\n     }\n \n+    throw new MaxIterationsExceededException(maximalIterationCount);\n+}\n+\n+private boolean isBracketing(double yMin, double yMax) {\n+    return yMin * yMax <= 0.0;\n+}\n+\n+private boolean diffEqualsTol(double a, double b, double relativeTol, double absoluteTol) {\n+    return Math.abs(a - b) <= (relativeTol * Math.abs(a) + absoluteTol);\n+}\n+\n     /**\n      * Find a zero in the given interval.\n      * <p>",
    "result_reason": "error: final parameter max may not be assigned",
    "test_result": "ERROR"
}