{
    "patch": "/**\n * Iterates the simplex according to the Nelder-Mead algorithm until convergence is reached.\n *\n * @param comparator comparator to be used for ordering the vertices of the simplex at each step\n * @throws FunctionEvaluationException when the objective function cannot be evaluated\n * @throws OptimizationException when the maximal number of iterations is reached\n * @throws IllegalArgumentException if the number of simplex vertices is smaller than the space dimension or the\n * maximum number of iterations is negative\n */\nprotected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    while (true) {\n        incrementIterationsCounter();\n\n        final RealPointValuePair best = simplex[0];\n        final RealPointValuePair reflected = evaluateNewSimplex(simplex, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n            final RealPointValuePair expanded = evaluateNewSimplex(simplex, gamma, comparator);\n            if (comparator.compare(expanded, reflected) < 0) {\n                simplex = contractAndShrink(simplex[0], simplex, comparator);\n            } else {\n                simplex = replaceWorst(simplex, expanded, comparator);\n            }\n        } else {\n            final RealPointValuePair contracted = evaluateNewSimplex(simplex, rho, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                simplex = replaceWorst(simplex, contracted, comparator);\n            } else {\n                simplex = contractAndShrink(best, simplex, comparator);\n            }\n        }\n\n        // check convergence\n        if ((getConvergenceChecker() != null) && getConvergenceChecker().converged(getIterations(),\n                simplex[0], simplex[simplex.length - 1])) {\n            return;\n        }\n\n        // check if the maximum number of iterations has been reached\n        if (getIterations() >= getMaxIterations()) {\n            throw new OptimizationException(\"Maximum number of iterations (\" + getMaxIterations() + \") exceeded\");\n        }\n    }\n}\n\n/**\n * Contracts and shrinks the simplex.\n * @param best the best vertex\n * @param simplex the current simplex\n * @param comparator comparator to be used for ordering the vertices of the simplex at each step\n * @return the new simplex\n */\nprivate RealPointValuePair[] contractAndShrink(final RealPointValuePair best,\n                                                final RealPointValuePair[] simplex,\n                                                final Comparator<RealPointValuePair> comparator) {\n    // contract\n    final RealPointValuePair contracted = evaluateNewSimplex(simplex, sigma, comparator);\n    if (comparator.compare(contracted, best) < 0) {\n        return replaceWorst(simplex, contracted, comparator);\n    }\n\n    // shrink\n    final RealPointValuePair[] newSimplex = new RealPointValuePair[simplex.length];\n    newSimplex[0] = best;\n    for (int i = 1; i < newSimplex.length; i++) {\n        final double[] coordinates = best.getPoint();\n        final RealPointValuePair simplexVertex = simplex[i];\n        for (int j = 0; j < coordinates.length; j++) {\n            coordinates[j] += sigma * (simplexVertex.getPoint()[j] - coordinates[j]);\n        }\n        final double value = computeObjectiveValue(coordinates);\n        newSimplex[i] = new RealPointValuePair(coordinates, value);\n  ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..a9c0f4e86 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,45 +58,79 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+/**\n+ * Iterates the simplex according to the Nelder-Mead algorithm until convergence is reached.\n+ *\n+ * @param comparator comparator to be used for ordering the vertices of the simplex at each step\n+ * @throws FunctionEvaluationException when the objective function cannot be evaluated\n+ * @throws OptimizationException when the maximal number of iterations is reached\n+ * @throws IllegalArgumentException if the number of simplex vertices is smaller than the space dimension or the\n+ * maximum number of iterations is negative\n+ */\n+protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-\n-        while (true) {\n-\n-            incrementIterationsCounter();\n-\n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n-\n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n-\n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n-\n-                return;\n-\n+    while (true) {\n+        incrementIterationsCounter();\n+\n+        final RealPointValuePair best = simplex[0];\n+        final RealPointValuePair reflected = evaluateNewSimplex(simplex, 1.0, comparator);\n+        if (comparator.compare(reflected, best) < 0) {\n+            final RealPointValuePair expanded = evaluateNewSimplex(simplex, gamma, comparator);\n+            if (comparator.compare(expanded, reflected) < 0) {\n+                simplex = contractAndShrink(simplex[0], simplex, comparator);\n+            } else {\n+                simplex = replaceWorst(simplex, expanded, comparator);\n             }\n-\n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n+        } else {\n+            final RealPointValuePair contracted = evaluateNewSimplex(simplex, rho, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n+                simplex = replaceWorst(simplex, contracted, comparator);\n+            } else {\n+                simplex = contractAndShrink(best, simplex, comparator);\n             }\n+        }\n \n+        // check convergence\n+        if ((getConvergenceChecker() != null) && getConvergenceChecker().converged(getIterations(),\n+                simplex[0], simplex[simplex.length - 1])) {\n+            return;\n         }\n \n+        // check if the maximum number of iterations has been reached\n+        if (getIterations() >= getMaxIterations()) {\n+            throw new OptimizationException(\"Maximum number of iterations (\" + getMaxIterations() + \") exceeded\");\n+        }\n     }\n+}\n+\n+/**\n+ * Contracts and shrinks the simplex.\n+ * @param best the best vertex\n+ * @param simplex the current simplex\n+ * @param comparator comparator to be used for ordering the vertices of the simplex at each step\n+ * @return the new simplex\n+ */\n+private RealPointValuePair[] contractAndShrink(final RealPointValuePair best,\n+                                                final RealPointValuePair[] simplex,\n+                                                final Comparator<RealPointValuePair> comparator) {\n+    // contract\n+    final RealPointValuePair contracted = evaluateNewSimplex(simplex, sigma, comparator);\n+    if (comparator.compare(contracted, best) < 0) {\n+        return replaceWorst(simplex, contracted, comparator);\n+    }\n+\n+    // shrink\n+    final RealPointValuePair[] newSimplex = new RealPointValuePair[simplex.length];\n+    newSimplex[0] = best;\n+    for (int i = 1; i < newSimplex.length; i++) {\n+        final double[] coordinates = best.getPoint();\n+        final RealPointValuePair simplexVertex = simplex[i];\n+        for (int j = 0; j < coordinates.length; j++) {\n+            coordinates[j] += sigma * (simplexVertex.getPoint()[j] - coordinates[j]);\n+        }\n+        final double value = computeObjectiveValue(coordinates);\n+        newSimplex[i] = new RealPointValuePair(coordinates, value);\n+  \n \n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}