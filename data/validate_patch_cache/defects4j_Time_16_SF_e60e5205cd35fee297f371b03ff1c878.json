{
    "patch": "    public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n\n        Chronology chrono = instant.getChronology();\n        Instant savedInstant = null;\n        long savedMillis = 0;\n        final DateTimeZone parsedZone;\n        int newPos;\n\n        final long instantMillis = instant.getMillis(); // changed\n\n        int offset = 0;\n        if (iZone != null) {\n            // use override zone\n            parsedZone = iZone;\n        } else {\n            // calculate effective zone\n            if (instant instanceof MutableDateTime) {\n                // cheap and reliable\n                offset = ((MutableDateTime)instant).getZone().getOffset(instantMillis);\n                parsedZone = DateTimeZone.forOffsetMillis(offset);\n            } else {\n                // getZone() may throw UnsupportedOperationException or IllegalArgumentException\n                try {\n                    parsedZone = chrono.getZone();\n                    offset = parsedZone.getOffset(instantMillis);\n                } catch (RuntimeException e) {\n                    // ...unless overridden\n                    parsedZone = DateTimeZone.UTC;\n                    offset = 0;\n                }\n            }\n        }\n\n        long instantLocal = instantMillis + offset; // changed\n\n        chrono = selectChronology(chrono);\n\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n        newPos = parser.parseInto(bucket, text, position);\n        savedInstant = bucket.computeInstant();\n\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            offset = bucket.getOffsetInteger();\n            parsedZone = DateTimeZone.forOffsetMillis(offset);\n        } else if (bucket.getZone() != null) {\n            parsedZone = bucket.getZone();\n        }\n        chrono = chrono.withZone(parsedZone);\n\n        if (iConvertByWeekyear) {\n            if (savedInstant != null) {\n                int savedWeekyear = ISOWeekDateTimeField.getInstanceUTC().getWeekyear(savedInstant);\n                int parsedWeekyear = ISOWeekDateTimeField.getInstance(parsedZone).getWeekyear(savedInstant);\n                chrono = chrono.withWeekyear(savedWeekyear);\n                chrono = chrono.withZone(parsedZone);\n                DateTimeField field = chrono.weekyear();\n                long diff = field.set(0, parsedWeekyear) - savedInstant.getMillis();\n                savedInstant = savedInstant.plus(diff);\n            }\n            // ignore leap second\n            instant.setMillis(savedInstant == null ? instant.getMillis() : savedInstant.getMillis());\n        } else {\n            if (savedInstant != null) {\n                instant.setMillis(savedInstant.getMillis());\n            } else {\n                savedMillis = bucket.computeMillis(false, text);\n                instant.setMillis(savedMillis);\n            }\n        }\n\n        instant.setChronology(chrono);\n        if (iZone == null) {\n            // setZone() may throw UnsupportedOperationException\n            try {\n                if (bucket.getOffsetInteger() != null) {\n                    instant.setZone(parsedZone);\n                } else if (bucket.getZone() != null) {\n                    instant.setZone(bucket.getZone());\n                }\n            } catch (RuntimeException e) {\n                // ignore\n            }\n        }\n\n        return newPos;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex a4b16127..4528eb81 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -699,27 +699,90 @@ public class DateTimeFormatter {\n         if (instant == null) {\n             throw new IllegalArgumentException(\"Instant must not be null\");\n         }\n-        \n-        long instantMillis = instant.getMillis();\n+\n         Chronology chrono = instant.getChronology();\n-        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n+        Instant savedInstant = null;\n+        long savedMillis = 0;\n+        final DateTimeZone parsedZone;\n+        int newPos;\n+\n+        final long instantMillis = instant.getMillis(); // changed\n+\n+        int offset = 0;\n+        if (iZone != null) {\n+            // use override zone\n+            parsedZone = iZone;\n+        } else {\n+            // calculate effective zone\n+            if (instant instanceof MutableDateTime) {\n+                // cheap and reliable\n+                offset = ((MutableDateTime)instant).getZone().getOffset(instantMillis);\n+                parsedZone = DateTimeZone.forOffsetMillis(offset);\n+            } else {\n+                // getZone() may throw UnsupportedOperationException or IllegalArgumentException\n+                try {\n+                    parsedZone = chrono.getZone();\n+                    offset = parsedZone.getOffset(instantMillis);\n+                } catch (RuntimeException e) {\n+                    // ...unless overridden\n+                    parsedZone = DateTimeZone.UTC;\n+                    offset = 0;\n+                }\n+            }\n+        }\n+\n+        long instantLocal = instantMillis + offset; // changed\n+\n         chrono = selectChronology(chrono);\n-        \n+\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n             instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n-        int newPos = parser.parseInto(bucket, text, position);\n-        instant.setMillis(bucket.computeMillis(false, text));\n+        newPos = parser.parseInto(bucket, text, position);\n+        savedInstant = bucket.computeInstant();\n+\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n-            int parsedOffset = bucket.getOffsetInteger();\n-            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n-            chrono = chrono.withZone(parsedZone);\n+            offset = bucket.getOffsetInteger();\n+            parsedZone = DateTimeZone.forOffsetMillis(offset);\n         } else if (bucket.getZone() != null) {\n-            chrono = chrono.withZone(bucket.getZone());\n+            parsedZone = bucket.getZone();\n+        }\n+        chrono = chrono.withZone(parsedZone);\n+\n+        if (iConvertByWeekyear) {\n+            if (savedInstant != null) {\n+                int savedWeekyear = ISOWeekDateTimeField.getInstanceUTC().getWeekyear(savedInstant);\n+                int parsedWeekyear = ISOWeekDateTimeField.getInstance(parsedZone).getWeekyear(savedInstant);\n+                chrono = chrono.withWeekyear(savedWeekyear);\n+                chrono = chrono.withZone(parsedZone);\n+                DateTimeField field = chrono.weekyear();\n+                long diff = field.set(0, parsedWeekyear) - savedInstant.getMillis();\n+                savedInstant = savedInstant.plus(diff);\n+            }\n+            // ignore leap second\n+            instant.setMillis(savedInstant == null ? instant.getMillis() : savedInstant.getMillis());\n+        } else {\n+            if (savedInstant != null) {\n+                instant.setMillis(savedInstant.getMillis());\n+            } else {\n+                savedMillis = bucket.computeMillis(false, text);\n+                instant.setMillis(savedMillis);\n+            }\n         }\n+\n         instant.setChronology(chrono);\n-        if (iZone != null) {\n-            instant.setZone(iZone);\n+        if (iZone == null) {\n+            // setZone() may throw UnsupportedOperationException\n+            try {\n+                if (bucket.getOffsetInteger() != null) {\n+                    instant.setZone(parsedZone);\n+                } else if (bucket.getZone() != null) {\n+                    instant.setZone(bucket.getZone());\n+                }\n+            } catch (RuntimeException e) {\n+                // ignore\n+            }\n         }\n+\n         return newPos;\n     }\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}