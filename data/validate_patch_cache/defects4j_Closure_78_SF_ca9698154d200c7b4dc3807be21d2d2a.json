{
    "patch": "private Node performArithmeticOp(int opType, Node left, Node right) {\n  // Unlike other operations, ADD operands are not always converted\n  // to Number.\n  if (opType == Token.ADD\n      && (NodeUtil.mayBeString(left, false)\n      || NodeUtil.mayBeString(right, false))) {\n    return null;\n  }\n\n  Double lValObj = NodeUtil.getNumberValue(left);\n  if (lValObj == null) {\n    return null;\n  }\n\n  Double rValObj = NodeUtil.getNumberValue(right);\n  if (rValObj == null) {\n    return null;\n  }\n\n  double lval = lValObj;\n  double rval = rValObj;\n\n  switch (opType) {\n    case Token.BITAND:\n      return Node.newNumber(ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval));\n    case Token.BITOR:\n      return Node.newNumber(ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval));\n    case Token.BITXOR:\n      return Node.newNumber(ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval));\n    case Token.ADD:\n      if (NodeUtil.isNumericResult(left) && NodeUtil.isNumericResult(right)) {\n        double result = lval + rval;\n        return canFold(result, left, right) ? Node.newNumber(result) : null;\n      } else {\n        String result = NodeUtil.getStringValue(left) + NodeUtil.getStringValue(right);\n        return Node.newString(result);\n      }\n    case Token.SUB:\n      return Node.newNumber(lval - rval);\n    case Token.MUL:\n      return Node.newNumber(lval * rval);\n    case Token.MOD:\n      if (rval == 0) {\n        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n        // Do not return an error node, return null so that further optimizations can be performed.\n        return null;\n      }\n      return Node.newNumber(lval % rval);\n    case Token.DIV:\n      if (rval == 0) {\n        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n        // Do not return an error node, return null so that further optimizations can be performed.\n        return null;\n      }\n      return Node.newNumber(lval / rval);\n    default:\n      throw new Error(\"Unexpected arithmetic operator\");\n  }\n}\n\nprivate static boolean canFold(double result, Node left, Node right) {\n  String s = String.valueOf(result);\n  int p = s.indexOf('.');\n  if (p != -1) {\n    int fractionDigits = s.length() - p - 1;\n    if (fractionDigits > 3) {\n      // The V8 JS engine has similar logic, see\n      // https://github.com/v8/v8/blob/df95078301c6867f03ff31498384d845c4e60b1b/src/js/script.cc#L394.\n      // Trimming the result may lose some precision, but it's better than generating digits\n      // that are completely bogus.\n      double trimmedResult = trim(result, fractionDigits);\n      return canFold(trimmedResult, left, right);\n    }\n    return true;\n  }\n  return true;\n}\n\nprivate static double trim(double result, int fractionDigits) {\n  BigDecimal bd = new BigDecimal(result);\n  bd = bd.setScale(fractionDigits, RoundingMode.FLOOR);\n  return bd.doubleValue();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex c5ef4b0f..284ab14a 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -661,89 +661,89 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n   /**\n    * Try to fold arithmetic binary operators\n    */\n-  private Node performArithmeticOp(int opType, Node left, Node right) {\n-    // Unlike other operations, ADD operands are not always converted\n-    // to Number.\n-    if (opType == Token.ADD\n-        && (NodeUtil.mayBeString(left, false)\n-            || NodeUtil.mayBeString(right, false))) {\n-      return null;\n-    }\n-\n-    double result;\n-\n-    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n-    // to zero so this is a little akward here.\n-\n-    Double lValObj = NodeUtil.getNumberValue(left);\n-    if (lValObj == null) {\n-      return null;\n-    }\n-    Double rValObj = NodeUtil.getNumberValue(right);\n-    if (rValObj == null) {\n-      return null;\n-    }\n-\n-    double lval = lValObj;\n-    double rval = rValObj;\n+private Node performArithmeticOp(int opType, Node left, Node right) {\n+  // Unlike other operations, ADD operands are not always converted\n+  // to Number.\n+  if (opType == Token.ADD\n+      && (NodeUtil.mayBeString(left, false)\n+      || NodeUtil.mayBeString(right, false))) {\n+    return null;\n+  }\n \n-    switch (opType) {\n-      case Token.BITAND:\n-        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n-        break;\n-      case Token.BITOR:\n-        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n-        break;\n-      case Token.BITXOR:\n-        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n-        break;\n-      case Token.ADD:\n-        result = lval + rval;\n-        break;\n-      case Token.SUB:\n-        result = lval - rval;\n-        break;\n-      case Token.MUL:\n-        result = lval * rval;\n-        break;\n-      case Token.MOD:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval % rval;\n-        break;\n-      case Token.DIV:\n-        if (rval == 0) {\n-          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n-        }\n-        result = lval / rval;\n-        break;\n-      default:\n-        throw new Error(\"Unexpected arithmetic operator\");\n-    }\n+  Double lValObj = NodeUtil.getNumberValue(left);\n+  if (lValObj == null) {\n+    return null;\n+  }\n \n-    // TODO(johnlenz): consider removing the result length check.\n-    // length of the left and right value plus 1 byte for the operator.\n-    if (String.valueOf(result).length() <=\n-        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n+  Double rValObj = NodeUtil.getNumberValue(right);\n+  if (rValObj == null) {\n+    return null;\n+  }\n \n-        // Do not try to fold arithmetic for numbers > 2^53. After that\n-        // point, fixed-point math starts to break down and become inaccurate.\n-        Math.abs(result) <= MAX_FOLD_NUMBER) {\n-      Node newNumber = Node.newNumber(result);\n-      return newNumber;\n-    } else if (Double.isNaN(result)) {\n-      return Node.newString(Token.NAME, \"NaN\");\n-    } else if (result == Double.POSITIVE_INFINITY) {\n-      return Node.newString(Token.NAME, \"Infinity\");\n-    } else if (result == Double.NEGATIVE_INFINITY) {\n-      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n-    }\n+  double lval = lValObj;\n+  double rval = rValObj;\n+\n+  switch (opType) {\n+    case Token.BITAND:\n+      return Node.newNumber(ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval));\n+    case Token.BITOR:\n+      return Node.newNumber(ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval));\n+    case Token.BITXOR:\n+      return Node.newNumber(ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval));\n+    case Token.ADD:\n+      if (NodeUtil.isNumericResult(left) && NodeUtil.isNumericResult(right)) {\n+        double result = lval + rval;\n+        return canFold(result, left, right) ? Node.newNumber(result) : null;\n+      } else {\n+        String result = NodeUtil.getStringValue(left) + NodeUtil.getStringValue(right);\n+        return Node.newString(result);\n+      }\n+    case Token.SUB:\n+      return Node.newNumber(lval - rval);\n+    case Token.MUL:\n+      return Node.newNumber(lval * rval);\n+    case Token.MOD:\n+      if (rval == 0) {\n+        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+        // Do not return an error node, return null so that further optimizations can be performed.\n+        return null;\n+      }\n+      return Node.newNumber(lval % rval);\n+    case Token.DIV:\n+      if (rval == 0) {\n+        error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n+        // Do not return an error node, return null so that further optimizations can be performed.\n+        return null;\n+      }\n+      return Node.newNumber(lval / rval);\n+    default:\n+      throw new Error(\"Unexpected arithmetic operator\");\n+  }\n+}\n \n-    return null;\n+private static boolean canFold(double result, Node left, Node right) {\n+  String s = String.valueOf(result);\n+  int p = s.indexOf('.');\n+  if (p != -1) {\n+    int fractionDigits = s.length() - p - 1;\n+    if (fractionDigits > 3) {\n+      // The V8 JS engine has similar logic, see\n+      // https://github.com/v8/v8/blob/df95078301c6867f03ff31498384d845c4e60b1b/src/js/script.cc#L394.\n+      // Trimming the result may lose some precision, but it's better than generating digits\n+      // that are completely bogus.\n+      double trimmedResult = trim(result, fractionDigits);\n+      return canFold(trimmedResult, left, right);\n+    }\n+    return true;\n   }\n+  return true;\n+}\n+\n+private static double trim(double result, int fractionDigits) {\n+  BigDecimal bd = new BigDecimal(result);\n+  bd = bd.setScale(fractionDigits, RoundingMode.FLOOR);\n+  return bd.doubleValue();\n+}\n \n   /**\n    * Expressions such as [foo() * 10 * 20] generate parse trees",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}