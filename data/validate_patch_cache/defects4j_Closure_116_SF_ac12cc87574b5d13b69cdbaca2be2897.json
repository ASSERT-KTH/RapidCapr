{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.StaticSourceFile;\nimport com.google.javascript.rhino.head.BaseFunctionNode;\nimport com.google.javascript.rhino.jstype.JSType;\n\nimport java.util.Set;\n\nclass Example {\n    private final AbstractCompiler compiler;\n\n    Example(AbstractCompiler compiler) {\n        this.compiler = compiler;\n    }\n\n    private boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n        // implementation\n        return false;\n    }\n\n    private enum CanInlineResult {\n        YES, NO\n    }\n\n    private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n        if (!isDirectCallNodeReplacementPossible(fnNode)) {\n            return CanInlineResult.NO;\n        }\n\n        Node block = fnNode.getLastChild();\n\n        // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n        Node cArg = callNode.getFirstChild().getNext();\n\n        // Functions called via 'call' and 'apply' have a this-object as\n        // the first parameter, but this is not part of the called function's\n        // parameter list.\n        if (!callNode.getFirstChild().isName()) {\n            if (NodeUtil.isFunctionObjectCall(callNode)) {\n                // TODO(johnlenz): Support replace this with a value.\n                if (cArg == null || !cArg.isThis()) {\n                    return CanInlineResult.NO;\n                }\n                cArg = cArg.getNext();\n            } else {\n                // \".apply\" call should be filtered before this.\n                Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n            }\n        }\n\n        // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n        Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n        while (fnParam != null) {\n            // If there are no more arguments and the current parameter\n            // is not optional or a rest parameter, then we cannot inline.\n            if (cArg == null && !fnParam.isOptionalArg() && !fnParam.isRest()) {\n                return CanInlineResult.NO;\n            }\n\n            // Otherwise, check for side-effects and move on to the next parameter\n            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n                return CanInlineResult.NO;\n            }\n            fnParam = fnParam.getNext();\n\n            // If there are still arguments, move on to the next argument\n            if (cArg != null && !fnParam.isRest()) {\n                cArg = cArg.getNext();\n            }\n        }\n\n        // If there are any remaining arguments, return NO\n        if (cArg != null) {\n            return CanInlineResult.NO;\n        }\n\n        return CanInlineResult.YES;\n    }\n\n    private boolean hasExceptionHandler(Node cfgNode) {\n        List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n        for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n            if (edge.getValue() == Branch.ON_EX) {\n                return true;\n            }\n        }\n        return false;\n    }\n\n    private ControlFlowGraph<Node> getCfg() {\n        // implementation\n        return null;\n    }\n\n    private static class Branch {\n        static final Branch ON_EX = new Branch();\n    }\n\n    private static class NodeUtil {\n        static boolean isFunctionObjectApply(Node n) {\n            // implementation\n            return false;\n        }\n\n        static boolean isFunctionObjectCall(Node n) {\n            // implementation\n            return false;\n        }\n\n        static Node getFunctionParameters(Node fnNode) {\n            // implementation\n            return null;\n        }\n\n        static int getNameReferenceCount(Node node, String name) {\n            // implementation\n            return 0;\n        }\n\n        static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) {\n            // implementation\n            return false;\n        }\n\n        static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\n            // implementation\n            return false;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex c3fc14b2..0f96e685 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -686,67 +686,137 @@ class FunctionInjector {\n    *     x = foo(i++);\n    * </pre>\n    */\n-  private CanInlineResult canInlineReferenceDirectly(\n-      Node callNode, Node fnNode) {\n-    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n-      return CanInlineResult.NO;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.StaticSourceFile;\n+import com.google.javascript.rhino.head.BaseFunctionNode;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+import java.util.Set;\n+\n+class Example {\n+    private final AbstractCompiler compiler;\n+\n+    Example(AbstractCompiler compiler) {\n+        this.compiler = compiler;\n     }\n \n-    Node block = fnNode.getLastChild();\n+    private boolean isDirectCallNodeReplacementPossible(Node fnNode) {\n+        // implementation\n+        return false;\n+    }\n \n+    private enum CanInlineResult {\n+        YES, NO\n+    }\n \n-    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n-    Node cArg = callNode.getFirstChild().getNext();\n+    private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n+        if (!isDirectCallNodeReplacementPossible(fnNode)) {\n+            return CanInlineResult.NO;\n+        }\n \n-    // Functions called via 'call' and 'apply' have a this-object as\n-    // the first parameter, but this is not part of the called function's\n-    // parameter list.\n-    if (!callNode.getFirstChild().isName()) {\n-      if (NodeUtil.isFunctionObjectCall(callNode)) {\n-        // TODO(johnlenz): Support replace this with a value.\n-        if (cArg == null || !cArg.isThis()) {\n-          return CanInlineResult.NO;\n+        Node block = fnNode.getLastChild();\n+\n+        // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n+        Node cArg = callNode.getFirstChild().getNext();\n+\n+        // Functions called via 'call' and 'apply' have a this-object as\n+        // the first parameter, but this is not part of the called function's\n+        // parameter list.\n+        if (!callNode.getFirstChild().isName()) {\n+            if (NodeUtil.isFunctionObjectCall(callNode)) {\n+                // TODO(johnlenz): Support replace this with a value.\n+                if (cArg == null || !cArg.isThis()) {\n+                    return CanInlineResult.NO;\n+                }\n+                cArg = cArg.getNext();\n+            } else {\n+                // \".apply\" call should be filtered before this.\n+                Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n+            }\n         }\n-        cArg = cArg.getNext();\n-      } else {\n-        // \".apply\" call should be filtered before this.\n-        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n-      }\n-    }\n \n-    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n-    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n-    while (cArg != null || fnParam != null) {\n-      // For each named parameter check if a mutable argument use more than one.\n-      if (fnParam != null) {\n-        if (cArg != null) {\n+        // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n+        Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n+        while (fnParam != null) {\n+            // If there are no more arguments and the current parameter\n+            // is not optional or a rest parameter, then we cannot inline.\n+            if (cArg == null && !fnParam.isOptionalArg() && !fnParam.isRest()) {\n+                return CanInlineResult.NO;\n+            }\n+\n+            // Otherwise, check for side-effects and move on to the next parameter\n+            if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n+                return CanInlineResult.NO;\n+            }\n+            fnParam = fnParam.getNext();\n+\n+            // If there are still arguments, move on to the next argument\n+            if (cArg != null && !fnParam.isRest()) {\n+                cArg = cArg.getNext();\n+            }\n+        }\n \n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n+        // If there are any remaining arguments, return NO\n+        if (cArg != null) {\n             return CanInlineResult.NO;\n-          }\n         }\n \n-        // Move to the next name.\n-        fnParam = fnParam.getNext();\n-      }\n+        return CanInlineResult.YES;\n+    }\n \n-      // For every call argument check for side-effects, even if there\n-      // isn't a named parameter to match.\n-      if (cArg != null) {\n-        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n-          return CanInlineResult.NO;\n+    private boolean hasExceptionHandler(Node cfgNode) {\n+        List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+        for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+            if (edge.getValue() == Branch.ON_EX) {\n+                return true;\n+            }\n         }\n-        cArg = cArg.getNext();\n-      }\n+        return false;\n     }\n \n-    return CanInlineResult.YES;\n-  }\n+    private ControlFlowGraph<Node> getCfg() {\n+        // implementation\n+        return null;\n+    }\n+\n+    private static class Branch {\n+        static final Branch ON_EX = new Branch();\n+    }\n+\n+    private static class NodeUtil {\n+        static boolean isFunctionObjectApply(Node n) {\n+            // implementation\n+            return false;\n+        }\n+\n+        static boolean isFunctionObjectCall(Node n) {\n+            // implementation\n+            return false;\n+        }\n+\n+        static Node getFunctionParameters(Node fnNode) {\n+            // implementation\n+            return null;\n+        }\n+\n+        static int getNameReferenceCount(Node node, String name) {\n+            // implementation\n+            return 0;\n+        }\n+\n+        static boolean mayEffectMutableState(Node n, AbstractCompiler compiler) {\n+            // implementation\n+            return false;\n+        }\n+\n+        static boolean mayHaveSideEffects(Node n, AbstractCompiler compiler) {\n+            // implementation\n+            return false;\n+        }\n+    }\n+}\n \n   /**\n    * Determine if inlining the function is likely to reduce the code size.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}