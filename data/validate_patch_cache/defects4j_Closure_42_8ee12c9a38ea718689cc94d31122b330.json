{
    "patch": "static class TransformDispatcher implements TypeSafeDispatcher<Node> {\n\n    @Override\n    public Node defaultValue(Node n) {\n      throw new IllegalStateException(\"No Transform defined for \" + n);\n    }\n\n    @Override\n    public Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n\n    @Override\n    public Node processBreakStatement(BreakStatement statementNode) {\n      Node node = newNode(Token.BREAK);\n      if (statementNode.getBreakLabel() != null) {\n        Node labelName = transform(statementNode.getBreakLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    public Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            \"Catch clauses are not supported\",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    @Override\n    public Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n          Token.HOOK,\n          transform(exprNode.getTestExpression()),\n          transform(exprNode.getTrueExpression()),\n          transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    public Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = transform(statementNode.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    public Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n          Token.DO,\n          transformBlock(loopNode.getBody()),\n          transform(loopNode.getCondition()));\n    }\n\n    @Override\n    public Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }\n\n    @Override\n    public Node processEmptyExpression(EmptyExpression exprNode) {\n      return newNode(Token.EMPTY);\n    }\n\n    @Override\n    public Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n\n    @Override\n    public Node processForInLoop(ForInLoop loopNode) {\n      Node node = newNode(Token.FOR);\n      Node lhs = null;\n      AstNode rhs = null;\n\n      if (loopNode.isForEach()) {\n        // for each (LHS in RHS) BODY\n        lhs = newName(loopNode.getIterator().toSource());\n        rhs = loopNode.getIteratedObject();\n      } else {\n        // for (LHS in RHS) BODY\n        lhs = transform(loopNode.getIterator());\n        rhs = transform(loopNode.getIteratedObject());\n      }\n\n      Node body = transformBlock(loopNode.getBody());\n\n      node.addChildToBack(lhs);\n      node.addChildToBack(rhs);\n      node.addChildToBack(body);\n\n      return node;\n    }\n\n    @Override\n    public Node processForLoop(ForLoop loopNode) {\n      Node node = newNode(Token.FOR);\n\n      Node initial = transform(loopNode.getInitializer());\n      Node condition = transform(loopNode.getCondition());\n      Node increment = transform(loopNode.getIncrement());\n      Node body = transformBlock(loopNode.getBody());\n\n      if (initial.getType() == Token.VAR && initial.hasChildren()) {\n        // Hoist vars into the for loop init.\n        for (Node var = initial.getFirstChild(); var != null; var = var.getNext()) {\n          var.setType(Token.NAME);\n          node.addChildToBack(var);\n        }\n      } else {\n        node.addChildToBack(initial);\n      }\n\n      node.addChildToBack(condition);\n      node.addChildToBack(increment);\n      node.addChildToBack(body);\n\n      return node;\n    }\n\n    @Override\n    public Node processFunctionCall(FunctionCall callNode) {\n      return newNode(Token.CALL, transform(callNode.getTarget()));\n    }\n\n    @Override\n    public Node processFunctionNode(FunctionNode functionNode) {\n      Node node = newNode(Token.FUNCTION, functionNode.getFunctionName());\n      Node paramsNode = newNode(Token.PARAM_LIST);\n\n      for (Iterator<AstNode> it = functionNode.getParams().iterator(); it.hasNext(); ) {\n        AstNode param = it.next();\n        Node name = new StringNode(Token.NAME, param.getString(), param.getLineno());\n        paramsNode.addChildToBack(name);\n      }\n      node.addChildToBack(paramsNode);\n\n      Node body;\n      if (compilerOptions.foldConstants) {\n        // foldConstants will replace all string literals in function\n        // nodes with StringNodes, so we need to perform an initial\n        // deep clone before transform() mutates the AST, otherwise\n        // the BACK edge of the function's CFG will be invalidated by\n        // the cloning operation.\n        body = NodeUtil.clonedBodyFor(functionNode, functionNode.getBody());\n      } else {\n        body = transform(functionNode.getBody());\n      }\n      node.addChildToBack(body);\n\n      // The count in the function node is not updated with new variables\n      // created in the body. However, having an approximate count is good.\n      NodeUtil.updateExplicitUseOfVariables(node, functionNode);\n\n      return node;\n    }\n\n    @Override\n    public Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(Token.IF);\n\n      node.addChildToBack(\n          transform(statementNode.getCondition()));\n      node.addChildToBack(\n          transformBlock(statementNode.getThenPart()));\n\n      if (statementNode.getElsePart() != null) {\n        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n      }\n\n      return node;\n    }\n\n    @Override\n    public Node processInfixExpression(InfixExpression exprNode) {\n      return newNode(\n          transformTokenType(exprNode.getType()),\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n    }\n\n    @Override\n    public Node processLabeledStatement(LabeledStatement statementNode) {\n      String name = statementNode.getLabelName();\n      Node result = transform(statementNode.getStatement());\n      result.setLabelName(name);\n      return result;\n    }\n\n    @Override\n    public Node processName(Name nameNode) {\n      return newName(nameNode.getIdentifier());\n    }\n\n    @Override\n    public Node processNewExpression(NewExpression exprNode) {\n      return newNode(Token.NEW, transform(exprNode.getTarget()));\n    }\n\n    @Override\n    public Node processNumber(NumberLiteral numberNode) {\n      return newNumber(numberNode.getValue(), numberNode.getLineno());\n    }\n\n    @Override\n    public Node processObjectLiteral(ObjectLiteral objNode) {\n      return newNode(Token.OBJECTLIT);\n    }\n\n    @Override\n    public Node processParenthesizedExpression(\n        ParenthesizedExpression exprNode) {\n      return transform(exprNode.getExpression());\n    }\n\n    @Override\n    public Node processPropertyGet(PropertyGet getNode) {\n      return newNode(\n          Token.GETPROP,\n          transform(getNode.getTarget()),\n          newName(getNode.getProperty().getIdentifier()));\n    }\n\n    @Override\n    public Node processRegExpLiteral(RegExpLiteral literalNode) {\n      return newRegExp(literalNode.getValue(), literalNode.getFlags());\n    }\n\n    @Override\n    public Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = newNode(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      }\n      return node;\n    }\n\n    @Override\n    public Node processString(StringLiteral stringNode) {\n      return newString(stringNode.getValue());\n    }\n\n    @Override\n    public Node processSwitchCase(SwitchCase caseNode) {\n      if (caseNode.isDefault()) {\n        return newNode(\n            Token.DEFAULT,\n            transformSwitchBlock(caseNode));\n      } else {\n        return newNode(\n            Token.CASE,\n            transform(caseNode.getExpression()),\n            transformSwitchBlock(caseNode));\n      }\n    }\n\n    @Override\n    public Node processSwitchStatement(SwitchStatement statementNode) {\n      Node node = newNode(Token.SWITCH);\n      Node expr = transform(statementNode.getExpression());\n\n      node.addChildToBack(expr);\n      for (SwitchCase caseNode = statementNode.getCases();\n           caseNode != null;\n           caseNode = caseNode.getNext()) {\n        node.addChildToBack(transform(caseNode));\n      }\n\n      return node;\n    }\n\n    @Override\n    public Node processThrowStatement(ThrowStatement statementNode) {\n      return newNode(Token.THROW, transform(statementNode.getExpression()));\n    }\n\n    @Override\n    public Node processTryStatement(TryStatement statementNode) {\n      Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n\n      if (statementNode.getCatchClauses() != null) {\n        Node catchBlock = newNode(Token.BLOCK);\n        for (CatchClause clause : statementNode.getCatchClauses()) {\n          catchBlock.addChildToBack(transform(clause));\n        }\n        node.addChildToBack(catchBlock);\n      }\n\n      if (statementNode.getFinallyBlock() != null) {\n        node.addChildToBack(\n            newNode(\n                Token.FINALLY,\n                transformBlock(statementNode.getFinallyBlock())));\n      }\n\n      return node;\n    }\n\n    @Override\n    public Node processUnaryExpression(UnaryExpression exprNode) {\n      // Token.POS and Token.NEG are the same thing.\n      Token tokenType = exprNode.getType();\n      if (tokenType == Token.POS || tokenType == Token.NEG) {\n        return newUnary(tokenType, transform(exprNode.getOperand()));\n      } else {\n        return newNode(transformTokenType(tokenType),\n                       transform(exprNode.getOperand()));\n      }\n    }\n\n    @Override\n    public Node processVariableDeclaration(\n        VariableDeclaration declarationNode) {\n      if (declarationNode.getVariables().size() == 1 &&\n          declarationNode.getType() == Token.VAR) {\n        // VAR is the default; leaving it out reduces file size.\n        return newNode(Token.NAME, declarationNode.getVariables().get(0).getName());\n      } else {\n        Node result = newNode(Token.BLOCK);\n        for (VariableInitializer initializer : declarationNode.getVariables()) {\n          Node node = newNode(Token.NAME, initializer.getName());\n          if (initializer.getInitializer() != null) {\n            node.addChildToBack(transform(initializer.getInitializer()));\n          }\n          result.addChildToBack(newNode(Token.EXPR_RESULT, node));\n        }\n        return result;\n      }\n    }\n\n    @Override\n    public Node processVariableInitializer(\n        VariableInitializer initializerNode) {\n      if (initializerNode.getInitializer() != null) {\n        return transform(initializerNode.getInitializer());\n      } else {\n        return newNode(Token.NULL);\n      }\n    }\n\n    @Override\n    public Node processWhileLoop(WhileLoop loopNode) {\n      Node node = newNode(Token.WHILE);\n      node.addChildToBack(\n          transform(loopNode.getCondition()));\n      node.addChildToBack(\n          transformBlock(loopNode.getBody()));\n      return node;\n    }\n\n    @Override\n    public Node processWithStatement(WithStatement statementNode) {\n      errorReporter.warning(\n          \"With statements are not supported\",\n          sourceName,\n          statementNode.getLineno(), \"\", 0);\n      return transform(statementNode.getStatement());\n    }\n\n    @Override\n    public Node processArrayLiteral(ArrayLiteral literalNode) {\n      Node node = newNode(Token.ARRAYLIT);\n      for (AstNode elem : literalNode.getElements()) {\n        node.addChildToBack(transform(elem));\n      }\n      return node;\n    }\n\n    @Override\n    public Node processAstRoot(AstRoot astRoot) {\n      return process((Node) astRoot);\n    }\n\n    @Override\n    public Node processAssignment(\n        Assignment assignmentNode) {\n      Token type = transformTokenType(assignmentNode.getType());\n      if (type == Token.ASSIGN) {\n        Node expr = newNode(Token.ASSIGN);\n        expr.addChildToBack(\n            transform(assignmentNode.getLeft()));\n        expr.addChildToBack(\n            transform(assignmentNode.getRight()));\n        return expr;\n      } else {\n        Node assignTarget = transform(assignmentNode.getLeft());\n        Node newTarget = null;\n        if (type == Token.ASSIGN_ADD) {\n          newTarget = binaryNode(Token.ADD, assignTarget, assignmentNode.getRight());\n        } else if (type == Token.ASSIGN_SUB) {\n          newTarget = binaryNode(Token.SUB, assignTarget, assignmentNode.getRight());\n        } else if (type == Token.ASSIGN_MUL) {\n          newTarget = binaryNode(Token.MUL, assignTarget, assignmentNode.getRight());\n        } else if (type == Token.ASSIGN_DIV) {\n          newTarget = binaryNode(Token.DIV, assignTarget, assignmentNode.getRight());\n        } else if (type == Token.ASSIGN_MOD) {\n          newTarget = binaryNode(Token.MOD, assignTarget, assignmentNode.getRight());\n        } else if (type == Token.ASSIGN_BITOR) {\n          newTarget = binaryNode(Token.BITOR, assignTarget, assignmentNode.getRight());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..410f0cb0 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -472,23 +472,20 @@ class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+static class TransformDispatcher implements TypeSafeDispatcher<Node> {\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n-\n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    @Override\n+    public Node defaultValue(Node n) {\n+      throw new IllegalStateException(\"No Transform defined for \" + n);\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n+    public Node processBlock(Block blockNode) {\n       return processGeneric(blockNode);\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n+    public Node processBreakStatement(BreakStatement statementNode) {\n       Node node = newNode(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n         Node labelName = transform(statementNode.getBreakLabel());\n@@ -500,7 +497,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n+    public Node processCatchClause(CatchClause clauseNode) {\n       AstNode catchVar = clauseNode.getVarName();\n       Node node = newNode(Token.CATCH, transform(catchVar));\n       if (clauseNode.getCatchCondition() != null) {\n@@ -514,7 +511,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+    public Node processConditionalExpression(ConditionalExpression exprNode) {\n       return newNode(\n           Token.HOOK,\n           transform(exprNode.getTestExpression()),\n@@ -523,7 +520,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n+    public Node processContinueStatement(ContinueStatement statementNode) {\n       Node node = newNode(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n         Node labelName = transform(statementNode.getLabel());\n@@ -535,7 +532,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n+    public Node processDoLoop(DoLoop loopNode) {\n       return newNode(\n           Token.DO,\n           transformBlock(loopNode.getBody()),\n@@ -543,7 +540,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n+    public Node processElementGet(ElementGet getNode) {\n       return newNode(\n           Token.GETELEM,\n           transform(getNode.getTarget()),\n@@ -551,29 +548,348 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node processEmptyExpression(EmptyExpression exprNode) {\n+      return newNode(Token.EMPTY);\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n+    public Node processExpressionStatement(ExpressionStatement statementNode) {\n       Node node = newNode(transformTokenType(statementNode.getType()));\n       node.addChildToBack(transform(statementNode.getExpression()));\n       return node;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node processForInLoop(ForInLoop loopNode) {\n+      Node node = newNode(Token.FOR);\n+      Node lhs = null;\n+      AstNode rhs = null;\n+\n+      if (loopNode.isForEach()) {\n+        // for each (LHS in RHS) BODY\n+        lhs = newName(loopNode.getIterator().toSource());\n+        rhs = loopNode.getIteratedObject();\n+      } else {\n+        // for (LHS in RHS) BODY\n+        lhs = transform(loopNode.getIterator());\n+        rhs = transform(loopNode.getIteratedObject());\n+      }\n+\n+      Node body = transformBlock(loopNode.getBody());\n+\n+      node.addChildToBack(lhs);\n+      node.addChildToBack(rhs);\n+      node.addChildToBack(body);\n+\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processForLoop(ForLoop loopNode) {\n+      Node node = newNode(Token.FOR);\n+\n+      Node initial = transform(loopNode.getInitializer());\n+      Node condition = transform(loopNode.getCondition());\n+      Node increment = transform(loopNode.getIncrement());\n+      Node body = transformBlock(loopNode.getBody());\n+\n+      if (initial.getType() == Token.VAR && initial.hasChildren()) {\n+        // Hoist vars into the for loop init.\n+        for (Node var = initial.getFirstChild(); var != null; var = var.getNext()) {\n+          var.setType(Token.NAME);\n+          node.addChildToBack(var);\n+        }\n+      } else {\n+        node.addChildToBack(initial);\n+      }\n+\n+      node.addChildToBack(condition);\n+      node.addChildToBack(increment);\n+      node.addChildToBack(body);\n+\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processFunctionCall(FunctionCall callNode) {\n+      return newNode(Token.CALL, transform(callNode.getTarget()));\n+    }\n+\n+    @Override\n+    public Node processFunctionNode(FunctionNode functionNode) {\n+      Node node = newNode(Token.FUNCTION, functionNode.getFunctionName());\n+      Node paramsNode = newNode(Token.PARAM_LIST);\n+\n+      for (Iterator<AstNode> it = functionNode.getParams().iterator(); it.hasNext(); ) {\n+        AstNode param = it.next();\n+        Node name = new StringNode(Token.NAME, param.getString(), param.getLineno());\n+        paramsNode.addChildToBack(name);\n+      }\n+      node.addChildToBack(paramsNode);\n+\n+      Node body;\n+      if (compilerOptions.foldConstants) {\n+        // foldConstants will replace all string literals in function\n+        // nodes with StringNodes, so we need to perform an initial\n+        // deep clone before transform() mutates the AST, otherwise\n+        // the BACK edge of the function's CFG will be invalidated by\n+        // the cloning operation.\n+        body = NodeUtil.clonedBodyFor(functionNode, functionNode.getBody());\n+      } else {\n+        body = transform(functionNode.getBody());\n+      }\n+      node.addChildToBack(body);\n+\n+      // The count in the function node is not updated with new variables\n+      // created in the body. However, having an approximate count is good.\n+      NodeUtil.updateExplicitUseOfVariables(node, functionNode);\n \n-        // Return the bare minimum to put the AST in a valid state.\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processIfStatement(IfStatement statementNode) {\n+      Node node = newNode(Token.IF);\n+\n+      node.addChildToBack(\n+          transform(statementNode.getCondition()));\n+      node.addChildToBack(\n+          transformBlock(statementNode.getThenPart()));\n+\n+      if (statementNode.getElsePart() != null) {\n+        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n+      }\n+\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processInfixExpression(InfixExpression exprNode) {\n       return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n+          transformTokenType(exprNode.getType()),\n+          transform(exprNode.getLeft()),\n+          transform(exprNode.getRight()));\n+    }\n+\n+    @Override\n+    public Node processLabeledStatement(LabeledStatement statementNode) {\n+      String name = statementNode.getLabelName();\n+      Node result = transform(statementNode.getStatement());\n+      result.setLabelName(name);\n+      return result;\n+    }\n+\n+    @Override\n+    public Node processName(Name nameNode) {\n+      return newName(nameNode.getIdentifier());\n+    }\n+\n+    @Override\n+    public Node processNewExpression(NewExpression exprNode) {\n+      return newNode(Token.NEW, transform(exprNode.getTarget()));\n+    }\n+\n+    @Override\n+    public Node processNumber(NumberLiteral numberNode) {\n+      return newNumber(numberNode.getValue(), numberNode.getLineno());\n+    }\n+\n+    @Override\n+    public Node processObjectLiteral(ObjectLiteral objNode) {\n+      return newNode(Token.OBJECTLIT);\n+    }\n+\n+    @Override\n+    public Node processParenthesizedExpression(\n+        ParenthesizedExpression exprNode) {\n+      return transform(exprNode.getExpression());\n+    }\n+\n+    @Override\n+    public Node processPropertyGet(PropertyGet getNode) {\n+      return newNode(\n+          Token.GETPROP,\n+          transform(getNode.getTarget()),\n+          newName(getNode.getProperty().getIdentifier()));\n+    }\n+\n+    @Override\n+    public Node processRegExpLiteral(RegExpLiteral literalNode) {\n+      return newRegExp(literalNode.getValue(), literalNode.getFlags());\n+    }\n+\n+    @Override\n+    public Node processReturnStatement(ReturnStatement statementNode) {\n+      Node node = newNode(Token.RETURN);\n+      if (statementNode.getReturnValue() != null) {\n+        node.addChildToBack(transform(statementNode.getReturnValue()));\n+      }\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processString(StringLiteral stringNode) {\n+      return newString(stringNode.getValue());\n+    }\n+\n+    @Override\n+    public Node processSwitchCase(SwitchCase caseNode) {\n+      if (caseNode.isDefault()) {\n+        return newNode(\n+            Token.DEFAULT,\n+            transformSwitchBlock(caseNode));\n+      } else {\n+        return newNode(\n+            Token.CASE,\n+            transform(caseNode.getExpression()),\n+            transformSwitchBlock(caseNode));\n+      }\n+    }\n+\n+    @Override\n+    public Node processSwitchStatement(SwitchStatement statementNode) {\n+      Node node = newNode(Token.SWITCH);\n+      Node expr = transform(statementNode.getExpression());\n+\n+      node.addChildToBack(expr);\n+      for (SwitchCase caseNode = statementNode.getCases();\n+           caseNode != null;\n+           caseNode = caseNode.getNext()) {\n+        node.addChildToBack(transform(caseNode));\n+      }\n+\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processThrowStatement(ThrowStatement statementNode) {\n+      return newNode(Token.THROW, transform(statementNode.getExpression()));\n+    }\n+\n+    @Override\n+    public Node processTryStatement(TryStatement statementNode) {\n+      Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+\n+      if (statementNode.getCatchClauses() != null) {\n+        Node catchBlock = newNode(Token.BLOCK);\n+        for (CatchClause clause : statementNode.getCatchClauses()) {\n+          catchBlock.addChildToBack(transform(clause));\n+        }\n+        node.addChildToBack(catchBlock);\n+      }\n+\n+      if (statementNode.getFinallyBlock() != null) {\n+        node.addChildToBack(\n+            newNode(\n+                Token.FINALLY,\n+                transformBlock(statementNode.getFinallyBlock())));\n+      }\n+\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processUnaryExpression(UnaryExpression exprNode) {\n+      // Token.POS and Token.NEG are the same thing.\n+      Token tokenType = exprNode.getType();\n+      if (tokenType == Token.POS || tokenType == Token.NEG) {\n+        return newUnary(tokenType, transform(exprNode.getOperand()));\n+      } else {\n+        return newNode(transformTokenType(tokenType),\n+                       transform(exprNode.getOperand()));\n+      }\n+    }\n+\n+    @Override\n+    public Node processVariableDeclaration(\n+        VariableDeclaration declarationNode) {\n+      if (declarationNode.getVariables().size() == 1 &&\n+          declarationNode.getType() == Token.VAR) {\n+        // VAR is the default; leaving it out reduces file size.\n+        return newNode(Token.NAME, declarationNode.getVariables().get(0).getName());\n+      } else {\n+        Node result = newNode(Token.BLOCK);\n+        for (VariableInitializer initializer : declarationNode.getVariables()) {\n+          Node node = newNode(Token.NAME, initializer.getName());\n+          if (initializer.getInitializer() != null) {\n+            node.addChildToBack(transform(initializer.getInitializer()));\n+          }\n+          result.addChildToBack(newNode(Token.EXPR_RESULT, node));\n+        }\n+        return result;\n+      }\n+    }\n+\n+    @Override\n+    public Node processVariableInitializer(\n+        VariableInitializer initializerNode) {\n+      if (initializerNode.getInitializer() != null) {\n+        return transform(initializerNode.getInitializer());\n+      } else {\n+        return newNode(Token.NULL);\n+      }\n+    }\n+\n+    @Override\n+    public Node processWhileLoop(WhileLoop loopNode) {\n+      Node node = newNode(Token.WHILE);\n+      node.addChildToBack(\n+          transform(loopNode.getCondition()));\n+      node.addChildToBack(\n           transformBlock(loopNode.getBody()));\n+      return node;\n+    }\n+\n+    @Override\n+    public Node processWithStatement(WithStatement statementNode) {\n+      errorReporter.warning(\n+          \"With statements are not supported\",\n+          sourceName,\n+          statementNode.getLineno(), \"\", 0);\n+      return transform(statementNode.getStatement());\n+    }\n+\n+    @Override\n+    public Node processArrayLiteral(ArrayLiteral literalNode) {\n+      Node node = newNode(Token.ARRAYLIT);\n+      for (AstNode elem : literalNode.getElements()) {\n+        node.addChildToBack(transform(elem));\n+      }\n+      return node;\n     }\n \n+    @Override\n+    public Node processAstRoot(AstRoot astRoot) {\n+      return process((Node) astRoot);\n+    }\n+\n+    @Override\n+    public Node processAssignment(\n+        Assignment assignmentNode) {\n+      Token type = transformTokenType(assignmentNode.getType());\n+      if (type == Token.ASSIGN) {\n+        Node expr = newNode(Token.ASSIGN);\n+        expr.addChildToBack(\n+            transform(assignmentNode.getLeft()));\n+        expr.addChildToBack(\n+            transform(assignmentNode.getRight()));\n+        return expr;\n+      } else {\n+        Node assignTarget = transform(assignmentNode.getLeft());\n+        Node newTarget = null;\n+        if (type == Token.ASSIGN_ADD) {\n+          newTarget = binaryNode(Token.ADD, assignTarget, assignmentNode.getRight());\n+        } else if (type == Token.ASSIGN_SUB) {\n+          newTarget = binaryNode(Token.SUB, assignTarget, assignmentNode.getRight());\n+        } else if (type == Token.ASSIGN_MUL) {\n+          newTarget = binaryNode(Token.MUL, assignTarget, assignmentNode.getRight());\n+        } else if (type == Token.ASSIGN_DIV) {\n+          newTarget = binaryNode(Token.DIV, assignTarget, assignmentNode.getRight());\n+        } else if (type == Token.ASSIGN_MOD) {\n+          newTarget = binaryNode(Token.MOD, assignTarget, assignmentNode.getRight());\n+        } else if (type == Token.ASSIGN_BITOR) {\n+          newTarget = binaryNode(Token.BITOR, assignTarget, assignmentNode.getRight());\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}