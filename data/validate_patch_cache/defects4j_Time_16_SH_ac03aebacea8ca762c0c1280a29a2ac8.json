{
    "patch": "        long instantLocal = instantMillis;\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            instantLocal -= bucket.getOffsetInteger().intValue();\n        }\n        instantLocal = chrono.getZone().convertLocalToUTC(instantLocal, false);\n        Chronology chronoUTC = chrono.withUTC();\n        int defaultYear = iDefaultYear;\n        if (defaultYear != Integer.MIN_VALUE && bucket.getOffsetInteger() == null &&\n            (bucket.getZone() == null || bucket.getZone() == DateTimeZone.UTC)) {\n            chronoUTC = chrono.withUTC().withYear(defaultYear);\n        }\n        instantLocal = bucket.computeMillis(false, text, chronoUTC);",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex a4b16127..8646bd5b 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -706,7 +706,18 @@ public class DateTimeFormatter {\n         chrono = selectChronology(chrono);\n         \n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, iDefaultYear);\n+        long instantLocal = instantMillis;\n+        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n+            instantLocal -= bucket.getOffsetInteger().intValue();\n+        }\n+        instantLocal = chrono.getZone().convertLocalToUTC(instantLocal, false);\n+        Chronology chronoUTC = chrono.withUTC();\n+        int defaultYear = iDefaultYear;\n+        if (defaultYear != Integer.MIN_VALUE && bucket.getOffsetInteger() == null &&\n+            (bucket.getZone() == null || bucket.getZone() == DateTimeZone.UTC)) {\n+            chronoUTC = chrono.withUTC().withYear(defaultYear);\n+        }\n+        instantLocal = bucket.computeMillis(false, text, chronoUTC);\n         int newPos = parser.parseInto(bucket, text, position);\n         instant.setMillis(bucket.computeMillis(false, text));\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {",
    "result_reason": "error: '.class' expected",
    "test_result": "ERROR"
}