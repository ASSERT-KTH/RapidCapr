{
    "patch": "for (int i = 0; i < count; i++) {\n    try {\n        millis = savedFields[i].set(millis, resetFields);\n    } catch (IllegalFieldValueException ex) {\n        if (text != null) {\n            ex.prependMessage(\"Cannot parse \\\"\" + text + \"\\\"\");\n        }\n        throw ex;\n    }\n    if (getRoundingMode(savedFields[i].iField) == ROUND_NONE) {\n        int i2 = i + 1;\n        while (i2 < count && getRoundingMode(savedFields[i2].iField) == ROUND_NONE) {\n            i2 += 1;\n        }\n        long value = computeMillis(savedFields, i, i2, millis);\n        if (i2 >= count || !savedFields[i2].iField.isLeapable()) {\n            millis = value;\n            i = i2 - 1;\n        } else {\n            Chronology chrono = savedFields[i2].iChronology;\n            long nextMillis = computeMillis(savedFields, i2, count, value);\n            LocalDate date = new LocalDate(value, chrono);\n            int year = date.getYear();\n            millis = computeMillis(savedFields, i, i2 - 1, chrono.year().set(nextMillis, year));\n            if (millis > value) {\n                i = i2 - 1;\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..42e64503 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,36 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+for (int i = 0; i < count; i++) {\n+    try {\n+        millis = savedFields[i].set(millis, resetFields);\n+    } catch (IllegalFieldValueException ex) {\n+        if (text != null) {\n+            ex.prependMessage(\"Cannot parse \\\"\" + text + \"\\\"\");\n+        }\n+        throw ex;\n+    }\n+    if (getRoundingMode(savedFields[i].iField) == ROUND_NONE) {\n+        int i2 = i + 1;\n+        while (i2 < count && getRoundingMode(savedFields[i2].iField) == ROUND_NONE) {\n+            i2 += 1;\n+        }\n+        long value = computeMillis(savedFields, i, i2, millis);\n+        if (i2 >= count || !savedFields[i2].iField.isLeapable()) {\n+            millis = value;\n+            i = i2 - 1;\n+        } else {\n+            Chronology chrono = savedFields[i2].iChronology;\n+            long nextMillis = computeMillis(savedFields, i2, count, value);\n+            LocalDate date = new LocalDate(value, chrono);\n+            int year = date.getYear();\n+            millis = computeMillis(savedFields, i, i2 - 1, chrono.year().set(nextMillis, year));\n+            if (millis > value) {\n+                i = i2 - 1;\n+            }\n+        }\n+    }\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}