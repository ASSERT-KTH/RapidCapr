{
    "patch": "  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    // Invariant: All the objectLit children of a de-aliased name have null parent pointers.\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    Name currentName, childName;\n    while (!workList.isEmpty()) {\n        currentName = workList.pop();\n\n        // Don't attempt to inline a getter or setter property as a variable.\n        if (currentName.type == Name.Type.GET || currentName.type == Name.Type.SET) {\n            continue;\n        }\n\n        if (currentName.globalSets == 1 && currentName.localSets == 0 &&\n                currentName.aliasingGets > 0) {\n            // {@code currentName} meets condition (b).\n            // Find all its local get and aliasing gets.\n            List<Ref> refs = new ArrayList<>(currentName.getRefs());\n            Set<Name> localGetChildNames = new HashSet<>();\n            Set<Name> aliasingGetChildNames = new HashSet<>();\n            for (Ref ref : refs) {\n                childName = ref.node;\n                if (!childName.isGetProp() || !childName.scope.isLocal()) {\n                    continue;\n                }\n                if (ref.type == Ref.Type.ALIASING_GET) {\n                    aliasingGetChildNames.add(childName);\n                } else if (ref.type == Ref.Type.GET) {\n                    localGetChildNames.add(childName);\n                }\n            }\n\n            // De-alias the children that could be inlined.\n            boolean canChildrenNamesBeInlined = true;\n            if (!localGetChildNames.isEmpty() || !aliasingGetChildNames.isEmpty()) {\n                Map<Name, Name> aliasMap = new LinkedHashMap<>();\n                for (Name child: localGetChildNames) {\n                    canChildrenNamesBeInlined =\n                            canChildrenNamesBeInlined && (child.aliasingGets == 0 || child.refSet.isEmpty());\n                    aliasMap.put(child, inlineAliasIfPossible(child.getSingleRef(), namespace, aliasMap));\n                }\n                for (Name child : aliasingGetChildNames) {\n                    canChildrenNamesBeInlined = canChildrenNamesBeInlined && child.aliasingGets == 0;\n                    aliasMap.put(child, currentName);\n                }\n\n                if (canChildrenNamesBeInlined) {\n                    // Add all of {@code name}'s children that do not have\n                    // any aliases left after de-aliasing to the work list.\n                    workList.addAll(getDealiasedChildNames(currentName, aliasMap));\n                }\n            }\n        }\n\n        // Check if {@code name} has any object literal children left after the\n        // local-alias-inlining above.\n        if (currentName.type == Name.Type.OBJECTLIT &&\n                (currentName.aliasingGets == 0 || currentName.refSet.isEmpty()) &&\n                currentName.props != null) {\n            workList.addAll(getDealiasedChildNames(currentName, Collections.emptyMap()));\n        }\n    }\n  }\n  \n  private List<Name> getDealiasedChildNames(Name objectLiteralName, Map<Name, Name> aliasMap) {\n        List<Name> dealiasedChildNames = new ArrayList<>();\n        for (Name childName : objectLiteralName.props) {\n            if (!aliasMap.containsKey(childName)) {\n                childName.parent = objectLiteralName;\n                dealiasedChildNames.add(childName);\n            }\n        }\n        objectLiteralName.props = null;\n        return dealiasedChildNames;\n    }\n\n  private Name inlineAliasIfPossible(Ref ref, GlobalNamespace namespace, Map<Name, Name> aliasMap) {\n    // The {@code currentScope} in which the ref is being looked up.\n    Scope currentScope = ref.scope;\n    // Only consider other aliasing GETs in the same scope, or GETs in the same scope that are\n    // transitively referencing other aliasing GETs in the same scope.\n    Set<Ref> refsToCheck = Sets.newHashSet(ref);\n    Set<Ref> seenRefsToCheck = Sets.newHashSet(ref);\n    Set<Ref> seenRefsToConsider = Sets.newHashSet(ref);\n    while (!refsToCheck.isEmpty()) {\n      Ref refToCheck = refsToCheck.iterator().next();\n      refsToCheck.remove(refToCheck);\n      Name name = refToCheck.node;\n      for (Ref reference : name.getRefs()) {\n        if (reference == ref ||\n            reference.type == Ref.Type.SET ||\n            seenRefsToConsider.contains(reference)) {\n          continue;\n        } else if (reference.type != Ref.Type.ALIASING_GET &&\n                   reference.type != Ref.Type.GET) {\n          break;\n        } else if (reference.type == Ref.Type.ALIASING_GET &&\n                   reference.scope == currentScope) {\n          seenRefsToConsider.add(reference);\n          refsToCheck.add(reference);\n          seenRefsToCheck.add(reference);\n        } else if (reference.type == Ref.Type.GET &&\n            reference.scope == currentScope) {\n          seenRefsToConsider.add(reference);\n          refsToCheck.addAll(getRefsToCheckFor(scope, reference, seenRefsToCheck));\n        }\n      }\n    }\n\n    if (ref.isSimpleAssignLhs() || seenRefsToConsider.size() == 1) {\n      return null;\n    }\n\n    Name originalName = ref.node;\n    Map<Object, Name> propertyMap = new LinkedHashMap<Object, Name>();\n    List<String> props = new ArrayList<>();\n    for (Ref aliasRef : seenRefsToConsider) {\n      Name aliasName = new Name(aliasRef.getNode().getQualifiedName(), aliasRef.getNode(), null);\n      aliasName.type = aliasRef.getNode().isFunction() ? Name.Type.FUNCTION : Name.Type.VARIABLE;\n      aliasName.setOriginalName(originalName.getOriginalName());\n      propertyMap.put(aliasRef, aliasName);\n      props.add(aliasRef.getNode().getLastProp());\n      if (aliasRef == ref) {\n        aliasName.initializeAliasReferences(originalName);\n      } else {\n        aliasName.initializeAliasReferences(aliasRef.getNode());\n      }\n    }\n\n    Name parent = originalName.parent;\n    Name newName = new Name(props, propertyMap, parent, originalName.isExported());\n    newName.setType(originalName.getType(), originalName.getDeclaration());\n    newName.setOriginalName(originalName.getOriginalName());\n    newName.copySets(originalName);\n    if (aliasMap.containsKey(originalName)) {\n        aliasMap.put(newName, aliasMap.get(originalName));\n    }   else {\n        aliasMap.put(newName, originalName);\n    }\n\n    // Fix local and global counts on originalName and newName.\n    // Fix reference chains on all names aliased.\n    for (Map.Entry<Object, Name> entry : propertyMap.entrySet()) {\n      Ref aliasRef = (Ref) entry.getKey();\n      Name aliasName = entry.getValue();\n      if (aliasRef == ref) {\n        namespace.removeRef(aliasRef);\n        newName.addRef(ref);\n      } else {\n        aliasName.addRef(aliasRef);\n        aliasRef.updateName(aliasName);\n      }\n    }\n\n    namespace.getNameIndex().put(props.get(props.size() - 1), newName);\n    return newName;\n  }\n\n  private Name inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n    return inlineAliasIfPossible(ref, namespace, Collections.emptyMap());\n  }\n\n  private Set<Ref> getRefsToCheckFor(Scope scope, Ref ref, Set<Ref> seenRefsToCheck) {\n    Set<Ref> refsToCheck = Sets.newHashSet();\n    for (Ref reference : ref.getNode().getRefs()) {\n      if (reference.type == Ref.Type.ALIASING_GET &&\n          reference.scope == scope &&\n          !seenRefsToCheck.contains(reference)) {\n        refsToCheck.add(reference);\n      }\n    }\n    return refsToCheck;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..d05c7943 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -160,40 +160,176 @@ class CollapseProperties implements CompilerPass {\n    */\n   private void inlineAliases(GlobalNamespace namespace) {\n     // Invariant: All the names in the worklist meet condition (a).\n+    // Invariant: All the objectLit children of a de-aliased name have null parent pointers.\n     Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n+    Name currentName, childName;\n     while (!workList.isEmpty()) {\n-      Name name = workList.pop();\n+        currentName = workList.pop();\n \n-      // Don't attempt to inline a getter or setter property as a variable.\n-      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n-        continue;\n-      }\n+        // Don't attempt to inline a getter or setter property as a variable.\n+        if (currentName.type == Name.Type.GET || currentName.type == Name.Type.SET) {\n+            continue;\n+        }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+        if (currentName.globalSets == 1 && currentName.localSets == 0 &&\n+                currentName.aliasingGets > 0) {\n+            // {@code currentName} meets condition (b).\n+            // Find all its local get and aliasing gets.\n+            List<Ref> refs = new ArrayList<>(currentName.getRefs());\n+            Set<Name> localGetChildNames = new HashSet<>();\n+            Set<Name> aliasingGetChildNames = new HashSet<>();\n+            for (Ref ref : refs) {\n+                childName = ref.node;\n+                if (!childName.isGetProp() || !childName.scope.isLocal()) {\n+                    continue;\n+                }\n+                if (ref.type == Ref.Type.ALIASING_GET) {\n+                    aliasingGetChildNames.add(childName);\n+                } else if (ref.type == Ref.Type.GET) {\n+                    localGetChildNames.add(childName);\n+                }\n             }\n-          }\n+\n+            // De-alias the children that could be inlined.\n+            boolean canChildrenNamesBeInlined = true;\n+            if (!localGetChildNames.isEmpty() || !aliasingGetChildNames.isEmpty()) {\n+                Map<Name, Name> aliasMap = new LinkedHashMap<>();\n+                for (Name child: localGetChildNames) {\n+                    canChildrenNamesBeInlined =\n+                            canChildrenNamesBeInlined && (child.aliasingGets == 0 || child.refSet.isEmpty());\n+                    aliasMap.put(child, inlineAliasIfPossible(child.getSingleRef(), namespace, aliasMap));\n+                }\n+                for (Name child : aliasingGetChildNames) {\n+                    canChildrenNamesBeInlined = canChildrenNamesBeInlined && child.aliasingGets == 0;\n+                    aliasMap.put(child, currentName);\n+                }\n+\n+                if (canChildrenNamesBeInlined) {\n+                    // Add all of {@code name}'s children that do not have\n+                    // any aliases left after de-aliasing to the work list.\n+                    workList.addAll(getDealiasedChildNames(currentName, aliasMap));\n+                }\n+            }\n+        }\n+\n+        // Check if {@code name} has any object literal children left after the\n+        // local-alias-inlining above.\n+        if (currentName.type == Name.Type.OBJECTLIT &&\n+                (currentName.aliasingGets == 0 || currentName.refSet.isEmpty()) &&\n+                currentName.props != null) {\n+            workList.addAll(getDealiasedChildNames(currentName, Collections.emptyMap()));\n+        }\n+    }\n+  }\n+  \n+  private List<Name> getDealiasedChildNames(Name objectLiteralName, Map<Name, Name> aliasMap) {\n+        List<Name> dealiasedChildNames = new ArrayList<>();\n+        for (Name childName : objectLiteralName.props) {\n+            if (!aliasMap.containsKey(childName)) {\n+                childName.parent = objectLiteralName;\n+                dealiasedChildNames.add(childName);\n+            }\n+        }\n+        objectLiteralName.props = null;\n+        return dealiasedChildNames;\n+    }\n+\n+  private Name inlineAliasIfPossible(Ref ref, GlobalNamespace namespace, Map<Name, Name> aliasMap) {\n+    // The {@code currentScope} in which the ref is being looked up.\n+    Scope currentScope = ref.scope;\n+    // Only consider other aliasing GETs in the same scope, or GETs in the same scope that are\n+    // transitively referencing other aliasing GETs in the same scope.\n+    Set<Ref> refsToCheck = Sets.newHashSet(ref);\n+    Set<Ref> seenRefsToCheck = Sets.newHashSet(ref);\n+    Set<Ref> seenRefsToConsider = Sets.newHashSet(ref);\n+    while (!refsToCheck.isEmpty()) {\n+      Ref refToCheck = refsToCheck.iterator().next();\n+      refsToCheck.remove(refToCheck);\n+      Name name = refToCheck.node;\n+      for (Ref reference : name.getRefs()) {\n+        if (reference == ref ||\n+            reference.type == Ref.Type.SET ||\n+            seenRefsToConsider.contains(reference)) {\n+          continue;\n+        } else if (reference.type != Ref.Type.ALIASING_GET &&\n+                   reference.type != Ref.Type.GET) {\n+          break;\n+        } else if (reference.type == Ref.Type.ALIASING_GET &&\n+                   reference.scope == currentScope) {\n+          seenRefsToConsider.add(reference);\n+          refsToCheck.add(reference);\n+          seenRefsToCheck.add(reference);\n+        } else if (reference.type == Ref.Type.GET &&\n+            reference.scope == currentScope) {\n+          seenRefsToConsider.add(reference);\n+          refsToCheck.addAll(getRefsToCheckFor(scope, reference, seenRefsToCheck));\n         }\n       }\n+    }\n+\n+    if (ref.isSimpleAssignLhs() || seenRefsToConsider.size() == 1) {\n+      return null;\n+    }\n+\n+    Name originalName = ref.node;\n+    Map<Object, Name> propertyMap = new LinkedHashMap<Object, Name>();\n+    List<String> props = new ArrayList<>();\n+    for (Ref aliasRef : seenRefsToConsider) {\n+      Name aliasName = new Name(aliasRef.getNode().getQualifiedName(), aliasRef.getNode(), null);\n+      aliasName.type = aliasRef.getNode().isFunction() ? Name.Type.FUNCTION : Name.Type.VARIABLE;\n+      aliasName.setOriginalName(originalName.getOriginalName());\n+      propertyMap.put(aliasRef, aliasName);\n+      props.add(aliasRef.getNode().getLastProp());\n+      if (aliasRef == ref) {\n+        aliasName.initializeAliasReferences(originalName);\n+      } else {\n+        aliasName.initializeAliasReferences(aliasRef.getNode());\n+      }\n+    }\n+\n+    Name parent = originalName.parent;\n+    Name newName = new Name(props, propertyMap, parent, originalName.isExported());\n+    newName.setType(originalName.getType(), originalName.getDeclaration());\n+    newName.setOriginalName(originalName.getOriginalName());\n+    newName.copySets(originalName);\n+    if (aliasMap.containsKey(originalName)) {\n+        aliasMap.put(newName, aliasMap.get(originalName));\n+    }   else {\n+        aliasMap.put(newName, originalName);\n+    }\n+\n+    // Fix local and global counts on originalName and newName.\n+    // Fix reference chains on all names aliased.\n+    for (Map.Entry<Object, Name> entry : propertyMap.entrySet()) {\n+      Ref aliasRef = (Ref) entry.getKey();\n+      Name aliasName = entry.getValue();\n+      if (aliasRef == ref) {\n+        namespace.removeRef(aliasRef);\n+        newName.addRef(ref);\n+      } else {\n+        aliasName.addRef(aliasRef);\n+        aliasRef.updateName(aliasName);\n+      }\n+    }\n+\n+    namespace.getNameIndex().put(props.get(props.size() - 1), newName);\n+    return newName;\n+  }\n+\n+  private Name inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n+    return inlineAliasIfPossible(ref, namespace, Collections.emptyMap());\n+  }\n \n-      // Check if {@code name} has any aliases left after the\n-      // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n-           name.type == Name.Type.FUNCTION) &&\n-          name.aliasingGets == 0 && name.props != null) {\n-        // All of {@code name}'s children meet condition (a), so they can be\n-        // added to the worklist.\n-        workList.addAll(name.props);\n+  private Set<Ref> getRefsToCheckFor(Scope scope, Ref ref, Set<Ref> seenRefsToCheck) {\n+    Set<Ref> refsToCheck = Sets.newHashSet();\n+    for (Ref reference : ref.getNode().getRefs()) {\n+      if (reference.type == Ref.Type.ALIASING_GET &&\n+          reference.scope == scope &&\n+          !seenRefsToCheck.contains(reference)) {\n+        refsToCheck.add(reference);\n       }\n     }\n+    return refsToCheck;\n   }\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}