{
    "patch": "        switch (value.getType()) {\n            case Token.NEW:\n              // Interpret the value as a local value only if all its children are local.\n              for (Node child : value.children()) {\n                if (!evaluatesToLocalValue(child, locals)) {\n                  return false;\n                }\n              }\n              return true;\n            case Token.FUNCTION:\n            case Token.REGEXP:\n            case Token.ARRAYLIT:\n            case Token.OBJECTLIT:\n            case Token.IN:\n              return true;\n            case Token.ASSIGN:\n              // A result that is aliased by a non-local name, is the effectively the\n              // same as returning a non-local name, but this doesn't matter if the\n              // value is immutable.\n              return NodeUtil.isImmutableValue(value.getLastChild())\n                      || (locals.apply(value)\n                      && evaluatesToLocalValue(value.getLastChild(), locals));\n            case Token.COMMA:\n              return evaluatesToLocalValue(value.getLastChild(), locals);\n            case Token.AND:\n            case Token.OR:\n              return evaluatesToLocalValue(value.getFirstChild(), locals)\n                      && evaluatesToLocalValue(value.getLastChild(), locals);\n            case Token.HOOK:\n              return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n                      && evaluatesToLocalValue(value.getLastChild(), locals);\n            case Token.INC:\n            case Token.DEC:\n              if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n                return evaluatesToLocalValue(value.getFirstChild(), locals);\n              } else {\n                return true;\n              }\n            case Token.THIS:\n              return locals.apply(value);\n            case Token.NAME:\n            case Token.GETELEM:\n            case Token.GETPROP:\n              return isImmutableValue(value) || locals.apply(value);\n            case Token.CALL:\n              return callHasLocalResult(value)\n                      || isToStringMethodCall(value)\n                      || locals.apply(value);\n            default:\n              // Other op force a local value:\n              //  x = '' + g (x is now an local string)\n              //  x -= g (x is now an local number)\n              if (isAssignmentOp(value)\n                      || isSimpleOperator(value)\n                      || isImmutableValue(value)) {\n                  return true;\n              } else if (value.isFunction()) {\n                  // Interpret the value as local only if it returns a local value and has no\n                  // references to unbound identifiers.\n                  Node body = value.getLastChild();\n                  Node returnStmt = lastReturn(body);\n                  if (returnStmt != null && evaluatesToLocalValue(returnStmt.getFirstChild(), locals)) {\n                      for (Node current = value.getFirstChild().getNext(); current != null && NodeUtil.isVar(current); current = current.getNext()) {\n                          String name = current.getString();\n                          if (!locals.apply(NodeUtil.newName(current.getLineno(), name))) {\n                              return false;\n                          }\n                      }\n                      return true;\n                  }\n                  return false;\n              }\n              throw new IllegalStateException(\n                      \"Unexpected expression node\" + value +\n                              \"\\n parent:\" + value.getParent());\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex dd78f900..d761b305 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2462,7 +2462,82 @@ public final class NodeUtil {\n         // TODO(nicksantos): This needs to be changed so that it\n         // returns true iff we're sure the value was never aliased from inside\n         // the constructor (similar to callHasLocalResult)\n-        return true;\n+        switch (value.getType()) {\n+            case Token.NEW:\n+              // Interpret the value as a local value only if all its children are local.\n+              for (Node child : value.children()) {\n+                if (!evaluatesToLocalValue(child, locals)) {\n+                  return false;\n+                }\n+              }\n+              return true;\n+            case Token.FUNCTION:\n+            case Token.REGEXP:\n+            case Token.ARRAYLIT:\n+            case Token.OBJECTLIT:\n+            case Token.IN:\n+              return true;\n+            case Token.ASSIGN:\n+              // A result that is aliased by a non-local name, is the effectively the\n+              // same as returning a non-local name, but this doesn't matter if the\n+              // value is immutable.\n+              return NodeUtil.isImmutableValue(value.getLastChild())\n+                      || (locals.apply(value)\n+                      && evaluatesToLocalValue(value.getLastChild(), locals));\n+            case Token.COMMA:\n+              return evaluatesToLocalValue(value.getLastChild(), locals);\n+            case Token.AND:\n+            case Token.OR:\n+              return evaluatesToLocalValue(value.getFirstChild(), locals)\n+                      && evaluatesToLocalValue(value.getLastChild(), locals);\n+            case Token.HOOK:\n+              return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n+                      && evaluatesToLocalValue(value.getLastChild(), locals);\n+            case Token.INC:\n+            case Token.DEC:\n+              if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+                return evaluatesToLocalValue(value.getFirstChild(), locals);\n+              } else {\n+                return true;\n+              }\n+            case Token.THIS:\n+              return locals.apply(value);\n+            case Token.NAME:\n+            case Token.GETELEM:\n+            case Token.GETPROP:\n+              return isImmutableValue(value) || locals.apply(value);\n+            case Token.CALL:\n+              return callHasLocalResult(value)\n+                      || isToStringMethodCall(value)\n+                      || locals.apply(value);\n+            default:\n+              // Other op force a local value:\n+              //  x = '' + g (x is now an local string)\n+              //  x -= g (x is now an local number)\n+              if (isAssignmentOp(value)\n+                      || isSimpleOperator(value)\n+                      || isImmutableValue(value)) {\n+                  return true;\n+              } else if (value.isFunction()) {\n+                  // Interpret the value as local only if it returns a local value and has no\n+                  // references to unbound identifiers.\n+                  Node body = value.getLastChild();\n+                  Node returnStmt = lastReturn(body);\n+                  if (returnStmt != null && evaluatesToLocalValue(returnStmt.getFirstChild(), locals)) {\n+                      for (Node current = value.getFirstChild().getNext(); current != null && NodeUtil.isVar(current); current = current.getNext()) {\n+                          String name = current.getString();\n+                          if (!locals.apply(NodeUtil.newName(current.getLineno(), name))) {\n+                              return false;\n+                          }\n+                      }\n+                      return true;\n+                  }\n+                  return false;\n+              }\n+              throw new IllegalStateException(\n+                      \"Unexpected expression node\" + value +\n+                              \"\\n parent:\" + value.getParent());\n+        }\n       case Token.FUNCTION:\n       case Token.REGEXP:\n       case Token.ARRAYLIT:",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}