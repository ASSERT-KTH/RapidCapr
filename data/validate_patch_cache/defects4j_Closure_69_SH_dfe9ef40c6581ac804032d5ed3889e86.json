{
    "patch": "  } else {\n    ensureTyped(t, n);\n  }\n\n  // TODO: Add something to check for calls of RegExp objects, which is not\n  // supported by IE.  Either say something about the return type or warn\n  // about the non-portability of the call or both.\n}\n\nprivate void visitParameterList(NodeTraversal t, Node n, FunctionType functionType) {\n  int i = 0;\n  for (Node param : NodeUtil.getFunctionParameters(n)) {\n    String paramName = param.getString();\n    JSType paramType = functionType.getParameterType(i).restrictByNotNullOrUndefined();\n    // isOptional() does not include undefined as an option, so we must check\n    // separately.\n    boolean isUndefined = paramType.equals(getNativeType(VOID_TYPE)) || paramType.isUnknownType();\n    if (param.isDefaultValue() && !isUndefined) {\n      // For default values, the type of the parameter is the type of the default value.\n      visit(t, param.getFirstChild());\n      ensureTyped(t, param, paramType);\n    } else {\n      ensureTyped(t, param, paramType);\n      visit(t, param);\n    }\n    i++;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..358deaaa 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,34 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+  } else {\n+    ensureTyped(t, n);\n+  }\n+\n+  // TODO: Add something to check for calls of RegExp objects, which is not\n+  // supported by IE.  Either say something about the return type or warn\n+  // about the non-portability of the call or both.\n+}\n+\n+private void visitParameterList(NodeTraversal t, Node n, FunctionType functionType) {\n+  int i = 0;\n+  for (Node param : NodeUtil.getFunctionParameters(n)) {\n+    String paramName = param.getString();\n+    JSType paramType = functionType.getParameterType(i).restrictByNotNullOrUndefined();\n+    // isOptional() does not include undefined as an option, so we must check\n+    // separately.\n+    boolean isUndefined = paramType.equals(getNativeType(VOID_TYPE)) || paramType.isUnknownType();\n+    if (param.isDefaultValue() && !isUndefined) {\n+      // For default values, the type of the parameter is the type of the default value.\n+      visit(t, param.getFirstChild());\n+      ensureTyped(t, param, paramType);\n+    } else {\n+      ensureTyped(t, param, paramType);\n+      visit(t, param);\n+    }\n+    i++;\n+  }\n+}\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());",
    "result_reason": "error: invalid method declaration; return type required",
    "test_result": "ERROR"
}