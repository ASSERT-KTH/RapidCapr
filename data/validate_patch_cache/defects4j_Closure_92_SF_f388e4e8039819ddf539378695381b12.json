{
    "patch": "void replace() {\n  if (firstNode == null) {\n    // Don't touch the base case ('goog').\n    replacementNode = candidateDefinition;\n    return;\n  }\n\n  // Handle the case where there is a duplicate definition for an explicitly\n  // provided symbol.\n  if (candidateDefinition != null && explicitNode != null) {\n    explicitNode.detachFromParent();\n    compiler.reportCodeChange();\n\n    // Does this need a VAR keyword?\n    replacementNode = candidateDefinition;\n    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n      Node assignNode = candidateDefinition.getFirstChild();\n      Node nameNode = assignNode.getFirstChild();\n      if (nameNode.getType() == Token.NAME) {\n        // Need to convert this assign to a var declaration.\n        Node valueNode = nameNode.getNext();\n        assignNode.removeChild(nameNode);\n        assignNode.removeChild(valueNode);\n        nameNode.addChildToFront(valueNode);\n        Node varNode = new Node(Token.VAR, nameNode);\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    }\n  } else {\n    // Handle the case where there's not a duplicate definition.\n    replacementNode = createDeclarationNode();\n    boolean nameDefinedInAnotherModule = false;\n    if (firstModule != minimumModule) {\n      int indexOfDot = namespace.indexOf('.');\n      String parentNamespace = namespace;\n      while (indexOfDot != -1) {\n        parentNamespace = namespace.substring(0, indexOfDot);\n        ProvidedName parentName = providedNames.get(parentNamespace);\n        if (parentName != null\n            && parentName.replacementNode != null\n            && parentName.replacementNode.hasChildren()) {\n          nameDefinedInAnotherModule = true;\n          break;\n        }\n        indexOfDot = parentNamespace.indexOf('.');\n      }\n    }\n    if (nameDefinedInAnotherModule) {\n      moveCodeUpToCommonModule(replacementNode);\n    } else {\n      insertDeclarationNode(replacementNode);\n    }\n    if (explicitNode != null) {\n      explicitNode.detachFromParent();\n    }\n    compiler.reportCodeChange();\n  }\n}\n\nprivate void moveCodeUpToCommonModule(Node newDeclarationNode) {\n  int indexOfDot = namespace.indexOf('.');\n  String parentNamespace = namespace.substring(0, indexOfDot);\n  ProvidedName parentName = providedNames.get(parentNamespace);\n  moveCodeUpToCommonModule(newDeclarationNode, parentName.replacementNode);\n}\n\nprivate void moveCodeUpToCommonModule(\n    Node newDeclarationNode, Node referenceNode) {\n  Preconditions.checkNotNull(referenceNode);\n  Node blockNode = referenceNode.getParent();\n  while (blockNode.getParent() != null\n      && NodeUtil.isStatementBlock(blockNode)) {\n    blockNode = blockNode.getParent();\n  }\n  blockNode.getParent().addChildAfter(newDeclarationNode, blockNode);\n}\n\nprivate void insertDeclarationNode(Node newDeclarationNode) {\n  if (firstModule == minimumModule) {\n    firstNode.getParent().addChildBefore(newDeclarationNode, firstNode);\n  } else {\n    // In this case, the name was implicitly provided by two independent\n    // modules. We need to move this code up to a common module.\n    moveCodeUpToCommonModule(newDeclarationNode);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex c929a363..e3407d05 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -744,69 +744,98 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n      * If we're providing a name with a duplicate definition, then make sure\n      * that definition becomes a declaration.\n      */\n-    void replace() {\n-      if (firstNode == null) {\n-        // Don't touch the base case ('goog').\n-        replacementNode = candidateDefinition;\n-        return;\n-      }\n+void replace() {\n+  if (firstNode == null) {\n+    // Don't touch the base case ('goog').\n+    replacementNode = candidateDefinition;\n+    return;\n+  }\n \n-      // Handle the case where there is a duplicate definition for an explicitly\n-      // provided symbol.\n-      if (candidateDefinition != null && explicitNode != null) {\n-        explicitNode.detachFromParent();\n-        compiler.reportCodeChange();\n+  // Handle the case where there is a duplicate definition for an explicitly\n+  // provided symbol.\n+  if (candidateDefinition != null && explicitNode != null) {\n+    explicitNode.detachFromParent();\n+    compiler.reportCodeChange();\n \n-        // Does this need a VAR keyword?\n-        replacementNode = candidateDefinition;\n-        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n-          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n-          Node assignNode = candidateDefinition.getFirstChild();\n-          Node nameNode = assignNode.getFirstChild();\n-          if (nameNode.getType() == Token.NAME) {\n-            // Need to convert this assign to a var declaration.\n-            Node valueNode = nameNode.getNext();\n-            assignNode.removeChild(nameNode);\n-            assignNode.removeChild(valueNode);\n-            nameNode.addChildToFront(valueNode);\n-            Node varNode = new Node(Token.VAR, nameNode);\n-            varNode.copyInformationFrom(candidateDefinition);\n-            candidateDefinition.getParent().replaceChild(\n-                candidateDefinition, varNode);\n-            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n-            compiler.reportCodeChange();\n-            replacementNode = varNode;\n-          }\n-        }\n-      } else {\n-        // Handle the case where there's not a duplicate definition.\n-        replacementNode = createDeclarationNode();\n-        if (firstModule == minimumModule) {\n-          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n-        } else {\n-          // In this case, the name was implicitly provided by two independent\n-          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n-          if (indexOfDot == -1) {\n-            // Any old place is fine.\n-            compiler.getNodeForCodeInsertion(minimumModule)\n-                .addChildToBack(replacementNode);\n-          } else {\n-            // Add it after the parent namespace.\n-            ProvidedName parentName =\n-                providedNames.get(namespace.substring(0, indexOfDot));\n-            Preconditions.checkNotNull(parentName);\n-            Preconditions.checkNotNull(parentName.replacementNode);\n-            parentName.replacementNode.getParent().addChildAfter(\n-                replacementNode, parentName.replacementNode);\n-          }\n-        }\n-        if (explicitNode != null) {\n-          explicitNode.detachFromParent();\n-        }\n+    // Does this need a VAR keyword?\n+    replacementNode = candidateDefinition;\n+    if (NodeUtil.isExpressionNode(candidateDefinition)) {\n+      candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n+      Node assignNode = candidateDefinition.getFirstChild();\n+      Node nameNode = assignNode.getFirstChild();\n+      if (nameNode.getType() == Token.NAME) {\n+        // Need to convert this assign to a var declaration.\n+        Node valueNode = nameNode.getNext();\n+        assignNode.removeChild(nameNode);\n+        assignNode.removeChild(valueNode);\n+        nameNode.addChildToFront(valueNode);\n+        Node varNode = new Node(Token.VAR, nameNode);\n+        varNode.copyInformationFrom(candidateDefinition);\n+        candidateDefinition.getParent().replaceChild(\n+            candidateDefinition, varNode);\n+        nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n         compiler.reportCodeChange();\n+        replacementNode = varNode;\n+      }\n+    }\n+  } else {\n+    // Handle the case where there's not a duplicate definition.\n+    replacementNode = createDeclarationNode();\n+    boolean nameDefinedInAnotherModule = false;\n+    if (firstModule != minimumModule) {\n+      int indexOfDot = namespace.indexOf('.');\n+      String parentNamespace = namespace;\n+      while (indexOfDot != -1) {\n+        parentNamespace = namespace.substring(0, indexOfDot);\n+        ProvidedName parentName = providedNames.get(parentNamespace);\n+        if (parentName != null\n+            && parentName.replacementNode != null\n+            && parentName.replacementNode.hasChildren()) {\n+          nameDefinedInAnotherModule = true;\n+          break;\n+        }\n+        indexOfDot = parentNamespace.indexOf('.');\n       }\n     }\n+    if (nameDefinedInAnotherModule) {\n+      moveCodeUpToCommonModule(replacementNode);\n+    } else {\n+      insertDeclarationNode(replacementNode);\n+    }\n+    if (explicitNode != null) {\n+      explicitNode.detachFromParent();\n+    }\n+    compiler.reportCodeChange();\n+  }\n+}\n+\n+private void moveCodeUpToCommonModule(Node newDeclarationNode) {\n+  int indexOfDot = namespace.indexOf('.');\n+  String parentNamespace = namespace.substring(0, indexOfDot);\n+  ProvidedName parentName = providedNames.get(parentNamespace);\n+  moveCodeUpToCommonModule(newDeclarationNode, parentName.replacementNode);\n+}\n+\n+private void moveCodeUpToCommonModule(\n+    Node newDeclarationNode, Node referenceNode) {\n+  Preconditions.checkNotNull(referenceNode);\n+  Node blockNode = referenceNode.getParent();\n+  while (blockNode.getParent() != null\n+      && NodeUtil.isStatementBlock(blockNode)) {\n+    blockNode = blockNode.getParent();\n+  }\n+  blockNode.getParent().addChildAfter(newDeclarationNode, blockNode);\n+}\n+\n+private void insertDeclarationNode(Node newDeclarationNode) {\n+  if (firstModule == minimumModule) {\n+    firstNode.getParent().addChildBefore(newDeclarationNode, firstNode);\n+  } else {\n+    // In this case, the name was implicitly provided by two independent\n+    // modules. We need to move this code up to a common module.\n+    moveCodeUpToCommonModule(newDeclarationNode);\n+  }\n+}\n \n     /**\n      * Create the declaration node for this name, without inserting it",
    "result_reason": "java.lang.StringIndexOutOfBoundsException: String index out of range: -1",
    "test_result": "FAIL"
}