{
    "patch": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n            throws MaxIterationsExceededException, FunctionEvaluationException {\n        double yInitial;\n        double y0;\n        double y1;\n        double yMin;\n        double yMax;\n\n        if (initial < min || initial > max) {\n            throw new IllegalArgumentException(\n                    \"Initial value not in search interval, min=\" + min + \", max=\" + max + \", initial=\" + initial);\n        }\n\n        // Initialize univariate solver method\n        verifyInterval(min, max);\n        verifySequence(min, initial, max);\n\n        // Get initial approximation x0\n        final double x0;\n        if (initial == min || initial == max) {\n            x0 = initial;\n        } else {\n            x0 = initial;\n        }\n\n        // Initialize solved function\n        yInitial = f.value(x0);\n        y0 = yInitial;\n        yMin = f.value(min);\n        yMax = f.value(max);\n\n        // Initialize univariate solver method\n        verifyBracketing(min, max, f);\n\n        // If one of the bounds is the root, return the bound\n        if (yMin == 0.0) {\n            return min;\n        }\n        if (yMax == 0.0) {\n            return max;\n        }\n\n        // Set default solver absolute accuracy\n        double functionValueAccuracy = getFunctionValueAccuracy();\n\n        // Keep looking while\n        // - the interval is wider than the tolerance,\n        // - and the number of iterations is less than the maximum.\n        int i = 0;\n        double delta = FastMath.max(functionRelativeAccuracy * FastMath.abs(x0), functionAbsoluteAccuracy);\n        while (i < maximalIterationCount && FastMath.abs(delta) > functionAbsoluteAccuracy) {\n            ++i;\n            // Find the two points in the domain with the most opposite function values\n            if (y0 < 0) {\n                // this is y1\n                y1 = yMax;\n                // ensure x1 is initially up the hill from x0\n                // we'll swap them later if that's not the case\n                x1 = max;\n            } else {\n                // this is y1\n                y1 = yMin;\n                // ensure x1 is initially up the hill from x0\n                // we'll swap them later if that's not the case\n                x1 = min;\n            }\n            int sign = FastMath.signum(y1);\n            double oldDelta = delta;\n            double x0Old;\n            double x1Old;\n            int j = 0;\n            double safeMin = min + functionRelativeAccuracy * (max - min);\n            double safeMax = max - functionRelativeAccuracy * (max - min);\n            while (true) {\n                // Calculate the point where the curve crosses the x-axis if it\n                // crosses between x0 and x1.\n                delta = (x1 - x0) / (1d + sign * FastMath.sqrt(y0 / y1));\n                double x = x0 + delta;\n\n                // If the new point is the same as the previous point, exit.\n                if (FastMath.abs(delta) <= functionRelativeAccuracy * FastMath.abs(x)) {\n                    break;\n                }\n\n                // Evaluate the function at the new point\n                double y = f.value(x);\n\n                // If the new point is outside of the search range, clamp to the closest endpoint\n                if (x < safeMin || x > safeMax) {\n                    delta = 0.5 * (x1 - x0);\n                    x = x0 + delta;\n                    y = f.value(x);\n\n                    // if it's still outside\n                    if (x < safeMin || x > safeMax) {\n                        if (y0 < y1) {\n                            x = min;\n                            y = yMin;\n                        } else {\n                            x = max;\n                            y = yMax;\n                        }\n                    }\n                }\n\n                // update bisection information\n                if (FastMath.signum(y) == sign) {\n                    if (FastMath.abs(y) < FastMath.abs(y1)) {\n                        if (y == 0d) {\n                            return x;\n                        }\n                        x0Old = x0;\n                        x1Old = x1;\n                        x0 = x;\n                        y0 = y;\n                        delta = x - x1;\n                        x1 = x;\n                        y1 = y;\n                    } else {\n                        if (y1 == 0d) {\n                            return x1;\n                        }\n                        x0Old = x0;\n                        x1Old = x1;\n                        x1 = x;\n                        y1 = y;\n                        delta = x - x0;\n                        y0 = y;\n                    }\n                } else {\n                    if (FastMath.abs(y) < FastMath.abs(y1)) {\n                        if (y == 0d) {\n                            return x;\n                        }\n                        x0Old = x0;\n                        x1Old = x1;\n                        x1 = x;\n                        y1 = y;\n                        delta = x - x0;\n                        x0 = x;\n                        y0 = y;\n                    } else {\n                        if (y1 == 0d) {\n                            return x1;\n                        }\n                        x0Old = x0;\n                        x1Old = x1;\n                        x0 = x;\n                        y0 = y;\n                        delta = x - x1;\n                        y1 = y;\n                    }\n                }\n\n                // re-check the status of convergence every 50 iterations\n                if ((j++ % evaluateInterval) == 0) {\n                    if (FastMath.abs(delta) <= functionRelativeAccuracy * FastMath.abs(x)) {\n                        break;\n                    }\n                }\n            }\n\n            if (FastMath.abs(delta) <= functionAbsoluteAccuracy) {\n                break;\n            }\n\n            // All endpoints are the same or no better than before\n            if (FastMath.abs(delta) >= oldDelta) {\n                if (y0 < 0) {\n                    x1 = x0;\n                    y1 = y0;\n                } else {\n                    x0 = x1;\n                    y0 = y1;\n                }\n                delta = 0.5 * (x1 - x0);\n            }\n\n            // Evaluate at midpoint\n            double xm = x0 + delta;\n            double ym = f.value(xm);\n\n            if (ym == 0d) {\n                return xm;\n            }\n\n            // Prepare for next iteration\n            if (FastMath.signum(ym) == FastMath.signum(y0)) {\n                yMax = ym;\n                max = xm;\n            } else {\n                yMin = ym;\n                min = xm;\n            }\n\n            // Convergence check: using ym with function value accuracy\n            if (FastMath.abs(ym) <= functionValueAccuracy) {\n                return xm;\n            }\n\n            if ((FastMath.abs(x1 - x0) <= FastMath.max(relativeAccuracy * FastMath.abs(x0), absoluteAccuracy))) {\n                break;\n            }\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount, x0, functionValueAccuracy);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..51dcadbc7 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -67,9 +67,212 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n+            throws MaxIterationsExceededException, FunctionEvaluationException {\n+        double yInitial;\n+        double y0;\n+        double y1;\n+        double yMin;\n+        double yMax;\n+\n+        if (initial < min || initial > max) {\n+            throw new IllegalArgumentException(\n+                    \"Initial value not in search interval, min=\" + min + \", max=\" + max + \", initial=\" + initial);\n+        }\n+\n+        // Initialize univariate solver method\n+        verifyInterval(min, max);\n+        verifySequence(min, initial, max);\n+\n+        // Get initial approximation x0\n+        final double x0;\n+        if (initial == min || initial == max) {\n+            x0 = initial;\n+        } else {\n+            x0 = initial;\n+        }\n+\n+        // Initialize solved function\n+        yInitial = f.value(x0);\n+        y0 = yInitial;\n+        yMin = f.value(min);\n+        yMax = f.value(max);\n+\n+        // Initialize univariate solver method\n+        verifyBracketing(min, max, f);\n+\n+        // If one of the bounds is the root, return the bound\n+        if (yMin == 0.0) {\n+            return min;\n+        }\n+        if (yMax == 0.0) {\n+            return max;\n+        }\n+\n+        // Set default solver absolute accuracy\n+        double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        // Keep looking while\n+        // - the interval is wider than the tolerance,\n+        // - and the number of iterations is less than the maximum.\n+        int i = 0;\n+        double delta = FastMath.max(functionRelativeAccuracy * FastMath.abs(x0), functionAbsoluteAccuracy);\n+        while (i < maximalIterationCount && FastMath.abs(delta) > functionAbsoluteAccuracy) {\n+            ++i;\n+            // Find the two points in the domain with the most opposite function values\n+            if (y0 < 0) {\n+                // this is y1\n+                y1 = yMax;\n+                // ensure x1 is initially up the hill from x0\n+                // we'll swap them later if that's not the case\n+                x1 = max;\n+            } else {\n+                // this is y1\n+                y1 = yMin;\n+                // ensure x1 is initially up the hill from x0\n+                // we'll swap them later if that's not the case\n+                x1 = min;\n+            }\n+            int sign = FastMath.signum(y1);\n+            double oldDelta = delta;\n+            double x0Old;\n+            double x1Old;\n+            int j = 0;\n+            double safeMin = min + functionRelativeAccuracy * (max - min);\n+            double safeMax = max - functionRelativeAccuracy * (max - min);\n+            while (true) {\n+                // Calculate the point where the curve crosses the x-axis if it\n+                // crosses between x0 and x1.\n+                delta = (x1 - x0) / (1d + sign * FastMath.sqrt(y0 / y1));\n+                double x = x0 + delta;\n+\n+                // If the new point is the same as the previous point, exit.\n+                if (FastMath.abs(delta) <= functionRelativeAccuracy * FastMath.abs(x)) {\n+                    break;\n+                }\n+\n+                // Evaluate the function at the new point\n+                double y = f.value(x);\n+\n+                // If the new point is outside of the search range, clamp to the closest endpoint\n+                if (x < safeMin || x > safeMax) {\n+                    delta = 0.5 * (x1 - x0);\n+                    x = x0 + delta;\n+                    y = f.value(x);\n+\n+                    // if it's still outside\n+                    if (x < safeMin || x > safeMax) {\n+                        if (y0 < y1) {\n+                            x = min;\n+                            y = yMin;\n+                        } else {\n+                            x = max;\n+                            y = yMax;\n+                        }\n+                    }\n+                }\n+\n+                // update bisection information\n+                if (FastMath.signum(y) == sign) {\n+                    if (FastMath.abs(y) < FastMath.abs(y1)) {\n+                        if (y == 0d) {\n+                            return x;\n+                        }\n+                        x0Old = x0;\n+                        x1Old = x1;\n+                        x0 = x;\n+                        y0 = y;\n+                        delta = x - x1;\n+                        x1 = x;\n+                        y1 = y;\n+                    } else {\n+                        if (y1 == 0d) {\n+                            return x1;\n+                        }\n+                        x0Old = x0;\n+                        x1Old = x1;\n+                        x1 = x;\n+                        y1 = y;\n+                        delta = x - x0;\n+                        y0 = y;\n+                    }\n+                } else {\n+                    if (FastMath.abs(y) < FastMath.abs(y1)) {\n+                        if (y == 0d) {\n+                            return x;\n+                        }\n+                        x0Old = x0;\n+                        x1Old = x1;\n+                        x1 = x;\n+                        y1 = y;\n+                        delta = x - x0;\n+                        x0 = x;\n+                        y0 = y;\n+                    } else {\n+                        if (y1 == 0d) {\n+                            return x1;\n+                        }\n+                        x0Old = x0;\n+                        x1Old = x1;\n+                        x0 = x;\n+                        y0 = y;\n+                        delta = x - x1;\n+                        y1 = y;\n+                    }\n+                }\n+\n+                // re-check the status of convergence every 50 iterations\n+                if ((j++ % evaluateInterval) == 0) {\n+                    if (FastMath.abs(delta) <= functionRelativeAccuracy * FastMath.abs(x)) {\n+                        break;\n+                    }\n+                }\n+            }\n+\n+            if (FastMath.abs(delta) <= functionAbsoluteAccuracy) {\n+                break;\n+            }\n+\n+            // All endpoints are the same or no better than before\n+            if (FastMath.abs(delta) >= oldDelta) {\n+                if (y0 < 0) {\n+                    x1 = x0;\n+                    y1 = y0;\n+                } else {\n+                    x0 = x1;\n+                    y0 = y1;\n+                }\n+                delta = 0.5 * (x1 - x0);\n+            }\n+\n+            // Evaluate at midpoint\n+            double xm = x0 + delta;\n+            double ym = f.value(xm);\n+\n+            if (ym == 0d) {\n+                return xm;\n+            }\n+\n+            // Prepare for next iteration\n+            if (FastMath.signum(ym) == FastMath.signum(y0)) {\n+                yMax = ym;\n+                max = xm;\n+            } else {\n+                yMin = ym;\n+                min = xm;\n+            }\n+\n+            // Convergence check: using ym with function value accuracy\n+            if (FastMath.abs(ym) <= functionValueAccuracy) {\n+                return xm;\n+            }\n+\n+            if ((FastMath.abs(x1 - x0) <= FastMath.max(relativeAccuracy * FastMath.abs(x0), absoluteAccuracy))) {\n+                break;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount, x0, functionValueAccuracy);\n     }\n \n     /** {@inheritDoc} */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}