{
    "patch": "public long computeMillis(boolean resetFields, String text) {\n        if (iSavedFieldsCount > 0) {\n            SavedField[] savedFields = iSavedFields;\n            int count = iSavedFieldsCount;\n            if (iSavedFieldsShared) {\n                iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n                iSavedFieldsShared = false;\n            }\n            sort(savedFields, count);\n            Chronology chrono = iChrono;\n            int year = Partial.NO_VALUE;\n            int monthOfYear = Partial.NO_VALUE;\n            int dayOfMonth = Partial.NO_VALUE;\n            int weekOfWeekyear = Partial.NO_VALUE;\n            int weekyear = Partial.NO_VALUE;\n            for (int i = 0; i < count; i++) {\n                SavedField save = savedFields[i];\n                DateTimeField field = save.iField;\n                int value = save.iValue;\n                if (field == null || value == Partial.NO_VALUE) {\n                    continue;\n                }\n                switch (field.getType()) {\n                    case DateTimeFieldType.year():\n                        year = value;\n                        break;\n                    case DateTimeFieldType.monthOfYear():\n                        monthOfYear = value;\n                        break;\n                    case DateTimeFieldType.dayOfMonth():\n                        dayOfMonth = value;\n                        break;\n                    case DateTimeFieldType.weekOfWeekyear():\n                        weekOfWeekyear = value;\n                        break;\n                    case DateTimeFieldType.weekyear():\n                        weekyear = value;\n                        break;\n                    default:\n                        break;\n                }\n            }\n            if (weekyear != Partial.NO_VALUE && weekOfWeekyear != Partial.NO_VALUE) {\n                int yearForWeekyear = weekyear;\n                chrono = chrono.withUTC();\n                LocalDate baseDate = new LocalDate(1970, 1, 4, chrono);\n                LocalDate date = baseDate.withWeekyear(yearForWeekyear).withWeekOfWeekyear(weekOfWeekyear);\n                if (year != Partial.NO_VALUE) {\n                    date = date.withYear(year);\n                }\n                else {\n                    // default to current year\n                    date = date.withYear(baseDate.getYear());\n                    if (date.isBefore(baseDate)) {\n                        date = date.withYear(baseDate.getYear() + 1);\n                    }\n                }\n                if (monthOfYear != Partial.NO_VALUE) {\n                    date = date.withMonthOfYear(monthOfYear);\n                }\n                else {\n                    // default to first month of year\n                    date = date.withMonthOfYear(1);\n                }\n                if (dayOfMonth != Partial.NO_VALUE) {\n                    date = date.withDayOfMonth(dayOfMonth);\n                }\n                else {\n                    // default to first day of month\n                    date = date.withDayOfMonth(1);\n                }\n                long result = date.toDateTimeAtMidnight().getMillis();\n                if (text != null) {\n                    long parsedMillis = super.computeMillis(resetFields, text);\n                    if (parsedMillis != result) {\n                        throw new IllegalArgumentException(\"Failed to parse weekyear/week/month fields \" +\n                                text + \", \" + parsedMillis + \"!=\" + result);\n                    }\n                }\n                return result;\n            }\n        }\n\n        return super.computeMillis(resetFields, text);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..f560961b 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -328,53 +328,90 @@ public class DateTimeParserBucket {\n      * @throws IllegalArgumentException if any field is out of range\n      * @since 1.3\n      */\n-    public long computeMillis(boolean resetFields, String text) {\n-        SavedField[] savedFields = iSavedFields;\n-        int count = iSavedFieldsCount;\n-        if (iSavedFieldsShared) {\n-            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n-            iSavedFieldsShared = false;\n-        }\n-        sort(savedFields, count);\n-        if (count > 0) {\n-            // alter base year for parsing if first field is month or day\n-            DurationField months = DurationFieldType.months().getField(iChrono);\n-            DurationField days = DurationFieldType.days().getField(iChrono);\n-            DurationField first = savedFields[0].iField.getDurationField();\n-            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n-                saveField(DateTimeFieldType.year(), iDefaultYear);\n-                return computeMillis(resetFields, text);\n+public long computeMillis(boolean resetFields, String text) {\n+        if (iSavedFieldsCount > 0) {\n+            SavedField[] savedFields = iSavedFields;\n+            int count = iSavedFieldsCount;\n+            if (iSavedFieldsShared) {\n+                iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+                iSavedFieldsShared = false;\n             }\n-        }\n-\n-        long millis = iMillis;\n-        try {\n+            sort(savedFields, count);\n+            Chronology chrono = iChrono;\n+            int year = Partial.NO_VALUE;\n+            int monthOfYear = Partial.NO_VALUE;\n+            int dayOfMonth = Partial.NO_VALUE;\n+            int weekOfWeekyear = Partial.NO_VALUE;\n+            int weekyear = Partial.NO_VALUE;\n             for (int i = 0; i < count; i++) {\n-                millis = savedFields[i].set(millis, resetFields);\n-            }\n-        } catch (IllegalFieldValueException e) {\n-            if (text != null) {\n-                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                SavedField save = savedFields[i];\n+                DateTimeField field = save.iField;\n+                int value = save.iValue;\n+                if (field == null || value == Partial.NO_VALUE) {\n+                    continue;\n+                }\n+                switch (field.getType()) {\n+                    case DateTimeFieldType.year():\n+                        year = value;\n+                        break;\n+                    case DateTimeFieldType.monthOfYear():\n+                        monthOfYear = value;\n+                        break;\n+                    case DateTimeFieldType.dayOfMonth():\n+                        dayOfMonth = value;\n+                        break;\n+                    case DateTimeFieldType.weekOfWeekyear():\n+                        weekOfWeekyear = value;\n+                        break;\n+                    case DateTimeFieldType.weekyear():\n+                        weekyear = value;\n+                        break;\n+                    default:\n+                        break;\n+                }\n             }\n-            throw e;\n-        }\n-        \n-        if (iZone == null) {\n-            millis -= iOffset;\n-        } else {\n-            int offset = iZone.getOffsetFromLocal(millis);\n-            millis -= offset;\n-            if (offset != iZone.getOffset(millis)) {\n-                String message =\n-                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n+            if (weekyear != Partial.NO_VALUE && weekOfWeekyear != Partial.NO_VALUE) {\n+                int yearForWeekyear = weekyear;\n+                chrono = chrono.withUTC();\n+                LocalDate baseDate = new LocalDate(1970, 1, 4, chrono);\n+                LocalDate date = baseDate.withWeekyear(yearForWeekyear).withWeekOfWeekyear(weekOfWeekyear);\n+                if (year != Partial.NO_VALUE) {\n+                    date = date.withYear(year);\n+                }\n+                else {\n+                    // default to current year\n+                    date = date.withYear(baseDate.getYear());\n+                    if (date.isBefore(baseDate)) {\n+                        date = date.withYear(baseDate.getYear() + 1);\n+                    }\n+                }\n+                if (monthOfYear != Partial.NO_VALUE) {\n+                    date = date.withMonthOfYear(monthOfYear);\n+                }\n+                else {\n+                    // default to first month of year\n+                    date = date.withMonthOfYear(1);\n+                }\n+                if (dayOfMonth != Partial.NO_VALUE) {\n+                    date = date.withDayOfMonth(dayOfMonth);\n+                }\n+                else {\n+                    // default to first day of month\n+                    date = date.withDayOfMonth(1);\n+                }\n+                long result = date.toDateTimeAtMidnight().getMillis();\n                 if (text != null) {\n-                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n+                    long parsedMillis = super.computeMillis(resetFields, text);\n+                    if (parsedMillis != result) {\n+                        throw new IllegalArgumentException(\"Failed to parse weekyear/week/month fields \" +\n+                                text + \", \" + parsedMillis + \"!=\" + result);\n+                    }\n                 }\n-                throw new IllegalArgumentException(message);\n+                return result;\n             }\n         }\n-        \n-        return millis;\n+\n+        return super.computeMillis(resetFields, text);\n     }\n     \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}