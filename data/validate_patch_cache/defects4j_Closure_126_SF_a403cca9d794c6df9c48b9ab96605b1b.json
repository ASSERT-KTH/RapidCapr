{
    "patch": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n    NodeUtil.tryCollapseBlock(n);\n\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    if (n.isBlock()) {\n      tryMinimizeBlockExit(n);\n      return;\n    }\n\n    if (n.isIf()) {\n      tryMinimizeIfExit(n, exitType, labelName);\n      return;\n    }\n\n    if (n.isTry()) {\n      tryMinimizeTryExit(n, exitType, labelName);\n      return;\n    }\n\n    if (n.isForIn()) {\n      tryMinimizeForInExit(n, exitType, labelName);\n      return;\n    }\n\n    if (n.isSwitch()) {\n      tryMinimizeSwitchExit(n, exitType, labelName);\n      return;\n    }\n\n    if (n.isFunction()) {\n      tryMinimizeFunctionExit(n, exitType, labelName);\n      return;\n    }\n\n    if (n.isClass()) {\n      tryMinimizeClassExit(n, exitType, labelName);\n      return;\n    }\n\n    if (n.hasChildren()) {\n      for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n        tryMinimizeExits(child, exitType, labelName);\n      }\n    }\n  }\n\n  private void tryMinimizeBlockExit(Node block) {\n    boolean changesMade;\n    do {\n      // Process the first n-1 statements to reduce the final statement exits\n      // See if it can be absorbed into a prior return or labeled break/continue.\n      changesMade = tryMinimizeBlockEnd(block, block.getLastChild().getPrevious());\n    } while (changesMade);\n    // Process the final statement next.\n    if (block.getLastChild() != null) {\n      tryMinimizeExits(block.getLastChild(), BlockTraversal.Order.POST_ORDER, null);\n    }\n  }\n\n  private void tryMinimizeIfExit(Node ifNode, int exitType, String labelName) {\n    tryMinimizeBlockExit(ifNode.getFirstChild().getNext());\n    if (ifNode.getChildCount() == 3) {\n      tryMinimizeBlockExit(ifNode.getLastChild());\n    }\n  }\n\n  private void tryMinimizeTryExit(Node tryNode, int exitType, String labelName) {\n    // We insert a flag to indicate if we are processing the finally block.\n    // If that flag is true, we do allow some extra statements to exit.\n    boolean processFinallyBlock = false;\n\n    for (Node lateExit = getLastExit(tryNode.getFirstChild());\n        lateExit != null;\n        lateExit = getLastExit(tryNode.getFirstChild())) {\n\n      boolean allowNonFinallyExits =\n          earlyExitAllowsFinallyCatchFinally(tryNode, lateExit);\n\n      if (lastExitIsFinallyBlock(tryNode, lateExit)) {\n        // We may allow exits from a finally block here\n        processFinallyBlock = true;\n      }\n\n      if (!processFinallyBlock && !allowNonFinallyExits) {\n        // Heuristic:  only use labeled breaks when there is no other choice.\n        boolean useLabeledBreaks = avoidBreakLabelsForClosures && !tryNode.getParent().isFunction();\n        if (useLabeledBreaks) {\n          tryMergeLabeledBreaks(\n              tryNode, lateExit,\n              getBestLabeledStatementOwner(tryNode, labelName), labelName);\n        } else {\n          NodeUtil.tryMergeBlock(lateExit);\n        }\n        compiler.reportCodeChange();\n        return;\n      }\n\n      tryMinimizeExits(lateExit, BlockTraversal.Order.PRE_ORDER, null);\n    }\n  }\n\n  private void tryMinimizeForInExit(Node forInNode, int exitType, String labelName) {\n    tryMinimizeBlockExit(forInNode.getLastChild());\n  }\n\n  private void tryMinimizeSwitchExit(Node switchNode, int exitType, String labelName) {\n    int caseCount = switchNode.getCaseCount();\n    for (int i = 0; i < caseCount; i++) {\n      Node caseNode = switchNode.getCaseNode(i);\n      // Ignore empty cases that are used as JSX placeholders.\n      if (caseNode.getLastChild() != null) {\n        tryMinimizeBlockExit(caseNode.getLastChild());\n      }\n    }\n  }\n\n  private void tryMinimizeFunctionExit(Node functionNode, int exitType, String labelName) {\n    tryMinimizeBlockExit(functionNode.getLastChild());\n  }\n\n  private void tryMinimizeClassExit(Node classNode, int exitType, String labelName) {\n    tryMinimizeBlockExit(classNode.getLastChild());\n  }\n\n  private boolean tryMinimizeBlockEnd(Node block, Node blockEnd) {\n    if (blockEnd == null) {\n      return false;\n    }\n\n    if (blockEnd.isReturn()) {\n      Node parent = blockEnd.getParent();\n      Node grandparent = parent.getParent();\n      if (grandparent == null) {\n        return false;\n      }\n\n      boolean canMerge = false;\n      if (grandparent.isScript()) {\n        canMerge = true;\n      } else if ((parent == grandparent.getLastChild()) && grandparent.isBlock()) {\n        Node nextSibling = grandparent.getNext();\n        Node lastStatement = parent.getLastChild();\n        if ((nextSibling == null) && NodeUtil.okToMoveClosureInside(lastStatement, grandparent)) {\n          // Don't merge the last return outside the block if there might be a closure there.\n          return false;\n        }\n        canMerge = true;\n      }\n\n      if (canMerge) {\n        NodeUtil.removeChild(parent, blockEnd);\n        NodeUtil.removeChild(block, parent);\n        compiler.reportCodeChange();\n        return true;\n      }\n    }\n\n    if (blockEnd.isBreak() || blockEnd.isContinue()) {\n      String labelName = blockEnd.getFirstChild() != null\n          ? blockEnd.getFirstChild().getString()\n          : null;\n      Node labeledStatementOwner = getBestLabeledStatementOwner(block, labelName);\n      if (labeledStatementOwner != null) {\n        tryMergeLabeledBreaks(block, blockEnd, labeledStatementOwner, labelName);\n        compiler.reportCodeChange();\n        return true;\n      }\n    }\n\n    return false;\n  }\n\n  /**\n   * Given a node in a labeled statement body, determine the best node to which to attach the\n   * label.\n   */\n  private static Node getBestLabeledStatementOwner(Node currentNode, String labelName) {\n    // Walk up the node tree looking for the nearest parent that can be labeled\n    Node parent = currentNode.getParent();\n    while (parent != null) {\n      if (labelable.contains(parent.getToken())) {\n        if (labelName == null || NodeUtil.getLabelName(parent).equals(labelName)) {\n          return parent;\n        }\n      }\n      // Don't bother going into nested functions or declarations.\n      if (parent.isFunction() || NodeUtil.isAnyClass(parent)) {\n        break;\n      }\n      currentNode = parent;\n      parent = currentNode.getParent();\n    }\n    return null;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..cacbb7a2 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -103,101 +103,204 @@ class MinimizeExitPoints\n    *   null otherwise.\n    * @nullable labelName non-null only for breaks within labels.\n    */\n-  void tryMinimizeExits(Node n, int exitType, String labelName) {\n+void tryMinimizeExits(Node n, int exitType, String labelName) {\n+    NodeUtil.tryCollapseBlock(n);\n \n-    // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n       NodeUtil.removeChild(n.getParent(), n);\n       compiler.reportCodeChange();\n       return;\n     }\n \n-    // Just an 'if'.\n+    if (n.isBlock()) {\n+      tryMinimizeBlockExit(n);\n+      return;\n+    }\n+\n     if (n.isIf()) {\n-      Node ifBlock = n.getFirstChild().getNext();\n-      tryMinimizeExits(ifBlock, exitType, labelName);\n-      Node elseBlock = ifBlock.getNext();\n-      if (elseBlock != null) {\n-        tryMinimizeExits(elseBlock, exitType, labelName);\n-      }\n+      tryMinimizeIfExit(n, exitType, labelName);\n       return;\n     }\n \n-    // Just a 'try/catch/finally'.\n     if (n.isTry()) {\n-      Node tryBlock = n.getFirstChild();\n-      tryMinimizeExits(tryBlock, exitType, labelName);\n-      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-        Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n+      tryMinimizeTryExit(n, exitType, labelName);\n+      return;\n+    }\n+\n+    if (n.isForIn()) {\n+      tryMinimizeForInExit(n, exitType, labelName);\n+      return;\n+    }\n+\n+    if (n.isSwitch()) {\n+      tryMinimizeSwitchExit(n, exitType, labelName);\n+      return;\n+    }\n+\n+    if (n.isFunction()) {\n+      tryMinimizeFunctionExit(n, exitType, labelName);\n+      return;\n+    }\n+\n+    if (n.isClass()) {\n+      tryMinimizeClassExit(n, exitType, labelName);\n+      return;\n+    }\n+\n+    if (n.hasChildren()) {\n+      for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+        tryMinimizeExits(child, exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+    }\n+  }\n+\n+  private void tryMinimizeBlockExit(Node block) {\n+    boolean changesMade;\n+    do {\n+      // Process the first n-1 statements to reduce the final statement exits\n+      // See if it can be absorbed into a prior return or labeled break/continue.\n+      changesMade = tryMinimizeBlockEnd(block, block.getLastChild().getPrevious());\n+    } while (changesMade);\n+    // Process the final statement next.\n+    if (block.getLastChild() != null) {\n+      tryMinimizeExits(block.getLastChild(), BlockTraversal.Order.POST_ORDER, null);\n+    }\n+  }\n+\n+  private void tryMinimizeIfExit(Node ifNode, int exitType, String labelName) {\n+    tryMinimizeBlockExit(ifNode.getFirstChild().getNext());\n+    if (ifNode.getChildCount() == 3) {\n+      tryMinimizeBlockExit(ifNode.getLastChild());\n+    }\n+  }\n+\n+  private void tryMinimizeTryExit(Node tryNode, int exitType, String labelName) {\n+    // We insert a flag to indicate if we are processing the finally block.\n+    // If that flag is true, we do allow some extra statements to exit.\n+    boolean processFinallyBlock = false;\n+\n+    for (Node lateExit = getLastExit(tryNode.getFirstChild());\n+        lateExit != null;\n+        lateExit = getLastExit(tryNode.getFirstChild())) {\n+\n+      boolean allowNonFinallyExits =\n+          earlyExitAllowsFinallyCatchFinally(tryNode, lateExit);\n+\n+      if (lastExitIsFinallyBlock(tryNode, lateExit)) {\n+        // We may allow exits from a finally block here\n+        processFinallyBlock = true;\n+      }\n+\n+      if (!processFinallyBlock && !allowNonFinallyExits) {\n+        // Heuristic:  only use labeled breaks when there is no other choice.\n+        boolean useLabeledBreaks = avoidBreakLabelsForClosures && !tryNode.getParent().isFunction();\n+        if (useLabeledBreaks) {\n+          tryMergeLabeledBreaks(\n+              tryNode, lateExit,\n+              getBestLabeledStatementOwner(tryNode, labelName), labelName);\n+        } else {\n+          NodeUtil.tryMergeBlock(lateExit);\n+        }\n+        compiler.reportCodeChange();\n+        return;\n       }\n+\n+      tryMinimizeExits(lateExit, BlockTraversal.Order.PRE_ORDER, null);\n     }\n+  }\n \n-    // Just a 'label'.\n-    if (n.isLabel()) {\n-      Node labelBlock = n.getLastChild();\n-      tryMinimizeExits(labelBlock, exitType, labelName);\n+  private void tryMinimizeForInExit(Node forInNode, int exitType, String labelName) {\n+    tryMinimizeBlockExit(forInNode.getLastChild());\n+  }\n+\n+  private void tryMinimizeSwitchExit(Node switchNode, int exitType, String labelName) {\n+    int caseCount = switchNode.getCaseCount();\n+    for (int i = 0; i < caseCount; i++) {\n+      Node caseNode = switchNode.getCaseNode(i);\n+      // Ignore empty cases that are used as JSX placeholders.\n+      if (caseNode.getLastChild() != null) {\n+        tryMinimizeBlockExit(caseNode.getLastChild());\n+      }\n     }\n+  }\n \n-    // TODO(johnlenz): The last case of SWITCH statement?\n+  private void tryMinimizeFunctionExit(Node functionNode, int exitType, String labelName) {\n+    tryMinimizeBlockExit(functionNode.getLastChild());\n+  }\n \n-    // The rest assumes a block with at least one child, bail on anything else.\n-    if (!n.isBlock() || n.getLastChild() == null) {\n-      return;\n+  private void tryMinimizeClassExit(Node classNode, int exitType, String labelName) {\n+    tryMinimizeBlockExit(classNode.getLastChild());\n+  }\n+\n+  private boolean tryMinimizeBlockEnd(Node block, Node blockEnd) {\n+    if (blockEnd == null) {\n+      return false;\n     }\n \n-    // Multiple if-exits can be converted in a single pass.\n-    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-\n-      // An 'if' block to process below.\n-      if (c.isIf()) {\n-        Node ifTree = c;\n-        Node trueBlock, falseBlock;\n-\n-        // First, the true condition block.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n-\n-        // Now the else block.\n-        // The if blocks may have changed, get them again.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n+    if (blockEnd.isReturn()) {\n+      Node parent = blockEnd.getParent();\n+      Node grandparent = parent.getParent();\n+      if (grandparent == null) {\n+        return false;\n+      }\n+\n+      boolean canMerge = false;\n+      if (grandparent.isScript()) {\n+        canMerge = true;\n+      } else if ((parent == grandparent.getLastChild()) && grandparent.isBlock()) {\n+        Node nextSibling = grandparent.getNext();\n+        Node lastStatement = parent.getLastChild();\n+        if ((nextSibling == null) && NodeUtil.okToMoveClosureInside(lastStatement, grandparent)) {\n+          // Don't merge the last return outside the block if there might be a closure there.\n+          return false;\n         }\n+        canMerge = true;\n       }\n \n-      if (c == n.getLastChild()) {\n-        break;\n+      if (canMerge) {\n+        NodeUtil.removeChild(parent, blockEnd);\n+        NodeUtil.removeChild(block, parent);\n+        compiler.reportCodeChange();\n+        return true;\n+      }\n+    }\n+\n+    if (blockEnd.isBreak() || blockEnd.isContinue()) {\n+      String labelName = blockEnd.getFirstChild() != null\n+          ? blockEnd.getFirstChild().getString()\n+          : null;\n+      Node labeledStatementOwner = getBestLabeledStatementOwner(block, labelName);\n+      if (labeledStatementOwner != null) {\n+        tryMergeLabeledBreaks(block, blockEnd, labeledStatementOwner, labelName);\n+        compiler.reportCodeChange();\n+        return true;\n       }\n     }\n \n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n+    return false;\n+  }\n+\n+  /**\n+   * Given a node in a labeled statement body, determine the best node to which to attach the\n+   * label.\n+   */\n+  private static Node getBestLabeledStatementOwner(Node currentNode, String labelName) {\n+    // Walk up the node tree looking for the nearest parent that can be labeled\n+    Node parent = currentNode.getParent();\n+    while (parent != null) {\n+      if (labelable.contains(parent.getToken())) {\n+        if (labelName == null || NodeUtil.getLabelName(parent).equals(labelName)) {\n+          return parent;\n+        }\n+      }\n+      // Don't bother going into nested functions or declarations.\n+      if (parent.isFunction() || NodeUtil.isAnyClass(parent)) {\n         break;\n       }\n+      currentNode = parent;\n+      parent = currentNode.getParent();\n     }\n+    return null;\n   }\n \n   /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}