{
    "patch": "/**\n * Returns whether a given node evaluates to a boolean result.\n *\n * <p>The method does not check if the expression is pure or if the result is always\n * a boolean. It only checks whether in cases where a boolean is expected, the result\n * will be a boolean.\n *\n * <p>For example, {@code !/a/.test(str)} is considered a boolean result, even though\n * it returns an object.\n *\n * @param node The node to test.\n */\nstatic boolean isBooleanResult(Node node) {\n  if (node == null) {\n    return false;\n  }\n  switch (node.getToken()) {\n    case Token.FALSE:\n    case Token.TRUE:\n      return true;\n    case Token.AND:\n    case Token.OR:\n      return isBooleanResult(node.getFirstChild())\n          && isBooleanResult(node.getLastChild());\n    case Token.NOT:\n      Node child = node.getFirstChild();\n      Node grandchild;\n      return child.isBoolean() ||\n          (child.isTypeOf() &&\n              (grandchild = child.getFirstChild()).isName() &&\n              \"undefined\".equals(grandchild.getString()));\n    case Token.HOOK:\n      return isBooleanResult(node.getFirstChild().getNext())\n          && isBooleanResult(node.getLastChild());\n    case Token.EQ:\n    case Token.NE:\n      Node left = node.getFirstChild();\n      Node right = node.getLastChild();\n      boolean leftIsObjectOrEnumKey = NodeUtil.isObjectType(left) || isEnumKey(left);\n      boolean rightIsObjectOrEnumKey = NodeUtil.isObjectType(right) || isEnumKey(right);\n      if (leftIsObjectOrEnumKey && rightIsObjectOrEnumKey) {\n        // The '==' operator will only return true if both operands\n        // reference the same object.\n        // We can treat this like a call to Object.is. If we're comparing\n        // the same object-reference, return TRUE; otherwise, calculate the\n        // usual object comparison result.\n        return left == right || !isObjectPropertiesOrEnumValuesComparisonHelper(left, right);\n      } else if (leftIsObjectOrEnumKey || rightIsObjectOrEnumKey) {\n        // Comparing an object/enum-key and a non-(object/enum-key)\n        // with '==' can never result in a boolean value.\n        return false;\n      } else if (left.isString() && right.isString()\n          && (node.getToken() == Token.EQ || node.getToken() == Token.NE)) {\n        return true;\n      } else if (left.isNumber() && right.isNumber()\n          && (node.getToken() == Token.EQ || node.getToken() == Token.NE)) {\n        return true;\n      } else {\n        return false;\n      }\n    case Token.LT:\n    case Token.GT:\n    case Token.LE:\n    case Token.GE:\n    case Token.INSTANCEOF:\n      return false;\n    case Token.TYPEOF:\n      // typeof always returns a string.\n      return true;\n    case Token.ZERO:\n      return false;\n    case Token.NAME:\n      // Names can be bools if they were created in a context that requested\n      // a boolean.\n      return node.getBooleanProp(Node.IS_BOOLEAN_FUNCTION);\n    default:\n      // All other operators known to return something truthy, might be booleans if used in boolean contexts.\n      return isAssignmentOp(node) || isSimpleOperator(node) || node.isBoolean() ||\n        node.isString() || node.isNumber();\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 08fb954f..156ee965 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1239,70 +1239,87 @@ public final class NodeUtil {\n     return valueCheck(n, BOOLEAN_RESULT_PREDICATE);\n   }\n \n-  static boolean isBooleanResultHelper(Node n) {\n-    switch (n.getType()) {\n-      // Primitives\n-      case Token.TRUE:\n-      case Token.FALSE:\n-      // Comparisons\n-      case Token.EQ:\n-      case Token.NE:\n-      case Token.SHEQ:\n-      case Token.SHNE:\n-      case Token.LT:\n-      case Token.GT:\n-      case Token.LE:\n-      case Token.GE:\n-      // Queryies\n-      case Token.IN:\n-      case Token.INSTANCEOF:\n-      // Inversion\n-      case Token.NOT:\n-      // delete operator returns a boolean.\n-        return true;\n-      default:\n-        return false;\n-    }\n-  }\n-\n-  static boolean isUndefined(Node n) {\n-    switch (n.getType()) {\n-      case Token.VOID:\n-        return true;\n-      case Token.NAME:\n-        return n.getString().equals(\"undefined\");\n-    }\n+/**\n+ * Returns whether a given node evaluates to a boolean result.\n+ *\n+ * <p>The method does not check if the expression is pure or if the result is always\n+ * a boolean. It only checks whether in cases where a boolean is expected, the result\n+ * will be a boolean.\n+ *\n+ * <p>For example, {@code !/a/.test(str)} is considered a boolean result, even though\n+ * it returns an object.\n+ *\n+ * @param node The node to test.\n+ */\n+static boolean isBooleanResult(Node node) {\n+  if (node == null) {\n     return false;\n   }\n-\n-  static boolean isNull(Node n) {\n-    return n.getType() == Token.NULL;\n-  }\n-\n-  static boolean isNullOrUndefined(Node n) {\n-    return isNull(n) || isUndefined(n);\n-  }\n-\n-  static class MayBeStringResultPredicate implements Predicate<Node> {\n-    public boolean apply(Node n) {\n-      return mayBeStringHelper(n);\n-    }\n-  }\n-\n-  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n-      new MayBeStringResultPredicate();\n-\n-  /**\n-   * @returns Whether the results is possibly a string.\n-   */\n-  static boolean mayBeString(Node n) {\n-    return mayBeString(n, true);\n+  switch (node.getToken()) {\n+    case Token.FALSE:\n+    case Token.TRUE:\n+      return true;\n+    case Token.AND:\n+    case Token.OR:\n+      return isBooleanResult(node.getFirstChild())\n+          && isBooleanResult(node.getLastChild());\n+    case Token.NOT:\n+      Node child = node.getFirstChild();\n+      Node grandchild;\n+      return child.isBoolean() ||\n+          (child.isTypeOf() &&\n+              (grandchild = child.getFirstChild()).isName() &&\n+              \"undefined\".equals(grandchild.getString()));\n+    case Token.HOOK:\n+      return isBooleanResult(node.getFirstChild().getNext())\n+          && isBooleanResult(node.getLastChild());\n+    case Token.EQ:\n+    case Token.NE:\n+      Node left = node.getFirstChild();\n+      Node right = node.getLastChild();\n+      boolean leftIsObjectOrEnumKey = NodeUtil.isObjectType(left) || isEnumKey(left);\n+      boolean rightIsObjectOrEnumKey = NodeUtil.isObjectType(right) || isEnumKey(right);\n+      if (leftIsObjectOrEnumKey && rightIsObjectOrEnumKey) {\n+        // The '==' operator will only return true if both operands\n+        // reference the same object.\n+        // We can treat this like a call to Object.is. If we're comparing\n+        // the same object-reference, return TRUE; otherwise, calculate the\n+        // usual object comparison result.\n+        return left == right || !isObjectPropertiesOrEnumValuesComparisonHelper(left, right);\n+      } else if (leftIsObjectOrEnumKey || rightIsObjectOrEnumKey) {\n+        // Comparing an object/enum-key and a non-(object/enum-key)\n+        // with '==' can never result in a boolean value.\n+        return false;\n+      } else if (left.isString() && right.isString()\n+          && (node.getToken() == Token.EQ || node.getToken() == Token.NE)) {\n+        return true;\n+      } else if (left.isNumber() && right.isNumber()\n+          && (node.getToken() == Token.EQ || node.getToken() == Token.NE)) {\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    case Token.LT:\n+    case Token.GT:\n+    case Token.LE:\n+    case Token.GE:\n+    case Token.INSTANCEOF:\n+      return false;\n+    case Token.TYPEOF:\n+      // typeof always returns a string.\n+      return true;\n+    case Token.ZERO:\n+      return false;\n+    case Token.NAME:\n+      // Names can be bools if they were created in a context that requested\n+      // a boolean.\n+      return node.getBooleanProp(Node.IS_BOOLEAN_FUNCTION);\n+    default:\n+      // All other operators known to return something truthy, might be booleans if used in boolean contexts.\n+      return isAssignmentOp(node) || isSimpleOperator(node) || node.isBoolean() ||\n+        node.isString() || node.isNumber();\n   }\n-\n-  static boolean mayBeString(Node n, boolean recurse) {\n-    if (recurse) {\n-      return valueCheck(n, MAY_BE_STRING_PREDICATE);\n-    } else {\n+}\n       return mayBeStringHelper(n);\n     }\n   }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}