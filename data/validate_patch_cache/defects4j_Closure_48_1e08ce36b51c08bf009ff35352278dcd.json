{
    "patch": "void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n    String ownerName = null, qName = null, propName = null;\n\n    if (n.isGetProp()) {\n        Node ownerNode = n.getFirstChild();\n\n        ownerName = ownerNode.getQualifiedName();\n        qName = n.getQualifiedName();\n        propName = n.getLastChild().getString();\n        Preconditions.checkArgument(qName != null && ownerName != null);\n    } else if (n.isName()) {\n        qName = n.getQualifiedName();\n        Preconditions.checkArgument(qName != null);\n        if (rhsValue != null && rhsValue.isFunction()) {\n            defineFunctionLiteral(qName, rhsValue, info);\n        } else if (rhsValue == null || !rhsValue.isFunction()) {\n            JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n            defineSlot(n, parent, valueType, true);\n        }\n        return;\n    }\n\n    JSType valueType = null;\n    boolean inferred = true;\n    ObjectType ownerType = null;\n\n    if (rhsValue == null || !rhsValue.isFunction()) {\n        valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n    } else {\n        FunctionTypeBuilder builder = new FunctionTypeBuilder(\n                typeRegistry, ownerName, n, scope, compiler.getCodingConvention());\n        builder.addSource(n);\n        builder.inferFrom(rhsValue);\n        valueType = builder.buildAndRegister();\n    }\n\n    if (valueType == null && rhsValue != null) {\n        valueType = rhsValue.getJSType();\n    }\n\n    if (info != null && (info.hasType() || info.hasEnumParameterType() ||\n            (info.isConstant() && valueType != null && !valueType.isUnknownType()) ||\n            FunctionTypeBuilder.isFunctionTypeDeclaration(info)) ||\n            (!qName.contains(\".\") && !\"exports\".equals(qName))\n            ) {\n        inferred = false;\n    }\n\n    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n        boolean isDeclared = (info != null || !scope.isDeclared(qName, false));\n        if (isDeclared) {\n            valueType = getFunctionType(n, ownerType, rhsValue, qName);\n            inferred = false;\n        } else {\n            // We'll add functions to their full owner name\n            defineFunctionLiteral(qName, rhsValue, info);\n            return;\n        }\n    }\n\n    if (ownerName != null) {\n        ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n            boolean isExtern = (t.getInput() != null && t.getInput().isExtern());\n            if ((!ownerType.hasOwnProperty(propName) ||\n                    ownerType.isPropertyTypeInferred(propName)) &&\n                    ((isExtern && !ownerType.isNativeObjectType()) ||\n                            !ownerType.isInstanceType())) {\n                // If the property is undeclared or inferred, declare it now.\n                ownerType.defineDeclaredProperty(propName, valueType, n);\n            }\n        }\n    }\n\n    if (!inferred) {\n        defineSlot(n, parent, valueType, inferred);\n    } else if (rhsValue != null && rhsValue.isTrue()) {\n        // We declare these for delegate proxy method properties.\n        FunctionType ownerTypeFunc = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerTypeFunc != null) {\n            JSType ownerTypeOfThis = ownerTypeFunc.getTypeOfThis();\n            String delegateName = compiler.getCodingConvention().getDelegateSuperclassName();\n            JSType delegateType = delegateName == null ?\n                    null : typeRegistry.getType(delegateName);\n\n            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n            }\n        }\n    }\n}\n\nprivate ObjectType getObjectSlot(String name) {\n    Var var = scope.getVar(name);\n    if (var == null) {\n        return null;\n    }\n    JSType varType = var.getType();\n    if (varType == null) {\n        return null;\n    }\n    if (varType.isNoType() || varType.isUnknownType()) {\n        ObjectType objType = var.getNameNode().isObjectLit() ?\n                createAnonymousObjectType(var.getNameNode()) :\n                null;\n        if (objType != null) {\n            var.setType(objType);\n        }\n    }\n    objType = ObjectType.cast(var.getType());\n    return objType;\n}\n\nprivate void defineFunctionLiteral(String qName, Node value, JSDocInfo info) {\n    checkArgument(value.isFunction());\n\n    FunctionTypeBuilder builder = new FunctionTypeBuilder(\n            typeRegistry, qName, value, scope, compiler.getCodingConvention());\n    builder.inferFrom(value);\n    builder.setDeclaredTypeExpression(info ? info.getType() : null);\n    FunctionType funType = builder.buildAndRegister();\n    funType.getReference().setSourceFile(value.getSourceFile());\n    defineSlot(value.getFirstChild(), value, funType, false);\n}\n\nprivate FunctionType getFunctionType(\n        Node n, ObjectType ownerType, Node value, String qName) {\n    FunctionType funcType = JSType.toMaybeFunctionType(getObjectSlot(qName));\n    if (funcType == null) {\n        FunctionTypeBuilder builder = new FunctionTypeBuilder(\n                typeRegistry, qName, value, scope, compiler.getCodingConvention());\n        builder.addSource(n);\n        builder.inferFrom(value);\n        boolean isConstructor = codingConvention.isConstructor(value);\n        if (isConstructor || codingConvention.isTypedefDecl(value)) {\n            constructorTypes.put(qName, builder.buildAndRegister());\n        }\n        funcType = builder.buildAndRegister();\n    }\n    if (ownerType != null) {\n        funcType = JSType.createFunctionTypeWithReceiver(ownerType, funcType);\n    }\n    return funcType;\n}\n\nprivate static ObjectType createAnonymousObjectType(Node ownerNode) {\n    checkArgument(ownerNode.isObjectLit());\n    ObjectType objType = ObjectType.create(typeRegistry);\n    for (Node key = ownerNode.getFirstChild(); key != null; key = key.getNext()) {\n        String keyName = key.getString();\n        Preconditions.checkState(key.isStringKey() || key.isGetterDef() || key.isSetterDef());\n        JSType keyType = null;\n        if (key.isGetterDef() || key.isSetterDef()) {\n            keyType = getGetterOrSetterType(key, objType, keyName);\n        }\n        if (keyType == null) {\n            keyType = inference.getBestJSType(key.getFirstChild());\n        }\n        if (key.isQuotedString()) {\n            keyName = keyName.substring(1, keyName.length() - 1);\n        }\n        objType.defineDeclaredProperty(keyName, keyType, key);\n    }\n    return objType;\n}\n\nprivate static JSType getGetterOrSetterType(\n        Node prop, ObjectType ownerType, String propName) {\n    String name = null;\n    Node value = null;\n    if (prop.isGetterDef()) {\n        name = AccessorSummary.getterProp(propName);\n        value = prop.getFirstChild();\n    } else if (prop.isSetterDef()) {\n        name = AccessorSummary.setterProp(propName);\n        value = prop.getFirstChild().getNext();\n    } else {\n        return null;\n    }\n    FunctionTypeBuilder builder = new FunctionTypeBuilder(\n            ownerType.getSource(), name, value, ownerType.getScope(), ownerType.getCodingConvention());\n    builder.addSource(prop);\n    builder.inferFrom(value);\n    ObjectType fType = builder.buildAndRegister();\n    return FunctionType.getDeclaredReturnTypeOf(fType);\n}\n\nprivate static void checkArgument(boolean condition) {\n    if (!condition) {\n        throw new IllegalArgumentException();\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 3fb48137..ba3d99d2 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1413,152 +1413,199 @@ final class TypedScopeCreator implements ScopeCreator {\n      * @param rhsValue The node that {@code n} is being initialized to,\n      *     or {@code null} if this is a stub declaration.\n      */\n-    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n+void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n         Node n, Node parent, Node rhsValue) {\n-      Node ownerNode = n.getFirstChild();\n-      String ownerName = ownerNode.getQualifiedName();\n-      String qName = n.getQualifiedName();\n-      String propName = n.getLastChild().getString();\n-      Preconditions.checkArgument(qName != null && ownerName != null);\n-\n-      // Precedence of type information on GETPROPs:\n-      // 1) @type annnotation / @enum annotation\n-      // 2) ASSIGN to FUNCTION literal\n-      // 3) @param/@return annotation (with no function literal)\n-      // 4) ASSIGN to something marked @const\n-      // 5) ASSIGN to anything else\n-      //\n-      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-      // the function has jsdoc or has not been declared before.\n-      //\n-      // FUNCTION literals are special because TypedScopeCreator is very smart\n-      // about getting as much type information as possible for them.\n-\n-      // Determining type for #1 + #2 + #3 + #4\n-      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-      if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n-      }\n-      // Function prototypes are special.\n-      // It's a common JS idiom to do:\n-      // F.prototype = { ... };\n-      // So if F does not have an explicitly declared super type,\n-      // allow F.prototype to be redefined arbitrarily.\n-      if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-          // If the programmer has declared that F inherits from Super,\n-          // and they assign F.prototype to an object literal,\n-          // then they are responsible for making sure that the object literal's\n-          // implicit prototype is set up appropriately. We just obey\n-          // the @extends tag.\n-          ObjectType qVarType = ObjectType.cast(qVar.getType());\n-          if (qVarType != null &&\n-              rhsValue != null &&\n-              rhsValue.isObjectLit()) {\n-            typeRegistry.resetImplicitPrototype(\n-                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n-          } else if (!qVar.isTypeInferred()) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to some arbitrary expression,\n-            // there's not much we can do. We just ignore the expression,\n-            // and hope they've annotated their code in a way to tell us\n-            // what props are going to be on that prototype.\n-            return;\n-          }\n-          if (qVar.getScope() == scope) {\n-            scope.undeclare(qVar);\n-          }\n+    String ownerName = null, qName = null, propName = null;\n+\n+    if (n.isGetProp()) {\n+        Node ownerNode = n.getFirstChild();\n+\n+        ownerName = ownerNode.getQualifiedName();\n+        qName = n.getQualifiedName();\n+        propName = n.getLastChild().getString();\n+        Preconditions.checkArgument(qName != null && ownerName != null);\n+    } else if (n.isName()) {\n+        qName = n.getQualifiedName();\n+        Preconditions.checkArgument(qName != null);\n+        if (rhsValue != null && rhsValue.isFunction()) {\n+            defineFunctionLiteral(qName, rhsValue, info);\n+        } else if (rhsValue == null || !rhsValue.isFunction()) {\n+            JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n+            defineSlot(n, parent, valueType, true);\n         }\n-      }\n+        return;\n+    }\n \n-      if (valueType == null) {\n-        if (parent.isExprResult()) {\n-          stubDeclarations.add(new StubDeclaration(\n-              n,\n-              t.getInput() != null && t.getInput().isExtern(),\n-              ownerName));\n-        }\n+    JSType valueType = null;\n+    boolean inferred = true;\n+    ObjectType ownerType = null;\n \n-        return;\n-      }\n+    if (rhsValue == null || !rhsValue.isFunction()) {\n+        valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n+    } else {\n+        FunctionTypeBuilder builder = new FunctionTypeBuilder(\n+                typeRegistry, ownerName, n, scope, compiler.getCodingConvention());\n+        builder.addSource(n);\n+        builder.inferFrom(rhsValue);\n+        valueType = builder.buildAndRegister();\n+    }\n \n-      // NOTE(nicksantos): Determining whether a property is declared or not\n-      // is really really obnoxious.\n-      //\n-      // The problem is that there are two (equally valid) coding styles:\n-      //\n-      // (function() {\n-      //   /* The authoritative definition of goog.bar. */\n-      //   goog.bar = function() {};\n-      // })();\n-      //\n-      // function f() {\n-      //   goog.bar();\n-      //   /* Reset goog.bar to a no-op. */\n-      //   goog.bar = function() {};\n-      // }\n-      //\n-      // In a dynamic language with first-class functions, it's very difficult\n-      // to know which one the user intended without looking at lots of\n-      // contextual information (the second example demonstrates a small case\n-      // of this, but there are some really pathological cases as well).\n-      //\n-      // The current algorithm checks if either the declaration has\n-      // jsdoc type information, or @const with a known type,\n-      // or a function literal with a name we haven't seen before.\n-      boolean inferred = true;\n-      if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType()\n-            || info.hasEnumParameterType()\n-            || (info.isConstant() && valueType != null\n-                && !valueType.isUnknownType())\n-            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-      }\n+    if (valueType == null && rhsValue != null) {\n+        valueType = rhsValue.getJSType();\n+    }\n \n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n-      }\n+    if (info != null && (info.hasType() || info.hasEnumParameterType() ||\n+            (info.isConstant() && valueType != null && !valueType.isUnknownType()) ||\n+            FunctionTypeBuilder.isFunctionTypeDeclaration(info)) ||\n+            (!qName.contains(\".\") && !\"exports\".equals(qName))\n+            ) {\n+        inferred = false;\n+    }\n \n-      if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n+    if (inferred && rhsValue != null && rhsValue.isFunction()) {\n+        boolean isDeclared = (info != null || !scope.isDeclared(qName, false));\n+        if (isDeclared) {\n+            valueType = getFunctionType(n, ownerType, rhsValue, qName);\n+            inferred = false;\n+        } else {\n+            // We'll add functions to their full owner name\n+            defineFunctionLiteral(qName, rhsValue, info);\n+            return;\n+        }\n+    }\n+\n+    if (ownerName != null) {\n+        ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n-          // Only declare this as an official property if it has not been\n-          // declared yet.\n-          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-          if ((!ownerType.hasOwnProperty(propName) ||\n-               ownerType.isPropertyTypeInferred(propName)) &&\n-              ((isExtern && !ownerType.isNativeObjectType()) ||\n-               !ownerType.isInstanceType())) {\n-            // If the property is undeclared or inferred, declare it now.\n-            ownerType.defineDeclaredProperty(propName, valueType, n);\n-          }\n+            boolean isExtern = (t.getInput() != null && t.getInput().isExtern());\n+            if ((!ownerType.hasOwnProperty(propName) ||\n+                    ownerType.isPropertyTypeInferred(propName)) &&\n+                    ((isExtern && !ownerType.isNativeObjectType()) ||\n+                            !ownerType.isInstanceType())) {\n+                // If the property is undeclared or inferred, declare it now.\n+                ownerType.defineDeclaredProperty(propName, valueType, n);\n+            }\n         }\n+    }\n \n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n+    if (!inferred) {\n         defineSlot(n, parent, valueType, inferred);\n-      } else if (rhsValue != null && rhsValue.isTrue()) {\n+    } else if (rhsValue != null && rhsValue.isTrue()) {\n         // We declare these for delegate proxy method properties.\n-        FunctionType ownerType =\n-            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-          String delegateName = codingConvention.getDelegateSuperclassName();\n-          JSType delegateType = delegateName == null ?\n-              null : typeRegistry.getType(delegateName);\n-          if (delegateType != null &&\n-              ownerTypeOfThis.isSubtype(delegateType)) {\n-            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n-          }\n+        FunctionType ownerTypeFunc = JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n+        if (ownerTypeFunc != null) {\n+            JSType ownerTypeOfThis = ownerTypeFunc.getTypeOfThis();\n+            String delegateName = compiler.getCodingConvention().getDelegateSuperclassName();\n+            JSType delegateType = delegateName == null ?\n+                    null : typeRegistry.getType(delegateName);\n+\n+            if (delegateType != null && ownerTypeOfThis.isSubtype(delegateType)) {\n+                defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+            }\n         }\n-      }\n     }\n+}\n+\n+private ObjectType getObjectSlot(String name) {\n+    Var var = scope.getVar(name);\n+    if (var == null) {\n+        return null;\n+    }\n+    JSType varType = var.getType();\n+    if (varType == null) {\n+        return null;\n+    }\n+    if (varType.isNoType() || varType.isUnknownType()) {\n+        ObjectType objType = var.getNameNode().isObjectLit() ?\n+                createAnonymousObjectType(var.getNameNode()) :\n+                null;\n+        if (objType != null) {\n+            var.setType(objType);\n+        }\n+    }\n+    objType = ObjectType.cast(var.getType());\n+    return objType;\n+}\n+\n+private void defineFunctionLiteral(String qName, Node value, JSDocInfo info) {\n+    checkArgument(value.isFunction());\n+\n+    FunctionTypeBuilder builder = new FunctionTypeBuilder(\n+            typeRegistry, qName, value, scope, compiler.getCodingConvention());\n+    builder.inferFrom(value);\n+    builder.setDeclaredTypeExpression(info ? info.getType() : null);\n+    FunctionType funType = builder.buildAndRegister();\n+    funType.getReference().setSourceFile(value.getSourceFile());\n+    defineSlot(value.getFirstChild(), value, funType, false);\n+}\n+\n+private FunctionType getFunctionType(\n+        Node n, ObjectType ownerType, Node value, String qName) {\n+    FunctionType funcType = JSType.toMaybeFunctionType(getObjectSlot(qName));\n+    if (funcType == null) {\n+        FunctionTypeBuilder builder = new FunctionTypeBuilder(\n+                typeRegistry, qName, value, scope, compiler.getCodingConvention());\n+        builder.addSource(n);\n+        builder.inferFrom(value);\n+        boolean isConstructor = codingConvention.isConstructor(value);\n+        if (isConstructor || codingConvention.isTypedefDecl(value)) {\n+            constructorTypes.put(qName, builder.buildAndRegister());\n+        }\n+        funcType = builder.buildAndRegister();\n+    }\n+    if (ownerType != null) {\n+        funcType = JSType.createFunctionTypeWithReceiver(ownerType, funcType);\n+    }\n+    return funcType;\n+}\n+\n+private static ObjectType createAnonymousObjectType(Node ownerNode) {\n+    checkArgument(ownerNode.isObjectLit());\n+    ObjectType objType = ObjectType.create(typeRegistry);\n+    for (Node key = ownerNode.getFirstChild(); key != null; key = key.getNext()) {\n+        String keyName = key.getString();\n+        Preconditions.checkState(key.isStringKey() || key.isGetterDef() || key.isSetterDef());\n+        JSType keyType = null;\n+        if (key.isGetterDef() || key.isSetterDef()) {\n+            keyType = getGetterOrSetterType(key, objType, keyName);\n+        }\n+        if (keyType == null) {\n+            keyType = inference.getBestJSType(key.getFirstChild());\n+        }\n+        if (key.isQuotedString()) {\n+            keyName = keyName.substring(1, keyName.length() - 1);\n+        }\n+        objType.defineDeclaredProperty(keyName, keyType, key);\n+    }\n+    return objType;\n+}\n+\n+private static JSType getGetterOrSetterType(\n+        Node prop, ObjectType ownerType, String propName) {\n+    String name = null;\n+    Node value = null;\n+    if (prop.isGetterDef()) {\n+        name = AccessorSummary.getterProp(propName);\n+        value = prop.getFirstChild();\n+    } else if (prop.isSetterDef()) {\n+        name = AccessorSummary.setterProp(propName);\n+        value = prop.getFirstChild().getNext();\n+    } else {\n+        return null;\n+    }\n+    FunctionTypeBuilder builder = new FunctionTypeBuilder(\n+            ownerType.getSource(), name, value, ownerType.getScope(), ownerType.getCodingConvention());\n+    builder.addSource(prop);\n+    builder.inferFrom(value);\n+    ObjectType fType = builder.buildAndRegister();\n+    return FunctionType.getDeclaredReturnTypeOf(fType);\n+}\n+\n+private static void checkArgument(boolean condition) {\n+    if (!condition) {\n+        throw new IllegalArgumentException();\n+    }\n+}\n \n     /**\n      * Find the ObjectType associated with the given slot.",
    "result_reason": "error: method getObjectSlot(String) is already defined in class TypedScopeCreator.AbstractScopeBuilder",
    "test_result": "ERROR"
}