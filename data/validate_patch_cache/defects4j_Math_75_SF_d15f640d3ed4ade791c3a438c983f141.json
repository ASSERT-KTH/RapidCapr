{
    "patch": "    private Dfp multiplyFast(final int y) {\n\n        Dfp result = new Dfp(this);\n        Dfp t1 = new Dfp(this);\n\n        boolean special = false;\n\n        result.exp += y;\n\n        if (result.exp < -150000) {\n\n            result = result.roundingError();\n            t1 = t1.roundingError();\n            special = true;\n\n        }\n\n        if (y == 0 || isNaN()) { // Handle NaN values\n            return newInstance(Double.NaN);\n        }\n\n        if (result.mant[0] == 0 && result.exp != 0) {\n            t1.exp = result.exp;\n            return t1;\n        }\n\n        if (mant[mant.length - 1] == 0 && exp != 0) {\n            t1.mant[t1.mant.length - 1] = Dfp.INTEGER_MASK;\n            t1.exp = exp;\n            t1.sign = sign;\n            return t1;\n        }\n\n        long rh;\n        long k = 0;\n\n        for (int i = 0; i < result.mant.length; i++) {\n            rh = ((long) mant[i] * (long) y) + k;\n            t1.mant[i] = (int) (rh & Dfp.INTEGER_MASK);\n            k = rh >>> 32;\n        }\n\n        if (special) {\n            t1 = t1.roundingError();\n        } else if (k != 0) {\n            result = result.extend();\n            result.mant[0] = (int) k;\n            t1 = result;\n        } else {\n            t1 = result;\n        }\n\n        t1.sign = sign == ((Dfp) one()).sign ? 1 : -1;\n\n        return t1;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/stat/Frequency.java b/src/main/java/org/apache/commons/math/stat/Frequency.java\nindex c45d72883..9f5c9ce57 100644\n--- a/src/main/java/org/apache/commons/math/stat/Frequency.java\n+++ b/src/main/java/org/apache/commons/math/stat/Frequency.java\n@@ -299,8 +299,61 @@ public class Frequency implements Serializable {\n      * @deprecated replaced by {@link #getPct(Comparable)} as of 2.0\n      */\n     @Deprecated\n-    public double getPct(Object v) {\n-        return getCumPct((Comparable<?>) v);\n+    private Dfp multiplyFast(final int y) {\n+\n+        Dfp result = new Dfp(this);\n+        Dfp t1 = new Dfp(this);\n+\n+        boolean special = false;\n+\n+        result.exp += y;\n+\n+        if (result.exp < -150000) {\n+\n+            result = result.roundingError();\n+            t1 = t1.roundingError();\n+            special = true;\n+\n+        }\n+\n+        if (y == 0 || isNaN()) { // Handle NaN values\n+            return newInstance(Double.NaN);\n+        }\n+\n+        if (result.mant[0] == 0 && result.exp != 0) {\n+            t1.exp = result.exp;\n+            return t1;\n+        }\n+\n+        if (mant[mant.length - 1] == 0 && exp != 0) {\n+            t1.mant[t1.mant.length - 1] = Dfp.INTEGER_MASK;\n+            t1.exp = exp;\n+            t1.sign = sign;\n+            return t1;\n+        }\n+\n+        long rh;\n+        long k = 0;\n+\n+        for (int i = 0; i < result.mant.length; i++) {\n+            rh = ((long) mant[i] * (long) y) + k;\n+            t1.mant[i] = (int) (rh & Dfp.INTEGER_MASK);\n+            k = rh >>> 32;\n+        }\n+\n+        if (special) {\n+            t1 = t1.roundingError();\n+        } else if (k != 0) {\n+            result = result.extend();\n+            result.mant[0] = (int) k;\n+            t1 = result;\n+        } else {\n+            t1 = result;\n+        }\n+\n+        t1.sign = sign == ((Dfp) one()).sign ? 1 : -1;\n+\n+        return t1;\n     }\n \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}