{
    "patch": "private boolean isInlinableObject(List<Reference> refs) {\n    boolean hasNonObjectAssign = false;\n    boolean hasSelfRef = false;\n    boolean hasES5GetterSetter = false;\n    boolean hasOrdinaryPropRef = false;\n  \n    for (Reference ref : refs) {\n        Node name = ref.getNode();\n        Node parent = ref.getParent();\n        Node gramps = ref.getGrandparent();\n\n        if (parent.isGetProp()) {\n            Preconditions.checkState(parent.getFirstChild() == name);\n            if (gramps.isCall()\n                    && gramps.getFirstChild() == parent) {\n                // disallow self-referential calls.\n                return false;\n            }\n            if (!isOrdinaryPropertyAccess(parent)) {\n                // We don't know how to handle non-ordinary properties\n                // in this context, so we can't inline.\n                return false;\n            }\n            hasOrdinaryPropRef = true;\n        } else if (!isVarOrAssignExprLhs(name)) {\n            // The node 'name' is not a var/assign and cannot hold an\n            // object literal. So skip to the next reference.\n            hasNonObjectAssign = true;\n            continue;\n        } else {\n            Preconditions.checkState(ref.isLvalue());\n        }\n        \n        Node val = ref.getAssignedValue();\n        if (val == null) {\n            // A var with no assignment.\n            hasNonObjectAssign = true;\n            continue;\n        }\n\n        if (!val.isObjectLit()) {\n            // We're looking for object literal assignments only.\n            hasNonObjectAssign = true;\n            continue;\n        }\n\n        // Check for ES5 getters/setters first, since they can be\n        // either self-referential or not, and the self-referential\n        // check wouldn't catch them as it is written.\n        NodeTraversal.traverse(val, new NodeVisitor() {\n            @Override\n            public void visit(Node node) {\n                if (node.isGetterDef() || node.isSetterDef()) {\n                    hasES5GetterSetter = true;\n                }\n            }\n        });\n\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n                // ES5 get/set not supported.\n                return false;\n            }\n\n            Node childVal = child.getFirstChild();\n            // Check if childVal is the parent of any of the passed in\n            // references, as that is how self-referential assignments\n            // will happen.\n            for (Reference t : refs) {\n                Node refNode = t.getNode();\n                while (!NodeUtil.isStatementBlock(refNode)) {\n                    if (childVal.isEquivalentTo(refNode)) {\n                        // There's a self-referential assignment\n                        hasSelfRef = true;\n                        break;\n                    }\n                    refNode = refNode.getParent();\n                }\n            }\n        }\n    }\n\n    // We have multiple cases for bailing in the loop above (return false),\n    // but only one case for continuing to the next reference (continue).\n    // Here, we check all those multiple cases and return false if any\n    // of them occurred.\n    if (hasNonObjectAssign || hasES5GetterSetter || hasSelfRef || !hasOrdinaryPropRef) {\n        return false;\n    }\n\n    // If we reached here, then all the references were \"ordinary\" property\n    // accesses to object literals that did not have self-referential assignments\n    // or ES5 getters/setters.\n    return true;\n}\n\nprivate static boolean isOrdinaryPropertyAccess(Node parent) {\n    Node child1 = parent.getFirstChild();\n    Node child2 = child1.getNext();\n    if (child2 == null) {\n        return false;\n    }\n    Node child3 = child2.getNext();\n    if (child3 != null) {\n        return false;\n    }\n    if (!child1.isName() || !isStringLiteral(child2)) {\n        return false;\n    }\n\n    // An access of a property that starts with an upper case letter is assumed to\n    // be a constructor call.\n    if (NodeUtil.isValidPropertyName(\".\".concat(child2.getString()))) {\n        return true;\n    }\n    return isPropertiesAccess(parent.getParent());\n}\n\nprivate static boolean isPropertiesAccess(Node ancestor) {\n    // Check whether this is a \"regular\" property access, or a property\n    // access with explicit receiver. In other words, check whether\n    // the access is of the form 'o.p' or 'a[3]'.\n    Node gramps = ancestor.getParent();\n    return gramps.isGetProp() || gramps.isGetElem();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 9f5c6072..a6bec85e 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -152,92 +152,132 @@ class InlineObjectLiterals implements CompilerPass {\n      *   x.fn();\n      * </pre>\n      */\n-    private boolean isInlinableObject(List<Reference> refs) {\n-      boolean ret = false;\n-      for (Reference ref : refs) {\n+private boolean isInlinableObject(List<Reference> refs) {\n+    boolean hasNonObjectAssign = false;\n+    boolean hasSelfRef = false;\n+    boolean hasES5GetterSetter = false;\n+    boolean hasOrdinaryPropRef = false;\n+  \n+    for (Reference ref : refs) {\n         Node name = ref.getNode();\n         Node parent = ref.getParent();\n         Node gramps = ref.getGrandparent();\n \n-        // Ignore indirect references, like x.y (except x.y(), since\n-        // the function referenced by y might reference 'this').\n-        //\n         if (parent.isGetProp()) {\n-          Preconditions.checkState(parent.getFirstChild() == name);\n-          // A call target maybe using the object as a 'this' value.\n-          if (gramps.isCall()\n-              && gramps.getFirstChild() == parent) {\n-            return false;\n-          }\n-\n-          // NOTE(nicksantos): This pass's object-splitting algorithm has\n-          // a blind spot. It assumes that if a property isn't defined on an\n-          // object, then the value is undefined. This is not true, because\n-          // Object.prototype can have arbitrary properties on it.\n-          //\n-          // We short-circuit this problem by bailing out if we see a reference\n-          // to a property that isn't defined on the object literal. This\n-          // isn't a perfect algorithm, but it should catch most cases.\n-          continue;\n-        }\n-\n-        // Only rewrite VAR declarations or simple assignment statements\n-        if (!isVarOrAssignExprLhs(name)) {\n-           return false;\n+            Preconditions.checkState(parent.getFirstChild() == name);\n+            if (gramps.isCall()\n+                    && gramps.getFirstChild() == parent) {\n+                // disallow self-referential calls.\n+                return false;\n+            }\n+            if (!isOrdinaryPropertyAccess(parent)) {\n+                // We don't know how to handle non-ordinary properties\n+                // in this context, so we can't inline.\n+                return false;\n+            }\n+            hasOrdinaryPropRef = true;\n+        } else if (!isVarOrAssignExprLhs(name)) {\n+            // The node 'name' is not a var/assign and cannot hold an\n+            // object literal. So skip to the next reference.\n+            hasNonObjectAssign = true;\n+            continue;\n+        } else {\n+            Preconditions.checkState(ref.isLvalue());\n         }\n-\n+        \n         Node val = ref.getAssignedValue();\n         if (val == null) {\n-          // A var with no assignment.\n-          continue;\n+            // A var with no assignment.\n+            hasNonObjectAssign = true;\n+            continue;\n         }\n \n-        // We're looking for object literal assignments only.\n         if (!val.isObjectLit()) {\n-          return false;\n+            // We're looking for object literal assignments only.\n+            hasNonObjectAssign = true;\n+            continue;\n         }\n \n-        // Make sure that the value is not self-refential. IOW,\n-        // disallow things like x = {b: x.a}.\n-        //\n-        // TODO: Only exclude unorderable self-referential\n-        // assignments. i.e. x = {a: x.b, b: x.a} is not orderable,\n-        // but x = {a: 1, b: x.a} is.\n-        //\n-        // Also, ES5 getters/setters aren't handled by this pass.\n+        // Check for ES5 getters/setters first, since they can be\n+        // either self-referential or not, and the self-referential\n+        // check wouldn't catch them as it is written.\n+        NodeTraversal.traverse(val, new NodeVisitor() {\n+            @Override\n+            public void visit(Node node) {\n+                if (node.isGetterDef() || node.isSetterDef()) {\n+                    hasES5GetterSetter = true;\n+                }\n+            }\n+        });\n+\n         for (Node child = val.getFirstChild(); child != null;\n              child = child.getNext()) {\n-          if (child.isGetterDef() ||\n-              child.isSetterDef()) {\n-            // ES5 get/set not supported.\n-            return false;\n-          }\n-\n-\n-          Node childVal = child.getFirstChild();\n-          // Check if childVal is the parent of any of the passed in\n-          // references, as that is how self-referential assignments\n-          // will happen.\n-          for (Reference t : refs) {\n-            Node refNode = t.getParent();\n-            while (!NodeUtil.isStatementBlock(refNode)) {\n-              if (refNode == childVal) {\n-                // There's a self-referential assignment\n+            if (child.isGetterDef() || child.isSetterDef()) {\n+                // ES5 get/set not supported.\n                 return false;\n-              }\n-              refNode = refNode.getParent();\n             }\n-          }\n+\n+            Node childVal = child.getFirstChild();\n+            // Check if childVal is the parent of any of the passed in\n+            // references, as that is how self-referential assignments\n+            // will happen.\n+            for (Reference t : refs) {\n+                Node refNode = t.getNode();\n+                while (!NodeUtil.isStatementBlock(refNode)) {\n+                    if (childVal.isEquivalentTo(refNode)) {\n+                        // There's a self-referential assignment\n+                        hasSelfRef = true;\n+                        break;\n+                    }\n+                    refNode = refNode.getParent();\n+                }\n+            }\n         }\n+    }\n \n+    // We have multiple cases for bailing in the loop above (return false),\n+    // but only one case for continuing to the next reference (continue).\n+    // Here, we check all those multiple cases and return false if any\n+    // of them occurred.\n+    if (hasNonObjectAssign || hasES5GetterSetter || hasSelfRef || !hasOrdinaryPropRef) {\n+        return false;\n+    }\n \n-        // We have found an acceptable object literal assignment. As\n-        // long as there are no other assignments that mess things up,\n-        // we can inline.\n-        ret = true;\n-      }\n-      return ret;\n+    // If we reached here, then all the references were \"ordinary\" property\n+    // accesses to object literals that did not have self-referential assignments\n+    // or ES5 getters/setters.\n+    return true;\n+}\n+\n+private static boolean isOrdinaryPropertyAccess(Node parent) {\n+    Node child1 = parent.getFirstChild();\n+    Node child2 = child1.getNext();\n+    if (child2 == null) {\n+        return false;\n+    }\n+    Node child3 = child2.getNext();\n+    if (child3 != null) {\n+        return false;\n     }\n+    if (!child1.isName() || !isStringLiteral(child2)) {\n+        return false;\n+    }\n+\n+    // An access of a property that starts with an upper case letter is assumed to\n+    // be a constructor call.\n+    if (NodeUtil.isValidPropertyName(\".\".concat(child2.getString()))) {\n+        return true;\n+    }\n+    return isPropertiesAccess(parent.getParent());\n+}\n+\n+private static boolean isPropertiesAccess(Node ancestor) {\n+    // Check whether this is a \"regular\" property access, or a property\n+    // access with explicit receiver. In other words, check whether\n+    // the access is of the form 'o.p' or 'a[3]'.\n+    Node gramps = ancestor.getParent();\n+    return gramps.isGetProp() || gramps.isGetElem();\n+}\n \n     private boolean isVarOrAssignExprLhs(Node n) {\n       Node parent = n.getParent();",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}