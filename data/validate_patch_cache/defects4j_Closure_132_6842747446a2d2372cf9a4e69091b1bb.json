{
    "patch": "                      // firstChild() calls getLhs() via checkNotNull.\n                      // Delaying isSideEffectFree prevents egregious performance regression.\n                      // Note that isSideEffectFree is not a guarantee of having no side\n                      // effects, but rather a conservative estimate needed because we're not\n                      // conducting the analysis over the entire AST.\n                      // \n                      // Example:\n                      //   var x;\n                      //   if (a_b()) {\n                      //     x = c();\n                      //   } else {\n                      //     x = d();\n                      //   }\n                      //   f(x);\n                      // is safe (even though x may receive a value with side effects) when\n                      // a_b, c, and d are known to be side-cffect-free, because the value of\n                      // x is not observed before escaped from the if statement; but it's not\n                      // safe in general.\n                      if (NodeUtil.isExpressionResult(lhsParent) || lhsParent.isForIn() ||\n                          lhsParent.isForOf() || lhsParent.isVanillaFor() ||\n                          NodeUtil.isNonArrowFunction(lhsParent) ||\n                          !lhs.isSideEffectFree() ||\n                          !mayEffectMutableState(lhs)) {",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..33708994 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,29 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+                      // firstChild() calls getLhs() via checkNotNull.\n+                      // Delaying isSideEffectFree prevents egregious performance regression.\n+                      // Note that isSideEffectFree is not a guarantee of having no side\n+                      // effects, but rather a conservative estimate needed because we're not\n+                      // conducting the analysis over the entire AST.\n+                      // \n+                      // Example:\n+                      //   var x;\n+                      //   if (a_b()) {\n+                      //     x = c();\n+                      //   } else {\n+                      //     x = d();\n+                      //   }\n+                      //   f(x);\n+                      // is safe (even though x may receive a value with side effects) when\n+                      // a_b, c, and d are known to be side-cffect-free, because the value of\n+                      // x is not observed before escaped from the if statement; but it's not\n+                      // safe in general.\n+                      if (NodeUtil.isExpressionResult(lhsParent) || lhsParent.isForIn() ||\n+                          lhsParent.isForOf() || lhsParent.isVanillaFor() ||\n+                          NodeUtil.isNonArrowFunction(lhsParent) ||\n+                          !lhs.isSideEffectFree() ||\n+                          !mayEffectMutableState(lhs)) {\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}