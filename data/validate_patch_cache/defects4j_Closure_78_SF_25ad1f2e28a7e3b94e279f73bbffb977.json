{
    "patch": "  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Check if we need to perform a string concatenation instead of an arithmetic operation.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    // Get the operand values as doubles.\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n    double lval = lValObj;\n    double rval = rValObj;\n\n    // Perform the arithmetic operation.\n    double result;\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        // Check if we are adding two strings.\n        if (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false)) {\n          String lstr = NodeUtil.getStringValue(left);\n          String rstr = NodeUtil.getStringValue(right);\n          if (lstr != null && rstr != null) {\n            return Node.newString(lstr + rstr);\n          }\n        }\n        // Otherwise, perform the arithmetic addition normally.\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return Node.newString(Token.NAME, \"NaN\");\n        } else {\n          result = lval % rval;\n        }\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return Node.newString(Token.NAME, \"NaN\");\n        } else {\n          result = lval / rval;\n        }\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // Check if the result can be represented as a Javascript number.\n    if (String.valueOf(result).length() <=\n            String.valueOf(lval).length() + String.valueOf(rval).length() + 1\n            && Math.abs(result) <= MAX_FOLD_NUMBER) {\n      // Create a new number node with the result.\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    // If we couldn't create a Javascript number with the result, just return null.\n    return null;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex c5ef4b0f..11bda941 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -662,19 +662,12 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n    * Try to fold arithmetic binary operators\n    */\n   private Node performArithmeticOp(int opType, Node left, Node right) {\n-    // Unlike other operations, ADD operands are not always converted\n-    // to Number.\n-    if (opType == Token.ADD\n-        && (NodeUtil.mayBeString(left, false)\n-            || NodeUtil.mayBeString(right, false))) {\n+    // Check if we need to perform a string concatenation instead of an arithmetic operation.\n+    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n       return null;\n     }\n \n-    double result;\n-\n-    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n-    // to zero so this is a little akward here.\n-\n+    // Get the operand values as doubles.\n     Double lValObj = NodeUtil.getNumberValue(left);\n     if (lValObj == null) {\n       return null;\n@@ -683,10 +676,11 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     if (rValObj == null) {\n       return null;\n     }\n-\n     double lval = lValObj;\n     double rval = rValObj;\n \n+    // Perform the arithmetic operation.\n+    double result;\n     switch (opType) {\n       case Token.BITAND:\n         result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n@@ -698,6 +692,15 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n         result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n         break;\n       case Token.ADD:\n+        // Check if we are adding two strings.\n+        if (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false)) {\n+          String lstr = NodeUtil.getStringValue(left);\n+          String rstr = NodeUtil.getStringValue(right);\n+          if (lstr != null && rstr != null) {\n+            return Node.newString(lstr + rstr);\n+          }\n+        }\n+        // Otherwise, perform the arithmetic addition normally.\n         result = lval + rval;\n         break;\n       case Token.SUB:\n@@ -709,29 +712,28 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n       case Token.MOD:\n         if (rval == 0) {\n           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n+          return Node.newString(Token.NAME, \"NaN\");\n+        } else {\n+          result = lval % rval;\n         }\n-        result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n+          return Node.newString(Token.NAME, \"NaN\");\n+        } else {\n+          result = lval / rval;\n         }\n-        result = lval / rval;\n         break;\n       default:\n         throw new Error(\"Unexpected arithmetic operator\");\n     }\n \n-    // TODO(johnlenz): consider removing the result length check.\n-    // length of the left and right value plus 1 byte for the operator.\n+    // Check if the result can be represented as a Javascript number.\n     if (String.valueOf(result).length() <=\n-        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n-\n-        // Do not try to fold arithmetic for numbers > 2^53. After that\n-        // point, fixed-point math starts to break down and become inaccurate.\n-        Math.abs(result) <= MAX_FOLD_NUMBER) {\n+            String.valueOf(lval).length() + String.valueOf(rval).length() + 1\n+            && Math.abs(result) <= MAX_FOLD_NUMBER) {\n+      // Create a new number node with the result.\n       Node newNumber = Node.newNumber(result);\n       return newNumber;\n     } else if (Double.isNaN(result)) {\n@@ -742,6 +744,7 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n       return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n \n+    // If we couldn't create a Javascript number with the result, just return null.\n     return null;\n   }\n ",
    "result_reason": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_DIVIDE_BY_0_ERROR. Divide by 0 at testcode line 1 : 8 expected:<0> but was:<1>",
    "test_result": "FAIL"
}