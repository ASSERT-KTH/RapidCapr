{
    "patch": "@Override\npublic void visit(NodeTraversal t, Node n, Node parent) {\n    if (t.inGlobalScope()) {\n        return;\n    }\n\n    if (n.isReturn() && n.getFirstChild() != null) {\n        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n    }\n\n    if (NodeUtil.isNameDeclaration(n)) {\n        if (n.hasChildren()) {\n            Node value = n.getFirstChild();\n            if (value != null && value.isFunction()) {\n                // This is a top-level function expression.\n                String name = n.getFirstChild().getSecondChild().getString();\n                Scope scope = t.getScope();\n                Var var = scope.getVar(name);\n                if (var != null) {\n                    Scope ownerScope = var.getScope();\n                    if (ownerScope.isLocal()) {\n                        data.get(ownerScope.getRootNode())\n                                .recordDeclaredFunctionName(name);\n                    }\n                }\n            }\n        }\n    } else if (n.isName() && NodeUtil.isLValue(n) &&\n            // Be careful of bleeding functions, which create variables\n            // in the inner scope, not the scope where the name appears.\n            !NodeUtil.isBleedingFunctionName(n)) {\n        String name = n.getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n            Scope ownerScope = var.getScope();\n            if (ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordAssignedName(name);\n            }\n\n            if (!isParentClassDefinition(n) &&\n                    scope != ownerScope && ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n            }\n        }\n    } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n            NodeUtil.isLValue(n)) {\n        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n        Scope scope = t.getScope();\n        Var var = scope.getVar(name);\n        if (var != null) {\n            Scope ownerScope = var.getScope();\n            if (scope != ownerScope && ownerScope.isLocal()) {\n                data.get(ownerScope.getRootNode())\n                        .recordEscapedQualifiedName(n.getQualifiedName());\n            }\n        }\n    }\n}\n\n// Add this helper method at the end of the class.\nprivate static boolean isParentClassDefinition(Node n) {\n    Node parent = n.getParent();\n    // Check the surrounding code.\n    while (parent != null && !parent.isScript()) {\n\n        // Check if the parent of the node is defining a class.\n        if (parent.isClass() || parent.isClassMembers() ||\n                (parent.isStringKey() && parent.getParent().isClassMembers())) {\n            return true;\n        }\n\n        // Check if the parent of the node is defining a TypeScript interface.\n        if (NodeUtil.isNameDeclaration(parent) &&\n                parent.getGrandparent() != null &&\n                parent.getGrandparent().isExport() &&\n                (parent.getJSDocInfo() == null || !parent.getJSDocInfo().hasType())) {\n            return true;\n        }\n\n        parent = parent.getParent();\n    }\n    return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..a9a96625 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1983,59 +1983,90 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.put(n, new AstFunctionContents(n));\n       }\n     }\n-\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (t.inGlobalScope()) {\n+@Override\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (t.inGlobalScope()) {\n         return;\n-      }\n+    }\n \n-      if (n.isReturn() && n.getFirstChild() != null) {\n+    if (n.isReturn() && n.getFirstChild() != null) {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n-      }\n-\n-      if (t.getScopeDepth() <= 2) {\n-        // The first-order function analyzer looks at two types of variables:\n-        //\n-        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n-        //\n-        // 2) Local variables that are assigned more than once.\n-        //\n-        // We treat all global variables as escaped by default, so there's\n-        // no reason to do this extra computation for them.\n-        return;\n-      }\n+    }\n \n-      if (n.isName() && NodeUtil.isLValue(n) &&\n-          // Be careful of bleeding functions, which create variables\n-          // in the inner scope, not the scope where the name appears.\n-          !NodeUtil.isBleedingFunctionName(n)) {\n+    if (NodeUtil.isNameDeclaration(n)) {\n+        if (n.hasChildren()) {\n+            Node value = n.getFirstChild();\n+            if (value != null && value.isFunction()) {\n+                // This is a top-level function expression.\n+                String name = n.getFirstChild().getSecondChild().getString();\n+                Scope scope = t.getScope();\n+                Var var = scope.getVar(name);\n+                if (var != null) {\n+                    Scope ownerScope = var.getScope();\n+                    if (ownerScope.isLocal()) {\n+                        data.get(ownerScope.getRootNode())\n+                                .recordDeclaredFunctionName(name);\n+                    }\n+                }\n+            }\n+        }\n+    } else if (n.isName() && NodeUtil.isLValue(n) &&\n+            // Be careful of bleeding functions, which create variables\n+            // in the inner scope, not the scope where the name appears.\n+            !NodeUtil.isBleedingFunctionName(n)) {\n         String name = n.getString();\n         Scope scope = t.getScope();\n         Var var = scope.getVar(name);\n         if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n-          }\n+            Scope ownerScope = var.getScope();\n+            if (ownerScope.isLocal()) {\n+                data.get(ownerScope.getRootNode()).recordAssignedName(name);\n+            }\n \n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n-          }\n+            if (!isParentClassDefinition(n) &&\n+                    scope != ownerScope && ownerScope.isLocal()) {\n+                data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n+            }\n         }\n-      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n-          NodeUtil.isLValue(n)) {\n+    } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n+            NodeUtil.isLValue(n)) {\n         String name = NodeUtil.getRootOfQualifiedName(n).getString();\n         Scope scope = t.getScope();\n         Var var = scope.getVar(name);\n         if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode())\n-                .recordEscapedQualifiedName(n.getQualifiedName());\n-          }\n+            Scope ownerScope = var.getScope();\n+            if (scope != ownerScope && ownerScope.isLocal()) {\n+                data.get(ownerScope.getRootNode())\n+                        .recordEscapedQualifiedName(n.getQualifiedName());\n+            }\n         }\n-      }\n     }\n+}\n+\n+// Add this helper method at the end of the class.\n+private static boolean isParentClassDefinition(Node n) {\n+    Node parent = n.getParent();\n+    // Check the surrounding code.\n+    while (parent != null && !parent.isScript()) {\n+\n+        // Check if the parent of the node is defining a class.\n+        if (parent.isClass() || parent.isClassMembers() ||\n+                (parent.isStringKey() && parent.getParent().isClassMembers())) {\n+            return true;\n+        }\n+\n+        // Check if the parent of the node is defining a TypeScript interface.\n+        if (NodeUtil.isNameDeclaration(parent) &&\n+                parent.getGrandparent() != null &&\n+                parent.getGrandparent().isExport() &&\n+                (parent.getJSDocInfo() == null || !parent.getJSDocInfo().hasType())) {\n+            return true;\n+        }\n+\n+        parent = parent.getParent();\n+    }\n+    return false;\n+}\n   }\n \n   private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}