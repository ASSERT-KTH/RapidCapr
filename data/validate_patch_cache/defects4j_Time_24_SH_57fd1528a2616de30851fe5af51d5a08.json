{
    "patch": "for (int i = 0; i < count; i++) {\n    SavedField savedField = savedFields[i];\n    DateTimeField field = savedField.iField;\n    long oldMillis = millis;\n    int wrapField = -1;\n    try {\n        millis = savedField.set(millis, resetFields);\n        if (i == count - 1 && savedField.iField.getType() == DateTimeFieldType.weekyear()) {\n            // compute year and remainder\n            int year = ISOChronology.getInstanceUTC().weekyear().get(millis);\n            long instant = ISOChronology.getInstanceUTC().year().set(0, year);\n            millis = ISOChronology.getInstanceUTC().weekyear().set(instant, year);\n        }\n    } catch (IllegalFieldValueException ex) {\n        if (ex.getIllegalFieldValue() != DateTimeConstants.ROUND_CEILING && ex.getIllegalFieldValue() != DateTimeConstants.ROUND_FLOOR &&\n                !(savedField.iField.getType() == DateTimeFieldType.monthOfYear() && ex.getIllegalFieldValue() == 2 && monthsInYear() == 13)) {\n            if (text != null) {\n                ex.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw ex;\n        }\n        // remember the field that caused the problem\n        wrapField = i;\n    }\n    if (i == 0 && wrapField >= 0) {\n        // if first field fails, then cannot resolve into another year\n        if (text != null) {\n            throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Year must be specified\");\n        }\n        throw new IllegalFieldValueException(DateTimeFieldType.year(), null, null, null);\n    }\n    for (int j = i + 1; j < count; j++) {\n        DateTimeField compareField = savedFields[j].iField;\n        if (wrapField >= 0 && compareField.getType() == DateTimeFieldType.year()) {\n            // trying to resolve into another year, but failed on wrap field\n            if (text != null) {\n                throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Year must be specified\");\n            }\n            throw new IllegalFieldValueException(DateTimeFieldType.year(), null, null, null);\n        }\n    }\n    if (wrapField >= 0) {\n        // need to wrap\n        // take the current value of the wrap field and add the difference\n        int min = savedField.iField.getMinimumValue();\n        int max = savedField.iField.getMaximumValue();\n        int currentValue = savedField.iField.get(oldMillis);\n        long instant = -1;  // initialize to something in case of an exception\n        for (int v = currentValue + (currentValue < ((max + min) / 2) ? 1 : -1);\n             v >= min && v <= max;\n             v += (currentValue < ((max + min) / 2) ? 1 : -1)) {\n            savedField.iField.set(oldMillis, v);\n            for (int j = i + 1; j < count; j++) {\n                SavedField test = savedFields[j];\n                if (wrapField < test.iField.getType() && test.set(savedField.get(), false) != savedField.get()) {\n                    if (text != null) {\n                        throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"');\n                    }\n                    throw new IllegalFieldValueException(test.iField.getType(), null, null, null);\n                }\n            }\n            instant = computeMillis(resetFields, text);\n            if ((currentValue < ((max + min) / 2) && instant >= oldMillis)\n                    || (currentValue >= ((max + min) / 2) && instant <= oldMillis)) {\n                break;  // found correct value, so drop out of loop\n            }\n        }\n        millis = instant;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..49520402 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,76 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+for (int i = 0; i < count; i++) {\n+    SavedField savedField = savedFields[i];\n+    DateTimeField field = savedField.iField;\n+    long oldMillis = millis;\n+    int wrapField = -1;\n+    try {\n+        millis = savedField.set(millis, resetFields);\n+        if (i == count - 1 && savedField.iField.getType() == DateTimeFieldType.weekyear()) {\n+            // compute year and remainder\n+            int year = ISOChronology.getInstanceUTC().weekyear().get(millis);\n+            long instant = ISOChronology.getInstanceUTC().year().set(0, year);\n+            millis = ISOChronology.getInstanceUTC().weekyear().set(instant, year);\n+        }\n+    } catch (IllegalFieldValueException ex) {\n+        if (ex.getIllegalFieldValue() != DateTimeConstants.ROUND_CEILING && ex.getIllegalFieldValue() != DateTimeConstants.ROUND_FLOOR &&\n+                !(savedField.iField.getType() == DateTimeFieldType.monthOfYear() && ex.getIllegalFieldValue() == 2 && monthsInYear() == 13)) {\n+            if (text != null) {\n+                ex.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+            }\n+            throw ex;\n+        }\n+        // remember the field that caused the problem\n+        wrapField = i;\n+    }\n+    if (i == 0 && wrapField >= 0) {\n+        // if first field fails, then cannot resolve into another year\n+        if (text != null) {\n+            throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Year must be specified\");\n+        }\n+        throw new IllegalFieldValueException(DateTimeFieldType.year(), null, null, null);\n+    }\n+    for (int j = i + 1; j < count; j++) {\n+        DateTimeField compareField = savedFields[j].iField;\n+        if (wrapField >= 0 && compareField.getType() == DateTimeFieldType.year()) {\n+            // trying to resolve into another year, but failed on wrap field\n+            if (text != null) {\n+                throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Year must be specified\");\n+            }\n+            throw new IllegalFieldValueException(DateTimeFieldType.year(), null, null, null);\n+        }\n+    }\n+    if (wrapField >= 0) {\n+        // need to wrap\n+        // take the current value of the wrap field and add the difference\n+        int min = savedField.iField.getMinimumValue();\n+        int max = savedField.iField.getMaximumValue();\n+        int currentValue = savedField.iField.get(oldMillis);\n+        long instant = -1;  // initialize to something in case of an exception\n+        for (int v = currentValue + (currentValue < ((max + min) / 2) ? 1 : -1);\n+             v >= min && v <= max;\n+             v += (currentValue < ((max + min) / 2) ? 1 : -1)) {\n+            savedField.iField.set(oldMillis, v);\n+            for (int j = i + 1; j < count; j++) {\n+                SavedField test = savedFields[j];\n+                if (wrapField < test.iField.getType() && test.set(savedField.get(), false) != savedField.get()) {\n+                    if (text != null) {\n+                        throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + '\"');\n+                    }\n+                    throw new IllegalFieldValueException(test.iField.getType(), null, null, null);\n+                }\n+            }\n+            instant = computeMillis(resetFields, text);\n+            if ((currentValue < ((max + min) / 2) && instant >= oldMillis)\n+                    || (currentValue >= ((max + min) / 2) && instant <= oldMillis)) {\n+                break;  // found correct value, so drop out of loop\n+            }\n+        }\n+        millis = instant;\n+    }\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}