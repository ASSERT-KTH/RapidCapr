{
    "patch": "    public double solve(final UnivariateRealFunction f, double min, double max, int maxIterations, double initial)\n            throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (f == null) {\n            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n        }\n        if (maximumIterations < 1) {\n            throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maxIterations);\n        }\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if ((yMin * yMax) > 0.0) {\n            throw new NoBracketingException(min, max, yMin, yMax);\n        }\n        if (yMin == 0.0) {\n            return min;\n        }\n        if (yMax == 0.0) {\n            return max;\n        }\n        // verify bracketing\n        if (yMin > yMax) {\n            double tmp = min;\n            min = max;\n            max = tmp;\n            tmp = yMin;\n            yMin = yMax;\n            yMax = tmp;\n        }\n        final double ftol = getFunctionValueAccuracy();\n        double x0 = initial;\n        double x1 = max;\n        double y0 = f.value(x0);\n        double y1 = f.value(x1);\n        int signChange = 0;\n        double oldDelta = max - min;\n        double delta = oldDelta;\n        final boolean inverted = y0 > y1;\n        if (inverted) {\n            double tmp = x0;\n            x0 = x1;\n            x1 = tmp;\n            tmp = y0;\n            y0 = y1;\n            y1 = tmp;\n        }\n        while (true) {\n            delta = 0.5 * delta;\n            final double x2 = x1 - delta;\n            final double y2 = f.value(x2);\n            if (Double.isNaN(y2)) {\n                return Double.NaN;\n            }\n            double h1 = x1 - x0;\n            double h2 = x2 - x1;\n            if (!(Math.abs(h1) > Math.abs(h2))) {\n                final double temp = h1;\n                h1 = h2;\n                h2 = temp;\n                final double temp2 = y0;\n                y0 = y2;\n                y2 = temp2;\n                final double temp3 = y1;\n                y1 = y2;\n                y2 = temp3;\n                final double temp4 = x0;\n                x0 = x2;\n                x2 = temp4;\n                final double temp5 = x1;\n                x1 = x2;\n                x2 = temp5;\n            }\n            final double delta2 = h2 / h1;\n            double d3 = y2 - y1 - h2 * (y1 - y0) / h1;\n            final double a = d3 / (h1 * h2);\n            final double b = delta2 * a;\n            if (b == 0.0) {\n                if (h1 < 0) {\n                    signChange++;\n                }\n                return x1;\n            }\n            final double discriminant = b * b - a * c;\n            final double denom = 2.0 * delta2;\n            if (discriminant >= 0.0) {\n                // real root, compute result\n                double root = (b + FastMath.sqrt(discriminant)) / denom;\n                if (isValidBracketing(f, x1, root)) {\n                    if (FastMath.abs(x1 - root) <= getAbsoluteAccuracy()) {\n                        if (h1 < 0) {\n                            signChange++;\n                        }\n                        return root;\n                    }\n                    x0 = x1;\n                    y0 = y1;\n                    x1 = root;\n                    y1 = f.value(x1);\n                    if (y1 == 0.0) {\n                        if (h1 < 0) {\n                            signChange++;\n                        }\n                        return x1;\n                    }\n                    if (inverted ? y1 >= y0 : y1 <= y0) {\n                        x1 = x0;\n                        y1 = y0;\n                    }\n                }\n            }\n            if (signChange >= 2) {\n                return solve(min, 0.5 * (x0 + x1));\n            }\n            if (delta2 * d3 >= 0.0) {\n                final double tmp = delta;\n                delta = oldDelta - delta;\n                oldDelta = tmp;\n            }\n            if (FastMath.abs(delta) <= getAbsoluteAccuracy()) {\n                if (h1 < 0) {\n                    signChange++;\n                }\n                return x1;\n            }\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..c7dac8e39 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,131 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+    public double solve(final UnivariateRealFunction f, double min, double max, int maxIterations, double initial)\n+            throws MaxIterationsExceededException, FunctionEvaluationException {\n+        if (f == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+        if (maximumIterations < 1) {\n+            throw new NotStrictlyPositiveException(LocalizedFormats.INVALID_MAX_ITERATIONS, maxIterations);\n+        }\n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n+        if ((yMin * yMax) > 0.0) {\n+            throw new NoBracketingException(min, max, yMin, yMax);\n+        }\n+        if (yMin == 0.0) {\n+            return min;\n+        }\n+        if (yMax == 0.0) {\n+            return max;\n+        }\n+        // verify bracketing\n+        if (yMin > yMax) {\n+            double tmp = min;\n+            min = max;\n+            max = tmp;\n+            tmp = yMin;\n+            yMin = yMax;\n+            yMax = tmp;\n+        }\n+        final double ftol = getFunctionValueAccuracy();\n+        double x0 = initial;\n+        double x1 = max;\n+        double y0 = f.value(x0);\n+        double y1 = f.value(x1);\n+        int signChange = 0;\n+        double oldDelta = max - min;\n+        double delta = oldDelta;\n+        final boolean inverted = y0 > y1;\n+        if (inverted) {\n+            double tmp = x0;\n+            x0 = x1;\n+            x1 = tmp;\n+            tmp = y0;\n+            y0 = y1;\n+            y1 = tmp;\n+        }\n+        while (true) {\n+            delta = 0.5 * delta;\n+            final double x2 = x1 - delta;\n+            final double y2 = f.value(x2);\n+            if (Double.isNaN(y2)) {\n+                return Double.NaN;\n+            }\n+            double h1 = x1 - x0;\n+            double h2 = x2 - x1;\n+            if (!(Math.abs(h1) > Math.abs(h2))) {\n+                final double temp = h1;\n+                h1 = h2;\n+                h2 = temp;\n+                final double temp2 = y0;\n+                y0 = y2;\n+                y2 = temp2;\n+                final double temp3 = y1;\n+                y1 = y2;\n+                y2 = temp3;\n+                final double temp4 = x0;\n+                x0 = x2;\n+                x2 = temp4;\n+                final double temp5 = x1;\n+                x1 = x2;\n+                x2 = temp5;\n+            }\n+            final double delta2 = h2 / h1;\n+            double d3 = y2 - y1 - h2 * (y1 - y0) / h1;\n+            final double a = d3 / (h1 * h2);\n+            final double b = delta2 * a;\n+            if (b == 0.0) {\n+                if (h1 < 0) {\n+                    signChange++;\n+                }\n+                return x1;\n+            }\n+            final double discriminant = b * b - a * c;\n+            final double denom = 2.0 * delta2;\n+            if (discriminant >= 0.0) {\n+                // real root, compute result\n+                double root = (b + FastMath.sqrt(discriminant)) / denom;\n+                if (isValidBracketing(f, x1, root)) {\n+                    if (FastMath.abs(x1 - root) <= getAbsoluteAccuracy()) {\n+                        if (h1 < 0) {\n+                            signChange++;\n+                        }\n+                        return root;\n+                    }\n+                    x0 = x1;\n+                    y0 = y1;\n+                    x1 = root;\n+                    y1 = f.value(x1);\n+                    if (y1 == 0.0) {\n+                        if (h1 < 0) {\n+                            signChange++;\n+                        }\n+                        return x1;\n+                    }\n+                    if (inverted ? y1 >= y0 : y1 <= y0) {\n+                        x1 = x0;\n+                        y1 = y0;\n+                    }\n+                }\n+            }\n+            if (signChange >= 2) {\n+                return solve(min, 0.5 * (x0 + x1));\n+            }\n+            if (delta2 * d3 >= 0.0) {\n+                final double tmp = delta;\n+                delta = oldDelta - delta;\n+                oldDelta = tmp;\n+            }\n+            if (FastMath.abs(delta) <= getAbsoluteAccuracy()) {\n+                if (h1 < 0) {\n+                    signChange++;\n+                }\n+                return x1;\n+            }\n+        }\n+    }\n     }\n \n     /** {@inheritDoc} */",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}