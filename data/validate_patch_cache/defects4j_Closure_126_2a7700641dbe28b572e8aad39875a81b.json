{
    "patch": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      boolean falseCatch = true;\n      Node tryBlock = n.getFirstChild();\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      List<Node> catchNodes = allCatchNodes != null ? allCatchNodes.children() : ImmutableList.of();\n      for (Node catchNode : catchNodes) {\n        falseCatch = false;\n        Node catchBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchBlock, exitType, labelName);\n      }\n\n      if (!falseCatch) {\n        // try block is equivalent to else block\n        Node lastCatchBlock = catchNodes.get(catchNodes.size() - 1).getLastChild();\n        tryMinimizeIfBlockExits(lastCatchBlock, tryBlock, n, exitType, labelName);\n      }\n\n      Node finallyBlock = NodeUtil.getFinallyBlock(n);\n      if (finallyBlock != null) {\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n      return;\n    }\n\n    // Handle a switch statement.\n    if (n.isSwitch()) {\n      Node switchBlock = n.getLastChild();\n      for (Node switchCase = switchBlock.getFirstChild();\n           switchCase != null;\n           switchCase = switchCase.getNext()) {\n        Node statementsBlock = switchCase.getLastChild();\n        tryMinimizeExits(statementsBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(\n            trueBlock, falseBlock, ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(\n              falseBlock, trueBlock, ifTree, exitType, labelName);\n        }\n      } else {\n        tryMinimizeExits(c, exitType, labelName);\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..873ffd27 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -104,7 +104,6 @@ class MinimizeExitPoints\n    * @nullable labelName non-null only for breaks within labels.\n    */\n   void tryMinimizeExits(Node n, int exitType, String labelName) {\n-\n     // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n       NodeUtil.removeChild(n.getParent(), n);\n@@ -125,32 +124,47 @@ class MinimizeExitPoints\n \n     // Just a 'try/catch/finally'.\n     if (n.isTry()) {\n+      boolean falseCatch = true;\n       Node tryBlock = n.getFirstChild();\n-      tryMinimizeExits(tryBlock, exitType, labelName);\n       Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-        Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n+      List<Node> catchNodes = allCatchNodes != null ? allCatchNodes.children() : ImmutableList.of();\n+      for (Node catchNode : catchNodes) {\n+        falseCatch = false;\n+        Node catchBlock = catchNode.getLastChild();\n+        tryMinimizeExits(catchBlock, exitType, labelName);\n+      }\n+\n+      if (!falseCatch) {\n+        // try block is equivalent to else block\n+        Node lastCatchBlock = catchNodes.get(catchNodes.size() - 1).getLastChild();\n+        tryMinimizeIfBlockExits(lastCatchBlock, tryBlock, n, exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n+\n+      Node finallyBlock = NodeUtil.getFinallyBlock(n);\n+      if (finallyBlock != null) {\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n       }\n+      return;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n       tryMinimizeExits(labelBlock, exitType, labelName);\n+      return;\n     }\n \n-    // TODO(johnlenz): The last case of SWITCH statement?\n+    // Handle a switch statement.\n+    if (n.isSwitch()) {\n+      Node switchBlock = n.getLastChild();\n+      for (Node switchCase = switchBlock.getFirstChild();\n+           switchCase != null;\n+           switchCase = switchCase.getNext()) {\n+        Node statementsBlock = switchCase.getLastChild();\n+        tryMinimizeExits(statementsBlock, exitType, labelName);\n+      }\n+      return;\n+    }\n \n     // The rest assumes a block with at least one child, bail on anything else.\n     if (!n.isBlock() || n.getLastChild() == null) {\n@@ -161,8 +175,7 @@ class MinimizeExitPoints\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n       // An 'if' block to process below.\n       if (c.isIf()) {\n         Node ifTree = c;\n@@ -171,31 +184,19 @@ class MinimizeExitPoints\n         // First, the true condition block.\n         trueBlock = ifTree.getFirstChild().getNext();\n         falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n+        tryMinimizeIfBlockExits(\n+            trueBlock, falseBlock, ifTree, exitType, labelName);\n \n         // Now the else block.\n         // The if blocks may have changed, get them again.\n         trueBlock = ifTree.getFirstChild().getNext();\n         falseBlock = trueBlock.getNext();\n         if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n+          tryMinimizeIfBlockExits(\n+              falseBlock, trueBlock, ifTree, exitType, labelName);\n         }\n-      }\n-\n-      if (c == n.getLastChild()) {\n-        break;\n-      }\n-    }\n-\n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n-        break;\n+      } else {\n+        tryMinimizeExits(c, exitType, labelName);\n       }\n     }\n   }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}