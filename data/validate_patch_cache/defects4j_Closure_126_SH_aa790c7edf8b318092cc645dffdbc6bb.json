{
    "patch": "// Don't try to minimize the exits of finally blocks if there is a return statement\n// within finally block. This can cause problems if it changes the completion type\n// of the finally block. See ECMA 262 Sections 8.9 and 12.14.\nif (NodeUtil.hasFinally(n)) {\n  Node finallyBlock = NodeUtil.getFinallyBlock(n);\n  if (NodeUtil.hasReturnWithinNode(finallyBlock)) {\n    return;\n  }\n}\n\n// Just a 'label'.\nif (n.isLabel()) {\n  Node labelBlock = n.getLastChild();\n  tryMinimizeExits(labelBlock, exitType, labelName);\n  return;\n}\n\n// Just a switch statement.\nif (n.isSwitch()) {\n  for (Node caseNode : n.getLastChild().children()) {\n    Node caseBlock = caseNode.getLastChild();\n    tryMinimizeExits(caseBlock, exitType, labelName);\n  }\n  return;\n}\n\n// Rest assumes a block with at least one child, bail on anything else.\nif (!n.isBlock() || n.getLastChild() == null) {\n  return;\n}\n\nfor (Node c : n.children()) {\n  // An 'if' block to process below.\n  if (c.isIf()) {\n    Node ifTree = c;\n    Node trueBlock = ifTree.getFirstChild().getNext();\n    Node falseBlock = trueBlock.getNext();\n    tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n\n    // Now the else block.\n    if (falseBlock != null) {\n      tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n    }\n  }\n\n  if (c == n.getLastChild()) {\n    break;\n  }\n}\n\n// Now try to minimize the exits of the last child.\ntryMinimizeExits(n.getLastChild(), exitType, labelName);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..e37c6cc5 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -138,10 +138,58 @@ class MinimizeExitPoints\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n        */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+// Don't try to minimize the exits of finally blocks if there is a return statement\n+// within finally block. This can cause problems if it changes the completion type\n+// of the finally block. See ECMA 262 Sections 8.9 and 12.14.\n+if (NodeUtil.hasFinally(n)) {\n+  Node finallyBlock = NodeUtil.getFinallyBlock(n);\n+  if (NodeUtil.hasReturnWithinNode(finallyBlock)) {\n+    return;\n+  }\n+}\n+\n+// Just a 'label'.\n+if (n.isLabel()) {\n+  Node labelBlock = n.getLastChild();\n+  tryMinimizeExits(labelBlock, exitType, labelName);\n+  return;\n+}\n+\n+// Just a switch statement.\n+if (n.isSwitch()) {\n+  for (Node caseNode : n.getLastChild().children()) {\n+    Node caseBlock = caseNode.getLastChild();\n+    tryMinimizeExits(caseBlock, exitType, labelName);\n+  }\n+  return;\n+}\n+\n+// Rest assumes a block with at least one child, bail on anything else.\n+if (!n.isBlock() || n.getLastChild() == null) {\n+  return;\n+}\n+\n+for (Node c : n.children()) {\n+  // An 'if' block to process below.\n+  if (c.isIf()) {\n+    Node ifTree = c;\n+    Node trueBlock = ifTree.getFirstChild().getNext();\n+    Node falseBlock = trueBlock.getNext();\n+    tryMinimizeIfBlockExits(trueBlock, falseBlock, ifTree, exitType, labelName);\n+\n+    // Now the else block.\n+    if (falseBlock != null) {\n+      tryMinimizeIfBlockExits(falseBlock, trueBlock, ifTree, exitType, labelName);\n+    }\n+  }\n+\n+  if (c == n.getLastChild()) {\n+    break;\n+  }\n+}\n+\n+// Now try to minimize the exits of the last child.\n+tryMinimizeExits(n.getLastChild(), exitType, labelName);\n     }\n \n     // Just a 'label'.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}