{
    "patch": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      if (n.isBreak() && !isLoop(n)) {\n        // Don't remove \"break\" statements that are not enclosed in loops,\n        // unless they are labeled or they have an explicit return value.\n        // The latter is used by the function normalizeReturns.\n        Node target = n.getFirstChild();\n        if (target == null || labelName != null || target.isReturnValue()) {\n          n.detach();\n        }\n      } else {\n        n.detach();\n      }\n      compiler.reportChangeToEnclosingScope(n);\n      return;\n    }\n \n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n \n      // 'finally' blocks should never change completion types.\n      if (!NodeUtil.hasFinally(n)) {\n        // If it's an unconditional block, transfer its children to the parent block.\n        if (NodeUtil.hasOneChildBlock(n) && !analyzer.mayHaveSideEffects(n.getFirstChild())) {\n          // Remove the blank return statement instead of detaching it.\n          NodeUtil.removeEnd(n.getParent(), n);\n          NodeUtil.moveChildren(n.getFirstChild(), n.getParent());\n          n.getParent().removeChild(n.getFirstChild());\n          compiler.reportChangeToEnclosingScope(n.getParent());\n          return;\n        }\n \n        // If there are only conditional blocks, try to combine them.\n        Node singleExit = tryCombineConditionalBlocks(n);\n        if (singleExit != null) {\n          tryMinimizeExits(singleExit, exitType, labelName);\n          return;\n        }\n      }\n \n      // Recurse into catch blocks.\n      if (NodeUtil.hasAnyCatchBlock(n)) {\n        Node catchers = NodeUtil.getCatchBlock(n);\n        Preconditions.checkState(catchers.isBlock(), catchers);\n        for (Node c = catchers.getFirstChild(); c != null; c = c.getNext()) {\n          tryMinimizeExits(c.getLastChild(), exitType, labelName);\n        }\n      }\n    }\n \n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n \n    // Recurse into block, label, and loop nodes.\n    if (n.isBlock() || n.isLabel() || n.isLoop()) {\n      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n        tryMinimizeExits(c, exitType, labelName);\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..ee44111d 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -104,98 +104,73 @@ class MinimizeExitPoints\n    * @nullable labelName non-null only for breaks within labels.\n    */\n   void tryMinimizeExits(Node n, int exitType, String labelName) {\n-\n     // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n-      NodeUtil.removeChild(n.getParent(), n);\n-      compiler.reportCodeChange();\n-      return;\n-    }\n-\n-    // Just an 'if'.\n-    if (n.isIf()) {\n-      Node ifBlock = n.getFirstChild().getNext();\n-      tryMinimizeExits(ifBlock, exitType, labelName);\n-      Node elseBlock = ifBlock.getNext();\n-      if (elseBlock != null) {\n-        tryMinimizeExits(elseBlock, exitType, labelName);\n+      if (n.isBreak() && !isLoop(n)) {\n+        // Don't remove \"break\" statements that are not enclosed in loops,\n+        // unless they are labeled or they have an explicit return value.\n+        // The latter is used by the function normalizeReturns.\n+        Node target = n.getFirstChild();\n+        if (target == null || labelName != null || target.isReturnValue()) {\n+          n.detach();\n+        }\n+      } else {\n+        n.detach();\n       }\n+      compiler.reportChangeToEnclosingScope(n);\n       return;\n     }\n-\n+ \n     // Just a 'try/catch/finally'.\n     if (n.isTry()) {\n       Node tryBlock = n.getFirstChild();\n       tryMinimizeExits(tryBlock, exitType, labelName);\n-      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-        Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n-      }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+ \n+      // 'finally' blocks should never change completion types.\n+      if (!NodeUtil.hasFinally(n)) {\n+        // If it's an unconditional block, transfer its children to the parent block.\n+        if (NodeUtil.hasOneChildBlock(n) && !analyzer.mayHaveSideEffects(n.getFirstChild())) {\n+          // Remove the blank return statement instead of detaching it.\n+          NodeUtil.removeEnd(n.getParent(), n);\n+          NodeUtil.moveChildren(n.getFirstChild(), n.getParent());\n+          n.getParent().removeChild(n.getFirstChild());\n+          compiler.reportChangeToEnclosingScope(n.getParent());\n+          return;\n+        }\n+ \n+        // If there are only conditional blocks, try to combine them.\n+        Node singleExit = tryCombineConditionalBlocks(n);\n+        if (singleExit != null) {\n+          tryMinimizeExits(singleExit, exitType, labelName);\n+          return;\n+        }\n       }\n-    }\n-\n-    // Just a 'label'.\n-    if (n.isLabel()) {\n-      Node labelBlock = n.getLastChild();\n-      tryMinimizeExits(labelBlock, exitType, labelName);\n-    }\n-\n-    // TODO(johnlenz): The last case of SWITCH statement?\n-\n-    // The rest assumes a block with at least one child, bail on anything else.\n-    if (!n.isBlock() || n.getLastChild() == null) {\n-      return;\n-    }\n-\n-    // Multiple if-exits can be converted in a single pass.\n-    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-\n-      // An 'if' block to process below.\n-      if (c.isIf()) {\n-        Node ifTree = c;\n-        Node trueBlock, falseBlock;\n-\n-        // First, the true condition block.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n-\n-        // Now the else block.\n-        // The if blocks may have changed, get them again.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n+ \n+      // Recurse into catch blocks.\n+      if (NodeUtil.hasAnyCatchBlock(n)) {\n+        Node catchers = NodeUtil.getCatchBlock(n);\n+        Preconditions.checkState(catchers.isBlock(), catchers);\n+        for (Node c = catchers.getFirstChild(); c != null; c = c.getNext()) {\n+          tryMinimizeExits(c.getLastChild(), exitType, labelName);\n         }\n       }\n-\n-      if (c == n.getLastChild()) {\n-        break;\n+    }\n+ \n+    // Just an 'if'.\n+    if (n.isIf()) {\n+      Node ifBlock = n.getFirstChild().getNext();\n+      tryMinimizeExits(ifBlock, exitType, labelName);\n+      Node elseBlock = ifBlock.getNext();\n+      if (elseBlock != null) {\n+        tryMinimizeExits(elseBlock, exitType, labelName);\n       }\n+      return;\n     }\n-\n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n-        break;\n+ \n+    // Recurse into block, label, and loop nodes.\n+    if (n.isBlock() || n.isLabel() || n.isLoop()) {\n+      for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+        tryMinimizeExits(c, exitType, labelName);\n       }\n     }\n   }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}