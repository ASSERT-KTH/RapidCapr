{
    "patch": "public double toDouble() {\n    if (isNaN()) {\n        return Double.NaN;\n    }\n    if (isInfinite()) {\n        return lessThan(Dfp.ZERO) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n    }\n    Dfp y = this;\n    boolean neg = false;\n    if (lessThan(Dfp.ZERO)) {\n        neg = true;\n        y = y.negate();\n    }\n    // extract exponent for y\n    int expY = y.getExponent();\n    while (y.greaterThan(Dfp.TEN)) {\n        y = y.divide(Dfp.TEN);\n        ++expY;\n    }\n    while (y.lessThan(Dfp.ONE)) {\n        y = y.multiply(Dfp.TEN);\n        --expY;\n    }\n    long bits = 0;\n    if (y.greaterThan(Dfp.MIN_NORMAL)) {\n        // Normal case: 1 <= y < 2^53\n        bits = ((expY + 1023L) << 52);\n        y = y.divide(Dfp.MIN_NORMAL);\n    } else {\n        // Subnormal case: y < 2^-1022, the minimum normal number\n        double scale = Math.scalb(1.0, Math.max(expY, -1022) - (-1022) + 1);\n        y = y.multiply(scale);\n        bits = 0;\n    }\n    // because y is a 64-bit fixed-point number, its value\n    // can be represented exactly as a double without any\n    // rounding errors. Thus, we can play with the high-order\n    // bits of its integer representation instead of multiplying\n    // and rounding to a 53-bit double floating-point number.\n    assert y.greaterThan(Dfp.ONE) && y.lessThan(Dfp.TWO);\n    assert bits >= 0 && bits <= ((long)1023L + 1023L) << 52;\n    for (int i = 1; i <= 52; i++) {\n        y = y.multiply(y);\n        if (y.greaterThan(Dfp.TWO)) {\n            bits |= (1L << (52 - i));\n            y = y.divide(Dfp.TWO);\n        }\n    }\n    return Double.longBitsToDouble(neg ? (bits | 0x8000000000000000L) : bits);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/dfp/Dfp.java b/src/main/java/org/apache/commons/math/dfp/Dfp.java\nindex 73f1ea3e8..9ef913e10 100644\n--- a/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n@@ -253,88 +253,56 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param field field to which this instance belongs\n      * @param x value to convert to an instance\n      */\n-    protected Dfp(final DfpField field, double x) {\n-\n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n-        this.field = field;\n-\n-        long bits = Double.doubleToLongBits(x);\n-        long mantissa = bits & 0x000fffffffffffffL;\n-        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n-\n-        if (exponent == -1023) {\n-            // Zero or sub-normal\n-            if (x == 0) {\n-                // make sure 0 has the right sign\n-                return;\n-            }\n-\n-            exponent++;\n-\n-            // Normalize the subnormal number\n-            while ( (mantissa & 0x0010000000000000L) == 0) {\n-                exponent--;\n-                mantissa <<= 1;\n-            }\n-            mantissa &= 0x000fffffffffffffL;\n-        }\n-\n-        if (exponent == 1024) {\n-            // infinity or NAN\n-            if (x != x) {\n-                sign = (byte) 1;\n-                nans = QNAN;\n-            } else if (x < 0) {\n-                sign = (byte) -1;\n-                nans = INFINITE;\n-            } else {\n-                sign = (byte) 1;\n-                nans = INFINITE;\n-            }\n-            return;\n-        }\n-\n-        Dfp xdfp = new Dfp(field, mantissa);\n-        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n-        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n-\n-        if ((bits & 0x8000000000000000L) != 0) {\n-            xdfp = xdfp.negate();\n-        }\n-\n-        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n-        sign = xdfp.sign;\n-        exp  = xdfp.exp;\n-        nans = xdfp.nans;\n-\n+public double toDouble() {\n+    if (isNaN()) {\n+        return Double.NaN;\n     }\n-\n-    /** Copy constructor.\n-     * @param d instance to copy\n-     */\n-    public Dfp(final Dfp d) {\n-        mant  = d.mant.clone();\n-        sign  = d.sign;\n-        exp   = d.exp;\n-        nans  = d.nans;\n-        field = d.field;\n+    if (isInfinite()) {\n+        return lessThan(Dfp.ZERO) ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n     }\n-\n-    /** Create an instance from a String representation.\n-     * @param field field to which this instance belongs\n-     * @param s string representation of the instance\n-     */\n-    protected Dfp(final DfpField field, final String s) {\n-\n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n+    Dfp y = this;\n+    boolean neg = false;\n+    if (lessThan(Dfp.ZERO)) {\n+        neg = true;\n+        y = y.negate();\n+    }\n+    // extract exponent for y\n+    int expY = y.getExponent();\n+    while (y.greaterThan(Dfp.TEN)) {\n+        y = y.divide(Dfp.TEN);\n+        ++expY;\n+    }\n+    while (y.lessThan(Dfp.ONE)) {\n+        y = y.multiply(Dfp.TEN);\n+        --expY;\n+    }\n+    long bits = 0;\n+    if (y.greaterThan(Dfp.MIN_NORMAL)) {\n+        // Normal case: 1 <= y < 2^53\n+        bits = ((expY + 1023L) << 52);\n+        y = y.divide(Dfp.MIN_NORMAL);\n+    } else {\n+        // Subnormal case: y < 2^-1022, the minimum normal number\n+        double scale = Math.scalb(1.0, Math.max(expY, -1022) - (-1022) + 1);\n+        y = y.multiply(scale);\n+        bits = 0;\n+    }\n+    // because y is a 64-bit fixed-point number, its value\n+    // can be represented exactly as a double without any\n+    // rounding errors. Thus, we can play with the high-order\n+    // bits of its integer representation instead of multiplying\n+    // and rounding to a 53-bit double floating-point number.\n+    assert y.greaterThan(Dfp.ONE) && y.lessThan(Dfp.TWO);\n+    assert bits >= 0 && bits <= ((long)1023L + 1023L) << 52;\n+    for (int i = 1; i <= 52; i++) {\n+        y = y.multiply(y);\n+        if (y.greaterThan(Dfp.TWO)) {\n+            bits |= (1L << (52 - i));\n+            y = y.divide(Dfp.TWO);\n+        }\n+    }\n+    return Double.longBitsToDouble(neg ? (bits | 0x8000000000000000L) : bits);\n+}\n         this.field = field;\n \n         boolean decimalFound = false;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}