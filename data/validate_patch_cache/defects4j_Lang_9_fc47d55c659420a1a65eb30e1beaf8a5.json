{
    "patch": "private String parse(String input, ParsePosition pos) throws ParseException {\n    Calendar cal = Calendar.getInstance(timeZone, locale);\n    int index = pos.getIndex();\n\n    Matcher matcher = parsePattern.matcher(input);\n    if (!matcher.region(index, input.length()).lookingAt()) {\n        pos.setErrorIndex(index);\n        return null;\n    }\n\n    String[][] newValues = new String[strategies.length][];\n    for (int i = 0; i < strategies.length; i++) {\n        newValues[i] = strategies[i].extractValues(this, matcher);\n        if (newValues[i] == null) {\n            pos.setErrorIndex(index);\n            return null;\n        }\n    }\n    for (int i = 0; i < nameValues.length; ++i) {\n        nameValues[i] = null;\n    }\n    for (int i = 0; i < newValues.length; ++i) {\n        KeyValue[] current = nameValues[i];\n        if (current == null || !Arrays.equals(current, newValues[i])) {\n            nameValues[i] = newValues[i];\n            strategies[i].setCalendar(this, cal, newValues[i]);\n        }\n    }\n    pos.setIndex(matcher.end());\n    return \"\";\n}\n\n// Regular expression that matches all valid 2-digit years.\n// Must try 2-digit years starting in 1950, so add 49 to the\n// current year to find the first year of the 100-year period\n// we will recognize.\nprivate static final String g_defaultCenturyStartString =\n    \"2000\";\nprivate static final int g_numCenturyDigits = 2;\n\nprivate static final SimpleDateFormat g_defaultFormatter = new SimpleDateFormat(\"yyyyMMddHHmmssSSS\");\npublic static final long UNSET = -1;\nstatic final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n\nprivate String pattern;\nprivate Locale locale;\nprivate TimeZone timeZone;\n\nprivate int thisYear;\nprivate ConcurrentHashMap<Integer, KeyValue[]> nameValues;\nprivate Strategy[] strategies;\nprivate Pattern parsePattern;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 8df302f9..8499b504 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -112,42 +112,58 @@ public class FastDateParser implements DateParser, Serializable {\n      * Initialize derived fields from defining fields.\n      * This is called from constructor and from readObject (de-serialization)\n      */\n-    private void init() {\n-        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n-\n-        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n-\n-        StringBuilder regex= new StringBuilder();\n-        List<Strategy> collector = new ArrayList<Strategy>();\n-\n-        Matcher patternMatcher= formatPattern.matcher(pattern);\n-        if(!patternMatcher.lookingAt()) {\n-            throw new IllegalArgumentException(\"Invalid pattern\");\n-        }\n+private String parse(String input, ParsePosition pos) throws ParseException {\n+    Calendar cal = Calendar.getInstance(timeZone, locale);\n+    int index = pos.getIndex();\n+\n+    Matcher matcher = parsePattern.matcher(input);\n+    if (!matcher.region(index, input.length()).lookingAt()) {\n+        pos.setErrorIndex(index);\n+        return null;\n+    }\n \n-        currentFormatField= patternMatcher.group();\n-        Strategy currentStrategy= getStrategy(currentFormatField);\n-        for(;;) {\n-            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n-            if(!patternMatcher.lookingAt()) {\n-                nextStrategy = null;\n-                break;\n-            }\n-            String nextFormatField= patternMatcher.group();\n-            nextStrategy = getStrategy(nextFormatField);\n-            if(currentStrategy.addRegex(this, regex)) {\n-                collector.add(currentStrategy);\n-            }\n-            currentFormatField= nextFormatField;\n-            currentStrategy= nextStrategy;\n+    String[][] newValues = new String[strategies.length][];\n+    for (int i = 0; i < strategies.length; i++) {\n+        newValues[i] = strategies[i].extractValues(this, matcher);\n+        if (newValues[i] == null) {\n+            pos.setErrorIndex(index);\n+            return null;\n         }\n-        if(currentStrategy.addRegex(this, regex)) {\n-            collector.add(currentStrategy);\n+    }\n+    for (int i = 0; i < nameValues.length; ++i) {\n+        nameValues[i] = null;\n+    }\n+    for (int i = 0; i < newValues.length; ++i) {\n+        KeyValue[] current = nameValues[i];\n+        if (current == null || !Arrays.equals(current, newValues[i])) {\n+            nameValues[i] = newValues[i];\n+            strategies[i].setCalendar(this, cal, newValues[i]);\n         }\n-        currentFormatField= null;\n-        strategies= collector.toArray(new Strategy[collector.size()]);\n-        parsePattern= Pattern.compile(regex.toString());\n     }\n+    pos.setIndex(matcher.end());\n+    return \"\";\n+}\n+\n+// Regular expression that matches all valid 2-digit years.\n+// Must try 2-digit years starting in 1950, so add 49 to the\n+// current year to find the first year of the 100-year period\n+// we will recognize.\n+private static final String g_defaultCenturyStartString =\n+    \"2000\";\n+private static final int g_numCenturyDigits = 2;\n+\n+private static final SimpleDateFormat g_defaultFormatter = new SimpleDateFormat(\"yyyyMMddHHmmssSSS\");\n+public static final long UNSET = -1;\n+static final TimeZone GMT = TimeZone.getTimeZone(\"GMT\");\n+\n+private String pattern;\n+private Locale locale;\n+private TimeZone timeZone;\n+\n+private int thisYear;\n+private ConcurrentHashMap<Integer, KeyValue[]> nameValues;\n+private Strategy[] strategies;\n+private Pattern parsePattern;\n \n     // Accessors\n     //-----------------------------------------------------------------------",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}