{
    "patch": "public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n            throws MaxIterationsExceededException, FunctionEvaluationException {\n        final double absoluteAccuracy = getAbsoluteAccuracy();\n        final double relativeAccuracy = getRelativeAccuracy();\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n\n        // Check inputs.\n        verifyInterval(min, max);\n        verifySequence(min, initial, max);\n\n        double yInitial = f.value(initial);\n        if (FastMath.abs(yInitial) <= 0) {\n            return initial;\n        }\n        double yMin = f.value(min);\n        if (FastMath.abs(yMin) <= 0) {\n            return min;\n        }\n        double yMax = f.value(max);\n        if (FastMath.abs(yMax) <= 0) {\n            return max;\n        }\n\n        // Bisection method.\n        double x1 = min, x2 = initial, x3 = max;\n        double y1 = yMin, y2 = yInitial, y3 = yMax;\n        double previousY = Double.POSITIVE_INFINITY;\n        double x = Double.NaN;\n        while (true) {\n            double denominator = (y2 - y1) * (y3 - y2) * (y3 - y1);\n            if (denominator == 0) {\n                // Cannot continue with bisection method.\n                throw new FunctionEvaluationException(x, \"the solution escaped the search interval\");\n            }\n            double delta =\n                    (\n                            (y1 - y2) * (y2 - y3) * (y3 - y1) * (x3 - x2) +\n                            x2 * (y2 - y3) * (y3 - y1) +\n                            x3 * (y1 - y2) * (y2 - y3)\n                    ) /\n                    (2 * denominator);\n            x = x2 + delta;\n\n            double y = f.value(x);\n            if (FastMath.abs(y) <= 0) {\n                // Found exact solution.\n                return x;\n            }\n\n            if (x == x1 || x == x2 || x == x3) {\n                // Cannot continue with bisection method.\n                throw new FunctionEvaluationException(x, \"the solution escaped the search interval\");\n            }\n\n            if (y1 * y < 0) {\n                x3 = x2;\n                y3 = y2;\n                x2 = x;\n                y2 = y;\n            } else if (y2 * y < 0) {\n                x1 = x2;\n                y1 = y2;\n                x2 = x;\n                y2 = y;\n            } else if (y3 * y < 0) {\n                x1 = x2;\n                y1 = y2;\n                x2 = x;\n                y2 = y;\n                x3 = x;\n                y3 = y;\n            } else {\n                // Cannot continue with bisection method.\n                throw new FunctionEvaluationException(x, \"the solution escaped the search interval\");\n            }\n\n            // Check convergence.\n            if (FastMath.abs(previousY - y) <=\n                    FastMath.max(absoluteAccuracy,\n                            FastMath.max(FastMath.abs(x) * relativeAccuracy, functionValueAccuracy))) {\n                return x;\n            }\n            previousY = y;\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..075d60025 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -69,7 +69,91 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+            throws MaxIterationsExceededException, FunctionEvaluationException {\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double relativeAccuracy = getRelativeAccuracy();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        // Check inputs.\n+        verifyInterval(min, max);\n+        verifySequence(min, initial, max);\n+\n+        double yInitial = f.value(initial);\n+        if (FastMath.abs(yInitial) <= 0) {\n+            return initial;\n+        }\n+        double yMin = f.value(min);\n+        if (FastMath.abs(yMin) <= 0) {\n+            return min;\n+        }\n+        double yMax = f.value(max);\n+        if (FastMath.abs(yMax) <= 0) {\n+            return max;\n+        }\n+\n+        // Bisection method.\n+        double x1 = min, x2 = initial, x3 = max;\n+        double y1 = yMin, y2 = yInitial, y3 = yMax;\n+        double previousY = Double.POSITIVE_INFINITY;\n+        double x = Double.NaN;\n+        while (true) {\n+            double denominator = (y2 - y1) * (y3 - y2) * (y3 - y1);\n+            if (denominator == 0) {\n+                // Cannot continue with bisection method.\n+                throw new FunctionEvaluationException(x, \"the solution escaped the search interval\");\n+            }\n+            double delta =\n+                    (\n+                            (y1 - y2) * (y2 - y3) * (y3 - y1) * (x3 - x2) +\n+                            x2 * (y2 - y3) * (y3 - y1) +\n+                            x3 * (y1 - y2) * (y2 - y3)\n+                    ) /\n+                    (2 * denominator);\n+            x = x2 + delta;\n+\n+            double y = f.value(x);\n+            if (FastMath.abs(y) <= 0) {\n+                // Found exact solution.\n+                return x;\n+            }\n+\n+            if (x == x1 || x == x2 || x == x3) {\n+                // Cannot continue with bisection method.\n+                throw new FunctionEvaluationException(x, \"the solution escaped the search interval\");\n+            }\n+\n+            if (y1 * y < 0) {\n+                x3 = x2;\n+                y3 = y2;\n+                x2 = x;\n+                y2 = y;\n+            } else if (y2 * y < 0) {\n+                x1 = x2;\n+                y1 = y2;\n+                x2 = x;\n+                y2 = y;\n+            } else if (y3 * y < 0) {\n+                x1 = x2;\n+                y1 = y2;\n+                x2 = x;\n+                y2 = y;\n+                x3 = x;\n+                y3 = y;\n+            } else {\n+                // Cannot continue with bisection method.\n+                throw new FunctionEvaluationException(x, \"the solution escaped the search interval\");\n+            }\n+\n+            // Check convergence.\n+            if (FastMath.abs(previousY - y) <=\n+                    FastMath.max(absoluteAccuracy,\n+                            FastMath.max(FastMath.abs(x) * relativeAccuracy, functionValueAccuracy))) {\n+                return x;\n+            }\n+            previousY = y;\n+        }\n+    }\n     }\n \n     /** {@inheritDoc} */",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}