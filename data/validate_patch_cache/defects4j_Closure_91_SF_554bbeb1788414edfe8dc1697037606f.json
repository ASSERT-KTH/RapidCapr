{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.ControlFlowGraph;\nimport com.google.javascript.jscomp.DiGraphEdge;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.TokenStream;\nimport com.google.javascript.rhino.jstype.JSDocInfo;\nimport java.util.EnumSet;\nimport java.util.function.Consumer;\n\npublic class MyTool {\n  \n  /**\n   * Looks for potentially dangerous function calls. Specifically,\n   * we are looking for function calls that pass the global \"this\" value\n   * as an argument.\n   */\n  public static class FindDangerousFunctionCalls\n      extends AbstractPostOrderCallback implements NodeTraversal.Callback {\n    \n    private final AbstractCompiler compiler;\n    private final Consumer<Node> dangerousFunctionCallback;\n    private ControlFlowGraph<Node> cfg;\n\n    public FindDangerousFunctionCalls(AbstractCompiler compiler,\n        Consumer<Node> dangerousFunctionCallback) {\n      this.compiler = compiler;\n      this.dangerousFunctionCallback = dangerousFunctionCallback;\n    }\n    \n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isFunction()) {\n        visitFunction(n);\n      } else if (n.isCall()) {\n        visitCall(n);\n      }\n    }\n\n    private void visitFunction(Node function) {\n      cfg = getCfg(function);\n    }\n    \n    private void visitCall(Node call) {\n      // Check if the function being called is dangerous. If it is, check if\n      // \"this\" is being passed as an argument. If it is, log it as dangerous.\n      Node callee = call.getFirstChild();\n      if (!callee.isQualifiedName()) {\n        return;\n      }\n      String functionName = callee.getQualifiedName();\n      if (functionName == null) {\n        return;\n      }\n      if (functionName.equals(\"eval\") || functionName.equals(\"execScript\")) {\n        // Code passed to eval and execScript run in the same global scope as\n        // the function that called it, so passing \"this\" to them is dangerous.\n        visitEvalOrExecScript(call);\n      } else if (functionName.equals(\"setTimeout\") ||\n                 functionName.equals(\"setInterval\")) {\n        // Functions passed to setTimeout and setInterval run in the global scope,\n        // so passing \"this\" to them is dangerous.\n        visitTimeoutOrInterval(functionName, call);\n      } else {\n        // Check if the function being called is a method of an object (i.e., \"this\"\n        // is specified by the caller of the function). If it is, check if \"this\" is\n        // being passed as an argument. If it is, log it as dangerous.\n        for (DiGraphEdge<Node, Branch> edge :\n             cfg.getInEdges(call)) {\n          Node function = edge.getSource().getValue();\n          if (!function.isFunction()) {\n            continue;\n          }\n          JSDocInfo jsDoc = getFunctionJsDocInfo(function);\n          if (jsDoc != null && jsDoc.isConstructor()) {\n            // Don't flag calls to constructors as dangerous because \"this\" is\n            // expected.\n            continue;\n          }\n          Node lhs = edge.getValue().getLhs(call);\n          if (lhs == null) {\n            // No \"this\" argument passed.\n            continue;\n          }\n          if (lhs.matchesQualifiedName(\"this\")) {\n            dangerousFunctionCallback.accept(function);\n          }\n        }\n      }\n    }\n\n    private void visitEvalOrExecScript(Node call) {\n      Node secondArg = call.getSecondChild();\n      // eval and execScript have special behavior when called with a second argument\n      // that specifies the scope in which the code should be evaluated. If it is not\n      // specified, the code is executed in the global scope.\n      if (secondArg == null) {\n        // \"this\" argument not specified, so it's dangerous.\n        dangerousFunctionCallback.accept(call);\n      } else if (!secondArg.isString()) {\n        // The second argument is not a string literal, so we can't determine\n        // where the code will be executed. Assume it's dangerous.\n        dangerousFunctionCallback.accept(call);\n      }\n    }\n\n    private void visitTimeoutOrInterval(String functionName, Node call) {\n      Node secondArg = call.getSecondChild();\n      if (secondArg == null) {\n        // A delay time should always be specified for the setTimeout and\n        // setInterval functions, so not passing \"this\" is not dangerous.\n        return;\n      }\n      JSDocInfo jsDoc = getFunctionJsDocInfo(secondArg);\n      if (jsDoc != null && jsDoc.hasThisType()) {\n        // A type is specified for the second argument, which indicates that the\n        // function passed is a method of an object. Since \"this\" is specified,\n        // it's possible that it's being used by the function and not dangerous.\n        return;\n      }\n      if (secondArg.matchesQualifiedName(\"this\")) {\n        dangerousFunctionCallback.accept(call);\n      }\n    }\n\n    private ControlFlowGraph<Node> getCfg(Node root) {\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      cfa.process(null, root);\n      DiGraph<Node, Branch> graph = cfa.getCfg().toDiGraph();\n      return new ControlFlowGraph<>(graph);\n    }\n    \n    // Returns any JSDocInfo associated with a function node.\n    private JSDocInfo getFunctionJsDocInfo(Node node) {\n      return NodeUtil.getBestJSDocInfo(node);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..a5380ce6 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -79,71 +79,145 @@ final class CheckGlobalThis implements Callback {\n    * Since this pass reports errors only when a global {@code this} keyword\n    * is encountered, there is no reason to traverse non global contexts.\n    */\n-  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n-\n-    if (n.getType() == Token.FUNCTION) {\n-      // Don't traverse functions that are constructors or have the @this\n-      // or @override annotation.\n-      JSDocInfo jsDoc = getFunctionJsDocInfo(n);\n-      if (jsDoc != null &&\n-          (jsDoc.isConstructor() ||\n-           jsDoc.isInterface() ||\n-           jsDoc.hasThisType() ||\n-           jsDoc.isOverride())) {\n-        return false;\n-      }\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.ControlFlowGraph;\n+import com.google.javascript.jscomp.DiGraphEdge;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.NodeUtil;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.TokenStream;\n+import com.google.javascript.rhino.jstype.JSDocInfo;\n+import java.util.EnumSet;\n+import java.util.function.Consumer;\n \n-      // Don't traverse functions unless they would normally\n-      // be able to have a @this annotation associated with them. e.g.,\n-      // var a = function() { }; // or\n-      // function a() {} // or\n-      // a.x = function() {}; // or\n-      // var a = {x: function() {}};\n-      int pType = parent.getType();\n-      if (!(pType == Token.BLOCK ||\n-            pType == Token.SCRIPT ||\n-            pType == Token.NAME ||\n-            pType == Token.ASSIGN ||\n-\n-            // object literal keys\n-            pType == Token.STRING ||\n-            pType == Token.NUMBER)) {\n-        return false;\n-      }\n+public class MyTool {\n+  \n+  /**\n+   * Looks for potentially dangerous function calls. Specifically,\n+   * we are looking for function calls that pass the global \"this\" value\n+   * as an argument.\n+   */\n+  public static class FindDangerousFunctionCalls\n+      extends AbstractPostOrderCallback implements NodeTraversal.Callback {\n+    \n+    private final AbstractCompiler compiler;\n+    private final Consumer<Node> dangerousFunctionCallback;\n+    private ControlFlowGraph<Node> cfg;\n \n-      // Don't traverse functions that are getting lent to a prototype.\n+    public FindDangerousFunctionCalls(AbstractCompiler compiler,\n+        Consumer<Node> dangerousFunctionCallback) {\n+      this.compiler = compiler;\n+      this.dangerousFunctionCallback = dangerousFunctionCallback;\n+    }\n+    \n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isFunction()) {\n+        visitFunction(n);\n+      } else if (n.isCall()) {\n+        visitCall(n);\n+      }\n     }\n \n-    if (parent != null && parent.getType() == Token.ASSIGN) {\n-      Node lhs = parent.getFirstChild();\n-      Node rhs = lhs.getNext();\n-\n-      if (n == lhs) {\n-        // Always traverse the left side of the assignment. To handle\n-        // nested assignments properly (e.g., (a = this).property = c;),\n-        // assignLhsChild should not be overridden.\n-        if (assignLhsChild == null) {\n-          assignLhsChild = lhs;\n-        }\n+    private void visitFunction(Node function) {\n+      cfg = getCfg(function);\n+    }\n+    \n+    private void visitCall(Node call) {\n+      // Check if the function being called is dangerous. If it is, check if\n+      // \"this\" is being passed as an argument. If it is, log it as dangerous.\n+      Node callee = call.getFirstChild();\n+      if (!callee.isQualifiedName()) {\n+        return;\n+      }\n+      String functionName = callee.getQualifiedName();\n+      if (functionName == null) {\n+        return;\n+      }\n+      if (functionName.equals(\"eval\") || functionName.equals(\"execScript\")) {\n+        // Code passed to eval and execScript run in the same global scope as\n+        // the function that called it, so passing \"this\" to them is dangerous.\n+        visitEvalOrExecScript(call);\n+      } else if (functionName.equals(\"setTimeout\") ||\n+                 functionName.equals(\"setInterval\")) {\n+        // Functions passed to setTimeout and setInterval run in the global scope,\n+        // so passing \"this\" to them is dangerous.\n+        visitTimeoutOrInterval(functionName, call);\n       } else {\n-        // Only traverse the right side if it's not an assignment to a prototype\n-        // property or subproperty.\n-        if (NodeUtil.isGet(lhs)) {\n-          if (lhs.getType() == Token.GETPROP &&\n-              lhs.getLastChild().getString().equals(\"prototype\")) {\n-            return false;\n+        // Check if the function being called is a method of an object (i.e., \"this\"\n+        // is specified by the caller of the function). If it is, check if \"this\" is\n+        // being passed as an argument. If it is, log it as dangerous.\n+        for (DiGraphEdge<Node, Branch> edge :\n+             cfg.getInEdges(call)) {\n+          Node function = edge.getSource().getValue();\n+          if (!function.isFunction()) {\n+            continue;\n           }\n-          Node llhs = lhs.getFirstChild();\n-          if (llhs.getType() == Token.GETPROP &&\n-              llhs.getLastChild().getString().equals(\"prototype\")) {\n-            return false;\n+          JSDocInfo jsDoc = getFunctionJsDocInfo(function);\n+          if (jsDoc != null && jsDoc.isConstructor()) {\n+            // Don't flag calls to constructors as dangerous because \"this\" is\n+            // expected.\n+            continue;\n+          }\n+          Node lhs = edge.getValue().getLhs(call);\n+          if (lhs == null) {\n+            // No \"this\" argument passed.\n+            continue;\n+          }\n+          if (lhs.matchesQualifiedName(\"this\")) {\n+            dangerousFunctionCallback.accept(function);\n           }\n         }\n       }\n     }\n \n-    return true;\n-  }\n+    private void visitEvalOrExecScript(Node call) {\n+      Node secondArg = call.getSecondChild();\n+      // eval and execScript have special behavior when called with a second argument\n+      // that specifies the scope in which the code should be evaluated. If it is not\n+      // specified, the code is executed in the global scope.\n+      if (secondArg == null) {\n+        // \"this\" argument not specified, so it's dangerous.\n+        dangerousFunctionCallback.accept(call);\n+      } else if (!secondArg.isString()) {\n+        // The second argument is not a string literal, so we can't determine\n+        // where the code will be executed. Assume it's dangerous.\n+        dangerousFunctionCallback.accept(call);\n+      }\n+    }\n+\n+    private void visitTimeoutOrInterval(String functionName, Node call) {\n+      Node secondArg = call.getSecondChild();\n+      if (secondArg == null) {\n+        // A delay time should always be specified for the setTimeout and\n+        // setInterval functions, so not passing \"this\" is not dangerous.\n+        return;\n+      }\n+      JSDocInfo jsDoc = getFunctionJsDocInfo(secondArg);\n+      if (jsDoc != null && jsDoc.hasThisType()) {\n+        // A type is specified for the second argument, which indicates that the\n+        // function passed is a method of an object. Since \"this\" is specified,\n+        // it's possible that it's being used by the function and not dangerous.\n+        return;\n+      }\n+      if (secondArg.matchesQualifiedName(\"this\")) {\n+        dangerousFunctionCallback.accept(call);\n+      }\n+    }\n+\n+    private ControlFlowGraph<Node> getCfg(Node root) {\n+      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+      cfa.process(null, root);\n+      DiGraph<Node, Branch> graph = cfa.getCfg().toDiGraph();\n+      return new ControlFlowGraph<>(graph);\n+    }\n+    \n+    // Returns any JSDocInfo associated with a function node.\n+    private JSDocInfo getFunctionJsDocInfo(Node node) {\n+      return NodeUtil.getBestJSDocInfo(node);\n+    }\n \n   public void visit(NodeTraversal t, Node n, Node parent) {\n     if (n.getType() == Token.THIS && shouldReportThis(n, parent)) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}