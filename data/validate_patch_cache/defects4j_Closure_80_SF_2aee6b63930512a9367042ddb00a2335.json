{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.CodingConvention.IdentifierCodingConvention;\n\nimport java.util.BitSet;\nimport java.util.HashSet;\nimport java.util.Set;\nimport java.util.function.Predicate;\n\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nclass Main {\n\n  static final class Var {\n    final String name;\n    final Node value;\n\n    Var(String name, Node value) {\n      this.name = name;\n      this.value = value;\n    }\n\n    @Override\n    public String toString() {\n      return \"Var [name=\" + name + \", value=\" + value + \"]\";\n    }\n  }\n\n  static class ControlFlowGraph {\n    private DiGraph<Node, DiGraphEdge<Node, Branch>> mDiagram;\n\n    ControlFlowGraph(DiGraph<Node, DiGraphEdge<Node, Branch>> diagram) {\n      mDiagram = diagram;\n    }\n\n    public DiGraph<Node, DiGraphEdge<Node, Branch>> getGraph() {\n      return mDiagram;\n    }\n\n    public List<DiGraphEdge<Node, Branch>> getOutEdges(Node node) {\n      return mDiagram.getOutEdges(node);\n    }\n  }\n\n  static class BasicBlock {\n    List<Node> mNodes = new ArrayList<>();\n    BasicBlock mNext = null;\n\n    @Override\n    public String toString() {\n      return \"BB:\" + mNodes.toString();\n    }\n  }\n\n  static class DiGraphEdge<V, E> {\n    private V mFrom;\n    private V mTo;\n    private E mValue;\n\n    DiGraphEdge(V from, V to, E value) {\n      mFrom = from;\n      mTo = to;\n      mValue = value;\n    }\n\n    public V getFrom() {\n      return mFrom;\n    }\n\n    public V getTo() {\n      return mTo;\n    }\n\n    public E getValue() {\n      return mValue;\n    }\n  }\n\n  static class DiGraph<V, E> {\n    private Map<V, List<DiGraphEdge<V, E>>> mOutEdges;\n    private Map<V, List<DiGraphEdge<V, E>>> mInEdges;\n\n    public DiGraph() {\n      mOutEdges = new LinkedHashMap<>();\n      mInEdges = new LinkedHashMap<>();\n    }\n\n    private List<DiGraphEdge<V, E>> getOutEdges(V node) {\n      return mOutEdges.getOrDefault(node, Collections.emptyList());\n    }\n\n    private void addEdge(V from, V to, E value) {\n      DiGraphEdge<V, E> edge = new DiGraphEdge<>(from, to, value);\n\n      // add the new edge to the forward and reverse maps\n      mOutEdges.computeIfAbsent(from, k -> new ArrayList<>()).add(edge);\n      mInEdges.computeIfAbsent(to, k -> new ArrayList<>()).add(edge);\n    }\n\n    /**\n     * Performs a depth-first traverse on the graph starting at the specified node. The given\n     * visitor will be called with each node in DFS order.\n     */\n    void visitDepthFirst(V node, DiGraphNodeVisitor<V, E> visitor) {\n      BitSet visited = new BitSet();\n\n      visitDepthFirstHelper(node, visited, visitor);\n    }\n\n    /**\n     * Helper method for {@link #visitDepthFirst(Object, DiGraphNodeVisitor)}.\n     */\n    private void visitDepthFirstHelper(V node, BitSet visited, DiGraphNodeVisitor<V, E> visitor) {\n      // mark the current node as visited and apply the visitor\n      visited.set(getNodeId(node));\n      visitor.visit(node);\n\n      // visit each neighbor that hasn't been visited before\n      for (DiGraphEdge<V, E> child : getOutEdges(node)) {\n        if (!visited.get(getNodeId(child.getTo()))) {\n          visitDepthFirstHelper(child.getTo(), visited, visitor);\n        }\n      }\n    }\n\n    /**\n     * Calculates the set of nodes that participate in one or more cycles in this graph.\n     */\n    Set<V> getCycleNodes() {\n      Set<V> ret = new HashSet<>();\n\n      // Visit all nodes, looking for cycles.\n      for (V root : mOutEdges.keySet()) {\n        // apply a DFS from this node until we find a cycle.\n        BitSet visited = new BitSet();\n        LinkedList<V> path = new LinkedList<>();\n        path.add(root);\n        visited.set(getNodeId(root));\n\n        findCycles(root, visited, path, ret);\n      }\n\n      return ret;\n    }\n\n    /**\n     * Helper function for getCycleNodes().\n     *\n     * @param cycleNodes The accumulator \"set\" of nodes participating in cycles.\n     */\n    private void findCycles(\n        V node, BitSet visited, LinkedList<V> path, Set<V> cycleNodes) {\n      for (DiGraphEdge<V, E> child : getOutEdges(node)) {\n        if (cycleNodes.contains(child.getTo())) {\n          // We've already detected this node as being part of a cycle. Ignore it.\n        } else {\n          if (visited.get(getNodeId(child.getTo()))) {\n            // We've already visited this node, which means we've found a cycle.\n            // Collect the cycle nodes.\n            int idx = 0;\n            for (V n : path) {\n              if (n.equals(child.getTo())) {\n                cycleNodes.addAll(path.subList(idx, path.size()));\n                break;\n              }\n              idx++;\n            }\n          } else {\n            // haven't visited this node yet\n            visited.set(getNodeId(child.getTo()));\n            path.add(child.getTo());\n            findCycles(child.getTo(), visited, path, cycleNodes);\n            path.removeLast();\n          }\n        }\n      }\n    }\n\n    /**\n     * Returns the number of nodes in the graph.\n     */\n    int getNodeCount() {\n      return mOutEdges.keySet().size();\n    }\n\n    /**\n     * Returns the position of a node within the list of all nodes, or -1 if the node is not in the\n     * graph.\n     */\n    private int getNodeId(V node) {\n      List<V> nodeList = new ArrayList<>(mOutEdges.keySet());\n      return nodeList.indexOf(node);\n    }\n\n    /**\n     * Returns a \"copy\" of this graph, but with the outgoing edges reversed.\n     *\n     * That is, returns a new graph such that for each edge U --> V in the original, there is an edge\n     * V --> U in the returned graph.\n     */\n    DiGraph<V, E> reverse() {\n      DiGraph<V, E> reversed = new DiGraph<>();\n\n      for (Entry<V, List<DiGraphEdge<V, E>>> entry : mOutEdges.entrySet()) {\n        V from = entry.getKey();\n        List<DiGraphEdge<V, E>> edges = entry.getValue();\n\n        for (DiGraphEdge<V, E> edge : edges) {\n          V to = edge.getTo();\n          E value = edge.getValue();\n\n          reversed.addEdge(to, from, value);\n        }\n      }\n\n      return reversed;\n    }\n  }\n\n  static interface DiGraphNodeVisitor<V, E> {\n    void visit(V node);\n  }\n\n  static class Break extends RuntimeException {\n    static final Break instance = new Break();\n\n    private Break() {}\n  }\n\n  static class Branch {\n    static enum BranchType {\n      SWITCH(\"SWITCH\"),\n      CASE(\"CASE\"),\n      DEFAULT(\"DEFAULT\"),\n      IF(\"IF\"),\n      COND(\"COND\"),\n      FOR(\"FOR\"),\n      WHILE(\"WHILE\"),\n      DO(\"DO\"),\n      AND(\"AND\"),\n      OR(\"OR\"),\n      HOOK(\"HOOK\"),\n      NULL(null);\n\n      private String mName;\n\n      private BranchType(String name) {\n        mName = name;\n      }\n\n      @Override\n      public String toString() {\n        return mName;\n      }\n    }\n\n    final BranchType mType;\n    final Set<Node> mTargetNodes;\n\n    Branch(BranchType type, Set<Node> targetNodes) {\n      mType = type;\n      mTargetNodes = targetNodes;\n    }\n\n    @Override\n    public String toString() {\n      StringBuilder builder = new StringBuilder();\n\n      builder.append(mType);\n      builder.append(\": \");\n\n      Iterator<Node> it = mTargetNodes.iterator();\n      while (it.hasNext()) {\n        builder.append(it.next().getLineno());\n        if (it.hasNext()) {\n          builder.append(\", \");\n        }\n      }\n\n      return builder.toString();\n    }\n\n    public Node getFirstTarget() {\n      return mTargetNodes.iterator().next();\n    }\n  }\n\n  static class ControlFlowAnalysis {\n    private final ControlFlowGraph mGraph;\n\n    ControlFlowAnalysis(ControlFlowGraph graph) {\n      mGraph = graph;\n    }\n\n    /**\n     * Visits every path in the CFG; calls relevant hooks for each node, and collects their return to\n     * supply as input to the next node.\n     *\n     * @param startNodes The set of nodes to start visiting from.\n     * @param initialEnv The initial input \"environment\".\n     * @return A merged \"environment\" after all paths have been visited.\n     */\n    <T> T traverse(Set<Node> startNodes, T initialEnv, NodeVisitor visitor) {\n      Map<Node, Branch> branches = calculateBranches(startNodes, mGraph.getGraph());\n\n      try {\n        doTraverse(branches.keySet(),\n                   initialEnv,\n                   branches,\n                   new HashSet<Integer>(),\n                   new HashSet<Integer>(),\n                   visitor);\n      } catch (Break b) {\n        // We use an exception for early termination. This is much faster than other options.\n      }\n\n      return visitor.getResult();\n    }\n\n    /**\n     * Helper method for traverse().\n     */\n    private <T> void doTraverse(\n        Set<Node> nodes,\n        T env,\n        Map<Node, Branch> valueOfBranches,\n        Set<Integer> visitedNormal,\n        Set<Integer> visitedExceptional,\n        NodeVisitor<T> visitor) {\n      Iterator<Node> it = nodes.iterator();\n\n      if (!it.hasNext()) {\n        // empty list: visiting a continue or break in an empty block.\n        visitor.visit(null, env);\n        return;\n      }\n\n      Node firstNode = it.next();\n\n      switch (firstNode.getType()) {\n        case Token.BLOCK:\n        case Token.SCRIPT:\n          // For simplicity we treat both BLOCKs and SCRIPTs as blocks.\n          doTraverse(NodeUtil.getFunctionBody(firstNode).removeChildren(),\n                     env,\n                     valueOfBranches,\n                     visitedNormal,\n                     visitedExceptional,\n                     visitor);\n          break;\n\n        case Token.FOR:\n        case Token.WHILE:\n        case Token.DOWHILE:\n          while (true) {\n            visitor.visit(firstNode, env);\n            Set<Node> nodesToVisit = new HashSet<>();\n            Branch branc",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 08fb954f..59545fff 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1238,71 +1238,365 @@ public final class NodeUtil {\n   static boolean isBooleanResult(Node n) {\n     return valueCheck(n, BOOLEAN_RESULT_PREDICATE);\n   }\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.CodingConvention.IdentifierCodingConvention;\n \n-  static boolean isBooleanResultHelper(Node n) {\n-    switch (n.getType()) {\n-      // Primitives\n-      case Token.TRUE:\n-      case Token.FALSE:\n-      // Comparisons\n-      case Token.EQ:\n-      case Token.NE:\n-      case Token.SHEQ:\n-      case Token.SHNE:\n-      case Token.LT:\n-      case Token.GT:\n-      case Token.LE:\n-      case Token.GE:\n-      // Queryies\n-      case Token.IN:\n-      case Token.INSTANCEOF:\n-      // Inversion\n-      case Token.NOT:\n-      // delete operator returns a boolean.\n-        return true;\n-      default:\n-        return false;\n+import java.util.BitSet;\n+import java.util.HashSet;\n+import java.util.Set;\n+import java.util.function.Predicate;\n+\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+class Main {\n+\n+  static final class Var {\n+    final String name;\n+    final Node value;\n+\n+    Var(String name, Node value) {\n+      this.name = name;\n+      this.value = value;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      return \"Var [name=\" + name + \", value=\" + value + \"]\";\n     }\n   }\n \n-  static boolean isUndefined(Node n) {\n-    switch (n.getType()) {\n-      case Token.VOID:\n-        return true;\n-      case Token.NAME:\n-        return n.getString().equals(\"undefined\");\n+  static class ControlFlowGraph {\n+    private DiGraph<Node, DiGraphEdge<Node, Branch>> mDiagram;\n+\n+    ControlFlowGraph(DiGraph<Node, DiGraphEdge<Node, Branch>> diagram) {\n+      mDiagram = diagram;\n+    }\n+\n+    public DiGraph<Node, DiGraphEdge<Node, Branch>> getGraph() {\n+      return mDiagram;\n+    }\n+\n+    public List<DiGraphEdge<Node, Branch>> getOutEdges(Node node) {\n+      return mDiagram.getOutEdges(node);\n     }\n-    return false;\n   }\n \n-  static boolean isNull(Node n) {\n-    return n.getType() == Token.NULL;\n+  static class BasicBlock {\n+    List<Node> mNodes = new ArrayList<>();\n+    BasicBlock mNext = null;\n+\n+    @Override\n+    public String toString() {\n+      return \"BB:\" + mNodes.toString();\n+    }\n   }\n \n-  static boolean isNullOrUndefined(Node n) {\n-    return isNull(n) || isUndefined(n);\n+  static class DiGraphEdge<V, E> {\n+    private V mFrom;\n+    private V mTo;\n+    private E mValue;\n+\n+    DiGraphEdge(V from, V to, E value) {\n+      mFrom = from;\n+      mTo = to;\n+      mValue = value;\n+    }\n+\n+    public V getFrom() {\n+      return mFrom;\n+    }\n+\n+    public V getTo() {\n+      return mTo;\n+    }\n+\n+    public E getValue() {\n+      return mValue;\n+    }\n   }\n \n-  static class MayBeStringResultPredicate implements Predicate<Node> {\n-    public boolean apply(Node n) {\n-      return mayBeStringHelper(n);\n+  static class DiGraph<V, E> {\n+    private Map<V, List<DiGraphEdge<V, E>>> mOutEdges;\n+    private Map<V, List<DiGraphEdge<V, E>>> mInEdges;\n+\n+    public DiGraph() {\n+      mOutEdges = new LinkedHashMap<>();\n+      mInEdges = new LinkedHashMap<>();\n+    }\n+\n+    private List<DiGraphEdge<V, E>> getOutEdges(V node) {\n+      return mOutEdges.getOrDefault(node, Collections.emptyList());\n+    }\n+\n+    private void addEdge(V from, V to, E value) {\n+      DiGraphEdge<V, E> edge = new DiGraphEdge<>(from, to, value);\n+\n+      // add the new edge to the forward and reverse maps\n+      mOutEdges.computeIfAbsent(from, k -> new ArrayList<>()).add(edge);\n+      mInEdges.computeIfAbsent(to, k -> new ArrayList<>()).add(edge);\n+    }\n+\n+    /**\n+     * Performs a depth-first traverse on the graph starting at the specified node. The given\n+     * visitor will be called with each node in DFS order.\n+     */\n+    void visitDepthFirst(V node, DiGraphNodeVisitor<V, E> visitor) {\n+      BitSet visited = new BitSet();\n+\n+      visitDepthFirstHelper(node, visited, visitor);\n     }\n+\n+    /**\n+     * Helper method for {@link #visitDepthFirst(Object, DiGraphNodeVisitor)}.\n+     */\n+    private void visitDepthFirstHelper(V node, BitSet visited, DiGraphNodeVisitor<V, E> visitor) {\n+      // mark the current node as visited and apply the visitor\n+      visited.set(getNodeId(node));\n+      visitor.visit(node);\n+\n+      // visit each neighbor that hasn't been visited before\n+      for (DiGraphEdge<V, E> child : getOutEdges(node)) {\n+        if (!visited.get(getNodeId(child.getTo()))) {\n+          visitDepthFirstHelper(child.getTo(), visited, visitor);\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Calculates the set of nodes that participate in one or more cycles in this graph.\n+     */\n+    Set<V> getCycleNodes() {\n+      Set<V> ret = new HashSet<>();\n+\n+      // Visit all nodes, looking for cycles.\n+      for (V root : mOutEdges.keySet()) {\n+        // apply a DFS from this node until we find a cycle.\n+        BitSet visited = new BitSet();\n+        LinkedList<V> path = new LinkedList<>();\n+        path.add(root);\n+        visited.set(getNodeId(root));\n+\n+        findCycles(root, visited, path, ret);\n+      }\n+\n+      return ret;\n+    }\n+\n+    /**\n+     * Helper function for getCycleNodes().\n+     *\n+     * @param cycleNodes The accumulator \"set\" of nodes participating in cycles.\n+     */\n+    private void findCycles(\n+        V node, BitSet visited, LinkedList<V> path, Set<V> cycleNodes) {\n+      for (DiGraphEdge<V, E> child : getOutEdges(node)) {\n+        if (cycleNodes.contains(child.getTo())) {\n+          // We've already detected this node as being part of a cycle. Ignore it.\n+        } else {\n+          if (visited.get(getNodeId(child.getTo()))) {\n+            // We've already visited this node, which means we've found a cycle.\n+            // Collect the cycle nodes.\n+            int idx = 0;\n+            for (V n : path) {\n+              if (n.equals(child.getTo())) {\n+                cycleNodes.addAll(path.subList(idx, path.size()));\n+                break;\n+              }\n+              idx++;\n+            }\n+          } else {\n+            // haven't visited this node yet\n+            visited.set(getNodeId(child.getTo()));\n+            path.add(child.getTo());\n+            findCycles(child.getTo(), visited, path, cycleNodes);\n+            path.removeLast();\n+          }\n+        }\n+      }\n+    }\n+\n+    /**\n+     * Returns the number of nodes in the graph.\n+     */\n+    int getNodeCount() {\n+      return mOutEdges.keySet().size();\n+    }\n+\n+    /**\n+     * Returns the position of a node within the list of all nodes, or -1 if the node is not in the\n+     * graph.\n+     */\n+    private int getNodeId(V node) {\n+      List<V> nodeList = new ArrayList<>(mOutEdges.keySet());\n+      return nodeList.indexOf(node);\n+    }\n+\n+    /**\n+     * Returns a \"copy\" of this graph, but with the outgoing edges reversed.\n+     *\n+     * That is, returns a new graph such that for each edge U --> V in the original, there is an edge\n+     * V --> U in the returned graph.\n+     */\n+    DiGraph<V, E> reverse() {\n+      DiGraph<V, E> reversed = new DiGraph<>();\n+\n+      for (Entry<V, List<DiGraphEdge<V, E>>> entry : mOutEdges.entrySet()) {\n+        V from = entry.getKey();\n+        List<DiGraphEdge<V, E>> edges = entry.getValue();\n+\n+        for (DiGraphEdge<V, E> edge : edges) {\n+          V to = edge.getTo();\n+          E value = edge.getValue();\n+\n+          reversed.addEdge(to, from, value);\n+        }\n+      }\n+\n+      return reversed;\n+    }\n+  }\n+\n+  static interface DiGraphNodeVisitor<V, E> {\n+    void visit(V node);\n   }\n \n-  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n-      new MayBeStringResultPredicate();\n+  static class Break extends RuntimeException {\n+    static final Break instance = new Break();\n \n-  /**\n-   * @returns Whether the results is possibly a string.\n-   */\n-  static boolean mayBeString(Node n) {\n-    return mayBeString(n, true);\n+    private Break() {}\n   }\n \n-  static boolean mayBeString(Node n, boolean recurse) {\n-    if (recurse) {\n-      return valueCheck(n, MAY_BE_STRING_PREDICATE);\n-    } else {\n+  static class Branch {\n+    static enum BranchType {\n+      SWITCH(\"SWITCH\"),\n+      CASE(\"CASE\"),\n+      DEFAULT(\"DEFAULT\"),\n+      IF(\"IF\"),\n+      COND(\"COND\"),\n+      FOR(\"FOR\"),\n+      WHILE(\"WHILE\"),\n+      DO(\"DO\"),\n+      AND(\"AND\"),\n+      OR(\"OR\"),\n+      HOOK(\"HOOK\"),\n+      NULL(null);\n+\n+      private String mName;\n+\n+      private BranchType(String name) {\n+        mName = name;\n+      }\n+\n+      @Override\n+      public String toString() {\n+        return mName;\n+      }\n+    }\n+\n+    final BranchType mType;\n+    final Set<Node> mTargetNodes;\n+\n+    Branch(BranchType type, Set<Node> targetNodes) {\n+      mType = type;\n+      mTargetNodes = targetNodes;\n+    }\n+\n+    @Override\n+    public String toString() {\n+      StringBuilder builder = new StringBuilder();\n+\n+      builder.append(mType);\n+      builder.append(\": \");\n+\n+      Iterator<Node> it = mTargetNodes.iterator();\n+      while (it.hasNext()) {\n+        builder.append(it.next().getLineno());\n+        if (it.hasNext()) {\n+          builder.append(\", \");\n+        }\n+      }\n+\n+      return builder.toString();\n+    }\n+\n+    public Node getFirstTarget() {\n+      return mTargetNodes.iterator().next();\n+    }\n+  }\n+\n+  static class ControlFlowAnalysis {\n+    private final ControlFlowGraph mGraph;\n+\n+    ControlFlowAnalysis(ControlFlowGraph graph) {\n+      mGraph = graph;\n+    }\n+\n+    /**\n+     * Visits every path in the CFG; calls relevant hooks for each node, and collects their return to\n+     * supply as input to the next node.\n+     *\n+     * @param startNodes The set of nodes to start visiting from.\n+     * @param initialEnv The initial input \"environment\".\n+     * @return A merged \"environment\" after all paths have been visited.\n+     */\n+    <T> T traverse(Set<Node> startNodes, T initialEnv, NodeVisitor visitor) {\n+      Map<Node, Branch> branches = calculateBranches(startNodes, mGraph.getGraph());\n+\n+      try {\n+        doTraverse(branches.keySet(),\n+                   initialEnv,\n+                   branches,\n+                   new HashSet<Integer>(),\n+                   new HashSet<Integer>(),\n+                   visitor);\n+      } catch (Break b) {\n+        // We use an exception for early termination. This is much faster than other options.\n+      }\n+\n+      return visitor.getResult();\n+    }\n+\n+    /**\n+     * Helper method for traverse().\n+     */\n+    private <T> void doTraverse(\n+        Set<Node> nodes,\n+        T env,\n+        Map<Node, Branch> valueOfBranches,\n+        Set<Integer> visitedNormal,\n+        Set<Integer> visitedExceptional,\n+        NodeVisitor<T> visitor) {\n+      Iterator<Node> it = nodes.iterator();\n+\n+      if (!it.hasNext()) {\n+        // empty list: visiting a continue or break in an empty block.\n+        visitor.visit(null, env);\n+        return;\n+      }\n+\n+      Node firstNode = it.next();\n+\n+      switch (firstNode.getType()) {\n+        case Token.BLOCK:\n+        case Token.SCRIPT:\n+          // For simplicity we treat both BLOCKs and SCRIPTs as blocks.\n+          doTraverse(NodeUtil.getFunctionBody(firstNode).removeChildren(),\n+                     env,\n+                     valueOfBranches,\n+                     visitedNormal,\n+                     visitedExceptional,\n+                     visitor);\n+          break;\n+\n+        case Token.FOR:\n+        case Token.WHILE:\n+        case Token.DOWHILE:\n+          while (true) {\n+            visitor.visit(firstNode, env);\n+            Set<Node> nodesToVisit = new HashSet<>();\n+            Branch branc\n       return mayBeStringHelper(n);\n     }\n   }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}