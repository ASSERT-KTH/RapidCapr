{
    "patch": "public static double pow(double x, double y) {\n        final double lns[] = new double[2];\n\n        if (y == 0.0) {\n            return 1.0;\n        }\n\n        if (x != x) { // X is NaN\n            return x;\n        }\n\n\n        if (x == 0) {\n            long bits = Double.doubleToLongBits(x);\n            if ((bits & 0x8000000000000000L) != 0) {\n                // -zero\n                long yi = (long) y;\n\n                if (y < 0 && y == yi && (yi & 1) == 1) {\n                    return Double.NEGATIVE_INFINITY;\n                }\n\n                if (y > 0 && y == yi && (yi & 1) == 1) {\n                    return -0.0;\n                }\n            }\n\n            if (y < 0) {\n                return Double.POSITIVE_INFINITY;\n            }\n          ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex d57132592..bec35dfd9 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -305,165 +305,37 @@ public class FastMath {\n     private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n \n     /** Mask used to clear low order 30 bits */\n-    private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;\n-\n-    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n-    private static final double TWO_POWER_52 = 4503599627370496.0;\n-    /** 2^53 - double numbers this large must be even. */\n-\n-    /** Constant: {@value}. */\n-    private static final double F_1_3 = 1d / 3d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_5 = 1d / 5d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_7 = 1d / 7d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_9 = 1d / 9d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_11 = 1d / 11d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_13 = 1d / 13d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_15 = 1d / 15d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_17 = 1d / 17d;\n-    /** Constant: {@value}. */\n-    private static final double F_3_4 = 3d / 4d;\n-    /** Constant: {@value}. */\n-    private static final double F_15_16 = 15d / 16d;\n-    /** Constant: {@value}. */\n-    private static final double F_13_14 = 13d / 14d;\n-    /** Constant: {@value}. */\n-    private static final double F_11_12 = 11d / 12d;\n-    /** Constant: {@value}. */\n-    private static final double F_9_10 = 9d / 10d;\n-    /** Constant: {@value}. */\n-    private static final double F_7_8 = 7d / 8d;\n-    /** Constant: {@value}. */\n-    private static final double F_5_6 = 5d / 6d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_2 = 1d / 2d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_4 = 1d / 4d;\n-\n-    /**\n-     * Private Constructor\n-     */\n-    private FastMath() {}\n-\n-    // Generic helper methods\n+public static double pow(double x, double y) {\n+        final double lns[] = new double[2];\n \n-    /**\n-     * Get the high order bits from the mantissa.\n-     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n-     *\n-     * @param d the value to split\n-     * @return the high order part of the mantissa\n-     */\n-    private static double doubleHighPart(double d) {\n-        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n-            return d; // These are un-normalised - don't try to convert\n+        if (y == 0.0) {\n+            return 1.0;\n         }\n-        long xl = Double.doubleToLongBits(d);\n-        xl = xl & MASK_30BITS; // Drop low order bits\n-        return Double.longBitsToDouble(xl);\n-    }\n-\n-    /** Compute the square root of a number.\n-     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n-     * @param a number on which evaluation is done\n-     * @return square root of a\n-     */\n-    public static double sqrt(final double a) {\n-        return Math.sqrt(a);\n-    }\n \n-    /** Compute the hyperbolic cosine of a number.\n-     * @param x number on which evaluation is done\n-     * @return hyperbolic cosine of x\n-     */\n-    public static double cosh(double x) {\n-      if (x != x) {\n-          return x;\n-      }\n-\n-      // cosh[z] = (exp(z) + exp(-z))/2\n-\n-      // for numbers with magnitude 20 or so,\n-      // exp(-z) can be ignored in comparison with exp(z)\n-\n-      if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n-              // Avoid overflow (MATH-905).\n-              final double t = exp(0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n-              return 0.5 * exp(x);\n-          }\n-      } else if (x < -20) {\n-          if (x <= -LOG_MAX_VALUE) {\n-              // Avoid overflow (MATH-905).\n-              final double t = exp(-0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n-              return 0.5 * exp(-x);\n-          }\n-      }\n+        if (x != x) { // X is NaN\n+            return x;\n+        }\n \n-      final double hiPrec[] = new double[2];\n-      if (x < 0.0) {\n-          x = -x;\n-      }\n-      exp(x, 0.0, hiPrec);\n-\n-      double ya = hiPrec[0] + hiPrec[1];\n-      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n-\n-      double temp = ya * HEX_40000000;\n-      double yaa = ya + temp - temp;\n-      double yab = ya - yaa;\n-\n-      // recip = 1/y\n-      double recip = 1.0/ya;\n-      temp = recip * HEX_40000000;\n-      double recipa = recip + temp - temp;\n-      double recipb = recip - recipa;\n-\n-      // Correct for rounding in division\n-      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n-      // Account for yb\n-      recipb += -yb * recip * recip;\n-\n-      // y = y + 1/y\n-      temp = ya + recipa;\n-      yb += -(temp - ya - recipa);\n-      ya = temp;\n-      temp = ya + recipb;\n-      yb += -(temp - ya - recipb);\n-      ya = temp;\n-\n-      double result = ya + yb;\n-      result *= 0.5;\n-      return result;\n-    }\n \n-    /** Compute the hyperbolic sine of a number.\n-     * @param x number on which evaluation is done\n-     * @return hyperbolic sine of x\n-     */\n-    public static double sinh(double x) {\n-      boolean negate = false;\n-      if (x != x) {\n-          return x;\n-      }\n+        if (x == 0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if ((bits & 0x8000000000000000L) != 0) {\n+                // -zero\n+                long yi = (long) y;\n \n-      // sinh[z] = (exp(z) - exp(-z) / 2\n+                if (y < 0 && y == yi && (yi & 1) == 1) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n \n-      // for values of z larger than about 20,\n-      // exp(-z) can be ignored in comparison with exp(z)\n+                if (y > 0 && y == yi && (yi & 1) == 1) {\n+                    return -0.0;\n+                }\n+            }\n \n-      if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n+            if (y < 0) {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+          \n               // Avoid overflow (MATH-905).\n               final double t = exp(0.5 * x);\n               return (0.5 * t) * t;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}