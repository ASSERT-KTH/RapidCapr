{
    "patch": "public Dfp regularizedGammaP(final Dfp a, final Dfp x) {\n    if (a.sign == -1) {\n        return newInstance(Double.NaN);\n    }\n    if (x.sign == -1) {\n        return newInstance(Double.NaN);\n    }\n    if (x.isZero()) {\n        return newInstance(0.0);\n    }\n    final int c = 0;\n    final Dfp small = newInstance(10, getPrecision());\n    Dfp w = newInstance(x);\n    Dfp p = newInstance(1.0);\n    final Dfp g = newInstance(1.0);\n    while (Double.isInfinite(g.toDouble())) {\n        w = w.divide(small);\n        c++;\n        g.copy(x).add(a.negate()).exp();\n        p.add(g.divide(small.pow(c)));\n    }\n    p.multiply(w.pow(a)).divide(a);\n    final Dfp p0 = newInstance(0.0);\n    final Dfp g0 = newInstance(0.0);\n    final Dfp a0 = newInstance(1.0);\n    final Dfp t0 = a0.divide(p0);\n    final Dfp t1 = newInstance();\n    final Dfp g1 = newInstance(0.0);\n    final Dfp p1 = newInstance(1.0);\n    final Dfp a1 = newInstance(0.0);\n    final Dfp t = newInstance();\n    final Dfp delta = newInstance();\n    final Dfp max = newInstance(0.0);\n    t0.subtract(t1, delta);\n    for (int n = 1; n <= getMaxIteration(); ++n) {\n        a1.copy(a0.add(B2.multiply(n - 1).add(B1).multiply(delta).divide(2 * n)));\n        p1.copy(p0.add(gammaMinus1.multiply(a1.subtract(a0))));\n        g1.copy(newInstance(1.0)).exp(a1.multiply(log(x)).negate()).multiply(p1);\n        t.copy(t1);\n        t1.copy(t0);\n        t0.copy(t);\n        t.divide(g1);\n        delta.copy(t);\n        delta.subtract(t0);\n        max.copy(t.abs().max(t1.abs()).multiply(getRelativeAccuracy()));\n        if (delta.abs().lessThan(max)) {\n            return dotrap(Dfp.TRAP_OVERFLOW, \"regularizedGammaP\", a, x, a0.divide(p0));\n        }\n        a0.copy(a1);\n        p0.copy(p1);\n    }\n    return dotrap(Dfp.TRAP_OVERFLOW, \"regularizedGammaP\", a, x, a0.divide(p0));\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..dcdd9e140 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,59 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public Dfp regularizedGammaP(final Dfp a, final Dfp x) {\n+    if (a.sign == -1) {\n+        return newInstance(Double.NaN);\n+    }\n+    if (x.sign == -1) {\n+        return newInstance(Double.NaN);\n+    }\n+    if (x.isZero()) {\n+        return newInstance(0.0);\n+    }\n+    final int c = 0;\n+    final Dfp small = newInstance(10, getPrecision());\n+    Dfp w = newInstance(x);\n+    Dfp p = newInstance(1.0);\n+    final Dfp g = newInstance(1.0);\n+    while (Double.isInfinite(g.toDouble())) {\n+        w = w.divide(small);\n+        c++;\n+        g.copy(x).add(a.negate()).exp();\n+        p.add(g.divide(small.pow(c)));\n+    }\n+    p.multiply(w.pow(a)).divide(a);\n+    final Dfp p0 = newInstance(0.0);\n+    final Dfp g0 = newInstance(0.0);\n+    final Dfp a0 = newInstance(1.0);\n+    final Dfp t0 = a0.divide(p0);\n+    final Dfp t1 = newInstance();\n+    final Dfp g1 = newInstance(0.0);\n+    final Dfp p1 = newInstance(1.0);\n+    final Dfp a1 = newInstance(0.0);\n+    final Dfp t = newInstance();\n+    final Dfp delta = newInstance();\n+    final Dfp max = newInstance(0.0);\n+    t0.subtract(t1, delta);\n+    for (int n = 1; n <= getMaxIteration(); ++n) {\n+        a1.copy(a0.add(B2.multiply(n - 1).add(B1).multiply(delta).divide(2 * n)));\n+        p1.copy(p0.add(gammaMinus1.multiply(a1.subtract(a0))));\n+        g1.copy(newInstance(1.0)).exp(a1.multiply(log(x)).negate()).multiply(p1);\n+        t.copy(t1);\n+        t1.copy(t0);\n+        t0.copy(t);\n+        t.divide(g1);\n+        delta.copy(t);\n+        delta.subtract(t0);\n+        max.copy(t.abs().max(t1.abs()).multiply(getRelativeAccuracy()));\n+        if (delta.abs().lessThan(max)) {\n+            return dotrap(Dfp.TRAP_OVERFLOW, \"regularizedGammaP\", a, x, a0.divide(p0));\n+        }\n+        a0.copy(a1);\n+        p0.copy(p1);\n+    }\n+    return dotrap(Dfp.TRAP_OVERFLOW, \"regularizedGammaP\", a, x, a0.divide(p0));\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}