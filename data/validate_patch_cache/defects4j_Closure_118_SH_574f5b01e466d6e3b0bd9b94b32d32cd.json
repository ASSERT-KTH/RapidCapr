{
    "patch": "        JSTypeUnion propertyType = JSTypeUnion.NULL;\n        JSType stringType =\n            getNativeType(JSTypeNative.STRING_TYPE) != null\n                ? getNativeType(JSTypeNative.STRING_TYPE).getReference()\n                : getNativeType(JSTypeNative.UNKNOWN_TYPE).getReference();\n\n        if (!child.isString()) {\n          // If propName is not a string literal, it must be something like a GETELEM,\n          // GETPROP, or ASSIGN to a dotted name.\n          Node stringNode = IR.string(\"\").setJSType(stringType);\n          new Node(Token.ASSIGN, stringNode, child.detach())\n              .setJSType(stringType)\n              .copyInformationFrom(child);\n\n          child.replaceWith(stringNode);\n          child = stringNode;\n        }\n\n        String name = child.getString();\n        Property prop = getProperty(name);\n        if (compiler.hasTypeCheckingRun() && typeSystem.isPropertyTypeDeclared(prop.getName())) {\n          propertyType = typeSystem.getDeclaredPropertyType(prop.getName());\n        } else {\n          T type = typeSystem.getType(getScope(), n, name);\n          if (type != null) {\n            if (type.isConstructor()) {\n              // Don't call getTypeOfThis() for constructors because it could return\n              // the constructor function itself.\n              propertyType =\n                  type.toMaybeFunctionType().getInstanceType().getUnionWith(JSType.NULL);\n            } else if (type.isEnumType()) {\n              propertyType =\n                  getNativeType(JSTypeNative.NUMBER_TYPE).getReference()\n                      .getUnionWith(JSType.NULL);\n            } else {\n              propertyType = type.getTypeOfThis().getUnionWith(JSType.NULL);\n            }\n          }\n        }\n\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, propertyType, null))) {\n          // TODO(b/26866213): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name, propertyType.toString(), n.toString(), \"\"));\n          }\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex b34921ed..61697b57 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -492,6 +492,56 @@ class DisambiguateProperties<T> implements CompilerPass {\n           child != null;\n           child = child.getNext()) {\n         // Maybe STRING, GET, SET\n+        JSTypeUnion propertyType = JSTypeUnion.NULL;\n+        JSType stringType =\n+            getNativeType(JSTypeNative.STRING_TYPE) != null\n+                ? getNativeType(JSTypeNative.STRING_TYPE).getReference()\n+                : getNativeType(JSTypeNative.UNKNOWN_TYPE).getReference();\n+\n+        if (!child.isString()) {\n+          // If propName is not a string literal, it must be something like a GETELEM,\n+          // GETPROP, or ASSIGN to a dotted name.\n+          Node stringNode = IR.string(\"\").setJSType(stringType);\n+          new Node(Token.ASSIGN, stringNode, child.detach())\n+              .setJSType(stringType)\n+              .copyInformationFrom(child);\n+\n+          child.replaceWith(stringNode);\n+          child = stringNode;\n+        }\n+\n+        String name = child.getString();\n+        Property prop = getProperty(name);\n+        if (compiler.hasTypeCheckingRun() && typeSystem.isPropertyTypeDeclared(prop.getName())) {\n+          propertyType = typeSystem.getDeclaredPropertyType(prop.getName());\n+        } else {\n+          T type = typeSystem.getType(getScope(), n, name);\n+          if (type != null) {\n+            if (type.isConstructor()) {\n+              // Don't call getTypeOfThis() for constructors because it could return\n+              // the constructor function itself.\n+              propertyType =\n+                  type.toMaybeFunctionType().getInstanceType().getUnionWith(JSType.NULL);\n+            } else if (type.isEnumType()) {\n+              propertyType =\n+                  getNativeType(JSTypeNative.NUMBER_TYPE).getReference()\n+                      .getUnionWith(JSType.NULL);\n+            } else {\n+              propertyType = type.getTypeOfThis().getUnionWith(JSType.NULL);\n+            }\n+          }\n+        }\n+\n+        if (!prop.scheduleRenaming(child,\n+                                   processProperty(t, prop, propertyType, null))) {\n+          // TODO(b/26866213): It doesn't look like the user can do much in this\n+          // case right now.\n+          if (propertiesToErrorFor.containsKey(name)) {\n+            compiler.report(JSError.make(\n+                t.getSourceName(), child, propertiesToErrorFor.get(name),\n+                Warnings.INVALIDATION, name, propertyType.toString(), n.toString(), \"\"));\n+          }\n+        }\n \n         // We should never see a mix of numbers and strings.\n         String name = child.getString();",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}