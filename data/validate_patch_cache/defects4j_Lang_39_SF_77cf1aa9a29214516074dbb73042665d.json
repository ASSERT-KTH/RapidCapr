{
    "patch": "private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                      boolean repeat, int timeToLive) \n    {\n\n        // mchyzer Performance note: This creates very few new objects (one major goal)\n        // let me know if there are performance requests, we can create a harness to measure\n\n        if (text == null || text.isEmpty() || searchList == null || \n            searchList.length == 0 || replacementList == null || replacementList.length == 0) \n        {\n            return text;\n        }\n\n        // if recursing, this shouldnt be less than 0\n        if (timeToLive < 0) {\n            throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n        }\n\n        if (searchList.length != replacementList.length) {\n            throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n                + searchList.length + \" vs \" + replacementList.length);\n        }\n\n        Map<String,String> replaceMap = new HashMap<>();\n        for(int i=0; i<searchList.length; i++) {\n            if(searchList[i] != null && !searchList[i].isEmpty() && replacementList[i] != null) {\n                replaceMap.put(searchList[i], replacementList[i]);\n            }\n        }\n\n        StringBuilder result = new StringBuilder();\n\n        Pattern pattern = Pattern.compile(String.join(\"|\", searchList));\n        Matcher matcher = pattern.matcher(text);\n\n        int startIndex = 0;\n        while (matcher.find()) {\n            String matchStr = matcher.group();\n            String replacement = replaceMap.getOrDefault(matchStr, matchStr);\n\n            result.append(text, startIndex, matcher.start()).append(replacement);\n            startIndex = matcher.end();\n        }\n        result.append(text, startIndex, text.length());\n\n        return repeat ? replaceEach(result.toString(), searchList, replacementList, repeat, timeToLive - 1) : result.toString();\n    }",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang3/StringUtils.java b/src/java/org/apache/commons/lang3/StringUtils.java\nindex 14563aa6..0ea25bef 100644\n--- a/src/java/org/apache/commons/lang3/StringUtils.java\n+++ b/src/java/org/apache/commons/lang3/StringUtils.java\n@@ -3602,14 +3602,14 @@ public class StringUtils {\n      *             and/or size 0)\n      * @since 2.4\n      */\n-    private static String replaceEach(String text, String[] searchList, String[] replacementList, \n+private static String replaceEach(String text, String[] searchList, String[] replacementList, \n                                       boolean repeat, int timeToLive) \n     {\n \n         // mchyzer Performance note: This creates very few new objects (one major goal)\n         // let me know if there are performance requests, we can create a harness to measure\n \n-        if (text == null || text.length() == 0 || searchList == null || \n+        if (text == null || text.isEmpty() || searchList == null || \n             searchList.length == 0 || replacementList == null || replacementList.length == 0) \n         {\n             return text;\n@@ -3620,114 +3620,34 @@ public class StringUtils {\n             throw new IllegalStateException(\"TimeToLive of \" + timeToLive + \" is less than 0: \" + text);\n         }\n \n-        int searchLength = searchList.length;\n-        int replacementLength = replacementList.length;\n-\n-        // make sure lengths are ok, these need to be equal\n-        if (searchLength != replacementLength) {\n+        if (searchList.length != replacementList.length) {\n             throw new IllegalArgumentException(\"Search and Replace array lengths don't match: \"\n-                + searchLength\n-                + \" vs \"\n-                + replacementLength);\n-        }\n-\n-        // keep track of which still have matches\n-        boolean[] noMoreMatchesForReplIndex = new boolean[searchLength];\n-\n-        // index on index that the match was found\n-        int textIndex = -1;\n-        int replaceIndex = -1;\n-        int tempIndex = -1;\n-\n-        // index of replace array that will replace the search string found\n-        // NOTE: logic duplicated below START\n-        for (int i = 0; i < searchLength; i++) {\n-            if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n-                searchList[i].length() == 0 || replacementList[i] == null) \n-            {\n-                continue;\n-            }\n-            tempIndex = text.indexOf(searchList[i]);\n-\n-            // see if we need to keep searching for this\n-            if (tempIndex == -1) {\n-                noMoreMatchesForReplIndex[i] = true;\n-            } else {\n-                if (textIndex == -1 || tempIndex < textIndex) {\n-                    textIndex = tempIndex;\n-                    replaceIndex = i;\n-                }\n-            }\n-        }\n-        // NOTE: logic mostly below END\n-\n-        // no search strings found, we are done\n-        if (textIndex == -1) {\n-            return text;\n+                + searchList.length + \" vs \" + replacementList.length);\n         }\n \n-        int start = 0;\n-\n-        // get a good guess on the size of the result buffer so it doesnt have to double if it goes over a bit\n-        int increase = 0;\n-\n-        // count the replacement text elements that are larger than their corresponding text being replaced\n-        for (int i = 0; i < searchList.length; i++) {\n-            int greater = replacementList[i].length() - searchList[i].length();\n-            if (greater > 0) {\n-                increase += 3 * greater; // assume 3 matches\n+        Map<String,String> replaceMap = new HashMap<>();\n+        for(int i=0; i<searchList.length; i++) {\n+            if(searchList[i] != null && !searchList[i].isEmpty() && replacementList[i] != null) {\n+                replaceMap.put(searchList[i], replacementList[i]);\n             }\n         }\n-        // have upper-bound at 20% increase, then let Java take over\n-        increase = Math.min(increase, text.length() / 5);\n \n-        StringBuilder buf = new StringBuilder(text.length() + increase);\n+        StringBuilder result = new StringBuilder();\n \n-        while (textIndex != -1) {\n-\n-            for (int i = start; i < textIndex; i++) {\n-                buf.append(text.charAt(i));\n-            }\n-            buf.append(replacementList[replaceIndex]);\n-\n-            start = textIndex + searchList[replaceIndex].length();\n-\n-            textIndex = -1;\n-            replaceIndex = -1;\n-            tempIndex = -1;\n-            // find the next earliest match\n-            // NOTE: logic mostly duplicated above START\n-            for (int i = 0; i < searchLength; i++) {\n-                if (noMoreMatchesForReplIndex[i] || searchList[i] == null || \n-                    searchList[i].length() == 0 || replacementList[i] == null) \n-                {\n-                    continue;\n-                }\n-                tempIndex = text.indexOf(searchList[i], start);\n+        Pattern pattern = Pattern.compile(String.join(\"|\", searchList));\n+        Matcher matcher = pattern.matcher(text);\n \n-                // see if we need to keep searching for this\n-                if (tempIndex == -1) {\n-                    noMoreMatchesForReplIndex[i] = true;\n-                } else {\n-                    if (textIndex == -1 || tempIndex < textIndex) {\n-                        textIndex = tempIndex;\n-                        replaceIndex = i;\n-                    }\n-                }\n-            }\n-            // NOTE: logic duplicated above END\n+        int startIndex = 0;\n+        while (matcher.find()) {\n+            String matchStr = matcher.group();\n+            String replacement = replaceMap.getOrDefault(matchStr, matchStr);\n \n+            result.append(text, startIndex, matcher.start()).append(replacement);\n+            startIndex = matcher.end();\n         }\n-        int textLength = text.length();\n-        for (int i = start; i < textLength; i++) {\n-            buf.append(text.charAt(i));\n-        }\n-        String result = buf.toString();\n-        if (!repeat) {\n-            return result;\n-        }\n+        result.append(text, startIndex, text.length());\n \n-        return replaceEach(result, searchList, replacementList, repeat, timeToLive - 1);\n+        return repeat ? replaceEach(result.toString(), searchList, replacementList, repeat, timeToLive - 1) : result.toString();\n     }\n \n     // Replace, character based",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}