{
    "patch": "import org.mockito.exceptions.base.MockitoException;\nimport org.mockito.creation.instance.ClassInstantiator;\nimport org.mockito.internal.InternalMockHandler;\nimport org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator;\nimport org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\nimport org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.MockAccess;\nimport org.mockito.internal.util.StringUtil;\nimport org.mockito.mock.MockCreationSettings;\nimport org.mockito.plugins.MockMaker;\nimport org.mockito.serialization.SerializableMode;\n\nimport java.lang.reflect.Constructor;\nimport java.lang.reflect.InvocationTargetException;\n\n@SuppressWarnings(\"unchecked\")\npublic class MyMockito implements MockMaker {\n    private static final StringUtil stringUtil = new StringUtil();\n    private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n    private final ClassInstantiator classInstantiator = new ClassInstantiator();\n\n    @Override\n    public <T> T createMock(MockCreationSettings<T> settings, InternalMockHandler handler) {\n        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n        }\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n            settings.getTypeToMock(),\n            settings.getExtraInterfaces()\n        );\n        T mockInstance = null;\n        Constructor<? extends T> constructor;\n        try {\n            constructor = mockedProxyType.getConstructor(MockCreationSettings.class);\n            mockInstance = constructor.newInstance(settings);\n            MockAccess mockAccess = (MockAccess) mockInstance;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n        } catch (NoSuchMethodException e) {\n            throw new MockitoException(\"Unable to find constructor with MockCreationSettings argument in mocked proxy class '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        } catch (InstantiationException e) {\n            throw new MockitoException(\"Unable to instantiate mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        } catch (IllegalAccessException e) {\n            throw new MockitoException(\"Unable to access constructor with MockCreationSettings argument in mocked proxy class '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        } catch (InvocationTargetException e) {\n            throw new MockitoException(\"Unable to invoke constructor with MockCreationSettings argument in mocked proxy class '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        } catch (ClassCastException e) {\n            throw new MockitoException(stringUtil.join(\n                    \"ClassCastException occurred while creating the mockito mock:\",\n                    \"  class to mock : \" + stringUtil.toString(mockedProxyType),\n                    \"  created class : \" + stringUtil.toString(settings.getTypeToMock()),\n                    \"  proxy instance class : \" + stringUtil.toString(mockInstance),\n                    \"  instance creation by : \" + constructor.getDeclaringClass() + \".\" + constructor.getName(),\n                    \"\",\n                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                    \"\"\n            ), e);\n        }\n    }\n\n    @Override\n    public InternalMockHandler getInternalMockHandler(Object mock) {\n        if (mock instanceof MockAccess) {\n            return ((MockAccess) mock).getMockitoInterceptor().getHandler();\n        }\n        return null;\n    }\n\n    @Override\n    public void resetMock(Object mock, MockCreationSettings settings, InternalMockHandler handler) {\n        if (mock instanceof MockAccess) {\n            MockAccess mockAccess = (MockAccess) mock;\n            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n        }\n    }\n\n    @Override\n    public TypeMockability isTypeMockable(Class<?> clazz) {\n        if (clazz.isArray() || clazz.isPrimitive() || clazz == String.class) {\n            return TypeMockability.NON_MOCKABLE;\n        }\n        if (clazz.getName().startsWith(\"java.\")) {\n            return TypeMockability.MOCKABLE;\n        }\n        return TypeMockability.UNKNOWN;\n    }\n\n    private static InternalMockHandler asInternalMockHandler(InternalMockHandler handler) {\n        if (handler == null) {\n            return null;\n        }\n        if (handler instanceof MockMethodInterceptor.MockAccess) {\n            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) handler;\n            return mockAccess.getMockitoInterceptor().getHandler();\n        }\n        return handler;\n    }\n\n    private static <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<?> settings, T mock) {\n        @SuppressWarnings(\"unchecked\")\n        Class<T> mockedType = (Class<T>) settings.getTypeToMock();\n        if (!mockedType.isInstance(mock)) {\n            throw new MockitoException(\"Mockito cannot determine the type of the mocked object.\\n\" +\n                    \"Mockito cannot cast '\" + String.valueOf(mock) + \"' to class '\" + mockedType.getName() + \"'.\\n\" +\n                    \"If the mocked type is a class (not a final class) you can determine your proxy instance's type\\n\" +\n                    \"by calling Object.getClass().\\n\" +\n                    \"ToString of the mocked object when invoked might print the type of the mocked instance.\");\n        }\n        return mock;\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\nindex 9dc44e663..8b3cad156 100644\n--- a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n+++ b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n@@ -20,38 +20,117 @@ public class ByteBuddyMockMaker implements MockMaker {\n         classInstantiator = initializeClassInstantiator();\n         cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n     }\n+import org.mockito.exceptions.base.MockitoException;\n+import org.mockito.creation.instance.ClassInstantiator;\n+import org.mockito.internal.InternalMockHandler;\n+import org.mockito.internal.creation.bytebuddy.CachingMockBytecodeGenerator;\n+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\n+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.MockAccess;\n+import org.mockito.internal.util.StringUtil;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.serialization.SerializableMode;\n \n-    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n+import java.lang.reflect.Constructor;\n+import java.lang.reflect.InvocationTargetException;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class MyMockito implements MockMaker {\n+    private static final StringUtil stringUtil = new StringUtil();\n+    private final CachingMockBytecodeGenerator cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n+    private final ClassInstantiator classInstantiator = new ClassInstantiator();\n+\n+    @Override\n+    public <T> T createMock(MockCreationSettings<T> settings, InternalMockHandler handler) {\n         if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n             throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n         }\n         Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n-                settings.getTypeToMock(),\n-                settings.getExtraInterfaces()\n+            settings.getTypeToMock(),\n+            settings.getExtraInterfaces()\n         );\n         T mockInstance = null;\n+        Constructor<? extends T> constructor;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n+            constructor = mockedProxyType.getConstructor(MockCreationSettings.class);\n+            mockInstance = constructor.newInstance(settings);\n+            MockAccess mockAccess = (MockAccess) mockInstance;\n             mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n             return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+        } catch (NoSuchMethodException e) {\n+            throw new MockitoException(\"Unable to find constructor with MockCreationSettings argument in mocked proxy class '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n+        } catch (InstantiationException e) {\n+            throw new MockitoException(\"Unable to instantiate mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n+        } catch (IllegalAccessException e) {\n+            throw new MockitoException(\"Unable to access constructor with MockCreationSettings argument in mocked proxy class '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n+        } catch (InvocationTargetException e) {\n+            throw new MockitoException(\"Unable to invoke constructor with MockCreationSettings argument in mocked proxy class '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n+        } catch (ClassCastException e) {\n+            throw new MockitoException(stringUtil.join(\n+                    \"ClassCastException occurred while creating the mockito mock:\",\n+                    \"  class to mock : \" + stringUtil.toString(mockedProxyType),\n+                    \"  created class : \" + stringUtil.toString(settings.getTypeToMock()),\n+                    \"  proxy instance class : \" + stringUtil.toString(mockInstance),\n+                    \"  instance creation by : \" + constructor.getDeclaringClass() + \".\" + constructor.getName(),\n                     \"\",\n                     \"You might experience classloading issues, please ask the mockito mailing-list.\",\n                     \"\"\n-            ),cce);\n-        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n-            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n+            ), e);\n+        }\n+    }\n+\n+    @Override\n+    public InternalMockHandler getInternalMockHandler(Object mock) {\n+        if (mock instanceof MockAccess) {\n+            return ((MockAccess) mock).getMockitoInterceptor().getHandler();\n         }\n+        return null;\n     }\n \n+    @Override\n+    public void resetMock(Object mock, MockCreationSettings settings, InternalMockHandler handler) {\n+        if (mock instanceof MockAccess) {\n+            MockAccess mockAccess = (MockAccess) mock;\n+            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n+        }\n+    }\n+\n+    @Override\n+    public TypeMockability isTypeMockable(Class<?> clazz) {\n+        if (clazz.isArray() || clazz.isPrimitive() || clazz == String.class) {\n+            return TypeMockability.NON_MOCKABLE;\n+        }\n+        if (clazz.getName().startsWith(\"java.\")) {\n+            return TypeMockability.MOCKABLE;\n+        }\n+        return TypeMockability.UNKNOWN;\n+    }\n+\n+    private static InternalMockHandler asInternalMockHandler(InternalMockHandler handler) {\n+        if (handler == null) {\n+            return null;\n+        }\n+        if (handler instanceof MockMethodInterceptor.MockAccess) {\n+            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) handler;\n+            return mockAccess.getMockitoInterceptor().getHandler();\n+        }\n+        return handler;\n+    }\n+\n+    private static <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<?> settings, T mock) {\n+        @SuppressWarnings(\"unchecked\")\n+        Class<T> mockedType = (Class<T>) settings.getTypeToMock();\n+        if (!mockedType.isInstance(mock)) {\n+            throw new MockitoException(\"Mockito cannot determine the type of the mocked object.\\n\" +\n+                    \"Mockito cannot cast '\" + String.valueOf(mock) + \"' to class '\" + mockedType.getName() + \"'.\\n\" +\n+                    \"If the mocked type is a class (not a final class) you can determine your proxy instance's type\\n\" +\n+                    \"by calling Object.getClass().\\n\" +\n+                    \"ToString of the mocked object when invoked might print the type of the mocked instance.\");\n+        }\n+        return mock;\n+    }\n+}\n+\n     private <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {\n         // Force explicit cast to mocked type here, instead of\n         // relying on the JVM to implicitly cast on the client call site.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}