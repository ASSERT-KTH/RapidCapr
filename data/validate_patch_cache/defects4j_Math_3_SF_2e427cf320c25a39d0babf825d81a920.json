{
    "patch": "public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n        if (len == 0) {\n            return 0.0;\n        }\n        if (len == 1) {\n            return a[0] * b[0];\n        }\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n\n            prodHigh[i] = ai * bi;\n\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                     aHigh * bHigh) -\n                                                    aLow * bHigh) -\n                                                   aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n\n        double prodHighCur = prodHigh[0];\n        double prodHighNext = prodHigh[1];\n        double sHighPrev = prodHighCur + prodHighNext;\n        double sPrime = sHighPrev - prodHighNext;\n        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            prodHighCur = prodHigh[i];\n            prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        prodHighNext = prodHigh[lenMinusOne];\n        sPrime = (sHighPrev + prodHighNext) - prodHighNext;\n        sLowSum += prodHighNext - (sHighPrev - sPrime) + prodLowSum;\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..77e6f00ad 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -811,14 +811,18 @@ public class MathArrays {\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n-    public static double linearCombination(final double[] a, final double[] b)\n+public static double linearCombination(final double[] a, final double[] b)\n         throws DimensionMismatchException {\n         final int len = a.length;\n         if (len != b.length) {\n             throw new DimensionMismatchException(len, b.length);\n         }\n-\n-            // Revert to scalar multiplication.\n+        if (len == 0) {\n+            return 0.0;\n+        }\n+        if (len == 1) {\n+            return a[0] * b[0];\n+        }\n \n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n@@ -833,16 +837,17 @@ public class MathArrays {\n             final double cb = SPLIT_FACTOR * bi;\n             final double bHigh = cb - (cb - bi);\n             final double bLow = bi - bHigh;\n+\n             prodHigh[i] = ai * bi;\n+\n             final double prodLow = aLow * bLow - (((prodHigh[i] -\n-                                                    aHigh * bHigh) -\n-                                                   aLow * bHigh) -\n-                                                  aHigh * bLow);\n+                                                     aHigh * bHigh) -\n+                                                    aLow * bHigh) -\n+                                                   aHigh * bLow);\n             prodLowSum += prodLow;\n         }\n \n-\n-        final double prodHighCur = prodHigh[0];\n+        double prodHighCur = prodHigh[0];\n         double prodHighNext = prodHigh[1];\n         double sHighPrev = prodHighCur + prodHighNext;\n         double sPrime = sHighPrev - prodHighNext;\n@@ -850,13 +855,18 @@ public class MathArrays {\n \n         final int lenMinusOne = len - 1;\n         for (int i = 1; i < lenMinusOne; i++) {\n+            prodHighCur = prodHigh[i];\n             prodHighNext = prodHigh[i + 1];\n             final double sHighCur = sHighPrev + prodHighNext;\n             sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n+            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n             sHighPrev = sHighCur;\n         }\n \n+        prodHighNext = prodHigh[lenMinusOne];\n+        sPrime = (sHighPrev + prodHighNext) - prodHighNext;\n+        sLowSum += prodHighNext - (sHighPrev - sPrime) + prodLowSum;\n+\n         double result = sHighPrev + (prodLowSum + sLowSum);\n \n         if (Double.isNaN(result)) {",
    "result_reason": "junit.framework.AssertionFailedError: expected:<-1.8551294182586249> but was:<-7.3483014880198144E16>",
    "test_result": "FAIL"
}