{
    "patch": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n  boolean nodeAlwaysExecutes = true;\n\n  // Just an 'exit'.\n  if (matchingExitNode(n, exitType, labelName)) {\n    nodeAlwaysExecutes = false;\n  }\n\n  // Just an 'if'.\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n\n    // Check if the condition is a boolean constant.\n    Node condition = n.getFirstChild();\n\n    if (condition.getBooleanProp(NodeUtil.SIDE_EFFECT_FREE_PROP)\n        && NodeUtil.isBooleanValue(condition)) {\n\n      // If the true block is always executed and the false block is not present,\n      // we remove the if and push the content of the true block up.\n      if (condition.getBoolean() && elseBlock == null) {\n        NodeUtil.redeclareVarsInsideBranch(ifBlock);\n        n.getParent().replaceChild(n, ifBlock.detachChildren());\n        nodeAlwaysExecutes = true;\n      } else if (!condition.getBoolean() && elseBlock != null) {\n\n        // If the false block is always executed, we replace the if with the else block.\n        // We need to make sure to copy the local vars of the if block inside the else\n        // block, if any.\n        NodeUtil.redeclareVarsInsideBranch(elseBlock);\n        n.getParent().replaceChild(n, elseBlock.detachChildren());\n        nodeAlwaysExecutes = true;\n\n      } else {\n        nodeAlwaysExecutes = false;\n      }\n\n    }\n  }\n\n  // Just a 'try/catch/finally'.\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n\n    // Check if everything after the finally block is unreachable.\n    if (NodeUtil.hasFinally(n)) {\n      Node finallyBlock = n.getLastChild();\n      tryMinimizeExits(finallyBlock, exitType, labelName);\n\n      // Check if the try and the catch blocks can be removed.\n      if (!NodeUtil.hasFinallyCatchOrFallback(n) &&\n          finallyBlock.isBlock() &&\n          finallyBlock.getLastChild().getNext() == null) {\n        NodeUtil.removeChild(n.getParent(), n);\n        nodeAlwaysExecutes = false;\n      }\n    } else {\n      nodeAlwaysExecutes = false;\n    }\n  }\n\n  // Just a 'label'.\n  if (n.isLabel()) {\n    Node labelBlock = n.getLastChild();\n    tryMinimizeExits(labelBlock, exitType, labelName);\n  }\n\n  // TODO(johnlenz): The last case of SWITCH statement?\n\n  // The rest assumes a block with at least one child, bail on anything else.\n  if (!n.isBlock() || n.getLastChild() == null) {\n    return;\n  }\n\n  // Multiple if-exits can be converted in a single pass.\n  // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n  // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n  // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n  for (Node c : n.children()) {\n\n    // An 'if' block to process below.\n    if (c.isIf()) {\n      Node ifTree = c;\n      Node trueBlock, falseBlock;\n\n      // First, the true condition block.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      tryMinimizeIfBlockExits(trueBlock, falseBlock,\n          ifTree, exitType, labelName);\n\n      // Now the else block.\n      // The if blocks may have changed, get them again.\n      trueBlock = ifTree.getFirstChild().getNext();\n      falseBlock = trueBlock.getNext();\n      if (falseBlock != null) {\n        tryMinimizeIfBlockExits(falseBlock, trueBlock,\n            ifTree, exitType, labelName);\n      }\n    }\n\n    if (c == n.getLastChild()) {\n      break;\n    }\n  }\n\n  if (nodeAlwaysExecutes) {\n    // nothing following will execute, everything after is dead code\n    NodeUtil.removeChild(n.getParent(), n);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..a8256b42 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -103,103 +103,132 @@ class MinimizeExitPoints\n    *   null otherwise.\n    * @nullable labelName non-null only for breaks within labels.\n    */\n-  void tryMinimizeExits(Node n, int exitType, String labelName) {\n+void tryMinimizeExits(Node n, int exitType, String labelName) {\n \n-    // Just an 'exit'.\n-    if (matchingExitNode(n, exitType, labelName)) {\n-      NodeUtil.removeChild(n.getParent(), n);\n-      compiler.reportCodeChange();\n-      return;\n-    }\n+  boolean nodeAlwaysExecutes = true;\n \n-    // Just an 'if'.\n-    if (n.isIf()) {\n-      Node ifBlock = n.getFirstChild().getNext();\n-      tryMinimizeExits(ifBlock, exitType, labelName);\n-      Node elseBlock = ifBlock.getNext();\n-      if (elseBlock != null) {\n-        tryMinimizeExits(elseBlock, exitType, labelName);\n-      }\n-      return;\n+  // Just an 'exit'.\n+  if (matchingExitNode(n, exitType, labelName)) {\n+    nodeAlwaysExecutes = false;\n+  }\n+\n+  // Just an 'if'.\n+  if (n.isIf()) {\n+    Node ifBlock = n.getFirstChild().getNext();\n+    tryMinimizeExits(ifBlock, exitType, labelName);\n+    Node elseBlock = ifBlock.getNext();\n+    if (elseBlock != null) {\n+      tryMinimizeExits(elseBlock, exitType, labelName);\n     }\n \n-    // Just a 'try/catch/finally'.\n-    if (n.isTry()) {\n-      Node tryBlock = n.getFirstChild();\n-      tryMinimizeExits(tryBlock, exitType, labelName);\n-      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-        Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n-      }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+    // Check if the condition is a boolean constant.\n+    Node condition = n.getFirstChild();\n+\n+    if (condition.getBooleanProp(NodeUtil.SIDE_EFFECT_FREE_PROP)\n+        && NodeUtil.isBooleanValue(condition)) {\n+\n+      // If the true block is always executed and the false block is not present,\n+      // we remove the if and push the content of the true block up.\n+      if (condition.getBoolean() && elseBlock == null) {\n+        NodeUtil.redeclareVarsInsideBranch(ifBlock);\n+        n.getParent().replaceChild(n, ifBlock.detachChildren());\n+        nodeAlwaysExecutes = true;\n+      } else if (!condition.getBoolean() && elseBlock != null) {\n+\n+        // If the false block is always executed, we replace the if with the else block.\n+        // We need to make sure to copy the local vars of the if block inside the else\n+        // block, if any.\n+        NodeUtil.redeclareVarsInsideBranch(elseBlock);\n+        n.getParent().replaceChild(n, elseBlock.detachChildren());\n+        nodeAlwaysExecutes = true;\n+\n+      } else {\n+        nodeAlwaysExecutes = false;\n       }\n+\n     }\n+  }\n \n-    // Just a 'label'.\n-    if (n.isLabel()) {\n-      Node labelBlock = n.getLastChild();\n-      tryMinimizeExits(labelBlock, exitType, labelName);\n+  // Just a 'try/catch/finally'.\n+  if (n.isTry()) {\n+    Node tryBlock = n.getFirstChild();\n+    tryMinimizeExits(tryBlock, exitType, labelName);\n+    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n+    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n+      Preconditions.checkState(allCatchNodes.hasOneChild());\n+      Node catchNode = allCatchNodes.getFirstChild();\n+      Node catchCodeBlock = catchNode.getLastChild();\n+      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n     }\n \n-    // TODO(johnlenz): The last case of SWITCH statement?\n+    // Check if everything after the finally block is unreachable.\n+    if (NodeUtil.hasFinally(n)) {\n+      Node finallyBlock = n.getLastChild();\n+      tryMinimizeExits(finallyBlock, exitType, labelName);\n \n-    // The rest assumes a block with at least one child, bail on anything else.\n-    if (!n.isBlock() || n.getLastChild() == null) {\n-      return;\n+      // Check if the try and the catch blocks can be removed.\n+      if (!NodeUtil.hasFinallyCatchOrFallback(n) &&\n+          finallyBlock.isBlock() &&\n+          finallyBlock.getLastChild().getNext() == null) {\n+        NodeUtil.removeChild(n.getParent(), n);\n+        nodeAlwaysExecutes = false;\n+      }\n+    } else {\n+      nodeAlwaysExecutes = false;\n     }\n+  }\n \n-    // Multiple if-exits can be converted in a single pass.\n-    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-\n-      // An 'if' block to process below.\n-      if (c.isIf()) {\n-        Node ifTree = c;\n-        Node trueBlock, falseBlock;\n-\n-        // First, the true condition block.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n+  // Just a 'label'.\n+  if (n.isLabel()) {\n+    Node labelBlock = n.getLastChild();\n+    tryMinimizeExits(labelBlock, exitType, labelName);\n+  }\n \n-        // Now the else block.\n-        // The if blocks may have changed, get them again.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n-        }\n-      }\n+  // TODO(johnlenz): The last case of SWITCH statement?\n \n-      if (c == n.getLastChild()) {\n-        break;\n+  // The rest assumes a block with at least one child, bail on anything else.\n+  if (!n.isBlock() || n.getLastChild() == null) {\n+    return;\n+  }\n+\n+  // Multiple if-exits can be converted in a single pass.\n+  // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n+  // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n+  // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n+  for (Node c : n.children()) {\n+\n+    // An 'if' block to process below.\n+    if (c.isIf()) {\n+      Node ifTree = c;\n+      Node trueBlock, falseBlock;\n+\n+      // First, the true condition block.\n+      trueBlock = ifTree.getFirstChild().getNext();\n+      falseBlock = trueBlock.getNext();\n+      tryMinimizeIfBlockExits(trueBlock, falseBlock,\n+          ifTree, exitType, labelName);\n+\n+      // Now the else block.\n+      // The if blocks may have changed, get them again.\n+      trueBlock = ifTree.getFirstChild().getNext();\n+      falseBlock = trueBlock.getNext();\n+      if (falseBlock != null) {\n+        tryMinimizeIfBlockExits(falseBlock, trueBlock,\n+            ifTree, exitType, labelName);\n       }\n     }\n \n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n-        break;\n-      }\n+    if (c == n.getLastChild()) {\n+      break;\n     }\n   }\n \n+  if (nodeAlwaysExecutes) {\n+    // nothing following will execute, everything after is dead code\n+    NodeUtil.removeChild(n.getParent(), n);\n+  }\n+}\n+\n   /**\n    * Look for exits (returns, breaks, or continues, depending on the context) at\n    * the end of a block and removes them by moving the if node's siblings,",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}