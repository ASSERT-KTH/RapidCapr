{
    "patch": "  private Node tryMinimizeIf(Node n) {\n    Node conditionNode = n.getFirstChild();\n    Node thenNode = conditionNode.getNext();\n    Node elseNode = thenNode.getNext();\n\n    boolean isConst =\n        NodeUtil.evaluateConditionToBoolean(conditionNode) != null &&\n        !mayHaveSideEffects(thenNode) &&\n        (elseNode == null || !mayHaveSideEffects(elseNode));\n    if (isConst) {\n      // The IF statement can be replaced with either the THEN or ELSE statement.\n      Node replacementNode =\n          elseNode == null ? thenNode.detach()\n              : NodeUtil.getKnownConstantResult(getCompiler(), conditionNode).equals(Boolean.FALSE)\n                  ? elseNode.detach()\n                  : thenNode.detach();\n      n.replaceWith(replacementNode);\n      reportCodeChange();\n      return replacementNode;\n    }\n\n    // Check if we can convert this to an AND or OR expression.\n    if (NodeUtil.isBooleanResultExpression(thenNode)) {\n      if (conditionNode.isAnd()) {\n        /*\n         * Change:      a && b && c && d ? foo() : bar();\n         * To:          a ? b && c && d ? foo() : bar() : bar();\n         * Unless we can guarantee that `b && c && d` will have side effects when a is true, so the semantics aren't changed.\n         */\n        for (Node andValue = conditionNode.getFirstChild(); andValue != null; andValue = andValue.getNext()) {\n          if (!mayHaveSideEffects(andValue)) {\n            return n;\n          }\n        }\n\n        n.removeChild(conditionNode);\n        Node newCondition = conditionNode.getFirstChild();\n        Node hook = IR.hook(\n            newCondition,\n            thenNode.removeFirstChild(),\n            elseNode == null ? IR.trueNode() : elseNode);\n        Node replacement = IR.or(conditionNode, hook).srcref(n);\n        n.replaceWith(replacement);\n        reportCodeChange();\n        return replacement;\n      } else if (conditionNode.isOr()) {\n        /*\n         * Change:      a || b || c || d ? foo() : bar();\n         * To:          a ? foo() : b || c || d ? foo() : bar()\n         * Unless we can guarantee that `b || c || d` will have side effects when a is false, so the semantics aren't changed.\n         */\n        for (Node orValue = conditionNode.getFirstChild(); orValue != null; orValue = orValue.getNext()) {\n          if (!mayHaveSideEffects(orValue)) {\n            return n;\n          }\n        }\n\n        n.removeChild(conditionNode);\n        Node newCondition = conditionNode.getFirstChild();\n        Node hook = IR.hook(newCondition, thenNode.removeFirstChild(), elseNode);\n        Node replacement = IR.and(conditionNode, hook).srcref(n);\n        n.replaceWith(replacement);\n        reportCodeChange();\n        return replacement;\n      }\n    }\n\n    // Perform side effect analysis of the THEN and ELSE statements.\n    boolean thenStatementHasSideEffects = mayHaveSideEffects(thenNode);\n    boolean elseStatementHasSideEffects = elseNode != null && mayHaveSideEffects(elseNode);\n    if (!thenStatementHasSideEffects && !elseStatementHasSideEffects) {\n      // Both THEN and ELSE statements have no side effects, so we can use a HOOK.\n      // Determine the most precise type between the THEN and ELSE statements.\n      final JSType thenStatementType = getBestJSType.apply(thenNode);\n      final JSType elseStatementType = getBestJSType.apply(elseNode);\n      if (maybeMorePreciseThan(thenStatementType, elseStatementType)) {\n        Node replacementNode =\n            IR.hook(conditionNode, thenNode.removeFirstChild(), elseNode.removeFirstChild())\n                .setJSType(thenStatementType)\n                .srcref(n);\n        n.replaceWith(replacementNode);\n        reportCodeChange();\n        return replacementNode;\n      }\n    } else if (elseNode != null && !elseStatementHasSideEffects) {\n      // The ELSE statement has no side effects, so we can replace the IF with the THEN\n      // statement with a comma expression.\n      Node replacementNode =\n          IR.comma(thenNode.removeFirstChild(), elseNode.detach()).srcref(n);\n      n.replaceWith(replacementNode);\n      reportCodeChange();\n      return replacementNode;\n    }\n\n    return n;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..ade83798 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -634,234 +634,97 @@ class PeepholeSubstituteAlternateSyntax\n    * necessary.\n    */\n   private Node tryMinimizeIf(Node n) {\n-\n-    Node parent = n.getParent();\n-\n-    Node cond = n.getFirstChild();\n-\n-    /* If the condition is a literal, we'll let other\n-     * optimizations try to remove useless code.\n-     */\n-    if (NodeUtil.isLiteralValue(cond, true)) {\n-      return n;\n+    Node conditionNode = n.getFirstChild();\n+    Node thenNode = conditionNode.getNext();\n+    Node elseNode = thenNode.getNext();\n+\n+    boolean isConst =\n+        NodeUtil.evaluateConditionToBoolean(conditionNode) != null &&\n+        !mayHaveSideEffects(thenNode) &&\n+        (elseNode == null || !mayHaveSideEffects(elseNode));\n+    if (isConst) {\n+      // The IF statement can be replaced with either the THEN or ELSE statement.\n+      Node replacementNode =\n+          elseNode == null ? thenNode.detach()\n+              : NodeUtil.getKnownConstantResult(getCompiler(), conditionNode).equals(Boolean.FALSE)\n+                  ? elseNode.detach()\n+                  : thenNode.detach();\n+      n.replaceWith(replacementNode);\n+      reportCodeChange();\n+      return replacementNode;\n     }\n \n-    Node thenBranch = cond.getNext();\n-    Node elseBranch = thenBranch.getNext();\n-\n-    if (elseBranch == null) {\n-      if (isFoldableExpressBlock(thenBranch)) {\n-        Node expr = getBlockExpression(thenBranch);\n-        if (!late && isPropertyAssignmentInExpression(expr)) {\n-          // Keep opportunities for CollapseProperties such as\n-          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-          // until CollapseProperties has been run.\n-          return n;\n-        }\n-\n-        if (cond.isNot()) {\n-          // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n+    // Check if we can convert this to an AND or OR expression.\n+    if (NodeUtil.isBooleanResultExpression(thenNode)) {\n+      if (conditionNode.isAnd()) {\n+        /*\n+         * Change:      a && b && c && d ? foo() : bar();\n+         * To:          a ? b && c && d ? foo() : bar() : bar();\n+         * Unless we can guarantee that `b && c && d` will have side effects when a is true, so the semantics aren't changed.\n+         */\n+        for (Node andValue = conditionNode.getFirstChild(); andValue != null; andValue = andValue.getNext()) {\n+          if (!mayHaveSideEffects(andValue)) {\n             return n;\n           }\n-\n-          Node or = IR.or(\n-              cond.removeFirstChild(),\n-              expr.removeFirstChild()).srcref(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          reportCodeChange();\n-\n-          return newExpr;\n-        }\n-\n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses is worth the change even if\n-          // there is no immediate code size win. However, two extra pair of\n-          // {}, we would have to think twice. (unless we know for sure the\n-          // we can further optimize its parent.\n-          return n;\n         }\n \n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n+        n.removeChild(conditionNode);\n+        Node newCondition = conditionNode.getFirstChild();\n+        Node hook = IR.hook(\n+            newCondition,\n+            thenNode.removeFirstChild(),\n+            elseNode == null ? IR.trueNode() : elseNode);\n+        Node replacement = IR.or(conditionNode, hook).srcref(n);\n+        n.replaceWith(replacement);\n         reportCodeChange();\n-\n-        return newExpr;\n-      } else {\n-\n-        // Try to combine two IF-ELSE\n-        if (NodeUtil.isStatementBlock(thenBranch) &&\n-            thenBranch.hasOneChild()) {\n-          Node innerIf = thenBranch.getFirstChild();\n-\n-          if (innerIf.isIf()) {\n-            Node innerCond = innerIf.getFirstChild();\n-            Node innerThenBranch = innerCond.getNext();\n-            Node innerElseBranch = innerThenBranch.getNext();\n-\n-            if (innerElseBranch == null &&\n-                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n-              n.detachChildren();\n-              n.addChildToBack(\n-                  IR.and(\n-                      cond,\n-                      innerCond.detachFromParent())\n-                      .srcref(cond));\n-              n.addChildrenToBack(innerThenBranch.detachFromParent());\n-              reportCodeChange();\n-              // Not worth trying to fold the current IF-ELSE into && because\n-              // the inner IF-ELSE wasn't able to be folded into && anyways.\n-              return n;\n-            }\n-          }\n-        }\n-      }\n-\n-      return n;\n-    }\n-\n-    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n-     * peephole optimization. This should probably get moved to another pass.\n-     */\n-    tryRemoveRepeatedStatements(n);\n-\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      reportCodeChange();\n-      return n;\n-    }\n-\n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-      Node thenExpr = getBlockReturnExpression(thenBranch);\n-      Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n-                                .srcref(n));\n-      parent.replaceChild(n, returnNode);\n-      reportCodeChange();\n-      return returnNode;\n-    }\n-\n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-      if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n-        if (NodeUtil.isAssignmentOp(thenOp)) {\n-          Node lhs = thenOp.getFirstChild();\n-          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n-            reportCodeChange();\n-\n-            return expr;\n+        return replacement;\n+      } else if (conditionNode.isOr()) {\n+        /*\n+         * Change:      a || b || c || d ? foo() : bar();\n+         * To:          a ? foo() : b || c || d ? foo() : bar()\n+         * Unless we can guarantee that `b || c || d` will have side effects when a is false, so the semantics aren't changed.\n+         */\n+        for (Node orValue = conditionNode.getFirstChild(); orValue != null; orValue = orValue.getNext()) {\n+          if (!mayHaveSideEffects(orValue)) {\n+            return n;\n           }\n         }\n-      }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n-      reportCodeChange();\n-      return expr;\n-    }\n \n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n+        n.removeChild(conditionNode);\n+        Node newCondition = conditionNode.getFirstChild();\n+        Node hook = IR.hook(newCondition, thenNode.removeFirstChild(), elseNode);\n+        Node replacement = IR.and(conditionNode, hook).srcref(n);\n+        n.replaceWith(replacement);\n         reportCodeChange();\n-        return var;\n+        return replacement;\n       }\n+    }\n \n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n+    // Perform side effect analysis of the THEN and ELSE statements.\n+    boolean thenStatementHasSideEffects = mayHaveSideEffects(thenNode);\n+    boolean elseStatementHasSideEffects = elseNode != null && mayHaveSideEffects(elseNode);\n+    if (!thenStatementHasSideEffects && !elseStatementHasSideEffects) {\n+      // Both THEN and ELSE statements have no side effects, so we can use a HOOK.\n+      // Determine the most precise type between the THEN and ELSE statements.\n+      final JSType thenStatementType = getBestJSType.apply(thenNode);\n+      final JSType elseStatementType = getBestJSType.apply(elseNode);\n+      if (maybeMorePreciseThan(thenStatementType, elseStatementType)) {\n+        Node replacementNode =\n+            IR.hook(conditionNode, thenNode.removeFirstChild(), elseNode.removeFirstChild())\n+                .setJSType(thenStatementType)\n+                .srcref(n);\n+        n.replaceWith(replacementNode);\n         reportCodeChange();\n-\n-        return var;\n+        return replacementNode;\n       }\n+    } else if (elseNode != null && !elseStatementHasSideEffects) {\n+      // The ELSE statement has no side effects, so we can replace the IF with the THEN\n+      // statement with a comma expression.\n+      Node replacementNode =\n+          IR.comma(thenNode.removeFirstChild(), elseNode.detach()).srcref(n);\n+      n.replaceWith(replacementNode);\n+      reportCodeChange();\n+      return replacementNode;\n     }\n \n     return n;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}