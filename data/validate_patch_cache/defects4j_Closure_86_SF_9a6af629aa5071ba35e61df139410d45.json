{
    "patch": "static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      // A result that is aliased by a non-local name, is the effectively the\n      // same as returning a non-local name, but this doesn't matter if the\n      // value is immutable.\n      return NodeUtil.isImmutableValue(value.getLastChild())\n              || (locals.apply(value)\n              && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n              && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.CALL:\n      return callHasLocalResult(value) || isToStringMethodCall(value)\n              || locals.apply(value);\n    case Token.NEW:\n      return isLocalConstructor(value);\n    case Token.THIS:\n    case Token.NAME:\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.apply(value);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n              && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      }\n      return true;\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      // Literals objects with non-literal children are allowed.\n      return true;\n    case Token.IN:\n      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n      return true;\n    default:\n      // Other op force a local value:\n      //  x = '' + g (x is now an local string)\n      //  x -= g (x is now an local number)\n      if (isAssignmentOp(value) || isSimpleOperator(value)\n              || isImmutableValue(value)) {\n        return true;\n      }\n      throw new IllegalStateException(\"Unexpected expression node\" + value\n              + \"\\n parent:\" + value.getParent());\n  }\n}\n\nprivate static boolean isLocalConstructor(Node node) {\n  Node first = node.getFirstChild();\n  if (first != null) {\n    if (first.getType() == Token.FUNCTION) {\n      Node functionNameNode = NodeUtil.getFunctionNameNode(first);\n      return functionNameNode == null || !isNativeFunctionName(functionNameNode.getString());\n    } else {\n      String className = getClassName(first);\n      if (className != null && !className.isEmpty()) {\n        if (isNativeFunctionName(className)) {\n          return false;\n        }\n        String firstChildSource = first.getSourceFileName();\n        String classSource = first.getLastChild().getSourceFileName();\n        if (firstChildSource.equals(classSource)) {\n          return true;\n        }\n        String classBaseName = SourceFile.fromFile(classSource).getName();\n        return firstChildSource.endsWith(classBaseName);\n      } else if (first.getType() == Token.NEW) {\n        return isLocalConstructor(first);\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * @return Whether the given name is the name of a built-in prototype method.\n */\nprivate static boolean isNativeFunctionName(String s) {\n  // Native function names are not prefixed with the \"@__\" symbol used for internal anonymous\n  // functions.\n  return (s.startsWith(\"$jscomp$\") && s.contains(\".\"))\n          || FUNCTION_PROTOTYPE_METHODS.contains(s)\n          || NATIVE_ARRAY_METHODS.contains(s)\n          || NATIVE_MATH_METHODS.contains(s)\n          || NATIVE_NUMBER_METHODS.contains(s)\n          || NATIVE_OBJECT_METHODS.contains(s)\n          || NATIVE_STRING_METHODS.contains(s);\n}\n\n/**\n * Gets the name of the class defined in the given node.\n * @param classNode The node defining the class.\n * @return The fully qualified name of the class, or null if it could not be determined.\n */\nprivate static String getClassName(Node classNode) {\n  if (classNode == null) {\n    return null;\n  }\n  String className = null;\n  Node nameNode = NodeUtil.getNameNode(classNode);\n  if (nameNode == null) {\n    if (classNode.getType() == Token.CALL) {\n      // ES6 class with a class name reference.\n      Node constructor = classNode.getFirstChild();\n      if (constructor.getType() == Token.GETPROP\n              && constructor.getLastChild() != null\n              && constructor.getLastChild().getString().equals(\"name\")) {\n        className = constructor.getFirstChild().getQualifiedName();\n      }\n    }\n  } else {\n    className = nameNode.getQualifiedName();\n  }\n  return className;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex dd78f900..9e36e37f 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -2421,72 +2421,130 @@ public final class NodeUtil {\n    * @return Whether the node is known to be a value that is not a reference\n    *     outside the expression scope.\n    */\n-  static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n-    switch (value.getType()) {\n-      case Token.ASSIGN:\n-        // A result that is aliased by a non-local name, is the effectively the\n-        // same as returning a non-local name, but this doesn't matter if the\n-        // value is immutable.\n-        return NodeUtil.isImmutableValue(value.getLastChild())\n-            || (locals.apply(value)\n-                && evaluatesToLocalValue(value.getLastChild(), locals));\n-      case Token.COMMA:\n-        return evaluatesToLocalValue(value.getLastChild(), locals);\n-      case Token.AND:\n-      case Token.OR:\n-        return evaluatesToLocalValue(value.getFirstChild(), locals)\n-           && evaluatesToLocalValue(value.getLastChild(), locals);\n-      case Token.HOOK:\n-        return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n-           && evaluatesToLocalValue(value.getLastChild(), locals);\n-      case Token.INC:\n-      case Token.DEC:\n-        if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n-          return evaluatesToLocalValue(value.getFirstChild(), locals);\n-        } else {\n-          return true;\n-        }\n-      case Token.THIS:\n-        return locals.apply(value);\n-      case Token.NAME:\n-        return isImmutableValue(value) || locals.apply(value);\n-      case Token.GETELEM:\n-      case Token.GETPROP:\n-        // There is no information about the locality of object properties.\n-        return locals.apply(value);\n-      case Token.CALL:\n-        return callHasLocalResult(value)\n-            || isToStringMethodCall(value)\n-            || locals.apply(value);\n-      case Token.NEW:\n-        // TODO(nicksantos): This needs to be changed so that it\n-        // returns true iff we're sure the value was never aliased from inside\n-        // the constructor (similar to callHasLocalResult)\n-        return true;\n-      case Token.FUNCTION:\n-      case Token.REGEXP:\n-      case Token.ARRAYLIT:\n-      case Token.OBJECTLIT:\n-        // Literals objects with non-literal children are allowed.\n-        return true;\n-      case Token.IN:\n-        // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n+static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+  switch (value.getType()) {\n+    case Token.ASSIGN:\n+      // A result that is aliased by a non-local name, is the effectively the\n+      // same as returning a non-local name, but this doesn't matter if the\n+      // value is immutable.\n+      return NodeUtil.isImmutableValue(value.getLastChild())\n+              || (locals.apply(value)\n+              && evaluatesToLocalValue(value.getLastChild(), locals));\n+    case Token.COMMA:\n+      return evaluatesToLocalValue(value.getLastChild(), locals);\n+    case Token.HOOK:\n+      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n+              && evaluatesToLocalValue(value.getLastChild(), locals);\n+    case Token.CALL:\n+      return callHasLocalResult(value) || isToStringMethodCall(value)\n+              || locals.apply(value);\n+    case Token.NEW:\n+      return isLocalConstructor(value);\n+    case Token.THIS:\n+    case Token.NAME:\n+    case Token.GETELEM:\n+    case Token.GETPROP:\n+      return locals.apply(value);\n+    case Token.AND:\n+    case Token.OR:\n+      return evaluatesToLocalValue(value.getFirstChild(), locals)\n+              && evaluatesToLocalValue(value.getLastChild(), locals);\n+    case Token.INC:\n+    case Token.DEC:\n+      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+        return evaluatesToLocalValue(value.getFirstChild(), locals);\n+      }\n+      return true;\n+    case Token.FUNCTION:\n+    case Token.REGEXP:\n+    case Token.ARRAYLIT:\n+    case Token.OBJECTLIT:\n+      // Literals objects with non-literal children are allowed.\n+      return true;\n+    case Token.IN:\n+      // TODO(johnlenz): should IN operator be included in #isSimpleOperator?\n+      return true;\n+    default:\n+      // Other op force a local value:\n+      //  x = '' + g (x is now an local string)\n+      //  x -= g (x is now an local number)\n+      if (isAssignmentOp(value) || isSimpleOperator(value)\n+              || isImmutableValue(value)) {\n         return true;\n-      default:\n-        // Other op force a local value:\n-        //  x = '' + g (x is now an local string)\n-        //  x -= g (x is now an local number)\n-        if (isAssignmentOp(value)\n-            || isSimpleOperator(value)\n-            || isImmutableValue(value)) {\n+      }\n+      throw new IllegalStateException(\"Unexpected expression node\" + value\n+              + \"\\n parent:\" + value.getParent());\n+  }\n+}\n+\n+private static boolean isLocalConstructor(Node node) {\n+  Node first = node.getFirstChild();\n+  if (first != null) {\n+    if (first.getType() == Token.FUNCTION) {\n+      Node functionNameNode = NodeUtil.getFunctionNameNode(first);\n+      return functionNameNode == null || !isNativeFunctionName(functionNameNode.getString());\n+    } else {\n+      String className = getClassName(first);\n+      if (className != null && !className.isEmpty()) {\n+        if (isNativeFunctionName(className)) {\n+          return false;\n+        }\n+        String firstChildSource = first.getSourceFileName();\n+        String classSource = first.getLastChild().getSourceFileName();\n+        if (firstChildSource.equals(classSource)) {\n           return true;\n         }\n+        String classBaseName = SourceFile.fromFile(classSource).getName();\n+        return firstChildSource.endsWith(classBaseName);\n+      } else if (first.getType() == Token.NEW) {\n+        return isLocalConstructor(first);\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+/**\n+ * @return Whether the given name is the name of a built-in prototype method.\n+ */\n+private static boolean isNativeFunctionName(String s) {\n+  // Native function names are not prefixed with the \"@__\" symbol used for internal anonymous\n+  // functions.\n+  return (s.startsWith(\"$jscomp$\") && s.contains(\".\"))\n+          || FUNCTION_PROTOTYPE_METHODS.contains(s)\n+          || NATIVE_ARRAY_METHODS.contains(s)\n+          || NATIVE_MATH_METHODS.contains(s)\n+          || NATIVE_NUMBER_METHODS.contains(s)\n+          || NATIVE_OBJECT_METHODS.contains(s)\n+          || NATIVE_STRING_METHODS.contains(s);\n+}\n \n-        throw new IllegalStateException(\n-            \"Unexpected expression node\" + value +\n-            \"\\n parent:\" + value.getParent());\n+/**\n+ * Gets the name of the class defined in the given node.\n+ * @param classNode The node defining the class.\n+ * @return The fully qualified name of the class, or null if it could not be determined.\n+ */\n+private static String getClassName(Node classNode) {\n+  if (classNode == null) {\n+    return null;\n+  }\n+  String className = null;\n+  Node nameNode = NodeUtil.getNameNode(classNode);\n+  if (nameNode == null) {\n+    if (classNode.getType() == Token.CALL) {\n+      // ES6 class with a class name reference.\n+      Node constructor = classNode.getFirstChild();\n+      if (constructor.getType() == Token.GETPROP\n+              && constructor.getLastChild() != null\n+              && constructor.getLastChild().getString().equals(\"name\")) {\n+        className = constructor.getFirstChild().getQualifiedName();\n+      }\n     }\n+  } else {\n+    className = nameNode.getQualifiedName();\n   }\n+  return className;\n+}\n \n   /**\n    * Given the first sibling, this returns the nth",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}