{
    "patch": "        if (thenOp.getType() == elseOp.getType()) {\n          // if(x)a=1;else a=2; -> a=x?1:2;\n          if (NodeUtil.isAssignmentOp(thenOp)) {\n            Node lhs = thenOp.getFirstChild();\n            if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n                !mayEffectMutableState(lhs)) {\n              n.removeChild(cond);\n              Node assignName = thenOp.removeFirstChild();\n              Node thenExpr = thenOp.removeFirstChild();\n              Node elseExpr = elseOp.getLastChild();\n              elseOp.removeChild(elseExpr);\n\n              Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n              Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                                .srcref(thenOp);\n              Node expr = NodeUtil.newExpr(assign);\n              parent.replaceChild(n, expr);\n              reportCodeChange();\n\n              return expr;\n            }\n          }\n        }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n\n      return expr;\n    }\n  }\n\n  private boolean mayEffectMutableState(Node n) {\n    switch (n.getType()) {\n      case Token.INC:\n      case Token.DEC:\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_BITXOR:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_URSH:\n      case Token.DELPROP:\n      case Token.CALL:\n      case Token.NEW:\n      case Token.TYPEOF:\n      case Token.OBJECTLIT:\n      case Token.ARRAYLIT:\n      case Token.FUNCTION:\n      case Token.REGEXP:\n        return true;\n    }\n\n    return false;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..1524d701 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,72 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+        if (thenOp.getType() == elseOp.getType()) {\n+          // if(x)a=1;else a=2; -> a=x?1:2;\n+          if (NodeUtil.isAssignmentOp(thenOp)) {\n+            Node lhs = thenOp.getFirstChild();\n+            if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n+                !mayEffectMutableState(lhs)) {\n+              n.removeChild(cond);\n+              Node assignName = thenOp.removeFirstChild();\n+              Node thenExpr = thenOp.removeFirstChild();\n+              Node elseExpr = elseOp.getLastChild();\n+              elseOp.removeChild(elseExpr);\n+\n+              Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+              Node assign = new Node(thenOp.getType(), assignName, hookNode)\n+                                .srcref(thenOp);\n+              Node expr = NodeUtil.newExpr(assign);\n+              parent.replaceChild(n, expr);\n+              reportCodeChange();\n+\n+              return expr;\n+            }\n+          }\n+        }\n+      }\n+      // if(x)foo();else bar(); -> x?foo():bar()\n+      n.removeChild(cond);\n+      thenOp.detachFromParent();\n+      elseOp.detachFromParent();\n+      Node expr = IR.exprResult(\n+          IR.hook(cond, thenOp, elseOp).srcref(n));\n+      parent.replaceChild(n, expr);\n+      reportCodeChange();\n+\n+      return expr;\n+    }\n+  }\n+\n+  private boolean mayEffectMutableState(Node n) {\n+    switch (n.getType()) {\n+      case Token.INC:\n+      case Token.DEC:\n+      case Token.ASSIGN:\n+      case Token.ASSIGN_ADD:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_DIV:\n+      case Token.ASSIGN_MOD:\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_BITXOR:\n+      case Token.ASSIGN_BITAND:\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_URSH:\n+      case Token.DELPROP:\n+      case Token.CALL:\n+      case Token.NEW:\n+      case Token.TYPEOF:\n+      case Token.OBJECTLIT:\n+      case Token.ARRAYLIT:\n+      case Token.FUNCTION:\n+      case Token.REGEXP:\n+        return true;\n+    }\n+\n+    return false;\n+  }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}