{
    "patch": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n    \n    clearResult();\n    \n    // Verify initial guess is within the bounds.\n    verifySequence(min, initial, max);\n\n    double y0 = f.value(initial);\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n\n    if (yMin * yMax >= 0) { // Endpoints do not bracket a root.\n        \n        if (yMin == 0.0) {\n            setResult(min, 0);\n            \n        } else if (yMax == 0.0) {\n            setResult(max, 0);\n            \n        } else {\n            final String errorMsg = String.format(\"Interval [%s, %s] does not bracket a root\", min, max);\n            throw new IllegalArgumentException(errorMsg);\n        }\n        \n        return result;\n        \n    } else if (Math.abs(y0) <= functionValueAccuracy) { // Initial guess is already a root.\n        \n        setResult(initial, 0);\n        return result;\n        \n    }\n\n    double d = 0.0; // Distance between last two bounding points.\n    double x0 = initial;\n    double y1 = yMax;\n    double x1 = max;\n    double y2;\n\n    while (true) {\n\n        if (yMax * y0 > 0.0) { // Update bounding endpoints.\n            yMax = y0;\n            x1 = x0;\n        } else {\n            yMin = y0;\n        }\n\n        if (Math.abs(yMin - yMax) <= functionValueAccuracy) { // Absolute accuracy of root found.\n            setResult(0.5 * (x1 + x0), d);\n            return result;\n        }\n\n        // Compute a new sequence (Brent's method).\n        if (y1 * y0 < 0.0) {\n            y2 = y1;\n            double x2 = x1;\n            y1 = y0;\n            x1 = x0;\n\n            double denom = (y1 - y2);\n            double xm = 0.5 * (x1 + x2);\n\n            if (denom != 0.0) {\n                final double s = y1 * (x1 - x2) / denom;\n                final double t = y0 * (x0 - x1) / denom;\n                final double p = t * (s * (t - s * (x1 - x2)) - (1.0 - s) * (y1 - y2));\n                d = s * (y0 - y2) * (y2 - y1) / denom;\n\n                if (p > 0.0) {\n                    x0 = x1;\n                    y0 = y1;\n                    x1 += d;\n                } else {\n                    x0 += d;\n                }\n\n            } else {\n                d = x0 - x1;\n                x0 = x1;\n                y0 = y1;\n                x1 += d;\n            }\n\n        } else {\n            y2 = y1;\n            y1 = y0;\n            double x2 = x1;\n            x1 = x0;\n            d = x2 - x1;\n            x0 = x2;\n        }\n\n        // Compute the next function evaluation.\n        y0 = f.value(x0);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..81ef252e5 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,49 +95,104 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n+public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n+    \n+    clearResult();\n+    \n+    // Verify initial guess is within the bounds.\n+    verifySequence(min, initial, max);\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+    double y0 = f.value(initial);\n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n \n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n+    if (yMin * yMax >= 0) { // Endpoints do not bracket a root.\n+        \n+        if (yMin == 0.0) {\n+            setResult(min, 0);\n+            \n+        } else if (yMax == 0.0) {\n+            setResult(max, 0);\n+            \n+        } else {\n+            final String errorMsg = String.format(\"Interval [%s, %s] does not bracket a root\", min, max);\n+            throw new IllegalArgumentException(errorMsg);\n         }\n+        \n+        return result;\n+        \n+    } else if (Math.abs(y0) <= functionValueAccuracy) { // Initial guess is already a root.\n+        \n+        setResult(initial, 0);\n+        return result;\n+        \n+    }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+    double d = 0.0; // Distance between last two bounding points.\n+    double x0 = initial;\n+    double y1 = yMax;\n+    double x1 = max;\n+    double y2;\n+\n+    while (true) {\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+        if (yMax * y0 > 0.0) { // Update bounding endpoints.\n+            yMax = y0;\n+            x1 = x0;\n+        } else {\n+            yMin = y0;\n         }\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+        if (Math.abs(yMin - yMax) <= functionValueAccuracy) { // Absolute accuracy of root found.\n+            setResult(0.5 * (x1 + x0), d);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        // Compute a new sequence (Brent's method).\n+        if (y1 * y0 < 0.0) {\n+            y2 = y1;\n+            double x2 = x1;\n+            y1 = y0;\n+            x1 = x0;\n \n+            double denom = (y1 - y2);\n+            double xm = 0.5 * (x1 + x2);\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+            if (denom != 0.0) {\n+                final double s = y1 * (x1 - x2) / denom;\n+                final double t = y0 * (x0 - x1) / denom;\n+                final double p = t * (s * (t - s * (x1 - x2)) - (1.0 - s) * (y1 - y2));\n+                d = s * (y0 - y2) * (y2 - y1) / denom;\n \n+                if (p > 0.0) {\n+                    x0 = x1;\n+                    y0 = y1;\n+                    x1 += d;\n+                } else {\n+                    x0 += d;\n+                }\n+\n+            } else {\n+                d = x0 - x1;\n+                x0 = x1;\n+                y0 = y1;\n+                x1 += d;\n+            }\n+\n+        } else {\n+            y2 = y1;\n+            y1 = y0;\n+            double x2 = x1;\n+            x1 = x0;\n+            d = x2 - x1;\n+            x0 = x2;\n+        }\n+\n+        // Compute the next function evaluation.\n+        y0 = f.value(x0);\n     }\n+}\n \n     /**\n      * Find a zero in the given interval.",
    "result_reason": "error: no suitable method found for setResult(double,double)",
    "test_result": "ERROR"
}