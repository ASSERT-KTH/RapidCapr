{
    "patch": "    void replace() {\n      if (firstNode == null) {\n        // Don't touch the base case ('goog').\n        replacementNode = candidateDefinition;\n        return;\n      }\n\n      // Handle the case where there is a duplicate definition for an explicitly\n      // provided symbol.\n      if (candidateDefinition != null && explicitNode != null) {\n        explicitNode.detachFromParent();\n        compiler.reportCodeChange();\n\n        // Does this need a VAR keyword?\n        replacementNode = candidateDefinition;\n        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n          Node assignNode = candidateDefinition.getFirstChild();\n          Node nameNode = assignNode.getFirstChild();\n          if (nameNode.getType() == Token.NAME) {\n            // Need to convert this assign to a var declaration.\n            Node valueNode = nameNode.getNext();\n            assignNode.removeChild(nameNode);\n            assignNode.removeChild(valueNode);\n            Node varNode = new Node(Token.VAR, assignNode);\n            Node varNameNode = nameNode.cloneNode();\n            varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n            varNode.copyInformationFrom(candidateDefinition);\n            varNode.AddChildrenToFront(varNameNode);\n            varNode.AddChildrenToBack(valueNode);\n            candidateDefinition.getParent().replaceChild(\n                candidateDefinition, varNode);\n            compiler.reportCodeChange();\n            replacementNode = varNode;\n          }\n        }\n      } else {\n        // Handle the case where there's not a duplicate definition.\n        replacementNode = createDeclarationNode();\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n          int indexOfDot = namespace.indexOf('.');\n          if (indexOfDot == -1) {\n            // Any old place is fine.\n            Node insertionPoint = compiler.getNodeForCodeInsertion(minimumModule);\n            if (!insertionPoint.hasChildren()) {\n              insertionPoint.addChildToBack(replacementNode);\n            } else {\n              insertionPoint.addChildAfter(replacementNode, insertionPoint.getFirstChild());\n            }\n          } else {\n            // Add it after the parent namespace.\n            ProvidedName parentName =\n                providedNames.get(namespace.substring(0, indexOfDot));\n            Preconditions.checkNotNull(parentName);\n            Preconditions.checkNotNull(parentName.replacementNode);\n            Node insertionPoint = parentName.replacementNode.getParent();\n            if (!insertionPoint.hasChildren()) {\n              insertionPoint.addChildToBack(replacementNode);\n            } else {\n              insertionPoint.addChildAfter(replacementNode, parentName.replacementNode);\n            }\n          }\n        }\n        if (explicitNode != null) {\n          explicitNode.detachFromParent();\n        }\n        compiler.reportCodeChange();\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex c929a363..2548d1f5 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -768,12 +768,14 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n             Node valueNode = nameNode.getNext();\n             assignNode.removeChild(nameNode);\n             assignNode.removeChild(valueNode);\n-            nameNode.addChildToFront(valueNode);\n-            Node varNode = new Node(Token.VAR, nameNode);\n+            Node varNode = new Node(Token.VAR, assignNode);\n+            Node varNameNode = nameNode.cloneNode();\n+            varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n             varNode.copyInformationFrom(candidateDefinition);\n+            varNode.AddChildrenToFront(varNameNode);\n+            varNode.AddChildrenToBack(valueNode);\n             candidateDefinition.getParent().replaceChild(\n                 candidateDefinition, varNode);\n-            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n             compiler.reportCodeChange();\n             replacementNode = varNode;\n           }\n@@ -789,16 +791,24 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n           int indexOfDot = namespace.indexOf('.');\n           if (indexOfDot == -1) {\n             // Any old place is fine.\n-            compiler.getNodeForCodeInsertion(minimumModule)\n-                .addChildToBack(replacementNode);\n+            Node insertionPoint = compiler.getNodeForCodeInsertion(minimumModule);\n+            if (!insertionPoint.hasChildren()) {\n+              insertionPoint.addChildToBack(replacementNode);\n+            } else {\n+              insertionPoint.addChildAfter(replacementNode, insertionPoint.getFirstChild());\n+            }\n           } else {\n             // Add it after the parent namespace.\n             ProvidedName parentName =\n                 providedNames.get(namespace.substring(0, indexOfDot));\n             Preconditions.checkNotNull(parentName);\n             Preconditions.checkNotNull(parentName.replacementNode);\n-            parentName.replacementNode.getParent().addChildAfter(\n-                replacementNode, parentName.replacementNode);\n+            Node insertionPoint = parentName.replacementNode.getParent();\n+            if (!insertionPoint.hasChildren()) {\n+              insertionPoint.addChildToBack(replacementNode);\n+            } else {\n+              insertionPoint.addChildAfter(replacementNode, parentName.replacementNode);\n+            }\n           }\n         }\n         if (explicitNode != null) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}