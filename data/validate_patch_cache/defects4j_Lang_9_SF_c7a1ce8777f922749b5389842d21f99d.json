{
    "patch": "import java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\npublic class SimpleDateFormat {\n    private String pattern;\n    private TimeZone timeZone;\n    private Locale locale;\n    private transient Calendar calendar;\n    private transient int thisYear;\n    private transient ConcurrentHashMap<Integer, KeyValue[]> nameValues;\n    private transient String[] eras;\n    private transient String[] months;\n    private transient String[] shortMonths;\n    private transient String[] weekdays;\n    private transient String[] shortWeekdays;\n    private transient String[] AmPmStrings;\n    private transient char zeroDigit;\n    private transient char minusSign;\n    private transient String currentFormatField;\n    private transient Strategy[] strategies;\n    private transient Pattern formatPattern;\n    private transient String decimalSeparator;\n    private transient String groupingSeparator;\n    private transient char dateSeparator;\n    private transient char timeSeparator;\n    private transient char dateTimeSeparator;    \n    private transient Date defaultCenturyStart;\n\n    // Define and Initialize only once the default century start date : January 1, 2000\n    private static final Date DEFAULT_CENTURY_START;\n    static {\n        Calendar calendar = Calendar.getInstance();\n        calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        DEFAULT_CENTURY_START = calendar.getTime();\n    }\n\n    public SimpleDateFormat() {}\n\n    public SimpleDateFormat(String pattern) {\n        this(pattern, Locale.getDefault());\n    }\n\n    public SimpleDateFormat(String pattern, Locale locale) {\n        this(pattern, locale, TimeZone.getDefault());\n    }\n\n    public SimpleDateFormat(String pattern, Locale locale, TimeZone timeZone) {\n        this.pattern= pattern;\n        this.timeZone= timeZone;\n        this.locale= locale;\n        initialize();\n    }\n\n    protected void initialize() {\n        formatPattern= Pattern.compile(\n          \"\\\\\\\\[uUyYwWdDhHsSaKkzZ]{1}|\\\\\\\\[bB]{1,}|[GMdFEaHkKhmsSzZXwWyYuU]\");\n\n        calendar= Calendar.getInstance(timeZone, locale);\n\n        eras= new String[] {\"\"};\n        months= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n        shortMonths= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n        weekdays= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n        shortWeekdays= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n        AmPmStrings= new String[] {\"\", \"\"};\n        zeroDigit= '0';\n        minusSign= '-';\n        groupingSeparator= \",\";\n        decimalSeparator= \".\";\n        dateSeparator= '/';\n        timeSeparator= ':';\n        dateTimeSeparator= ' ';\n\n        init();\n    }\n\n    private void init() {\n        thisYear= calendar.get(Calendar.YEAR);\n\n        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n\n        StringBuilder regex= new StringBuilder();\n        List<Strategy> collector = new ArrayList<Strategy>();\n\n        Matcher patternMatcher= formatPattern.matcher(pattern);\n        if(!patternMatcher.lookingAt()) {\n            throw new IllegalArgumentException(\"Invalid pattern\");\n        }\n\n        currentFormatField= patternMatcher.group();\n        Strategy currentStrategy= getStrategy(currentFormatField);\n        for(;;) {\n            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n            if(!patternMatcher.lookingAt()) {\n                nextStrategy = null;\n                break;\n            }\n            String nextFormatField= patternMatcher.group();\n            nextStrategy = getStrategy(nextFormatField);\n            if(currentStrategy.addRegex(this, regex)) {\n                collector.add(currentStrategy);\n            }\n            currentFormatField= nextFormatField;\n            currentStrategy= nextStrategy;\n        }\n        if(currentStrategy.addRegex(this, regex)) {\n            collector.add(currentStrategy);\n        }\n        currentFormatField= null;\n        strategies= collector.toArray(new Strategy[collector.size()]);\n        parsePattern= Pattern.compile(regex.toString());\n\n        // Initialize defaultCenturyStart field\n        defaultCenturyStart = DEFAULT_CENTURY_START;\n    }\n\n    private Strategy nextStrategy; // Set by previous call to addRegex\n    Strategy getStrategy(String formatField) {\n        final Strategy strategy;\n        switch (formatField.charAt(0)) {\n            case 'G':\n                strategy= new GStrategy();\n                break;\n            case 'y':\n                if(formatField.length() == 2) {\n                    strategy= new SimpleDateFormat.YearStrategy();\n                }\n                else {\n                    strategy= new SimpleDateFormat.YearInEraStrategy();\n                }\n                break;\n            case 'M':\n            case 'L':\n                strategy= new SimpleDateFormat.MonthStrategy();\n                break;\n            case 'D':\n            case 'd':\n            case 'F':\n            case 'E':\n                strategy= new SimpleDateFormat.DayInYearStrategy();\n                break;\n            case 'w':\n            case 'W':\n                strategy= new SimpleDateFormat.WeekInMonthStrategy();\n                break;\n            case 'a':\n            case 'H':\n            case 'k':\n            case 'K':\n            case 'h':\n            case 'm':\n            case 's':\n                strategy= new SimpleDateFormat.TimeStrategy();\n                break;\n            case 'S':\n                strategy= new SimpleDateFormat.MillisecondStrategy();\n                break;\n            case 'z':\n            case 'Z':\n            case 'X':\n                strategy= new SimpleDateFormat.TimeZoneStrategy();\n                break;\n            default:\n                strategy= null;\n                break;\n        }\n        return strategy;\n    }\n\n    //...\n\n    private static final class KeyValue {\n        final int key;\n        final String value;\n        KeyValue(int key, String value) {\n            this.key= key;\n            this.value= value;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 8df302f9..8c8418b7 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -112,8 +112,87 @@ public class FastDateParser implements DateParser, Serializable {\n      * Initialize derived fields from defining fields.\n      * This is called from constructor and from readObject (de-serialization)\n      */\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+public class SimpleDateFormat {\n+    private String pattern;\n+    private TimeZone timeZone;\n+    private Locale locale;\n+    private transient Calendar calendar;\n+    private transient int thisYear;\n+    private transient ConcurrentHashMap<Integer, KeyValue[]> nameValues;\n+    private transient String[] eras;\n+    private transient String[] months;\n+    private transient String[] shortMonths;\n+    private transient String[] weekdays;\n+    private transient String[] shortWeekdays;\n+    private transient String[] AmPmStrings;\n+    private transient char zeroDigit;\n+    private transient char minusSign;\n+    private transient String currentFormatField;\n+    private transient Strategy[] strategies;\n+    private transient Pattern formatPattern;\n+    private transient String decimalSeparator;\n+    private transient String groupingSeparator;\n+    private transient char dateSeparator;\n+    private transient char timeSeparator;\n+    private transient char dateTimeSeparator;    \n+    private transient Date defaultCenturyStart;\n+\n+    // Define and Initialize only once the default century start date : January 1, 2000\n+    private static final Date DEFAULT_CENTURY_START;\n+    static {\n+        Calendar calendar = Calendar.getInstance();\n+        calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        DEFAULT_CENTURY_START = calendar.getTime();\n+    }\n+\n+    public SimpleDateFormat() {}\n+\n+    public SimpleDateFormat(String pattern) {\n+        this(pattern, Locale.getDefault());\n+    }\n+\n+    public SimpleDateFormat(String pattern, Locale locale) {\n+        this(pattern, locale, TimeZone.getDefault());\n+    }\n+\n+    public SimpleDateFormat(String pattern, Locale locale, TimeZone timeZone) {\n+        this.pattern= pattern;\n+        this.timeZone= timeZone;\n+        this.locale= locale;\n+        initialize();\n+    }\n+\n+    protected void initialize() {\n+        formatPattern= Pattern.compile(\n+          \"\\\\\\\\[uUyYwWdDhHsSaKkzZ]{1}|\\\\\\\\[bB]{1,}|[GMdFEaHkKhmsSzZXwWyYuU]\");\n+\n+        calendar= Calendar.getInstance(timeZone, locale);\n+\n+        eras= new String[] {\"\"};\n+        months= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n+        shortMonths= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n+        weekdays= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n+        shortWeekdays= new String[] {\"\", \"\", \"\", \"\", \"\", \"\", \"\"};\n+        AmPmStrings= new String[] {\"\", \"\"};\n+        zeroDigit= '0';\n+        minusSign= '-';\n+        groupingSeparator= \",\";\n+        decimalSeparator= \".\";\n+        dateSeparator= '/';\n+        timeSeparator= ':';\n+        dateTimeSeparator= ' ';\n+\n+        init();\n+    }\n+\n     private void init() {\n-        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n+        thisYear= calendar.get(Calendar.YEAR);\n \n         nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n \n@@ -147,8 +226,76 @@ public class FastDateParser implements DateParser, Serializable {\n         currentFormatField= null;\n         strategies= collector.toArray(new Strategy[collector.size()]);\n         parsePattern= Pattern.compile(regex.toString());\n+\n+        // Initialize defaultCenturyStart field\n+        defaultCenturyStart = DEFAULT_CENTURY_START;\n     }\n \n+    private Strategy nextStrategy; // Set by previous call to addRegex\n+    Strategy getStrategy(String formatField) {\n+        final Strategy strategy;\n+        switch (formatField.charAt(0)) {\n+            case 'G':\n+                strategy= new GStrategy();\n+                break;\n+            case 'y':\n+                if(formatField.length() == 2) {\n+                    strategy= new SimpleDateFormat.YearStrategy();\n+                }\n+                else {\n+                    strategy= new SimpleDateFormat.YearInEraStrategy();\n+                }\n+                break;\n+            case 'M':\n+            case 'L':\n+                strategy= new SimpleDateFormat.MonthStrategy();\n+                break;\n+            case 'D':\n+            case 'd':\n+            case 'F':\n+            case 'E':\n+                strategy= new SimpleDateFormat.DayInYearStrategy();\n+                break;\n+            case 'w':\n+            case 'W':\n+                strategy= new SimpleDateFormat.WeekInMonthStrategy();\n+                break;\n+            case 'a':\n+            case 'H':\n+            case 'k':\n+            case 'K':\n+            case 'h':\n+            case 'm':\n+            case 's':\n+                strategy= new SimpleDateFormat.TimeStrategy();\n+                break;\n+            case 'S':\n+                strategy= new SimpleDateFormat.MillisecondStrategy();\n+                break;\n+            case 'z':\n+            case 'Z':\n+            case 'X':\n+                strategy= new SimpleDateFormat.TimeZoneStrategy();\n+                break;\n+            default:\n+                strategy= null;\n+                break;\n+        }\n+        return strategy;\n+    }\n+\n+    //...\n+\n+    private static final class KeyValue {\n+        final int key;\n+        final String value;\n+        KeyValue(int key, String value) {\n+            this.key= key;\n+            this.value= value;\n+        }\n+    }\n+}\n+\n     // Accessors\n     //-----------------------------------------------------------------------\n     /* (non-Javadoc)",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}