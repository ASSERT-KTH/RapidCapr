{
    "patch": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n\n      // Get the parent block of the try-catch block\n      Node parentBlock = n;\n      while(!parentBlock.isBlock()) {\n        parentBlock = parentBlock.getParent();\n      }\n\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n\n        // Get the end node of the try block\n        Node endNode = NodeUtil.getTryBlockEnd(n);\n\n        // Try to determine if it is safe to remove the catch block,\n        // applying the following rules:\n        //   - the catch block must not exit\n        //   - the catch block must not contain a reference to any parameter passed to the function\n        boolean isSafeToRemoveCatchBlock = !NodeUtil.NodeTraversal.traverse(compiler, catchCodeBlock,\n          new NodeUtil.MatchShallowStatement(), new NodeUtil.MatchAllExitPoints()).hasMatched();\n\n        if(isSafeToRemoveCatchBlock && usesOnlyUnreferencedCatchParameters(catchNode, tryBlock, endNode)) {\n          NodeUtil.removeChild(n, allCatchNodes);\n          compiler.reportCodeChange();\n          return;\n        } else {\n          tryMinimizeExits(catchCodeBlock, exitType, labelName);\n        }\n      }\n\n      /* Don't try to minimize the exits of finally blocks, as this\n       * can cause problems if it changes the completion type of the finally\n       * block. See ECMA 262 Sections 8.9 & 12.14\n       */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock, exitType, labelName);\n\n        if(isEmptyBlock(finallyBlock)) {\n          NodeUtil.removeChild(n, finallyBlock);\n          parentBlock.removeChildAfter(n);\n          // If the try block is now empty, remove it\n          if(isEmptyBlock(tryBlock)) {\n            NodeUtil.removeChild(parentBlock, n);\n          }\n          compiler.reportCodeChange();\n        }\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n\n  /**\n   * Determine if the provided catch block uses only unreferenced parameters\n   */\n  private boolean usesOnlyUnreferencedCatchParameters(\n      Node catchNode, Node tryBlock, Node endNode) {\n    // Optimization: if the catch node doesn't have any siblings, then it's guaranteed\n    // to use only unreferenced parameters.\n    if(!catchNode.hasMoreThanOneChild()) {\n      return true;\n    }\n\n    int nCatchParams = catchNode.getChildCount() - 1;\n    int nUsedParams = 0;\n    int[] usedParamIDs = new int[nCatchParams];\n    for (int i = 0; i < nCatchParams; i++) {\n      Node catchParam = catchNode.getChildAt(i);\n      if (catchParam.isDefaultValue()) {\n        catchParam = catchParam.getFirstChild();\n      }\n      // Skip the parameter identifier\n      catchParam = catchParam.getLastChild();\n\n      boolean foundUse = NodeUtil.NodeTraversal.traverse(compiler, tryBlock, new FindParametersInUse(catchParam))\n        .hasMatched()\n        || NodeUtil.NodeTraversal.traverse(compiler, endNode, new FindParametersInUse(catchParam))\n        .hasMatched();\n      if(foundUse) {\n        usedParamIDs[nUsedParams++] = i;\n      }\n    }\n\n    // If all parameters are unused, then we can remove the whole catch block.\n    return nUsedParams == 0;\n  }\n\n  /**\n   * Ask if the given block or its descendents is empty.\n   */\n  private boolean isEmptyBlock(Node blockNode) {\n    for(Node child : blockNode.children()) {\n      if(!child.isEmpty()) {\n        return false;\n      }\n    }\n    return true;\n  }\n\n  /**\n   * Find a condition that would break from this block\n   * and simplify the surrounding block.\n   */\n  private void tryMinimizeIfBlockExits(Node trueBlock, Node falseBlock,\n                                        Node ifBlock, int exitType, String labelName) {\n    tryMinimizeExits(trueBlock, exitType, labelName);\n\n    // Try to extract a 'if (condition) [break;] else' pattern.\n    if (falseBlock != null && falseBlock.isCollapse()) {\n      // Only try this if falseBlock is collapsible.\n      //   if (cond) { ... } else { }\n      List<Node> children = falseBlock.removeChildren();\n      Preconditions.checkState(children.isEmpty());\n      IfStatement ifStatement = matchSimpleIf(ifBlock);\n      if (ifStatement != null) {\n        Node predicate = ifStatement.getCondition();\n        Node assignment = NodeUtil.getAssignedValue(predicate);\n        if (assignment != null) {\n          predicate = assignment;\n        }\n        Node newCondition = new Node(Token.NOT, predicate);\n        newCondition.useSourceInfoFrom(predicate);\n        Node newIf = new Node(Token.IF, newCondition);\n        newIf.useSourceInfoFrom(predicate);\n\n        // Move the falseBlock Nodes to the end of the then block.\n        for (Node child : children) {\n          if (!child.isEmpty()) {\n            newIf.addChildToBack(child);\n          }\n        }\n        if (newIf.hasChildren()) {\n          NodeUtil.replaceChild(ifBlock.getParent(), ifBlock, newIf);\n          compiler.reportCodeChange();\n        }\n      }\n    }\n\n    tryMinimizeExits(falseBlock, exitType, labelName);\n  }\n\n  /**\n   * A visitor to determine if an identifier node is referenced in the given scope\n   */\n  private static class FindParametersInUse extends AbstractShallowStatementCallback {\n\n    private final Node param;\n\n    private FindParametersInUse(Node param) {\n      this.param = param;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node node, Node parent) {\n      if (node.matchesQualifiedName(param.getString())) {\n        t.reportMatch(node);\n      }\n    }\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n      return !NodeUtil.isControlStructure(n) && !n.isFunction();\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..4f3e172e 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -125,6 +125,13 @@ class MinimizeExitPoints\n \n     // Just a 'try/catch/finally'.\n     if (n.isTry()) {\n+\n+      // Get the parent block of the try-catch block\n+      Node parentBlock = n;\n+      while(!parentBlock.isBlock()) {\n+        parentBlock = parentBlock.getParent();\n+      }\n+\n       Node tryBlock = n.getFirstChild();\n       tryMinimizeExits(tryBlock, exitType, labelName);\n       Node allCatchNodes = NodeUtil.getCatchBlock(n);\n@@ -132,8 +139,26 @@ class MinimizeExitPoints\n         Preconditions.checkState(allCatchNodes.hasOneChild());\n         Node catchNode = allCatchNodes.getFirstChild();\n         Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n+\n+        // Get the end node of the try block\n+        Node endNode = NodeUtil.getTryBlockEnd(n);\n+\n+        // Try to determine if it is safe to remove the catch block,\n+        // applying the following rules:\n+        //   - the catch block must not exit\n+        //   - the catch block must not contain a reference to any parameter passed to the function\n+        boolean isSafeToRemoveCatchBlock = !NodeUtil.NodeTraversal.traverse(compiler, catchCodeBlock,\n+          new NodeUtil.MatchShallowStatement(), new NodeUtil.MatchAllExitPoints()).hasMatched();\n+\n+        if(isSafeToRemoveCatchBlock && usesOnlyUnreferencedCatchParameters(catchNode, tryBlock, endNode)) {\n+          NodeUtil.removeChild(n, allCatchNodes);\n+          compiler.reportCodeChange();\n+          return;\n+        } else {\n+          tryMinimizeExits(catchCodeBlock, exitType, labelName);\n+        }\n       }\n+\n       /* Don't try to minimize the exits of finally blocks, as this\n        * can cause problems if it changes the completion type of the finally\n        * block. See ECMA 262 Sections 8.9 & 12.14\n@@ -141,6 +166,16 @@ class MinimizeExitPoints\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n         tryMinimizeExits(finallyBlock, exitType, labelName);\n+\n+        if(isEmptyBlock(finallyBlock)) {\n+          NodeUtil.removeChild(n, finallyBlock);\n+          parentBlock.removeChildAfter(n);\n+          // If the try block is now empty, remove it\n+          if(isEmptyBlock(tryBlock)) {\n+            NodeUtil.removeChild(parentBlock, n);\n+          }\n+          compiler.reportCodeChange();\n+        }\n       }\n     }\n \n@@ -200,6 +235,119 @@ class MinimizeExitPoints\n     }\n   }\n \n+  /**\n+   * Determine if the provided catch block uses only unreferenced parameters\n+   */\n+  private boolean usesOnlyUnreferencedCatchParameters(\n+      Node catchNode, Node tryBlock, Node endNode) {\n+    // Optimization: if the catch node doesn't have any siblings, then it's guaranteed\n+    // to use only unreferenced parameters.\n+    if(!catchNode.hasMoreThanOneChild()) {\n+      return true;\n+    }\n+\n+    int nCatchParams = catchNode.getChildCount() - 1;\n+    int nUsedParams = 0;\n+    int[] usedParamIDs = new int[nCatchParams];\n+    for (int i = 0; i < nCatchParams; i++) {\n+      Node catchParam = catchNode.getChildAt(i);\n+      if (catchParam.isDefaultValue()) {\n+        catchParam = catchParam.getFirstChild();\n+      }\n+      // Skip the parameter identifier\n+      catchParam = catchParam.getLastChild();\n+\n+      boolean foundUse = NodeUtil.NodeTraversal.traverse(compiler, tryBlock, new FindParametersInUse(catchParam))\n+        .hasMatched()\n+        || NodeUtil.NodeTraversal.traverse(compiler, endNode, new FindParametersInUse(catchParam))\n+        .hasMatched();\n+      if(foundUse) {\n+        usedParamIDs[nUsedParams++] = i;\n+      }\n+    }\n+\n+    // If all parameters are unused, then we can remove the whole catch block.\n+    return nUsedParams == 0;\n+  }\n+\n+  /**\n+   * Ask if the given block or its descendents is empty.\n+   */\n+  private boolean isEmptyBlock(Node blockNode) {\n+    for(Node child : blockNode.children()) {\n+      if(!child.isEmpty()) {\n+        return false;\n+      }\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Find a condition that would break from this block\n+   * and simplify the surrounding block.\n+   */\n+  private void tryMinimizeIfBlockExits(Node trueBlock, Node falseBlock,\n+                                        Node ifBlock, int exitType, String labelName) {\n+    tryMinimizeExits(trueBlock, exitType, labelName);\n+\n+    // Try to extract a 'if (condition) [break;] else' pattern.\n+    if (falseBlock != null && falseBlock.isCollapse()) {\n+      // Only try this if falseBlock is collapsible.\n+      //   if (cond) { ... } else { }\n+      List<Node> children = falseBlock.removeChildren();\n+      Preconditions.checkState(children.isEmpty());\n+      IfStatement ifStatement = matchSimpleIf(ifBlock);\n+      if (ifStatement != null) {\n+        Node predicate = ifStatement.getCondition();\n+        Node assignment = NodeUtil.getAssignedValue(predicate);\n+        if (assignment != null) {\n+          predicate = assignment;\n+        }\n+        Node newCondition = new Node(Token.NOT, predicate);\n+        newCondition.useSourceInfoFrom(predicate);\n+        Node newIf = new Node(Token.IF, newCondition);\n+        newIf.useSourceInfoFrom(predicate);\n+\n+        // Move the falseBlock Nodes to the end of the then block.\n+        for (Node child : children) {\n+          if (!child.isEmpty()) {\n+            newIf.addChildToBack(child);\n+          }\n+        }\n+        if (newIf.hasChildren()) {\n+          NodeUtil.replaceChild(ifBlock.getParent(), ifBlock, newIf);\n+          compiler.reportCodeChange();\n+        }\n+      }\n+    }\n+\n+    tryMinimizeExits(falseBlock, exitType, labelName);\n+  }\n+\n+  /**\n+   * A visitor to determine if an identifier node is referenced in the given scope\n+   */\n+  private static class FindParametersInUse extends AbstractShallowStatementCallback {\n+\n+    private final Node param;\n+\n+    private FindParametersInUse(Node param) {\n+      this.param = param;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node node, Node parent) {\n+      if (node.matchesQualifiedName(param.getString())) {\n+        t.reportMatch(node);\n+      }\n+    }\n+\n+    @Override\n+    public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n+      return !NodeUtil.isControlStructure(n) && !n.isFunction();\n+    }\n+  }\n+\n   /**\n    * Look for exits (returns, breaks, or continues, depending on the context) at\n    * the end of a block and removes them by moving the if node's siblings,",
    "result_reason": "error: method tryMinimizeIfBlockExits(Node,Node,Node,int,String) is already defined in class MinimizeExitPoints",
    "test_result": "ERROR"
}