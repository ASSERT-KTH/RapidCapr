{
    "patch": "public void integrate(final ExpandableStatefulODE equations, final double t)\n      throws MathIllegalStateException, MathIllegalArgumentException {\n\n    // perform sanity checks on input\n    sanityChecks(equations, t);\n\n    // set up integrator\n    setEquations(equations);\n    final double[] y0 = equations.getCompleteState();\n    final int dim = y0.length;\n    final double[] y = y0.clone();\n\n    // initialize arrays\n    final int stages = getC().length + 1;\n    final double[][] yDotK = new double[stages][dim];\n    final double[] yTmp = y0.clone();\n    final double[] yDotTmp = new double[dim];\n\n    // set up interpolator\n    final RungeKuttaStepInterpolator interpolator =\n        (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, true, equations.getPrimaryMapper(),\n                               equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    double hNew = 0;\n    boolean forward = t > equations.getTime();\n    initIntegration(equations.getTime(), y0, t);\n\n    while (!isLastStep()) {\n\n        interpolator.shift();\n\n        boolean firstTime = isFirstStep();\n        if (firstTime) {\n            // special case for first step\n            hNew = initializeStep(forward, getOrder(), getScale(), getStepStart(), y, yDotK[0], yTmp,\n                                   yDotK[1]);\n            setStepSize(hNew);\n        } else {\n            // retrieve stepsize from previous step\n            hNew = getStepSize();\n        }\n\n        // iterate over step\n        double error = 10.0;\n        while (error >= 1.0) {\n\n            // compute derivatives\n            if (firstTime || !isFSAL()) {\n                computeDerivatives(getStepStart(), y, yDotK[0]);\n            }\n\n            // step\n            for(int k = 1; k < stages; ++k) {\n                computeStage(k, getStepStart(), y, yDotK, yTmp, getStepSize());\n            }\n\n            // estimate solution\n            update(y, yTmp, yDotK, getStepSize());\n            error = estimateError(y, yTmp, yDotK, getStepSize());\n            if (error >= 1.0) {\n                // stepsize control\n                final double factor =\n                    Math.min(getMaxGrowth(), Math.max(getMinReduction(),\n                                                       getSafety()\n                                                           * Math.pow(error, getExponent())));\n                final double scaledH = getStepSize() * factor;\n                setStepSize(filterStep(forward, getStepStart() + scaledH) - getStepStart());\n            }\n\n        }\n\n        // accept step and prepare for next iteration\n        interpolator.storeTime(getStepStart() + getStepSize());\n        System.arraycopy(yTmp, 0, y, 0, dim);\n        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, dim);\n        double nextStep = acceptStep(interpolator, y, yDotTmp, t);\n        if (!isLastStep()) {\n            // stepsize control for next step\n            final boolean nextIsLast = forward ? nextStep >= t : nextStep <= t;\n            setStepSize(filterStep(forward, nextStep, nextIsLast) - getStepStart());\n        }\n\n    }\n\n    // dispatch results\n    equations.setTime(getStepStart());\n    equations.setCompleteState(y);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..ef37bf0e4 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -188,144 +188,97 @@ public abstract class EmbeddedRungeKuttaIntegrator\n \n   /** {@inheritDoc} */\n   @Override\n-  public void integrate(final ExpandableStatefulODE equations, final double t)\n+public void integrate(final ExpandableStatefulODE equations, final double t)\n       throws MathIllegalStateException, MathIllegalArgumentException {\n \n+    // perform sanity checks on input\n     sanityChecks(equations, t);\n-    setEquations(equations);\n-    final boolean forward = t > equations.getTime();\n \n-    // create some internal working arrays\n-    final double[] y0  = equations.getCompleteState();\n+    // set up integrator\n+    setEquations(equations);\n+    final double[] y0 = equations.getCompleteState();\n+    final int dim = y0.length;\n     final double[] y = y0.clone();\n-    final int stages = c.length + 1;\n-    final double[][] yDotK = new double[stages][y.length];\n-    final double[] yTmp    = y0.clone();\n-    final double[] yDotTmp = new double[y.length];\n-\n-    // set up an interpolator sharing the integrator arrays\n-    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n-    interpolator.reinitialize(this, yTmp, yDotK, forward,\n-                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n+\n+    // initialize arrays\n+    final int stages = getC().length + 1;\n+    final double[][] yDotK = new double[stages][dim];\n+    final double[] yTmp = y0.clone();\n+    final double[] yDotTmp = new double[dim];\n+\n+    // set up interpolator\n+    final RungeKuttaStepInterpolator interpolator =\n+        (RungeKuttaStepInterpolator) prototype.copy();\n+    interpolator.reinitialize(this, yTmp, yDotK, true, equations.getPrimaryMapper(),\n+                               equations.getSecondaryMappers());\n     interpolator.storeTime(equations.getTime());\n \n     // set up integration control objects\n-    stepStart         = equations.getTime();\n-    double  hNew      = 0;\n-    boolean firstTime = true;\n+    double hNew = 0;\n+    boolean forward = t > equations.getTime();\n     initIntegration(equations.getTime(), y0, t);\n \n-    // main integration loop\n-    isLastStep = false;\n-    do {\n+    while (!isLastStep()) {\n \n-      interpolator.shift();\n-\n-      // iterate over step size, ensuring local normalized error is smaller than 1\n-      double error = 10;\n-      while (error >= 1.0) {\n-\n-        if (firstTime || !fsal) {\n-          // first stage\n-          computeDerivatives(stepStart, y, yDotK[0]);\n-        }\n+        interpolator.shift();\n \n+        boolean firstTime = isFirstStep();\n         if (firstTime) {\n-          final double[] scale = new double[mainSetDimension];\n-          if (vecAbsoluteTolerance == null) {\n-              for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n-              }\n-          } else {\n-              for (int i = 0; i < scale.length; ++i) {\n-                scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n-              }\n-          }\n-          hNew = initializeStep(forward, getOrder(), scale,\n-                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n-          firstTime = false;\n+            // special case for first step\n+            hNew = initializeStep(forward, getOrder(), getScale(), getStepStart(), y, yDotK[0], yTmp,\n+                                   yDotK[1]);\n+            setStepSize(hNew);\n+        } else {\n+            // retrieve stepsize from previous step\n+            hNew = getStepSize();\n         }\n \n-        stepSize = hNew;\n+        // iterate over step\n+        double error = 10.0;\n+        while (error >= 1.0) {\n \n-        // next stages\n-        for (int k = 1; k < stages; ++k) {\n-\n-          for (int j = 0; j < y0.length; ++j) {\n-            double sum = a[k-1][0] * yDotK[0][j];\n-            for (int l = 1; l < k; ++l) {\n-              sum += a[k-1][l] * yDotK[l][j];\n+            // compute derivatives\n+            if (firstTime || !isFSAL()) {\n+                computeDerivatives(getStepStart(), y, yDotK[0]);\n             }\n-            yTmp[j] = y[j] + stepSize * sum;\n-          }\n \n-          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+            // step\n+            for(int k = 1; k < stages; ++k) {\n+                computeStage(k, getStepStart(), y, yDotK, yTmp, getStepSize());\n+            }\n \n-        }\n+            // estimate solution\n+            update(y, yTmp, yDotK, getStepSize());\n+            error = estimateError(y, yTmp, yDotK, getStepSize());\n+            if (error >= 1.0) {\n+                // stepsize control\n+                final double factor =\n+                    Math.min(getMaxGrowth(), Math.max(getMinReduction(),\n+                                                       getSafety()\n+                                                           * Math.pow(error, getExponent())));\n+                final double scaledH = getStepSize() * factor;\n+                setStepSize(filterStep(forward, getStepStart() + scaledH) - getStepStart());\n+            }\n \n-        // estimate the state at the end of the step\n-        for (int j = 0; j < y0.length; ++j) {\n-          double sum    = b[0] * yDotK[0][j];\n-          for (int l = 1; l < stages; ++l) {\n-            sum    += b[l] * yDotK[l][j];\n-          }\n-          yTmp[j] = y[j] + stepSize * sum;\n         }\n \n-        // estimate the error at the end of the step\n-        error = estimateError(yDotK, y, yTmp, stepSize);\n-        if (error >= 1.0) {\n-          // reject the step and attempt to reduce error by stepsize control\n-          final double factor =\n-              FastMath.min(maxGrowth,\n-                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n-          hNew = filterStep(stepSize * factor, forward, false);\n+        // accept step and prepare for next iteration\n+        interpolator.storeTime(getStepStart() + getStepSize());\n+        System.arraycopy(yTmp, 0, y, 0, dim);\n+        System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, dim);\n+        double nextStep = acceptStep(interpolator, y, yDotTmp, t);\n+        if (!isLastStep()) {\n+            // stepsize control for next step\n+            final boolean nextIsLast = forward ? nextStep >= t : nextStep <= t;\n+            setStepSize(filterStep(forward, nextStep, nextIsLast) - getStepStart());\n         }\n \n-      }\n-\n-      // local error is small enough: accept the step, trigger events and step handlers\n-      interpolator.storeTime(stepStart + stepSize);\n-      System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n-      stepStart = acceptStep(interpolator, y, yDotTmp, t);\n-      System.arraycopy(y, 0, yTmp, 0, y.length);\n-\n-      if (!isLastStep) {\n-\n-          // prepare next step\n-          interpolator.storeTime(stepStart);\n-\n-          if (fsal) {\n-              // save the last evaluation for the next step\n-              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n-          }\n-\n-          // stepsize control for next step\n-          final double factor =\n-              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n-          final double  scaledH    = stepSize * factor;\n-          final double  nextT      = stepStart + scaledH;\n-          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n-          hNew = filterStep(scaledH, forward, nextIsLast);\n-\n-          final double  filteredNextT      = stepStart + hNew;\n-          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n-          if (filteredNextIsLast) {\n-              hNew = t - stepStart;\n-          }\n-\n-      }\n-\n-    } while (!isLastStep);\n+    }\n \n     // dispatch results\n-    equations.setTime(stepStart);\n+    equations.setTime(getStepStart());\n     equations.setCompleteState(y);\n-\n-    resetInternalState();\n-\n-  }\n+}\n \n   /** Get the minimal reduction factor for stepsize control.\n    * @return minimal reduction factor",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}