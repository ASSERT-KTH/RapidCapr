{
    "patch": "        double lastMidpoint = initial;\n        int numIterations = 0;\n        double yMid = f.value(lastMidpoint);\n        double yPrev = yInitial;\n        double yTmp;\n\n        while (numIterations++ < maximalIterationCount) {\n            if ((yMid > 0) == (yMin > 0)) {\n                // Midpoint and min bracket the root\n                lastMidpoint = min;\n                yTmp = yMin;\n            } else if ((yMid > 0) == (yMax > 0)) {\n                // Midpoint and max bracket the root\n                lastMidpoint = max;\n                yTmp = yMax;\n            } else {\n                // Midpoint brackets the root\n                setResult(lastMidpoint, 0);\n                return result;\n            }\n            if (numIterations == 1 || Math.abs(lastMidpoint - result) >= 0.5 * Math.abs(result)) {\n                // Bisection required\n                double daringMidpoint = lastMidpoint + 0.5 * (max - min);\n                double yDaring = f.value(daringMidpoint);\n                if (yDaring > 0) {\n                    max = lastMidpoint;\n                    yMax = yTmp;\n                } else {\n                    min = lastMidpoint;\n                    yMin = yTmp;\n                }\n                // next action depends on whether we have just completed a bisection\n                if (numIterations != 1) {\n                    // if we have just completed a bisection, divide the new interval by 2\n                    yPrev /= 2;\n                }\n                lastMidpoint = daringMidpoint;\n                yMid = yDaring;\n            } else {\n                // Attempt interpolation\n                double deltaY = yMid - yPrev;\n                double deltaMid = lastMidpoint - initial;\n                double slope = deltaY / deltaMid;\n                double intercept = yMid - slope * lastMidpoint;\n                double newPoint = -intercept / slope;\n                if (Double.isNaN(newPoint) || Double.isInfinite(newPoint)) {\n                    // Interpolation failed, use bisection\n                    yPrev /= 2;\n                    lastMidpoint = 0.5 * (max + min);\n                    yMid = f.value(lastMidpoint);\n                } else {\n                    // Interpolation succeeded, accept it\n                    double nextStep = newPoint - lastMidpoint;\n                    if (nextStep > 0) {\n                        yPrev *= 0.5;\n                    } else {\n                        yPrev = yMid;\n                        yMid = f.value(newPoint);\n                    }\n                    lastMidpoint = newPoint;\n                }\n            }\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..2afda559d 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,71 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double lastMidpoint = initial;\n+        int numIterations = 0;\n+        double yMid = f.value(lastMidpoint);\n+        double yPrev = yInitial;\n+        double yTmp;\n+\n+        while (numIterations++ < maximalIterationCount) {\n+            if ((yMid > 0) == (yMin > 0)) {\n+                // Midpoint and min bracket the root\n+                lastMidpoint = min;\n+                yTmp = yMin;\n+            } else if ((yMid > 0) == (yMax > 0)) {\n+                // Midpoint and max bracket the root\n+                lastMidpoint = max;\n+                yTmp = yMax;\n+            } else {\n+                // Midpoint brackets the root\n+                setResult(lastMidpoint, 0);\n+                return result;\n+            }\n+            if (numIterations == 1 || Math.abs(lastMidpoint - result) >= 0.5 * Math.abs(result)) {\n+                // Bisection required\n+                double daringMidpoint = lastMidpoint + 0.5 * (max - min);\n+                double yDaring = f.value(daringMidpoint);\n+                if (yDaring > 0) {\n+                    max = lastMidpoint;\n+                    yMax = yTmp;\n+                } else {\n+                    min = lastMidpoint;\n+                    yMin = yTmp;\n+                }\n+                // next action depends on whether we have just completed a bisection\n+                if (numIterations != 1) {\n+                    // if we have just completed a bisection, divide the new interval by 2\n+                    yPrev /= 2;\n+                }\n+                lastMidpoint = daringMidpoint;\n+                yMid = yDaring;\n+            } else {\n+                // Attempt interpolation\n+                double deltaY = yMid - yPrev;\n+                double deltaMid = lastMidpoint - initial;\n+                double slope = deltaY / deltaMid;\n+                double intercept = yMid - slope * lastMidpoint;\n+                double newPoint = -intercept / slope;\n+                if (Double.isNaN(newPoint) || Double.isInfinite(newPoint)) {\n+                    // Interpolation failed, use bisection\n+                    yPrev /= 2;\n+                    lastMidpoint = 0.5 * (max + min);\n+                    yMid = f.value(lastMidpoint);\n+                } else {\n+                    // Interpolation succeeded, accept it\n+                    double nextStep = newPoint - lastMidpoint;\n+                    if (nextStep > 0) {\n+                        yPrev *= 0.5;\n+                    } else {\n+                        yPrev = yMid;\n+                        yMid = f.value(newPoint);\n+                    }\n+                    lastMidpoint = newPoint;\n+                }\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: final parameter max may not be assigned",
    "test_result": "ERROR"
}