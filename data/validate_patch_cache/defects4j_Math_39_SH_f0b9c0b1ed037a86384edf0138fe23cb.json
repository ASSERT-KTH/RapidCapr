{
    "patch": "// set up the accepted state for the next step\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\n\n// set up the derivatives for the next step, using FSAL if possible\nif (fsal) {\n    System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    computeDerivatives(stepStart + hNew, y, yDotK[0]);\n} else {\n    computeDerivatives(stepStart + hNew, y, yDotK[stages - 1]);\n}\n\n// trigger events and step handlers\nstepStart = acceptStep(interpolator, y, yDotK[stages - 1], t);\n\n// prepare next step\ninterpolator.storeTime(stepStart);\n\nif (!isLastStep) {\n    // decide on next step size and FSAL test\n    final double  factor           = computeStepGrowShrinkFactor(error);\n    final double  scaledH          = stepSize * factor;\n    final double  nextT            = stepStart + scaledH;\n    final boolean nextIsLast       = forward ? (nextT >= t) : (nextT <= t);\n    final double  truncationError  = error / factor;\n    final double  optimalStepSize  = computeOptimalStepSize(truncationError, hNew, stepSize, getOrder());\n    final boolean fsalShouldBeUsed = optimalStepSize > stepSize;\n\n    // apply size and FSAL decision to the arrays\n    final double  finalH           = decideStepSize(optimalStepSize, nextIsLast);\n    fsal = fsalShouldBeUsed;\n    if (fsal) {\n        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n    }\n    System.arraycopy(y, 0, yTmp, 0, y0.length);\n    computeDerivatives(stepStart, y, yDotK[0]);\n\n    // update the internal working arrays\n    hNew = finalH;\n    stepSize = finalH;\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(stepStart);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..9c6df24b2 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,49 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+// set up the accepted state for the next step\n+System.arraycopy(yTmp, 0, y, 0, y0.length);\n+\n+// set up the derivatives for the next step, using FSAL if possible\n+if (fsal) {\n+    System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+    computeDerivatives(stepStart + hNew, y, yDotK[0]);\n+} else {\n+    computeDerivatives(stepStart + hNew, y, yDotK[stages - 1]);\n+}\n+\n+// trigger events and step handlers\n+stepStart = acceptStep(interpolator, y, yDotK[stages - 1], t);\n+\n+// prepare next step\n+interpolator.storeTime(stepStart);\n+\n+if (!isLastStep) {\n+    // decide on next step size and FSAL test\n+    final double  factor           = computeStepGrowShrinkFactor(error);\n+    final double  scaledH          = stepSize * factor;\n+    final double  nextT            = stepStart + scaledH;\n+    final boolean nextIsLast       = forward ? (nextT >= t) : (nextT <= t);\n+    final double  truncationError  = error / factor;\n+    final double  optimalStepSize  = computeOptimalStepSize(truncationError, hNew, stepSize, getOrder());\n+    final boolean fsalShouldBeUsed = optimalStepSize > stepSize;\n+\n+    // apply size and FSAL decision to the arrays\n+    final double  finalH           = decideStepSize(optimalStepSize, nextIsLast);\n+    fsal = fsalShouldBeUsed;\n+    if (fsal) {\n+        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n+    }\n+    System.arraycopy(y, 0, yTmp, 0, y0.length);\n+    computeDerivatives(stepStart, y, yDotK[0]);\n+\n+    // update the internal working arrays\n+    hNew = finalH;\n+    stepSize = finalH;\n+    interpolator.reinitialize(this, yTmp, yDotK, forward,\n+                              equations.getPrimaryMapper(), equations.getSecondaryMappers());\n+    interpolator.storeTime(stepStart);\n+}\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}