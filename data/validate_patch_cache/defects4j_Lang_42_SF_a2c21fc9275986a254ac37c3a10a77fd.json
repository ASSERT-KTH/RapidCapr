{
    "patch": "```\npublic void escape(Writer writer, String str) throws IOException {\n    int len = str.length();\n    for (int i = 0; i < len; ) {\n        int codePoint = str.codePointAt(i);\n        i += Character.charCount(codePoint);\n        if (codePoint > 0x7F) {\n            writer.write(\"&#\");\n            writer.write(Integer.toString(codePoint, 10));\n            writer.write(';');\n        } else {\n            String entityName = this.entityName(codePoint);\n            if (entityName != null) {\n                writer.write('&');\n                writer.write(entityName);\n                writer.write(';');\n            } else {\n                writer.write((char) codePoint);\n            }\n        }\n    }\n}\n```\nExplanation: The issue is related to Unicode surrogate pairs that should be treated as a single character in the fix. In the original code, the if statement for escaping high Unicode characters is checking for c > 0x7F, which incorrectly treats surrogate pairs as two separate characters. The fix handles surrogate pairs properly by using the codePointAt() method, which returns the entire code point for such pairs. The code then checks if the code point is greater than 0x7F, and if so, escapes it as per the original code. Otherwise, it checks for named entities or just writes the character.",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang/Entities.java b/src/java/org/apache/commons/lang/Entities.java\nindex 900e1a89..b2fb2443 100644\n--- a/src/java/org/apache/commons/lang/Entities.java\n+++ b/src/java/org/apache/commons/lang/Entities.java\n@@ -822,26 +822,30 @@ class Entities {\n      * @see #escape(String)\n      * @see Writer\n      */\n-    public void escape(Writer writer, String str) throws IOException {\n-        int len = str.length();\n-        for (int i = 0; i < len; i++) {\n-            char c = str.charAt(i);\n-            String entityName = this.entityName(c);\n-            if (entityName == null) {\n-                if (c > 0x7F) {\n-                    writer.write(\"&#\");\n-                    writer.write(Integer.toString(c, 10));\n-                    writer.write(';');\n-                } else {\n-                    writer.write(c);\n-                }\n-            } else {\n+```\n+public void escape(Writer writer, String str) throws IOException {\n+    int len = str.length();\n+    for (int i = 0; i < len; ) {\n+        int codePoint = str.codePointAt(i);\n+        i += Character.charCount(codePoint);\n+        if (codePoint > 0x7F) {\n+            writer.write(\"&#\");\n+            writer.write(Integer.toString(codePoint, 10));\n+            writer.write(';');\n+        } else {\n+            String entityName = this.entityName(codePoint);\n+            if (entityName != null) {\n                 writer.write('&');\n                 writer.write(entityName);\n                 writer.write(';');\n+            } else {\n+                writer.write((char) codePoint);\n             }\n         }\n     }\n+}\n+```\n+Explanation: The issue is related to Unicode surrogate pairs that should be treated as a single character in the fix. In the original code, the if statement for escaping high Unicode characters is checking for c > 0x7F, which incorrectly treats surrogate pairs as two separate characters. The fix handles surrogate pairs properly by using the codePointAt() method, which returns the entire code point for such pairs. The code then checks if the code point is greater than 0x7F, and if so, escapes it as per the original code. Otherwise, it checks for named entities or just writes the character.\n \n     /**\n      * <p>",
    "result_reason": "error: illegal character: \\96",
    "test_result": "ERROR"
}