{
    "patch": "private boolean isGlobalNameReference(String name, Scope scope) {\n    if(scope.isDeclared(name, false)){\n      return true;\n    }\n    Scope.Var var = scope.getVar(name);\n    if (var == null || !var.isGlobal()) {\n      return false;\n    }\n    Node nameNode = var.getNameNode();\n    Scope declaredScope = var.getScope();\n    if (NodeUtil.isCatchBlock(declaredScope.getRootNode())) {\n      // If the variable is declared in a catch block,\n      // it is only global if it is not a catch parameter\n      Node catchRoot = declaredScope.getRootNode();\n      Node catchParam = catchRoot.getFirstChild().getFirstChild();\n      if (catchParam == null || !name.equals(catchParam.getString())) {\n        return false;\n      }\n    }\n    return declaredScope.isGlobal();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 639318df..b003c1d0 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -302,132 +302,27 @@ class GlobalNamespace\n \n       return true;\n     }\n-\n-    public void collect(JSModule module, Scope scope, Node n) {\n-      Node parent = n.getParent();\n-\n-      String name;\n-      boolean isSet = false;\n-      Name.Type type = Name.Type.OTHER;\n-      boolean isPropAssign = false;\n-\n-      switch (n.getType()) {\n-        case Token.GETTER_DEF:\n-        case Token.SETTER_DEF:\n-        case Token.STRING_KEY:\n-          // This may be a key in an object literal declaration.\n-          name = null;\n-          if (parent != null && parent.isObjectLit()) {\n-            name = getNameForObjLitKey(n);\n-          }\n-          if (name == null) {\n-            return;\n-          }\n-          isSet = true;\n-          switch (n.getType()) {\n-            case Token.STRING_KEY:\n-              type = getValueType(n.getFirstChild());\n-              break;\n-            case Token.GETTER_DEF:\n-              type = Name.Type.GET;\n-              break;\n-            case Token.SETTER_DEF:\n-              type = Name.Type.SET;\n-              break;\n-            default:\n-              throw new IllegalStateException(\"unexpected:\" + n);\n-          }\n-          break;\n-        case Token.NAME:\n-          // This may be a variable get or set.\n-          if (parent != null) {\n-            switch (parent.getType()) {\n-              case Token.VAR:\n-                isSet = true;\n-                Node rvalue = n.getFirstChild();\n-                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n-                break;\n-              case Token.ASSIGN:\n-                if (parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = getValueType(n.getNext());\n-                }\n-                break;\n-              case Token.GETPROP:\n-                return;\n-              case Token.FUNCTION:\n-                Node gramps = parent.getParent();\n-                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n-                  return;\n-                }\n-                isSet = true;\n-                type = Name.Type.FUNCTION;\n-                break;\n-              case Token.INC:\n-              case Token.DEC:\n-                isSet = true;\n-                type = Name.Type.OTHER;\n-                break;\n-              default:\n-                if (NodeUtil.isAssignmentOp(parent) &&\n-                    parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = Name.Type.OTHER;\n-                }\n-            }\n-          }\n-          name = n.getString();\n-          break;\n-        case Token.GETPROP:\n-          // This may be a namespaced name get or set.\n-          if (parent != null) {\n-            switch (parent.getType()) {\n-              case Token.ASSIGN:\n-                if (parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = getValueType(n.getNext());\n-                  isPropAssign = true;\n-                }\n-                break;\n-              case Token.INC:\n-              case Token.DEC:\n-                isSet = true;\n-                type = Name.Type.OTHER;\n-                break;\n-              case Token.GETPROP:\n-                return;\n-              default:\n-                if (NodeUtil.isAssignmentOp(parent) &&\n-                    parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = Name.Type.OTHER;\n-                }\n-            }\n-          }\n-          name = n.getQualifiedName();\n-          if (name == null) {\n-            return;\n-          }\n-          break;\n-        default:\n-          return;\n-      }\n-\n-      // We are only interested in global names.\n-      if (!isGlobalNameReference(name, scope)) {\n-        return;\n-      }\n-\n-      if (isSet) {\n-        if (isGlobalScope(scope)) {\n-          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n-        } else {\n-          handleSetFromLocal(module, scope, n, parent, name);\n-        }\n-      } else {\n-        handleGet(module, scope, n, parent, name);\n+private boolean isGlobalNameReference(String name, Scope scope) {\n+    if(scope.isDeclared(name, false)){\n+      return true;\n+    }\n+    Scope.Var var = scope.getVar(name);\n+    if (var == null || !var.isGlobal()) {\n+      return false;\n+    }\n+    Node nameNode = var.getNameNode();\n+    Scope declaredScope = var.getScope();\n+    if (NodeUtil.isCatchBlock(declaredScope.getRootNode())) {\n+      // If the variable is declared in a catch block,\n+      // it is only global if it is not a catch parameter\n+      Node catchRoot = declaredScope.getRootNode();\n+      Node catchParam = catchRoot.getFirstChild().getFirstChild();\n+      if (catchParam == null || !name.equals(catchParam.getString())) {\n+        return false;\n       }\n     }\n+    return declaredScope.isGlobal();\n+}\n \n     /**\n      * Gets the fully qualified name corresponding to an object literal key,",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}