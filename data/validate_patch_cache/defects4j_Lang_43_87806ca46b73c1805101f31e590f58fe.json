{
    "patch": "import java.text.DateFormat;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.Date;\nimport java.util.Locale;\nimport java.util.TimeZone;\n\npublic class BugfixClass {\n\n    private static final String ESCAPED_QUOTE = \"''\";\n    private static final char QUOTE = '\\'';\n\n    public static String formatTimeZone(TimeZone tz, boolean isShort) {\n        DateFormat fmt = isShort\n                ? TimeZone.getShortTimeZoneNames(Locale.getDefault()).getFormat()\n                : TimeZone.getLongTimeZoneNames(Locale.getDefault()).getFormat();\n        fmt.setTimeZone(tz);\n        return fmt.format(0);\n    }\n\n    public static String formatDate(Date date, String pattern, Locale locale) {\n        DateFormat fmt = new SimpleDateFormat(pattern, locale != null ? locale : Locale.ROOT);\n        return fmt.format(date);\n    }\n\n    private static void next(ParsePosition pos) {\n        pos.setIndex(pos.getIndex() + 1);\n    }\n\n    public static boolean isAvailableLocale(Locale locale) {\n        return availableLocaleList().contains(locale);\n    }\n\n    public static Locale[] availableLocaleList() {\n        return Locale.getAvailableLocales();\n    }\n\n    private static StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n            StringBuffer appendTo, boolean escapingOn) {\n        int start = pos.getIndex();\n        char[] c = pattern.toCharArray();\n        if (escapingOn && c[start] == QUOTE) {\n            return appendTo == null ? null : appendTo.append(QUOTE);\n        }\n        int lastHold = start;\n        for (int i = pos.getIndex(); i < pattern.length(); i++) {\n            if (escapingOn && pattern.substring(i).startsWith(ESCAPED_QUOTE)) {\n                appendTo.append(c, lastHold, pos.getIndex() - lastHold).append(\n                        QUOTE);\n                pos.setIndex(i + ESCAPED_QUOTE.length());\n                lastHold = pos.getIndex();\n                continue;\n            }\n            switch (c[pos.getIndex()]) {\n            case QUOTE:\n                next(pos);\n                return appendTo == null ? null : appendTo.append(c, lastHold,\n                        pos.getIndex() - lastHold);\n            default:\n                next(pos);\n            }\n        }\n        throw new IllegalArgumentException(\n                \"Unterminated quoted string at position \" + start);\n    }\n\n    public static void main(String[] args) {\n        Locale.setDefault(Locale.US);\n        testAvailableLocaleSet();\n    }\n\n    private static void testAvailableLocaleSet() {\n        Locale[] locales = Locale.getAvailableLocales();\n        if (locales.length > 0) {\n            Locale locale = locales[0];\n            boolean isAvailable = BugfixClass.isAvailableLocale(locale);\n            assert isAvailable;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\nindex 404be490..61b63789 100644\n--- a/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n+++ b/src/java/org/apache/commons/lang/text/ExtendedMessageFormat.java\n@@ -414,7 +414,44 @@ public class ExtendedMessageFormat extends MessageFormat {\n      * @param escapingOn whether to process escaped quotes\n      * @return <code>appendTo</code>\n      */\n-    private StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n+import java.text.DateFormat;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.Date;\n+import java.util.Locale;\n+import java.util.TimeZone;\n+\n+public class BugfixClass {\n+\n+    private static final String ESCAPED_QUOTE = \"''\";\n+    private static final char QUOTE = '\\'';\n+\n+    public static String formatTimeZone(TimeZone tz, boolean isShort) {\n+        DateFormat fmt = isShort\n+                ? TimeZone.getShortTimeZoneNames(Locale.getDefault()).getFormat()\n+                : TimeZone.getLongTimeZoneNames(Locale.getDefault()).getFormat();\n+        fmt.setTimeZone(tz);\n+        return fmt.format(0);\n+    }\n+\n+    public static String formatDate(Date date, String pattern, Locale locale) {\n+        DateFormat fmt = new SimpleDateFormat(pattern, locale != null ? locale : Locale.ROOT);\n+        return fmt.format(date);\n+    }\n+\n+    private static void next(ParsePosition pos) {\n+        pos.setIndex(pos.getIndex() + 1);\n+    }\n+\n+    public static boolean isAvailableLocale(Locale locale) {\n+        return availableLocaleList().contains(locale);\n+    }\n+\n+    public static Locale[] availableLocaleList() {\n+        return Locale.getAvailableLocales();\n+    }\n+\n+    private static StringBuffer appendQuotedString(String pattern, ParsePosition pos,\n             StringBuffer appendTo, boolean escapingOn) {\n         int start = pos.getIndex();\n         char[] c = pattern.toCharArray();\n@@ -443,6 +480,21 @@ public class ExtendedMessageFormat extends MessageFormat {\n                 \"Unterminated quoted string at position \" + start);\n     }\n \n+    public static void main(String[] args) {\n+        Locale.setDefault(Locale.US);\n+        testAvailableLocaleSet();\n+    }\n+\n+    private static void testAvailableLocaleSet() {\n+        Locale[] locales = Locale.getAvailableLocales();\n+        if (locales.length > 0) {\n+            Locale locale = locales[0];\n+            boolean isAvailable = BugfixClass.isAvailableLocale(locale);\n+            assert isAvailable;\n+        }\n+    }\n+}\n+\n     /**\n      * Consume quoted string only\n      * ",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}