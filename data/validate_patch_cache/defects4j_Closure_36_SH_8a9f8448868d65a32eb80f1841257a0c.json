{
    "patch": "if (value.isFunction()) {\n  Node callNodeForSingletons = reference.getParent();\n  if (reference.getParent().isCall()) {\n    CodingConvention convention = compiler.getCodingConvention();\n    // Bug 2388531: Don't inline subclass definitions into class defining\n    // calls as this confused class removing logic.\n    SubclassRelationship relationship =\n        convention.getClassesDefinedByCall(callNodeForSingletons);\n    if (relationship != null) {\n      return false;\n    }\n\n    // issue 668: Don't inline singleton getter methods\n    // calls as this confused class removing logic.\n    boolean isSingletonGetter = false;\n    Node parent = value.getParent();\n    if (parent != null && parent.isAssign()) {\n      Node rValue = parent.getLastChild();\n      if (rValue != null && rValue.isFunction()) {\n        Node functionBody = rValue.getLastChild();\n        if (functionBody != null && !functionBody.hasChildren()) {\n          String fullName = convention.getSingletonGetterClassName(parent.getFirstChild());\n          if (fullName != null) {\n            isSingletonGetter = true;\n            // Don't go past the outermost function if this is a nested\n            // singleton getter. You are checking the call target x\n            // to see if it's the outer function, so don't go past that.\n            Node ancestor = parent.getParent();\n            while (ancestor.isAssign() && ancestor.getParent().isFunction()) {\n              ancestor = ancestor.getParent().getParent();\n            }\n\n            if (ancestor.isScript() || ancestor.isBlock()) {\n              // check if x is a reference to the outermost function\n              Node outerFunction = parent.getParent();\n              if (outerFunction != null && outerFunction.isFunction()) {\n                Node outermostFunction = outerFunction;\n                while (outerFunction.getParent().isFunction()) {\n                  outerFunction = outerFunction.getParent().getParent();\n                }\n                if (outerFunction.getParent().isScript()) {\n                  Node x = reference.getNode();\n                  while (x != null && !x.isFunction()) {\n                    x = x.getParent();\n                  }\n                  if (x != null && x == outermostFunction) {\n                    return false;\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n    if (isSingletonGetter) {\n      return false;\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..072e36e8 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,66 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+if (value.isFunction()) {\n+  Node callNodeForSingletons = reference.getParent();\n+  if (reference.getParent().isCall()) {\n+    CodingConvention convention = compiler.getCodingConvention();\n+    // Bug 2388531: Don't inline subclass definitions into class defining\n+    // calls as this confused class removing logic.\n+    SubclassRelationship relationship =\n+        convention.getClassesDefinedByCall(callNodeForSingletons);\n+    if (relationship != null) {\n+      return false;\n+    }\n+\n+    // issue 668: Don't inline singleton getter methods\n+    // calls as this confused class removing logic.\n+    boolean isSingletonGetter = false;\n+    Node parent = value.getParent();\n+    if (parent != null && parent.isAssign()) {\n+      Node rValue = parent.getLastChild();\n+      if (rValue != null && rValue.isFunction()) {\n+        Node functionBody = rValue.getLastChild();\n+        if (functionBody != null && !functionBody.hasChildren()) {\n+          String fullName = convention.getSingletonGetterClassName(parent.getFirstChild());\n+          if (fullName != null) {\n+            isSingletonGetter = true;\n+            // Don't go past the outermost function if this is a nested\n+            // singleton getter. You are checking the call target x\n+            // to see if it's the outer function, so don't go past that.\n+            Node ancestor = parent.getParent();\n+            while (ancestor.isAssign() && ancestor.getParent().isFunction()) {\n+              ancestor = ancestor.getParent().getParent();\n+            }\n+\n+            if (ancestor.isScript() || ancestor.isBlock()) {\n+              // check if x is a reference to the outermost function\n+              Node outerFunction = parent.getParent();\n+              if (outerFunction != null && outerFunction.isFunction()) {\n+                Node outermostFunction = outerFunction;\n+                while (outerFunction.getParent().isFunction()) {\n+                  outerFunction = outerFunction.getParent().getParent();\n+                }\n+                if (outerFunction.getParent().isScript()) {\n+                  Node x = reference.getNode();\n+                  while (x != null && !x.isFunction()) {\n+                    x = x.getParent();\n+                  }\n+                  if (x != null && x == outermostFunction) {\n+                    return false;\n+                  }\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+    }\n+    if (isSingletonGetter) {\n+      return false;\n+    }\n+  }\n+}\n         }\n       }\n ",
    "result_reason": "error: variable convention is already defined in method canInline(Reference,Reference,Reference)",
    "test_result": "ERROR"
}