{
    "patch": "  private CanInlineResult canInlineReferenceDirectly(\n    Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node lastChild = fnNode.getLastChild();\n  if (!lastChild.hasChildren()) {\n    return CanInlineResult.YES;\n  }\n\n  if (NodeUtil.isObjectLitOrTemplateLit(callNode.getFirstChild())) {\n    // Only named functions that are `call`-ed could potentially be inlined into an object-literal\n    // method, and only if the object and function are in the same scope.\n    if (callNode.getFirstChild().isName()) {\n      String fnName = callNode.getFirstChild().getString();\n      Var fnVar = getScope().getVar(fnName);\n      if (fnVar != null && fnVar.getScope() == getScope()) {\n        lastChild.getPrevious().getLastChild();\n        return new Es6SyntacticScopeCreator(compiler).scopeContainsThisReference(lastChild.getPrevious().getLastChild());\n      }\n    }\n    return CanInlineResult.NO;\n  }\n\n  List<Node> argNodes = new ArrayList<>();\n  for (Node argNode = callNode.getFirstChild().getNext(); argNode != null; argNode = argNode.getNext()) {\n    argNodes.add(argNode);\n  }\n\n  int requiredArgCount = lastChild.isParamList() ? lastChild.getChildCount() : 0;\n  if (NodeUtil.isFunctionObjectCall(callNode)) {\n    // Functions called via 'call' and 'apply' have a this-object as\n    // the first parameter, but this is not part of the called function's\n    // parameter list.\n    if (!argNodes.isEmpty()) {\n      if (argNodes.get(0).isThis()) {\n        argNodes.remove(0);\n      } else {\n        return CanInlineResult.NO;\n      }\n    } else {\n      return CanInlineResult.NO;\n    }\n  } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n    // Functions called via \"apply\" have a this-object as the first parameter.\n    if (!argNodes.isEmpty()) {\n      if (argNodes.get(0).isThis()) {\n        argNodes.remove(0);\n      } else {\n        return CanInlineResult.NO;\n      }\n    } else {\n      return CanInlineResult.NO;\n    }\n\n    // The second parameter to \"apply\" must be an array or Arguments object.\n    if (argNodes.isEmpty() || !NodeUtil.isArgumentsObject(argNodes.get(0))) {\n      return CanInlineResult.NO;\n    } else {\n      argNodes = new ArrayList<>(argNodes.get(0).children());\n    }\n  }\n\n  Map<String, Node> paramInfo = new HashMap<>();\n  Node paramNode = lastChild.isParamList() ? lastChild.getFirstChild() : null;\n  for (Node argNode : argNodes) {\n    // Map parameters based on order.\n    if (paramNode != null) {\n      String name = getArgName(paramNode);\n      registerParameter(paramInfo, name, argNode);\n      paramNode = paramNode.getNext();\n    } else {\n      // More arguments than parameters.\n      return CanInlineResult.NO;\n    }\n  }\n\n  if (paramNode != null && !lastChild.isVarArgs()) {\n    // Unused parameters without destructuring rest need to be undefined to inlined.\n    while (paramNode != null) {\n      String name = getArgName(paramNode);\n      if (!registerParameter(paramInfo, name, NodeUtil.getUndefinedNode())) {\n        // Unsupported case that may occur with destructuring rest.\n        return CanInlineResult.NO;\n      }\n      paramNode = paramNode.getNext();\n    }\n  }\n\n  for (String name : paramInfo.keySet()) {\n    Node argNode = paramInfo.get(name);\n    if (argNode == null) {\n      return CanInlineResult.NO;\n    }\n\n    Node varNode = getVarNode(name);\n    Preconditions.checkNotNull(varNode, \"Variable was not declared: %s\", name);\n    // Ignore destructuring binding names.\n    if (NodeUtil.isDestructuringLhs(varNode)) {\n      continue;\n    }\n\n    if (NodeUtil.isImmutableValue(varNode)\n        && NodeUtil.getUseCount(varNode, lastChild) > NodeUtil.getUseCount(argNode, lastChild)) {\n      return CanInlineResult.NO;\n    }\n  }\n\n  return CanInlineResult.YES;\n}\n\nprivate boolean registerParameter(Map<String, Node> paramInfo, String paramName, Node argNode) {\n  if (paramInfo.containsKey(paramName)) {\n    Node previousArgNode = paramInfo.get(paramName);\n    if (previousArgNode != argNode) {\n      // A parameter was assigned more than once.\n      return false;\n    }\n  } else {\n    paramInfo.put(paramName, argNode);\n  }\n  return true;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex c3fc14b2..2ea664fa 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -687,66 +687,129 @@ class FunctionInjector {\n    * </pre>\n    */\n   private CanInlineResult canInlineReferenceDirectly(\n-      Node callNode, Node fnNode) {\n-    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n-      return CanInlineResult.NO;\n-    }\n+    Node callNode, Node fnNode) {\n+  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n+    return CanInlineResult.NO;\n+  }\n \n-    Node block = fnNode.getLastChild();\n+  Node lastChild = fnNode.getLastChild();\n+  if (!lastChild.hasChildren()) {\n+    return CanInlineResult.YES;\n+  }\n \n+  if (NodeUtil.isObjectLitOrTemplateLit(callNode.getFirstChild())) {\n+    // Only named functions that are `call`-ed could potentially be inlined into an object-literal\n+    // method, and only if the object and function are in the same scope.\n+    if (callNode.getFirstChild().isName()) {\n+      String fnName = callNode.getFirstChild().getString();\n+      Var fnVar = getScope().getVar(fnName);\n+      if (fnVar != null && fnVar.getScope() == getScope()) {\n+        lastChild.getPrevious().getLastChild();\n+        return new Es6SyntacticScopeCreator(compiler).scopeContainsThisReference(lastChild.getPrevious().getLastChild());\n+      }\n+    }\n+    return CanInlineResult.NO;\n+  }\n \n-    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n-    Node cArg = callNode.getFirstChild().getNext();\n+  List<Node> argNodes = new ArrayList<>();\n+  for (Node argNode = callNode.getFirstChild().getNext(); argNode != null; argNode = argNode.getNext()) {\n+    argNodes.add(argNode);\n+  }\n \n+  int requiredArgCount = lastChild.isParamList() ? lastChild.getChildCount() : 0;\n+  if (NodeUtil.isFunctionObjectCall(callNode)) {\n     // Functions called via 'call' and 'apply' have a this-object as\n     // the first parameter, but this is not part of the called function's\n     // parameter list.\n-    if (!callNode.getFirstChild().isName()) {\n-      if (NodeUtil.isFunctionObjectCall(callNode)) {\n-        // TODO(johnlenz): Support replace this with a value.\n-        if (cArg == null || !cArg.isThis()) {\n-          return CanInlineResult.NO;\n-        }\n-        cArg = cArg.getNext();\n+    if (!argNodes.isEmpty()) {\n+      if (argNodes.get(0).isThis()) {\n+        argNodes.remove(0);\n       } else {\n-        // \".apply\" call should be filtered before this.\n-        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n+        return CanInlineResult.NO;\n       }\n+    } else {\n+      return CanInlineResult.NO;\n+    }\n+  } else if (NodeUtil.isFunctionObjectApply(callNode)) {\n+    // Functions called via \"apply\" have a this-object as the first parameter.\n+    if (!argNodes.isEmpty()) {\n+      if (argNodes.get(0).isThis()) {\n+        argNodes.remove(0);\n+      } else {\n+        return CanInlineResult.NO;\n+      }\n+    } else {\n+      return CanInlineResult.NO;\n     }\n \n-    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n-    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n-    while (cArg != null || fnParam != null) {\n-      // For each named parameter check if a mutable argument use more than one.\n-      if (fnParam != null) {\n-        if (cArg != null) {\n-\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n-          }\n-        }\n+    // The second parameter to \"apply\" must be an array or Arguments object.\n+    if (argNodes.isEmpty() || !NodeUtil.isArgumentsObject(argNodes.get(0))) {\n+      return CanInlineResult.NO;\n+    } else {\n+      argNodes = new ArrayList<>(argNodes.get(0).children());\n+    }\n+  }\n \n-        // Move to the next name.\n-        fnParam = fnParam.getNext();\n-      }\n+  Map<String, Node> paramInfo = new HashMap<>();\n+  Node paramNode = lastChild.isParamList() ? lastChild.getFirstChild() : null;\n+  for (Node argNode : argNodes) {\n+    // Map parameters based on order.\n+    if (paramNode != null) {\n+      String name = getArgName(paramNode);\n+      registerParameter(paramInfo, name, argNode);\n+      paramNode = paramNode.getNext();\n+    } else {\n+      // More arguments than parameters.\n+      return CanInlineResult.NO;\n+    }\n+  }\n \n-      // For every call argument check for side-effects, even if there\n-      // isn't a named parameter to match.\n-      if (cArg != null) {\n-        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n-          return CanInlineResult.NO;\n-        }\n-        cArg = cArg.getNext();\n+  if (paramNode != null && !lastChild.isVarArgs()) {\n+    // Unused parameters without destructuring rest need to be undefined to inlined.\n+    while (paramNode != null) {\n+      String name = getArgName(paramNode);\n+      if (!registerParameter(paramInfo, name, NodeUtil.getUndefinedNode())) {\n+        // Unsupported case that may occur with destructuring rest.\n+        return CanInlineResult.NO;\n       }\n+      paramNode = paramNode.getNext();\n     }\n+  }\n \n-    return CanInlineResult.YES;\n+  for (String name : paramInfo.keySet()) {\n+    Node argNode = paramInfo.get(name);\n+    if (argNode == null) {\n+      return CanInlineResult.NO;\n+    }\n+\n+    Node varNode = getVarNode(name);\n+    Preconditions.checkNotNull(varNode, \"Variable was not declared: %s\", name);\n+    // Ignore destructuring binding names.\n+    if (NodeUtil.isDestructuringLhs(varNode)) {\n+      continue;\n+    }\n+\n+    if (NodeUtil.isImmutableValue(varNode)\n+        && NodeUtil.getUseCount(varNode, lastChild) > NodeUtil.getUseCount(argNode, lastChild)) {\n+      return CanInlineResult.NO;\n+    }\n+  }\n+\n+  return CanInlineResult.YES;\n+}\n+\n+private boolean registerParameter(Map<String, Node> paramInfo, String paramName, Node argNode) {\n+  if (paramInfo.containsKey(paramName)) {\n+    Node previousArgNode = paramInfo.get(paramName);\n+    if (previousArgNode != argNode) {\n+      // A parameter was assigned more than once.\n+      return false;\n+    }\n+  } else {\n+    paramInfo.put(paramName, argNode);\n   }\n+  return true;\n+}\n \n   /**\n    * Determine if inlining the function is likely to reduce the code size.",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}