{
    "patch": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(yMin, 0);\n            return result;\n        }\n\n        // check that min and max bracket the root\n        double yMax = f.value(max);\n        if (yMin * yMax >= 0) {\n            throw new IllegalArgumentException(\"Interval [\" + min + \", \" + max + \"] does not bracket a root.\");\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, yMin, initial, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(yMax, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n        }\n        \n        // full Brent algorithm starting with provided initial guess\n        double a = (yMin < yMax) ? min : max;\n        double b = initial; \n        double c = initial;\n        double fa = f.value(a);\n        double fb = f.value(b);\n        double fc = fb;\n        \n        double s, d = b;\n        while (maxIterations-- > 0) {\n            if (fb == 0 || Math.abs(b - c) < relativeAccuracy) {\n                setResult(b, 0);\n                return result;\n            }\n            if (Math.abs(a - c) < functionValueAccuracy ||\n                Math.abs(fa) <= Math.abs(fb)) {\n                c = b;\n                fc = fb;\n                d = s = b - a;\n            } else {\n                s = fb / fa;\n                if (a == c) {\n                    // linear interpolation\n                    d = b - a;\n                    s = fb / fc;\n                } else {\n                    // inverse quadratic interpolation\n                    double t = fb / fc;\n                    double p = s * (fa - fc);\n                    double q = (1 - s) * (fb - fc);\n                    double r = t * (fa - fb);\n                    d = p * (q - s * r) - (1 - s) * t * r;\n                    d /= (q - p) * (1 - s) - s * (1 - s) * (r - q);\n                }\n                if (d > 0) {\n                    c = b;\n                    fc = fb;\n                }\n                d = Math.min(relativeTolerance * (b + relativeTolerance), d);\n                if (Math.abs(d) < functionValueAccuracy) {\n                    d = (d < 0) ? -functionValueAccuracy : functionValueAccuracy;\n                }\n            }\n            a = b;\n            fa = fb;\n            if (Math.abs(d) > functionValueAccuracy) {\n                b += d;\n            } else {\n                b += (b > c) ? -functionValueAccuracy : functionValueAccuracy;\n            }\n            fb = f.value(b);\n            if ((fb > 0 && fc > 0) || (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                fb = fa;\n            }\n        }\n\n        throw new MaxIterationsExceededException(maxIterations);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..a64be315c 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,110 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+    public double solve(final UnivariateRealFunction f,\n+                        final double min, final double max, final double initial)\n+        throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        clearResult();\n+        verifySequence(min, initial, max);\n+\n+        // return the initial guess if it is good enough\n+        double yInitial = f.value(initial);\n+        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+            setResult(initial, 0);\n+            return result;\n+        }\n+\n+        // return the first endpoint if it is good enough\n+        double yMin = f.value(min);\n+        if (Math.abs(yMin) <= functionValueAccuracy) {\n+            setResult(yMin, 0);\n+            return result;\n+        }\n+\n+        // check that min and max bracket the root\n+        double yMax = f.value(max);\n+        if (yMin * yMax >= 0) {\n+            throw new IllegalArgumentException(\"Interval [\" + min + \", \" + max + \"] does not bracket a root.\");\n+        }\n+\n+        // reduce interval if min and initial bracket the root\n+        if (yInitial * yMin < 0) {\n+            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+        }\n+\n+        // return the second endpoint if it is good enough\n+        if (Math.abs(yMax) <= functionValueAccuracy) {\n+            setResult(yMax, 0);\n+            return result;\n+        }\n+\n+        // reduce interval if initial and max bracket the root\n+        if (yInitial * yMax < 0) {\n+            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        }\n+        \n+        // full Brent algorithm starting with provided initial guess\n+        double a = (yMin < yMax) ? min : max;\n+        double b = initial; \n+        double c = initial;\n+        double fa = f.value(a);\n+        double fb = f.value(b);\n+        double fc = fb;\n+        \n+        double s, d = b;\n+        while (maxIterations-- > 0) {\n+            if (fb == 0 || Math.abs(b - c) < relativeAccuracy) {\n+                setResult(b, 0);\n+                return result;\n+            }\n+            if (Math.abs(a - c) < functionValueAccuracy ||\n+                Math.abs(fa) <= Math.abs(fb)) {\n+                c = b;\n+                fc = fb;\n+                d = s = b - a;\n+            } else {\n+                s = fb / fa;\n+                if (a == c) {\n+                    // linear interpolation\n+                    d = b - a;\n+                    s = fb / fc;\n+                } else {\n+                    // inverse quadratic interpolation\n+                    double t = fb / fc;\n+                    double p = s * (fa - fc);\n+                    double q = (1 - s) * (fb - fc);\n+                    double r = t * (fa - fb);\n+                    d = p * (q - s * r) - (1 - s) * t * r;\n+                    d /= (q - p) * (1 - s) - s * (1 - s) * (r - q);\n+                }\n+                if (d > 0) {\n+                    c = b;\n+                    fc = fb;\n+                }\n+                d = Math.min(relativeTolerance * (b + relativeTolerance), d);\n+                if (Math.abs(d) < functionValueAccuracy) {\n+                    d = (d < 0) ? -functionValueAccuracy : functionValueAccuracy;\n+                }\n+            }\n+            a = b;\n+            fa = fb;\n+            if (Math.abs(d) > functionValueAccuracy) {\n+                b += d;\n+            } else {\n+                b += (b > c) ? -functionValueAccuracy : functionValueAccuracy;\n+            }\n+            fb = f.value(b);\n+            if ((fb > 0 && fc > 0) || (fb <= 0 && fc <= 0)) {\n+                c = a;\n+                fc = fa;\n+                d = b - a;\n+                fb = fa;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maxIterations);\n+    }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}