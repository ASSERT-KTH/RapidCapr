{
    "patch": "  private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n        if (conditional) {\n          recordAllVars(gen, kill, n, false);\n          computeGenKill(n.getFirstChild(), gen, kill, true);\n        } else {\n          computeGenKill(n.getFirstChild(), gen, kill, false);\n          recordAllVars(gen, kill, n, true);\n        }\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          Node forCondition = NodeUtil.getConditionExpression(n);\n          computeGenKill(forCondition, gen, kill, true);\n          if (conditional) {\n            recordAllVars(gen, kill, forCondition, false);\n          }\n          // First child node is init, getNext() gives condition, getNext() gives increment\n          computeGenKill(n.getFirstChild().getNext(), gen, kill, conditional);\n        } else {\n          Node lhs = n.getFirstChild();\n          // Add both values of the IN node into the kill set\n          addToLocalKillSet(lhs, kill, conditional);\n          addToLocalKillSet(lhs.getNext().detach(), kill, conditional);\n          recordAllVars(gen, kill, lhs.getNext(), false);\n          computeGenKill(lhs.getNext().getNext(), gen, kill, conditional);\n        }\n        return;\n\n      case Token.VAR:\n        for (Node curr = n.getFirstChild(); curr != null; curr = curr.getNext()) {\n          if (curr.hasChildren()) {\n            Node varInitializer = curr.getFirstChild();\n            computeGenKill(varInitializer, gen, kill, conditional);\n            addToLocalSet(curr, gen);\n            if (!conditional) {\n              addToLocalKillSet(curr, kill);\n            }\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        if (!conditional) {\n          Node firstChild = n.getFirstChild();\n          Node lastChild = n.getLastChild();\n\n          BitSet firstChildKill = createBitSet();\n          firstChildKill.or(gen);\n\n          BitSet lastChildKill = createBitSet();\n          lastChildKill.or(gen);\n\n          computeGenKill(firstChild, firstChildKill, createBitSet(), false);\n          computeGenKill(lastChild, lastChildKill, createBitSet(), false);\n\n          gen.or(firstChildKill);\n          gen.or(lastChildKill);\n        }\n        return;\n\n      case Token.HOOK:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n        Node trueExpression = NodeUtil.getSecondChild(n);\n        computeGenKill(trueExpression, gen, kill, true);\n        Node falseExpression = NodeUtil.getLastChild(n);\n        computeGenKill(falseExpression, gen, kill, true);\n\n        if (!conditional) {\n          BitSet trueGen = createBitSet();\n          trueGen.or(kill);\n\n          BitSet falseGen = createBitSet();\n          falseGen.or(kill);\n\n          computeGenKill(trueExpression, trueGen, createBitSet(), false);\n          computeGenKill(falseExpression, falseGen, createBitSet(), false);\n\n          gen.or(trueGen);\n          gen.or(falseGen);\n        }\n        return;\n\n      case Token.NAME:\n        if (!isArgumentsName(n)) {\n          addToLocalSet(n, gen);\n        }\n        return;\n\n      default:\n        // All assignments that assign to a local variable or the right side is a local variable\n        // need to be added to the gen set\n        if (NodeUtil.isAssignmentOp(n)\n            && (NodeUtil.isName(n.getFirstChild()) || NodeUtil.isName(n.getLastChild()))) {\n          Node lhs = n.getFirstChild();\n          Node rhs = n.getLastChild();\n          addToLocalSet(rhs, gen);\n          addToLocalSet(lhs, gen);\n          if (!conditional) {\n            addToLocalKillSet(lhs, kill);\n          }\n          computeGenKill(rhs, gen, kill, conditional);\n        } else if (NodeUtil.isCall(n)) {\n          boolean recordArgs = false;\n          Node callee = n.getFirstChild();\n          String functionName = null;\n          if (callerFunctions != null && callee.getType() == Token.NAME) {\n            functionName = callee.getString();\n            if (callerFunctions.contains(functionName)) {\n              recordArgs = true;\n            }\n          }\n          for (Node callChild = callee.getNext(); callChild !",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\nindex 7999db40..8acd7fb5 100644\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n@@ -175,9 +175,7 @@ class LiveVariablesAnalysis extends\n    * @param conditional {@code true} if any assignments encountered are\n    *        conditionally executed. These assignments might not kill a variable.\n    */\n-  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n-      boolean conditional) {\n-\n+  private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\n     switch (n.getType()) {\n       case Token.SCRIPT:\n       case Token.BLOCK:\n@@ -187,34 +185,43 @@ class LiveVariablesAnalysis extends\n       case Token.WHILE:\n       case Token.DO:\n       case Token.IF:\n-        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n-            conditional);\n+        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n+        if (conditional) {\n+          recordAllVars(gen, kill, n, false);\n+          computeGenKill(n.getFirstChild(), gen, kill, true);\n+        } else {\n+          computeGenKill(n.getFirstChild(), gen, kill, false);\n+          recordAllVars(gen, kill, n, true);\n+        }\n         return;\n \n       case Token.FOR:\n         if (!NodeUtil.isForIn(n)) {\n-          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n-              conditional);\n+          Node forCondition = NodeUtil.getConditionExpression(n);\n+          computeGenKill(forCondition, gen, kill, true);\n+          if (conditional) {\n+            recordAllVars(gen, kill, forCondition, false);\n+          }\n+          // First child node is init, getNext() gives condition, getNext() gives increment\n+          computeGenKill(n.getFirstChild().getNext(), gen, kill, conditional);\n         } else {\n-          // for(x in y) {...}\n           Node lhs = n.getFirstChild();\n-          Node rhs = lhs.getNext();\n-          if (NodeUtil.isVar(lhs)) {\n-            // for(var x in y) {...}\n-            lhs = lhs.getLastChild();\n-          }\n-            addToSetIfLocal(lhs, kill);\n-            addToSetIfLocal(lhs, gen);\n-          computeGenKill(rhs, gen, kill, conditional);\n+          // Add both values of the IN node into the kill set\n+          addToLocalKillSet(lhs, kill, conditional);\n+          addToLocalKillSet(lhs.getNext().detach(), kill, conditional);\n+          recordAllVars(gen, kill, lhs.getNext(), false);\n+          computeGenKill(lhs.getNext().getNext(), gen, kill, conditional);\n         }\n         return;\n \n       case Token.VAR:\n-        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (c.hasChildren()) {\n-            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n+        for (Node curr = n.getFirstChild(); curr != null; curr = curr.getNext()) {\n+          if (curr.hasChildren()) {\n+            Node varInitializer = curr.getFirstChild();\n+            computeGenKill(varInitializer, gen, kill, conditional);\n+            addToLocalSet(curr, gen);\n             if (!conditional) {\n-              addToSetIfLocal(c, kill);\n+              addToLocalKillSet(curr, kill);\n             }\n           }\n         }\n@@ -222,45 +229,78 @@ class LiveVariablesAnalysis extends\n \n       case Token.AND:\n       case Token.OR:\n-        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n-        // May short circuit.\n+        computeGenKill(n.getFirstChild(), gen, kill, true);\n         computeGenKill(n.getLastChild(), gen, kill, true);\n+        if (!conditional) {\n+          Node firstChild = n.getFirstChild();\n+          Node lastChild = n.getLastChild();\n+\n+          BitSet firstChildKill = createBitSet();\n+          firstChildKill.or(gen);\n+\n+          BitSet lastChildKill = createBitSet();\n+          lastChildKill.or(gen);\n+\n+          computeGenKill(firstChild, firstChildKill, createBitSet(), false);\n+          computeGenKill(lastChild, lastChildKill, createBitSet(), false);\n+\n+          gen.or(firstChildKill);\n+          gen.or(lastChildKill);\n+        }\n         return;\n \n       case Token.HOOK:\n-        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n-        // Assume both sides are conditional.\n-        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n-        computeGenKill(n.getLastChild(), gen, kill, true);\n+        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n+        Node trueExpression = NodeUtil.getSecondChild(n);\n+        computeGenKill(trueExpression, gen, kill, true);\n+        Node falseExpression = NodeUtil.getLastChild(n);\n+        computeGenKill(falseExpression, gen, kill, true);\n+\n+        if (!conditional) {\n+          BitSet trueGen = createBitSet();\n+          trueGen.or(kill);\n+\n+          BitSet falseGen = createBitSet();\n+          falseGen.or(kill);\n+\n+          computeGenKill(trueExpression, trueGen, createBitSet(), false);\n+          computeGenKill(falseExpression, falseGen, createBitSet(), false);\n+\n+          gen.or(trueGen);\n+          gen.or(falseGen);\n+        }\n         return;\n \n       case Token.NAME:\n-        if (isArgumentsName(n)) {\n-          markAllParametersEscaped();\n-        } else {\n-          addToSetIfLocal(n, gen);\n+        if (!isArgumentsName(n)) {\n+          addToLocalSet(n, gen);\n         }\n         return;\n \n       default:\n-        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n+        // All assignments that assign to a local variable or the right side is a local variable\n+        // need to be added to the gen set\n+        if (NodeUtil.isAssignmentOp(n)\n+            && (NodeUtil.isName(n.getFirstChild()) || NodeUtil.isName(n.getLastChild()))) {\n           Node lhs = n.getFirstChild();\n+          Node rhs = n.getLastChild();\n+          addToLocalSet(rhs, gen);\n+          addToLocalSet(lhs, gen);\n           if (!conditional) {\n-            addToSetIfLocal(lhs, kill);\n-          }\n-          if (!NodeUtil.isAssign(n)) {\n-            // assignments such as a += 1 reads a.\n-            addToSetIfLocal(lhs, gen);\n+            addToLocalKillSet(lhs, kill);\n           }\n-          computeGenKill(lhs.getNext(), gen, kill, conditional);\n-        } else {\n-          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-            computeGenKill(c, gen, kill, conditional);\n+          computeGenKill(rhs, gen, kill, conditional);\n+        } else if (NodeUtil.isCall(n)) {\n+          boolean recordArgs = false;\n+          Node callee = n.getFirstChild();\n+          String functionName = null;\n+          if (callerFunctions != null && callee.getType() == Token.NAME) {\n+            functionName = callee.getString();\n+            if (callerFunctions.contains(functionName)) {\n+              recordArgs = true;\n+            }\n           }\n-        }\n-        return;\n-    }\n-  }\n+          for (Node callChild = callee.getNext(); callChild !\n \n   private void addToSetIfLocal(Node node, BitSet set) {\n     Preconditions.checkState(NodeUtil.isName(node));",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}