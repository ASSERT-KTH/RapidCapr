{
    "patch": "// converts some special chars to escaped versions\nprivate String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape,\n                  String backslashEscape, CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        switch (c) {\n            case '\\n':\n                sb.append(\"\\\\n\");\n                break;\n            case '\\r':\n                sb.append(\"\\\\r\");\n                break;\n            case '\\t':\n                sb.append(\"\\\\t\");\n                break;\n            case '\\\\':\n                sb.append(backslashEscape);\n                break;\n            // fix: add quotes so \\0 is interpreted as a char\n            case '\\0':\n                sb.append(\"\\\\x00\");\n                break;\n            case '\\\"':\n                sb.append(doublequoteEscape);\n                break;\n            case '\\'':\n                sb.append(singlequoteEscape);\n                break;\n            case '>':  // Break --> into --\\> or ]]> into ]]\\>\n                if (i >= 2 && ((s.charAt(i-1) == '-' && s.charAt(i-2) == '-') ||\n                        (s.charAt(i-1) == ']' && s.charAt(i-2) == ']'))) {\n                    sb.append(\"\\\\>\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            case '<':\n                // Break </script into <\\/script\n                final String END_SCRIPT = \"/script\";\n\n                // Break <!-- into <\\!--\n                final String START_COMMENT = \"!--\";\n\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\n                    sb.append(\"<\\\\\");\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\n                    sb.append(\"<\\\\\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            default:\n                // If we're given an outputCharsetEncoder, then check if the\n                //  character can be represented in this character set.\n                if (outputCharsetEncoder != null) {\n                    if (outputCharsetEncoder.canEncode(c)) {\n                        sb.append(c);\n                    } else {\n                        // Unicode-escape the character.\n                        appendHexJavaScriptRepresentation(sb, c);\n                    }\n                } else {\n                    // No charsetEncoder provided - pass straight latin characters\n                    // through, and escape the rest.  Doing the explicit character\n                    // check is measurably faster than using the CharsetEncoder.\n                    if (c > 0x1f && c <= 0x7f) {\n                        sb.append(c);\n                    } else {\n                        // Other characters can be misinterpreted by some js parsers,\n                        // or perhaps mangled by proxies along the way,\n                        // so we play it safe and unicode escape them.\n                        appendHexJavaScriptRepresentation(sb, c);\n                    }\n                }\n        }\n    }\n    sb.append(quote);\n    return sb.toString();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 8cd3ab9d..df94744c 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -963,6 +963,87 @@ class CodeGenerator {\n     for (int i = 0; i < s.length(); i++) {\n       char c = s.charAt(i);\n       switch (c) {\n+// converts some special chars to escaped versions\n+private String strEscape(String s, char quote, String doublequoteEscape, String singlequoteEscape,\n+                  String backslashEscape, CharsetEncoder outputCharsetEncoder) {\n+    StringBuilder sb = new StringBuilder(s.length() + 2);\n+    sb.append(quote);\n+    for (int i = 0; i < s.length(); i++) {\n+        char c = s.charAt(i);\n+        switch (c) {\n+            case '\\n':\n+                sb.append(\"\\\\n\");\n+                break;\n+            case '\\r':\n+                sb.append(\"\\\\r\");\n+                break;\n+            case '\\t':\n+                sb.append(\"\\\\t\");\n+                break;\n+            case '\\\\':\n+                sb.append(backslashEscape);\n+                break;\n+            // fix: add quotes so \\0 is interpreted as a char\n+            case '\\0':\n+                sb.append(\"\\\\x00\");\n+                break;\n+            case '\\\"':\n+                sb.append(doublequoteEscape);\n+                break;\n+            case '\\'':\n+                sb.append(singlequoteEscape);\n+                break;\n+            case '>':  // Break --> into --\\> or ]]> into ]]\\>\n+                if (i >= 2 && ((s.charAt(i-1) == '-' && s.charAt(i-2) == '-') ||\n+                        (s.charAt(i-1) == ']' && s.charAt(i-2) == ']'))) {\n+                    sb.append(\"\\\\>\");\n+                } else {\n+                    sb.append(c);\n+                }\n+                break;\n+            case '<':\n+                // Break </script into <\\/script\n+                final String END_SCRIPT = \"/script\";\n+\n+                // Break <!-- into <\\!--\n+                final String START_COMMENT = \"!--\";\n+\n+                if (s.regionMatches(true, i + 1, END_SCRIPT, 0, END_SCRIPT.length())) {\n+                    sb.append(\"<\\\\\");\n+                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0, START_COMMENT.length())) {\n+                    sb.append(\"<\\\\\");\n+                } else {\n+                    sb.append(c);\n+                }\n+                break;\n+            default:\n+                // If we're given an outputCharsetEncoder, then check if the\n+                //  character can be represented in this character set.\n+                if (outputCharsetEncoder != null) {\n+                    if (outputCharsetEncoder.canEncode(c)) {\n+                        sb.append(c);\n+                    } else {\n+                        // Unicode-escape the character.\n+                        appendHexJavaScriptRepresentation(sb, c);\n+                    }\n+                } else {\n+                    // No charsetEncoder provided - pass straight latin characters\n+                    // through, and escape the rest.  Doing the explicit character\n+                    // check is measurably faster than using the CharsetEncoder.\n+                    if (c > 0x1f && c <= 0x7f) {\n+                        sb.append(c);\n+                    } else {\n+                        // Other characters can be misinterpreted by some js parsers,\n+                        // or perhaps mangled by proxies along the way,\n+                        // so we play it safe and unicode escape them.\n+                        appendHexJavaScriptRepresentation(sb, c);\n+                    }\n+                }\n+        }\n+    }\n+    sb.append(quote);\n+    return sb.toString();\n+}\n         case '\\n': sb.append(\"\\\\n\"); break;\n         case '\\r': sb.append(\"\\\\r\"); break;\n         case '\\t': sb.append(\"\\\\t\"); break;",
    "result_reason": "error: case, default, or '}' expected",
    "test_result": "ERROR"
}