{
    "patch": "    public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n        final double[] y = interpolator.getInterpolatedState();\n        final double   t = interpolator.getInterpolatedTime();\n        final double[] yDot = interpolator.getInterpolatedDerivatives();\n        for (final EventState state : eventsStates) {\n            state.stepAccepted(t, y);\n        }\n        if (!eventsStates.isEmpty()) {\n            final SortedSet<EventState> occuringEvents = new TreeSet<>(new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n            double tMin = Double.POSITIVE_INFINITY;\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                    final double tEvent = state.getEventTime();\n                    if (tEvent < tMin) {\n                        tMin = tEvent;\n                    }\n                }\n            }\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronological first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(t);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, false);\n                }\n                if (isLastStep) {\n                    break;\n                }\n            }\n        }\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLast);\n        }\n        if (isLast) {\n            eventsStates.clear();\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..733f9c959 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,29 +313,40 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n+    public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+        final double[] y = interpolator.getInterpolatedState();\n+        final double   t = interpolator.getInterpolatedTime();\n+        final double[] yDot = interpolator.getInterpolatedDerivatives();\n+        for (final EventState state : eventsStates) {\n+            state.stepAccepted(t, y);\n+        }\n+        if (!eventsStates.isEmpty()) {\n+            final SortedSet<EventState> occuringEvents = new TreeSet<>(new Comparator<EventState>() {\n                 public int compare(EventState es0, EventState es1) {\n                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                 }\n-\n             });\n-\n+            double tMin = Double.POSITIVE_INFINITY;\n             for (final EventState state : eventsStates) {\n                 if (state.evaluateStep(interpolator)) {\n                     // the event occurs during the current step\n                     occuringEvents.add(state);\n+                    final double tEvent = state.getEventTime();\n+                    if (tEvent < tMin) {\n+                        tMin = tEvent;\n+                    }\n                 }\n             }\n-\n             while (!occuringEvents.isEmpty()) {\n \n-                // handle the chronologically first event\n+                // handle the chronological first event\n                 final Iterator<EventState> iterator = occuringEvents.iterator();\n                 final EventState currentEvent = iterator.next();\n                 iterator.remove();\n \n                 // restrict the interpolator to the first part of the step, up to the event\n                 final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n+                interpolator.setSoftPreviousTime(t);\n                 interpolator.setSoftCurrentTime(eventT);\n \n                 // get state at event time\n@@ -348,8 +359,20 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                    handler.handleStep(interpolator, false);\n                 }\n+                if (isLastStep) {\n+                    break;\n+                }\n+            }\n+        }\n+        for (final StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, isLast);\n+        }\n+        if (isLast) {\n+            eventsStates.clear();\n+        }\n+    }\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}