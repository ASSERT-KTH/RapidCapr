{
    "patch": "public class IRFactory implements NodeTransformer {\n  private static final Set<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\");\n\n  private final String sourceName;\n  private final ErrorReporter errorReporter;\n  private final CodingConvention codingConvention;\n\n  IRFactory(String sourceName, ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.errorReporter = errorReporter;\n    this.codingConvention = new GoogleCodingConvention();\n  }\n\n  @Override\n  public Node transform(Node node) {\n    return node;\n  }\n\n  /**\n   * Overrides for all statement types.\n   */\n  private abstract static class TransformDispatcher implements TypeSafeDispatcher {\n\n    @Override\n    public final void process(Node node) {\n      throw new IllegalStateException(\"Unexpected concrete Node type: \" + node.getClass());\n    }\n\n    abstract Node processBlock(Block blockNode);\n\n    abstract Node processExpressionStatement(ExpressionStatement statementNode);\n\n    abstract Node processIfStatement(IfStatement statementNode);\n\n    abstract Node processSwitch(SwitchStatement switchNode);\n\n    abstract Node processWhileLoop(WhileLoop loopNode);\n\n    abstract Node processDoLoop(DoLoop loopNode);\n\n    abstract Node processForLoop(ForLoop loopNode);\n\n    abstract Node processForInLoop(ForInLoop loopNode);\n\n    abstract Node processFunctionNode(FunctionNode functionNode);\n\n    abstract Node processBreakStatement(BreakStatement statementNode);\n\n    abstract Node processContinueStatement(ContinueStatement statementNode);\n\n    abstract Node processTry(TryStatement tryNode);\n\n    abstract Node processThrow(ThrowStatement throwNode);\n\n    abstract Node processReturn(ReturnStatement returnNode);\n\n    abstract Node processWith(WithStatement withNode);\n\n    abstract Node processLabel(Label label);\n\n    abstract Node processSwitchCase(SwitchCase switchCase);\n\n    abstract Node processDefaultCase(Node defaultCase);\n\n    abstract Node processCatchClause(CatchClause catchClause);\n\n    abstract Node processDebuggerStatement(DebuggerStatement debuggerStatement);\n\n    abstract Node processEmptyExpression(EmptyExpression exprNode);\n\n    abstract Node processElementGet(ElementGet getNode);\n\n    abstract Node processConditionalExpression(ConditionalExpression exprNode);\n\n    abstract Node processNewExpression(NewExpression newExprNode);\n\n    abstract Node processUnaryExpression(UnaryExpression unaryExprNode);\n\n    abstract Node processBinaryExpression(BinaryExpression binaryExprNode);\n\n    abstract Node processAssignment(Assignment assignmentNode);\n\n    abstract Node processName(Name nameNode);\n\n    abstract Node processNumber(NumberLiteral numberNode);\n\n    abstract Node processString(StringLiteral stringNode);\n\n    abstract Node processRegExp(RegExpLiteral regExpNode);\n\n    abstract Node processGetProp(GetProp node);\n\n    abstract Node processObjectLit(ObjectLiteral objLitNode);\n\n    abstract Node processArrayLit(ArrayLiteral arrayLitNode);\n\n    abstract Node processObjectProperty(ObjectProperty objPropNode);\n\n    abstract Node processFunctionCall(FunctionCall callNode);\n\n    abstract Node processThis(ThisLiteral thisNode);\n\n    abstract Node processNull(NullLiteral nullNode);\n\n    abstract Node processBoolean(BooleanLiteral booleanNode);\n\n    abstract Node processVariableDeclarationList(\n        VariableDeclarationList declarationList,\n        Token declarationType);\n\n    abstract Node processVariableDeclaration(\n        VariableDeclaration declaration,\n        Token declarationType);\n\n    abstract Node processComment(Comment commentNode);\n  }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) {\n      return false;\n    }\n\n    int nType = n.getType();\n    return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n        n.getFirstChild().getType() == Token.STRING &&\n        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  private Node parseFunctionBody(ExpressionStatement stmt, FunctionNode fnNode) {\n    checkNotNull(fnNode.getFunctionName());\n\n    Node functionNode = newNode(Token.EXPR_RESULT, transform(fnNode));\n    parseDirectives(fnNode.getBody());\n    functionNode.useSourceInfoFrom(fnNode);\n\n    if (hasExceptionHandler(fnNode.getBody())) {\n      errorReporter.warning(\n          \"try/catch statement around function body will be removed\",\n          sourceName,\n          fnNode.getLineno());\n    }\n    return functionNode;\n  }\n\n  @Override\n  public final Node transform(ExpressionStatement exprStmt) {\n    AstNode expr = exprStmt.getExpression();\n    int type = expr.getType();\n\n    switch (type) {\n      case Token.STRING:\n        // Handle top level required of modules.\n        String required = codingConvention.extractRequirableModuleName(\n            ((StringLiteral) expr).getValue());\n        if (!required.isEmpty()) {\n          Node requireCall = newNode(Token.CALL, newNode(Token.NAME, \"require\", expr));\n          requireCall.addChildToBack(newNode(Token.STRING, required, expr));\n          return requireCall;\n        }\n        if (isDirective(expr)) {\n          return null;\n        }\n        break;\n\n      case Token.CALL:\n        FunctionCall call = (FunctionCall) expr;\n        if (call.getTarget().getType() == Token.NAME) {\n          String functionName = ((Name) call.getTarget()).getIdentifier();\n          // Handle top level required of modules.\n          required = codingConvention.extractRequirableModuleName(functionName);\n          if (!required.isEmpty()) {\n            Node newCall = newNode(Token.CALL, newNode(Token.NAME, \"require\", expr));\n            newCall.addChildToBack(newNode(Token.STRING, required, expr));\n            for (AstNode child : call.getArguments()) {\n              newCall.addChildToBack(transform(child));\n            }\n            newCall.setLineno(call.getLineno());\n            newCall.setCharno(call.getCharno());\n            return newCall;\n          }\n        }\n        break;\n\n      case Token.FUNCTION:\n        return parseFunctionBody(exprStmt, (FunctionNode) expr);\n\n      default:\n        break;\n    }\n\n    Node result = processExpressionStatement(exprStmt);\n    return result;\n  }\n\n  @Override\n  public final Node transform(FunctionNode fnNode) {\n    Node result = processFunctionNode(fnNode);\n    return result;\n  }\n\n  private final class CommonTransforms extends TransformDispatcher {\n\n    @Override\n    Node processBlock(Block blockNode) {\n      Node block = newNode(Token.BLOCK);\n      for (Node n = blockNode.getFirstChild(); n != null; n = n.getNext()) {\n        Node transformed = transform(n);\n        if (transformed != null) {\n          block.addChildToBack(transformed);\n        }\n      }\n      block.setLineno(blockNode.getLineno());\n      return block;\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(Token.EXPR_RESULT);\n      node.addChildToBack(transform(statementNode.getExpression()));\n      node.setLineno(statementNode.getLineno());\n      node.setCharno(position2charno(statementNode.getAbsolutePosition()));\n      return node;\n    }\n\n    @Override\n    Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(\n          Token.",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..6cd1c72f 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -384,183 +384,246 @@ public class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+public class IRFactory implements NodeTransformer {\n+  private static final Set<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\");\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+  private final String sourceName;\n+  private final ErrorReporter errorReporter;\n+  private final CodingConvention codingConvention;\n \n-      int nType = n.getType();\n-      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n-          n.getFirstChild().getType() == Token.STRING &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  IRFactory(String sourceName, ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.errorReporter = errorReporter;\n+    this.codingConvention = new GoogleCodingConvention();\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+  @Override\n+  public Node transform(Node node) {\n+    return node;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+  /**\n+   * Overrides for all statement types.\n+   */\n+  private abstract static class TransformDispatcher implements TypeSafeDispatcher {\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    public final void process(Node node) {\n+      throw new IllegalStateException(\"Unexpected concrete Node type: \" + node.getClass());\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+    abstract Node processBlock(Block blockNode);\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    abstract Node processExpressionStatement(ExpressionStatement statementNode);\n+\n+    abstract Node processIfStatement(IfStatement statementNode);\n+\n+    abstract Node processSwitch(SwitchStatement switchNode);\n+\n+    abstract Node processWhileLoop(WhileLoop loopNode);\n+\n+    abstract Node processDoLoop(DoLoop loopNode);\n+\n+    abstract Node processForLoop(ForLoop loopNode);\n+\n+    abstract Node processForInLoop(ForInLoop loopNode);\n+\n+    abstract Node processFunctionNode(FunctionNode functionNode);\n+\n+    abstract Node processBreakStatement(BreakStatement statementNode);\n+\n+    abstract Node processContinueStatement(ContinueStatement statementNode);\n+\n+    abstract Node processTry(TryStatement tryNode);\n+\n+    abstract Node processThrow(ThrowStatement throwNode);\n+\n+    abstract Node processReturn(ReturnStatement returnNode);\n+\n+    abstract Node processWith(WithStatement withNode);\n+\n+    abstract Node processLabel(Label label);\n+\n+    abstract Node processSwitchCase(SwitchCase switchCase);\n+\n+    abstract Node processDefaultCase(Node defaultCase);\n+\n+    abstract Node processCatchClause(CatchClause catchClause);\n+\n+    abstract Node processDebuggerStatement(DebuggerStatement debuggerStatement);\n+\n+    abstract Node processEmptyExpression(EmptyExpression exprNode);\n+\n+    abstract Node processElementGet(ElementGet getNode);\n+\n+    abstract Node processConditionalExpression(ConditionalExpression exprNode);\n+\n+    abstract Node processNewExpression(NewExpression newExprNode);\n+\n+    abstract Node processUnaryExpression(UnaryExpression unaryExprNode);\n+\n+    abstract Node processBinaryExpression(BinaryExpression binaryExprNode);\n+\n+    abstract Node processAssignment(Assignment assignmentNode);\n+\n+    abstract Node processName(Name nameNode);\n+\n+    abstract Node processNumber(NumberLiteral numberNode);\n+\n+    abstract Node processString(StringLiteral stringNode);\n+\n+    abstract Node processRegExp(RegExpLiteral regExpNode);\n+\n+    abstract Node processGetProp(GetProp node);\n+\n+    abstract Node processObjectLit(ObjectLiteral objLitNode);\n+\n+    abstract Node processArrayLit(ArrayLiteral arrayLitNode);\n+\n+    abstract Node processObjectProperty(ObjectProperty objPropNode);\n+\n+    abstract Node processFunctionCall(FunctionCall callNode);\n+\n+    abstract Node processThis(ThisLiteral thisNode);\n+\n+    abstract Node processNull(NullLiteral nullNode);\n+\n+    abstract Node processBoolean(BooleanLiteral booleanNode);\n+\n+    abstract Node processVariableDeclarationList(\n+        VariableDeclarationList declarationList,\n+        Token declarationType);\n+\n+    abstract Node processVariableDeclaration(\n+        VariableDeclaration declaration,\n+        Token declarationType);\n+\n+    abstract Node processComment(Comment commentNode);\n+  }\n+\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n       }\n-      return node;\n     }\n+    return false;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  private boolean isDirective(Node n) {\n+    if (n == null) {\n+      return false;\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n+    int nType = n.getType();\n+    return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n+        n.getFirstChild().getType() == Token.STRING &&\n+        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+  private Node parseFunctionBody(ExpressionStatement stmt, FunctionNode fnNode) {\n+    checkNotNull(fnNode.getFunctionName());\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n-    }\n+    Node functionNode = newNode(Token.EXPR_RESULT, transform(fnNode));\n+    parseDirectives(fnNode.getBody());\n+    functionNode.useSourceInfoFrom(fnNode);\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    if (hasExceptionHandler(fnNode.getBody())) {\n+      errorReporter.warning(\n+          \"try/catch statement around function body will be removed\",\n+          sourceName,\n+          fnNode.getLineno());\n     }\n+    return functionNode;\n+  }\n \n-    @Override\n-    Node processForLoop(ForLoop loopNode) {\n-      Node node = newNode(\n-          Token.FOR,\n-          transform(loopNode.getInitializer()),\n-          transform(loopNode.getCondition()),\n-          transform(loopNode.getIncrement()));\n-      node.addChildToBack(transformBlock(loopNode.getBody()));\n-      return node;\n-    }\n+  @Override\n+  public final Node transform(ExpressionStatement exprStmt) {\n+    AstNode expr = exprStmt.getExpression();\n+    int type = expr.getType();\n+\n+    switch (type) {\n+      case Token.STRING:\n+        // Handle top level required of modules.\n+        String required = codingConvention.extractRequirableModuleName(\n+            ((StringLiteral) expr).getValue());\n+        if (!required.isEmpty()) {\n+          Node requireCall = newNode(Token.CALL, newNode(Token.NAME, \"require\", expr));\n+          requireCall.addChildToBack(newNode(Token.STRING, required, expr));\n+          return requireCall;\n+        }\n+        if (isDirective(expr)) {\n+          return null;\n+        }\n+        break;\n+\n+      case Token.CALL:\n+        FunctionCall call = (FunctionCall) expr;\n+        if (call.getTarget().getType() == Token.NAME) {\n+          String functionName = ((Name) call.getTarget()).getIdentifier();\n+          // Handle top level required of modules.\n+          required = codingConvention.extractRequirableModuleName(functionName);\n+          if (!required.isEmpty()) {\n+            Node newCall = newNode(Token.CALL, newNode(Token.NAME, \"require\", expr));\n+            newCall.addChildToBack(newNode(Token.STRING, required, expr));\n+            for (AstNode child : call.getArguments()) {\n+              newCall.addChildToBack(transform(child));\n+            }\n+            newCall.setLineno(call.getLineno());\n+            newCall.setCharno(call.getCharno());\n+            return newCall;\n+          }\n+        }\n+        break;\n \n-    @Override\n-    Node processFunctionCall(FunctionCall callNode) {\n-      Node node = newNode(transformTokenType(callNode.getType()),\n-                           transform(callNode.getTarget()));\n-      for (AstNode child : callNode.getArguments()) {\n-        node.addChildToBack(transform(child));\n-      }\n+      case Token.FUNCTION:\n+        return parseFunctionBody(exprStmt, (FunctionNode) expr);\n \n-      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n-      node.setLineno(callNode.getLineno());\n-      node.setCharno(position2charno(leftParamPos));\n-      return node;\n+      default:\n+        break;\n     }\n \n-    @Override\n-    Node processFunctionNode(FunctionNode functionNode) {\n-      Name name = functionNode.getFunctionName();\n-      Boolean isUnnamedFunction = false;\n-      if (name == null) {\n-        name = new Name();\n-        name.setIdentifier(\"\");\n-        isUnnamedFunction = true;\n-      }\n-      Node node = newNode(Token.FUNCTION);\n-      Node newName = transform(name);\n-      if (isUnnamedFunction) {\n-        // Old Rhino tagged the empty name node with the line number of the\n-        // declaration.\n-        newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() +\n-            functionNode.getLp();\n-        newName.setCharno(position2charno(lpColumn));\n-      }\n+    Node result = processExpressionStatement(exprStmt);\n+    return result;\n+  }\n \n-      node.addChildToBack(newName);\n-      Node lp = newNode(Token.LP);\n-      // The left paren's complicated because it's not represented by an\n-      // AstNode, so there's nothing that has the actual line number that it\n-      // appeared on.  We know the paren has to appear on the same line as the\n-      // function name (or else a semicolon will be inserted.)  If there's no\n-      // function name, assume the paren was on the same line as the function.\n-      // TODO(bowdidge): Mark line number of paren correctly.\n-      Name fnName = functionNode.getFunctionName();\n-      if (fnName != null) {\n-        lp.setLineno(fnName.getLineno());\n-      } else {\n-        lp.setLineno(functionNode.getLineno());\n-      }\n-      int lparenCharno = functionNode.getLp() +\n-          functionNode.getAbsolutePosition();\n+  @Override\n+  public final Node transform(FunctionNode fnNode) {\n+    Node result = processFunctionNode(fnNode);\n+    return result;\n+  }\n+\n+  private final class CommonTransforms extends TransformDispatcher {\n \n-      lp.setCharno(position2charno(lparenCharno));\n-      for (AstNode param : functionNode.getParams()) {\n-        lp.addChildToBack(transform(param));\n+    @Override\n+    Node processBlock(Block blockNode) {\n+      Node block = newNode(Token.BLOCK);\n+      for (Node n = blockNode.getFirstChild(); n != null; n = n.getNext()) {\n+        Node transformed = transform(n);\n+        if (transformed != null) {\n+          block.addChildToBack(transformed);\n+        }\n       }\n-      node.addChildToBack(lp);\n+      block.setLineno(blockNode.getLineno());\n+      return block;\n+    }\n \n-      Node bodyNode = transform(functionNode.getBody());\n-      parseDirectives(bodyNode);\n-      node.addChildToBack(bodyNode);\n-     return node;\n+    @Override\n+    Node processExpressionStatement(ExpressionStatement statementNode) {\n+      Node node = newNode(Token.EXPR_RESULT);\n+      node.addChildToBack(transform(statementNode.getExpression()));\n+      node.setLineno(statementNode.getLineno());\n+      node.setCharno(position2charno(statementNode.getAbsolutePosition()));\n+      return node;\n     }\n \n+    @Override\n+    Node processIfStatement(IfStatement statementNode) {\n+      Node node = newNode(\n+          Token.\n+\n     @Override\n     Node processIfStatement(IfStatement statementNode) {\n       Node node = newNode(Token.IF);",
    "result_reason": "error: <identifier> expected",
    "test_result": "ERROR"
}