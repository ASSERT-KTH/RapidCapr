{
    "patch": "private boolean isDirective(Node n) {\n  if (n == null) return false;\n\n  int nType = n.getType();\n  return nType == Token.EXPR_RESULT &&\n      n.getFirstChild().isString() &&\n      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n}\n\n@Override\nNode processBlock(Block blockNode) {\n  return processGeneric(blockNode);\n}\n\n@Override\nNode processBreakStatement(BreakStatement statementNode) {\n  Node node = newNode(Token.BREAK);\n  if (statementNode.getBreakLabel() != null) {\n    Node labelName = transform(statementNode.getBreakLabel());\n    // Change the NAME to LABEL_NAME\n    labelName.setType(Token.LABEL_NAME);\n    node.addChildToBack(labelName);\n  }\n  return node;\n}\n\n@Override\nNode processCatchClause(CatchClause clauseNode) {\n  AstNode catchVar = clauseNode.getVarName();\n  Node node = newNode(Token.CATCH, transform(catchVar));\n  if (clauseNode.getCatchCondition() != null) {\n    errorReporter.error(\n        \"Catch clauses are not supported\",\n        sourceName,\n        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n  }\n  node.addChildToBack(transformBlock(clauseNode.getBody()));\n  return node;\n}\n\n@Override\nNode processConditionalExpression(ConditionalExpression exprNode) {\n  return newNode(\n      Token.HOOK,\n      transform(exprNode.getTestExpression()),\n      transform(exprNode.getTrueExpression()),\n      transform(exprNode.getFalseExpression()));\n}\n\n@Override\nNode processContinueStatement(ContinueStatement statementNode) {\n  Node node = newNode(Token.CONTINUE);\n  if (statementNode.getLabel() != null) {\n    Node labelName = transform(statementNode.getLabel());\n    // Change the NAME to LABEL_NAME\n    labelName.setType(Token.LABEL_NAME);\n    node.addChildToBack(labelName);\n  }\n  return node;\n}\n\n@Override\nNode processDoLoop(DoLoop loopNode) {\n  return newNode(\n      Token.DO,\n      transformBlock(loopNode.getBody()),\n      transform(loopNode.getCondition()));\n}\n\n@Override\nNode processElementGet(ElementGet getNode) {\n  return newNode(\n      Token.GETELEM,\n      transform(getNode.getTarget()),\n      transform(getNode.getElement()));\n}\n\n@Override\nNode processEmptyExpression(EmptyExpression exprNode) {\n  Node node = newNode(Token.EMPTY);\n  return node;\n}\n\n@Override\nNode processExpressionStatement(ExpressionStatement statementNode) {\n  Node expr = statementNode.getExpression();\n  int type = transformTokenType(statementNode.getType());\n\n  if (isDirective(expr)) {\n    Node node = newNode(Token.EXPR_RESULT, transform(expr));\n    node.setIsDirective(true);\n    return node;\n  } else if (type == Token.FUNCTION) {\n    // Do not translate function definitions yet, let the caller do that.\n    return newNode(Token.EMPTY);\n  } else {\n    Node node = new Node(type, expr.getLineno());\n    node.copyInformationFrom(expr);\n    node.addChildToBack(transform(expr));\n    return node;\n  }\n}\n\n@Override\nNode processForInLoop(ForInLoop loopNode) {\n\n    // Return the bare minimum to put the AST in a valid state.\n  return newNode(\n      Token.FOR,\n      transform(loopNode.getIterator()),\n      transform(loopNode.getIteratedObject()),\n      transformBlock(loopNode.getBody()));\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..88702633 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,119 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+private boolean isDirective(Node n) {\n+  if (n == null) return false;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  int nType = n.getType();\n+  return nType == Token.EXPR_RESULT &&\n+      n.getFirstChild().isString() &&\n+      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+}\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+@Override\n+Node processBlock(Block blockNode) {\n+  return processGeneric(blockNode);\n+}\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+@Override\n+Node processBreakStatement(BreakStatement statementNode) {\n+  Node node = newNode(Token.BREAK);\n+  if (statementNode.getBreakLabel() != null) {\n+    Node labelName = transform(statementNode.getBreakLabel());\n+    // Change the NAME to LABEL_NAME\n+    labelName.setType(Token.LABEL_NAME);\n+    node.addChildToBack(labelName);\n+  }\n+  return node;\n+}\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n+@Override\n+Node processCatchClause(CatchClause clauseNode) {\n+  AstNode catchVar = clauseNode.getVarName();\n+  Node node = newNode(Token.CATCH, transform(catchVar));\n+  if (clauseNode.getCatchCondition() != null) {\n+    errorReporter.error(\n+        \"Catch clauses are not supported\",\n+        sourceName,\n+        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  }\n+  node.addChildToBack(transformBlock(clauseNode.getBody()));\n+  return node;\n+}\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+@Override\n+Node processConditionalExpression(ConditionalExpression exprNode) {\n+  return newNode(\n+      Token.HOOK,\n+      transform(exprNode.getTestExpression()),\n+      transform(exprNode.getTrueExpression()),\n+      transform(exprNode.getFalseExpression()));\n+}\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+@Override\n+Node processContinueStatement(ContinueStatement statementNode) {\n+  Node node = newNode(Token.CONTINUE);\n+  if (statementNode.getLabel() != null) {\n+    Node labelName = transform(statementNode.getLabel());\n+    // Change the NAME to LABEL_NAME\n+    labelName.setType(Token.LABEL_NAME);\n+    node.addChildToBack(labelName);\n+  }\n+  return node;\n+}\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+@Override\n+Node processDoLoop(DoLoop loopNode) {\n+  return newNode(\n+      Token.DO,\n+      transformBlock(loopNode.getBody()),\n+      transform(loopNode.getCondition()));\n+}\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n+@Override\n+Node processElementGet(ElementGet getNode) {\n+  return newNode(\n+      Token.GETELEM,\n+      transform(getNode.getTarget()),\n+      transform(getNode.getElement()));\n+}\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+@Override\n+Node processEmptyExpression(EmptyExpression exprNode) {\n+  Node node = newNode(Token.EMPTY);\n+  return node;\n+}\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n-    }\n+@Override\n+Node processExpressionStatement(ExpressionStatement statementNode) {\n+  Node expr = statementNode.getExpression();\n+  int type = transformTokenType(statementNode.getType());\n+\n+  if (isDirective(expr)) {\n+    Node node = newNode(Token.EXPR_RESULT, transform(expr));\n+    node.setIsDirective(true);\n+    return node;\n+  } else if (type == Token.FUNCTION) {\n+    // Do not translate function definitions yet, let the caller do that.\n+    return newNode(Token.EMPTY);\n+  } else {\n+    Node node = new Node(type, expr.getLineno());\n+    node.copyInformationFrom(expr);\n+    node.addChildToBack(transform(expr));\n+    return node;\n+  }\n+}\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+@Override\n+Node processForInLoop(ForInLoop loopNode) {\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+    // Return the bare minimum to put the AST in a valid state.\n+  return newNode(\n+      Token.FOR,\n+      transform(loopNode.getIterator()),\n+      transform(loopNode.getIteratedObject()),\n+      transformBlock(loopNode.getBody()));\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: incompatible types",
    "test_result": "ERROR"
}