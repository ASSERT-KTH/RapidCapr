{
    "patch": "          // No charsetEncoder provided - pass straight latin characters\n          // through, and escape the rest.  Doing the explicit character\n          // check is measurably faster than using the CharsetEncoder.\n          if (c > 0x1f && c <= 0x7e && c != quote && c != '\\\\') {\n            sb.append(c);\n          } else if (outputCharsetEncoder != null) {\n            // If the character can be encoded in our charset, do it.\n            CharBuffer charBuffer = CharBuffer.wrap(new char[] { c });\n            ByteBuffer byteBuffer = null;\n            try {\n              byteBuffer = outputCharsetEncoder.encode(charBuffer);\n            } catch (CharacterCodingException e) {\n              // Ignore and fall back to unicode escaping.\n            }\n            if (byteBuffer != null && byteBuffer.hasRemaining()) {\n              for (int j = byteBuffer.position(); j < byteBuffer.limit(); ++j) {\n                sb.append((char) byteBuffer.get(j));\n              }\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..4df75ca7 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,33 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+          // No charsetEncoder provided - pass straight latin characters\n+          // through, and escape the rest.  Doing the explicit character\n+          // check is measurably faster than using the CharsetEncoder.\n+          if (c > 0x1f && c <= 0x7e && c != quote && c != '\\\\') {\n+            sb.append(c);\n+          } else if (outputCharsetEncoder != null) {\n+            // If the character can be encoded in our charset, do it.\n+            CharBuffer charBuffer = CharBuffer.wrap(new char[] { c });\n+            ByteBuffer byteBuffer = null;\n+            try {\n+              byteBuffer = outputCharsetEncoder.encode(charBuffer);\n+            } catch (CharacterCodingException e) {\n+              // Ignore and fall back to unicode escaping.\n+            }\n+            if (byteBuffer != null && byteBuffer.hasRemaining()) {\n+              for (int j = byteBuffer.position(); j < byteBuffer.limit(); ++j) {\n+                sb.append((char) byteBuffer.get(j));\n+              }\n+            } else {\n+              appendHexJavaScriptRepresentation(sb, c);\n+            }\n+          } else {\n+            // Other characters can be misinterpreted by some js parsers,\n+            // or perhaps mangled by proxies along the way,\n+            // so we play it safe and unicode escape them.\n+            appendHexJavaScriptRepresentation(sb, c);\n+          }\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "result_reason": "error: 'else' without 'if'",
    "test_result": "ERROR"
}