{
    "patch": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n  // ...\n\n  if (finallyNode != null) {\n    Node parentFinallyNode = NodeUtil.getEnclosingFinallyNode(fromNode, parent);\n    if (parentFinallyNode == finallyNode) {\n      // We should add a conditional edge to the finallyNode.\n      cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n    } else {\n      // We should add an unconditional edge to the finallyNode.\n      cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n    }\n  }\n  return computeFollowNode(fromNode, parent, cfa);\n}\n\nprivate static Node getEnclosingFinallyNode(Node fromNode, Node currentNode) {\n  Node parent = currentNode.getParent();\n  while (parent != null) {\n    if (parent.getType() == Token.FINALLY) {\n      return parent;\n    }\n    currentNode = parent;\n    parent = currentNode.getParent();\n  }\n  return null;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..942590bc 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,33 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n+  // ...\n+\n+  if (finallyNode != null) {\n+    Node parentFinallyNode = NodeUtil.getEnclosingFinallyNode(fromNode, parent);\n+    if (parentFinallyNode == finallyNode) {\n+      // We should add a conditional edge to the finallyNode.\n+      cfa.createEdge(fromNode, Branch.ON_EX, finallyNode);\n+    } else {\n+      // We should add an unconditional edge to the finallyNode.\n+      cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+    }\n+  }\n+  return computeFollowNode(fromNode, parent, cfa);\n+}\n+\n+private static Node getEnclosingFinallyNode(Node fromNode, Node currentNode) {\n+  Node parent = currentNode.getParent();\n+  while (parent != null) {\n+    if (parent.getType() == Token.FINALLY) {\n+      return parent;\n+    }\n+    currentNode = parent;\n+    parent = currentNode.getParent();\n+  }\n+  return null;\n+}\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}