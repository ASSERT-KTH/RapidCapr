{
    "patch": "static String strEscape(String s, char quote,\n                        String doublequoteEscape,\n                        String singlequoteEscape,\n                        String backslashEscape,\n                        CharsetEncoder outputCharsetEncoder) {\n    StringBuilder sb = new StringBuilder(s.length() + 2);\n    sb.append(quote);\n    for (int i = 0; i < s.length(); i++) {\n        char c = s.charAt(i);\n        switch (c) {\n            case '\\0':\n                sb.append(\"\\\\0\");\n                break;\n            case '\\n':\n                sb.append(\"\\\\n\");\n                break;\n            case '\\r':\n                sb.append(\"\\\\r\");\n                break;\n            case '\\t':\n                sb.append(\"\\\\t\");\n                break;\n            case '\\\\':\n                sb.append(backslashEscape);\n                break;\n            case '\\\"':\n                sb.append(doublequoteEscape);\n                break;\n            case '\\'':\n                sb.append(singlequoteEscape);\n                break;\n            case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n                if (i >= 2 &&\n                        ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n                                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n                    sb.append(\"\\\\>\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            case '<':\n                // Break </script into <\\/script\n                final String END_SCRIPT = \"/script\";\n\n                // Break <!-- into <\\!--\n                final String START_COMMENT = \"!--\";\n\n                if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n                        END_SCRIPT.length())) {\n                    sb.append(\"<\\\\\");\n                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n                        START_COMMENT.length())) {\n                    sb.append(\"<\\\\\");\n                } else {\n                    sb.append(c);\n                }\n                break;\n            default:\n                if (outputCharsetEncoder != null) {\n                    if (outputCharsetEncoder.canEncode(c)) {\n                        sb.append(c);\n                    } else {\n                        // Fix added here to use Java's built-in hex encoding\n                        ByteBuffer buffer = outputCharsetEncoder.encode(CharBuffer.wrap(Character.toString(c)));\n                        while (buffer.hasRemaining()) {\n                            sb.append(String.format(\"\\\\u%04x\", buffer.get() & 0xFF));\n                        }\n                    }\n                } else if (c >= 0x1f && c < 0x7f) {\n                    sb.append(c);\n                } else {\n                    // Fix added here to use Java's built-in hex encoding\n                    sb.append(\"\\\\u\");\n                    sb.append(String.format(\"%04x\", (int) c));\n                }\n                break;\n        }\n    }\n    sb.append(quote);\n    return sb.toString();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 6117a89b..8b4d868c 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1002,77 +1002,87 @@ class CodeGenerator {\n   }\n \n   /** Helper to escape javascript string as well as regular expression */\n-  static String strEscape(String s, char quote,\n-                          String doublequoteEscape,\n-                          String singlequoteEscape,\n-                          String backslashEscape,\n-                          CharsetEncoder outputCharsetEncoder) {\n+static String strEscape(String s, char quote,\n+                        String doublequoteEscape,\n+                        String singlequoteEscape,\n+                        String backslashEscape,\n+                        CharsetEncoder outputCharsetEncoder) {\n     StringBuilder sb = new StringBuilder(s.length() + 2);\n     sb.append(quote);\n     for (int i = 0; i < s.length(); i++) {\n-      char c = s.charAt(i);\n-      switch (c) {\n-        case '\\0': sb.append(\"\\\\0\"); break;\n-        case '\\n': sb.append(\"\\\\n\"); break;\n-        case '\\r': sb.append(\"\\\\r\"); break;\n-        case '\\t': sb.append(\"\\\\t\"); break;\n-        case '\\\\': sb.append(backslashEscape); break;\n-        case '\\\"': sb.append(doublequoteEscape); break;\n-        case '\\'': sb.append(singlequoteEscape); break;\n-        case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n-          if (i >= 2 &&\n-              ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n-               (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n-            sb.append(\"\\\\>\");\n-          } else {\n-            sb.append(c);\n-          }\n-          break;\n-        case '<':\n-          // Break </script into <\\/script\n-          final String END_SCRIPT = \"/script\";\n-\n-          // Break <!-- into <\\!--\n-          final String START_COMMENT = \"!--\";\n-\n-          if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n-                              END_SCRIPT.length())) {\n-            sb.append(\"<\\\\\");\n-          } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n-                                     START_COMMENT.length())) {\n-            sb.append(\"<\\\\\");\n-          } else {\n-            sb.append(c);\n-          }\n-          break;\n-        default:\n-          // If we're given an outputCharsetEncoder, then check if the\n-          //  character can be represented in this character set.\n-          if (outputCharsetEncoder != null) {\n-            if (outputCharsetEncoder.canEncode(c)) {\n-              sb.append(c);\n-            } else {\n-              // Unicode-escape the character.\n-              appendHexJavaScriptRepresentation(sb, c);\n-            }\n-          } else {\n-            // No charsetEncoder provided - pass straight latin characters\n-            // through, and escape the rest.  Doing the explicit character\n-            // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c < 0x7f) {\n-              sb.append(c);\n-            } else {\n-              // Other characters can be misinterpreted by some js parsers,\n-              // or perhaps mangled by proxies along the way,\n-              // so we play it safe and unicode escape them.\n-              appendHexJavaScriptRepresentation(sb, c);\n-            }\n-          }\n-      }\n+        char c = s.charAt(i);\n+        switch (c) {\n+            case '\\0':\n+                sb.append(\"\\\\0\");\n+                break;\n+            case '\\n':\n+                sb.append(\"\\\\n\");\n+                break;\n+            case '\\r':\n+                sb.append(\"\\\\r\");\n+                break;\n+            case '\\t':\n+                sb.append(\"\\\\t\");\n+                break;\n+            case '\\\\':\n+                sb.append(backslashEscape);\n+                break;\n+            case '\\\"':\n+                sb.append(doublequoteEscape);\n+                break;\n+            case '\\'':\n+                sb.append(singlequoteEscape);\n+                break;\n+            case '>':                       // Break --> into --\\> or ]]> into ]]\\>\n+                if (i >= 2 &&\n+                        ((s.charAt(i - 1) == '-' && s.charAt(i - 2) == '-') ||\n+                                (s.charAt(i - 1) == ']' && s.charAt(i - 2) == ']'))) {\n+                    sb.append(\"\\\\>\");\n+                } else {\n+                    sb.append(c);\n+                }\n+                break;\n+            case '<':\n+                // Break </script into <\\/script\n+                final String END_SCRIPT = \"/script\";\n+\n+                // Break <!-- into <\\!--\n+                final String START_COMMENT = \"!--\";\n+\n+                if (s.regionMatches(true, i + 1, END_SCRIPT, 0,\n+                        END_SCRIPT.length())) {\n+                    sb.append(\"<\\\\\");\n+                } else if (s.regionMatches(false, i + 1, START_COMMENT, 0,\n+                        START_COMMENT.length())) {\n+                    sb.append(\"<\\\\\");\n+                } else {\n+                    sb.append(c);\n+                }\n+                break;\n+            default:\n+                if (outputCharsetEncoder != null) {\n+                    if (outputCharsetEncoder.canEncode(c)) {\n+                        sb.append(c);\n+                    } else {\n+                        // Fix added here to use Java's built-in hex encoding\n+                        ByteBuffer buffer = outputCharsetEncoder.encode(CharBuffer.wrap(Character.toString(c)));\n+                        while (buffer.hasRemaining()) {\n+                            sb.append(String.format(\"\\\\u%04x\", buffer.get() & 0xFF));\n+                        }\n+                    }\n+                } else if (c >= 0x1f && c < 0x7f) {\n+                    sb.append(c);\n+                } else {\n+                    // Fix added here to use Java's built-in hex encoding\n+                    sb.append(\"\\\\u\");\n+                    sb.append(String.format(\"%04x\", (int) c));\n+                }\n+                break;\n+        }\n     }\n     sb.append(quote);\n     return sb.toString();\n-  }\n+}\n \n   static String identifierEscape(String s) {\n     // First check if escaping is needed at all -- in most cases it isn't.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}