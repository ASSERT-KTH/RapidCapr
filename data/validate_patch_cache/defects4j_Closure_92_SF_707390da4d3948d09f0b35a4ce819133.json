{
    "patch": "void addImplicitNamespaces() {\n  Set<String> implicitNamespaces = Sets.newHashSet();\n\n  for (JSModule module : compiler.getModules()) {\n    for (NodeTraversal t = new NodeTraversal(compiler, new ModuleScopeCreator(compiler));\n        t.getScopeRoot() != null;\n        t = t.getCallback().getModuleScopeTraversal()) {\n      // Look for cases where non-local symbols are referred to.\n      NodeTraversal.traverse(compiler, t.getScopeRoot(), new SyntacticScopeCreator(compiler),\n          new ImplicitNamespacesCallback(t, implicitNamespaces));\n    }\n  }\n\n  for (String namespace : implicitNamespaces) {\n    // Create a tree of the implicit namespace, but don't insert the new nodes yet.\n    SplitName splitName = SplitName.split(namespace);\n    Node parent = getBase(splitName.parent);\n    for (int i = 0; i < splitName.parts.size() - 1; i++) {\n      Node namespaceNode =\n          new Node(Token.NAMESPACE,\n              new Node(Token.STRING, splitName.parts.get(i)),\n              new Node(Token.EMPTY));\n      namespaceNode.putProp(Node.ORIGINALNAME_PROP, namespace + '.' + splitName.parts.get(i));\n      parent.addChildToBack(namespaceNode);\n      parent = namespaceNode.getFirstChild();\n    }\n\n    // Create the declaration node and insert it into the AST.\n    Node lastNamespaceNode =\n        new Node(Token.NAMESPACE,\n            new Node(Token.STRING, splitName.parts.get(splitName.parts.size() - 1)),\n            createDeclarationNode());\n    lastNamespaceNode.putProp(Node.ORIGINALNAME_PROP,\n        namespace + '.' + splitName.parts.get(splitName.parts.size() - 1));\n    ProvidedName provided =\n        new ProvidedName(parent, lastNamespaceNode.getFirstChild(), lastNamespaceNode);\n    providedNames.put(namespace, provided);\n    implicitNamespaceNodes.add(provided.replacementNode);\n    minimumModule = Math.min(minimumModule, findModuleForNamespace(namespace));\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex c929a363..1ef68ac6 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -744,69 +744,47 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n      * If we're providing a name with a duplicate definition, then make sure\n      * that definition becomes a declaration.\n      */\n-    void replace() {\n-      if (firstNode == null) {\n-        // Don't touch the base case ('goog').\n-        replacementNode = candidateDefinition;\n-        return;\n-      }\n+void addImplicitNamespaces() {\n+  Set<String> implicitNamespaces = Sets.newHashSet();\n \n-      // Handle the case where there is a duplicate definition for an explicitly\n-      // provided symbol.\n-      if (candidateDefinition != null && explicitNode != null) {\n-        explicitNode.detachFromParent();\n-        compiler.reportCodeChange();\n-\n-        // Does this need a VAR keyword?\n-        replacementNode = candidateDefinition;\n-        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n-          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n-          Node assignNode = candidateDefinition.getFirstChild();\n-          Node nameNode = assignNode.getFirstChild();\n-          if (nameNode.getType() == Token.NAME) {\n-            // Need to convert this assign to a var declaration.\n-            Node valueNode = nameNode.getNext();\n-            assignNode.removeChild(nameNode);\n-            assignNode.removeChild(valueNode);\n-            nameNode.addChildToFront(valueNode);\n-            Node varNode = new Node(Token.VAR, nameNode);\n-            varNode.copyInformationFrom(candidateDefinition);\n-            candidateDefinition.getParent().replaceChild(\n-                candidateDefinition, varNode);\n-            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n-            compiler.reportCodeChange();\n-            replacementNode = varNode;\n-          }\n-        }\n-      } else {\n-        // Handle the case where there's not a duplicate definition.\n-        replacementNode = createDeclarationNode();\n-        if (firstModule == minimumModule) {\n-          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n-        } else {\n-          // In this case, the name was implicitly provided by two independent\n-          // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n-          if (indexOfDot == -1) {\n-            // Any old place is fine.\n-            compiler.getNodeForCodeInsertion(minimumModule)\n-                .addChildToBack(replacementNode);\n-          } else {\n-            // Add it after the parent namespace.\n-            ProvidedName parentName =\n-                providedNames.get(namespace.substring(0, indexOfDot));\n-            Preconditions.checkNotNull(parentName);\n-            Preconditions.checkNotNull(parentName.replacementNode);\n-            parentName.replacementNode.getParent().addChildAfter(\n-                replacementNode, parentName.replacementNode);\n-          }\n-        }\n-        if (explicitNode != null) {\n-          explicitNode.detachFromParent();\n-        }\n-        compiler.reportCodeChange();\n-      }\n+  for (JSModule module : compiler.getModules()) {\n+    for (NodeTraversal t = new NodeTraversal(compiler, new ModuleScopeCreator(compiler));\n+        t.getScopeRoot() != null;\n+        t = t.getCallback().getModuleScopeTraversal()) {\n+      // Look for cases where non-local symbols are referred to.\n+      NodeTraversal.traverse(compiler, t.getScopeRoot(), new SyntacticScopeCreator(compiler),\n+          new ImplicitNamespacesCallback(t, implicitNamespaces));\n     }\n+  }\n+\n+  for (String namespace : implicitNamespaces) {\n+    // Create a tree of the implicit namespace, but don't insert the new nodes yet.\n+    SplitName splitName = SplitName.split(namespace);\n+    Node parent = getBase(splitName.parent);\n+    for (int i = 0; i < splitName.parts.size() - 1; i++) {\n+      Node namespaceNode =\n+          new Node(Token.NAMESPACE,\n+              new Node(Token.STRING, splitName.parts.get(i)),\n+              new Node(Token.EMPTY));\n+      namespaceNode.putProp(Node.ORIGINALNAME_PROP, namespace + '.' + splitName.parts.get(i));\n+      parent.addChildToBack(namespaceNode);\n+      parent = namespaceNode.getFirstChild();\n+    }\n+\n+    // Create the declaration node and insert it into the AST.\n+    Node lastNamespaceNode =\n+        new Node(Token.NAMESPACE,\n+            new Node(Token.STRING, splitName.parts.get(splitName.parts.size() - 1)),\n+            createDeclarationNode());\n+    lastNamespaceNode.putProp(Node.ORIGINALNAME_PROP,\n+        namespace + '.' + splitName.parts.get(splitName.parts.size() - 1));\n+    ProvidedName provided =\n+        new ProvidedName(parent, lastNamespaceNode.getFirstChild(), lastNamespaceNode);\n+    providedNames.put(namespace, provided);\n+    implicitNamespaceNodes.add(provided.replacementNode);\n+    minimumModule = Math.min(minimumModule, findModuleForNamespace(namespace));\n+  }\n+}\n \n     /**\n      * Create the declaration node for this name, without inserting it",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}