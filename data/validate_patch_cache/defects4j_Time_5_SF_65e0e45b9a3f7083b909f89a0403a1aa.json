{
    "patch": "public Period normalizedStandard(PeriodType type) {\n    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n\n    type = DateTimeUtils.getPeriodType(type);\n    PeriodType normalizedType = type.isPrecise() ? type : PeriodType.dayTime();\n    Period normalized = new Period(this, normalizedType);\n\n    // normalize years and months separately, since they are variable duration\n    if (normalizedType.isSupported(DurationFieldType.years()) || normalizedType.isSupported(DurationFieldType.months())) {\n        long yearMonthMillis = 0;\n        long yearMillis = 0;\n\n        // add years/months as duration to millis\n        if (normalizedType.isSupported(DurationFieldType.years())) {\n            yearMonthMillis = (long) (normalized.getYears() * ((double) DateTimeConstants.MILLIS_PER_YEAR / 12));\n            yearMillis = normalized.getYears() * DateTimeConstants.MILLIS_PER_YEAR;\n        }\n        if (normalizedType.isSupported(DurationFieldType.months())) {\n            yearMonthMillis += (long) (normalized.getMonths() * ((double) DateTimeConstants.MILLIS_PER_YEAR / 12));\n        }\n\n        // add year/month millis to duration\n        millis += yearMonthMillis;\n        normalized = normalized.withYears(0).withMonths(0);\n\n        // create temporary period with years and months\n        Period tmpPeriod = new Period(yearMillis + yearMonthMillis, PeriodType.yearMonth(), ISOChronology.getInstanceUTC());\n        tmpPeriod = tmpPeriod.normalizedStandard(ISOChronology.getInstanceUTC());\n\n        // add normalized years and months back to the duration\n        if (normalizedType.isSupported(DurationFieldType.years())) {\n            normalized = normalized.withYears(tmpPeriod.getYears());\n        }\n        if (normalizedType.isSupported(DurationFieldType.months())) {\n            normalized = normalized.withMonths(tmpPeriod.getMonths());\n        }\n    }\n\n    // normalize the remaining fields using standard duration normalization\n    return new Period(millis + normalized.normalizedStandard().toDurationFrom(ISOChronology.getInstanceUTC()).getMillis(), type, ISOChronology.getInstanceUTC());\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/Period.java b/src/main/java/org/joda/time/Period.java\nindex f4047933..695580d8 100644\n--- a/src/main/java/org/joda/time/Period.java\n+++ b/src/main/java/org/joda/time/Period.java\n@@ -1613,28 +1613,51 @@ public final class Period\n      *  years or months but the specified period type does not support them\n      * @since 1.5\n      */\n-    public Period normalizedStandard(PeriodType type) {\n-        type = DateTimeUtils.getPeriodType(type);\n-        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n-        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n-        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n-        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n-        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n-        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n-        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n-        int years = getYears();\n-        int months = getMonths();\n-        if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n-            }\n+public Period normalizedStandard(PeriodType type) {\n+    long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n+    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n+    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n+    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n+    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n+    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n+\n+    type = DateTimeUtils.getPeriodType(type);\n+    PeriodType normalizedType = type.isPrecise() ? type : PeriodType.dayTime();\n+    Period normalized = new Period(this, normalizedType);\n+\n+    // normalize years and months separately, since they are variable duration\n+    if (normalizedType.isSupported(DurationFieldType.years()) || normalizedType.isSupported(DurationFieldType.months())) {\n+        long yearMonthMillis = 0;\n+        long yearMillis = 0;\n+\n+        // add years/months as duration to millis\n+        if (normalizedType.isSupported(DurationFieldType.years())) {\n+            yearMonthMillis = (long) (normalized.getYears() * ((double) DateTimeConstants.MILLIS_PER_YEAR / 12));\n+            yearMillis = normalized.getYears() * DateTimeConstants.MILLIS_PER_YEAR;\n+        }\n+        if (normalizedType.isSupported(DurationFieldType.months())) {\n+            yearMonthMillis += (long) (normalized.getMonths() * ((double) DateTimeConstants.MILLIS_PER_YEAR / 12));\n+        }\n+\n+        // add year/month millis to duration\n+        millis += yearMonthMillis;\n+        normalized = normalized.withYears(0).withMonths(0);\n+\n+        // create temporary period with years and months\n+        Period tmpPeriod = new Period(yearMillis + yearMonthMillis, PeriodType.yearMonth(), ISOChronology.getInstanceUTC());\n+        tmpPeriod = tmpPeriod.normalizedStandard(ISOChronology.getInstanceUTC());\n+\n+        // add normalized years and months back to the duration\n+        if (normalizedType.isSupported(DurationFieldType.years())) {\n+            normalized = normalized.withYears(tmpPeriod.getYears());\n+        }\n+        if (normalizedType.isSupported(DurationFieldType.months())) {\n+            normalized = normalized.withMonths(tmpPeriod.getMonths());\n         }\n-        return result;\n     }\n \n+    // normalize the remaining fields using standard duration normalization\n+    return new Period(millis + normalized.normalizedStandard().toDurationFrom(ISOChronology.getInstanceUTC()).getMillis(), type, ISOChronology.getInstanceUTC());\n+}\n+\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}