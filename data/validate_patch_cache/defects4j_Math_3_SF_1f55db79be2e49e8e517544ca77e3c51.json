{
    "patch": "public static double linearCombination(final double[] a, final double[] b)\n    throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n    double prodHighCur = a[0] * b[0];\n    double prodHighNext = 0.0;\n    double sHighPrev = prodHighCur;\n    double sPrime = 0.0;\n    double sLowSum = 0.0;\n    double prodLowSum = 0.0;\n\n    if (len == 1) {\n        return prodHighCur;\n    }\n\n    // Revert to scalar multiplication.\n    for (int i = 1; i < len; i++) {\n        prodHighNext = a[i] * b[i];\n        sHighPrev += prodHighNext;\n        sPrime = sHighPrev - prodHighNext;\n        sLowSum += ((prodHighNext - sPrime) + (prodHighCur - (sHighPrev - sPrime)));\n        prodHighCur = sHighPrev;\n        prodLowSum += a[i] *\n                      (b[i] - prodHighNext / a[i]);\n    }\n\n    double result = sHighPrev + (prodLowSum + sLowSum);\n\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; i++) {\n            result += a[i] * b[i];\n        }\n    }\n\n    return result;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..ace991dfc 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -811,66 +811,48 @@ public class MathArrays {\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n-    public static double linearCombination(final double[] a, final double[] b)\n-        throws DimensionMismatchException {\n-        final int len = a.length;\n-        if (len != b.length) {\n-            throw new DimensionMismatchException(len, b.length);\n-        }\n+public static double linearCombination(final double[] a, final double[] b)\n+    throws DimensionMismatchException {\n+    final int len = a.length;\n+    if (len != b.length) {\n+        throw new DimensionMismatchException(len, b.length);\n+    }\n+    double prodHighCur = a[0] * b[0];\n+    double prodHighNext = 0.0;\n+    double sHighPrev = prodHighCur;\n+    double sPrime = 0.0;\n+    double sLowSum = 0.0;\n+    double prodLowSum = 0.0;\n+\n+    if (len == 1) {\n+        return prodHighCur;\n+    }\n \n-            // Revert to scalar multiplication.\n+    // Revert to scalar multiplication.\n+    for (int i = 1; i < len; i++) {\n+        prodHighNext = a[i] * b[i];\n+        sHighPrev += prodHighNext;\n+        sPrime = sHighPrev - prodHighNext;\n+        sLowSum += ((prodHighNext - sPrime) + (prodHighCur - (sHighPrev - sPrime)));\n+        prodHighCur = sHighPrev;\n+        prodLowSum += a[i] *\n+                      (b[i] - prodHighNext / a[i]);\n+    }\n \n-        final double[] prodHigh = new double[len];\n-        double prodLowSum = 0;\n+    double result = sHighPrev + (prodLowSum + sLowSum);\n \n+    if (Double.isNaN(result)) {\n+        // either we have split infinite numbers or some coefficients were NaNs,\n+        // just rely on the naive implementation and let IEEE754 handle this\n+        result = 0;\n         for (int i = 0; i < len; i++) {\n-            final double ai = a[i];\n-            final double ca = SPLIT_FACTOR * ai;\n-            final double aHigh = ca - (ca - ai);\n-            final double aLow = ai - aHigh;\n-\n-            final double bi = b[i];\n-            final double cb = SPLIT_FACTOR * bi;\n-            final double bHigh = cb - (cb - bi);\n-            final double bLow = bi - bHigh;\n-            prodHigh[i] = ai * bi;\n-            final double prodLow = aLow * bLow - (((prodHigh[i] -\n-                                                    aHigh * bHigh) -\n-                                                   aLow * bHigh) -\n-                                                  aHigh * bLow);\n-            prodLowSum += prodLow;\n-        }\n-\n-\n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n-\n-        final int lenMinusOne = len - 1;\n-        for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n-            final double sHighCur = sHighPrev + prodHighNext;\n-            sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n-            sHighPrev = sHighCur;\n-        }\n-\n-        double result = sHighPrev + (prodLowSum + sLowSum);\n-\n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = 0;\n-            for (int i = 0; i < len; ++i) {\n-                result += a[i] * b[i];\n-            }\n+            result += a[i] * b[i];\n         }\n-\n-        return result;\n     }\n \n+    return result;\n+}\n+\n     /**\n      * Compute a linear combination accurately.\n      * <p>",
    "result_reason": "junit.framework.AssertionFailedError: expected:<-1.8551294182586249> but was:<0.0>",
    "test_result": "FAIL"
}