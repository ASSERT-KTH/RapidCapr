{
    "patch": "public class IRFactory extends AstNodeVisitor<Node> implements RawTransformer {\n    // ...\n\n    @Override\n    public Node transform(AstNode node) {\n        checkState(currentScriptOrFn != null, \"No root script in IRFactory\");\n\n        // Map the AST to its IR representation and wrap in a SCRIPT node.\n        return newNode(\n            Token.SCRIPT,\n            new Node(Token.FUNCTION, currentScriptOrFn, process(node)));\n    }\n\n    // ...\n\n    private Node processStatement(AstNode statementNode) {\n        switch (statementNode.getType()) {\n            case Token.BLOCK:\n                return processBlock((Block) statementNode);\n            case Token.BREAK:\n                return processBreakStatement((BreakStatement) statementNode);\n            case Token.CATCH:\n                return processCatchClause((CatchClause) statementNode);\n            case Token.CONST:\n            case Token.LET:\n            case Token.VAR:\n                return processVariableStatement((VariableDeclaration) statementNode);\n            case Token.CONTINUE:\n                return processContinueStatement((ContinueStatement) statementNode);\n            case Token.DEBUGGER:\n                return processDebuggerStatement((DebuggerStatement) statementNode);\n            case Token.DO:\n                return processDoLoop((DoLoop) statementNode);\n            case Token.EMPTY:\n                return processEmptyExpression((EmptyExpression) statementNode);\n            case Token.EXPR_VOID:\n                return processExpressionStatement((ExpressionStatement) statementNode);\n            case Token.FOR:\n                return processForLoop((ForLoop) statementNode);\n            case Token.FOR_IN:\n                return processForInLoop((ForInLoop) statementNode);\n            case Token.FUNCTION:\n                return processFunction((FunctionNode) statementNode);\n            case Token.IF:\n                return processIfStatement((IfStatement) statementNode);\n            case Token.RETURN:\n                return processReturnStatement((ReturnStatement) statementNode);\n            case Token.SWITCH:\n                return processSwitchStatement((SwitchStatement) statementNode);\n            case Token.THROW:\n                return processThrowStatement((ThrowStatement) statementNode);\n            case Token.TRY:\n                return processTryStatement((TryStatement) statementNode);\n            case Token.WHILE:\n                return processWhileLoop((WhileLoop) statementNode);\n            case Token.WITH:\n                errorReporter.error(\n                    \"With statements are not supported\",\n                    sourceName,\n                    statementNode.getLineno(), \"\", 0);\n                return newNode(Token.BLOCK);\n            default:\n                errorReporter.error(\n                    \"Unsupported or unrecognized statement type \" + statementNode.getType(),\n                    sourceName,\n                    statementNode.getLineno(), \"\", 0);\n                return newNode(Token.BLOCK);\n        }\n    }\n\n    private Node processExpression(AstNode exprNode) {\n      int type = exprNode.getType();\n      switch (type) {\n        case Token.FUNCTION:\n          return processFunction((FunctionNode) exprNode);\n        case Token.ARRAYLIT:\n          return processArrayLiteral((ArrayLiteral) exprNode);\n        case Token.OBJECTLIT:\n          return processObjectLiteral((ObjectLiteral) exprNode, null);\n        case Token.CALL:\n          return processFunctionCall((FunctionCall) exprNode);\n        case Token.NEW:\n          return processNewExpr((NewExpression) exprNode);\n        case Token.DOT:\n          return processPropertyGet((PropertyGet) exprNode);\n        case Token.NAME:\n          return processName((Name) exprNode);\n        case Token.GETPROP:\n          return processElementGet((ElementGet) exprNode);\n        case Token.THIS:\n          return processThis((ThisLiteral) exprNode);\n        case Token.ARRAYCOMP:\n          return processArrayComp((ArrayComprehension) exprNode);\n        case Token.COMPREHENSIONFOR:\n          return processArrayCompFor((ArrayComprehensionLoop) exprNode);\n        case Token.COMPREHENSIONIF:\n          return processArrayCompIf((ArrayComprehensionIf) exprNode);\n        case Token.FALSE:\n        case Token.TRUE:\n          return newNode(type);\n        case Token.NULL:\n          return newNode(Token.NULL);\n        case Token.NUMBER:\n        case Token.STRING:\n          return newNode(type, exprNode.getString());\n        case Token.REGEXP:\n          return processRegExp((RegExpLiteral) exprNode);\n        case Token.NOT:\n        case Token.POS:\n        case Token.NEG:\n        case Token.BITNOT:\n          return newNode(type, transform(exprNode.getFirstChild()));\n        case Token.HOOK:\n          return processConditionalExpression((ConditionalExpression) exprNode);\n        case Token.OR:\n        case Token.AND:\n        case Token.BITOR:\n        case Token.BITXOR:\n        case Token.BITAND:\n        case Token.SHEQ:\n        case Token.SHNE:\n        case Token.EQ:\n        case Token.NE:\n        case Token.LE:\n        case Token.LT:\n        case Token.GE:\n        case Token.GT:\n        case Token.INSTANCEOF:\n        case Token.IN:\n        case Token.LSH:\n        case Token.RSH:\n        case Token.URSH:\n        case Token.ADD:\n        case Token.SUB:\n        case Token.MUL:\n        case Token.DIV:\n        case Token.MOD:\n          return newNode(\n              type,\n              transform(exprNode.getFirstChild()),\n              transform(exprNode.getLastChild()));\n        case Token.TYPEOF:\n        case Token.VOID:\n        case Token.DELPROP:\n          return newNode(type, transform(exprNode.getFirstChild()));\n        case Token.INC:\n        case Token.DEC:\n          return newNode(type, processUnary((UnaryExpression) exprNode));\n        case Token.ASSIGN:\n          return processAssignment((Assignment) exprNode);\n        case Token.ASSIGN_ADD:\n        case Token.ASSIGN_SUB:\n        case Token.ASSIGN_MUL:\n        case Token.ASSIGN_DIV:\n        case Token.ASSIGN_MOD:\n        case Token.ASSIGN_BITOR:\n        case Token.ASSIGN_BITXOR:\n        case Token.ASSIGN_BITAND:\n        case Token.ASSIGN_LSH:\n        case Token.ASSIGN_RSH:\n        case Token.ASSIGN_URSH:\n          return processCompoundAssignment((Assignment) exprNode);\n        case Token.DEFAULTNAMESPACE:\n          return newNode(Token.DEFAULTNAMESPACE, transform(exprNode.getFirstChild()));\n        case Token.XMLLIT:\n          return processXmlLiteral((XmlLiteral) exprNode);\n        case Token.YIELD:\n          return processYield((Yield) exprNode);\n        case Token.TEMPLATELIT:\n          return processTemplateLiteral((TemplateLiteral) exprNode);\n        case Token.TEMPLATELIT_SUB:\n          return processTemplateLiteralSub((TemplateLiteral) exprNode);\n        default:\n          errorReporter.error(\n              \"Unsupported or unrecognized expression type \" + type,\n              sourceName,\n              exprNode.getLineno(), \"\", 0);\n          return newNode(Token.EMPTY);\n      }\n    }\n\n    private Node processUnary(UnaryExpression exprNode) {\n        return newNode(exprNode.getType(), transform(exprNode.getOperand()).detachFromParent());\n    }\n\n    private Node processBinary(BinaryExpression exprNode) {\n        Node lhs = transform(exprNode.getLeft());\n        Node rhs = transform(exprNode.getRight());\n        return newNode(exprNode.getType(), lhs.detachFromParent(), rhs.detachFromParent());\n    }\n\n    private Node processVariableName(String name, boolean isDestructuring) {\n        Node nameNode = createName(name);\n        if (isDestructuring) {\n            // We don't want the destructuring child to be confused with a NAME.\n            // We use a NOOP to mark it as \"ok to rename\".\n            nameNode.putProp(Node.IS_DUMMY_PLACEHOLDER, true);\n            setRequiresQualifiedName(true);\n            return newNode(Token.DESTRUCTURING_LHS, nameNode);\n        } else {\n            return nameNode;\n        }\n    }\n\n    private Node processVariableInitializers(\n        Node varNode, VariableDeclaration declarationNode) {\n\n        AstNode rhs = declarationNode.getInitializer();\n\n      // Check If this declaration node contains only one assignment with the right hand side\n      // being a function. For example, 'let x = function() { ... }'.\n      // If so, change the type of the parsed variable to 'GETFUN' and the type of\n      // its initializer's first child to FUNCTION.\n      if (rhs instanceof FunctionNode) {\n        // This node is similar to a VAR initially assigned to a function expression.\n        varNode.setType(Token.GETFUN);\n        Node functionNode = transform((FunctionNode) rhs);\n        if (functionNode.getFirstChild() != null\n            && functionNode.getFirstChild().getType() == Token.NAME) {\n          // See https://github.com/google/closure-compiler/issues/2107 for more details.\n          functionNode.getLastChild().addChildToFront(\n              newNode(Token.NAME, declarationNode.getString()));\n        }\n        functionNode.setType(Token.FUNCTION);\n        // Propagate the function's name to the VAR.\n        setJsDocInfoForVar(varNode, declarationNode);\n        varNode.addChildToBack(functionNode);\n        shorthandPropertyCheck(functionNode);\n      } else {\n        Node initializer = null;\n        if (rhs != null) {\n          initializer = transform(rhs);\n        }\n        varNode.addChildToBack(initializer == null ? new Node(Token.EMPTY) : initializer);\n      }\n\n      // Propagate the source information to the VAR node.\n      setJsDocInfoForVar(varNode, declarationNode);\n\n      return varNode;\n    }\n\n    private Node processVariableStatement(VariableDeclaration statementNode) {\n        Node varNode;\n        if (statementNode.isDestructuringDeclaration()) {\n          // Initialize the VAR with an empty child if we are going to add\n          // destructuring nodes later. This simplifies later checking of\n          // the children.\n          varNode = newNode(Token.VAR);\n          varNode.addChildToBack(new Node(Token.EMPTY));\n        } else {\n          varNode = createName(statementNode.getType());\n        }\n\n        // Convert each variable definition to a VAR statement.\n        for (VariableInitializer initNode : statementNode.getVariables()) {\n            if (initNode.isDestructuring()) {\n              varNode.addChildToBack(transform(initNode.getTarget()));\n              varNode.addChildToBack(transform(initNode.getInitializer()));\n            } else {\n              varNode.addChildToBack(\n                  processVariableInitializers(\n                      newNode(Token.NAME), initNode.getTarget()));\n            }\n        }\n\n        return varNode;\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) return false;\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n               n.getFirstChild().isString() &&\n               ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    private Node processStatementHelper(AstNode node) {\n        if (node instanceof Block) {\n            return processBlock((Block) node);\n        } else if (node instanceof ReturnStatement) {\n            return processReturnStatement((ReturnStatement) node);\n        } else if (node instanceof ExpressionStatement) {\n            return processExpressionStatement((ExpressionStatement) node);\n        } else if (node instanceof IfStatement) {\n            return processIfStatement((IfStatement) node);\n        } else if (node instanceof ForLoop) {\n            return processForLoop((ForLoop) node);\n        } else if (node instanceof ForInLoop) {\n            return processForInLoop((ForInLoop) node);\n        } else if (node instanceof DoLoop) {\n            return processDoLoop((DoLoop) node);\n        } else if (node instanceof WhileLoop) {\n            return processWhileLoop((WhileLoop) node);\n        } else if (node instanceof SwitchStatement) {\n            return processSwitchStatement((SwitchStatement) node);\n        } else if (node instanceof BreakStatement) {\n            return processBreakStatement((BreakStatement) node);\n        } else if (node instanceof ContinueStatement) {\n            return processContinueStatement((ContinueStatement) node);\n        } else if (node instanceof WithStatement) {\n            errorReporter.error(\n                \"With statements are not supported\",\n                sourceName,\n                node.getLineno(), \"\", 0);\n            return newNode(Token.BLOCK);\n        } else if (node instanceof TryStatement) {\n            return processTryStatement((TryStatement) node);\n        } else if (node instanceof ThrowStatement) {\n            return processThrowStatement((ThrowStatement) node);\n        } else if (node instanceof VariableDeclaration) {\n            return processVariableStatement((VariableDeclaration) node);\n        } else if (node instanceof LabeledStatement) {\n            return processLabeledStatement((LabeledStatement) node);\n        } else if (node instanceof FunctionNode) {\n            return processFunction((FunctionNode) node);\n        } else if (node instanceof ScriptNode) {\n            return transform(node);\n        }\n        errorReporter.error(\n            \"Unsupported or unrecognized statement type \" + node.getClass(),\n            sourceName,\n            node.getLineno(), \"\", 0);\n        return newNode(Token.EMPTY);\n    }\n\n    @Override\n    public Node process(Node jsRoot) {\n      checkNotNull(jsRoot);\n\n      // Set the current root script.\n      currentScriptOrFn =\n          new FunctionNode(\n              Node.newString(Token.NAME, \"\"),\n              new AstNode(0),\n              new Block(),\n              jsRoot.getLineno());\n\n      // Visit the root node.\n      Node rootNode = visit(jsRoot);\n\n      // Reset the current root script.\n      currentScriptOrFn = null;\n\n      return rootNode;\n    }\n\n    @Override\n    public Node processFunction(FunctionNode functionNode) {\n        // Create a new FUNCTION node.\n        Node functionRoot =\n                newNode(\n                    Token.FUNCTION,\n                    createName(functionNode.getName()),\n                    newNode(Token.PARAM_LIST),\n                    transformBlock(functionNode.getBody())\n                );\n        // Make the FUNCTION a named function.\n        if (functionNode.getName() != null) {\n            functionRoot.setIsArrowFunction(false);\n        }\n\n        // Handle the parameters. Add named parameters to the PARAM_LIST.\n        if (functionNode.getFunctionType().isParamList()) {\n            switch (functionNode.getFunctionType()) {\n                case FUNCTION:\n                case ARROW:\n                    for (AstNode param : functionNode.getParams()) {\n                        if (param instanceof RestElement) {\n                            functionRoot.addChildToBack(transform(param));\n                        } else {\n                            Node nameNode = createName(param.getStrin",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..6e185b76 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,378 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n-\n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+public class IRFactory extends AstNodeVisitor<Node> implements RawTransformer {\n+    // ...\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node transform(AstNode node) {\n+        checkState(currentScriptOrFn != null, \"No root script in IRFactory\");\n+\n+        // Map the AST to its IR representation and wrap in a SCRIPT node.\n+        return newNode(\n+            Token.SCRIPT,\n+            new Node(Token.FUNCTION, currentScriptOrFn, process(node)));\n+    }\n+\n+    // ...\n+\n+    private Node processStatement(AstNode statementNode) {\n+        switch (statementNode.getType()) {\n+            case Token.BLOCK:\n+                return processBlock((Block) statementNode);\n+            case Token.BREAK:\n+                return processBreakStatement((BreakStatement) statementNode);\n+            case Token.CATCH:\n+                return processCatchClause((CatchClause) statementNode);\n+            case Token.CONST:\n+            case Token.LET:\n+            case Token.VAR:\n+                return processVariableStatement((VariableDeclaration) statementNode);\n+            case Token.CONTINUE:\n+                return processContinueStatement((ContinueStatement) statementNode);\n+            case Token.DEBUGGER:\n+                return processDebuggerStatement((DebuggerStatement) statementNode);\n+            case Token.DO:\n+                return processDoLoop((DoLoop) statementNode);\n+            case Token.EMPTY:\n+                return processEmptyExpression((EmptyExpression) statementNode);\n+            case Token.EXPR_VOID:\n+                return processExpressionStatement((ExpressionStatement) statementNode);\n+            case Token.FOR:\n+                return processForLoop((ForLoop) statementNode);\n+            case Token.FOR_IN:\n+                return processForInLoop((ForInLoop) statementNode);\n+            case Token.FUNCTION:\n+                return processFunction((FunctionNode) statementNode);\n+            case Token.IF:\n+                return processIfStatement((IfStatement) statementNode);\n+            case Token.RETURN:\n+                return processReturnStatement((ReturnStatement) statementNode);\n+            case Token.SWITCH:\n+                return processSwitchStatement((SwitchStatement) statementNode);\n+            case Token.THROW:\n+                return processThrowStatement((ThrowStatement) statementNode);\n+            case Token.TRY:\n+                return processTryStatement((TryStatement) statementNode);\n+            case Token.WHILE:\n+                return processWhileLoop((WhileLoop) statementNode);\n+            case Token.WITH:\n+                errorReporter.error(\n+                    \"With statements are not supported\",\n+                    sourceName,\n+                    statementNode.getLineno(), \"\", 0);\n+                return newNode(Token.BLOCK);\n+            default:\n+                errorReporter.error(\n+                    \"Unsupported or unrecognized statement type \" + statementNode.getType(),\n+                    sourceName,\n+                    statementNode.getLineno(), \"\", 0);\n+                return newNode(Token.BLOCK);\n+        }\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    private Node processExpression(AstNode exprNode) {\n+      int type = exprNode.getType();\n+      switch (type) {\n+        case Token.FUNCTION:\n+          return processFunction((FunctionNode) exprNode);\n+        case Token.ARRAYLIT:\n+          return processArrayLiteral((ArrayLiteral) exprNode);\n+        case Token.OBJECTLIT:\n+          return processObjectLiteral((ObjectLiteral) exprNode, null);\n+        case Token.CALL:\n+          return processFunctionCall((FunctionCall) exprNode);\n+        case Token.NEW:\n+          return processNewExpr((NewExpression) exprNode);\n+        case Token.DOT:\n+          return processPropertyGet((PropertyGet) exprNode);\n+        case Token.NAME:\n+          return processName((Name) exprNode);\n+        case Token.GETPROP:\n+          return processElementGet((ElementGet) exprNode);\n+        case Token.THIS:\n+          return processThis((ThisLiteral) exprNode);\n+        case Token.ARRAYCOMP:\n+          return processArrayComp((ArrayComprehension) exprNode);\n+        case Token.COMPREHENSIONFOR:\n+          return processArrayCompFor((ArrayComprehensionLoop) exprNode);\n+        case Token.COMPREHENSIONIF:\n+          return processArrayCompIf((ArrayComprehensionIf) exprNode);\n+        case Token.FALSE:\n+        case Token.TRUE:\n+          return newNode(type);\n+        case Token.NULL:\n+          return newNode(Token.NULL);\n+        case Token.NUMBER:\n+        case Token.STRING:\n+          return newNode(type, exprNode.getString());\n+        case Token.REGEXP:\n+          return processRegExp((RegExpLiteral) exprNode);\n+        case Token.NOT:\n+        case Token.POS:\n+        case Token.NEG:\n+        case Token.BITNOT:\n+          return newNode(type, transform(exprNode.getFirstChild()));\n+        case Token.HOOK:\n+          return processConditionalExpression((ConditionalExpression) exprNode);\n+        case Token.OR:\n+        case Token.AND:\n+        case Token.BITOR:\n+        case Token.BITXOR:\n+        case Token.BITAND:\n+        case Token.SHEQ:\n+        case Token.SHNE:\n+        case Token.EQ:\n+        case Token.NE:\n+        case Token.LE:\n+        case Token.LT:\n+        case Token.GE:\n+        case Token.GT:\n+        case Token.INSTANCEOF:\n+        case Token.IN:\n+        case Token.LSH:\n+        case Token.RSH:\n+        case Token.URSH:\n+        case Token.ADD:\n+        case Token.SUB:\n+        case Token.MUL:\n+        case Token.DIV:\n+        case Token.MOD:\n+          return newNode(\n+              type,\n+              transform(exprNode.getFirstChild()),\n+              transform(exprNode.getLastChild()));\n+        case Token.TYPEOF:\n+        case Token.VOID:\n+        case Token.DELPROP:\n+          return newNode(type, transform(exprNode.getFirstChild()));\n+        case Token.INC:\n+        case Token.DEC:\n+          return newNode(type, processUnary((UnaryExpression) exprNode));\n+        case Token.ASSIGN:\n+          return processAssignment((Assignment) exprNode);\n+        case Token.ASSIGN_ADD:\n+        case Token.ASSIGN_SUB:\n+        case Token.ASSIGN_MUL:\n+        case Token.ASSIGN_DIV:\n+        case Token.ASSIGN_MOD:\n+        case Token.ASSIGN_BITOR:\n+        case Token.ASSIGN_BITXOR:\n+        case Token.ASSIGN_BITAND:\n+        case Token.ASSIGN_LSH:\n+        case Token.ASSIGN_RSH:\n+        case Token.ASSIGN_URSH:\n+          return processCompoundAssignment((Assignment) exprNode);\n+        case Token.DEFAULTNAMESPACE:\n+          return newNode(Token.DEFAULTNAMESPACE, transform(exprNode.getFirstChild()));\n+        case Token.XMLLIT:\n+          return processXmlLiteral((XmlLiteral) exprNode);\n+        case Token.YIELD:\n+          return processYield((Yield) exprNode);\n+        case Token.TEMPLATELIT:\n+          return processTemplateLiteral((TemplateLiteral) exprNode);\n+        case Token.TEMPLATELIT_SUB:\n+          return processTemplateLiteralSub((TemplateLiteral) exprNode);\n+        default:\n+          errorReporter.error(\n+              \"Unsupported or unrecognized expression type \" + type,\n+              sourceName,\n+              exprNode.getLineno(), \"\", 0);\n+          return newNode(Token.EMPTY);\n       }\n-      return node;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    private Node processUnary(UnaryExpression exprNode) {\n+        return newNode(exprNode.getType(), transform(exprNode.getOperand()).detachFromParent());\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    private Node processBinary(BinaryExpression exprNode) {\n+        Node lhs = transform(exprNode.getLeft());\n+        Node rhs = transform(exprNode.getRight());\n+        return newNode(exprNode.getType(), lhs.detachFromParent(), rhs.detachFromParent());\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private Node processVariableName(String name, boolean isDestructuring) {\n+        Node nameNode = createName(name);\n+        if (isDestructuring) {\n+            // We don't want the destructuring child to be confused with a NAME.\n+            // We use a NOOP to mark it as \"ok to rename\".\n+            nameNode.putProp(Node.IS_DUMMY_PLACEHOLDER, true);\n+            setRequiresQualifiedName(true);\n+            return newNode(Token.DESTRUCTURING_LHS, nameNode);\n+        } else {\n+            return nameNode;\n+        }\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    private Node processVariableInitializers(\n+        Node varNode, VariableDeclaration declarationNode) {\n+\n+        AstNode rhs = declarationNode.getInitializer();\n+\n+      // Check If this declaration node contains only one assignment with the right hand side\n+      // being a function. For example, 'let x = function() { ... }'.\n+      // If so, change the type of the parsed variable to 'GETFUN' and the type of\n+      // its initializer's first child to FUNCTION.\n+      if (rhs instanceof FunctionNode) {\n+        // This node is similar to a VAR initially assigned to a function expression.\n+        varNode.setType(Token.GETFUN);\n+        Node functionNode = transform((FunctionNode) rhs);\n+        if (functionNode.getFirstChild() != null\n+            && functionNode.getFirstChild().getType() == Token.NAME) {\n+          // See https://github.com/google/closure-compiler/issues/2107 for more details.\n+          functionNode.getLastChild().addChildToFront(\n+              newNode(Token.NAME, declarationNode.getString()));\n+        }\n+        functionNode.setType(Token.FUNCTION);\n+        // Propagate the function's name to the VAR.\n+        setJsDocInfoForVar(varNode, declarationNode);\n+        varNode.addChildToBack(functionNode);\n+        shorthandPropertyCheck(functionNode);\n+      } else {\n+        Node initializer = null;\n+        if (rhs != null) {\n+          initializer = transform(rhs);\n+        }\n+        varNode.addChildToBack(initializer == null ? new Node(Token.EMPTY) : initializer);\n+      }\n+\n+      // Propagate the source information to the VAR node.\n+      setJsDocInfoForVar(varNode, declarationNode);\n+\n+      return varNode;\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    private Node processVariableStatement(VariableDeclaration statementNode) {\n+        Node varNode;\n+        if (statementNode.isDestructuringDeclaration()) {\n+          // Initialize the VAR with an empty child if we are going to add\n+          // destructuring nodes later. This simplifies later checking of\n+          // the children.\n+          varNode = newNode(Token.VAR);\n+          varNode.addChildToBack(new Node(Token.EMPTY));\n+        } else {\n+          varNode = createName(statementNode.getType());\n+        }\n+\n+        // Convert each variable definition to a VAR statement.\n+        for (VariableInitializer initNode : statementNode.getVariables()) {\n+            if (initNode.isDestructuring()) {\n+              varNode.addChildToBack(transform(initNode.getTarget()));\n+              varNode.addChildToBack(transform(initNode.getInitializer()));\n+            } else {\n+              varNode.addChildToBack(\n+                  processVariableInitializers(\n+                      newNode(Token.NAME), initNode.getTarget()));\n+            }\n+        }\n+\n+        return varNode;\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    private boolean isDirective(Node n) {\n+        if (n == null) return false;\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+               n.getFirstChild().isString() &&\n+               ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    }\n+\n+    private Node processStatementHelper(AstNode node) {\n+        if (node instanceof Block) {\n+            return processBlock((Block) node);\n+        } else if (node instanceof ReturnStatement) {\n+            return processReturnStatement((ReturnStatement) node);\n+        } else if (node instanceof ExpressionStatement) {\n+            return processExpressionStatement((ExpressionStatement) node);\n+        } else if (node instanceof IfStatement) {\n+            return processIfStatement((IfStatement) node);\n+        } else if (node instanceof ForLoop) {\n+            return processForLoop((ForLoop) node);\n+        } else if (node instanceof ForInLoop) {\n+            return processForInLoop((ForInLoop) node);\n+        } else if (node instanceof DoLoop) {\n+            return processDoLoop((DoLoop) node);\n+        } else if (node instanceof WhileLoop) {\n+            return processWhileLoop((WhileLoop) node);\n+        } else if (node instanceof SwitchStatement) {\n+            return processSwitchStatement((SwitchStatement) node);\n+        } else if (node instanceof BreakStatement) {\n+            return processBreakStatement((BreakStatement) node);\n+        } else if (node instanceof ContinueStatement) {\n+            return processContinueStatement((ContinueStatement) node);\n+        } else if (node instanceof WithStatement) {\n+            errorReporter.error(\n+                \"With statements are not supported\",\n+                sourceName,\n+                node.getLineno(), \"\", 0);\n+            return newNode(Token.BLOCK);\n+        } else if (node instanceof TryStatement) {\n+            return processTryStatement((TryStatement) node);\n+        } else if (node instanceof ThrowStatement) {\n+            return processThrowStatement((ThrowStatement) node);\n+        } else if (node instanceof VariableDeclaration) {\n+            return processVariableStatement((VariableDeclaration) node);\n+        } else if (node instanceof LabeledStatement) {\n+            return processLabeledStatement((LabeledStatement) node);\n+        } else if (node instanceof FunctionNode) {\n+            return processFunction((FunctionNode) node);\n+        } else if (node instanceof ScriptNode) {\n+            return transform(node);\n+        }\n+        errorReporter.error(\n+            \"Unsupported or unrecognized statement type \" + node.getClass(),\n+            sourceName,\n+            node.getLineno(), \"\", 0);\n+        return newNode(Token.EMPTY);\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node process(Node jsRoot) {\n+      checkNotNull(jsRoot);\n+\n+      // Set the current root script.\n+      currentScriptOrFn =\n+          new FunctionNode(\n+              Node.newString(Token.NAME, \"\"),\n+              new AstNode(0),\n+              new Block(),\n+              jsRoot.getLineno());\n+\n+      // Visit the root node.\n+      Node rootNode = visit(jsRoot);\n+\n+      // Reset the current root script.\n+      currentScriptOrFn = null;\n+\n+      return rootNode;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node processFunction(FunctionNode functionNode) {\n+        // Create a new FUNCTION node.\n+        Node functionRoot =\n+                newNode(\n+                    Token.FUNCTION,\n+                    createName(functionNode.getName()),\n+                    newNode(Token.PARAM_LIST),\n+                    transformBlock(functionNode.getBody())\n+                );\n+        // Make the FUNCTION a named function.\n+        if (functionNode.getName() != null) {\n+            functionRoot.setIsArrowFunction(false);\n+        }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+        // Handle the parameters. Add named parameters to the PARAM_LIST.\n+        if (functionNode.getFunctionType().isParamList()) {\n+            switch (functionNode.getFunctionType()) {\n+                case FUNCTION:\n+                case ARROW:\n+                    for (AstNode param : functionNode.getParams()) {\n+                        if (param instanceof RestElement) {\n+                            functionRoot.addChildToBack(transform(param));\n+                        } else {\n+                            Node nameNode = createName(param.getStrin\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}