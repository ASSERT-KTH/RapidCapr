{
    "patch": "          if (parent.getParent().isDelProp()\n              && parent.getParent().getFirstChild() == parent) {\n            return false;\n          }\n\n          if (parent.isGetProp()) {\n            // NOTE(nicksantos): This pass's object-splitting algorithm has\n            // a blind spot. It assumes that if a property isn't defined on an\n            // object, then the value is undefined. This is not true, because\n            // Object.prototype can have arbitrary properties on it.\n            //\n            // We short-circuit this problem by bailing out if we see a reference\n            // to a property that isn't defined on the object literal. This\n            // isn't a perfect algorithm, but it should catch most cases.\n            String propertyName = parent.getLastChild().getString();\n            if (!validProperties.contains(propertyName)) {\n              Node grandparent = parent.getParent();\n              if (NodeUtil.isExprAssign(grandparent)) {\n                if (NodeUtil.isLhs(grandparent.getFirstChild(), parent)) {\n                  if (NodeUtil.isExprOptChain(grandparent.getFirstChild().getNext())) {\n                    Node optChained = grandparent.getFirstChild().getNext();\n                    if (NodeUtil.isGetProp(optChained)) {\n                      propertyName = optChained.getLastChild().getString();\n                      if (!validProperties.contains(propertyName)) {\n                        return false; // disallow adding new property via optional chain\n                      } \n                    }\n                  }\n                }\n              }\n\n              // The property doesn't yet exist on the object literal but might\n              // be defined on Object.prototype.\n              Node objNode = parent.getFirstChild();\n              boolean existOnObjectLiteral = false;\n              if (objNode.isName() && objNode.getString().equals(\"Object\")) {\n                if (propertyName.equals(\"prototype\")) {\n                  // Object.prototype exists on the global scope.\n                  existOnObjectLiteral = true; // treat it as if it was part of the object literal\n                }\n              } else {\n                if (objNode.isObjectLit()) {\n                  for (Node child = objNode.getFirstChild(); child != null;\n                      child = child.getNext()) {\n                    if (child.isStringKey() && child.getString().equals(propertyName)) {\n                      existOnObjectLiteral = true;\n                      break;\n                    }\n                  }\n                } else if (objNode.isCall()) {\n                  existOnObjectLiteral = true; // call returning an object is treated as object literal\n                }\n              }\n\n              if (existOnObjectLiteral) {\n                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                  validProperties.add(propertyName);\n                } else {\n                  return false;\n                }\n              } else {\n                return false;\n              }\n            }\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..819e8da0 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,71 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+          if (parent.getParent().isDelProp()\n+              && parent.getParent().getFirstChild() == parent) {\n+            return false;\n+          }\n+\n+          if (parent.isGetProp()) {\n+            // NOTE(nicksantos): This pass's object-splitting algorithm has\n+            // a blind spot. It assumes that if a property isn't defined on an\n+            // object, then the value is undefined. This is not true, because\n+            // Object.prototype can have arbitrary properties on it.\n+            //\n+            // We short-circuit this problem by bailing out if we see a reference\n+            // to a property that isn't defined on the object literal. This\n+            // isn't a perfect algorithm, but it should catch most cases.\n+            String propertyName = parent.getLastChild().getString();\n+            if (!validProperties.contains(propertyName)) {\n+              Node grandparent = parent.getParent();\n+              if (NodeUtil.isExprAssign(grandparent)) {\n+                if (NodeUtil.isLhs(grandparent.getFirstChild(), parent)) {\n+                  if (NodeUtil.isExprOptChain(grandparent.getFirstChild().getNext())) {\n+                    Node optChained = grandparent.getFirstChild().getNext();\n+                    if (NodeUtil.isGetProp(optChained)) {\n+                      propertyName = optChained.getLastChild().getString();\n+                      if (!validProperties.contains(propertyName)) {\n+                        return false; // disallow adding new property via optional chain\n+                      } \n+                    }\n+                  }\n+                }\n+              }\n+\n+              // The property doesn't yet exist on the object literal but might\n+              // be defined on Object.prototype.\n+              Node objNode = parent.getFirstChild();\n+              boolean existOnObjectLiteral = false;\n+              if (objNode.isName() && objNode.getString().equals(\"Object\")) {\n+                if (propertyName.equals(\"prototype\")) {\n+                  // Object.prototype exists on the global scope.\n+                  existOnObjectLiteral = true; // treat it as if it was part of the object literal\n+                }\n+              } else {\n+                if (objNode.isObjectLit()) {\n+                  for (Node child = objNode.getFirstChild(); child != null;\n+                      child = child.getNext()) {\n+                    if (child.isStringKey() && child.getString().equals(propertyName)) {\n+                      existOnObjectLiteral = true;\n+                      break;\n+                    }\n+                  }\n+                } else if (objNode.isCall()) {\n+                  existOnObjectLiteral = true; // call returning an object is treated as object literal\n+                }\n+              }\n+\n+              if (existOnObjectLiteral) {\n+                if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n+                  validProperties.add(propertyName);\n+                } else {\n+                  return false;\n+                }\n+              } else {\n+                return false;\n+              }\n+            }\n+          }\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}