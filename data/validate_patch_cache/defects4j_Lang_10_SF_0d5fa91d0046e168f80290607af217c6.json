{
    "patch": "import java.text.ParseException;\nimport java.text.ParsePosition;\nimport java.text.SimpleDateFormat;\nimport java.util.*;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class FastDateParser extends SimpleDateFormat {\n\n    private static final long serialVersionUID = 3L;\n\n    private final Locale mLocale;\n    private final int mMaxLengthEstimate;\n    private final Calendar mCalendar;\n    private final String mPattern;\n\n    private static final ConcurrentMap<Locale, Map<String, String>> cCache = new ConcurrentHashMap<>();\n\n    public FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n        super(pattern, locale);\n        mPattern = pattern;\n        mLocale = locale;\n\n        // following is workaround for bug in SimpleDateFormat\n        // (it honors DST for fixed dates)\n        Calendar calendar = Calendar.getInstance(timeZone, locale);\n        calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0);\n        calendar.set(Calendar.MILLISECOND, 0);\n        mMaxLengthEstimate = format(calendar.getTime()).length();\n        mCalendar = calendar;\n    }\n\n    @Override\n    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos) {\n        pos.endIndex = 0;\n        pos.beginIndex = 0;\n        return super.format(date, toAppendTo, pos);\n    }\n\n    @Override\n    public Date parse(String source) throws ParseException {\n        Exception saved = null;\n        ParsePosition pp = new ParsePosition(0);\n        final Date parse = super.parse(source, pp);\n        if (parse != null && pp.getErrorIndex() == -1) {\n            return parse;\n        }\n        int errors = Integer.MAX_VALUE;\n        for (String currentPattern : cCache.get(mLocale).values()) {\n            FastDateParser fdp = new FastDateParser(currentPattern, getTimeZone(), getLocale());\n            ParsePosition ppos = new ParsePosition(0);\n            fdp.setLenient(getLenient());\n            final Date parsedDate = fdp.parse(source, ppos);\n            if (parsedDate != null && ppos.getIndex() == source.length()) {\n                return parsedDate;\n            }\n            if (ppos.getErrorIndex() < errors) {\n                errors = ppos.getErrorIndex();\n                saved = new ParseException(\"Failed to parse date [\" + source + \"] with any of \" +\n                        cCache.get(mLocale).values(), errors);\n            }\n        }\n        if (saved instanceof RuntimeException) {\n            throw (RuntimeException) saved;\n        } else if (saved instanceof ParseException) {\n            throw (ParseException) saved;\n        } else {\n            throw new RuntimeException(\"Unexpected exception thrown\", saved);\n        }\n    }\n\n    public static String getPatternForStyle(Locale aLocale, int style) {\n        Map<String, String> patternsForLocale = cCache.get(aLocale);\n        if (patternsForLocale == null) {\n            patternsForLocale = new HashMap<>();\n            cCache.put(aLocale, patternsForLocale);\n        }\n        String[] dateTimePatterns = aLocale.getDateFormatSymbols().getDateTimePatterns(style);\n        String pattern = dateTimePatterns[0] + dateTimePatterns[1];\n        patternsForLocale.put(pattern, pattern);\n        return pattern;\n    }\n\n    private static StringBuilder escapeRegex(String value, boolean unquote) {\n        StringBuilder regex= new StringBuilder(value.length()*2);\n        boolean wasWhiteSpace = false;\n\n        for (int i= 0; i < value.length(); ++i) {\n            char c= value.charAt(i);\n\n            if (Character.isWhitespace(c)) {\n                if (!wasWhiteSpace) {\n                    wasWhiteSpace = true;\n                    regex.append(\"\\\\s*+\");\n                }\n                continue;\n            }\n            wasWhiteSpace = false;\n\n            switch (c) {\n                case '\\'':\n                    if (unquote) {\n                        if (++i == value.length()) {\n                            return regex;\n                        }\n                        c = value.charAt(i);\n                    }\n                    break;\n                case '?':\n                case '[':\n                case ']':\n                case '(':\n                case ')':\n                case '{':\n                case '}':\n                case '\\\\':\n                case '|':\n                case '*':\n                case '+':\n                case '^':\n                case '$':\n                case '.':\n                    regex.append('\\\\');\n                    break;\n            }\n            regex.append(c);\n        }\n        return regex;\n    }\n\n    private static List<String> parsePattern(String pattern) {\n        char[] array = pattern.toCharArray();\n        List<String> segments = new ArrayList<>(array.length);\n        StringBuilder builder = new StringBuilder();\n\n        for (int i = 0; i < array.length; i++) {\n            if (i > 0 && array[i - 1] != '\\''\n                    && ((array[i] >= 'a' && array[i] <= 'z') || (array[i] >= 'A' && array[i] <= 'Z'))) {\n                segments.add(builder.toString());\n                builder.setLength(0);\n            }\n\n            builder.append(array[i]);\n\n            if (i == array.length - 1) {\n                segments.add(builder.toString());\n            }\n        }\n\n        return segments;\n    }\n\n    public static void main(String[] args) {\n        String source = \"02-Mar-2022 02:01:18.256\";\n        FastDateParser fdp = new FastDateParser(getPatternForStyle(Locale.US, SimpleDateFormat.MEDIUM), TimeZone.getTimeZone(\"GMT\"), null);\n        Calendar date = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n        date.clear();\n        date.set(Calendar.YEAR, 2022);\n        date.set(Calendar.MONTH, Calendar.MARCH);\n        date.set(Calendar.DAY_OF_MONTH, 2);\n        date.set(Calendar.HOUR_OF_DAY, 2);\n        date.set(Calendar.MINUTE, 1);\n        date.set(Calendar.SECOND, 18);\n        date.set(Calendar.MILLISECOND, 256);\n        System.out.println(\"Expected date: \" + date.getTime());\n        try {\n            Date parsedDate = fdp.parse(source);\n            System.out.println(\"Parsed date: \" + parsedDate);\n        } catch (ParseException e) {\n            e.printStackTrace();\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159bd..2abf9e2e 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -300,48 +300,180 @@ public class FastDateParser implements DateParser, Serializable {\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n-    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n+import java.text.ParseException;\n+import java.text.ParsePosition;\n+import java.text.SimpleDateFormat;\n+import java.util.*;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+public class FastDateParser extends SimpleDateFormat {\n+\n+    private static final long serialVersionUID = 3L;\n+\n+    private final Locale mLocale;\n+    private final int mMaxLengthEstimate;\n+    private final Calendar mCalendar;\n+    private final String mPattern;\n+\n+    private static final ConcurrentMap<Locale, Map<String, String>> cCache = new ConcurrentHashMap<>();\n+\n+    public FastDateParser(String pattern, TimeZone timeZone, Locale locale) {\n+        super(pattern, locale);\n+        mPattern = pattern;\n+        mLocale = locale;\n+\n+        // following is workaround for bug in SimpleDateFormat\n+        // (it honors DST for fixed dates)\n+        Calendar calendar = Calendar.getInstance(timeZone, locale);\n+        calendar.set(2000, Calendar.JANUARY, 1, 0, 0, 0);\n+        calendar.set(Calendar.MILLISECOND, 0);\n+        mMaxLengthEstimate = format(calendar.getTime()).length();\n+        mCalendar = calendar;\n+    }\n+\n+    @Override\n+    public StringBuffer format(Date date, StringBuffer toAppendTo, FieldPosition pos) {\n+        pos.endIndex = 0;\n+        pos.beginIndex = 0;\n+        return super.format(date, toAppendTo, pos);\n+    }\n+\n+    @Override\n+    public Date parse(String source) throws ParseException {\n+        Exception saved = null;\n+        ParsePosition pp = new ParsePosition(0);\n+        final Date parse = super.parse(source, pp);\n+        if (parse != null && pp.getErrorIndex() == -1) {\n+            return parse;\n+        }\n+        int errors = Integer.MAX_VALUE;\n+        for (String currentPattern : cCache.get(mLocale).values()) {\n+            FastDateParser fdp = new FastDateParser(currentPattern, getTimeZone(), getLocale());\n+            ParsePosition ppos = new ParsePosition(0);\n+            fdp.setLenient(getLenient());\n+            final Date parsedDate = fdp.parse(source, ppos);\n+            if (parsedDate != null && ppos.getIndex() == source.length()) {\n+                return parsedDate;\n+            }\n+            if (ppos.getErrorIndex() < errors) {\n+                errors = ppos.getErrorIndex();\n+                saved = new ParseException(\"Failed to parse date [\" + source + \"] with any of \" +\n+                        cCache.get(mLocale).values(), errors);\n+            }\n+        }\n+        if (saved instanceof RuntimeException) {\n+            throw (RuntimeException) saved;\n+        } else if (saved instanceof ParseException) {\n+            throw (ParseException) saved;\n+        } else {\n+            throw new RuntimeException(\"Unexpected exception thrown\", saved);\n+        }\n+    }\n+\n+    public static String getPatternForStyle(Locale aLocale, int style) {\n+        Map<String, String> patternsForLocale = cCache.get(aLocale);\n+        if (patternsForLocale == null) {\n+            patternsForLocale = new HashMap<>();\n+            cCache.put(aLocale, patternsForLocale);\n+        }\n+        String[] dateTimePatterns = aLocale.getDateFormatSymbols().getDateTimePatterns(style);\n+        String pattern = dateTimePatterns[0] + dateTimePatterns[1];\n+        patternsForLocale.put(pattern, pattern);\n+        return pattern;\n+    }\n+\n+    private static StringBuilder escapeRegex(String value, boolean unquote) {\n+        StringBuilder regex= new StringBuilder(value.length()*2);\n+        boolean wasWhiteSpace = false;\n+\n+        for (int i= 0; i < value.length(); ++i) {\n             char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n+\n+            if (Character.isWhitespace(c)) {\n+                if (!wasWhiteSpace) {\n+                    wasWhiteSpace = true;\n                     regex.append(\"\\\\s*+\");\n                 }\n                 continue;\n             }\n-            wasWhite= false;\n-            switch(c) {\n-            case '\\'':\n-                if(unquote) {\n-                    if(++i==value.length()) {\n-                        return regex;\n+            wasWhiteSpace = false;\n+\n+            switch (c) {\n+                case '\\'':\n+                    if (unquote) {\n+                        if (++i == value.length()) {\n+                            return regex;\n+                        }\n+                        c = value.charAt(i);\n                     }\n-                    c= value.charAt(i);\n-                }\n-                break;\n-            case '?':\n-            case '[':\n-            case ']':\n-            case '(':\n-            case ')':\n-            case '{':\n-            case '}':\n-            case '\\\\':\n-            case '|':\n-            case '*':\n-            case '+':\n-            case '^':\n-            case '$':\n-            case '.':\n-                regex.append('\\\\');\n+                    break;\n+                case '?':\n+                case '[':\n+                case ']':\n+                case '(':\n+                case ')':\n+                case '{':\n+                case '}':\n+                case '\\\\':\n+                case '|':\n+                case '*':\n+                case '+':\n+                case '^':\n+                case '$':\n+                case '.':\n+                    regex.append('\\\\');\n+                    break;\n             }\n             regex.append(c);\n         }\n         return regex;\n     }\n \n+    private static List<String> parsePattern(String pattern) {\n+        char[] array = pattern.toCharArray();\n+        List<String> segments = new ArrayList<>(array.length);\n+        StringBuilder builder = new StringBuilder();\n+\n+        for (int i = 0; i < array.length; i++) {\n+            if (i > 0 && array[i - 1] != '\\''\n+                    && ((array[i] >= 'a' && array[i] <= 'z') || (array[i] >= 'A' && array[i] <= 'Z'))) {\n+                segments.add(builder.toString());\n+                builder.setLength(0);\n+            }\n+\n+            builder.append(array[i]);\n+\n+            if (i == array.length - 1) {\n+                segments.add(builder.toString());\n+            }\n+        }\n+\n+        return segments;\n+    }\n+\n+    public static void main(String[] args) {\n+        String source = \"02-Mar-2022 02:01:18.256\";\n+        FastDateParser fdp = new FastDateParser(getPatternForStyle(Locale.US, SimpleDateFormat.MEDIUM), TimeZone.getTimeZone(\"GMT\"), null);\n+        Calendar date = Calendar.getInstance(TimeZone.getTimeZone(\"GMT\"));\n+        date.clear();\n+        date.set(Calendar.YEAR, 2022);\n+        date.set(Calendar.MONTH, Calendar.MARCH);\n+        date.set(Calendar.DAY_OF_MONTH, 2);\n+        date.set(Calendar.HOUR_OF_DAY, 2);\n+        date.set(Calendar.MINUTE, 1);\n+        date.set(Calendar.SECOND, 18);\n+        date.set(Calendar.MILLISECOND, 256);\n+        System.out.println(\"Expected date: \" + date.getTime());\n+        try {\n+            Date parsedDate = fdp.parse(source);\n+            System.out.println(\"Parsed date: \" + parsedDate);\n+        } catch (ParseException e) {\n+            e.printStackTrace();\n+        }\n+    }\n+}\n+\n     /**\n      * A class to store Key / Value pairs\n      */",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}