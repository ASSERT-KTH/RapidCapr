{
    "patch": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n            throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifyInterval(min, max);\n        verifySequence(min, initial, max);\n\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n\n        if (yInitial * yMin < 0) {\n            return solve(f, min, initial, yMin, yInitial, min, yMin);\n        }\n\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, max, yInitial, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        return solve(f, min, yMin, max, yMax, initial, yInitial);\n    }\n    \n    private double solve(final UnivariateRealFunction f,\n                        double min, double yMin,\n                        double max, double yMax,\n                        double start, double yStart)\n            throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        double delta = yMax - yMin;\n        if (delta == 0) {\n            setResult((max + min) / 2, 0);\n            return result;\n        }\n\n        double r;\n        double s;\n        double q;\n        double p;\n\n        double a = (start - min) * yMax - (start - max) * yMin;\n        double b = 2 * delta;\n        if (a == 0) {\n            q = max - min;\n            p = 0;\n        } else {\n            q = -2 * a;\n            p = Math.sqrt(b * b - 4 * a * delta);\n        }\n\n        if (yStart < 0) {\n            r = (-b - p) / 2;\n            s = (-b + p) / 2;\n        } else {\n            r = (-b + p) / 2;\n            s = (-b - p) / 2;\n        }\n\n        double x = start;\n        double y = yStart;\n        double oldDelta = Math.abs(max - min);\n\n        double h = 0;\n        double w = 0;\n        for (int i = 0; i < maximalIterationCount; ++i) {\n            double d1 = x - ((x <= ((min + max) / 2)) ? min : max);\n            double d2 = ((x <= ((min + max) / 2)) ? max : min) - x;\n\n            // tolerance check on location of the root\n            if (Math.abs(2 * y * h) <= functionValueAccuracy &&\n                    oldDelta <= Math.abs(max - min) / 2) {\n                setResult(x, i);\n                return result;\n            }\n            oldDelta = Math.abs(max - min);\n\n            // choose the best approximation\n            if (Math.abs(r) < Math.abs(s)) {\n                h = r;\n                r = s;\n                s = h;\n            }\n\n            w = x + h;\n\n            if (w == x) {\n                // nothing happened on the last step - investigate brun \n                // only recalculate value for a zero step, up to round-off\n                y = f.value(x);\n                if (Math.abs(y) <= functionValueAccuracy) {\n                    setResult(x, i);\n                    return result;\n                }\n            } else {\n                y = f.value(w);\n\n                // test for convergence\n                if (Math.abs(y) <= functionValueAccuracy) {\n                    setResult(w, i);\n                    return result;\n                }\n\n                // test for termination\n                if (Math.abs(h) <= absoluteAccuracy || Math.abs(d1 + d2) <= absoluteAccuracy) {\n                    setResult(w, i);\n                    return result;\n                }\n            }\n\n            // adjust the bracketing interval\n            if (y * h > 0) {\n                if (x <= start) {\n                    min = x;\n                    yMin = y;\n                } else {\n                    max = x;\n                    yMax = y;\n                }\n                h = r;\n            } else {\n                if (x <= start) {\n                    max = start;\n                    yMax = yStart;\n                } else {\n                    min = start;\n                    yMin = yStart;\n                }\n                h = s;\n                s = r;\n                r = h;\n            }\n\n            x = w;\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..78f7961b5 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -97,50 +97,159 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      */\n     public double solve(final UnivariateRealFunction f,\n                         final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+            throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         clearResult();\n+        verifyInterval(min, max);\n         verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n         double yInitial = f.value(initial);\n         if (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+            return solve(f, min, initial, yMin, yInitial, min, yMin);\n         }\n \n-        // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+            return solve(f, initial, max, yInitial, yMax, initial, yInitial);\n         }\n \n         if (yMin * yMax > 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+                    NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n         }\n \n-        // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);\n+    }\n+    \n+    private double solve(final UnivariateRealFunction f,\n+                        double min, double yMin,\n+                        double max, double yMax,\n+                        double start, double yStart)\n+            throws MaxIterationsExceededException, FunctionEvaluationException {\n+\n+        double delta = yMax - yMin;\n+        if (delta == 0) {\n+            setResult((max + min) / 2, 0);\n+            return result;\n+        }\n+\n+        double r;\n+        double s;\n+        double q;\n+        double p;\n+\n+        double a = (start - min) * yMax - (start - max) * yMin;\n+        double b = 2 * delta;\n+        if (a == 0) {\n+            q = max - min;\n+            p = 0;\n+        } else {\n+            q = -2 * a;\n+            p = Math.sqrt(b * b - 4 * a * delta);\n+        }\n+\n+        if (yStart < 0) {\n+            r = (-b - p) / 2;\n+            s = (-b + p) / 2;\n+        } else {\n+            r = (-b + p) / 2;\n+            s = (-b - p) / 2;\n+        }\n+\n+        double x = start;\n+        double y = yStart;\n+        double oldDelta = Math.abs(max - min);\n+\n+        double h = 0;\n+        double w = 0;\n+        for (int i = 0; i < maximalIterationCount; ++i) {\n+            double d1 = x - ((x <= ((min + max) / 2)) ? min : max);\n+            double d2 = ((x <= ((min + max) / 2)) ? max : min) - x;\n+\n+            // tolerance check on location of the root\n+            if (Math.abs(2 * y * h) <= functionValueAccuracy &&\n+                    oldDelta <= Math.abs(max - min) / 2) {\n+                setResult(x, i);\n+                return result;\n+            }\n+            oldDelta = Math.abs(max - min);\n+\n+            // choose the best approximation\n+            if (Math.abs(r) < Math.abs(s)) {\n+                h = r;\n+                r = s;\n+                s = h;\n+            }\n+\n+            w = x + h;\n+\n+            if (w == x) {\n+                // nothing happened on the last step - investigate brun \n+                // only recalculate value for a zero step, up to round-off\n+                y = f.value(x);\n+                if (Math.abs(y) <= functionValueAccuracy) {\n+                    setResult(x, i);\n+                    return result;\n+                }\n+            } else {\n+                y = f.value(w);\n+\n+                // test for convergence\n+                if (Math.abs(y) <= functionValueAccuracy) {\n+                    setResult(w, i);\n+                    return result;\n+                }\n+\n+                // test for termination\n+                if (Math.abs(h) <= absoluteAccuracy || Math.abs(d1 + d2) <= absoluteAccuracy) {\n+                    setResult(w, i);\n+                    return result;\n+                }\n+            }\n \n+            // adjust the bracketing interval\n+            if (y * h > 0) {\n+                if (x <= start) {\n+                    min = x;\n+                    yMin = y;\n+                } else {\n+                    max = x;\n+                    yMax = y;\n+                }\n+                h = r;\n+            } else {\n+                if (x <= start) {\n+                    max = start;\n+                    yMax = yStart;\n+                } else {\n+                    min = start;\n+                    yMin = yStart;\n+                }\n+                h = s;\n+                s = r;\n+                r = h;\n+            }\n+\n+            x = w;\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n     /**",
    "result_reason": "error: method solve(UnivariateRealFunction,double,double,double,double,double,double) is already defined in class BrentSolver",
    "test_result": "ERROR"
}