{
    "patch": "case Token.NAME:\n  // This may be a variable get or set.\n  if (NodeUtil.isNameDeclaration(parent)) {\n    Node grandparent = parent.getParent();\n    if (grandparent != null && grandparent.isCatch()) {\n      return;\n    }\n    if (NodeUtil.isVarDeclaration(parent)) {\n      if (isGlobalScope(scope)) {\n        // Handle global var declarations.\n        for (Node child : parent.children()) {\n          if (child.isName()) {\n            handleSetFromGlobal(module, scope, child, parent, child.getString(), false, Name.Type.OTHER);\n          }\n        }\n      }\n    } else {\n      // Handle let/const declarations.\n      Node lvalue = parent.getFirstChild();\n      if (lvalue == n) {\n        if (isGlobalScope(scope)) {\n          handleSetFromGlobal(module, scope, n, parent, n.getString(), false, Name.Type.OTHER);\n        }\n      }\n    }\n  } else if (parent.isDestructuringLhs() && NodeUtil.isAssignmentOp(grandparent)) {\n    // Handle destructuring aliases as local sets.\n    NameExtractor.extractNames(n).forEach(name -> {\n      handleSetFromLocal(module, scope, n, grandparent, name);\n    });\n  } else if (parent.isFunction() || NodeUtil.isClass(parent)) {\n    // Handle named function expressions and classes.\n    if (NodeUtil.isNameDeclaration(n) && n.getString() != null) {\n      handleSetFromLocal(module, scope, n, parent, n.getString());\n    }\n    Node idNode = NodeUtil.getNameNode(parent);\n    if (idNode != null) {\n      handleSetFromLocal(module, scope, idNode, parent, idNode.getString());\n    }\n  } else if (parent.isParam()) {\n    // Handle function parameters.\n    handleSetFromLocal(module, scope, n, parent, n.getString());\n  } else {\n    // Handle all other get/set usages.\n    Node target = parent.getFirstChild();\n    if (NodeUtil.isPrototypeProperty(target) &&\n        target.getFirstChild() == n &&\n        !NodeUtil.isWithinStaticMemberFunction(target) &&\n        !scope.isDeclared(target.getQualifiedName(), false) &&\n        !module.isExported(target, null)) {\n      return;\n    }\n    String qName = n.getQualifiedName();\n    if (qName != null) {\n      if (isGlobalNameReference(qName, scope)) {\n        if (isGlobalScope(scope)) {\n          handleGet(module, scope, n, parent, qName);\n        } else {\n          handleSetFromGlobal(module, scope, n, parent, qName, false, Name.Type.OTHER);\n        }\n      } else {\n        handleGet(module, scope, n, parent, qName);\n      }\n    }\n  }\n  break;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 639318df..5b2d5c8a 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -302,7 +302,6 @@ class GlobalNamespace\n \n       return true;\n     }\n-\n     public void collect(JSModule module, Scope scope, Node n) {\n       Node parent = n.getParent();\n \n@@ -363,6 +362,72 @@ class GlobalNamespace\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n+case Token.NAME:\n+  // This may be a variable get or set.\n+  if (NodeUtil.isNameDeclaration(parent)) {\n+    Node grandparent = parent.getParent();\n+    if (grandparent != null && grandparent.isCatch()) {\n+      return;\n+    }\n+    if (NodeUtil.isVarDeclaration(parent)) {\n+      if (isGlobalScope(scope)) {\n+        // Handle global var declarations.\n+        for (Node child : parent.children()) {\n+          if (child.isName()) {\n+            handleSetFromGlobal(module, scope, child, parent, child.getString(), false, Name.Type.OTHER);\n+          }\n+        }\n+      }\n+    } else {\n+      // Handle let/const declarations.\n+      Node lvalue = parent.getFirstChild();\n+      if (lvalue == n) {\n+        if (isGlobalScope(scope)) {\n+          handleSetFromGlobal(module, scope, n, parent, n.getString(), false, Name.Type.OTHER);\n+        }\n+      }\n+    }\n+  } else if (parent.isDestructuringLhs() && NodeUtil.isAssignmentOp(grandparent)) {\n+    // Handle destructuring aliases as local sets.\n+    NameExtractor.extractNames(n).forEach(name -> {\n+      handleSetFromLocal(module, scope, n, grandparent, name);\n+    });\n+  } else if (parent.isFunction() || NodeUtil.isClass(parent)) {\n+    // Handle named function expressions and classes.\n+    if (NodeUtil.isNameDeclaration(n) && n.getString() != null) {\n+      handleSetFromLocal(module, scope, n, parent, n.getString());\n+    }\n+    Node idNode = NodeUtil.getNameNode(parent);\n+    if (idNode != null) {\n+      handleSetFromLocal(module, scope, idNode, parent, idNode.getString());\n+    }\n+  } else if (parent.isParam()) {\n+    // Handle function parameters.\n+    handleSetFromLocal(module, scope, n, parent, n.getString());\n+  } else {\n+    // Handle all other get/set usages.\n+    Node target = parent.getFirstChild();\n+    if (NodeUtil.isPrototypeProperty(target) &&\n+        target.getFirstChild() == n &&\n+        !NodeUtil.isWithinStaticMemberFunction(target) &&\n+        !scope.isDeclared(target.getQualifiedName(), false) &&\n+        !module.isExported(target, null)) {\n+      return;\n+    }\n+    String qName = n.getQualifiedName();\n+    if (qName != null) {\n+      if (isGlobalNameReference(qName, scope)) {\n+        if (isGlobalScope(scope)) {\n+          handleGet(module, scope, n, parent, qName);\n+        } else {\n+          handleSetFromGlobal(module, scope, n, parent, qName, false, Name.Type.OTHER);\n+        }\n+      } else {\n+        handleGet(module, scope, n, parent, qName);\n+      }\n+    }\n+  }\n+  break;\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}