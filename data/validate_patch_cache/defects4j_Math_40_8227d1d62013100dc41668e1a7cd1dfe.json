{
    "patch": "    protected double doSolve() {\n\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        List<Integer> signChangeIndices = new ArrayList<>();\n        if (y[0] * y[1] <= 0) {\n\n            // reduce interval if it brackets the root\n            nbPoints = 2;\n            signChangeIndices.add(1);\n\n        } else {\n\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] <= 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints = 3;\n                signChangeIndices.add(1);\n                signChangeIndices.add(2);\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // search loop\n        while (true) {\n\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                    getRelativeAccuracy() * FastMath.max(FastMath.abs(x[signChangeIndices.get(0) - 1]), FastMath.abs(x[signChangeIndices.get(signChangeIndices.size() - 1)]));\n            final double yTol = getFunctionValueAccuracy();\n            if (Precision.equals(y[signChangeIndices.get(0)], 0.0, 1)) {\n                // we found an exact root\n                return x[signChangeIndices.get(0)];\n            } else if (Precision.equals(y[signChangeIndices.get(signChangeIndices.size() - 1)], 0.0, 1)) {\n                // we found an exact root\n                return x[signChangeIndices.get(signChangeIndices.size() - 1)];\n            } else if ((x[signChangeIndices.get(signChangeIndices.size() - 1)] - x[signChangeIndices.get(0)]) <= xTol) {\n                // we have bracketed the root with reasonable tolerance\n                switch (allowed) {\n                    case ANY_SIDE :\n                        // return the one that is closest to zero\n                        int idx = -1;\n                        double dist = Double.POSITIVE_INFINITY;\n                        for (int i : signChangeIndices) {\n                            double d = FastMath.abs(y[i]);\n                            if (d < dist) {\n                                dist = d;\n                                idx = i;\n                            }\n                        }\n                        return x[idx];\n                    case LEFT_SIDE :\n                        return x[signChangeIndices.get(0)];\n                    case RIGHT_SIDE :\n                        return x[signChangeIndices.get(signChangeIndices.size() - 1)];\n                    case BELOW_SIDE :\n                        // return the one that is below zero, if any\n                        for (int i : signChangeIndices) {\n                            if (y[i] <= 0) {\n                                return x[i];\n                            }\n                        }\n                        return Double.NaN;\n                    case ABOVE_SIDE :\n                        // return the one that is above zero, if any\n                        for (int i : signChangeIndices) {\n                            if (y[i] >= 0) {\n                                return x[i];\n                            }\n                        }\n                        return Double.NaN;\n                    default :\n                        // this should never happen\n                        throw new MathInternalError(null);\n                }\n            }\n\n            // find all sign changes\n            List<Integer> newSignChangeIndices = new ArrayList<>(signChangeIndices.size());\n            for (int i = 0; i < signChangeIndices.size() - 1; ++i) {\n                int si = signChangeIndices.get(i);\n                int sj = signChangeIndices.get(i + 1);\n                if (y[si] * y[sj] <= 0) {\n                    newSignChangeIndices.add(si);\n                }\n            }\n            newSignChangeIndices.add(signChangeIndices.get(signChangeIndices.size() - 1));\n\n            // prepare interpolation interval for each sign change\n            List<int[]> intervals = new ArrayList<>(newSignChangeIndices.size() - 1);\n            for (int i = 0; i < newSignChangeIndices.size() - 1; ++i) {\n                int si = newSignChangeIndices.get(i);\n                int sj = newSignChangeIndices.get(i + 1);\n                intervals.add(new int[] { si, sj });\n            }\n\n            // loop over all intervals\n            double[] targets = new double[intervals.size()];\n            int aging = 0;\n            for (int i = 0; i < intervals.size(); ++i) {\n                int[] interval = intervals.get(i);\n                double xa = x[interval[0]];\n                double xb = x[interval[1]];\n                double ya = y[interval[0]];\n                double yb = y[interval[1]];\n                double absya = FastMath.abs(ya);\n                double absyb = FastMath.abs(yb);\n                double xTola = getAbsoluteAccuracy() +\n                        getRelativeAccuracy() * FastMath.max(FastMath.abs(xa), FastMath.abs(xb));\n                double fTola = yTol;\n                if (absya < absyb) {\n                    targets[i] = xa + 0.5 * (xb - xa);\n                    aging = FastMath.max(0, aging - 1);\n                } else {\n                    targets[i] = xb - 0.5 * (xb - xa);\n                    aging = FastMath.min(aging + 1, MAXIMAL_AGING);\n                }\n                if (((xb - xa) <= xTola) || (FastMath.max(absya, absyb) < fTola)) {\n                    if (absya < absyb) {\n                        return x[interval[0]];\n                    } else {\n                        return x[interval[1]];\n                    }\n                }\n            }\n\n            // sort the targets\n            Arrays.sort(targets);\n\n            // make a few attempts to guess a root,\n            double nextX;\n            int start = 0;\n            int end = nbPoints;\n            do {\n\n                // guess a value for current target, using inverse polynomial interpolation\n                System.arraycopy(x, start, tmpX, start, end - start);\n                nextX = guessX(targets, tmpX, y, start, end);\n\n                if (Double.isNaN(nextX) || !((nextX >= x[signChangeIndices.get(0) - 1]) && (nextX <= x[signChangeIndices.get(signChangeIndices.size() - 1)]))) {\n                    // the guessed root is not strictly inside any of the intervals\n\n                    // we try again with a lower interpolation order\n                    // start from the smallest interval that contains nextX\n                    boolean found = false;\n                    for (int[] interval : intervals) {\n                        if (nextX < x[interval[0]]) {\n                            break;\n                        }\n                        if ((nextX >= x[interval[0]]) && (nextX <= x[interval[1]])) {\n                            start = interval[0];\n                            end = interval[1];\n                            found = true;\n                            break;\n                        }\n                    }\n                    if (!found) {\n                        // error: should never happen\n                        throw new MathInternalError(null);\n                    }\n\n                    // we need to do one more attempt\n                    nextX = Double.NaN;\n\n                }\n\n            } while (Double.isNaN(nextX) && (end - start > 1));\n\n            if (Double.isNaN(nextX)) {\n                // fall back to bisection\n                int si = signChangeIndices.get(0);\n                int sj = signChangeIndices.get(signChangeIndices.size() - 1);\n                nextX = xa + 0.5 * (xb - xa);\n                start = si;\n                end = sj;\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(nextX);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return nextX;\n            }\n\n            if ((nbPoints > 2) && (end - start != nbPoints)) {\n\n                // we have been forced to ignore some points to keep bracketing,\n                // they are probably too far from the root, drop them from now on\n                nbPoints = end - start;\n                System.arraycopy(x, start, x, 0, nbPoints);\n                System.arraycopy(y, start, y, 0, nbPoints);\n                signChangeIndices.clear();\n                for (int i = 0; i < newSignChangeIndices.siz",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..b4ed23315 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -165,12 +165,12 @@ public class BracketingNthOrderBrentSolver\n         }\n \n         int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n+        List<Integer> signChangeIndices = new ArrayList<>();\n+        if (y[0] * y[1] <= 0) {\n \n             // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n+            nbPoints = 2;\n+            signChangeIndices.add(1);\n \n         } else {\n \n@@ -181,10 +181,11 @@ public class BracketingNthOrderBrentSolver\n                 return x[2];\n             }\n \n-            if (y[1] * y[2] < 0) {\n+            if (y[1] * y[2] <= 0) {\n                 // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n+                nbPoints = 3;\n+                signChangeIndices.add(1);\n+                signChangeIndices.add(2);\n             } else {\n                 throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n             }\n@@ -194,75 +195,142 @@ public class BracketingNthOrderBrentSolver\n         // prepare a work array for inverse polynomial interpolation\n         final double[] tmpX = new double[x.length];\n \n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n         // search loop\n         while (true) {\n \n             // check convergence of bracketing interval\n             final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n+                    getRelativeAccuracy() * FastMath.max(FastMath.abs(x[signChangeIndices.get(0) - 1]), FastMath.abs(x[signChangeIndices.get(signChangeIndices.size() - 1)]));\n+            final double yTol = getFunctionValueAccuracy();\n+            if (Precision.equals(y[signChangeIndices.get(0)], 0.0, 1)) {\n+                // we found an exact root\n+                return x[signChangeIndices.get(0)];\n+            } else if (Precision.equals(y[signChangeIndices.get(signChangeIndices.size() - 1)], 0.0, 1)) {\n+                // we found an exact root\n+                return x[signChangeIndices.get(signChangeIndices.size() - 1)];\n+            } else if ((x[signChangeIndices.get(signChangeIndices.size() - 1)] - x[signChangeIndices.get(0)]) <= xTol) {\n+                // we have bracketed the root with reasonable tolerance\n                 switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n+                    case ANY_SIDE :\n+                        // return the one that is closest to zero\n+                        int idx = -1;\n+                        double dist = Double.POSITIVE_INFINITY;\n+                        for (int i : signChangeIndices) {\n+                            double d = FastMath.abs(y[i]);\n+                            if (d < dist) {\n+                                dist = d;\n+                                idx = i;\n+                            }\n+                        }\n+                        return x[idx];\n+                    case LEFT_SIDE :\n+                        return x[signChangeIndices.get(0)];\n+                    case RIGHT_SIDE :\n+                        return x[signChangeIndices.get(signChangeIndices.size() - 1)];\n+                    case BELOW_SIDE :\n+                        // return the one that is below zero, if any\n+                        for (int i : signChangeIndices) {\n+                            if (y[i] <= 0) {\n+                                return x[i];\n+                            }\n+                        }\n+                        return Double.NaN;\n+                    case ABOVE_SIDE :\n+                        // return the one that is above zero, if any\n+                        for (int i : signChangeIndices) {\n+                            if (y[i] >= 0) {\n+                                return x[i];\n+                            }\n+                        }\n+                        return Double.NaN;\n+                    default :\n+                        // this should never happen\n+                        throw new MathInternalError(null);\n                 }\n             }\n \n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n-            } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n+            // find all sign changes\n+            List<Integer> newSignChangeIndices = new ArrayList<>(signChangeIndices.size());\n+            for (int i = 0; i < signChangeIndices.size() - 1; ++i) {\n+                int si = signChangeIndices.get(i);\n+                int sj = signChangeIndices.get(i + 1);\n+                if (y[si] * y[sj] <= 0) {\n+                    newSignChangeIndices.add(si);\n+                }\n+            }\n+            newSignChangeIndices.add(signChangeIndices.get(signChangeIndices.size() - 1));\n+\n+            // prepare interpolation interval for each sign change\n+            List<int[]> intervals = new ArrayList<>(newSignChangeIndices.size() - 1);\n+            for (int i = 0; i < newSignChangeIndices.size() - 1; ++i) {\n+                int si = newSignChangeIndices.get(i);\n+                int sj = newSignChangeIndices.get(i + 1);\n+                intervals.add(new int[] { si, sj });\n+            }\n+\n+            // loop over all intervals\n+            double[] targets = new double[intervals.size()];\n+            int aging = 0;\n+            for (int i = 0; i < intervals.size(); ++i) {\n+                int[] interval = intervals.get(i);\n+                double xa = x[interval[0]];\n+                double xb = x[interval[1]];\n+                double ya = y[interval[0]];\n+                double yb = y[interval[1]];\n+                double absya = FastMath.abs(ya);\n+                double absyb = FastMath.abs(yb);\n+                double xTola = getAbsoluteAccuracy() +\n+                        getRelativeAccuracy() * FastMath.max(FastMath.abs(xa), FastMath.abs(xb));\n+                double fTola = yTol;\n+                if (absya < absyb) {\n+                    targets[i] = xa + 0.5 * (xb - xa);\n+                    aging = FastMath.max(0, aging - 1);\n+                } else {\n+                    targets[i] = xb - 0.5 * (xb - xa);\n+                    aging = FastMath.min(aging + 1, MAXIMAL_AGING);\n+                }\n+                if (((xb - xa) <= xTola) || (FastMath.max(absya, absyb) < fTola)) {\n+                    if (absya < absyb) {\n+                        return x[interval[0]];\n+                    } else {\n+                        return x[interval[1]];\n+                    }\n+                }\n             }\n \n+            // sort the targets\n+            Arrays.sort(targets);\n+\n             // make a few attempts to guess a root,\n             double nextX;\n             int start = 0;\n-            int end   = nbPoints;\n+            int end = nbPoints;\n             do {\n \n                 // guess a value for current target, using inverse polynomial interpolation\n                 System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n+                nextX = guessX(targets, tmpX, y, start, end);\n \n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n+                if (Double.isNaN(nextX) || !((nextX >= x[signChangeIndices.get(0) - 1]) && (nextX <= x[signChangeIndices.get(signChangeIndices.size() - 1)]))) {\n+                    // the guessed root is not strictly inside any of the intervals\n \n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n                     // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n+                    // start from the smallest interval that contains nextX\n+                    boolean found = false;\n+                    for (int[] interval : intervals) {\n+                        if (nextX < x[interval[0]]) {\n+                            break;\n+                        }\n+                        if ((nextX >= x[interval[0]]) && (nextX <= x[interval[1]])) {\n+                            start = interval[0];\n+                            end = interval[1];\n+                            found = true;\n+                            break;\n+                        }\n+                    }\n+                    if (!found) {\n+                        // error: should never happen\n+                        throw new MathInternalError(null);\n                     }\n \n                     // we need to do one more attempt\n@@ -274,9 +342,11 @@ public class BracketingNthOrderBrentSolver\n \n             if (Double.isNaN(nextX)) {\n                 // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n+                int si = signChangeIndices.get(0);\n+                int sj = signChangeIndices.get(signChangeIndices.size() - 1);\n+                nextX = xa + 0.5 * (xb - xa);\n+                start = si;\n+                end = sj;\n             }\n \n             // evaluate the function at the guessed root\n@@ -294,55 +364,8 @@ public class BracketingNthOrderBrentSolver\n                 nbPoints = end - start;\n                 System.arraycopy(x, start, x, 0, nbPoints);\n                 System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n-\n-            }\n-\n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n-            } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n-            }\n-\n-        }\n-\n-    }\n+                signChangeIndices.clear();\n+                for (int i = 0; i < newSignChangeIndices.siz\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}