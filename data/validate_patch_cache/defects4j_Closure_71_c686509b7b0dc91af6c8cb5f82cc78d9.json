{
    "patch": "      StaticScope.Var var = t.getScope().getVar(propertyName);\n      boolean isOverride =\n          var != null && var.getParentNode().isName() &&\n          parent.getType() == Token.ASSIGN &&\n          parent.getFirstChild() == getprop;\n\n      // Find the lowest property defined on a class with visibility\n      // information.\n      if (isOverride) {\n        // Determine whether this is an override of a private variable.\n        // This is necessary to determine whether we need to enforce PRIVATE_OVERRIDE or\n        // VISIBILITY_MISMATCH.\n        for (ObjectType currentObjType : objectType.getTypeHierarchy()) {\n          JSDocInfo originalPropInfo =\n              currentObjType.getOwnPropertyJSDocInfo(propertyName);\n          if (originalPropInfo != null) {\n            boolean originalIsPrivate =\n                originalPropInfo.getVisibility() == Visibility.PRIVATE;\n            if (originalIsPrivate) {\n              compiler.report(\n                  t.makeError(getprop, PRIVATE_OVERRIDE, propertyName));\n            }\n            break;\n          }\n        }\n        objectType = objectType.getImplicitPrototype();\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckAccessControls.java b/src/com/google/javascript/jscomp/CheckAccessControls.java\nindex b23fd7af..e990957c 100644\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n@@ -413,7 +413,33 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+      StaticScope.Var var = t.getScope().getVar(propertyName);\n+      boolean isOverride =\n+          var != null && var.getParentNode().isName() &&\n+          parent.getType() == Token.ASSIGN &&\n+          parent.getFirstChild() == getprop;\n+\n+      // Find the lowest property defined on a class with visibility\n+      // information.\n+      if (isOverride) {\n+        // Determine whether this is an override of a private variable.\n+        // This is necessary to determine whether we need to enforce PRIVATE_OVERRIDE or\n+        // VISIBILITY_MISMATCH.\n+        for (ObjectType currentObjType : objectType.getTypeHierarchy()) {\n+          JSDocInfo originalPropInfo =\n+              currentObjType.getOwnPropertyJSDocInfo(propertyName);\n+          if (originalPropInfo != null) {\n+            boolean originalIsPrivate =\n+                originalPropInfo.getVisibility() == Visibility.PRIVATE;\n+            if (originalIsPrivate) {\n+              compiler.report(\n+                  t.makeError(getprop, PRIVATE_OVERRIDE, propertyName));\n+            }\n+            break;\n+          }\n+        }\n+        objectType = objectType.getImplicitPrototype();\n+      }\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n ",
    "result_reason": "error: not a statement",
    "test_result": "ERROR"
}