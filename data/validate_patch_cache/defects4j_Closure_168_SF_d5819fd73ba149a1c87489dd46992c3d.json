{
    "patch": "/**\n * Traverses a script node and records the first-order functions and other function-use information.\n */\nclass FirstOrderFunctionAnalyzer implements Callback {\n  private static final Pattern FUNCTION_PATTERN = Pattern.compile(\"^function\\\\s+[^\\\\(]*\\\\(([^\\\\)]*)\\\\)\");\n\n  final Map<Node, FunctionInfo> data;\n  final Compiler compiler;\n\n  public FirstOrderFunctionAnalyzer(Compiler compiler) {\n    data = new LinkedHashMap<>();\n    this.compiler = compiler;\n  }\n\n  /**\n   * Analyze a function.\n   * @param node A SCRIPT, FUNCTION, GETPROP, or CALL node.\n   */\n  private void analyzeFunction(Node node) {\n    Preconditions.checkState(node.isScript() || node.isFunction() || node.isGetProp() || node.isCall());\n\n    Scope functionScope = NodeUtil.getFunctionScopeRoot(compiler, node);\n\n    // Record function information.\n    FunctionInfo functionInfo = new FunctionInfo(node.getFirstChild(), functionScope);\n    data.put(node, functionInfo);\n  }\n\n  /**\n   * Gets the return type of a function in a string form.\n   * @param functionSource The source code of the function.\n   * @return The return type of the function, as a string, or \"undefined\" if the return type is not\n   *     specified.\n   */\n  private String getReturnType(String functionSource) {\n    String returnType = \"undefined\";\n    Matcher matcher = FUNCTION_PATTERN.matcher(functionSource);\n    if (matcher.find()) {\n      String functionSignature = matcher.group(1);\n      returnType = getReturnTypeFromFunctionSignature(functionSignature);\n    }\n    return returnType;\n  }\n\n  private String getReturnTypeFromFunctionSignature(String functionSignature) {\n    int splitIndex = functionSignature.lastIndexOf(':');\n    if (splitIndex == -1) {\n      return \"undefined\";\n    }\n    String returnType = functionSignature.substring(splitIndex + 1);\n    returnType = returnType.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n    return returnType;\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (n.isScript() || n.isFunction() || n.isGetProp() || n.isCall()) {\n      analyzeFunction(n);\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    // Do nothing.\n  }\n\n  /**\n   * Records whether a node has an exception handler branching out of it.\n   */\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n  \n  /**\n   * Analyzes all function calls.\n   */\n  void analyzeCalls() {\n    NodeTraversal.traverse(compiler, compiler.getRoot(),\n        new AbstractShallowCallback() {\n          @Override\n          public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isCall()) {\n              Node callee = n.getFirstChild();\n              String qualifiedName = ReferenceCollectingCallback.getBestQualifiedName(callee, parent);\n              if (qualifiedName != null) {\n                FunctionInfo info = getFunctionInfo(callee);\n                if (info != null) {\n                  info.recordCallSite(qualifiedName, parent);\n                }\n              }\n            }\n          }\n        });\n  }\n\n  /**\n   * Analyzes all the function's internals.\n   */\n  public void analyze() {\n    SortedSet<Node> sortedNodes = new TreeSet<>(data.keySet());\n    for (Node node : sortedNodes) {\n      FunctionInfo functionInfo = data.get(node);\n\n      // Record the function's return types and the vars/props that they are assigned to.\n      Set<Node> returnNodes = NodeUtil.findAllFunctionReturnNodes(node);\n      for (Node returnNode : returnNodes) {\n        Node valueNode = returnNode.getFirstChild();\n        if (!valueNode.isEmpty()) {\n          String returnValueType = NodeUtil.getBestJSType(valueNode);\n          functionInfo.recordReturnType(getReturnType(returnNode.getSourceFileName()), returnValueType);\n        }\n      }\n\n      // Handle function calls.\n      analyzeCalls();\n    }\n  }\n\n  /**\n   * Gets the function information for a function node or a GETPROP that refers to a function.\n   * @param node A FUNCTION or GETPROP that refers to a function.\n   * @return The function information, or null if the node is not a function or GETPROP.\n   */\n  private FunctionInfo getFunctionInfo(Node node) {\n    if (node.isFunction()) {\n      return data.get(node);\n    }\n\n    if (node.isGetProp() && node.getLastChild().getString().equals(\"call\")) {\n      Node grandparentNode = node.getParent().getParent();\n      if (grandparentNode.isCall()) {\n        Node functionNode = node.getFirstChild();\n        if (functionNode.isFunction()) {\n          return data.get(functionNode);\n        }\n      }\n    }\n\n    return null;\n  }\n\n  /**\n   * Gets the compiler's control flow graph.\n   */\n  private ControlFlowGraph<Node> getCfg() {\n    return compiler.getCfg();\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..0bbe337f 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1984,58 +1984,161 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n     }\n \n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (t.inGlobalScope()) {\n-        return;\n-      }\n+/**\n+ * Traverses a script node and records the first-order functions and other function-use information.\n+ */\n+class FirstOrderFunctionAnalyzer implements Callback {\n+  private static final Pattern FUNCTION_PATTERN = Pattern.compile(\"^function\\\\s+[^\\\\(]*\\\\(([^\\\\)]*)\\\\)\");\n \n-      if (n.isReturn() && n.getFirstChild() != null) {\n-        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n-      }\n+  final Map<Node, FunctionInfo> data;\n+  final Compiler compiler;\n \n-      if (t.getScopeDepth() <= 2) {\n-        // The first-order function analyzer looks at two types of variables:\n-        //\n-        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n-        //\n-        // 2) Local variables that are assigned more than once.\n-        //\n-        // We treat all global variables as escaped by default, so there's\n-        // no reason to do this extra computation for them.\n-        return;\n-      }\n+  public FirstOrderFunctionAnalyzer(Compiler compiler) {\n+    data = new LinkedHashMap<>();\n+    this.compiler = compiler;\n+  }\n \n-      if (n.isName() && NodeUtil.isLValue(n) &&\n-          // Be careful of bleeding functions, which create variables\n-          // in the inner scope, not the scope where the name appears.\n-          !NodeUtil.isBleedingFunctionName(n)) {\n-        String name = n.getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n-          }\n+  /**\n+   * Analyze a function.\n+   * @param node A SCRIPT, FUNCTION, GETPROP, or CALL node.\n+   */\n+  private void analyzeFunction(Node node) {\n+    Preconditions.checkState(node.isScript() || node.isFunction() || node.isGetProp() || node.isCall());\n+\n+    Scope functionScope = NodeUtil.getFunctionScopeRoot(compiler, node);\n+\n+    // Record function information.\n+    FunctionInfo functionInfo = new FunctionInfo(node.getFirstChild(), functionScope);\n+    data.put(node, functionInfo);\n+  }\n \n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n+  /**\n+   * Gets the return type of a function in a string form.\n+   * @param functionSource The source code of the function.\n+   * @return The return type of the function, as a string, or \"undefined\" if the return type is not\n+   *     specified.\n+   */\n+  private String getReturnType(String functionSource) {\n+    String returnType = \"undefined\";\n+    Matcher matcher = FUNCTION_PATTERN.matcher(functionSource);\n+    if (matcher.find()) {\n+      String functionSignature = matcher.group(1);\n+      returnType = getReturnTypeFromFunctionSignature(functionSignature);\n+    }\n+    return returnType;\n+  }\n+\n+  private String getReturnTypeFromFunctionSignature(String functionSignature) {\n+    int splitIndex = functionSignature.lastIndexOf(':');\n+    if (splitIndex == -1) {\n+      return \"undefined\";\n+    }\n+    String returnType = functionSignature.substring(splitIndex + 1);\n+    returnType = returnType.replaceAll(\"^\\\\s+|\\\\s+$\", \"\");\n+    return returnType;\n+  }\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+    if (n.isScript() || n.isFunction() || n.isGetProp() || n.isCall()) {\n+      analyzeFunction(n);\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    // Do nothing.\n+  }\n+\n+  /**\n+   * Records whether a node has an exception handler branching out of it.\n+   */\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+  \n+  /**\n+   * Analyzes all function calls.\n+   */\n+  void analyzeCalls() {\n+    NodeTraversal.traverse(compiler, compiler.getRoot(),\n+        new AbstractShallowCallback() {\n+          @Override\n+          public void visit(NodeTraversal t, Node n, Node parent) {\n+            if (n.isCall()) {\n+              Node callee = n.getFirstChild();\n+              String qualifiedName = ReferenceCollectingCallback.getBestQualifiedName(callee, parent);\n+              if (qualifiedName != null) {\n+                FunctionInfo info = getFunctionInfo(callee);\n+                if (info != null) {\n+                  info.recordCallSite(qualifiedName, parent);\n+                }\n+              }\n+            }\n           }\n+        });\n+  }\n+\n+  /**\n+   * Analyzes all the function's internals.\n+   */\n+  public void analyze() {\n+    SortedSet<Node> sortedNodes = new TreeSet<>(data.keySet());\n+    for (Node node : sortedNodes) {\n+      FunctionInfo functionInfo = data.get(node);\n+\n+      // Record the function's return types and the vars/props that they are assigned to.\n+      Set<Node> returnNodes = NodeUtil.findAllFunctionReturnNodes(node);\n+      for (Node returnNode : returnNodes) {\n+        Node valueNode = returnNode.getFirstChild();\n+        if (!valueNode.isEmpty()) {\n+          String returnValueType = NodeUtil.getBestJSType(valueNode);\n+          functionInfo.recordReturnType(getReturnType(returnNode.getSourceFileName()), returnValueType);\n         }\n-      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n-          NodeUtil.isLValue(n)) {\n-        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode())\n-                .recordEscapedQualifiedName(n.getQualifiedName());\n-          }\n+      }\n+\n+      // Handle function calls.\n+      analyzeCalls();\n+    }\n+  }\n+\n+  /**\n+   * Gets the function information for a function node or a GETPROP that refers to a function.\n+   * @param node A FUNCTION or GETPROP that refers to a function.\n+   * @return The function information, or null if the node is not a function or GETPROP.\n+   */\n+  private FunctionInfo getFunctionInfo(Node node) {\n+    if (node.isFunction()) {\n+      return data.get(node);\n+    }\n+\n+    if (node.isGetProp() && node.getLastChild().getString().equals(\"call\")) {\n+      Node grandparentNode = node.getParent().getParent();\n+      if (grandparentNode.isCall()) {\n+        Node functionNode = node.getFirstChild();\n+        if (functionNode.isFunction()) {\n+          return data.get(functionNode);\n         }\n       }\n     }\n+\n+    return null;\n+  }\n+\n+  /**\n+   * Gets the compiler's control flow graph.\n+   */\n+  private ControlFlowGraph<Node> getCfg() {\n+    return compiler.getCfg();\n+  }\n+}\n   }\n \n   private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}