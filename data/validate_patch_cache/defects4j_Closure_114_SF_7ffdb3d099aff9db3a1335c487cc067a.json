{
    "patch": "    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n      Node parent = n.getParent();\n      if (parent == null) {\n        return;\n      }\n\n      // Get the lhs of the assignment\n      Node lhs = n.getFirstChild();\n\n      if (!NodeUtil.isExpressionResultUsed(parent) || parent.isAssign()) {\n        // LHS needs to be recorded as a reference.\n        NameInformation lhsInfo = createNameInformation(t, lhs);\n        if (lhsInfo != null) recordDepScope(lhs, lhsInfo);\n      }\n\n      // Handle hoisted function expressions\n      if (NodeUtil.isFunctionDeclaration(lhs.getParent())) {\n        recordHoistedFunction(lhs.getParent());\n      }\n\n      // Special case: some expressions shouldn't be tracked as references.\n      Node value = n.getLastChild();\n      if (value != null && NodeUtil.mayHaveSideEffects(value)) {\n        return;\n      }\n\n      // Don't record references for the result of assignments within FOR loops\n      if (parent.isFor() && rhsVarBeforeStmt(parent, lhs)) {\n        return;\n      }\n\n      // Record the entire rhs as a reference, excluding child PROPERTY nodes.\n      Node rhsNode = n.getLastChild();\n      recordRhs(t, rhsNode, recordNode, /*excludeProp=*/ true);\n    }\n\n    private boolean rhsVarBeforeStmt(Node forNode, Node lhsNode) {\n      Node init = forNode.getFirstChild();\n      if (init.isVar()) {\n        Node forVars = init.getFirstChild();\n        while (forVars != null) {\n          Node name = forVars.getFirstChild();\n          if (name.matchesQualifiedName(lhsNode.getQualifiedName())) {\n            return true;\n          }\n          forVars = forVars.getNext();\n        }\n      } else if (init.isAssign()) {\n        Node name = init.getFirstChild();\n        if (name.matchesQualifiedName(lhsNode.getQualifiedName())) {\n          return true;\n        }\n      }\n      return false;\n    }\n\n    private void recordRhs(NodeTraversal t, Node n, Node recordNode, boolean excludeProp) {\n      String propName = null;\n      if (NodeUtil.isAssignmentOp(n) || n.isComma()) {\n        recordRhs(t, n.getFirstChild(), recordNode, excludeProp);\n        recordRhs(t, n.getLastChild(), recordNode, excludeProp);\n        return;\n      } else if (excludeProp && n.isGetProp()) {\n        propName = n.getLastChild().getString();\n      }\n      NameInformation info = createNameInformation(t, n);\n      if (info != null) {\n        recordDepScope(n, info, propName);\n      }\n    }    ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 0fc5ae8f..4dab14d9 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -554,39 +554,77 @@ final class NameAnalyzer implements CompilerPass {\n           break;\n       }\n     }\n-\n     private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n-      Node nameNode = n.getFirstChild();\n       Node parent = n.getParent();\n-      NameInformation ns = createNameInformation(t, nameNode);\n-      if (ns != null) {\n-        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n-          // Patch for assignments that appear in the init,\n-          // condition or iteration part of a FOR loop.  Without\n-          // this change, all 3 of those parts try to claim the for\n-          // loop as their dependency scope.  The last assignment in\n-          // those three fields wins, which can result in incorrect\n-          // reference edges between referenced and assigned variables.\n-          //\n-          // TODO(user) revisit the dependency scope calculation\n-          // logic.\n-          if (parent.getFirstChild().getNext() != n) {\n-            recordDepScope(recordNode, ns);\n-          } else {\n-            recordDepScope(nameNode, ns);\n+      if (parent == null) {\n+        return;\n+      }\n+\n+      // Get the lhs of the assignment\n+      Node lhs = n.getFirstChild();\n+\n+      if (!NodeUtil.isExpressionResultUsed(parent) || parent.isAssign()) {\n+        // LHS needs to be recorded as a reference.\n+        NameInformation lhsInfo = createNameInformation(t, lhs);\n+        if (lhsInfo != null) recordDepScope(lhs, lhsInfo);\n+      }\n+\n+      // Handle hoisted function expressions\n+      if (NodeUtil.isFunctionDeclaration(lhs.getParent())) {\n+        recordHoistedFunction(lhs.getParent());\n+      }\n+\n+      // Special case: some expressions shouldn't be tracked as references.\n+      Node value = n.getLastChild();\n+      if (value != null && NodeUtil.mayHaveSideEffects(value)) {\n+        return;\n+      }\n+\n+      // Don't record references for the result of assignments within FOR loops\n+      if (parent.isFor() && rhsVarBeforeStmt(parent, lhs)) {\n+        return;\n+      }\n+\n+      // Record the entire rhs as a reference, excluding child PROPERTY nodes.\n+      Node rhsNode = n.getLastChild();\n+      recordRhs(t, rhsNode, recordNode, /*excludeProp=*/ true);\n+    }\n+\n+    private boolean rhsVarBeforeStmt(Node forNode, Node lhsNode) {\n+      Node init = forNode.getFirstChild();\n+      if (init.isVar()) {\n+        Node forVars = init.getFirstChild();\n+        while (forVars != null) {\n+          Node name = forVars.getFirstChild();\n+          if (name.matchesQualifiedName(lhsNode.getQualifiedName())) {\n+            return true;\n           }\n-        } else {\n-          // The rhs of the assignment is the caller, so it's used by the\n-          // context. Don't associate it w/ the lhs.\n-          // FYI: this fixes only the specific case where the assignment is the\n-          // caller expression, but it could be nested deeper in the caller and\n-          // we would still get a bug.\n-          // See testAssignWithCall2 for an example of this.\n-          recordDepScope(recordNode, ns);\n+          forVars = forVars.getNext();\n+        }\n+      } else if (init.isAssign()) {\n+        Node name = init.getFirstChild();\n+        if (name.matchesQualifiedName(lhsNode.getQualifiedName())) {\n+          return true;\n         }\n       }\n+      return false;\n     }\n \n+    private void recordRhs(NodeTraversal t, Node n, Node recordNode, boolean excludeProp) {\n+      String propName = null;\n+      if (NodeUtil.isAssignmentOp(n) || n.isComma()) {\n+        recordRhs(t, n.getFirstChild(), recordNode, excludeProp);\n+        recordRhs(t, n.getLastChild(), recordNode, excludeProp);\n+        return;\n+      } else if (excludeProp && n.isGetProp()) {\n+        propName = n.getLastChild().getString();\n+      }\n+      NameInformation info = createNameInformation(t, n);\n+      if (info != null) {\n+        recordDepScope(n, info, propName);\n+      }\n+    }    \n+\n     /**\n      * Defines a dependency scope.\n      */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}