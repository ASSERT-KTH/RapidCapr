{
    "patch": "                      // firstChild() calls getLhs() via checkNotNull.\n                      // Delaying isSideEffectFree prevents egregious performance regression.\n                      // Note that isSideEffectFree is not a guarantee of having no side\n                      // effects, but rather a conservative estimate needed because we're not\n                      // conducting the analysis over the entire AST.\n                      // \n                      // Example:\n                      //   var x;\n                      //   if (a_b()) {\n                      //     x = c();\n                      //   } else {\n                      //     x = d();\n                      //   }\n                      //   f(x);\n                      // is safe (even though x may receive a value with side effects) when\n                      // a_b, c, and d are known to be side-cffect-free, because the value of\n                      // x is not observed before escaped from the if statement; but it's not\n                      // safe in general.\n                      if (NodeUtil.isExpressionResult(lhsParent) || lhsParent.isForIn() ||\n                          lhsParent.isForOf() || lhsParent.isVanillaFor() ||\n                          NodeUtil.isNonArrowFunction(lhsParent) ||\n                          !lhs.isSideEffectFree() ||\n                          !mayEffectMutableState(lhs)) {\n                        return false;\n                      }\n                      lhs = lhs.getParent();\n                    }\n                    return true;\n                  }\n                  return false;\n                }\n                continue;\n              }\n              case Token.CALL: {\n                Node callee = cur.getFirstChild();\n                if (callee.isFunction()) {\n                  if (!isValidFunction(callee)) {\n                    return false;\n                  }\n                } else if (mayEffectArguments(callee)) {\n                  return false;\n                }\n\n                // Ignore aliases.\n                Node originalCallee = functionAliasMap.get(callee);\n                if (originalCallee != null) {\n                  callee = originalCallee;\n                }\n\n                Node lastArg = cur.getLastChild();\n                while (lastArg != null && lastArg.isSpread()) {\n                  lastArg = lastArg.getPrevious();\n                }\n\n                // Special method calls can have non-standard references.\n                if (lastArg != null && mayEffectMutableState(lastArg)) {\n                  return false;\n                }\n\n                // We don't need to check anything else for the call expression.\n                lhs = lhs.getParent();\n                continue;\n              }\n              case Token.NEW: {\n                Node callee = cur.getFirstChild();\n                if (callee.isFunction()) {\n                  if (!isValidFunction(callee)) {\n                    return false;\n                  }\n                } else if (mayEffectArguments(callee)) {\n                  return false;\n                }\n                lhs = lhs.getParent();\n                continue;\n              }\n            }\n          } else if (cur != usedValue) {\n            // The traversal has gone up past usedValue.\n            lhs = lhs.getParent();\n            while (lhs != null && !lhs.isExprStmt()) {\n              // If any part of the LHS is not side-effect-free,\n              // consider the entire assignment side-effecting.\n              if (!lhs.getFirstChild().isSideEffectFree()) {\n                return false;\n              }\n              lhs = lhs.getParent();\n            }\n            return true;\n          } else {\n            // cur is usedValue.\n            usedValue = null;\n          }\n        }\n      }\n      lhs = lhs.getParent();\n    }\n    return false;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..a37b9e27 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,104 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+                      // firstChild() calls getLhs() via checkNotNull.\n+                      // Delaying isSideEffectFree prevents egregious performance regression.\n+                      // Note that isSideEffectFree is not a guarantee of having no side\n+                      // effects, but rather a conservative estimate needed because we're not\n+                      // conducting the analysis over the entire AST.\n+                      // \n+                      // Example:\n+                      //   var x;\n+                      //   if (a_b()) {\n+                      //     x = c();\n+                      //   } else {\n+                      //     x = d();\n+                      //   }\n+                      //   f(x);\n+                      // is safe (even though x may receive a value with side effects) when\n+                      // a_b, c, and d are known to be side-cffect-free, because the value of\n+                      // x is not observed before escaped from the if statement; but it's not\n+                      // safe in general.\n+                      if (NodeUtil.isExpressionResult(lhsParent) || lhsParent.isForIn() ||\n+                          lhsParent.isForOf() || lhsParent.isVanillaFor() ||\n+                          NodeUtil.isNonArrowFunction(lhsParent) ||\n+                          !lhs.isSideEffectFree() ||\n+                          !mayEffectMutableState(lhs)) {\n+                        return false;\n+                      }\n+                      lhs = lhs.getParent();\n+                    }\n+                    return true;\n+                  }\n+                  return false;\n+                }\n+                continue;\n+              }\n+              case Token.CALL: {\n+                Node callee = cur.getFirstChild();\n+                if (callee.isFunction()) {\n+                  if (!isValidFunction(callee)) {\n+                    return false;\n+                  }\n+                } else if (mayEffectArguments(callee)) {\n+                  return false;\n+                }\n+\n+                // Ignore aliases.\n+                Node originalCallee = functionAliasMap.get(callee);\n+                if (originalCallee != null) {\n+                  callee = originalCallee;\n+                }\n+\n+                Node lastArg = cur.getLastChild();\n+                while (lastArg != null && lastArg.isSpread()) {\n+                  lastArg = lastArg.getPrevious();\n+                }\n+\n+                // Special method calls can have non-standard references.\n+                if (lastArg != null && mayEffectMutableState(lastArg)) {\n+                  return false;\n+                }\n+\n+                // We don't need to check anything else for the call expression.\n+                lhs = lhs.getParent();\n+                continue;\n+              }\n+              case Token.NEW: {\n+                Node callee = cur.getFirstChild();\n+                if (callee.isFunction()) {\n+                  if (!isValidFunction(callee)) {\n+                    return false;\n+                  }\n+                } else if (mayEffectArguments(callee)) {\n+                  return false;\n+                }\n+                lhs = lhs.getParent();\n+                continue;\n+              }\n+            }\n+          } else if (cur != usedValue) {\n+            // The traversal has gone up past usedValue.\n+            lhs = lhs.getParent();\n+            while (lhs != null && !lhs.isExprStmt()) {\n+              // If any part of the LHS is not side-effect-free,\n+              // consider the entire assignment side-effecting.\n+              if (!lhs.getFirstChild().isSideEffectFree()) {\n+                return false;\n+              }\n+              lhs = lhs.getParent();\n+            }\n+            return true;\n+          } else {\n+            // cur is usedValue.\n+            usedValue = null;\n+          }\n+        }\n+      }\n+      lhs = lhs.getParent();\n+    }\n+    return false;\n+  }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}