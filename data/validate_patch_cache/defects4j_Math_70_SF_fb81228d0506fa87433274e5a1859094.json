{
    "patch": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    verifyBracketing(min, max, f);\n\n    double x1 = min;\n    double y1 = f.value(x1);\n    double x2 = max;\n    double y2 = f.value(x2);\n\n    if (y1 == 0.0) {\n        return x1;\n    }\n    if (y2 == 0.0) {\n        return x2;\n    }\n\n    if (y1 * y2 > 0.0) {\n        throw new NoBracketingException(x1, x2, y1, y2);\n    }\n\n    // Get accuracies.\n    final double functionValueAccuracy = getFunctionValueAccuracy();\n    final double absoluteAccuracy = getAbsoluteAccuracy();\n    final double relativeAccuracy = getRelativeAccuracy();\n\n    double x0 = initial;\n    double y0 = f.value(x0);\n    double oldDelta = Double.POSITIVE_INFINITY;\n\n    while (true) {\n        // Compute the denominator.\n        final double denominator = (y2 - y1) / (x2 - x1) - (y0 - y1) / (x0 - x1);\n\n        // If the denominator is zero, the tangent line is parallel to x-axis and cannot proceed further.\n        if (denominator == 0) {\n            throw new RuntimeException(\"A tangent line is parallel to x-axis and cannot proceed further.\");\n        }\n\n        // Compute the numerator.\n        final double numerator = FastMath.sqrt(FastMath.max(0.0, y0 * y0\n                + 2.0 * ((y1 - y0) / (x1 - x0) - denominator) * y0 * FastMath.pow(x1 - x0, 2)\n                + (y1 - y0) * (y1 - y0) * FastMath.pow(x1 - x0, 4) / 4.0 / FastMath.pow(x0 - x1, 2)));\n\n        double x = Double.NaN;\n        if (denominator < 0.0) {\n            x = x0 - (x0 - x1) * (y0 + numerator / FastMath.abs(denominator));\n        } else {\n            x = x0 - (x0 - x1) * (y0 - numerator / FastMath.abs(denominator));\n        }\n\n        // Check for convergence.\n        final double y = f.value(x);\n        final double relativeError = FastMath.abs((x - oldDelta) / x);\n        if ((y == 0.0) || (relativeError < relativeAccuracy) || (FastMath.abs(x - oldDelta) < absoluteAccuracy)) {\n            return x;\n        }\n\n        // Update bisection interval.\n        final double previousDelta = oldDelta;\n        oldDelta = x;\n        if (FastMath.signum(y) == FastMath.signum(y0)) {\n            x0 = x;\n            y0 = y;\n            x1 = x1;\n            y1 = y1;\n            x2 = x2;\n            y2 = y2;\n        } else {\n            x0 = x0;\n            y0 = y0;\n            x1 = x1;\n            y1 = y1;\n            x2 = x;\n            y2 = y;\n        }\n\n        // If updated interval is not bracketing anymore throw an exception.\n        if (FastMath.signum(y) == FastMath.signum(y1)) {\n            if (FastMath.abs(y2) >= FastMath.abs(y1)) {\n                throw new NoBracketingException(x1, x2, y1, y2);\n            }\n            x1 = x2;\n            y1 = y2;\n            x2 = oldDelta;\n            y2 = f.value(x2);\n        }\n        else if (FastMath.signum(y) == FastMath.signum(y2)) {\n            if (FastMath.abs(y1) >= FastMath.abs(y2)) {\n                throw new NoBracketingException(x1, x2, y1, y2);\n            }\n            x2 = oldDelta;\n            y2 = f.value(x2);\n        }\n\n        // Check for convergence again.\n        if (FastMath.abs(previousDelta - oldDelta) <= absoluteAccuracy) {\n            if (FastMath.signum(y0) == FastMath.signum(y)) {\n                x = x0;\n            }\n            else if (FastMath.signum(y1) == FastMath.signum(y)) {\n                x = x1;\n            }\n            else {\n                x = x2;\n            }\n            return x;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..decca1c05 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -67,10 +67,116 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+\n+    verifyBracketing(min, max, f);\n+\n+    double x1 = min;\n+    double y1 = f.value(x1);\n+    double x2 = max;\n+    double y2 = f.value(x2);\n+\n+    if (y1 == 0.0) {\n+        return x1;\n+    }\n+    if (y2 == 0.0) {\n+        return x2;\n+    }\n+\n+    if (y1 * y2 > 0.0) {\n+        throw new NoBracketingException(x1, x2, y1, y2);\n+    }\n+\n+    // Get accuracies.\n+    final double functionValueAccuracy = getFunctionValueAccuracy();\n+    final double absoluteAccuracy = getAbsoluteAccuracy();\n+    final double relativeAccuracy = getRelativeAccuracy();\n+\n+    double x0 = initial;\n+    double y0 = f.value(x0);\n+    double oldDelta = Double.POSITIVE_INFINITY;\n+\n+    while (true) {\n+        // Compute the denominator.\n+        final double denominator = (y2 - y1) / (x2 - x1) - (y0 - y1) / (x0 - x1);\n+\n+        // If the denominator is zero, the tangent line is parallel to x-axis and cannot proceed further.\n+        if (denominator == 0) {\n+            throw new RuntimeException(\"A tangent line is parallel to x-axis and cannot proceed further.\");\n+        }\n+\n+        // Compute the numerator.\n+        final double numerator = FastMath.sqrt(FastMath.max(0.0, y0 * y0\n+                + 2.0 * ((y1 - y0) / (x1 - x0) - denominator) * y0 * FastMath.pow(x1 - x0, 2)\n+                + (y1 - y0) * (y1 - y0) * FastMath.pow(x1 - x0, 4) / 4.0 / FastMath.pow(x0 - x1, 2)));\n+\n+        double x = Double.NaN;\n+        if (denominator < 0.0) {\n+            x = x0 - (x0 - x1) * (y0 + numerator / FastMath.abs(denominator));\n+        } else {\n+            x = x0 - (x0 - x1) * (y0 - numerator / FastMath.abs(denominator));\n+        }\n+\n+        // Check for convergence.\n+        final double y = f.value(x);\n+        final double relativeError = FastMath.abs((x - oldDelta) / x);\n+        if ((y == 0.0) || (relativeError < relativeAccuracy) || (FastMath.abs(x - oldDelta) < absoluteAccuracy)) {\n+            return x;\n+        }\n+\n+        // Update bisection interval.\n+        final double previousDelta = oldDelta;\n+        oldDelta = x;\n+        if (FastMath.signum(y) == FastMath.signum(y0)) {\n+            x0 = x;\n+            y0 = y;\n+            x1 = x1;\n+            y1 = y1;\n+            x2 = x2;\n+            y2 = y2;\n+        } else {\n+            x0 = x0;\n+            y0 = y0;\n+            x1 = x1;\n+            y1 = y1;\n+            x2 = x;\n+            y2 = y;\n+        }\n+\n+        // If updated interval is not bracketing anymore throw an exception.\n+        if (FastMath.signum(y) == FastMath.signum(y1)) {\n+            if (FastMath.abs(y2) >= FastMath.abs(y1)) {\n+                throw new NoBracketingException(x1, x2, y1, y2);\n+            }\n+            x1 = x2;\n+            y1 = y2;\n+            x2 = oldDelta;\n+            y2 = f.value(x2);\n+        }\n+        else if (FastMath.signum(y) == FastMath.signum(y2)) {\n+            if (FastMath.abs(y1) >= FastMath.abs(y2)) {\n+                throw new NoBracketingException(x1, x2, y1, y2);\n+            }\n+            x2 = oldDelta;\n+            y2 = f.value(x2);\n+        }\n+\n+        // Check for convergence again.\n+        if (FastMath.abs(previousDelta - oldDelta) <= absoluteAccuracy) {\n+            if (FastMath.signum(y0) == FastMath.signum(y)) {\n+                x = x0;\n+            }\n+            else if (FastMath.signum(y1) == FastMath.signum(y)) {\n+                x = x1;\n+            }\n+            else {\n+                x = x2;\n+            }\n+            return x;\n+        }\n     }\n+}\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max)",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}