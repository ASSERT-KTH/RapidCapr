{
    "patch": "    protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n\n        // initialize search interval and other variables\n        double a = getMin();\n        double b = getMax();\n        double c = a + GOLDEN_SECTION * (b - a);\n        double d = b - GOLDEN_SECTION * (b - a);\n        double fc = computeObjectiveValue(c);\n        if (!isMinim) {\n            fc = -fc;\n        }\n        double fd = computeObjectiveValue(d);\n        if (!isMinim) {\n            fd = -fd;\n        }\n\n        while (true) {\n            if (fc < fd) {\n                b = d;\n                d = c;\n                fd = fc;\n                c = a + GOLDEN_SECTION * (b - a);\n                fc = computeObjectiveValue(c);\n                if (!isMinim) {\n                    fc = -fc;\n                }\n            } else {\n                a = c;\n                c = d;\n                fc = fd;\n                d = b - GOLDEN_SECTION * (b - a);\n                fd = computeObjectiveValue(d);\n                if (!isMinim) {\n                    fd = -fd;\n                }\n            }\n\n            double tol = Math.max(relativeThreshold * Math.max(Math.abs(d), Math.abs(c)),\n                                   absoluteThreshold);\n            if (Math.abs(d - c) < tol) {\n                double x = 0.5 * (c + d);\n                double fx = computeObjectiveValue(x);\n                if (!isMinim) {\n                    fx = -fx;\n                }\n                UnivariatePointValuePair solution = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n                return solution;\n            }\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex b6ce68ef3..c7c9d17a7 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -108,165 +108,53 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n     @Override\n     protected UnivariatePointValuePair doOptimize() {\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n-        final double lo = getMin();\n-        final double mid = getStartValue();\n-        final double hi = getMax();\n \n-        // Optional additional convergence criteria.\n-        final ConvergenceChecker<UnivariatePointValuePair> checker\n-            = getConvergenceChecker();\n-\n-        double a;\n-        double b;\n-        if (lo < hi) {\n-            a = lo;\n-            b = hi;\n-        } else {\n-            a = hi;\n-            b = lo;\n+        // initialize search interval and other variables\n+        double a = getMin();\n+        double b = getMax();\n+        double c = a + GOLDEN_SECTION * (b - a);\n+        double d = b - GOLDEN_SECTION * (b - a);\n+        double fc = computeObjectiveValue(c);\n+        if (!isMinim) {\n+            fc = -fc;\n         }\n-\n-        double x = mid;\n-        double v = x;\n-        double w = x;\n-        double d = 0;\n-        double e = 0;\n-        double fx = computeObjectiveValue(x);\n+        double fd = computeObjectiveValue(d);\n         if (!isMinim) {\n-            fx = -fx;\n+            fd = -fd;\n         }\n-        double fv = fx;\n-        double fw = fx;\n-\n-        UnivariatePointValuePair previous = null;\n-        UnivariatePointValuePair current\n-            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n \n-        int iter = 0;\n         while (true) {\n-            final double m = 0.5 * (a + b);\n-            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n-            final double tol2 = 2 * tol1;\n-\n-            // Default stopping criterion.\n-            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n-            if (!stop) {\n-                double p = 0;\n-                double q = 0;\n-                double r = 0;\n-                double u = 0;\n-\n-                if (FastMath.abs(e) > tol1) { // Fit parabola.\n-                    r = (x - w) * (fx - fv);\n-                    q = (x - v) * (fx - fw);\n-                    p = (x - v) * q - (x - w) * r;\n-                    q = 2 * (q - r);\n-\n-                    if (q > 0) {\n-                        p = -p;\n-                    } else {\n-                        q = -q;\n-                    }\n-\n-                    r = e;\n-                    e = d;\n-\n-                    if (p > q * (a - x) &&\n-                        p < q * (b - x) &&\n-                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n-                        // Parabolic interpolation step.\n-                        d = p / q;\n-                        u = x + d;\n-\n-                        // f must not be evaluated too close to a or b.\n-                        if (u - a < tol2 || b - u < tol2) {\n-                            if (x <= m) {\n-                                d = tol1;\n-                            } else {\n-                                d = -tol1;\n-                            }\n-                        }\n-                    } else {\n-                        // Golden section step.\n-                        if (x < m) {\n-                            e = b - x;\n-                        } else {\n-                            e = a - x;\n-                        }\n-                        d = GOLDEN_SECTION * e;\n-                    }\n-                } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n-                }\n-\n-                // Update by at least \"tol1\".\n-                if (FastMath.abs(d) < tol1) {\n-                    if (d >= 0) {\n-                        u = x + tol1;\n-                    } else {\n-                        u = x - tol1;\n-                    }\n-                } else {\n-                    u = x + d;\n-                }\n-\n-                double fu = computeObjectiveValue(u);\n+            if (fc < fd) {\n+                b = d;\n+                d = c;\n+                fd = fc;\n+                c = a + GOLDEN_SECTION * (b - a);\n+                fc = computeObjectiveValue(c);\n                 if (!isMinim) {\n-                    fu = -fu;\n+                    fc = -fc;\n                 }\n-\n-                // User-defined convergence checker.\n-                previous = current;\n-                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n-\n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return current;\n-                    }\n+            } else {\n+                a = c;\n+                c = d;\n+                fc = fd;\n+                d = b - GOLDEN_SECTION * (b - a);\n+                fd = computeObjectiveValue(d);\n+                if (!isMinim) {\n+                    fd = -fd;\n                 }\n+            }\n \n-                // Update a, b, v, w and x.\n-                if (fu <= fx) {\n-                    if (u < x) {\n-                        b = x;\n-                    } else {\n-                        a = x;\n-                    }\n-                    v = w;\n-                    fv = fw;\n-                    w = x;\n-                    fw = fx;\n-                    x = u;\n-                    fx = fu;\n-                } else {\n-                    if (u < x) {\n-                        a = u;\n-                    } else {\n-                        b = u;\n-                    }\n-                    if (fu <= fw ||\n-                        Precision.equals(w, x)) {\n-                        v = w;\n-                        fv = fw;\n-                        w = u;\n-                        fw = fu;\n-                    } else if (fu <= fv ||\n-                               Precision.equals(v, x) ||\n-                               Precision.equals(v, w)) {\n-                        v = u;\n-                        fv = fu;\n-                    }\n+            double tol = Math.max(relativeThreshold * Math.max(Math.abs(d), Math.abs(c)),\n+                                   absoluteThreshold);\n+            if (Math.abs(d - c) < tol) {\n+                double x = 0.5 * (c + d);\n+                double fx = computeObjectiveValue(x);\n+                if (!isMinim) {\n+                    fx = -fx;\n                 }\n-            } else { // Default termination (Brent's criterion).\n-                return current;\n+                UnivariatePointValuePair solution = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+                return solution;\n             }\n-            ++iter;\n         }\n     }\n ",
    "result_reason": "org.apache.commons.math3.exception.TooManyEvaluationsException: illegal state: maximal count (1,000) exceeded: evaluations",
    "test_result": "FAIL"
}