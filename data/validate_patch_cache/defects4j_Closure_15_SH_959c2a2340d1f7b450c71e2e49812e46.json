{
    "patch": "import com.google.javascript.jscomp.graph.DiGraphEdge;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.jscomp.graph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph;\nimport com.google.javascript.rhino.StaticSourceFile;\n\nimport java.util.*;\n\npublic final class DataFlowAnalysis {\n\n  private final Map<Node, Set<Node>> dependent;\n\n  private final DiGraph<Node, Branch> cfg;\n\n  public DataFlowAnalysis(DiGraph<Node, Branch> cfg) {\n    this.cfg = cfg;\n    dependent = new HashMap<>();\n  }\n\n  private enum Branch {\n    ON_TRUE,\n    ON_FALSE,\n    ON_EX,\n    UNCOND,\n    SWITCH,\n    CASE,\n    DEFAULT,\n    CONTINUE,\n    BREAK\n  }\n\n  public Map<Node, Set<Node>> getDependents() {\n    return dependent;\n  }\n\n  public DiGraph<Node, Branch> getCfg() {\n    return cfg;\n  }\n\n  public void analyze() {\n    ControlFlowAnalysis cfa = new ControlFlowAnalysis(getCfg());\n    cfa.analyze();\n\n    final List<Node> reversePostOrder = cfa.getReversePostOrder();\n    final Map<Node, Integer> order = new HashMap<>(reversePostOrder.size());\n    for (int i = 0; i < reversePostOrder.size(); i++) {\n      final Node node = reversePostOrder.get(i);\n      order.put(node, i);\n    }\n\n    Map<Node, Set<Node>> defSets = new HashMap<>();\n    Set<Node> defSet = new HashSet<>();\n    Block.clear(defSet);\n    defSets.put(null, defSet);\n\n    final Node externsRoot = cfa.getExternsRoot();\n\n    for (final Node node : reversePostOrder) {\n      if (node.isFunction()) {\n        defSet = new HashSet<>();\n        Block.clear(defSet);\n        final FunctionSummaryProvider provider = getFunctionInfo(node);\n        for (final Node formal : provider.getFunction().getJSDocInfo().getParameterNames()) {\n          defSet.add(formal);\n        }\n        defSets.put(node, defSet);\n      } else if (node.isScript() || node == externsRoot) {\n        defSet = new HashSet<>();\n        Block.clear(defSet);\n        defSets.put(node, defSet);\n      } else {\n        // clone the previous set\n        defSet = new HashSet<>(defSets.get(node.getParent()));\n      }\n      propagate(node, defSet, defSets);\n    }\n    dependent.putAll(defSets);\n  }\n\n  private void propagate(Node n, Set<Node> defSet, Map<Node, Set<Node>> defSets) {\n    switch (n.getToken()) {\n      case CALL:\n      case NEW:\n        {\n          final Node callee = n.getFirstChild();\n          final FunctionSummaryProvider provider = getFunctionInfo(callee);\n          if (provider != null) {\n            if (provider.couldHaveSideEffects()) {\n              defSet = new HashSet<>(); // Overkill to be creating a new set.\n              defSet.add(n);\n              defSets.put(n, defSet);\n            } else {\n              defSets.put(n, defSet);\n            }\n          } else {\n            propagateChildren(n, defSet);\n            defSets.put(n, defSet);\n          }\n          break;\n        }\n      case NAME:\n        {\n          final Node parent = n.getParent();\n          if (parent.isExprResult()) {\n            final FunctionSummaryProvider provider = getFunctionInfo(n);\n            if (provider != null) {\n              if (provider.couldHaveSideEffects()) {\n                defSet = new HashSet<>(); // Overkill to be creating a new set.\n                defSet.add(n);\n                defSets.put(n, defSet);\n              } else {\n                defSets.put(n, defSet);\n              }\n            } else {\n              propagateChildren(n, defSet);\n              defSets.put(n, defSet);\n            }\n          } else if (parent.isAssign() && parent.getFirstChild() == n) {\n            defSet = new HashSet<>(); // Overkill to be creating a new set.\n            defSet.add(n);\n            defSets.put(n, defSet);\n          } else if (defSet.contains(n)) { // n has been redefined and hence is no longer a dependent.\n            defSet = new HashSet<>(defSet);\n            defSet.remove(n);\n            defSets.put(n, defSet);\n            propagateChildren(n, defSet);\n          } else {\n            propagateChildren(n, defSet);\n            defSets.put(n, defSet);\n          }\n          break;\n        }\n      case BLOCK:\n      case SCRIPT:\n      case IF:\n      case SWITCH:\n      case WHILE:\n      case DOWHILE:\n      case FOR:\n        {\n          Map<Node, Set<Node>> lattice = new HashMap<>();\n          for (DiGraphEdge<Node, Branch> edge : getCfg().getOutEdges(n)) {\n            propagate(edge.getDestination(), defSet, defSets);\n            lattice.put(edge.getDestination(), defSets.get(edge.getDestination()));\n          }\n          final Set<Node> deps = join(n, lattice);\n          defSets.put(n, deps);\n          break;\n        }\n      default:\n        propagateChildren(n, defSet);\n        defSets.put(n, defSet);\n    }\n  }\n\n  private void propagateChildren(Node n, Set<Node> defSet) {\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {\n        defSet.addAll(dependent.get(c));\n      }\n    }\n  }\n\n  private Set<Node> join(Node n, Map<Node, Set<Node>> lattice) {\n    Branch branch = null;\n    for (DiGraphEdge<Node, Branch> edge : getCfg().getOutEdges(n)) {\n      if (edge.getDestination() == null) {\n        branch = edge.getValue();\n      }\n    }\n    if (branch == Branch.CASE || branch == Branch.DEFAULT) {\n      // We take the intersection of dependent values for a CASE or\n      // DEFAULT clause.\n      Set<Node> deps = null;\n      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n        if (outEdge.getValue() == branch) {\n          final Set<Node> outs = dependent.get(outEdge.getDestination());\n          if (deps == null) {\n            deps = new HashSet<Node>(outs);\n          } else {\n            deps.retainAll(outs);\n          }\n        }\n      }\n      if (deps == null) {\n        deps = new HashSet<Node>();\n      }\n      return deps;\n    } else {\n      Set<Node> deps = new HashSet<Node>();\n      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n        final Set<Node> outs = dependent.get(outEdge.getDestination());\n        deps.addAll(outs);\n      }\n>>> [ INFILL HERE ] <<<\n      return deps;\n    }\n  }\n\n  private FunctionSummaryProvider getFunctionInfo(Node callNode) {\n    final Node callee = callNode.getFirstChild();\n    if (callee.isName()) {\n      final String name = callee.getString();\n      StaticSourceFile staticSourceFile = null;\n      if (callNode.getSourceFileName() != null) {\n        staticSourceFile =\n            new StaticSourceFile(callNode.getSourceFileName(), callNode.getInputId());\n      }\n      return FunctionSummaryProvider.fromScope(name, staticSourceFile);\n    }\n    return FunctionSummaryProvider.fromFunction(getCfg(), callee);\n  }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  public static Map<Node, Set<Node>> analyze(DiGraph<Node, Branch> cfg) {\n    DataFlowAnalysis analysis = new DataFlowAnalysis(cfg);\n    analysis.analyze();\n    return analysis.getDependents();\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex a8e92fcc..197cf64d 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,6 +99,235 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n+import com.google.javascript.jscomp.graph.DiGraphEdge;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.jscomp.graph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.rhino.StaticSourceFile;\n+\n+import java.util.*;\n+\n+public final class DataFlowAnalysis {\n+\n+  private final Map<Node, Set<Node>> dependent;\n+\n+  private final DiGraph<Node, Branch> cfg;\n+\n+  public DataFlowAnalysis(DiGraph<Node, Branch> cfg) {\n+    this.cfg = cfg;\n+    dependent = new HashMap<>();\n+  }\n+\n+  private enum Branch {\n+    ON_TRUE,\n+    ON_FALSE,\n+    ON_EX,\n+    UNCOND,\n+    SWITCH,\n+    CASE,\n+    DEFAULT,\n+    CONTINUE,\n+    BREAK\n+  }\n+\n+  public Map<Node, Set<Node>> getDependents() {\n+    return dependent;\n+  }\n+\n+  public DiGraph<Node, Branch> getCfg() {\n+    return cfg;\n+  }\n+\n+  public void analyze() {\n+    ControlFlowAnalysis cfa = new ControlFlowAnalysis(getCfg());\n+    cfa.analyze();\n+\n+    final List<Node> reversePostOrder = cfa.getReversePostOrder();\n+    final Map<Node, Integer> order = new HashMap<>(reversePostOrder.size());\n+    for (int i = 0; i < reversePostOrder.size(); i++) {\n+      final Node node = reversePostOrder.get(i);\n+      order.put(node, i);\n+    }\n+\n+    Map<Node, Set<Node>> defSets = new HashMap<>();\n+    Set<Node> defSet = new HashSet<>();\n+    Block.clear(defSet);\n+    defSets.put(null, defSet);\n+\n+    final Node externsRoot = cfa.getExternsRoot();\n+\n+    for (final Node node : reversePostOrder) {\n+      if (node.isFunction()) {\n+        defSet = new HashSet<>();\n+        Block.clear(defSet);\n+        final FunctionSummaryProvider provider = getFunctionInfo(node);\n+        for (final Node formal : provider.getFunction().getJSDocInfo().getParameterNames()) {\n+          defSet.add(formal);\n+        }\n+        defSets.put(node, defSet);\n+      } else if (node.isScript() || node == externsRoot) {\n+        defSet = new HashSet<>();\n+        Block.clear(defSet);\n+        defSets.put(node, defSet);\n+      } else {\n+        // clone the previous set\n+        defSet = new HashSet<>(defSets.get(node.getParent()));\n+      }\n+      propagate(node, defSet, defSets);\n+    }\n+    dependent.putAll(defSets);\n+  }\n+\n+  private void propagate(Node n, Set<Node> defSet, Map<Node, Set<Node>> defSets) {\n+    switch (n.getToken()) {\n+      case CALL:\n+      case NEW:\n+        {\n+          final Node callee = n.getFirstChild();\n+          final FunctionSummaryProvider provider = getFunctionInfo(callee);\n+          if (provider != null) {\n+            if (provider.couldHaveSideEffects()) {\n+              defSet = new HashSet<>(); // Overkill to be creating a new set.\n+              defSet.add(n);\n+              defSets.put(n, defSet);\n+            } else {\n+              defSets.put(n, defSet);\n+            }\n+          } else {\n+            propagateChildren(n, defSet);\n+            defSets.put(n, defSet);\n+          }\n+          break;\n+        }\n+      case NAME:\n+        {\n+          final Node parent = n.getParent();\n+          if (parent.isExprResult()) {\n+            final FunctionSummaryProvider provider = getFunctionInfo(n);\n+            if (provider != null) {\n+              if (provider.couldHaveSideEffects()) {\n+                defSet = new HashSet<>(); // Overkill to be creating a new set.\n+                defSet.add(n);\n+                defSets.put(n, defSet);\n+              } else {\n+                defSets.put(n, defSet);\n+              }\n+            } else {\n+              propagateChildren(n, defSet);\n+              defSets.put(n, defSet);\n+            }\n+          } else if (parent.isAssign() && parent.getFirstChild() == n) {\n+            defSet = new HashSet<>(); // Overkill to be creating a new set.\n+            defSet.add(n);\n+            defSets.put(n, defSet);\n+          } else if (defSet.contains(n)) { // n has been redefined and hence is no longer a dependent.\n+            defSet = new HashSet<>(defSet);\n+            defSet.remove(n);\n+            defSets.put(n, defSet);\n+            propagateChildren(n, defSet);\n+          } else {\n+            propagateChildren(n, defSet);\n+            defSets.put(n, defSet);\n+          }\n+          break;\n+        }\n+      case BLOCK:\n+      case SCRIPT:\n+      case IF:\n+      case SWITCH:\n+      case WHILE:\n+      case DOWHILE:\n+      case FOR:\n+        {\n+          Map<Node, Set<Node>> lattice = new HashMap<>();\n+          for (DiGraphEdge<Node, Branch> edge : getCfg().getOutEdges(n)) {\n+            propagate(edge.getDestination(), defSet, defSets);\n+            lattice.put(edge.getDestination(), defSets.get(edge.getDestination()));\n+          }\n+          final Set<Node> deps = join(n, lattice);\n+          defSets.put(n, deps);\n+          break;\n+        }\n+      default:\n+        propagateChildren(n, defSet);\n+        defSets.put(n, defSet);\n+    }\n+  }\n+\n+  private void propagateChildren(Node n, Set<Node> defSet) {\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      if (!ControlFlowGraph.isEnteringNewCfgNode(c)) {\n+        defSet.addAll(dependent.get(c));\n+      }\n+    }\n+  }\n+\n+  private Set<Node> join(Node n, Map<Node, Set<Node>> lattice) {\n+    Branch branch = null;\n+    for (DiGraphEdge<Node, Branch> edge : getCfg().getOutEdges(n)) {\n+      if (edge.getDestination() == null) {\n+        branch = edge.getValue();\n+      }\n+    }\n+    if (branch == Branch.CASE || branch == Branch.DEFAULT) {\n+      // We take the intersection of dependent values for a CASE or\n+      // DEFAULT clause.\n+      Set<Node> deps = null;\n+      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n+        if (outEdge.getValue() == branch) {\n+          final Set<Node> outs = dependent.get(outEdge.getDestination());\n+          if (deps == null) {\n+            deps = new HashSet<Node>(outs);\n+          } else {\n+            deps.retainAll(outs);\n+          }\n+        }\n+      }\n+      if (deps == null) {\n+        deps = new HashSet<Node>();\n+      }\n+      return deps;\n+    } else {\n+      Set<Node> deps = new HashSet<Node>();\n+      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n+        final Set<Node> outs = dependent.get(outEdge.getDestination());\n+        deps.addAll(outs);\n+      }\n+>>> [ INFILL HERE ] <<<\n+      return deps;\n+    }\n+  }\n+\n+  private FunctionSummaryProvider getFunctionInfo(Node callNode) {\n+    final Node callee = callNode.getFirstChild();\n+    if (callee.isName()) {\n+      final String name = callee.getString();\n+      StaticSourceFile staticSourceFile = null;\n+      if (callNode.getSourceFileName() != null) {\n+        staticSourceFile =\n+            new StaticSourceFile(callNode.getSourceFileName(), callNode.getInputId());\n+      }\n+      return FunctionSummaryProvider.fromScope(name, staticSourceFile);\n+    }\n+    return FunctionSummaryProvider.fromFunction(getCfg(), callee);\n+  }\n+\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  public static Map<Node, Set<Node>> analyze(DiGraph<Node, Branch> cfg) {\n+    DataFlowAnalysis analysis = new DataFlowAnalysis(cfg);\n+    analysis.analyze();\n+    return analysis.getDependents();\n+  }\n+}\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}