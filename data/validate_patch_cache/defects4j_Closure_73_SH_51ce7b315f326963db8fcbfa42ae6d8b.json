{
    "patch": "          if (outputCharsetEncoder != null) {\n            CharBuffer cb = CharBuffer.wrap(new char[]{c});\n            ByteBuffer bb;\n            try {\n              bb = outputCharsetEncoder.encode(cb);\n            } catch (CharacterCodingException e) {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n              continue;\n            }\n            if (bb == null || bb.limit() != 1) {\n              // Unicode-escape the character.\n              appendHexJavaScriptRepresentation(sb, c);\n              continue;\n            }\n            byte b = bb.get();\n            if (b >= 0) {\n              sb.append((char) b);\n            } else {\n              // b < 0 is equivalent to b + 256, but in hex.\n              sb.append(\"\\\\x\");\n              if (b < -0x0f) sb.append('0');\n              sb.append(Integer.toHexString(b + 256));\n            }\n          } \n          if (outputCharsetEncoder == null && (c <= 0x1f || c >= 0x7f)) {\n            // Other characters can be misinterpreted by some js parsers,\n            // or perhaps mangled by proxies along the way,\n            // so we play it safe and unicode escape them.\n            appendHexJavaScriptRepresentation(sb, c);\n          } else {\n            sb.append(c);\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..b5bcf0ae 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,39 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+          if (outputCharsetEncoder != null) {\n+            CharBuffer cb = CharBuffer.wrap(new char[]{c});\n+            ByteBuffer bb;\n+            try {\n+              bb = outputCharsetEncoder.encode(cb);\n+            } catch (CharacterCodingException e) {\n+              // Unicode-escape the character.\n+              appendHexJavaScriptRepresentation(sb, c);\n+              continue;\n+            }\n+            if (bb == null || bb.limit() != 1) {\n+              // Unicode-escape the character.\n+              appendHexJavaScriptRepresentation(sb, c);\n+              continue;\n+            }\n+            byte b = bb.get();\n+            if (b >= 0) {\n+              sb.append((char) b);\n+            } else {\n+              // b < 0 is equivalent to b + 256, but in hex.\n+              sb.append(\"\\\\x\");\n+              if (b < -0x0f) sb.append('0');\n+              sb.append(Integer.toHexString(b + 256));\n+            }\n+          } \n+          if (outputCharsetEncoder == null && (c <= 0x1f || c >= 0x7f)) {\n+            // Other characters can be misinterpreted by some js parsers,\n+            // or perhaps mangled by proxies along the way,\n+            // so we play it safe and unicode escape them.\n+            appendHexJavaScriptRepresentation(sb, c);\n+          } else {\n+            sb.append(c);\n+          }\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "result_reason": "error: 'else' without 'if'",
    "test_result": "ERROR"
}