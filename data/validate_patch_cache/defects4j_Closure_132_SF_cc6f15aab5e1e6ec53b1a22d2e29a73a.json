{
    "patch": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    // If the condition is a literal, we'll let other optimizations try to remove useless code.\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    // Ensure the two branches of the conditional exist for optimization.\n    if (elseBranch == null) {\n        return n;\n    }\n\n    // Optimize the case where both branches have a return statement.\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n        Node thenExpr = getBlockReturnExpression(thenBranch);\n        Node elseExpr = getBlockReturnExpression(elseBranch);\n        n.removeChild(cond);\n        thenExpr.detachFromParent();\n        elseExpr.detachFromParent();\n        Node result = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n)).srcrefTreeIfMissing(n);\n        parent.replaceChild(n, result);\n        reportCodeChange();\n        return result;\n    }\n\n    // Optimize the case where the then branch node is an expression block.\n    if (isFoldableExpressBlock(thenBranch)) {\n        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                isLowerPrecedenceInExpression(thenOp.getFirstChild(), AND_PRECEDENCE)) {\n            return n;\n        }\n\n        elseOp = null;\n\n        if (!late && isPropertyAssignmentInExpression(getBlockExpression(thenBranch))) {\n            // Keep opportunities for CollapseProperties such as\n            // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n            // until CollapseProperties has been run.\n            return n;\n        }\n\n        // Check whether the else branch is an expression block.\n        if (isFoldableExpressBlock(elseBranch)) {\n            elseOp = getBlockExpression(elseBranch).getFirstChild();\n            if (thenOp.getType() == elseOp.getType()) {\n                Node lhs = thenOp.getFirstChild();\n                Node rhs = elseOp.getFirstChild();\n                if (areNodesEqualForInlining(lhs, rhs) &&\n                        !mayEffectMutableState(lhs)) {\n                    n.removeChild(cond);\n\n                    if (thenOp.getType() == Token.ASSIGN) {\n                        // a = b: c + d ? e : f\n                        Node newCondition = createHook(cond, \n                                                        thenOp.getSecondChild(),\n                                                        elseOp.getLastChild());\n                        Node newExpression = IR.exprResult(createAssign(\n                                                   lhs.cloneTree(),\n                                                   newCondition));\n                        parent.replaceChild(n, newExpression);\n                        reportCodeChange();\n                        return newExpression;\n                    }\n\n                    // a = b ? c : d\n                    Node assign = new Node(thenOp.getType(),\n                                            lhs.cloneTree(),\n                                            createHook(\n                                                cond,\n                                                thenOp.getSecondChild(),\n                                                elseOp.getLastChild()));\n                    Node newExpression = NodeUtil.newExpr(assign);\n                    parent.replaceChild(n, newExpression);\n                    reportCodeChange();\n                    return newExpression;\n                }\n            } else if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n                    isLowerPrecedenceInExpression(thenOp.getFirstChild(), OR_PRECEDENCE)) {\n                // We cannot add two sets of parentheses in an expression tree.\n                return n;\n            }\n        }\n\n        // Check whether the else branch is a statement block.\n        if (elseOp == null && NodeUtil.isStatementBlock(elseBranch)) {\n            // Keep track of the parent, condition, and then branch nodes, and then try optimize on the inner child.\n            Node parent_ = n;\n            Node cond_ = cond;\n            Node thenBranch_ = thenBranch.getFirstChild();\n\n            while (NodeUtil.isStatementBlock(elseBranch)) {\n                Node elseBranchFirstChild = elseBranch.getFirstChild();\n\n                // The inner child should be an if statement.\n                if (!elseBranchFirstChild.isIf()) {\n                    break;\n                }\n\n                Node elseCond = elseBranchFirstChild.getFirstChild();\n                Node elseThenBranch = elseCond.getNext();\n                Node elseElseBranch = elseThenBranch.getNext();\n\n                // The if statement should only have two children.\n                if (elseElseBranch != null) {\n                    break;\n                }\n\n                // Try optimize the inner if statement.\n                tryMinimizeIf(elseBranchFirstChild);\n\n                Node newCondition = IR.and(cond_,\n                                            IR.not(elseCond.cloneTree()))\n                                            .srcref(cond_);\n                elseCond.replaceWith(IR.and(\n                                        elseCond.detachFromParent(),\n                                        cond_.cloneNode())\n                                        .srcref(cond_));\n                Node newThenBranch = elseThenBranch.detachFromParent();\n                newThenBranch.setJSDocInfo(n.getJSDocInfo());\n                elseOp = createHook(cond_,\n                                    thenOp.getSecondChild(),\n                                    newThenBranch);\n                parent_.replaceChild(n, elseOp);\n                reportCodeChange();\n                return elseOp;\n            }\n\n            return n;\n        }\n\n        if (elseOp == null) {\n            return n;\n        }\n\n        Node expression;\n\n        // Use the conditional operator if the operator precedences allow it.\n        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE)) {\n            if (isLowerPrecedenceInExpression(thenOp.getFirstChild(), OR_PRECEDENCE)) {\n                return n;\n            }\n\n            expression = IR.or(cond,\n                                IR.comma(elseOp.detachFromParent(),\n                                          thenOp.getSecondChild())).srcref(n);\n        }\n        else if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)) {\n            if (isLowerPrecedenceInExpression(thenOp.getFirstChild(), AND_PRECEDENCE)) {\n                return n;\n            }\n\n            expression = IR.and(cond, \n                                IR.comma(thenOp.getSecondChild(),\n                                            elseOp.detachFromParent())).srcref(n);\n        }\n        else {\n            return n;\n        }\n\n        n.removeChild(cond);\n        Node newExpr = NodeUtil.newExpr(expression);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n    }\n\n    // Optimize the case where the then branch node is a statement block.\n    if (NodeUtil.isStatementBlock(thenBranch)) {\n        // Get the nested if statement from the then branch.\n        if (thenBranch.hasOneChild() && thenBranch.getFirstChild().isIf()) {\n            Node parent_ = n;\n            Node cond_ = cond;\n            Node thenBranch_ = thenBranch.getFirstChild();\n            Node elseBranch_ = elseBranch;\n\n            Node elseCond = IR.not(cond_.cloneTree());\n\n            if (!tryMinimizeIf(thenBranch_)) {\n                return n;\n            }\n\n            thenBranch_.removeChild(0);\n            Node thenReturns = thenBranch_.detachChildren();\n\n            boolean canOptimizeBraces = !NodeUtil.isStatementBlock(thenReturns);\n\n            elseBranch_ = IR.block(elseBranch_.detachChildren());\n            elseBranch_.setIsSyntheticBlock(true);\n            elseBranch_.addChildToFront(IR.exprResult(IR.assign(\n                                                        thenBranch_.removeFirstChild().removeFirstChild(),\n                                                        elseBranch_)).srcref(thenBranch_));\n\n            Node newIf = new Node(Token.IF,\n                      IR.comma(cond_.detachFromParent(), thenBranch_),\n                      elseBranch_).srcref(n);\n\n            if (parent_.replaceChild(n, newIf)) {\n                if (canOptimizeBraces \n                    && NodeUtil.isStatementBlock(newIf.getLastChild()) \n                    && newIf.getLastChild().hasOneChild() \n                    && NodeUtil.isControlStructure(newIf.getLastChild().getFirstChild())) {\n                    Node block = newIf.getLastChild();\n                    block.removeChildAt(0);\n                    parent_.replaceChild(newIf, block);\n                }\n                reportCodeChange();\n                return newIf;\n            }\n        } else if (NodeUtil.isStatementBlock(elseBranch)) {\n            Node parent_ = n;\n            Node cond_ = cond;\n            Node thenBranch_ = thenBranch.getFirstChild();\n            Node elseBranch_ = elseBranch.getFirstChild();\n            if (!elseBranch_.isIf()) {\n                return n;\n            }\n\n            Node elseCond = elseBranch_.getFirstChild();\n            Node elseThenBranch = elseCond.getNext();\n            Node elseElseBranch = elseThenBranch.getNext();\n\n            if (elseElseBranch != null) {\n                return n;\n            }\n\n            // Try optimize the nested if statement.\n            if (!tryMinimizeIf(elseBranch_)) {\n                return n;\n            }\n\n            elseBranch_.removeChild(0);\n            Node elseReturns = elseBranch_.detachChildren();\n\n            boolean canOptimizeBraces = !NodeUtil.isStatementBlock",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..c48aa0e0 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -633,239 +633,246 @@ class PeepholeSubstituteAlternateSyntax\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n-  private Node tryMinimizeIf(Node n) {\n-\n+private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n-\n     Node cond = n.getFirstChild();\n \n-    /* If the condition is a literal, we'll let other\n-     * optimizations try to remove useless code.\n-     */\n+    // If the condition is a literal, we'll let other optimizations try to remove useless code.\n     if (NodeUtil.isLiteralValue(cond, true)) {\n-      return n;\n+        return n;\n     }\n \n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n+    // Ensure the two branches of the conditional exist for optimization.\n     if (elseBranch == null) {\n-      if (isFoldableExpressBlock(thenBranch)) {\n-        Node expr = getBlockExpression(thenBranch);\n-        if (!late && isPropertyAssignmentInExpression(expr)) {\n-          // Keep opportunities for CollapseProperties such as\n-          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-          // until CollapseProperties has been run.\n-          return n;\n-        }\n+        return n;\n+    }\n+\n+    // Optimize the case where both branches have a return statement.\n+    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+        Node thenExpr = getBlockReturnExpression(thenBranch);\n+        Node elseExpr = getBlockReturnExpression(elseBranch);\n+        n.removeChild(cond);\n+        thenExpr.detachFromParent();\n+        elseExpr.detachFromParent();\n+        Node result = IR.returnNode(IR.hook(cond, thenExpr, elseExpr).srcref(n)).srcrefTreeIfMissing(n);\n+        parent.replaceChild(n, result);\n+        reportCodeChange();\n+        return result;\n+    }\n \n-        if (cond.isNot()) {\n-          // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n+    // Optimize the case where the then branch node is an expression block.\n+    if (isFoldableExpressBlock(thenBranch)) {\n+        Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n+                isLowerPrecedenceInExpression(thenOp.getFirstChild(), AND_PRECEDENCE)) {\n             return n;\n-          }\n+        }\n \n-          Node or = IR.or(\n-              cond.removeFirstChild(),\n-              expr.removeFirstChild()).srcref(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          reportCodeChange();\n+        elseOp = null;\n \n-          return newExpr;\n+        if (!late && isPropertyAssignmentInExpression(getBlockExpression(thenBranch))) {\n+            // Keep opportunities for CollapseProperties such as\n+            // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n+            // until CollapseProperties has been run.\n+            return n;\n         }\n \n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses is worth the change even if\n-          // there is no immediate code size win. However, two extra pair of\n-          // {}, we would have to think twice. (unless we know for sure the\n-          // we can further optimize its parent.\n-          return n;\n+        // Check whether the else branch is an expression block.\n+        if (isFoldableExpressBlock(elseBranch)) {\n+            elseOp = getBlockExpression(elseBranch).getFirstChild();\n+            if (thenOp.getType() == elseOp.getType()) {\n+                Node lhs = thenOp.getFirstChild();\n+                Node rhs = elseOp.getFirstChild();\n+                if (areNodesEqualForInlining(lhs, rhs) &&\n+                        !mayEffectMutableState(lhs)) {\n+                    n.removeChild(cond);\n+\n+                    if (thenOp.getType() == Token.ASSIGN) {\n+                        // a = b: c + d ? e : f\n+                        Node newCondition = createHook(cond, \n+                                                        thenOp.getSecondChild(),\n+                                                        elseOp.getLastChild());\n+                        Node newExpression = IR.exprResult(createAssign(\n+                                                   lhs.cloneTree(),\n+                                                   newCondition));\n+                        parent.replaceChild(n, newExpression);\n+                        reportCodeChange();\n+                        return newExpression;\n+                    }\n+\n+                    // a = b ? c : d\n+                    Node assign = new Node(thenOp.getType(),\n+                                            lhs.cloneTree(),\n+                                            createHook(\n+                                                cond,\n+                                                thenOp.getSecondChild(),\n+                                                elseOp.getLastChild()));\n+                    Node newExpression = NodeUtil.newExpr(assign);\n+                    parent.replaceChild(n, newExpression);\n+                    reportCodeChange();\n+                    return newExpression;\n+                }\n+            } else if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n+                    isLowerPrecedenceInExpression(thenOp.getFirstChild(), OR_PRECEDENCE)) {\n+                // We cannot add two sets of parentheses in an expression tree.\n+                return n;\n+            }\n         }\n \n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n-        reportCodeChange();\n+        // Check whether the else branch is a statement block.\n+        if (elseOp == null && NodeUtil.isStatementBlock(elseBranch)) {\n+            // Keep track of the parent, condition, and then branch nodes, and then try optimize on the inner child.\n+            Node parent_ = n;\n+            Node cond_ = cond;\n+            Node thenBranch_ = thenBranch.getFirstChild();\n \n-        return newExpr;\n-      } else {\n+            while (NodeUtil.isStatementBlock(elseBranch)) {\n+                Node elseBranchFirstChild = elseBranch.getFirstChild();\n \n-        // Try to combine two IF-ELSE\n-        if (NodeUtil.isStatementBlock(thenBranch) &&\n-            thenBranch.hasOneChild()) {\n-          Node innerIf = thenBranch.getFirstChild();\n-\n-          if (innerIf.isIf()) {\n-            Node innerCond = innerIf.getFirstChild();\n-            Node innerThenBranch = innerCond.getNext();\n-            Node innerElseBranch = innerThenBranch.getNext();\n-\n-            if (innerElseBranch == null &&\n-                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n-              n.detachChildren();\n-              n.addChildToBack(\n-                  IR.and(\n-                      cond,\n-                      innerCond.detachFromParent())\n-                      .srcref(cond));\n-              n.addChildrenToBack(innerThenBranch.detachFromParent());\n-              reportCodeChange();\n-              // Not worth trying to fold the current IF-ELSE into && because\n-              // the inner IF-ELSE wasn't able to be folded into && anyways.\n-              return n;\n+                // The inner child should be an if statement.\n+                if (!elseBranchFirstChild.isIf()) {\n+                    break;\n+                }\n+\n+                Node elseCond = elseBranchFirstChild.getFirstChild();\n+                Node elseThenBranch = elseCond.getNext();\n+                Node elseElseBranch = elseThenBranch.getNext();\n+\n+                // The if statement should only have two children.\n+                if (elseElseBranch != null) {\n+                    break;\n+                }\n+\n+                // Try optimize the inner if statement.\n+                tryMinimizeIf(elseBranchFirstChild);\n+\n+                Node newCondition = IR.and(cond_,\n+                                            IR.not(elseCond.cloneTree()))\n+                                            .srcref(cond_);\n+                elseCond.replaceWith(IR.and(\n+                                        elseCond.detachFromParent(),\n+                                        cond_.cloneNode())\n+                                        .srcref(cond_));\n+                Node newThenBranch = elseThenBranch.detachFromParent();\n+                newThenBranch.setJSDocInfo(n.getJSDocInfo());\n+                elseOp = createHook(cond_,\n+                                    thenOp.getSecondChild(),\n+                                    newThenBranch);\n+                parent_.replaceChild(n, elseOp);\n+                reportCodeChange();\n+                return elseOp;\n             }\n-          }\n+\n+            return n;\n         }\n-      }\n \n-      return n;\n-    }\n+        if (elseOp == null) {\n+            return n;\n+        }\n \n-    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n-     * peephole optimization. This should probably get moved to another pass.\n-     */\n-    tryRemoveRepeatedStatements(n);\n-\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      reportCodeChange();\n-      return n;\n-    }\n+        Node expression;\n \n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-      Node thenExpr = getBlockReturnExpression(thenBranch);\n-      Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n-                                .srcref(n));\n-      parent.replaceChild(n, returnNode);\n-      reportCodeChange();\n-      return returnNode;\n-    }\n+        // Use the conditional operator if the operator precedences allow it.\n+        if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE)) {\n+            if (isLowerPrecedenceInExpression(thenOp.getFirstChild(), OR_PRECEDENCE)) {\n+                return n;\n+            }\n \n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-      if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n-        if (NodeUtil.isAssignmentOp(thenOp)) {\n-          Node lhs = thenOp.getFirstChild();\n-          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n-            reportCodeChange();\n+            expression = IR.or(cond,\n+                                IR.comma(elseOp.detachFromParent(),\n+                                          thenOp.getSecondChild())).srcref(n);\n+        }\n+        else if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE)) {\n+            if (isLowerPrecedenceInExpression(thenOp.getFirstChild(), AND_PRECEDENCE)) {\n+                return n;\n+            }\n \n-            return expr;\n-          }\n+            expression = IR.and(cond, \n+                                IR.comma(thenOp.getSecondChild(),\n+                                            elseOp.detachFromParent())).srcref(n);\n+        }\n+        else {\n+            return n;\n         }\n-      }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n-      reportCodeChange();\n-      return expr;\n-    }\n \n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n+        n.removeChild(cond);\n+        Node newExpr = NodeUtil.newExpr(expression);\n+        parent.replaceChild(n, newExpr);\n         reportCodeChange();\n-        return var;\n-      }\n+        return newExpr;\n+    }\n \n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n+    // Optimize the case where the then branch node is a statement block.\n+    if (NodeUtil.isStatementBlock(thenBranch)) {\n+        // Get the nested if statement from the then branch.\n+        if (thenBranch.hasOneChild() && thenBranch.getFirstChild().isIf()) {\n+            Node parent_ = n;\n+            Node cond_ = cond;\n+            Node thenBranch_ = thenBranch.getFirstChild();\n+            Node elseBranch_ = elseBranch;\n \n-        return var;\n-      }\n-    }\n+            Node elseCond = IR.not(cond_.cloneTree());\n \n-    return n;\n-  }\n+            if (!tryMinimizeIf(thenBranch_)) {\n+                return n;\n+            }\n+\n+            thenBranch_.removeChild(0);\n+            Node thenReturns = thenBranch_.detachChildren();\n+\n+            boolean canOptimizeBraces = !NodeUtil.isStatementBlock(thenReturns);\n+\n+            elseBranch_ = IR.block(elseBranch_.detachChildren());\n+            elseBranch_.setIsSyntheticBlock(true);\n+            elseBranch_.addChildToFront(IR.exprResult(IR.assign(\n+                                                        thenBranch_.removeFirstChild().removeFirstChild(),\n+                                                        elseBranch_)).srcref(thenBranch_));\n+\n+            Node newIf = new Node(Token.IF,\n+                      IR.comma(cond_.detachFromParent(), thenBranch_),\n+                      elseBranch_).srcref(n);\n+\n+            if (parent_.replaceChild(n, newIf)) {\n+                if (canOptimizeBraces \n+                    && NodeUtil.isStatementBlock(newIf.getLastChild()) \n+                    && newIf.getLastChild().hasOneChild() \n+                    && NodeUtil.isControlStructure(newIf.getLastChild().getFirstChild())) {\n+                    Node block = newIf.getLastChild();\n+                    block.removeChildAt(0);\n+                    parent_.replaceChild(newIf, block);\n+                }\n+                reportCodeChange();\n+                return newIf;\n+            }\n+        } else if (NodeUtil.isStatementBlock(elseBranch)) {\n+            Node parent_ = n;\n+            Node cond_ = cond;\n+            Node thenBranch_ = thenBranch.getFirstChild();\n+            Node elseBranch_ = elseBranch.getFirstChild();\n+            if (!elseBranch_.isIf()) {\n+                return n;\n+            }\n+\n+            Node elseCond = elseBranch_.getFirstChild();\n+            Node elseThenBranch = elseCond.getNext();\n+            Node elseElseBranch = elseThenBranch.getNext();\n+\n+            if (elseElseBranch != null) {\n+                return n;\n+            }\n+\n+            // Try optimize the nested if statement.\n+            if (!tryMinimizeIf(elseBranch_)) {\n+                return n;\n+            }\n+\n+            elseBranch_.removeChild(0);\n+            Node elseReturns = elseBranch_.detachChildren();\n+\n+            boolean canOptimizeBraces = !NodeUtil.isStatementBlock\n \n   /**\n    * Try to remove duplicate statements from IF blocks. For example:",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}