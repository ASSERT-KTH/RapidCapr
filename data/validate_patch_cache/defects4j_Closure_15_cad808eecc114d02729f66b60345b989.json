{
    "patch": "  private Set<Node> join(Node n, Map<Node, Set<Node>> lattice) {\n    Branch branch = null;\n    for (DiGraphEdge<Node, Branch> edge : getCfg().getOutEdges(n)) {\n      if (edge.getDestination() == null) {\n        branch = edge.getValue();\n      }\n    }\n    if (branch == Branch.CASE || branch == Branch.DEFAULT) {\n      // We take the intersection of dependent values for a CASE or\n      // DEFAULT clause.\n      Set<Node> deps = null;\n      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n        if (outEdge.getValue() == branch) {\n          final Set<Node> outs = dependent.get(outEdge.getDestination());\n          if (deps == null) {\n            deps = new HashSet<Node>(outs);\n          } else {\n            deps.retainAll(outs);\n          }\n        }\n      }\n      if (deps == null) {\n        deps = new HashSet<Node>();\n      }\n      return deps;\n    } else {\n      Set<Node> deps = new HashSet<Node>();\n      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n        final Set<Node> outs = dependent.get(outEdge.getDestination());\n        deps.addAll(outs);\n      }\n      /* [ INFILL HERE ] */\n      if (hasExceptionHandler(n)) {\n        final Set<Node> exceptionDeps = new HashSet<>();\n        for (Node dep : deps) {\n          if (dependent.containsKey(dep)) {\n            exceptionDeps.addAll(dependent.get(dep));\n          }\n        }\n        deps.addAll(exceptionDeps);\n      }\n      return deps;\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex a8e92fcc..5013f867 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,6 +99,51 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n+  private Set<Node> join(Node n, Map<Node, Set<Node>> lattice) {\n+    Branch branch = null;\n+    for (DiGraphEdge<Node, Branch> edge : getCfg().getOutEdges(n)) {\n+      if (edge.getDestination() == null) {\n+        branch = edge.getValue();\n+      }\n+    }\n+    if (branch == Branch.CASE || branch == Branch.DEFAULT) {\n+      // We take the intersection of dependent values for a CASE or\n+      // DEFAULT clause.\n+      Set<Node> deps = null;\n+      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n+        if (outEdge.getValue() == branch) {\n+          final Set<Node> outs = dependent.get(outEdge.getDestination());\n+          if (deps == null) {\n+            deps = new HashSet<Node>(outs);\n+          } else {\n+            deps.retainAll(outs);\n+          }\n+        }\n+      }\n+      if (deps == null) {\n+        deps = new HashSet<Node>();\n+      }\n+      return deps;\n+    } else {\n+      Set<Node> deps = new HashSet<Node>();\n+      for (DiGraphEdge<Node, Branch> outEdge : getCfg().getOutEdges(n)) {\n+        final Set<Node> outs = dependent.get(outEdge.getDestination());\n+        deps.addAll(outs);\n+      }\n+      /* [ INFILL HERE ] */\n+      if (hasExceptionHandler(n)) {\n+        final Set<Node> exceptionDeps = new HashSet<>();\n+        for (Node dep : deps) {\n+          if (dependent.containsKey(dep)) {\n+            exceptionDeps.addAll(dependent.get(dep));\n+          }\n+        }\n+        deps.addAll(exceptionDeps);\n+      }\n+      return deps;\n+    }\n+  }\n+}\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}