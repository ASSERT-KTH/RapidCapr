{
    "patch": "private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() ||\n        (cfa != null && node == cfa.getRoot())) {\n      return null;\n    }\n    switch (parent.getToken()) {\n      case IF:\n        return computeFollowNode(fromNode, parent, cfa);\n      case CASE:\n      case DEFAULT_CASE:\n        if (parent.getNext() != null) {\n          if (parent.getNext().getToken() == Token.CASE) {\n            return parent.getNext().getFirstChild().getNext();\n          } else if (parent.getNext().getToken() == Token.DEFAULT_CASE) {\n            return parent.getNext().getFirstChild();\n          } else {\n            throw new IllegalStateException(\"Not reachable\");\n          }\n        } else {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n      case FOR:\n        switch (NodeUtil.getEnclosingType(node)) {\n          case FOR:\n          case FOR_IN:\n            if (node == parent.getFirstChild()) {\n              Node initialize = parent.getFirstChild().getNext();\n              if (initialize == node) {\n                // The follow of the FOR initializes to the first iteration\n                // of the loop, which is the body of the loop if the\n                // condition is non-constant, or the follow of the loop\n                // otherwise. (Note that if the condition is constant,\n                // then the type of follow is actually a next statement\n                // rather than a follow statement; however, the type of\n                // follow only matters if the loop body terminates normally,\n                // so we can treat both cases the same way here.)\n                Node condition = initialize.getNext();\n                if (condition.getToken() == Token.EMPTY) {\n                  // No condition; treat same as if always true\n                  return computeFollowNode(fromNode,\n                      condition.getNext().getNext(), cfa);\n                } else {\n                  return computeConditionalFollow(condition, cfa);\n                }\n              } else {\n                // After the initialization but before the condition:\n                return initialize;\n              }\n            } else if (node == parent.getChildAtIndex(1)) {\n              Node condition = parent.getChildAtIndex(1);\n              Node increment = parent.getChildAtIndex(2);\n              if (computeConstantValue(condition) == BooleanLiteral.FALSE) {\n                // The loop will never execute. Follow is whatever comes next.\n                return computeFallThrough(parent);\n              }\n              return increment;\n            } else {\n              // After the increment:\n              return computeFollowNode(fromNode, parent, cfa);\n            }\n          default:\n            if (NodeUtil.isForIn(parent)) {\n              return parent.getFirstChild().getNext();\n            } else {\n              Node conditionNode = parent.getChildAtIndex(1);\n              for (Node n : conditionNode.children()) {\n                if (n.getToken() == Token.EMPTY) {\n                  continue;\n                }\n                if (NodeUtil.isFunctionDeclaration(n)) {\n                  break;\n                }\n                if (NodeUtil.isStatementBlock(n)) {\n                  Node statementNode = getStatementNode(n);\n                  if (statementNode == null) {\n                    continue;\n                  }\n                  if (statementNode.isJump()) {\n                    if (NodeUtil.isFinallyBlock(statementNode.getParent())) {\n                      return computeFallThrough(statementNode.getNext());\n                    }\n                  } else {\n                    return statementNode;\n                  }\n                }\n              }\n              return computeFollowNode(fromNode, parent, cfa);\n            }\n        }\n      case WHILE:\n      case DO:\n        return parent;\n      case TRY:\n        if (parent.getFirstChild() == node) {\n          if (NodeUtil.hasFinallyBlock(parent)) {\n            return computeFallThrough(parent.getLastChild());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (cfa != null\n            && cfa.getCatchBlock(node) == node) {\n          if (NodeUtil.hasFinallyBlock(parent)) {\n            return computeFallThrough(node.getNext());\n          } else {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n        } else if (parent.getLastChild() == node){\n          if (cfa != null) {\n            for (Node finallyNode : cfa.getFinallyBlocks(parent)) {\n              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n    }\n    Node nextSibling = node.getNext();\n    while (nextSibling != null && nextSibling.isFunction()) {\n      nextSibling = nextSibling.getNext();\n    }\n    if (nextSibling != null) {\n      return computeFallThrough(nextSibling);\n    } else {\n      return computeFollowNode(fromNode, parent, cfa);\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..e472ebc3 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -689,101 +689,130 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n    *        during recursion.\n    * @param node The node that follow() should compute.\n    */\n-  private static Node computeFollowNode(\n+private static Node computeFollowNode(\n       Node fromNode, Node node, ControlFlowAnalysis cfa) {\n-    /*\n-     * This is the case where:\n-     *\n-     * 1. Parent is null implies that we are transferring control to the end of\n-     * the script.\n-     *\n-     * 2. Parent is a function implies that we are transferring control back to\n-     * the caller of the function.\n-     *\n-     * 3. If the node is a return statement, we should also transfer control\n-     * back to the caller of the function.\n-     *\n-     * 4. If the node is root then we have reached the end of what we have been\n-     * asked to traverse.\n-     *\n-     * In all cases we should transfer control to a \"symbolic return\" node.\n-     * This will make life easier for DFAs.\n-     */\n     Node parent = node.getParent();\n     if (parent == null || parent.isFunction() ||\n-        (cfa != null && node == cfa.root)) {\n+        (cfa != null && node == cfa.getRoot())) {\n       return null;\n     }\n-\n-    // If we are just before a IF/WHILE/DO/FOR:\n-    switch (parent.getType()) {\n-      // The follow() of any of the path from IF would be what follows IF.\n-      case Token.IF:\n+    switch (parent.getToken()) {\n+      case IF:\n         return computeFollowNode(fromNode, parent, cfa);\n-      case Token.CASE:\n-      case Token.DEFAULT_CASE:\n-        // After the body of a CASE, the control goes to the body of the next\n-        // case, without having to go to the case condition.\n+      case CASE:\n+      case DEFAULT_CASE:\n         if (parent.getNext() != null) {\n-          if (parent.getNext().isCase()) {\n+          if (parent.getNext().getToken() == Token.CASE) {\n             return parent.getNext().getFirstChild().getNext();\n-          } else if (parent.getNext().isDefaultCase()) {\n+          } else if (parent.getNext().getToken() == Token.DEFAULT_CASE) {\n             return parent.getNext().getFirstChild();\n           } else {\n-            Preconditions.checkState(false, \"Not reachable\");\n+            throw new IllegalStateException(\"Not reachable\");\n           }\n         } else {\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n-        break;\n-      case Token.FOR:\n-        if (NodeUtil.isForIn(parent)) {\n-          return parent;\n-        } else {\n-          return parent.getFirstChild().getNext().getNext();\n+      case FOR:\n+        switch (NodeUtil.getEnclosingType(node)) {\n+          case FOR:\n+          case FOR_IN:\n+            if (node == parent.getFirstChild()) {\n+              Node initialize = parent.getFirstChild().getNext();\n+              if (initialize == node) {\n+                // The follow of the FOR initializes to the first iteration\n+                // of the loop, which is the body of the loop if the\n+                // condition is non-constant, or the follow of the loop\n+                // otherwise. (Note that if the condition is constant,\n+                // then the type of follow is actually a next statement\n+                // rather than a follow statement; however, the type of\n+                // follow only matters if the loop body terminates normally,\n+                // so we can treat both cases the same way here.)\n+                Node condition = initialize.getNext();\n+                if (condition.getToken() == Token.EMPTY) {\n+                  // No condition; treat same as if always true\n+                  return computeFollowNode(fromNode,\n+                      condition.getNext().getNext(), cfa);\n+                } else {\n+                  return computeConditionalFollow(condition, cfa);\n+                }\n+              } else {\n+                // After the initialization but before the condition:\n+                return initialize;\n+              }\n+            } else if (node == parent.getChildAtIndex(1)) {\n+              Node condition = parent.getChildAtIndex(1);\n+              Node increment = parent.getChildAtIndex(2);\n+              if (computeConstantValue(condition) == BooleanLiteral.FALSE) {\n+                // The loop will never execute. Follow is whatever comes next.\n+                return computeFallThrough(parent);\n+              }\n+              return increment;\n+            } else {\n+              // After the increment:\n+              return computeFollowNode(fromNode, parent, cfa);\n+            }\n+          default:\n+            if (NodeUtil.isForIn(parent)) {\n+              return parent.getFirstChild().getNext();\n+            } else {\n+              Node conditionNode = parent.getChildAtIndex(1);\n+              for (Node n : conditionNode.children()) {\n+                if (n.getToken() == Token.EMPTY) {\n+                  continue;\n+                }\n+                if (NodeUtil.isFunctionDeclaration(n)) {\n+                  break;\n+                }\n+                if (NodeUtil.isStatementBlock(n)) {\n+                  Node statementNode = getStatementNode(n);\n+                  if (statementNode == null) {\n+                    continue;\n+                  }\n+                  if (statementNode.isJump()) {\n+                    if (NodeUtil.isFinallyBlock(statementNode.getParent())) {\n+                      return computeFallThrough(statementNode.getNext());\n+                    }\n+                  } else {\n+                    return statementNode;\n+                  }\n+                }\n+              }\n+              return computeFollowNode(fromNode, parent, cfa);\n+            }\n         }\n-      case Token.WHILE:\n-      case Token.DO:\n+      case WHILE:\n+      case DO:\n         return parent;\n-      case Token.TRY:\n-        // If we are coming out of the TRY block...\n+      case TRY:\n         if (parent.getFirstChild() == node) {\n-          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n+          if (NodeUtil.hasFinallyBlock(parent)) {\n             return computeFallThrough(parent.getLastChild());\n-          } else { // and have no FINALLY.\n+          } else {\n             return computeFollowNode(fromNode, parent, cfa);\n           }\n-        // CATCH block.\n-        } else if (NodeUtil.getCatchBlock(parent) == node){\n-          if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n+        } else if (cfa != null\n+            && cfa.getCatchBlock(node) == node) {\n+          if (NodeUtil.hasFinallyBlock(parent)) {\n             return computeFallThrough(node.getNext());\n           } else {\n             return computeFollowNode(fromNode, parent, cfa);\n           }\n-        // If we are coming out of the FINALLY block...\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n-            for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+            for (Node finallyNode : cfa.getFinallyBlocks(parent)) {\n               cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n-\n-    // Now that we are done with the special cases follow should be its\n-    // immediate sibling, unless its sibling is a function\n     Node nextSibling = node.getNext();\n-\n-    // Skip function declarations because control doesn't get pass into it.\n     while (nextSibling != null && nextSibling.isFunction()) {\n       nextSibling = nextSibling.getNext();\n     }\n-\n     if (nextSibling != null) {\n       return computeFallThrough(nextSibling);\n     } else {\n-      // If there are no more siblings, control is transferred up the AST.\n       return computeFollowNode(fromNode, parent, cfa);\n     }\n   }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}