{
    "patch": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n        Node n, Node parent, Node rhsValue) {\n      Node ownerNode = n.getFirstChild();\n      if (ownerNode == null) {\n        return;\n      }\n      String ownerName = ownerNode.getQualifiedName();\n      if (ownerName == null) {\n        return;\n      }\n      String qName = n.getQualifiedName();\n      String propName = n.getLastChild().getString();\n      Preconditions.checkArgument(qName != null && ownerName != null);\n\n      // Precedence of type information on GETPROPs:\n      // 1) @type annnotation / @enum annotation\n      // 2) ASSIGN to FUNCTION literal\n      // 3) @param/@return annotation (with no function literal)\n      // 4) ASSIGN to something marked @const\n      // 5) ASSIGN to anything else\n      //\n      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n      // the function has jsdoc or has not been declared before.\n      //\n      // FUNCTION literals are special because TypedScopeCreator is very smart\n      // about getting as much type information as possible for them.\n\n      // Determining type for #1 + #2 + #3 + #4\n      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n      if (valueType == null && rhsValue != null) {\n        // Determining type for #5\n        valueType = rhsValue.getJSType();\n      }\n      // Function prototypes are special.\n      // It's a common JS idiom to do:\n      // F.prototype = { ... };\n      // So if F does not have an explicitly declared super type,\n      // allow F.prototype to be redefined arbitrarily.\n      if (\"prototype\".equals(propName)) {\n        Var qVar = scope.getVar(qName);\n        if (qVar != null) {\n          ObjectType qVarType = ObjectType.cast(qVar.getType());\n          if (qVarType != null &&\n              rhsValue != null &&\n              rhsValue.isObjectLit()) {\n            typeRegistry.resetImplicitPrototype(\n                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n          } else if (!qVar.isTypeInferred()) {\n            return;\n          }\n          if (qVar.getScope() == scope) {\n            scope.undeclare(qVar);\n          }\n        }\n      }\n\n      if (valueType == null) {\n        if (parent != null && parent.isExprResult()) {\n          stubDeclarations.add(new StubDeclaration(\n              n,\n              t.getInput() != null && t.getInput().isExtern(),\n              ownerName));\n        }\n\n        return;\n      }\n\n      boolean inferred = true;\n      if (info != null) {\n        inferred = !(info.hasType()\n            || info.hasEnumParameterType()\n            || (info.isConstant() && valueType != null\n                && !valueType.isUnknownType())\n            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n      }\n\n      if (inferred) {\n        inferred = !(rhsValue != null &&\n            rhsValue.isFunction() &&\n            (info != null || !scope.isDeclared(qName, false)));\n      }\n\n      if (!inferred) {\n        ObjectType ownerType = getObjectSlot(ownerName);\n        if (ownerType != null) {\n          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n          if ((!ownerType.hasOwnProperty(propName) ||\n               ownerType.isPropertyTypeInferred(propName)) &&\n              ((isExtern && !ownerType.isNativeObjectType()) ||\n               !ownerType.isInstanceType())) {\n            ownerType.defineDeclaredProperty(propName, valueType, n);\n          }\n        }\n\n        defineSlot(n, parent, valueType, inferred);\n      } else if (rhsValue != null && rhsValue.isTrue()) {\n        FunctionType ownerType =\n            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n        if (ownerType != null) {\n          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n          String delegateName = codingConvention.getDelegateSuperclassName();\n          JSType delegateType = delegateName == null ?\n              null : typeRegistry.getType(delegateName);\n          if (delegateType != null &&\n              ownerTypeOfThis.isSubtype(delegateType)) {\n            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n          }\n        }\n      } else if (parent != null && parent.isExprResult() &&\n                 !isTopLevel() && isFullyResolved(n)) {\n        stubDeclarations.add(new StubDeclaration(\n            n, t.getInput() != null && ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 3fb48137..04d123ba 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1416,7 +1416,13 @@ final class TypedScopeCreator implements ScopeCreator {\n     void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n         Node n, Node parent, Node rhsValue) {\n       Node ownerNode = n.getFirstChild();\n+      if (ownerNode == null) {\n+        return;\n+      }\n       String ownerName = ownerNode.getQualifiedName();\n+      if (ownerName == null) {\n+        return;\n+      }\n       String qName = n.getQualifiedName();\n       String propName = n.getLastChild().getString();\n       Preconditions.checkArgument(qName != null && ownerName != null);\n@@ -1448,11 +1454,6 @@ final class TypedScopeCreator implements ScopeCreator {\n       if (\"prototype\".equals(propName)) {\n         Var qVar = scope.getVar(qName);\n         if (qVar != null) {\n-          // If the programmer has declared that F inherits from Super,\n-          // and they assign F.prototype to an object literal,\n-          // then they are responsible for making sure that the object literal's\n-          // implicit prototype is set up appropriately. We just obey\n-          // the @extends tag.\n           ObjectType qVarType = ObjectType.cast(qVar.getType());\n           if (qVarType != null &&\n               rhsValue != null &&\n@@ -1460,11 +1461,6 @@ final class TypedScopeCreator implements ScopeCreator {\n             typeRegistry.resetImplicitPrototype(\n                 rhsValue.getJSType(), qVarType.getImplicitPrototype());\n           } else if (!qVar.isTypeInferred()) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to some arbitrary expression,\n-            // there's not much we can do. We just ignore the expression,\n-            // and hope they've annotated their code in a way to tell us\n-            // what props are going to be on that prototype.\n             return;\n           }\n           if (qVar.getScope() == scope) {\n@@ -1474,7 +1470,7 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n \n       if (valueType == null) {\n-        if (parent.isExprResult()) {\n+        if (parent != null && parent.isExprResult()) {\n           stubDeclarations.add(new StubDeclaration(\n               n,\n               t.getInput() != null && t.getInput().isExtern(),\n@@ -1484,33 +1480,8 @@ final class TypedScopeCreator implements ScopeCreator {\n         return;\n       }\n \n-      // NOTE(nicksantos): Determining whether a property is declared or not\n-      // is really really obnoxious.\n-      //\n-      // The problem is that there are two (equally valid) coding styles:\n-      //\n-      // (function() {\n-      //   /* The authoritative definition of goog.bar. */\n-      //   goog.bar = function() {};\n-      // })();\n-      //\n-      // function f() {\n-      //   goog.bar();\n-      //   /* Reset goog.bar to a no-op. */\n-      //   goog.bar = function() {};\n-      // }\n-      //\n-      // In a dynamic language with first-class functions, it's very difficult\n-      // to know which one the user intended without looking at lots of\n-      // contextual information (the second example demonstrates a small case\n-      // of this, but there are some really pathological cases as well).\n-      //\n-      // The current algorithm checks if either the declaration has\n-      // jsdoc type information, or @const with a known type,\n-      // or a function literal with a name we haven't seen before.\n       boolean inferred = true;\n       if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n         inferred = !(info.hasType()\n             || info.hasEnumParameterType()\n             || (info.isConstant() && valueType != null\n@@ -1519,7 +1490,6 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n \n       if (inferred) {\n-        // Determining declaration for #2\n         inferred = !(rhsValue != null &&\n             rhsValue.isFunction() &&\n             (info != null || !scope.isDeclared(qName, false)));\n@@ -1528,23 +1498,17 @@ final class TypedScopeCreator implements ScopeCreator {\n       if (!inferred) {\n         ObjectType ownerType = getObjectSlot(ownerName);\n         if (ownerType != null) {\n-          // Only declare this as an official property if it has not been\n-          // declared yet.\n           boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n           if ((!ownerType.hasOwnProperty(propName) ||\n                ownerType.isPropertyTypeInferred(propName)) &&\n               ((isExtern && !ownerType.isNativeObjectType()) ||\n                !ownerType.isInstanceType())) {\n-            // If the property is undeclared or inferred, declare it now.\n             ownerType.defineDeclaredProperty(propName, valueType, n);\n           }\n         }\n \n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n         defineSlot(n, parent, valueType, inferred);\n       } else if (rhsValue != null && rhsValue.isTrue()) {\n-        // We declare these for delegate proxy method properties.\n         FunctionType ownerType =\n             JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n         if (ownerType != null) {\n@@ -1557,8 +1521,10 @@ final class TypedScopeCreator implements ScopeCreator {\n             defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n           }\n         }\n-      }\n-    }\n+      } else if (parent != null && parent.isExprResult() &&\n+                 !isTopLevel() && isFullyResolved(n)) {\n+        stubDeclarations.add(new StubDeclaration(\n+            n, t.getInput() != null && \n \n     /**\n      * Find the ObjectType associated with the given slot.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}