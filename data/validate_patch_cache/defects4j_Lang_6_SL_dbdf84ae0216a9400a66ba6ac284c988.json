{
    "patch": "import java.io.IOException;\nimport java.io.Writer;\n\npublic final class StringEscapeUtils {\n\n    private static final String CSV_QUOTE_STR = String.valueOf('\"');\n    private static final char CSV_DELIMITER = ',';\n\n    private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE_STR.charAt(0), '\\r', '\\n'};\n\n    private static CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n\n    private StringEscapeUtils() {\n        // empty constructor\n    }\n\n    /**\n     * Translates a string to be in a format suitable for CSV.\n     *\n     * This method will:<br>\n     * <ul>\n     * <li>Check if the input string needs processing, by looking for any of the following characters: comma, quote,\n     * newline (\\n) or carriage return (\\r).</li>\n     * <li>If the string does not contain any of the above characters, return the string as is.</li>\n     * <li>Enclose the input string in quotes.</li>\n     * <li>Double up any double quotes found inside the string.</li>\n     * </ul>\n     *\n     * @see <a href=\"https://tools.ietf.org/html/rfc4180\">RFC 4180</a>\n     *\n     * @param input String to escape values in, may be null\n     * @return input String with all occurrences of the CSV search characters escaped with a preceding \\\n     */\n    public static final String escapeCsv(final String input) {\n        return ESCAPE_CSV.translate(input);\n    }\n\n    /**\n     * Performs the CSV escape on the dataset, optionally enclosing the whole data set in quotes.\n     *\n     * @param input dataset to escape.\n     * @param alwaysQuote if true the method will always enclose the dataset in quotes.\n     * @param delimiter the delimiter of the dataset to escape.\n     * @return CSV escaped dataset.\n     * @throws NullPointerException if either input or delimiter is null.\n     * @since 3.3\n     */\n    public static String escapeCsv(final String input, final boolean alwaysQuote, final char delimiter) {\n        if (input == null) {\n            return null;\n        }\n        boolean hasSpecialChars = containsNone(input, CSV_SEARCH_CHARS);\n        if (!hasSpecialChars) {\n            return input;\n        }\n        StringBuilder sb = new StringBuilder(input.length() + 10);\n        if (alwaysQuote) {\n            sb.append(CSV_QUOTE_STR);\n        }\n        for (int i = 0; i < input.length(); i++) {\n            char c = input.charAt(i);\n            if (c == CSV_QUOTE_STR.charAt(0)) {\n                sb.append(CSV_QUOTE_STR).append(CSV_QUOTE_STR);\n            } else if (c == delimiter) {\n                sb.append(CSV_QUOTE_STR).append(c).append(CSV_QUOTE_STR);\n            } else if (c == '\\r' || c == '\\n') {\n                sb.append(c);\n            } else {\n                sb.append(c);\n            }\n        }\n        if (alwaysQuote) {\n            sb.append(CSV_QUOTE_STR);\n        }\n        return sb.toString();\n    }\n\n    /**\n     * Unescapes any CSV escaping made by the {@link #escapeCsv(String)} method.\n     *\n     * @param input the CSV String to unescape, may be null\n     * @return the plain unescaped String, null if null String input\n     * @throws IllegalArgumentException if the input contains an odd number of half-quotes\n     */\n    public static String unescapeCsv(final String input) {\n        final int len = input == null ? 0 : input.length();\n        if (len == 0) {\n            return input;\n        }\n        if (len < 2) {\n            return CSV_QUOTE_STR.equals(input) ? \"\" : input;\n        }\n\n        // strip quotes\n        if (input.charAt(0) != CSV_QUOTE_STR.charAt(0) || input.charAt(len - 1) != CSV_QUOTE_STR.charAt(0)) {\n            return input;\n        }\n\n        final StringBuilder builder = new StringBuilder(len - 2);\n        boolean quoted = false;\n        for (int i = 1; i < len - 1; i++) {\n            final char prevChar = input.charAt(i - 1);\n            final char currChar = input.charAt(i);\n            if (currChar == CSV_QUOTE_STR.charAt(0)) {\n                quoted = !quoted;\n            } else if (!quoted && currChar == CSV_DELIMITER && (prevChar == CSV_DELIMITER || prevChar == CSV_QUOTE_STR.charAt(0))) {\n                // CSV-4180 allows the field to be escaped by doubling the field quote.\n                // This is trying to unescape the unquoted delimiter.\n                builder.append(currChar);\n            } else {\n                builder.append(currChar);\n            }\n        }\n        return builder.toString();\n    }\n\n    /**\n     * Helper function to determine whether or not a string contains any of the\n     * characters in the given set.\n     *\n     * @param str  String to check\n     * @param searchChars  Characters to look for\n     * @return {@code true} if any of the search chars are found, {@code false} otherwise\n     */\n    private static boolean containsNone(final CharSequence str, final char[] searchChars) {\n        if (str == null || searchChars == null) {\n            return true;\n        }\n        final int len = str.length();\n        final int searchLen = searchChars.length;\n        for (int i = 0; i < len; i++) {\n            final char ch = str.charAt(i);\n            for (int j = 0; j < searchLen; j++) {\n                if (searchChars[j] == ch) {\n                    return false;\n                }\n            }\n        }\n        return true;\n    }\n\n    /**\n     * Translator object for escaping CSV values.\n     *\n     * While {@link #escapeCsv(String)} is the expected method of use, this object allows the CSV\n     * escape rules to be used with any text.\n     */\n    static class CsvEscaper extends CharSequenceTranslator {\n\n        @Override\n        public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n            if (index != 0) {\n                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n            }\n\n            if (input.charAt(0) == CSV_QUOTE_STR.charAt(0)) {\n                out.write(CSV_QUOTE_STR);\n            }\n\n            final int len = input.length();\n            for (int i = 0; i < len; i++) {\n                final char c = input.charAt(i);\n                if (c == CSV_QUOTE_STR.charAt(0)) {\n                    out.write(CSV_QUOTE_STR); // escape double quote\n                    out.write(CSV_QUOTE_STR);\n                } else {\n                    out.write(c);\n                }\n            }\n\n            if (input.charAt(len - 1) == CSV_QUOTE_STR.charAt(0)) {\n                out.write(CSV_QUOTE_STR);\n            }\n\n            return len;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010eaf..526ea2ed 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -92,7 +92,184 @@ public abstract class CharSequenceTranslator {\n //          // contract with translators is that they have to understand codepoints \n //          // and they just took care of a surrogate pair\n             for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+import java.io.IOException;\n+import java.io.Writer;\n+\n+public final class StringEscapeUtils {\n+\n+    private static final String CSV_QUOTE_STR = String.valueOf('\"');\n+    private static final char CSV_DELIMITER = ',';\n+\n+    private static final char[] CSV_SEARCH_CHARS = new char[] {CSV_DELIMITER, CSV_QUOTE_STR.charAt(0), '\\r', '\\n'};\n+\n+    private static CharSequenceTranslator ESCAPE_CSV = new CsvEscaper();\n+\n+    private StringEscapeUtils() {\n+        // empty constructor\n+    }\n+\n+    /**\n+     * Translates a string to be in a format suitable for CSV.\n+     *\n+     * This method will:<br>\n+     * <ul>\n+     * <li>Check if the input string needs processing, by looking for any of the following characters: comma, quote,\n+     * newline (\\n) or carriage return (\\r).</li>\n+     * <li>If the string does not contain any of the above characters, return the string as is.</li>\n+     * <li>Enclose the input string in quotes.</li>\n+     * <li>Double up any double quotes found inside the string.</li>\n+     * </ul>\n+     *\n+     * @see <a href=\"https://tools.ietf.org/html/rfc4180\">RFC 4180</a>\n+     *\n+     * @param input String to escape values in, may be null\n+     * @return input String with all occurrences of the CSV search characters escaped with a preceding \\\n+     */\n+    public static final String escapeCsv(final String input) {\n+        return ESCAPE_CSV.translate(input);\n+    }\n+\n+    /**\n+     * Performs the CSV escape on the dataset, optionally enclosing the whole data set in quotes.\n+     *\n+     * @param input dataset to escape.\n+     * @param alwaysQuote if true the method will always enclose the dataset in quotes.\n+     * @param delimiter the delimiter of the dataset to escape.\n+     * @return CSV escaped dataset.\n+     * @throws NullPointerException if either input or delimiter is null.\n+     * @since 3.3\n+     */\n+    public static String escapeCsv(final String input, final boolean alwaysQuote, final char delimiter) {\n+        if (input == null) {\n+            return null;\n+        }\n+        boolean hasSpecialChars = containsNone(input, CSV_SEARCH_CHARS);\n+        if (!hasSpecialChars) {\n+            return input;\n+        }\n+        StringBuilder sb = new StringBuilder(input.length() + 10);\n+        if (alwaysQuote) {\n+            sb.append(CSV_QUOTE_STR);\n+        }\n+        for (int i = 0; i < input.length(); i++) {\n+            char c = input.charAt(i);\n+            if (c == CSV_QUOTE_STR.charAt(0)) {\n+                sb.append(CSV_QUOTE_STR).append(CSV_QUOTE_STR);\n+            } else if (c == delimiter) {\n+                sb.append(CSV_QUOTE_STR).append(c).append(CSV_QUOTE_STR);\n+            } else if (c == '\\r' || c == '\\n') {\n+                sb.append(c);\n+            } else {\n+                sb.append(c);\n+            }\n+        }\n+        if (alwaysQuote) {\n+            sb.append(CSV_QUOTE_STR);\n+        }\n+        return sb.toString();\n+    }\n+\n+    /**\n+     * Unescapes any CSV escaping made by the {@link #escapeCsv(String)} method.\n+     *\n+     * @param input the CSV String to unescape, may be null\n+     * @return the plain unescaped String, null if null String input\n+     * @throws IllegalArgumentException if the input contains an odd number of half-quotes\n+     */\n+    public static String unescapeCsv(final String input) {\n+        final int len = input == null ? 0 : input.length();\n+        if (len == 0) {\n+            return input;\n+        }\n+        if (len < 2) {\n+            return CSV_QUOTE_STR.equals(input) ? \"\" : input;\n+        }\n+\n+        // strip quotes\n+        if (input.charAt(0) != CSV_QUOTE_STR.charAt(0) || input.charAt(len - 1) != CSV_QUOTE_STR.charAt(0)) {\n+            return input;\n+        }\n+\n+        final StringBuilder builder = new StringBuilder(len - 2);\n+        boolean quoted = false;\n+        for (int i = 1; i < len - 1; i++) {\n+            final char prevChar = input.charAt(i - 1);\n+            final char currChar = input.charAt(i);\n+            if (currChar == CSV_QUOTE_STR.charAt(0)) {\n+                quoted = !quoted;\n+            } else if (!quoted && currChar == CSV_DELIMITER && (prevChar == CSV_DELIMITER || prevChar == CSV_QUOTE_STR.charAt(0))) {\n+                // CSV-4180 allows the field to be escaped by doubling the field quote.\n+                // This is trying to unescape the unquoted delimiter.\n+                builder.append(currChar);\n+            } else {\n+                builder.append(currChar);\n+            }\n+        }\n+        return builder.toString();\n+    }\n+\n+    /**\n+     * Helper function to determine whether or not a string contains any of the\n+     * characters in the given set.\n+     *\n+     * @param str  String to check\n+     * @param searchChars  Characters to look for\n+     * @return {@code true} if any of the search chars are found, {@code false} otherwise\n+     */\n+    private static boolean containsNone(final CharSequence str, final char[] searchChars) {\n+        if (str == null || searchChars == null) {\n+            return true;\n+        }\n+        final int len = str.length();\n+        final int searchLen = searchChars.length;\n+        for (int i = 0; i < len; i++) {\n+            final char ch = str.charAt(i);\n+            for (int j = 0; j < searchLen; j++) {\n+                if (searchChars[j] == ch) {\n+                    return false;\n+                }\n+            }\n+        }\n+        return true;\n+    }\n+\n+    /**\n+     * Translator object for escaping CSV values.\n+     *\n+     * While {@link #escapeCsv(String)} is the expected method of use, this object allows the CSV\n+     * escape rules to be used with any text.\n+     */\n+    static class CsvEscaper extends CharSequenceTranslator {\n+\n+        @Override\n+        public int translate(final CharSequence input, final int index, final Writer out) throws IOException {\n+            if (index != 0) {\n+                throw new IllegalStateException(\"CsvEscaper should never reach the [1] index\");\n+            }\n+\n+            if (input.charAt(0) == CSV_QUOTE_STR.charAt(0)) {\n+                out.write(CSV_QUOTE_STR);\n+            }\n+\n+            final int len = input.length();\n+            for (int i = 0; i < len; i++) {\n+                final char c = input.charAt(i);\n+                if (c == CSV_QUOTE_STR.charAt(0)) {\n+                    out.write(CSV_QUOTE_STR); // escape double quote\n+                    out.write(CSV_QUOTE_STR);\n+                } else {\n+                    out.write(c);\n+                }\n+            }\n+\n+            if (input.charAt(len - 1) == CSV_QUOTE_STR.charAt(0)) {\n+                out.write(CSV_QUOTE_STR);\n+            }\n+\n+            return len;\n+        }\n+    }\n+}\n             }\n         }\n     }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}