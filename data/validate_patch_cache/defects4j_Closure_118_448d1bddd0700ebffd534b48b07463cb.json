{
    "patch": "private void handleObjectLit(NodeTraversal t, Node n) {\n  Set<String> processedProperties = new HashSet<String>();\n\n  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n    // Maybe STRING, GET, SET\n\n    // We should never see a mix of numbers and strings.\n    String name = child.getString();\n    if (processedProperties.contains(name)) {\n      // Property has already been processed, skip it to prevent reporting duplicated errors.\n      continue;\n    }\n\n    List<Node> propertyDefs = getPropertyDefinitionNodes(name);\n\n    // Traverse the prototype chain to gather all properties from all prototypes.\n    Node objectLiteral = n;\n    while (!propertyDefs.isEmpty() && objectLiteral.hasOneChild()) {\n      objectLiteral = objectLiteral.getFirstChild();\n      propertyDefs = getPropertyDefinitionNodes(propertyDefs, objectLiteral);\n    }\n\n    T type = typeSystem.getType(getScope(), n, name);\n    Property prop = getProperty(name);\n\n    boolean renamed = false;\n    for (Node propertyDef : propertyDefs) {\n      if (prop.scheduleRenaming(propertyDef, processProperty(t, prop, type, null))) {\n        renamed = true;\n      }\n      processedProperties.add(name);\n    }\n\n    if (!renamed) {\n      // TODO(user): It doesn't look like the user can do much in this\n      // case right now.\n      if (propertiesToErrorFor.containsKey(name)) {\n        compiler.report(\n            JSError.make(\n                t.getSourceName(),\n                child,\n                propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION,\n                name,\n                (type == null ? \"null\" : type.toString()),\n                n.toString(),\n                \"\"));\n      }\n    }\n  }\n}\n\n/**\n * Gets the nodes where a given property is defined.\n *\n * @param propertyName the name of the property to get the definition nodes for.\n * @return a list of nodes where the given property is defined.\n */\nprivate List<Node> getPropertyDefinitionNodes(String propertyName) {\n  List<Node> definitionNodes = new ArrayList<Node>();\n  Node globalScope = getScope().getGlobalScope();\n  Var var = globalScope.getVar(propertyName);\n  if (var != null) {\n    definitionNodes.addAll(var.getDeclarationNodes());\n    definitionNodes.addAll(var.getOccurrences());\n  }\n  return definitionNodes;\n}\n\n/**\n * Gets the nodes where a given property is defined on the prototype chain of a given object node.\n *\n * @param propertyDefs the list of property definition nodes to filter.\n * @param objectNode the object node to look for the property on the prototype chain of.\n * @return a list of nodes where the given property is defined on the prototype chain of the given\n *     object node.\n */\nprivate List<Node> getPropertyDefinitionNodes(List<Node> propertyDefs, Node objectNode) {\n  List<Node> filteredDefs = new ArrayList<Node>();\n  for (Node propDef : propertyDefs) {\n    Node objDef = getContainingObject(propDef);\n    if (objDef == objectNode || objDef.getJSDocInfo() == null || !objDef.getJSDocInfo().isConstructor()) {\n      continue;\n    }\n\n    Node prototypeAssign = objDef.getFirstChild().getNext();\n    if (prototypeAssign == null || prototypeAssign.getToken() != Token.ASSIGN) {\n      continue;\n    }\n\n    Node prototypeObjLit = prototypeAssign.getLastChild();\n    if (prototypeObjLit == null || prototypeObjLit.getToken() != Token.OBJECTLIT) {\n      continue;\n    }\n\n    for (Node child = prototypeObjLit.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.isString() && child.getString().equals(propDef.getString())) {\n        filteredDefs.add(propDef);\n        break;\n      }\n    }\n  }\n  return filteredDefs;\n}\n\n/**\n * Gets the object literal that a property definition node is contained in.\n *\n * @param propertyDef the property definition node to get the parent object literal for.\n * @return the object literal node that the given property definition node is contained in.\n */\nprivate Node getContainingObject(Node propertyDef) {\n  Node current = propertyDef.getParent();\n  while (current != null && current.getToken() != Token.OBJECTLIT) {\n    current = current.getParent();\n  }\n  return current;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex b34921ed..e056546d 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -487,31 +487,125 @@ class DisambiguateProperties<T> implements CompilerPass {\n     /**\n      * Processes a OBJECTLIT node.\n      */\n-    private void handleObjectLit(NodeTraversal t, Node n) {\n-      for (Node child = n.getFirstChild();\n-          child != null;\n-          child = child.getNext()) {\n-        // Maybe STRING, GET, SET\n-\n-        // We should never see a mix of numbers and strings.\n-        String name = child.getString();\n-        T type = typeSystem.getType(getScope(), n, name);\n-\n-        Property prop = getProperty(name);\n-        if (!prop.scheduleRenaming(child,\n-                                   processProperty(t, prop, type, null))) {\n-          // TODO(user): It doesn't look like the user can do much in this\n-          // case right now.\n-          if (propertiesToErrorFor.containsKey(name)) {\n-            compiler.report(JSError.make(\n-                t.getSourceName(), child, propertiesToErrorFor.get(name),\n-                Warnings.INVALIDATION, name,\n-                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n-          }\n-        }\n+private void handleObjectLit(NodeTraversal t, Node n) {\n+  Set<String> processedProperties = new HashSet<String>();\n+\n+  for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+    // Maybe STRING, GET, SET\n+\n+    // We should never see a mix of numbers and strings.\n+    String name = child.getString();\n+    if (processedProperties.contains(name)) {\n+      // Property has already been processed, skip it to prevent reporting duplicated errors.\n+      continue;\n+    }\n+\n+    List<Node> propertyDefs = getPropertyDefinitionNodes(name);\n+\n+    // Traverse the prototype chain to gather all properties from all prototypes.\n+    Node objectLiteral = n;\n+    while (!propertyDefs.isEmpty() && objectLiteral.hasOneChild()) {\n+      objectLiteral = objectLiteral.getFirstChild();\n+      propertyDefs = getPropertyDefinitionNodes(propertyDefs, objectLiteral);\n+    }\n+\n+    T type = typeSystem.getType(getScope(), n, name);\n+    Property prop = getProperty(name);\n+\n+    boolean renamed = false;\n+    for (Node propertyDef : propertyDefs) {\n+      if (prop.scheduleRenaming(propertyDef, processProperty(t, prop, type, null))) {\n+        renamed = true;\n       }\n+      processedProperties.add(name);\n     }\n \n+    if (!renamed) {\n+      // TODO(user): It doesn't look like the user can do much in this\n+      // case right now.\n+      if (propertiesToErrorFor.containsKey(name)) {\n+        compiler.report(\n+            JSError.make(\n+                t.getSourceName(),\n+                child,\n+                propertiesToErrorFor.get(name),\n+                Warnings.INVALIDATION,\n+                name,\n+                (type == null ? \"null\" : type.toString()),\n+                n.toString(),\n+                \"\"));\n+      }\n+    }\n+  }\n+}\n+\n+/**\n+ * Gets the nodes where a given property is defined.\n+ *\n+ * @param propertyName the name of the property to get the definition nodes for.\n+ * @return a list of nodes where the given property is defined.\n+ */\n+private List<Node> getPropertyDefinitionNodes(String propertyName) {\n+  List<Node> definitionNodes = new ArrayList<Node>();\n+  Node globalScope = getScope().getGlobalScope();\n+  Var var = globalScope.getVar(propertyName);\n+  if (var != null) {\n+    definitionNodes.addAll(var.getDeclarationNodes());\n+    definitionNodes.addAll(var.getOccurrences());\n+  }\n+  return definitionNodes;\n+}\n+\n+/**\n+ * Gets the nodes where a given property is defined on the prototype chain of a given object node.\n+ *\n+ * @param propertyDefs the list of property definition nodes to filter.\n+ * @param objectNode the object node to look for the property on the prototype chain of.\n+ * @return a list of nodes where the given property is defined on the prototype chain of the given\n+ *     object node.\n+ */\n+private List<Node> getPropertyDefinitionNodes(List<Node> propertyDefs, Node objectNode) {\n+  List<Node> filteredDefs = new ArrayList<Node>();\n+  for (Node propDef : propertyDefs) {\n+    Node objDef = getContainingObject(propDef);\n+    if (objDef == objectNode || objDef.getJSDocInfo() == null || !objDef.getJSDocInfo().isConstructor()) {\n+      continue;\n+    }\n+\n+    Node prototypeAssign = objDef.getFirstChild().getNext();\n+    if (prototypeAssign == null || prototypeAssign.getToken() != Token.ASSIGN) {\n+      continue;\n+    }\n+\n+    Node prototypeObjLit = prototypeAssign.getLastChild();\n+    if (prototypeObjLit == null || prototypeObjLit.getToken() != Token.OBJECTLIT) {\n+      continue;\n+    }\n+\n+    for (Node child = prototypeObjLit.getFirstChild(); child != null; child = child.getNext()) {\n+      if (child.isString() && child.getString().equals(propDef.getString())) {\n+        filteredDefs.add(propDef);\n+        break;\n+      }\n+    }\n+  }\n+  return filteredDefs;\n+}\n+\n+/**\n+ * Gets the object literal that a property definition node is contained in.\n+ *\n+ * @param propertyDef the property definition node to get the parent object literal for.\n+ * @return the object literal node that the given property definition node is contained in.\n+ */\n+private Node getContainingObject(Node propertyDef) {\n+  Node current = propertyDef.getParent();\n+  while (current != null && current.getToken() != Token.OBJECTLIT) {\n+    current = current.getParent();\n+  }\n+  return current;\n+}\n+\n     private void printErrorLocations(List<String> errors, JSType t) {\n       if (!t.isObject() || t.isAllType()) {\n         return;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}