{
    "patch": "          if (NodeUtil.isFunctionExpression(value) &&\n              isSingletonGetter(value, reference)) {\n            return false;\n          }\n        }\n      }\n\n      return canMoveAggressively(value) ||\n          canMoveModerately(initialization, reference);\n    }\n\n    private boolean isSingletonGetter(Node value, Reference reference) {\n      Node parent = reference.getParent();\n      if (parent.isCall()) {\n        parent = parent.getParent();\n      }\n      if (parent.isGetProp()) {\n        PropertyInfo propInfo = reference.getScope().getProperty((Node) parent.getLastChild());\n        return isSingletonGetterMethodInfo(propInfo, value);\n      }\n      return false;\n    }\n\n    private boolean isSingletonGetterMethodInfo(PropertyInfo propInfo, Node value) {\n      return propInfo != null\n          && propInfo.isMethodDefinition()\n          && isSingletonGetterFunction(value);\n    }\n\n    private boolean isSingletonGetterFunction(Node value) {\n      Preconditions.checkArgument(value.isFunction());\n      if (value.getChildCount() != 1) {\n        return false;\n      }\n      Node body = value.getFirstChild().getNext();\n      if (body == null || !body.isBlock()) {\n        return false;\n      }\n      controlFlowAnalysis.process(null, value.getLastChild(), body);\n      return controlFlowAnalysis.isSingleExitPointFunction();\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..eb96b2d3 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,47 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+          if (NodeUtil.isFunctionExpression(value) &&\n+              isSingletonGetter(value, reference)) {\n+            return false;\n+          }\n+        }\n+      }\n+\n+      return canMoveAggressively(value) ||\n+          canMoveModerately(initialization, reference);\n+    }\n+\n+    private boolean isSingletonGetter(Node value, Reference reference) {\n+      Node parent = reference.getParent();\n+      if (parent.isCall()) {\n+        parent = parent.getParent();\n+      }\n+      if (parent.isGetProp()) {\n+        PropertyInfo propInfo = reference.getScope().getProperty((Node) parent.getLastChild());\n+        return isSingletonGetterMethodInfo(propInfo, value);\n+      }\n+      return false;\n+    }\n+\n+    private boolean isSingletonGetterMethodInfo(PropertyInfo propInfo, Node value) {\n+      return propInfo != null\n+          && propInfo.isMethodDefinition()\n+          && isSingletonGetterFunction(value);\n+    }\n+\n+    private boolean isSingletonGetterFunction(Node value) {\n+      Preconditions.checkArgument(value.isFunction());\n+      if (value.getChildCount() != 1) {\n+        return false;\n+      }\n+      Node body = value.getFirstChild().getNext();\n+      if (body == null || !body.isBlock()) {\n+        return false;\n+      }\n+      controlFlowAnalysis.process(null, value.getLastChild(), body);\n+      return controlFlowAnalysis.isSingleExitPointFunction();\n+    }\n         }\n       }\n ",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}