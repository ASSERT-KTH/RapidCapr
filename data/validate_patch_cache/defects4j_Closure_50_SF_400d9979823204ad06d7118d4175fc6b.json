{
    "patch": "  private Node tryFoldArrayJoin(Node n) {\n    Node callTarget = n.getFirstChild();\n\n    if (callTarget == null || !NodeUtil.isGetProp(callTarget)) {\n      return n;\n    }\n\n    Node right = callTarget.getNext();\n    if (right != null && !NodeUtil.isImmutableValue(right)) {\n      return n;\n    }\n\n    Node arrayNode = callTarget.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n        !functionName.getString().equals(\"join\")) {\n      return n;\n    }\n\n    // \",\" is the default, it doesn't need to be explicit\n    String joinString = \",\";\n    if (right != null) {\n      joinString = NodeUtil.getStringValue(right);\n      if (joinString == null) {\n        return n;\n      }\n    }\n\n    int arrayFoldedChildrenSize = countFoldedArrayChildren(arrayNode, joinString);\n    if (arrayFoldedChildrenSize < 0) {\n      return n;\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    int foldedSize = getFoldedArraySize(arrayNode, arrayFoldedChildrenSize, joinString);\n\n    // If the folded size is bigger than original size, we won't inline.\n    if (foldedSize > originalSize) {\n      return n;\n    }\n\n    switch (arrayFoldedChildrenSize) {\n      case 0:\n        Node emptyStringNode = IR.string(\"\");\n        n.replaceWith(emptyStringNode);\n        reportCodeChange();\n        return emptyStringNode;\n\n      case 1:\n        Node foldedNode = getNodeFromFoldedChildren(arrayNode, joinString);\n        if (foldedNode == null) {\n          return n;\n        }\n        if (foldedSize > originalSize) {\n          return n;\n        }\n\n        n.replaceWith(foldedNode);\n        reportCodeChange();\n        return foldedNode;\n\n      default:\n        boolean shouldInline = shouldInlineArrayJoin(arrayFoldedChildrenSize, arrayNode);\n        if (shouldInline) {\n          Node foldedFunctions = IR.getprop(arrayNode.getFirstChild().cloneTree(), \"join\");\n          Node foldedArgument = getFoldedArgumentNode(arrayFoldedChildrenSize, arrayNode, joinString);\n\n          Node resultNode;\n          boolean isWindowArray = isWindowArray(callTarget);\n          if (isWindowArray) {\n            // Window.prototype.join cannot be a native function because it is not a constructor.\n            // Thus, it can safely be called with window as a context.\n            resultNode =\n                IR.call(foldedFunctions, NodeUtil.newTarget(getAstRoot(), callTarget), foldedArgument);\n          } else {\n            resultNode = IR.exprResult(\n                IR.assign(IR.name(\"$jscomp$tmp$array$join\"), foldedFunctions.cloneTree()),\n                callTarget.cloneTree(),\n                foldedArgument.cloneTree()\n            );\n          }\n\n          NodeUtil.addFeatureToScript(n, Feature.ARRAY_JOIN);\n          n.replaceWith(resultNode);\n          reportCodeChange();\n          return resultNode;\n        } else {\n          return n;\n        }\n    }\n  }\n\n  /**\n   * Count the number of non-empty and non-null string nodes in the array node.\n   */\n  private int countFoldedArrayChildren(Node arrayNode, String joinString) {\n    int arrayFoldedChildrenSize = 0;\n    Node currentArrayNode = arrayNode.getFirstChild();\n    boolean firstElement = true;\n    while (currentArrayNode != null) {\n      if (currentArrayNode.isEmpty()) {\n        // We don't treat empty nodes, otherwise index sequence would be affected.\n        // An element would be missing and the order of other elements would be wrong.\n        return -1;\n      } else if (firstElement) {\n        // If the first element is not a string, check if we should\n        // add toString().\n        if (!NodeUtil.isStringNode(currentArrayNode)) {\n          currentArrayNode = IR.call(\n              IR.getprop(\n                  IR.getprop(IR.name(\"Object\"), IR.string(\"prototype\")), IR.string(\"toString\")),\n              currentArrayNode);\n        }\n        firstElement = false;\n      } else if (!NodeUtil.isStringNode(currentArrayNode)) {\n        return -1;\n      } else if (joinString.isEmpty() && currentArrayNode.getString().isEmpty()) {\n        // If the join string is empty, and the current string is\n        // empty, we have to make sure that this does not affect the\n        // sequence of indices displayed when console.logged.\n        arrayFoldedChildrenSize++;\n        currentArrayNode = currentArrayNode.getNext();\n        continue;\n      }\n\n      arrayFoldedChildrenSize++;\n      currentArrayNode = currentArrayNode.getNext();\n    }\n    return arrayFoldedChildrenSize;\n  }\n\n  /**\n   * Utility method to retrieve folded node containing a single string resulting from folding the\n   * array.\n   *\n   * <p>Strings are joined by a separator, so folded element might contain concatenation. A\n   * concatenation is still allowed only if it is between at most one non-empty or null element and\n   * a string that derives from a primitive value or the value null.\n   */\n  private Node getNodeFromFoldedChildren(Node arrayNode, String joinString) {\n    Node firstChild = arrayNode.getFirstChild();\n    StringBuilder sb = null;\n    boolean firstElement = true;\n\n    while (firstChild != null) {\n      Node currentStringNode;\n      if (firstElement) {\n        currentStringNode = firstChild.cloneTree();\n        if (!NodeUtil.isStringNode(currentStringNode)) {\n          String addToString = \".toString()\";\n          currentStringNode = NodeUtil.isImmutableValue(currentStringNode)\n              ? NodeUtil.newConstNode(currentStringNode)\n              : IR.comma(IR.name(\"$_$\"), currentStringNode);\n          currentStringNode = IR.add(IR.getelem(currentStringNode, IR.zero()), IR.string(\"\"));\n          currentStringNode = NodeUtil.newExprStatementSilentScope(currentStringNode);\n          return null;\n        }\n        firstElement = false;\n      } else {\n        currentStringNode = firstChild.cloneTree();\n        if (!NodeUtil.isStringNode(currentStringNode) || joinString.isEmpty()) {\n          return null;\n        }\n      }\n\n      String currentString = currentStringNode.getString();\n      if (!currentString.isEmpty() || (currentString.isEmpty() && joinString.isEmpty())) {\n        if (sb == null) {\n          sb = new StringBuilder(currentString);\n        } else {\n          sb.append(joinString).append(currentString);\n        }\n      }\n      firstChild = firstChild.getNext();\n    }\n\n    if (sb == null) {\n      return IR.string(\"\");\n    }\n    return IR.string(sb.toString());\n  }\n\n  /**\n   * Returns true if we should inline the array join statement with length {@code size}.\n   *\n   * <p>Inlining is allowed only up to a certain size limit (currently {@link\n   * CompilerOptions#getMaximumInliningSize}), unless the array join is a construction of a\n   * window.Array object, joining an empty array or a join using an empty string.\n   */\n  private boolean shouldInlineArrayJoin(int size, Node arrayNode) {\n    Preconditions.checkArgument(size > 1);\n    if (size > compiler.getOptions().getMaximumInliningSize()) {\n      return false;\n    }\n\n    Node targetNode = arrayNode.getParent();\n    while (targetNode != null) {\n      if (targetNode.isNew()) {\n        Node calleeNode = targetNode.getFirstFirstChild();\n        if (calleeNode.isQualifiedName()) {\n          String qName = calleeNode.getQualifiedName();\n          if (qName != null && qName.equals(\"Array\")) {\n            Node argNode = calleeNode.getNext();\n            if (argNode == null) {\n              return true;\n            } else if (argNode.isEmpty()) {\n              return Arrays.equals(CharMatcher.anyOf(\",\").matchesAllOf(size == 2 ? \"\" :\n                  new String(new char[size - 2]).replace(\"\\0\", \",\")), \",\".repeat(size - 2));\n            }\n          }\n        }\n      }\n      if (targetNode.isScript()) {\n        break;\n      }\n      targetNode = targetNode.getParent();\n    }\n    return true;\n  }\n\n  /**\n   * Given an array node, constructs a new node that is the sanitized array node.\n   *\n   * <p>Sanitized array node drops empty nodes and null values.\n   *\n   * <p>We also concatenate the first empty string or null with the second string if the join string\n   * is empty. We do this because this sequence of indices is seen in console output.\n   */\n  private Node getFoldedArgumentNode(int size, Node arrayNode, String joinString) {\n\n    Node currentFoldedNode = arrayNode.getFirstChild();\n    Node foldedArgument = IR.arraylit();\n    for (var i = 0; i < size; i++) {\n      if (currentFoldedNode == null || currentFoldedNode.isEmpty()) {\n        // Skip null or empty values.\n        foldedArgument.addChildToBack(IR.string(\"\"));\n        foldedArgument.putBooleanProp(Node.CONSTANT_KEY, true);\n        currentFoldedNode = currentFoldedNode.getNext();\n      } else if (joinString.isEmpty()) {\n        // Handles corner case where join string is an empty string but the array contains one or more\n        // empty string in the middle. Console output displays special indices for this sequence.\n        boolean isCurrentNodeString = NodeUtil.isStringNode(currentFoldedNode);\n        Node rightNode = isCurrentNodeString ? currentFoldedNode.getNext() : currentFoldedNode;\n        boolean isRightNodeString = NodeUtil.isStringNode(rightNode);\n        if (!isCurrentNodeString || !isRightNodeString || rightNode.isEmpty()) {\n          foldedArgument.addChildToBack(currentFoldedNode.cloneNode());\n          currentFoldedNode = rightNode;\n        } else {\n          NodeList<Node> nodeList = currentFoldedNode.removeChildren();\n          StringBuilder sb = new StringBuilder(nodeList.get(0).getString());\n          sb.append(rightNode.getString());\n          foldedArgument.addChildToBack(IR.string(sb.toString()));\n          currentFoldedNode = rightNode.getNext();\n        }\n      } else {\n        foldedArgument.addChildToBack(currentFoldedNode.cloneNode());\n        currentFoldedNode = currentFoldedNode.getNext();\n      }\n    }\n    return foldedArgument;\n  }\n\n  private boolean isWindowArray(Node callTarget) {\n    Node target = NodeUtil.getBestLValuePrototype(callTarget);\n    if (target != null && target.getFirstChild().matchesQualifiedName(\"Window.prototype\")) {\n      return true;\n    }\n    return false;\n  }\n\n  /**\n   * Calculate folded array size.\n   *\n   * <p>The size of the folded array consists of size of the all folded elements plus size of separator\n   * repeated number of elements minus one.\n   */\n  private int getFoldedArraySize(Node arrayNode, int arrayFoldedChildrenSize, String joinString) {\n    boolean first = true;\n    int length = 0;\n    Node currentNode = arrayNode.getFirstChild();\n    if (currentNode == null) {\n      // The result will be the empty string, so the folded size is one (for the prolog at least).\n      return 1;\n    }\n\n    while (currentNode != null) {\n      if (currentNode.getType() != Token.EMPTY && (first || joinString.isEmpty() ||\n          NodeUtil.isStringNode(currentNode))) {\n        if (first && !NodeUtil.isStringNode(currentNode)) {\n          currentNode = NodeUtil.newCallNode(IR.getprop(IR.name(\"Object\"), IR.string(\"prototype\")),\n              currentNode);\n        }\n        length += InlineCostEstimator.getCost(currentNode);\n        first = false;\n      }\n      currentNode = currentNode.getNext();\n      if (currentNode != null && currentNode.getType() != Token.EMPTY && !first) {\n        length += joinString.length();\n      }\n    }\n    length += (arrayFoldedChildrenSize > 1) ? joinString.length() * (arrayFoldedChildrenSize - 1) : 0;\n    return length;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\nindex ffe47d3d..f771a5d4 100644\n--- a/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n+++ b/src/com/google/javascript/jscomp/PeepholeReplaceKnownMethods.java\n@@ -372,10 +372,8 @@ class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n     }\n \n     Node right = callTarget.getNext();\n-    if (right != null) {\n-      if (!NodeUtil.isImmutableValue(right)) {\n-        return n;\n-      }\n+    if (right != null && !NodeUtil.isImmutableValue(right)) {\n+      return n;\n     }\n \n     Node arrayNode = callTarget.getFirstChild();\n@@ -386,93 +384,289 @@ class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n       return n;\n     }\n \n-      // \",\" is the default, it doesn't need to be explicit\n-\n-    String joinString = (right == null) ? \",\" : NodeUtil.getStringValue(right);\n-    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = null;\n-    int foldedSize = 0;\n-    Node prev = null;\n-    Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n-    while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem) || elem.getType() == Token.EMPTY) {\n-        if (sb == null) {\n-          sb = new StringBuilder();\n-        } else {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getArrayElementStringValue(elem));\n-      } else {\n-        if (sb != null) {\n-          Preconditions.checkNotNull(prev);\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(\n-              Node.newString(sb.toString()).copyInformationFrom(prev));\n-          sb = null;\n-        }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n+    // \",\" is the default, it doesn't need to be explicit\n+    String joinString = \",\";\n+    if (right != null) {\n+      joinString = NodeUtil.getStringValue(right);\n+      if (joinString == null) {\n+        return n;\n       }\n-      prev = elem;\n-      elem = elem.getNext();\n     }\n \n-    if (sb != null) {\n-      Preconditions.checkNotNull(prev);\n-      // + 2 for the quotes.\n-      foldedSize += sb.length() + 2;\n-      arrayFoldedChildren.add(\n-          Node.newString(sb.toString()).copyInformationFrom(prev));\n+    int arrayFoldedChildrenSize = countFoldedArrayChildren(arrayNode, joinString);\n+    if (arrayFoldedChildrenSize < 0) {\n+      return n;\n     }\n-    // one for each comma.\n-    foldedSize += arrayFoldedChildren.size() - 1;\n \n     int originalSize = InlineCostEstimator.getCost(n);\n-    switch (arrayFoldedChildren.size()) {\n+    int foldedSize = getFoldedArraySize(arrayNode, arrayFoldedChildrenSize, joinString);\n+\n+    // If the folded size is bigger than original size, we won't inline.\n+    if (foldedSize > originalSize) {\n+      return n;\n+    }\n+\n+    switch (arrayFoldedChildrenSize) {\n       case 0:\n-        Node emptyStringNode = Node.newString(\"\");\n-        n.getParent().replaceChild(n, emptyStringNode);\n+        Node emptyStringNode = IR.string(\"\");\n+        n.replaceWith(emptyStringNode);\n         reportCodeChange();\n         return emptyStringNode;\n+\n       case 1:\n-        Node foldedStringNode = arrayFoldedChildren.remove(0);\n-        if (foldedSize > originalSize) {\n+        Node foldedNode = getNodeFromFoldedChildren(arrayNode, joinString);\n+        if (foldedNode == null) {\n           return n;\n         }\n-        arrayNode.detachChildren();\n-        if (foldedStringNode.getType() != Token.STRING) {\n-          // If the Node is not a string literal, ensure that\n-          // it is coerced to a string.\n-          Node replacement = new Node(Token.ADD,\n-              Node.newString(\"\").copyInformationFrom(n),\n-              foldedStringNode);\n-          foldedStringNode = replacement;\n+        if (foldedSize > originalSize) {\n+          return n;\n         }\n-        n.getParent().replaceChild(n, foldedStringNode);\n+\n+        n.replaceWith(foldedNode);\n         reportCodeChange();\n-        return foldedStringNode;\n+        return foldedNode;\n+\n       default:\n-        // No folding could actually be performed.\n-        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n+        boolean shouldInline = shouldInlineArrayJoin(arrayFoldedChildrenSize, arrayNode);\n+        if (shouldInline) {\n+          Node foldedFunctions = IR.getprop(arrayNode.getFirstChild().cloneTree(), \"join\");\n+          Node foldedArgument = getFoldedArgumentNode(arrayFoldedChildrenSize, arrayNode, joinString);\n+\n+          Node resultNode;\n+          boolean isWindowArray = isWindowArray(callTarget);\n+          if (isWindowArray) {\n+            // Window.prototype.join cannot be a native function because it is not a constructor.\n+            // Thus, it can safely be called with window as a context.\n+            resultNode =\n+                IR.call(foldedFunctions, NodeUtil.newTarget(getAstRoot(), callTarget), foldedArgument);\n+          } else {\n+            resultNode = IR.exprResult(\n+                IR.assign(IR.name(\"$jscomp$tmp$array$join\"), foldedFunctions.cloneTree()),\n+                callTarget.cloneTree(),\n+                foldedArgument.cloneTree()\n+            );\n+          }\n+\n+          NodeUtil.addFeatureToScript(n, Feature.ARRAY_JOIN);\n+          n.replaceWith(resultNode);\n+          reportCodeChange();\n+          return resultNode;\n+        } else {\n           return n;\n         }\n-        int kJoinOverhead = \"[].join()\".length();\n-        foldedSize += kJoinOverhead;\n-        foldedSize += (right != null) ? InlineCostEstimator.getCost(right) : 0;\n-        if (foldedSize > originalSize) {\n-          return n;\n+    }\n+  }\n+\n+  /**\n+   * Count the number of non-empty and non-null string nodes in the array node.\n+   */\n+  private int countFoldedArrayChildren(Node arrayNode, String joinString) {\n+    int arrayFoldedChildrenSize = 0;\n+    Node currentArrayNode = arrayNode.getFirstChild();\n+    boolean firstElement = true;\n+    while (currentArrayNode != null) {\n+      if (currentArrayNode.isEmpty()) {\n+        // We don't treat empty nodes, otherwise index sequence would be affected.\n+        // An element would be missing and the order of other elements would be wrong.\n+        return -1;\n+      } else if (firstElement) {\n+        // If the first element is not a string, check if we should\n+        // add toString().\n+        if (!NodeUtil.isStringNode(currentArrayNode)) {\n+          currentArrayNode = IR.call(\n+              IR.getprop(\n+                  IR.getprop(IR.name(\"Object\"), IR.string(\"prototype\")), IR.string(\"toString\")),\n+              currentArrayNode);\n         }\n-        arrayNode.detachChildren();\n-        for (Node node : arrayFoldedChildren) {\n-          arrayNode.addChildToBack(node);\n+        firstElement = false;\n+      } else if (!NodeUtil.isStringNode(currentArrayNode)) {\n+        return -1;\n+      } else if (joinString.isEmpty() && currentArrayNode.getString().isEmpty()) {\n+        // If the join string is empty, and the current string is\n+        // empty, we have to make sure that this does not affect the\n+        // sequence of indices displayed when console.logged.\n+        arrayFoldedChildrenSize++;\n+        currentArrayNode = currentArrayNode.getNext();\n+        continue;\n+      }\n+\n+      arrayFoldedChildrenSize++;\n+      currentArrayNode = currentArrayNode.getNext();\n+    }\n+    return arrayFoldedChildrenSize;\n+  }\n+\n+  /**\n+   * Utility method to retrieve folded node containing a single string resulting from folding the\n+   * array.\n+   *\n+   * <p>Strings are joined by a separator, so folded element might contain concatenation. A\n+   * concatenation is still allowed only if it is between at most one non-empty or null element and\n+   * a string that derives from a primitive value or the value null.\n+   */\n+  private Node getNodeFromFoldedChildren(Node arrayNode, String joinString) {\n+    Node firstChild = arrayNode.getFirstChild();\n+    StringBuilder sb = null;\n+    boolean firstElement = true;\n+\n+    while (firstChild != null) {\n+      Node currentStringNode;\n+      if (firstElement) {\n+        currentStringNode = firstChild.cloneTree();\n+        if (!NodeUtil.isStringNode(currentStringNode)) {\n+          String addToString = \".toString()\";\n+          currentStringNode = NodeUtil.isImmutableValue(currentStringNode)\n+              ? NodeUtil.newConstNode(currentStringNode)\n+              : IR.comma(IR.name(\"$_$\"), currentStringNode);\n+          currentStringNode = IR.add(IR.getelem(currentStringNode, IR.zero()), IR.string(\"\"));\n+          currentStringNode = NodeUtil.newExprStatementSilentScope(currentStringNode);\n+          return null;\n         }\n-        reportCodeChange();\n+        firstElement = false;\n+      } else {\n+        currentStringNode = firstChild.cloneTree();\n+        if (!NodeUtil.isStringNode(currentStringNode) || joinString.isEmpty()) {\n+          return null;\n+        }\n+      }\n+\n+      String currentString = currentStringNode.getString();\n+      if (!currentString.isEmpty() || (currentString.isEmpty() && joinString.isEmpty())) {\n+        if (sb == null) {\n+          sb = new StringBuilder(currentString);\n+        } else {\n+          sb.append(joinString).append(currentString);\n+        }\n+      }\n+      firstChild = firstChild.getNext();\n+    }\n+\n+    if (sb == null) {\n+      return IR.string(\"\");\n+    }\n+    return IR.string(sb.toString());\n+  }\n+\n+  /**\n+   * Returns true if we should inline the array join statement with length {@code size}.\n+   *\n+   * <p>Inlining is allowed only up to a certain size limit (currently {@link\n+   * CompilerOptions#getMaximumInliningSize}), unless the array join is a construction of a\n+   * window.Array object, joining an empty array or a join using an empty string.\n+   */\n+  private boolean shouldInlineArrayJoin(int size, Node arrayNode) {\n+    Preconditions.checkArgument(size > 1);\n+    if (size > compiler.getOptions().getMaximumInliningSize()) {\n+      return false;\n+    }\n+\n+    Node targetNode = arrayNode.getParent();\n+    while (targetNode != null) {\n+      if (targetNode.isNew()) {\n+        Node calleeNode = targetNode.getFirstFirstChild();\n+        if (calleeNode.isQualifiedName()) {\n+          String qName = calleeNode.getQualifiedName();\n+          if (qName != null && qName.equals(\"Array\")) {\n+            Node argNode = calleeNode.getNext();\n+            if (argNode == null) {\n+              return true;\n+            } else if (argNode.isEmpty()) {\n+              return Arrays.equals(CharMatcher.anyOf(\",\").matchesAllOf(size == 2 ? \"\" :\n+                  new String(new char[size - 2]).replace(\"\\0\", \",\")), \",\".repeat(size - 2));\n+            }\n+          }\n+        }\n+      }\n+      if (targetNode.isScript()) {\n         break;\n+      }\n+      targetNode = targetNode.getParent();\n+    }\n+    return true;\n+  }\n+\n+  /**\n+   * Given an array node, constructs a new node that is the sanitized array node.\n+   *\n+   * <p>Sanitized array node drops empty nodes and null values.\n+   *\n+   * <p>We also concatenate the first empty string or null with the second string if the join string\n+   * is empty. We do this because this sequence of indices is seen in console output.\n+   */\n+  private Node getFoldedArgumentNode(int size, Node arrayNode, String joinString) {\n+\n+    Node currentFoldedNode = arrayNode.getFirstChild();\n+    Node foldedArgument = IR.arraylit();\n+    for (var i = 0; i < size; i++) {\n+      if (currentFoldedNode == null || currentFoldedNode.isEmpty()) {\n+        // Skip null or empty values.\n+        foldedArgument.addChildToBack(IR.string(\"\"));\n+        foldedArgument.putBooleanProp(Node.CONSTANT_KEY, true);\n+        currentFoldedNode = currentFoldedNode.getNext();\n+      } else if (joinString.isEmpty()) {\n+        // Handles corner case where join string is an empty string but the array contains one or more\n+        // empty string in the middle. Console output displays special indices for this sequence.\n+        boolean isCurrentNodeString = NodeUtil.isStringNode(currentFoldedNode);\n+        Node rightNode = isCurrentNodeString ? currentFoldedNode.getNext() : currentFoldedNode;\n+        boolean isRightNodeString = NodeUtil.isStringNode(rightNode);\n+        if (!isCurrentNodeString || !isRightNodeString || rightNode.isEmpty()) {\n+          foldedArgument.addChildToBack(currentFoldedNode.cloneNode());\n+          currentFoldedNode = rightNode;\n+        } else {\n+          NodeList<Node> nodeList = currentFoldedNode.removeChildren();\n+          StringBuilder sb = new StringBuilder(nodeList.get(0).getString());\n+          sb.append(rightNode.getString());\n+          foldedArgument.addChildToBack(IR.string(sb.toString()));\n+          currentFoldedNode = rightNode.getNext();\n+        }\n+      } else {\n+        foldedArgument.addChildToBack(currentFoldedNode.cloneNode());\n+        currentFoldedNode = currentFoldedNode.getNext();\n+      }\n     }\n+    return foldedArgument;\n+  }\n \n-    return n;\n+  private boolean isWindowArray(Node callTarget) {\n+    Node target = NodeUtil.getBestLValuePrototype(callTarget);\n+    if (target != null && target.getFirstChild().matchesQualifiedName(\"Window.prototype\")) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Calculate folded array size.\n+   *\n+   * <p>The size of the folded array consists of size of the all folded elements plus size of separator\n+   * repeated number of elements minus one.\n+   */\n+  private int getFoldedArraySize(Node arrayNode, int arrayFoldedChildrenSize, String joinString) {\n+    boolean first = true;\n+    int length = 0;\n+    Node currentNode = arrayNode.getFirstChild();\n+    if (currentNode == null) {\n+      // The result will be the empty string, so the folded size is one (for the prolog at least).\n+      return 1;\n+    }\n+\n+    while (currentNode != null) {\n+      if (currentNode.getType() != Token.EMPTY && (first || joinString.isEmpty() ||\n+          NodeUtil.isStringNode(currentNode))) {\n+        if (first && !NodeUtil.isStringNode(currentNode)) {\n+          currentNode = NodeUtil.newCallNode(IR.getprop(IR.name(\"Object\"), IR.string(\"prototype\")),\n+              currentNode);\n+        }\n+        length += InlineCostEstimator.getCost(currentNode);\n+        first = false;\n+      }\n+      currentNode = currentNode.getNext();\n+      if (currentNode != null && currentNode.getType() != Token.EMPTY && !first) {\n+        length += joinString.length();\n+      }\n+    }\n+    length += (arrayFoldedChildrenSize > 1) ? joinString.length() * (arrayFoldedChildrenSize - 1) : 0;\n+    return length;\n   }\n \n   /**\n@@ -642,4 +836,4 @@ class PeepholeReplaceKnownMethods extends AbstractPeepholeOptimization{\n     reportCodeChange();\n     return resultNode;\n   }\n-}\n\\ No newline at end of file\n+}",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}