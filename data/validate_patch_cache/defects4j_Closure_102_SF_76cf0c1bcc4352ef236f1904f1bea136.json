{
    "patch": "class PropogateConstantAnnotations extends AbstractPostOrderCallback {\n\n  private final AbstractCompiler compiler;\n  private boolean assertOnChange;\n\n  PropogateConstantAnnotations(AbstractCompiler compiler, boolean assertOnChange) {\n    this.compiler = compiler;\n    this.assertOnChange = assertOnChange;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isName()) {\n      if (n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n        n.putBooleanProp(Node.IS_CONSTANT_VAR, true);\n      } else if (n.getBooleanProp(Node.IS_CONSTANT_VAR)) {\n        // Track changes to constant vars.\n        checkState(n.getBooleanProp(Node.CHANGED_VALUE_PROP));\n        if (assertOnChange && parent.isScript()) {\n          n.getParent().addChildAfter(\n              NodeUtil.newExpr(\n                  IR.call(\n                      IR.getprop(\n                          IR.name(\"console\"), IR.string(\"assert\")),\n                      IR.not(\n                          IR.name(n.getString())))),\n              n);\n        }\n      }\n    } else if (n.isFunction()) {\n      for (Node param : n.getSecondChild().children()) {\n        if (param.isName() && param.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          param.putBooleanProp(Node.IS_CONSTANT_VAR, true);\n        }\n      }\n    }\n  }\n\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, externs, this);\n    NodeTraversal.traverse(compiler, root, this);\n\n    // Remove variable declarations that have been marked as constants and not used.\n    NodeTraversal.traverse(compiler, root, new NodeTraversal.Callback() {\n      @Override\n      public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n        // Only traverse function and script nodes.\n        return node.isFunction() || node.isScript();\n      }\n\n      @Override\n      public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {\n        if (node.isVar()) {\n          Node name = node.getFirstChild();\n          if (name.getBooleanProp(Node.IS_CONSTANT_VAR) && name.getParent().hasOneChild()) {\n            name.detach();\n            compiler.reportChangeToEnclosingScope(name);\n          }\n        }\n      }\n    });\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Normalize.java b/src/com/google/javascript/jscomp/Normalize.java\nindex 4aa45558..d9db6c3c 100644\n--- a/src/com/google/javascript/jscomp/Normalize.java\n+++ b/src/com/google/javascript/jscomp/Normalize.java\n@@ -84,17 +84,69 @@ class Normalize implements CompilerPass, Callback {\n   }\n \n   @Override\n+class PropogateConstantAnnotations extends AbstractPostOrderCallback {\n+\n+  private final AbstractCompiler compiler;\n+  private boolean assertOnChange;\n+\n+  PropogateConstantAnnotations(AbstractCompiler compiler, boolean assertOnChange) {\n+    this.compiler = compiler;\n+    this.assertOnChange = assertOnChange;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (n.isName()) {\n+      if (n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n+        n.putBooleanProp(Node.IS_CONSTANT_VAR, true);\n+      } else if (n.getBooleanProp(Node.IS_CONSTANT_VAR)) {\n+        // Track changes to constant vars.\n+        checkState(n.getBooleanProp(Node.CHANGED_VALUE_PROP));\n+        if (assertOnChange && parent.isScript()) {\n+          n.getParent().addChildAfter(\n+              NodeUtil.newExpr(\n+                  IR.call(\n+                      IR.getprop(\n+                          IR.name(\"console\"), IR.string(\"assert\")),\n+                      IR.not(\n+                          IR.name(n.getString())))),\n+              n);\n+        }\n+      }\n+    } else if (n.isFunction()) {\n+      for (Node param : n.getSecondChild().children()) {\n+        if (param.isName() && param.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n+          param.putBooleanProp(Node.IS_CONSTANT_VAR, true);\n+        }\n+      }\n+    }\n+  }\n+\n   public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, externs, this);\n     NodeTraversal.traverse(compiler, root, this);\n-    if (MAKE_LOCAL_NAMES_UNIQUE) {\n-      MakeDeclaredNamesUnique renamer = new MakeDeclaredNamesUnique();\n-      NodeTraversal t = new NodeTraversal(compiler, renamer);\n-      t.traverseRoots(externs, root);\n-    }\n-    removeDuplicateDeclarations(root);\n-    new PropogateConstantAnnotations(compiler, assertOnChange)\n-        .process(externs, root);\n+\n+    // Remove variable declarations that have been marked as constants and not used.\n+    NodeTraversal.traverse(compiler, root, new NodeTraversal.Callback() {\n+      @Override\n+      public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n+        // Only traverse function and script nodes.\n+        return node.isFunction() || node.isScript();\n+      }\n+\n+      @Override\n+      public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {\n+        if (node.isVar()) {\n+          Node name = node.getFirstChild();\n+          if (name.getBooleanProp(Node.IS_CONSTANT_VAR) && name.getParent().hasOneChild()) {\n+            name.detach();\n+            compiler.reportChangeToEnclosingScope(name);\n+          }\n+        }\n+      }\n+    });\n   }\n+}\n \n   @Override\n   public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {",
    "result_reason": "error: class Normalize.PropogateConstantAnnotations is already defined in class Normalize",
    "test_result": "ERROR"
}