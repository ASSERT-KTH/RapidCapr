{
    "patch": "  private Node tryFoldSimpleFunctionCall(Node n) {\n    Preconditions.checkState(n.isCall());\n    Node callTarget = n.getFirstChild();\n\n    // Only fold calls to String\n    if (callTarget != null && callTarget.isName() &&\n        callTarget.getString().equals(\"String\")) {\n      boolean hasSideEffect = NodeUtil.mayHaveSideEffects(n.getLastChild());\n\n      // Fold String(a) to '' + (a) on immutable literals,\n      // which allows further optimizations\n      //\n      // We can't do this in the general case, because String(a) has\n      // slightly different semantics than '' + (a). See\n      // http://code.google.com/p/closure-compiler/issues/detail?id=759\n      Node value = callTarget.getNext();\n      if (value != null && !hasSideEffect) {\n        if (value.isString() && !value.hasChildren()) {\n          Node addition = IR.add(\n              IR.string(\"\").srcref(callTarget),\n              value.detachFromParent());\n          n.getParent().replaceChild(n, addition);\n          reportCodeChange();\n          return addition;\n        } else if (value.isComma()) {\n          Node left = value.getFirstChild();\n\n          // Check whether all comma separated arguments are also strings\n          boolean allStrings = true;\n          while (left != null) {\n            if (!left.isString() || left.hasChildren()) {\n              allStrings = false;\n              break;\n            }\n            left = left.getNext();\n          }\n\n          if (allStrings) {\n            // Simply join all strings together\n            StringBuilder sb = new StringBuilder(\"\\\"\");\n            left = value.getFirstChild();\n            while (left != null) {\n              sb.append(left.getString());\n              left = left.getNext();\n            }\n            sb.append(\"\\\"\");\n\n            Node newLiteral = IR.string(sb.toString()).srcref(value);\n            n.getParent().replaceChild(n, newLiteral);\n            reportCodeChange();\n            return newLiteral;\n          } else {\n            List<Node> nodes = new ArrayList<>();\n\n            // Extract first comma-separated expression\n            Node commaExpression = value;\n            while (commaExpression.getFirstChild().getToken().equals(Token.COMMA)) {\n              commaExpression = commaExpression.getFirstChild();\n            }\n            nodes.add(commaExpression.getFirstChild().detachFromParent());\n\n            // Add all following arguments\n            commaExpression = commaExpression.getNext();\n            while (commaExpression != null) {\n              nodes.add(commaExpression.getFirstChild().detachFromParent());\n\n              commaExpression = commaExpression.getNext();\n            }\n\n            // Build merged string\n            Node mergedString = nodes.remove(0);\n            for (Node node : nodes) {\n              mergedString =\n                  IR.add(IR.string(\"\").srcref(callTarget), mergedString, node).srcref(callTarget);\n            }\n\n            n.getParent().replaceChild(n, mergedString);\n            reportCodeChange();\n            return mergedString;\n          }\n        }\n      }\n    }\n    return n;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex bfa17074..f504a3c0 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -208,8 +208,12 @@ class PeepholeSubstituteAlternateSyntax\n   private Node tryFoldSimpleFunctionCall(Node n) {\n     Preconditions.checkState(n.isCall());\n     Node callTarget = n.getFirstChild();\n+\n+    // Only fold calls to String\n     if (callTarget != null && callTarget.isName() &&\n-          callTarget.getString().equals(\"String\")) {\n+        callTarget.getString().equals(\"String\")) {\n+      boolean hasSideEffect = NodeUtil.mayHaveSideEffects(n.getLastChild());\n+\n       // Fold String(a) to '' + (a) on immutable literals,\n       // which allows further optimizations\n       //\n@@ -217,13 +221,71 @@ class PeepholeSubstituteAlternateSyntax\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n-        Node addition = IR.add(\n-            IR.string(\"\").srcref(callTarget),\n-            value.detachFromParent());\n-        n.getParent().replaceChild(n, addition);\n-        reportCodeChange();\n-        return addition;\n+      if (value != null && !hasSideEffect) {\n+        if (value.isString() && !value.hasChildren()) {\n+          Node addition = IR.add(\n+              IR.string(\"\").srcref(callTarget),\n+              value.detachFromParent());\n+          n.getParent().replaceChild(n, addition);\n+          reportCodeChange();\n+          return addition;\n+        } else if (value.isComma()) {\n+          Node left = value.getFirstChild();\n+\n+          // Check whether all comma separated arguments are also strings\n+          boolean allStrings = true;\n+          while (left != null) {\n+            if (!left.isString() || left.hasChildren()) {\n+              allStrings = false;\n+              break;\n+            }\n+            left = left.getNext();\n+          }\n+\n+          if (allStrings) {\n+            // Simply join all strings together\n+            StringBuilder sb = new StringBuilder(\"\\\"\");\n+            left = value.getFirstChild();\n+            while (left != null) {\n+              sb.append(left.getString());\n+              left = left.getNext();\n+            }\n+            sb.append(\"\\\"\");\n+\n+            Node newLiteral = IR.string(sb.toString()).srcref(value);\n+            n.getParent().replaceChild(n, newLiteral);\n+            reportCodeChange();\n+            return newLiteral;\n+          } else {\n+            List<Node> nodes = new ArrayList<>();\n+\n+            // Extract first comma-separated expression\n+            Node commaExpression = value;\n+            while (commaExpression.getFirstChild().getToken().equals(Token.COMMA)) {\n+              commaExpression = commaExpression.getFirstChild();\n+            }\n+            nodes.add(commaExpression.getFirstChild().detachFromParent());\n+\n+            // Add all following arguments\n+            commaExpression = commaExpression.getNext();\n+            while (commaExpression != null) {\n+              nodes.add(commaExpression.getFirstChild().detachFromParent());\n+\n+              commaExpression = commaExpression.getNext();\n+            }\n+\n+            // Build merged string\n+            Node mergedString = nodes.remove(0);\n+            for (Node node : nodes) {\n+              mergedString =\n+                  IR.add(IR.string(\"\").srcref(callTarget), mergedString, node).srcref(callTarget);\n+            }\n+\n+            n.getParent().replaceChild(n, mergedString);\n+            reportCodeChange();\n+            return mergedString;\n+          }\n+        }\n       }\n     }\n     return n;",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}