{
    "patch": "import java.util.ArrayList;\nimport java.util.List;\nimport com.google.common.base.Preconditions;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.ast.Branch;\nimport com.google.javascript.rhino.ast.Statement;\n\n...\n\nvoid tryMinimizeExits(Node n, int exitType, String labelName) {\n  // Just an 'exit'.\n  if (matchingExitNode(n, exitType, labelName)) {\n    Node parent = n.getParent();\n    int index = parent.isSwitch() ? parent.getIndexOfCase(n) : parent.getIndexOfChild(n);\n    Node newStatement = IR.block().srcref(n);\n    parent.replaceChild(n, newStatement);\n    Node before = newStatement;\n    List<Statement> statementList = new ArrayList<Statement>();\n    while (before.getPrevious() != null) {\n      if (before instanceof Statement) {\n        statementList.add((Statement) before);\n      }\n      before = before.getPrevious();\n    }\n    before = null;\n    for (int i = statementList.size() - 1; i >= 0; i--) {\n      Statement statement = statementList.get(i);\n      Node newBlock = IR.block(statement).srcref(statement);\n      if (before == null) {\n        before = newBlock;\n      } else {\n        Node newIf = IR.ifNode(IR.not(before)).srcref(statement);\n        newIf.addChildToBack(newBlock);\n        before = newIf;\n      }\n    }\n    if (before == null) {\n      before = newStatement;\n    }\n    if (parent.isSwitch()) {\n      Node switchBlock = IR.block(before).srcref(n);\n      parent.replaceChild(newStatement, switchBlock);\n    } else {\n      Node newIf = IR.ifNode(IR.not(before)).srcref(n);\n      newIf.addChildToBack(newStatement.detach());\n      parent.addChildBefore(newIf, newStatement);\n    }\n    compiler.reportCodeChange();\n    return;\n  }\n\n  // Just an 'if'.\n  if (n.isIf()) {\n    Node ifBlock = n.getFirstChild().getNext();\n    tryMinimizeExits(ifBlock, exitType, labelName);\n    Node elseBlock = ifBlock.getNext();\n    if (elseBlock != null) {\n      tryMinimizeExits(elseBlock, exitType, labelName);\n    }\n    return;\n  }\n\n  // Just a 'try/catch/finally'.\n  if (n.isTry()) {\n    Node tryBlock = n.getFirstChild();\n    tryMinimizeExits(tryBlock, exitType, labelName);\n    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n      Preconditions.checkState(allCatchNodes.hasOneChild());\n      Node catchNode = allCatchNodes.getFirstChild();\n      Node catchCodeBlock = catchNode.getLastChild();\n      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n    }\n    /* Don't try to minimize the exits of finally blocks, as thi",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..86c5b19d 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -103,102 +103,80 @@ class MinimizeExitPoints\n    *   null otherwise.\n    * @nullable labelName non-null only for breaks within labels.\n    */\n-  void tryMinimizeExits(Node n, int exitType, String labelName) {\n+import java.util.ArrayList;\n+import java.util.List;\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.ast.Branch;\n+import com.google.javascript.rhino.ast.Statement;\n \n-    // Just an 'exit'.\n-    if (matchingExitNode(n, exitType, labelName)) {\n-      NodeUtil.removeChild(n.getParent(), n);\n-      compiler.reportCodeChange();\n-      return;\n-    }\n+...\n \n-    // Just an 'if'.\n-    if (n.isIf()) {\n-      Node ifBlock = n.getFirstChild().getNext();\n-      tryMinimizeExits(ifBlock, exitType, labelName);\n-      Node elseBlock = ifBlock.getNext();\n-      if (elseBlock != null) {\n-        tryMinimizeExits(elseBlock, exitType, labelName);\n+void tryMinimizeExits(Node n, int exitType, String labelName) {\n+  // Just an 'exit'.\n+  if (matchingExitNode(n, exitType, labelName)) {\n+    Node parent = n.getParent();\n+    int index = parent.isSwitch() ? parent.getIndexOfCase(n) : parent.getIndexOfChild(n);\n+    Node newStatement = IR.block().srcref(n);\n+    parent.replaceChild(n, newStatement);\n+    Node before = newStatement;\n+    List<Statement> statementList = new ArrayList<Statement>();\n+    while (before.getPrevious() != null) {\n+      if (before instanceof Statement) {\n+        statementList.add((Statement) before);\n       }\n-      return;\n+      before = before.getPrevious();\n     }\n-\n-    // Just a 'try/catch/finally'.\n-    if (n.isTry()) {\n-      Node tryBlock = n.getFirstChild();\n-      tryMinimizeExits(tryBlock, exitType, labelName);\n-      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-        Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n-      }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+    before = null;\n+    for (int i = statementList.size() - 1; i >= 0; i--) {\n+      Statement statement = statementList.get(i);\n+      Node newBlock = IR.block(statement).srcref(statement);\n+      if (before == null) {\n+        before = newBlock;\n+      } else {\n+        Node newIf = IR.ifNode(IR.not(before)).srcref(statement);\n+        newIf.addChildToBack(newBlock);\n+        before = newIf;\n       }\n     }\n-\n-    // Just a 'label'.\n-    if (n.isLabel()) {\n-      Node labelBlock = n.getLastChild();\n-      tryMinimizeExits(labelBlock, exitType, labelName);\n+    if (before == null) {\n+      before = newStatement;\n     }\n-\n-    // TODO(johnlenz): The last case of SWITCH statement?\n-\n-    // The rest assumes a block with at least one child, bail on anything else.\n-    if (!n.isBlock() || n.getLastChild() == null) {\n-      return;\n+    if (parent.isSwitch()) {\n+      Node switchBlock = IR.block(before).srcref(n);\n+      parent.replaceChild(newStatement, switchBlock);\n+    } else {\n+      Node newIf = IR.ifNode(IR.not(before)).srcref(n);\n+      newIf.addChildToBack(newStatement.detach());\n+      parent.addChildBefore(newIf, newStatement);\n     }\n+    compiler.reportCodeChange();\n+    return;\n+  }\n \n-    // Multiple if-exits can be converted in a single pass.\n-    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-\n-      // An 'if' block to process below.\n-      if (c.isIf()) {\n-        Node ifTree = c;\n-        Node trueBlock, falseBlock;\n-\n-        // First, the true condition block.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n-\n-        // Now the else block.\n-        // The if blocks may have changed, get them again.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n-        }\n-      }\n-\n-      if (c == n.getLastChild()) {\n-        break;\n-      }\n+  // Just an 'if'.\n+  if (n.isIf()) {\n+    Node ifBlock = n.getFirstChild().getNext();\n+    tryMinimizeExits(ifBlock, exitType, labelName);\n+    Node elseBlock = ifBlock.getNext();\n+    if (elseBlock != null) {\n+      tryMinimizeExits(elseBlock, exitType, labelName);\n     }\n+    return;\n+  }\n \n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n-        break;\n-      }\n+  // Just a 'try/catch/finally'.\n+  if (n.isTry()) {\n+    Node tryBlock = n.getFirstChild();\n+    tryMinimizeExits(tryBlock, exitType, labelName);\n+    Node allCatchNodes = NodeUtil.getCatchBlock(n);\n+    if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n+      Preconditions.checkState(allCatchNodes.hasOneChild());\n+      Node catchNode = allCatchNodes.getFirstChild();\n+      Node catchCodeBlock = catchNode.getLastChild();\n+      tryMinimizeExits(catchCodeBlock, exitType, labelName);\n     }\n-  }\n+    /* Don't try to minimize the exits of finally blocks, as thi\n \n   /**\n    * Look for exits (returns, breaks, or continues, depending on the context) at",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}