{
    "patch": "public static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n  switch (n.getType()) {\n      // Excludes GETPROPs and GETELEMs as they are not simple assigns.\n    case Token.NAME:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return isLhs(n, parent);\n    case Token.GETPROP:\n      if (!isLhs(n, parent)) {\n        return false;\n      }\n      Node currNode = n;\n      while (true) {\n        if (currNode.getFirstChild().getType() != Token.GETPROP) {\n          return isLhs(currNode.getFirstChild(), currNode);\n        }\n        currNode = currNode.getFirstChild();\n      }\n    case Token.GETELEM:\n      if (!isLhs(n, parent)) {\n        return false;\n      }\n      currNode = n;\n      while (true) {\n        if (currNode.getFirstChild().getType() != Token.GETELEM) {\n          return isLhs(currNode.getFirstChild(), currNode)\n              && isLhs(currNode.getLastChild(), currNode);\n        }\n        currNode = currNode.getFirstChild();\n      }\n    case Token.ASSIGN:\n      return isLhs(n.getFirstChild(), n);\n    case Token.DESTRUCTURING_LHS:\n      return !containsUnsupportedDestructuring(n);\n    case Token.DEFAULT_VALUE:\n      return isVarOrSimpleAssignLhs(n.getFirstChild(), parent);\n    default:\n      return false;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\nindex 30b19e0b..235affc3 100644\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n@@ -310,28 +310,46 @@ class AnalyzePrototypeProperties implements CompilerPass {\n            n.getType() == Token.FUNCTION &&\n            n.getParent().getType() == Token.NAME);\n     }\n-\n-    private boolean isPrototypePropertyAssign(Node assign) {\n-      Node n = assign.getFirstChild();\n-      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n-          && n.getType() == Token.GETPROP\n-          ) {\n-        // We want to exclude the assignment itself from the usage list\n-        boolean isChainedProperty =\n-            n.getFirstChild().getType() == Token.GETPROP;\n-\n-        if (isChainedProperty) {\n-          Node child = n.getFirstChild().getFirstChild().getNext();\n-\n-          if (child.getType() == Token.STRING &&\n-              child.getString().equals(\"prototype\")) {\n-            return true;\n-          }\n+public static boolean isVarOrSimpleAssignLhs(Node n, Node parent) {\n+  switch (n.getType()) {\n+      // Excludes GETPROPs and GETELEMs as they are not simple assigns.\n+    case Token.NAME:\n+    case Token.ARRAYLIT:\n+    case Token.OBJECTLIT:\n+      return isLhs(n, parent);\n+    case Token.GETPROP:\n+      if (!isLhs(n, parent)) {\n+        return false;\n+      }\n+      Node currNode = n;\n+      while (true) {\n+        if (currNode.getFirstChild().getType() != Token.GETPROP) {\n+          return isLhs(currNode.getFirstChild(), currNode);\n         }\n+        currNode = currNode.getFirstChild();\n       }\n-\n+    case Token.GETELEM:\n+      if (!isLhs(n, parent)) {\n+        return false;\n+      }\n+      currNode = n;\n+      while (true) {\n+        if (currNode.getFirstChild().getType() != Token.GETELEM) {\n+          return isLhs(currNode.getFirstChild(), currNode)\n+              && isLhs(currNode.getLastChild(), currNode);\n+        }\n+        currNode = currNode.getFirstChild();\n+      }\n+    case Token.ASSIGN:\n+      return isLhs(n.getFirstChild(), n);\n+    case Token.DESTRUCTURING_LHS:\n+      return !containsUnsupportedDestructuring(n);\n+    case Token.DEFAULT_VALUE:\n+      return isVarOrSimpleAssignLhs(n.getFirstChild(), parent);\n+    default:\n       return false;\n-    }\n+  }\n+}\n \n     /**\n      * Processes a NAME node to see if it's a global function declaration.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}