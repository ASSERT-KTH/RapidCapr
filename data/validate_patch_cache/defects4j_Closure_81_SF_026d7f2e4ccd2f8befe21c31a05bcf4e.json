{
    "patch": "public class IRFactory {\n\n  // Existing code...\n\n  private final class TransformDispatcher implements TypeSafeDispatcher<Node> {\n\n    public Node dispatch(AstNode node) {\n      return null;\n    }\n\n    public Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n\n    public Node processBreakStatement(BreakStatement statementNode) {\n      Node node = newNode(Token.BREAK);\n      if (statementNode.getBreakLabel() != null) {\n        Node labelName = transform(statementNode.getBreakLabel());\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    public Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            \"Catch clauses are not supported\",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    public Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n          Token.HOOK,\n          transform(exprNode.getTestExpression()),\n          transform(exprNode.getTrueExpression()),\n          transform(exprNode.getFalseExpression()));\n    }\n\n    public Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = transform(statementNode.getLabel());\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    public Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n          Token.DO,\n          transformBlock(loopNode.getBody()),\n          transform(loopNode.getCondition()));\n    }\n\n    public Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }\n\n    public Node processEmptyExpression(EmptyExpression exprNode) {\n      Node node = newNode(Token.EMPTY);\n      return node;\n    }\n\n    public Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n\n    public Node processForInLoop(ForInLoop loopNode) {\n      return newNode(\n          Token.FOR,\n          transform(loopNode.getIterator()),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    public Node processForLoop(ForLoop loopNode) {\n      Node node = newNode(\n          Token.FOR,\n          transform(loopNode.getInitializer()),\n          transform(loopNode.getCondition()),\n          transform(loopNode.getIncrement()));\n      node.addChildToBack(transformBlock(loopNode.getBody()));\n      return node;\n    }\n\n    public Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(transformTokenType(callNode.getType()),\n                           transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n      node.setLineno(callNode.getLineno());\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }\n\n    public Node processFunctionNode(FunctionNode functionNode) {\n      Node node = newNode(Token.FUNCTION);\n\n      Node newName;\n      if (functionNode.getFunctionName() == null) {\n        newName = newNode(Token.NAME);\n        newName.setString(\"\");\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      } else {\n        newName = transform(functionNode.getFunctionName());\n      }\n\n      node.addChildToBack(newName);\n\n      Node lp = newNode(Token.LP);\n      lp.setLineno(newName.getLineno());\n      int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n      lp.setCharno(position2charno(lparenCharno));\n\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n\n      node.addChildToBack(lp);\n      node.addChildToBack(transform(functionNode.getBody()));\n\n      return node;\n    }\n\n    public Node processIfStatement(IfStatement statementNode) {\n      return newNode(\n          Token.IF,\n          transform(statementNode.getCondition()),\n          transformBlock(statementNode.getThenPart()),\n          statementNode.getElsePart() != null ?\n              transformBlock(statementNode.getElsePart()) :\n              null);\n    }\n\n    public Node processInfixExpression(InfixExpression infixNode) {\n      return newNode(\n          transformTokenType(infixNode.getType()),\n          transform(infixNode.getLeft()),\n          transform(infixNode.getRight()));\n    }\n\n    public Node processLabeledStatement(LabeledStatement statementNode) {\n      Node node = newNode(Token.LABEL, transform(statementNode.getStatement()));\n      node.addChildToBack(transform(statementNode.getLabel()));\n      return node;\n    }\n\n    public Node processLetNode(LetNode letNode) {\n      throw new UnsupportedOperationException(\"let/const not supported\");\n    }\n\n    public Node processName(Name nameNode) {\n      return processGeneric(nameNode);\n    }\n\n    public Node processNewExpression(NewExpression callNode) {\n      Node node = newNode(Token.NEW, transform(callNode.getTarget()));\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n      return node;\n    }\n\n    public Node processNumber(NumberLiteral numberNode) {\n      return newNode(Token.NUMBER, numberNode.getValue());\n    }\n\n    public Node processObjectLiteral(ObjectLiteral literalNode) {\n      Node node = newNode(Token.OBJECTLIT);\n\n      List<ObjectProperty> props = literalNode.getElements();\n      for (int i = 0, len = props.size(); i < len; i++) {\n        ObjectProperty prop = props.get(i);\n        node.addChildToBack(transform(prop));\n      }\n\n      return node;\n    }\n\n    public Node processObjectProperty(ObjectProperty propNode) {\n      Node node = newNode(Token.OBJECT_PROP_DEF, transform(propNode.getLeft()));\n      node.addChildToBack(transform(propNode.getRight()));\n      return node;\n    }\n\n    public Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n      Node node = transform(exprNode.getExpression());\n      // Match indentation with transformed inner expression.\n      if (node.getFirstChild() == null) {\n        node.addChildToFront(new Node(Token.EMPTY));\n      }\n      node.setIsParenthesized(true);\n      return node;\n    }\n\n    public Node processPropertyGet(PropertyGet getPropNode) {\n      return newNode(\n          Token.GETPROP,\n          transform(getPropNode.getTarget()),\n          newNode(Token.STRING, getPropNode.getProperty()));\n    }\n\n    public Node processRegExpLiteral(RegExpLiteral regexpNode) {\n      StringBuilder flags = new StringBuilder();\n      if (regexpNode.getFlags() != null) {\n        flags.append(regexpNode.getFlags());\n      }\n      // If regexpNode.getValue() is null, then regexpNode may have invalid syntax, according to\n      // rhino documentation.\n      return newNode(Token.REGEXP, regexpNode.getValue() != null ? regexpNode.getValue() : \"\",\n          flags.toString());\n    }\n\n    public Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = newNode(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      }\n      return node;\n    }\n\n    public Node processString(StringLiteral stringNode) {\n      return newNode(Token.STRING, stringNode.getValue());\n    }\n\n    public Node processSwitchCase(SwitchCase caseNode) {\n      if (caseNode.getType() == Token.DEFAULT) {\n        return newNode(Token.DEFAULT, transformAll(caseNode.getStatements()));\n      } else {\n        return newNode(Token.CASE, transform(caseNode.getExpression()),\n                        transformAll(caseNode.getStatements()));\n      }\n    }\n\n    public Node processSwitchStatement(SwitchStatement statementNode) {\n      Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n\n      for (SwitchCase caseNode : statementNode.getCases()) {\n        node.addChildToBack(transform(caseNode));\n      }\n\n      return node;\n    }\n\n    public Node processThrowStatement(ThrowStatement statementNode) {\n      return newNode(Token.THROW, transform(statementNode.getExpression()));\n    }\n\n    public Node processTryStatement(TryStatement statementNode) {\n      Node node = newNode(Token.TRY);\n      node.addChildToBack(transformBlock(statementNode.getTryBlock()));\n\n      if (statementNode.getCatchClause() != null) {\n        node.addChildToBack(transform(statementNode.getCatchClause()));\n      }\n\n      if (statementNode.getFinallyBlock() != null) {\n        node.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n      }\n\n      return node;\n    }\n\n    public Node processUnaryExpression(UnaryExpression unaryNode) {\n      if (unaryNode.getType() == Token.DELPROP) {\n        Node obj = transform(unaryNode.getOperand());\n        if (obj.getType() == Token.OBJECTLIT) {\n          // Remove the property from the object literal.\n          for (Node keyNode = obj.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n            if (keyNode.getLastChild().getString().equals(unaryNode.getOperand().getString())) {\n              obj.removeChild(keyNode);\n              break;\n            }\n          }\n          return obj;\n        } else {\n          // Just delete the symbol.\n          return newNode(Token.DELPROP, obj);\n        }\n      } else {\n        return newNode(transformTokenType(unaryNode.getType()), transform(unaryNode.getOperand()));\n      }\n    }\n\n    public Node processVariableDeclaration(VariableDeclaration declNode) {\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer init : declNode.getVariables()) {\n        Node child = transform(init);\n        if (init.getTarget() instanceof DestructuringForm) {\n          try {\n            node.addChildrenToFront(Destruc",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..99af82ee 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -384,35 +384,31 @@ public class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+public class IRFactory {\n+\n+  // Existing code...\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+  private final class TransformDispatcher implements TypeSafeDispatcher<Node> {\n \n-      int nType = n.getType();\n-      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n-          n.getFirstChild().getType() == Token.STRING &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    public Node dispatch(AstNode node) {\n+      return null;\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n+    public Node processBlock(Block blockNode) {\n       return processGeneric(blockNode);\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n+    public Node processBreakStatement(BreakStatement statementNode) {\n       Node node = newNode(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n         Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n         labelName.setType(Token.LABEL_NAME);\n         node.addChildToBack(labelName);\n       }\n       return node;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n+    public Node processCatchClause(CatchClause clauseNode) {\n       AstNode catchVar = clauseNode.getVarName();\n       Node node = newNode(Token.CATCH, transform(catchVar));\n       if (clauseNode.getCatchCondition() != null) {\n@@ -425,8 +421,7 @@ public class IRFactory {\n       return node;\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+    public Node processConditionalExpression(ConditionalExpression exprNode) {\n       return newNode(\n           Token.HOOK,\n           transform(exprNode.getTestExpression()),\n@@ -434,49 +429,42 @@ public class IRFactory {\n           transform(exprNode.getFalseExpression()));\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n+    public Node processContinueStatement(ContinueStatement statementNode) {\n       Node node = newNode(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n         Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n         labelName.setType(Token.LABEL_NAME);\n         node.addChildToBack(labelName);\n       }\n       return node;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n+    public Node processDoLoop(DoLoop loopNode) {\n       return newNode(\n           Token.DO,\n           transformBlock(loopNode.getBody()),\n           transform(loopNode.getCondition()));\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n+    public Node processElementGet(ElementGet getNode) {\n       return newNode(\n           Token.GETELEM,\n           transform(getNode.getTarget()),\n           transform(getNode.getElement()));\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n+    public Node processEmptyExpression(EmptyExpression exprNode) {\n       Node node = newNode(Token.EMPTY);\n       return node;\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n+    public Node processExpressionStatement(ExpressionStatement statementNode) {\n       Node node = newNode(transformTokenType(statementNode.getType()));\n       node.addChildToBack(transform(statementNode.getExpression()));\n       return node;\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node processForInLoop(ForInLoop loopNode) {\n       return newNode(\n           Token.FOR,\n           transform(loopNode.getIterator()),\n@@ -484,8 +472,7 @@ public class IRFactory {\n           transformBlock(loopNode.getBody()));\n     }\n \n-    @Override\n-    Node processForLoop(ForLoop loopNode) {\n+    public Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(\n           Token.FOR,\n           transform(loopNode.getInitializer()),\n@@ -495,8 +482,7 @@ public class IRFactory {\n       return node;\n     }\n \n-    @Override\n-    Node processFunctionCall(FunctionCall callNode) {\n+    public Node processFunctionCall(FunctionCall callNode) {\n       Node node = newNode(transformTokenType(callNode.getType()),\n                            transform(callNode.getTarget()));\n       for (AstNode child : callNode.getArguments()) {\n@@ -509,58 +495,205 @@ public class IRFactory {\n       return node;\n     }\n \n-    @Override\n-    Node processFunctionNode(FunctionNode functionNode) {\n-      Name name = functionNode.getFunctionName();\n-      Boolean isUnnamedFunction = false;\n-      if (name == null) {\n-        name = new Name();\n-        name.setIdentifier(\"\");\n-        isUnnamedFunction = true;\n-      }\n+    public Node processFunctionNode(FunctionNode functionNode) {\n       Node node = newNode(Token.FUNCTION);\n-      Node newName = transform(name);\n-      if (isUnnamedFunction) {\n-        // Old Rhino tagged the empty name node with the line number of the\n-        // declaration.\n+\n+      Node newName;\n+      if (functionNode.getFunctionName() == null) {\n+        newName = newNode(Token.NAME);\n+        newName.setString(\"\");\n         newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() +\n-            functionNode.getLp();\n+        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n         newName.setCharno(position2charno(lpColumn));\n+      } else {\n+        newName = transform(functionNode.getFunctionName());\n       }\n \n       node.addChildToBack(newName);\n-      Node lp = newNode(Token.LP);\n-      // The left paren's complicated because it's not represented by an\n-      // AstNode, so there's nothing that has the actual line number that it\n-      // appeared on.  We know the paren has to appear on the same line as the\n-      // function name (or else a semicolon will be inserted.)  If there's no\n-      // function name, assume the paren was on the same line as the function.\n-      // TODO(bowdidge): Mark line number of paren correctly.\n-      Name fnName = functionNode.getFunctionName();\n-      if (fnName != null) {\n-        lp.setLineno(fnName.getLineno());\n-      } else {\n-        lp.setLineno(functionNode.getLineno());\n-      }\n-      int lparenCharno = functionNode.getLp() +\n-          functionNode.getAbsolutePosition();\n \n+      Node lp = newNode(Token.LP);\n+      lp.setLineno(newName.getLineno());\n+      int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n       lp.setCharno(position2charno(lparenCharno));\n+\n       for (AstNode param : functionNode.getParams()) {\n         lp.addChildToBack(transform(param));\n       }\n+\n       node.addChildToBack(lp);\n+      node.addChildToBack(transform(functionNode.getBody()));\n+\n+      return node;\n+    }\n+\n+    public Node processIfStatement(IfStatement statementNode) {\n+      return newNode(\n+          Token.IF,\n+          transform(statementNode.getCondition()),\n+          transformBlock(statementNode.getThenPart()),\n+          statementNode.getElsePart() != null ?\n+              transformBlock(statementNode.getElsePart()) :\n+              null);\n+    }\n+\n+    public Node processInfixExpression(InfixExpression infixNode) {\n+      return newNode(\n+          transformTokenType(infixNode.getType()),\n+          transform(infixNode.getLeft()),\n+          transform(infixNode.getRight()));\n+    }\n+\n+    public Node processLabeledStatement(LabeledStatement statementNode) {\n+      Node node = newNode(Token.LABEL, transform(statementNode.getStatement()));\n+      node.addChildToBack(transform(statementNode.getLabel()));\n+      return node;\n+    }\n+\n+    public Node processLetNode(LetNode letNode) {\n+      throw new UnsupportedOperationException(\"let/const not supported\");\n+    }\n+\n+    public Node processName(Name nameNode) {\n+      return processGeneric(nameNode);\n+    }\n+\n+    public Node processNewExpression(NewExpression callNode) {\n+      Node node = newNode(Token.NEW, transform(callNode.getTarget()));\n+      for (AstNode child : callNode.getArguments()) {\n+        node.addChildToBack(transform(child));\n+      }\n+      return node;\n+    }\n+\n+    public Node processNumber(NumberLiteral numberNode) {\n+      return newNode(Token.NUMBER, numberNode.getValue());\n+    }\n+\n+    public Node processObjectLiteral(ObjectLiteral literalNode) {\n+      Node node = newNode(Token.OBJECTLIT);\n+\n+      List<ObjectProperty> props = literalNode.getElements();\n+      for (int i = 0, len = props.size(); i < len; i++) {\n+        ObjectProperty prop = props.get(i);\n+        node.addChildToBack(transform(prop));\n+      }\n+\n+      return node;\n+    }\n+\n+    public Node processObjectProperty(ObjectProperty propNode) {\n+      Node node = newNode(Token.OBJECT_PROP_DEF, transform(propNode.getLeft()));\n+      node.addChildToBack(transform(propNode.getRight()));\n+      return node;\n+    }\n+\n+    public Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n+      Node node = transform(exprNode.getExpression());\n+      // Match indentation with transformed inner expression.\n+      if (node.getFirstChild() == null) {\n+        node.addChildToFront(new Node(Token.EMPTY));\n+      }\n+      node.setIsParenthesized(true);\n+      return node;\n+    }\n \n-      Node bodyNode = transform(functionNode.getBody());\n-      parseDirectives(bodyNode);\n-      node.addChildToBack(bodyNode);\n-     return node;\n+    public Node processPropertyGet(PropertyGet getPropNode) {\n+      return newNode(\n+          Token.GETPROP,\n+          transform(getPropNode.getTarget()),\n+          newNode(Token.STRING, getPropNode.getProperty()));\n     }\n \n+    public Node processRegExpLiteral(RegExpLiteral regexpNode) {\n+      StringBuilder flags = new StringBuilder();\n+      if (regexpNode.getFlags() != null) {\n+        flags.append(regexpNode.getFlags());\n+      }\n+      // If regexpNode.getValue() is null, then regexpNode may have invalid syntax, according to\n+      // rhino documentation.\n+      return newNode(Token.REGEXP, regexpNode.getValue() != null ? regexpNode.getValue() : \"\",\n+          flags.toString());\n+    }\n+\n+    public Node processReturnStatement(ReturnStatement statementNode) {\n+      Node node = newNode(Token.RETURN);\n+      if (statementNode.getReturnValue() != null) {\n+        node.addChildToBack(transform(statementNode.getReturnValue()));\n+      }\n+      return node;\n+    }\n+\n+    public Node processString(StringLiteral stringNode) {\n+      return newNode(Token.STRING, stringNode.getValue());\n+    }\n+\n+    public Node processSwitchCase(SwitchCase caseNode) {\n+      if (caseNode.getType() == Token.DEFAULT) {\n+        return newNode(Token.DEFAULT, transformAll(caseNode.getStatements()));\n+      } else {\n+        return newNode(Token.CASE, transform(caseNode.getExpression()),\n+                        transformAll(caseNode.getStatements()));\n+      }\n+    }\n+\n+    public Node processSwitchStatement(SwitchStatement statementNode) {\n+      Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+\n+      for (SwitchCase caseNode : statementNode.getCases()) {\n+        node.addChildToBack(transform(caseNode));\n+      }\n+\n+      return node;\n+    }\n+\n+    public Node processThrowStatement(ThrowStatement statementNode) {\n+      return newNode(Token.THROW, transform(statementNode.getExpression()));\n+    }\n+\n+    public Node processTryStatement(TryStatement statementNode) {\n+      Node node = newNode(Token.TRY);\n+      node.addChildToBack(transformBlock(statementNode.getTryBlock()));\n+\n+      if (statementNode.getCatchClause() != null) {\n+        node.addChildToBack(transform(statementNode.getCatchClause()));\n+      }\n+\n+      if (statementNode.getFinallyBlock() != null) {\n+        node.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n+      }\n+\n+      return node;\n+    }\n+\n+    public Node processUnaryExpression(UnaryExpression unaryNode) {\n+      if (unaryNode.getType() == Token.DELPROP) {\n+        Node obj = transform(unaryNode.getOperand());\n+        if (obj.getType() == Token.OBJECTLIT) {\n+          // Remove the property from the object literal.\n+          for (Node keyNode = obj.getFirstChild(); keyNode != null; keyNode = keyNode.getNext()) {\n+            if (keyNode.getLastChild().getString().equals(unaryNode.getOperand().getString())) {\n+              obj.removeChild(keyNode);\n+              break;\n+            }\n+          }\n+          return obj;\n+        } else {\n+          // Just delete the symbol.\n+          return newNode(Token.DELPROP, obj);\n+        }\n+      } else {\n+        return newNode(transformTokenType(unaryNode.getType()), transform(unaryNode.getOperand()));\n+      }\n+    }\n+\n+    public Node processVariableDeclaration(VariableDeclaration declNode) {\n+      Node node = newNode(Token.VAR);\n+      for (VariableInitializer init : declNode.getVariables()) {\n+        Node child = transform(init);\n+        if (init.getTarget() instanceof DestructuringForm) {\n+          try {\n+            node.addChildrenToFront(Destruc\n+\n     @Override\n     Node processIfStatement(IfStatement statementNode) {\n       Node node = newNode(Token.IF);",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}