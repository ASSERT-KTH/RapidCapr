{
    "patch": "  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  /**\n   * Defines a property if the property has not been defined yet.\n   */\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor = NodeUtil.isThis(obj) &&\n        getJSType(syntacticScope.getRootNode()).isConstructor();\n\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else if (nodeType.isStruct()) {\n      // In general, we don't want to define a property on a struct object,\n      // b/c TypeCheck will later check for improper property creation on\n      // structs. However, there are two exceptions: 1) If it's a prototype\n      // property, defined inside the constructor or anywhere globally where\n      // the constructor is defined. 2) If it's an object literal, that is\n      // one-time-use, and therefore more narrow than the declared property\n      // type. The one-time anonymous object on the right side is as narrow\n      // as it can possibly be, but we need to make sure we back-infer the\n      // <string> element constraint on the left hand side. The code below\n      // applies this constraint.\n      boolean staticPropCreation = false;\n      boolean isPropertyDefined = false;\n      Node owner = objectType.getOwnerFunction();\n      if (syntacticScope.isGlobal() &&\n          NodeUtil.isPrototypePropertyDeclaration(getprop.getParent().getParent())) {\n        // Case (1): Property is created inside the constructor.\n        String propCreationFilename = getprop.getParent().getParent().getSourceFileName();\n        if (owner != null && owner.getSourceFileName().equals(propCreationFilename)) {\n          staticPropCreation = true;\n        }\n      } else {\n        isPropertyDefined = objectType.hasProperty(propName);\n      }\n      if ((isPropertyDefined && !staticPropCreation) ||\n          (propCreationInConstructor && !isPropertyDefined && NodeUtil.isPrototypeProperty(getprop))) {\n        // Avoid defining the same property twice.\n        return;\n      }\n      if (!objectType.hasProperty(propName)) {\n        // Infer the prop based on the right-hand expression's type, unless the\n        // left-hand side restricts it, in which case use the restricted type.\n        JSType typeOnRight =\n            !getprop.isFromExterns() && rightType != null ? rightType : unknownType;\n        ObjectType inferredObjType =\n            registry.createAnonymousObjectWithBrand(propName, objectType.getBrand());\n        inferredObjType.defineDeclaredProperty(propName, typeOnRight, getprop);\n        objectType.defineInferredProperty(propName, inferredObjType, getprop);\n      }\n      JSType leftType = getJSType(getprop.getFirstChild());\n\n      // Flow scope needs to be cleared since the expression might contain \"unknown\"\n      // or \"undefined\".\n      FlowScope.flushCache();\n      if (leftType != null && nodeType.isObject()) {\n        if (!leftType.isTop()) {\n          // We have a left type to restrict the property.\n          objectType.defineInferredProperty(propName, leftType.restrictByNotNullOrUndefined(),\n              getprop);\n        }\n        // Propagate types from the inferred property to the flow-insensitive\n        // property.\n        JSType inferredPropertyType = objectType.getPropertyType(propName);\n        if (inferredPropertyType != null && leftType.isObject()) {\n          QualifiedName qname = new QualifiedName(getprop.getQualifiedName().split(\"\\\\.\"));\n          ObjectType restrictedRightType =\n              inferredPropertyType.restrictByNotNullOrUndefined().toObjectType();\n          ObjectType rhsRoot = objectType;\n          if (qname != null) {\n            rhsRoot = qname.getRootType(rhsRoot, objectType);\n          }\n          ObjectType rhs = ObjectType.cast(rhsRoot.getSlot(qname));\n          if (rhs != null && !rhs.isEquivalentTo(restrictedRightType)) {\n            rhs.extendStructuralType(\n                restrictedRightType, getprop.getSourceFileName(), getprop.getLineno());\n          }\n        }\n      }\n    } else if (!objectType.hasProperty(propName) || nodeType.isTop()) {\n      // Infer the prop based on the right-hand expression's type\n      // when the object type is not a struct or literal.\n      JSType typeOnRight =\n          !getprop.isFromExterns() && rightType != null ? rightType : unknownType;\n      objectType.defineDeclaredProperty(propName, typeOnRight, getprop);\n    } else {\n      // Make the property at least declared.\n      maybeDeclareLegacyNamespace(objectType, getprop);\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..c1bd3b86 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,67 +521,14 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n-\n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n-\n-\n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n-\n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n-        }\n-        break;\n-      case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n-        }\n-\n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n-        break;\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n+      }\n     }\n+    return false;\n   }\n \n   /**\n@@ -593,37 +540,90 @@ class TypeInference\n     JSType nodeType = getJSType(obj);\n     ObjectType objectType = ObjectType.cast(\n         nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n+    boolean propCreationInConstructor = NodeUtil.isThis(obj) &&\n         getJSType(syntacticScope.getRootNode()).isConstructor();\n \n     if (objectType == null) {\n       registry.registerPropertyOnType(propName, nodeType);\n-    } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n-        boolean staticPropCreation = false;\n-        Node maybeAssignStm = getprop.getParent().getParent();\n-        if (syntacticScope.isGlobal() &&\n-            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n-          String propCreationFilename = maybeAssignStm.getSourceFileName();\n-          Node ctor = objectType.getOwnerFunction().getSource();\n-          if (ctor != null &&\n-              ctor.getSourceFileName().equals(propCreationFilename)) {\n-            staticPropCreation = true;\n-          }\n+    } else if (nodeType.isStruct()) {\n+      // In general, we don't want to define a property on a struct object,\n+      // b/c TypeCheck will later check for improper property creation on\n+      // structs. However, there are two exceptions: 1) If it's a prototype\n+      // property, defined inside the constructor or anywhere globally where\n+      // the constructor is defined. 2) If it's an object literal, that is\n+      // one-time-use, and therefore more narrow than the declared property\n+      // type. The one-time anonymous object on the right side is as narrow\n+      // as it can possibly be, but we need to make sure we back-infer the\n+      // <string> element constraint on the left hand side. The code below\n+      // applies this constraint.\n+      boolean staticPropCreation = false;\n+      boolean isPropertyDefined = false;\n+      Node owner = objectType.getOwnerFunction();\n+      if (syntacticScope.isGlobal() &&\n+          NodeUtil.isPrototypePropertyDeclaration(getprop.getParent().getParent())) {\n+        // Case (1): Property is created inside the constructor.\n+        String propCreationFilename = getprop.getParent().getParent().getSourceFileName();\n+        if (owner != null && owner.getSourceFileName().equals(propCreationFilename)) {\n+          staticPropCreation = true;\n         }\n-        if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n+      } else {\n+        isPropertyDefined = objectType.hasProperty(propName);\n+      }\n+      if ((isPropertyDefined && !staticPropCreation) ||\n+          (propCreationInConstructor && !isPropertyDefined && NodeUtil.isPrototypeProperty(getprop))) {\n+        // Avoid defining the same property twice.\n+        return;\n+      }\n+      if (!objectType.hasProperty(propName)) {\n+        // Infer the prop based on the right-hand expression's type, unless the\n+        // left-hand side restricts it, in which case use the restricted type.\n+        JSType typeOnRight =\n+            !getprop.isFromExterns() && rightType != null ? rightType : unknownType;\n+        ObjectType inferredObjType =\n+            registry.createAnonymousObjectWithBrand(propName, objectType.getBrand());\n+        inferredObjType.defineDeclaredProperty(propName, typeOnRight, getprop);\n+        objectType.defineInferredProperty(propName, inferredObjType, getprop);\n+      }\n+      JSType leftType = getJSType(getprop.getFirstChild());\n+\n+      // Flow scope needs to be cleared since the expression might contain \"unknown\"\n+      // or \"undefined\".\n+      FlowScope.flushCache();\n+      if (leftType != null && nodeType.isObject()) {\n+        if (!leftType.isTop()) {\n+          // We have a left type to restrict the property.\n+          objectType.defineInferredProperty(propName, leftType.restrictByNotNullOrUndefined(),\n+              getprop);\n+        }\n+        // Propagate types from the inferred property to the flow-insensitive\n+        // property.\n+        JSType inferredPropertyType = objectType.getPropertyType(propName);\n+        if (inferredPropertyType != null && leftType.isObject()) {\n+          QualifiedName qname = new QualifiedName(getprop.getQualifiedName().split(\"\\\\.\"));\n+          ObjectType restrictedRightType =\n+              inferredPropertyType.restrictByNotNullOrUndefined().toObjectType();\n+          ObjectType rhsRoot = objectType;\n+          if (qname != null) {\n+            rhsRoot = qname.getRootType(rhsRoot, objectType);\n+          }\n+          ObjectType rhs = ObjectType.cast(rhsRoot.getSlot(qname));\n+          if (rhs != null && !rhs.isEquivalentTo(restrictedRightType)) {\n+            rhs.extendStructuralType(\n+                restrictedRightType, getprop.getSourceFileName(), getprop.getLineno());\n+          }\n         }\n       }\n+    } else if (!objectType.hasProperty(propName) || nodeType.isTop()) {\n+      // Infer the prop based on the right-hand expression's type\n+      // when the object type is not a struct or literal.\n+      JSType typeOnRight =\n+          !getprop.isFromExterns() && rightType != null ? rightType : unknownType;\n+      objectType.defineDeclaredProperty(propName, typeOnRight, getprop);\n+    } else {\n+      // Make the property at least declared.\n+      maybeDeclareLegacyNamespace(objectType, getprop);\n+    }\n+  }\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}