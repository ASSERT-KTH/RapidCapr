{
    "patch": "void replace() {\n    if (firstNode == null) {\n      // Don't touch the base case ('goog').\n      replacementNode = candidateDefinition;\n      return;\n    }\n\n    // Check if candidateDefinition is a VAR node.\n    boolean candidateIsVar = candidateDefinition != null &&\n        candidateDefinition.isVar() &&\n        candidateDefinition.hasOneChild() &&\n        candidateDefinition.getFirstChild().isName();\n\n    // Handle the case where there is a duplicate definition for an explicitly\n    // provided symbol.\n    if (candidateDefinition != null && explicitNode != null) {\n      explicitNode.detachFromParent();\n      compiler.reportCodeChange();\n\n      // Case 1: Don't need VAR.\n      // e.g. candidateDefinition is already a VAR - `var ns1 = ns1 || {};`\n      if (!candidateIsVar) {\n\n        // e.g. replace the expression node `ns1 = ns1 || {};`\n        // with `var ns1 = ns1 || {};`.\n        Node varNode = IR.var(candidateDefinition.detach());\n        replacementNode = varNode;\n        Node nameNode = candidateDefinition.getFirstChild().detach();\n        varNode.getFirstChild().addChildToBack(nameNode);\n        varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        compiler.reportCodeChange();\n\n      // Case 2: Need VAR.\n      // e.g. candidateDefinition is an assignment - `ns1 = ns1 || {};`\n      } else {\n\n        // e.g. convert `ns1 = ns1 || {};`\n        // to `var ns1 = ns1 || {};`.\n        Node assignNode = candidateDefinition.getFirstChild();\n        Node nameNode = assignNode.getFirstChild();\n        Node valueNode = nameNode.getNext();\n        Node varNode = IR.var(nameNode.detach(), valueNode.detach());\n        varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n        varNode.copyInformationFrom(candidateDefinition);\n        candidateDefinition.getParent().replaceChild(\n            candidateDefinition, varNode);\n        compiler.reportCodeChange();\n        replacementNode = varNode;\n      }\n    } else {\n      // Handle the case where there's not a duplicate definition.\n      if (!candidateIsVar) {\n\n        // Case 3: Don't need VAR.\n        // e.g. `ns1 = ns1 || {};`.\n        Node assignNode = candidateDefinition.detach();\n        Node varNode = IR.var(assignNode);\n        varNode.copyInformationFrom(assignNode);\n        replacementNode = varNode;\n        Node nameNode = assignNode.getFirstChild().detach();\n        varNode.getFirstChild().addChildToBack(nameNode);\n        Node initializerNode = nameNode.getNext().detach();\n        assignNode.removeChild(initializerNode);\n        nameNode.addChildToBack(initializerNode);\n        if (firstModule == minimumModule) {\n          firstNode.getParent().addChildBefore(varNode, firstNode);\n        } else {\n          Node parent = providedNames.get(namespace.substring(\n              0, namespace.lastIndexOf('.'))).replacementNode.getParent();\n          parent.addChildAfter(varNode, parent.getLastChild());\n        }\n\n      } else {\n\n        // Case 4: Need VAR.\n        // e.g. `var ns1 = ns1 || {};`\n        replacementNode = candidateDefinition.cloneTree();\n        if (firstModule == minimumModule) {\n          // Place the new node immediately before the first node.\n          Node parent = firstNode.getParent();\n          parent.addChildBefore(replacementNode, firstNode);\n        } else {\n          // In this case, the name was implicitly provided by two independent\n          // modules. We need to move this code up to a common module.\n\n          // Find the parent namespace.\n          int indexOfDot = namespace.lastIndexOf('.');\n          String parentNamespace = namespace.substring(0, indexOfDot);\n          ProvidedName parentName =\n              providedNames.get(parentNamespace);\n          Preconditions.checkNotNull(parentName);\n          Preconditions.checkNotNull(parentName.replacementNode);\n\n          // Add the new declaration after the parent namespace's declaration.\n          Node parent = parentName.replacementNode.getParent();\n          parent.addChildAfter(replacementNode, parentName.replacementNode);\n\n          // Update source information\n          NodeUtil.copySourceInfo(compiler, parentName.replacementNode, replacementNode);\n        }\n      }\n      if (explicitNode != null) {\n        explicitNode.detachFromParent();\n      }\n      compiler.reportCodeChange();\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex c929a363..1e6c22e3 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -744,69 +744,116 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n      * If we're providing a name with a duplicate definition, then make sure\n      * that definition becomes a declaration.\n      */\n-    void replace() {\n-      if (firstNode == null) {\n-        // Don't touch the base case ('goog').\n-        replacementNode = candidateDefinition;\n-        return;\n-      }\n+void replace() {\n+    if (firstNode == null) {\n+      // Don't touch the base case ('goog').\n+      replacementNode = candidateDefinition;\n+      return;\n+    }\n \n-      // Handle the case where there is a duplicate definition for an explicitly\n-      // provided symbol.\n-      if (candidateDefinition != null && explicitNode != null) {\n-        explicitNode.detachFromParent();\n+    // Check if candidateDefinition is a VAR node.\n+    boolean candidateIsVar = candidateDefinition != null &&\n+        candidateDefinition.isVar() &&\n+        candidateDefinition.hasOneChild() &&\n+        candidateDefinition.getFirstChild().isName();\n+\n+    // Handle the case where there is a duplicate definition for an explicitly\n+    // provided symbol.\n+    if (candidateDefinition != null && explicitNode != null) {\n+      explicitNode.detachFromParent();\n+      compiler.reportCodeChange();\n+\n+      // Case 1: Don't need VAR.\n+      // e.g. candidateDefinition is already a VAR - `var ns1 = ns1 || {};`\n+      if (!candidateIsVar) {\n+\n+        // e.g. replace the expression node `ns1 = ns1 || {};`\n+        // with `var ns1 = ns1 || {};`.\n+        Node varNode = IR.var(candidateDefinition.detach());\n+        replacementNode = varNode;\n+        Node nameNode = candidateDefinition.getFirstChild().detach();\n+        varNode.getFirstChild().addChildToBack(nameNode);\n+        varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n+        varNode.copyInformationFrom(candidateDefinition);\n+        candidateDefinition.getParent().replaceChild(\n+            candidateDefinition, varNode);\n         compiler.reportCodeChange();\n \n-        // Does this need a VAR keyword?\n-        replacementNode = candidateDefinition;\n-        if (NodeUtil.isExpressionNode(candidateDefinition)) {\n-          candidateDefinition.putBooleanProp(Node.IS_NAMESPACE, true);\n-          Node assignNode = candidateDefinition.getFirstChild();\n-          Node nameNode = assignNode.getFirstChild();\n-          if (nameNode.getType() == Token.NAME) {\n-            // Need to convert this assign to a var declaration.\n-            Node valueNode = nameNode.getNext();\n-            assignNode.removeChild(nameNode);\n-            assignNode.removeChild(valueNode);\n-            nameNode.addChildToFront(valueNode);\n-            Node varNode = new Node(Token.VAR, nameNode);\n-            varNode.copyInformationFrom(candidateDefinition);\n-            candidateDefinition.getParent().replaceChild(\n-                candidateDefinition, varNode);\n-            nameNode.setJSDocInfo(assignNode.getJSDocInfo());\n-            compiler.reportCodeChange();\n-            replacementNode = varNode;\n-          }\n+      // Case 2: Need VAR.\n+      // e.g. candidateDefinition is an assignment - `ns1 = ns1 || {};`\n+      } else {\n+\n+        // e.g. convert `ns1 = ns1 || {};`\n+        // to `var ns1 = ns1 || {};`.\n+        Node assignNode = candidateDefinition.getFirstChild();\n+        Node nameNode = assignNode.getFirstChild();\n+        Node valueNode = nameNode.getNext();\n+        Node varNode = IR.var(nameNode.detach(), valueNode.detach());\n+        varNode.setJSDocInfo(candidateDefinition.getJSDocInfo());\n+        varNode.copyInformationFrom(candidateDefinition);\n+        candidateDefinition.getParent().replaceChild(\n+            candidateDefinition, varNode);\n+        compiler.reportCodeChange();\n+        replacementNode = varNode;\n+      }\n+    } else {\n+      // Handle the case where there's not a duplicate definition.\n+      if (!candidateIsVar) {\n+\n+        // Case 3: Don't need VAR.\n+        // e.g. `ns1 = ns1 || {};`.\n+        Node assignNode = candidateDefinition.detach();\n+        Node varNode = IR.var(assignNode);\n+        varNode.copyInformationFrom(assignNode);\n+        replacementNode = varNode;\n+        Node nameNode = assignNode.getFirstChild().detach();\n+        varNode.getFirstChild().addChildToBack(nameNode);\n+        Node initializerNode = nameNode.getNext().detach();\n+        assignNode.removeChild(initializerNode);\n+        nameNode.addChildToBack(initializerNode);\n+        if (firstModule == minimumModule) {\n+          firstNode.getParent().addChildBefore(varNode, firstNode);\n+        } else {\n+          Node parent = providedNames.get(namespace.substring(\n+              0, namespace.lastIndexOf('.'))).replacementNode.getParent();\n+          parent.addChildAfter(varNode, parent.getLastChild());\n         }\n+\n       } else {\n-        // Handle the case where there's not a duplicate definition.\n-        replacementNode = createDeclarationNode();\n+\n+        // Case 4: Need VAR.\n+        // e.g. `var ns1 = ns1 || {};`\n+        replacementNode = candidateDefinition.cloneTree();\n         if (firstModule == minimumModule) {\n-          firstNode.getParent().addChildBefore(replacementNode, firstNode);\n+          // Place the new node immediately before the first node.\n+          Node parent = firstNode.getParent();\n+          parent.addChildBefore(replacementNode, firstNode);\n         } else {\n           // In this case, the name was implicitly provided by two independent\n           // modules. We need to move this code up to a common module.\n-          int indexOfDot = namespace.indexOf('.');\n-          if (indexOfDot == -1) {\n-            // Any old place is fine.\n-            compiler.getNodeForCodeInsertion(minimumModule)\n-                .addChildToBack(replacementNode);\n-          } else {\n-            // Add it after the parent namespace.\n-            ProvidedName parentName =\n-                providedNames.get(namespace.substring(0, indexOfDot));\n-            Preconditions.checkNotNull(parentName);\n-            Preconditions.checkNotNull(parentName.replacementNode);\n-            parentName.replacementNode.getParent().addChildAfter(\n-                replacementNode, parentName.replacementNode);\n-          }\n-        }\n-        if (explicitNode != null) {\n-          explicitNode.detachFromParent();\n+\n+          // Find the parent namespace.\n+          int indexOfDot = namespace.lastIndexOf('.');\n+          String parentNamespace = namespace.substring(0, indexOfDot);\n+          ProvidedName parentName =\n+              providedNames.get(parentNamespace);\n+          Preconditions.checkNotNull(parentName);\n+          Preconditions.checkNotNull(parentName.replacementNode);\n+\n+          // Add the new declaration after the parent namespace's declaration.\n+          Node parent = parentName.replacementNode.getParent();\n+          parent.addChildAfter(replacementNode, parentName.replacementNode);\n+\n+          // Update source information\n+          NodeUtil.copySourceInfo(compiler, parentName.replacementNode, replacementNode);\n         }\n-        compiler.reportCodeChange();\n       }\n+      if (explicitNode != null) {\n+        explicitNode.detachFromParent();\n+      }\n+      compiler.reportCodeChange();\n     }\n+  }\n \n     /**\n      * Create the declaration node for this name, without inserting it",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}