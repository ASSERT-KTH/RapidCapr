{
    "patch": "class IRFactory {\n  private Map<String, Node> namedFunctions = new HashMap<>();\n\n  private static class TransformDispatcher implements NodeTransformer {\n    @Override\n    public Node transform(Node node) {\n      throw new RuntimeException(\"Unsupported node type: \" + node);\n    }\n\n    private Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n\n    private Node processBreakStatement(BreakStatement statementNode) {\n      Node node = newNode(Token.BREAK);\n      if (statementNode.getBreakLabel() != null) {\n        Node labelName = transform(statementNode.getBreakLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    private Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            \"Catch clauses are not supported\",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    private Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n          Token.HOOK,\n          transform(exprNode.getTestExpression()),\n          transform(exprNode.getTrueExpression()),\n          transform(exprNode.getFalseExpression()));\n    }\n\n    private Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = transform(statementNode.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    private Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n          Token.DO,\n          transformBlock(loopNode.getBody()),\n          transform(loopNode.getCondition()));\n    }\n\n    private Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }\n\n    private Node processEmptyExpression(EmptyExpression exprNode) {\n      Node node = newNode(Token.EMPTY);\n      return node;\n    }\n\n    private Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n\n    private Node processForInLoop(ForInLoop loopNode) {\n      AstNode iterVar = loopNode.getIterator();\n      if (iterVar.getType() != Token.NAME) {\n        errorReporter.error(\n            \"Unsupported loop variable type: \" + Token.name(iterVar.getType()),\n            sourceName,\n            iterVar.getLineno(), \"\", 0);\n      }\n      Node forNode = newNode(\n          Token.FOR,\n          transform(iterVar),\n          transform(loopNode.getIteratedObject()),\n          transformBlock(loopNode.getBody()));\n      return forNode;\n    }\n\n    private Node processForLoop(ForLoop loopNode) {\n      Node initNode = null;\n      AstNode init = loopNode.getInitializer();\n      if (init != null) {\n        int initType = init.getType();\n        if (initType == Token.VAR || initType == Token.LET || initType == Token.CONST) {\n          initNode = transform(init);\n        } else {\n          initNode = transform(init);\n          initNode.setType(Token.EXPR_RESULT);\n        }\n      }\n      return newNode(\n          Token.FOR,\n          initNode,\n          transform(loopNode.getCondition()),\n          transform(loopNode.getIncrement()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    private Node processFunctionCall(FunctionCall callNode) {\n      if (callNode.getTarget().getType() == Token.NAME) {\n        String functionName = callNode.getTarget().getString();\n        if (namedFunctions.containsKey(functionName)) {\n          Node functionNode = namedFunctions.get(functionName);\n          Node call = newNode(Token.CALL, transform(callNode.getTarget()));\n          for (AstNode arg : callNode.getArguments()) {\n            call.addChildToBack(transform(arg));\n          }\n          functionNode = functionNode.cloneTree();\n          call.setLineno(callNode.getLineno());\n          functionNode.replaceChild(functionNode.getFirstChild(), call);\n          return functionNode;\n        }\n      }\n      return newNode(Token.CALL, transform(callNode.getTarget()), transformArgs(callNode));\n    }\n\n    private Node processFunctionNode(FunctionNode functionNode) {\n      Node parent = currentScriptOrFn;\n      try {\n        currentScriptOrFn = functionNode;\n\n        Node fnNode = newNode(Token.FUNCTION);\n\n        // name\n        String name = functionNode.getName();\n        if (name != null) {\n          // We don't need to check if it is in namedFunctions. If it\n          // has a name, it is\n          // either assigned to a variable, or defined on an object.\n          Node nameNode = newString(name);\n          fnNode.addChildToBack(nameNode);\n        }\n\n        // parameters\n        Node paramNode = newNode(Token.PARAM_LIST);\n        for (int i = 0; i < functionNode.getParamCount(); i++) {\n          AstNode param = functionNode.getParam(i);\n          if (!param.hasChildren()) {\n            continue;\n          }\n          paramNode.addChildToBack(transform(param));\n        }\n        fnNode.addChildToBack(paramNode);\n\n        // body\n        fnNode.addChildToBack(transform(functionNode.getBody()));\n\n        // Force a return statement when a function ends with an unconditional\n        // throw statement.\n        Node lastChild = fnNode.getLastChild();\n        if (lastChild.getType() == Token.THROW) {\n          Node returnNode = newNode(Token.RETURN, lastChild.getFirstChild());\n          fnNode.replaceChild(lastChild, returnNode);\n        }\n\n        // Create a NAME node representing the function object.\n        Node qName = createName(name, functionNode.getLineno());\n\n        // Add the function node to the global scope.\n        Node varNode =\n            IR.var(qName, newNode(Token.ASSIGN, qName.cloneNode(), fnNode)).setOriginalName(name);\n        parent.addChildToBack(varNode);\n\n        if (name != null) {\n          namedFunctions.put(name, qName);\n        }\n\n        return qName;\n      } finally {\n        currentScriptOrFn = parent;\n      }\n    }\n\n    private Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(Token.IF, transform(statementNode.getCondition()));\n      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n      if (statementNode.getElsePart() != null) {\n        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n      }\n      return node;\n    }\n\n    private Node processLabeledStatement(LabeledStatement statementNode) {\n      Node node = newNode(Token.LABEL);\n      node.addChildToBack(transform(statementNode.getStatement()));\n      node.addChildToBack(newString(statementNode.getLabelName()));\n      return node;\n    }\n\n    private Node processLetNode(LetNode letNode) {\n      return newNode(Token.LET, transform(letNode.getVariables()));\n    }\n\n    private Node processName(Name nameNode) {\n      if (nameNode.getIdentifier().equals(\"undefined\")) {\n        return newUndefined();\n      }\n      return createName(nameNode.getIdentifier(), nameNode.getLineno());\n    }\n\n    private Node processNewExpression(NewExpression callNode) {\n      Node newNode = newNode(Token.NEW, transform(callNode.getTarget()));\n      for (AstNode arg : callNode.getArguments()) {\n        newNode.addChildToBack(transform(arg));\n      }\n      return newNode;\n    }\n\n    private Node processNumber(NumberLiteral numberNode) {\n      return newNumber(numberNode.getNumber());\n    }\n\n    private Node processObjectLiteral(ObjectLiteral literalNode) {\n      Node literal = newNode(Token.OBJECTLIT);\n      for (ObjectProperty prop : literalNode.getElements()) {\n        AstNode left = prop.getLeft();\n        if (left.getType() == Token.GET) {\n          Node fnNode =\n              newNode(Token.GETTER_DEF, transform(left), transform(prop.getRight()));\n          fnNode.setIsStaticProp(prop.isStaticMember());\n          literal.addChildToBack(fnNode);\n        } else if (left.getType() == Token.SET) {\n          Node fnNode =\n              newNode(Token.SETTER_DEF, transform(left), transform(prop.getRight()));\n          fnNode.setIsStaticProp(prop.isStaticMember());\n          literal.addChildToBack(fnNode);\n        } else {\n          literal.addChildToBack(\n              newNode(Token.STRING_KEY, newString(left.getString()), transform(prop.getRight()))\n                  .setIsStaticProp(prop.isStaticMember()));\n        }\n      }\n      return literal;\n    }\n\n    private Node processRegExpLiteral(RegExpLiteral literalNode) {\n      return newRegExp(literalNode.getValue(), literalNode.getFlags());\n    }\n\n    private Node processReturnStatement(ReturnStatement statementNode) {\n      Node node = newNode(Token.RETURN);\n      if (statementNode.getReturnValue() != null) {\n        node.addChildToBack(transform(statementNode.getReturnValue()));\n      } else {\n        node.addChildToBack(newUndefined());\n      }\n      return node;\n    }\n\n    private Node processString(StringLiteral stringNode) {\n      return newString(stringNode.getValue());\n    }\n\n    private Node processSwitchStatement(SwitchStatement statementNode) {\n      Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n      List<SwitchCase> cases = statementNode.getCases();\n      for (SwitchCase sc : cases) {\n        Node caseNode;\n        if (sc.getExpression() != null) {\n          caseNode = newNode(Token.CASE, transform(sc.getExpression()));\n        } else {\n          caseNode = newNode(Token.DEFAULT);\n        }\n        node.addChildToBack(caseNode);\n        List<AstNode> statements = sc.getStatements();\n        for (AstNode st : statements) {\n          caseNode.addChildToBack(transform(st));\n        }\n      }\n      return node;\n    }\n\n    private Node processThrowStatement(ThrowStatement statementNode) {\n      return newNode(Token.THROW, transform(statementNode.getExpression()));\n    }\n\n    private Node processTryStatement(TryStatement statementNode) {\n      Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n      if (statementNode.getCatchClause() != null) {\n        node.addChildToBack(transform(statementNode.getCatchClause()));\n      }\n      if (statementNode.getFinallyBlock() != null) {\n        node.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n      }\n      return node;\n    }\n\n    private Node processUnaryExpression(UnaryExpression exprNode) {\n      return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n    }\n\n    private Node processVariableDeclaration(VariableDeclaration declarationNode) {\n      Node varNode = newNode(declarationNode.getType());\n      for (VariableInitializer init : declarationNode.getVariables()) {\n        Node decl = transform(init);\n        // Check if this variable is defined with `let` or `const`\n        boolean isLet = declarationNode.isLet();\n        boolean isConst = declarationNode.isConst();\n        if (isLet || isConst) {\n          decl.getFirstChild().setType(Token.LET);\n        }\n        varNode.addChildToBack(decl);\n      }\n      return varNode;\n    }\n\n    private Node processVariableInitializer(VariableInitializer initializerNode) {\n      Node initNode = transform(initializerNode.getTarget());\n      AstNode value = initializerNode.getInitializer();\n      if (value != null) {\n        initNode.addChildToBack(transform(value));\n      }\n      return initNode;\n    }\n\n    private Node processWhileLoop(WhileLoop loopNode) {\n      return createLoop(\n          Token.WHILE,\n          newNode(Token.EMPTY),\n          transform(loopNode.getCondition()),\n          transformBlock(loopNode.getBody()));\n    }\n\n    private Node processWithStatement(WithStatement statementNode) {\n      return newNode(Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement()));\n    }\n\n    protected Node processGeneric(AstNode node) {\n      int count = node.getChildCount();\n      Node n = new Node(tokenTypeFrom(node));\n      for (int i = 0; i < count; i++) {\n        n.addChildToBack(transform(node.getChildAtIndex(i)));\n      }\n      return n;\n    }\n\n    private Node createLoop(int tokenType, Node initNode, Node condExpr, Node body) {\n      return newNode(tokenType, initNode, condExpr, body);\n    }\n\n    private Node transformArgs(CallArguments argsNode) {\n      Node n = newNode(Token.EMPTY);\n      for (AstNode arg : argsNode) {\n        n.addChildToBack(transform(arg));\n      }\n      return n;\n    }\n\n    private Node createName(String identifier, int lineno) {\n      Node nameNode = new Node(Token.NAME, new String(identifier));\n      nameNode.setLineno(lineno);\n      return nameNode;\n    }\n\n    private static int tokenTypeFrom(AstNode node) {\n      int tt = node.getType();\n      if (tt == Token.LET || tt == Token.CONST || tt == Token.VAR) {\n        return Token.VAR;\n      }\n      return tt;\n    }\n\n    private Node transformBlock(AstNode node) {\n      if (node instanceof Block) {\n        return transform(node);\n      } else {\n        // Rhino doesn't always give us a block node.\n        Node block = newNode(Token.BLOCK);\n        block.addChildToBack(transfor",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..0cec55ca 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -472,23 +472,20 @@ class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+class IRFactory {\n+  private Map<String, Node> namedFunctions = new HashMap<>();\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n-\n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private static class TransformDispatcher implements NodeTransformer {\n+    @Override\n+    public Node transform(Node node) {\n+      throw new RuntimeException(\"Unsupported node type: \" + node);\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n+    private Node processBlock(Block blockNode) {\n       return processGeneric(blockNode);\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n+    private Node processBreakStatement(BreakStatement statementNode) {\n       Node node = newNode(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n         Node labelName = transform(statementNode.getBreakLabel());\n@@ -499,8 +496,7 @@ class IRFactory {\n       return node;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n+    private Node processCatchClause(CatchClause clauseNode) {\n       AstNode catchVar = clauseNode.getVarName();\n       Node node = newNode(Token.CATCH, transform(catchVar));\n       if (clauseNode.getCatchCondition() != null) {\n@@ -513,8 +509,7 @@ class IRFactory {\n       return node;\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+    private Node processConditionalExpression(ConditionalExpression exprNode) {\n       return newNode(\n           Token.HOOK,\n           transform(exprNode.getTestExpression()),\n@@ -522,8 +517,7 @@ class IRFactory {\n           transform(exprNode.getFalseExpression()));\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n+    private Node processContinueStatement(ContinueStatement statementNode) {\n       Node node = newNode(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n         Node labelName = transform(statementNode.getLabel());\n@@ -534,46 +528,339 @@ class IRFactory {\n       return node;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n+    private Node processDoLoop(DoLoop loopNode) {\n       return newNode(\n           Token.DO,\n           transformBlock(loopNode.getBody()),\n           transform(loopNode.getCondition()));\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n+    private Node processElementGet(ElementGet getNode) {\n       return newNode(\n           Token.GETELEM,\n           transform(getNode.getTarget()),\n           transform(getNode.getElement()));\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n+    private Node processEmptyExpression(EmptyExpression exprNode) {\n       Node node = newNode(Token.EMPTY);\n       return node;\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n+    private Node processExpressionStatement(ExpressionStatement statementNode) {\n       Node node = newNode(transformTokenType(statementNode.getType()));\n       node.addChildToBack(transform(statementNode.getExpression()));\n       return node;\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    private Node processForInLoop(ForInLoop loopNode) {\n+      AstNode iterVar = loopNode.getIterator();\n+      if (iterVar.getType() != Token.NAME) {\n+        errorReporter.error(\n+            \"Unsupported loop variable type: \" + Token.name(iterVar.getType()),\n+            sourceName,\n+            iterVar.getLineno(), \"\", 0);\n+      }\n+      Node forNode = newNode(\n+          Token.FOR,\n+          transform(iterVar),\n+          transform(loopNode.getIteratedObject()),\n+          transformBlock(loopNode.getBody()));\n+      return forNode;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n+    private Node processForLoop(ForLoop loopNode) {\n+      Node initNode = null;\n+      AstNode init = loopNode.getInitializer();\n+      if (init != null) {\n+        int initType = init.getType();\n+        if (initType == Token.VAR || initType == Token.LET || initType == Token.CONST) {\n+          initNode = transform(init);\n+        } else {\n+          initNode = transform(init);\n+          initNode.setType(Token.EXPR_RESULT);\n+        }\n+      }\n       return newNode(\n           Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n+          initNode,\n+          transform(loopNode.getCondition()),\n+          transform(loopNode.getIncrement()),\n           transformBlock(loopNode.getBody()));\n     }\n \n+    private Node processFunctionCall(FunctionCall callNode) {\n+      if (callNode.getTarget().getType() == Token.NAME) {\n+        String functionName = callNode.getTarget().getString();\n+        if (namedFunctions.containsKey(functionName)) {\n+          Node functionNode = namedFunctions.get(functionName);\n+          Node call = newNode(Token.CALL, transform(callNode.getTarget()));\n+          for (AstNode arg : callNode.getArguments()) {\n+            call.addChildToBack(transform(arg));\n+          }\n+          functionNode = functionNode.cloneTree();\n+          call.setLineno(callNode.getLineno());\n+          functionNode.replaceChild(functionNode.getFirstChild(), call);\n+          return functionNode;\n+        }\n+      }\n+      return newNode(Token.CALL, transform(callNode.getTarget()), transformArgs(callNode));\n+    }\n+\n+    private Node processFunctionNode(FunctionNode functionNode) {\n+      Node parent = currentScriptOrFn;\n+      try {\n+        currentScriptOrFn = functionNode;\n+\n+        Node fnNode = newNode(Token.FUNCTION);\n+\n+        // name\n+        String name = functionNode.getName();\n+        if (name != null) {\n+          // We don't need to check if it is in namedFunctions. If it\n+          // has a name, it is\n+          // either assigned to a variable, or defined on an object.\n+          Node nameNode = newString(name);\n+          fnNode.addChildToBack(nameNode);\n+        }\n+\n+        // parameters\n+        Node paramNode = newNode(Token.PARAM_LIST);\n+        for (int i = 0; i < functionNode.getParamCount(); i++) {\n+          AstNode param = functionNode.getParam(i);\n+          if (!param.hasChildren()) {\n+            continue;\n+          }\n+          paramNode.addChildToBack(transform(param));\n+        }\n+        fnNode.addChildToBack(paramNode);\n+\n+        // body\n+        fnNode.addChildToBack(transform(functionNode.getBody()));\n+\n+        // Force a return statement when a function ends with an unconditional\n+        // throw statement.\n+        Node lastChild = fnNode.getLastChild();\n+        if (lastChild.getType() == Token.THROW) {\n+          Node returnNode = newNode(Token.RETURN, lastChild.getFirstChild());\n+          fnNode.replaceChild(lastChild, returnNode);\n+        }\n+\n+        // Create a NAME node representing the function object.\n+        Node qName = createName(name, functionNode.getLineno());\n+\n+        // Add the function node to the global scope.\n+        Node varNode =\n+            IR.var(qName, newNode(Token.ASSIGN, qName.cloneNode(), fnNode)).setOriginalName(name);\n+        parent.addChildToBack(varNode);\n+\n+        if (name != null) {\n+          namedFunctions.put(name, qName);\n+        }\n+\n+        return qName;\n+      } finally {\n+        currentScriptOrFn = parent;\n+      }\n+    }\n+\n+    private Node processIfStatement(IfStatement statementNode) {\n+      Node node = newNode(Token.IF, transform(statementNode.getCondition()));\n+      node.addChildToBack(transformBlock(statementNode.getThenPart()));\n+      if (statementNode.getElsePart() != null) {\n+        node.addChildToBack(transformBlock(statementNode.getElsePart()));\n+      }\n+      return node;\n+    }\n+\n+    private Node processLabeledStatement(LabeledStatement statementNode) {\n+      Node node = newNode(Token.LABEL);\n+      node.addChildToBack(transform(statementNode.getStatement()));\n+      node.addChildToBack(newString(statementNode.getLabelName()));\n+      return node;\n+    }\n+\n+    private Node processLetNode(LetNode letNode) {\n+      return newNode(Token.LET, transform(letNode.getVariables()));\n+    }\n+\n+    private Node processName(Name nameNode) {\n+      if (nameNode.getIdentifier().equals(\"undefined\")) {\n+        return newUndefined();\n+      }\n+      return createName(nameNode.getIdentifier(), nameNode.getLineno());\n+    }\n+\n+    private Node processNewExpression(NewExpression callNode) {\n+      Node newNode = newNode(Token.NEW, transform(callNode.getTarget()));\n+      for (AstNode arg : callNode.getArguments()) {\n+        newNode.addChildToBack(transform(arg));\n+      }\n+      return newNode;\n+    }\n+\n+    private Node processNumber(NumberLiteral numberNode) {\n+      return newNumber(numberNode.getNumber());\n+    }\n+\n+    private Node processObjectLiteral(ObjectLiteral literalNode) {\n+      Node literal = newNode(Token.OBJECTLIT);\n+      for (ObjectProperty prop : literalNode.getElements()) {\n+        AstNode left = prop.getLeft();\n+        if (left.getType() == Token.GET) {\n+          Node fnNode =\n+              newNode(Token.GETTER_DEF, transform(left), transform(prop.getRight()));\n+          fnNode.setIsStaticProp(prop.isStaticMember());\n+          literal.addChildToBack(fnNode);\n+        } else if (left.getType() == Token.SET) {\n+          Node fnNode =\n+              newNode(Token.SETTER_DEF, transform(left), transform(prop.getRight()));\n+          fnNode.setIsStaticProp(prop.isStaticMember());\n+          literal.addChildToBack(fnNode);\n+        } else {\n+          literal.addChildToBack(\n+              newNode(Token.STRING_KEY, newString(left.getString()), transform(prop.getRight()))\n+                  .setIsStaticProp(prop.isStaticMember()));\n+        }\n+      }\n+      return literal;\n+    }\n+\n+    private Node processRegExpLiteral(RegExpLiteral literalNode) {\n+      return newRegExp(literalNode.getValue(), literalNode.getFlags());\n+    }\n+\n+    private Node processReturnStatement(ReturnStatement statementNode) {\n+      Node node = newNode(Token.RETURN);\n+      if (statementNode.getReturnValue() != null) {\n+        node.addChildToBack(transform(statementNode.getReturnValue()));\n+      } else {\n+        node.addChildToBack(newUndefined());\n+      }\n+      return node;\n+    }\n+\n+    private Node processString(StringLiteral stringNode) {\n+      return newString(stringNode.getValue());\n+    }\n+\n+    private Node processSwitchStatement(SwitchStatement statementNode) {\n+      Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+      List<SwitchCase> cases = statementNode.getCases();\n+      for (SwitchCase sc : cases) {\n+        Node caseNode;\n+        if (sc.getExpression() != null) {\n+          caseNode = newNode(Token.CASE, transform(sc.getExpression()));\n+        } else {\n+          caseNode = newNode(Token.DEFAULT);\n+        }\n+        node.addChildToBack(caseNode);\n+        List<AstNode> statements = sc.getStatements();\n+        for (AstNode st : statements) {\n+          caseNode.addChildToBack(transform(st));\n+        }\n+      }\n+      return node;\n+    }\n+\n+    private Node processThrowStatement(ThrowStatement statementNode) {\n+      return newNode(Token.THROW, transform(statementNode.getExpression()));\n+    }\n+\n+    private Node processTryStatement(TryStatement statementNode) {\n+      Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+      if (statementNode.getCatchClause() != null) {\n+        node.addChildToBack(transform(statementNode.getCatchClause()));\n+      }\n+      if (statementNode.getFinallyBlock() != null) {\n+        node.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n+      }\n+      return node;\n+    }\n+\n+    private Node processUnaryExpression(UnaryExpression exprNode) {\n+      return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n+    }\n+\n+    private Node processVariableDeclaration(VariableDeclaration declarationNode) {\n+      Node varNode = newNode(declarationNode.getType());\n+      for (VariableInitializer init : declarationNode.getVariables()) {\n+        Node decl = transform(init);\n+        // Check if this variable is defined with `let` or `const`\n+        boolean isLet = declarationNode.isLet();\n+        boolean isConst = declarationNode.isConst();\n+        if (isLet || isConst) {\n+          decl.getFirstChild().setType(Token.LET);\n+        }\n+        varNode.addChildToBack(decl);\n+      }\n+      return varNode;\n+    }\n+\n+    private Node processVariableInitializer(VariableInitializer initializerNode) {\n+      Node initNode = transform(initializerNode.getTarget());\n+      AstNode value = initializerNode.getInitializer();\n+      if (value != null) {\n+        initNode.addChildToBack(transform(value));\n+      }\n+      return initNode;\n+    }\n+\n+    private Node processWhileLoop(WhileLoop loopNode) {\n+      return createLoop(\n+          Token.WHILE,\n+          newNode(Token.EMPTY),\n+          transform(loopNode.getCondition()),\n+          transformBlock(loopNode.getBody()));\n+    }\n+\n+    private Node processWithStatement(WithStatement statementNode) {\n+      return newNode(Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement()));\n+    }\n+\n+    protected Node processGeneric(AstNode node) {\n+      int count = node.getChildCount();\n+      Node n = new Node(tokenTypeFrom(node));\n+      for (int i = 0; i < count; i++) {\n+        n.addChildToBack(transform(node.getChildAtIndex(i)));\n+      }\n+      return n;\n+    }\n+\n+    private Node createLoop(int tokenType, Node initNode, Node condExpr, Node body) {\n+      return newNode(tokenType, initNode, condExpr, body);\n+    }\n+\n+    private Node transformArgs(CallArguments argsNode) {\n+      Node n = newNode(Token.EMPTY);\n+      for (AstNode arg : argsNode) {\n+        n.addChildToBack(transform(arg));\n+      }\n+      return n;\n+    }\n+\n+    private Node createName(String identifier, int lineno) {\n+      Node nameNode = new Node(Token.NAME, new String(identifier));\n+      nameNode.setLineno(lineno);\n+      return nameNode;\n+    }\n+\n+    private static int tokenTypeFrom(AstNode node) {\n+      int tt = node.getType();\n+      if (tt == Token.LET || tt == Token.CONST || tt == Token.VAR) {\n+        return Token.VAR;\n+      }\n+      return tt;\n+    }\n+\n+    private Node transformBlock(AstNode node) {\n+      if (node instanceof Block) {\n+        return transform(node);\n+      } else {\n+        // Rhino doesn't always give us a block node.\n+        Node block = newNode(Token.BLOCK);\n+        block.addChildToBack(transfor\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}