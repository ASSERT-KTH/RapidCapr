{
    "patch": "private String getRemainingJSDocLine() {\n    String result = stream.getRemainingJSDocLine();\n    unreadToken = NO_UNREAD_TOKEN;\n    return result;\n}\n\n/**\n * Unifies this type and the given type into a new union type.\n */\n@Override\npublic JSType getLeastSupertype(JSType that) {\n    if (this.equals(that)) {\n        return this;\n    }\n    UnionBuilder builder = new UnionBuilder();\n    builder.addAlternate(this);\n    if (that.isUnionType()) {\n        for (JSType alternate : ((UnionType) that).alternates) {\n            builder.addAlternate(alternate.getLeastSupertype(this));\n        }\n        JSType result = builder.build();\n        if (result.isUnionType()) {\n            return ((UnionType) result).flatten();\n        }\n        return result;\n    } else if (that.isSubtype(this)) {\n        builder.addAlternate(that);\n        JSType result = builder.build();\n        if (result.isUnionType()) {\n            return ((UnionType) result).flatten();\n        }\n        return result;\n    } else if (this.isObject() && that.isObject()) {\n        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    } else if (this.isNoType() || that.isNoType()) {\n         return getNativeType(JSTypeNative.NO_TYPE);\n    } else {\n        return getNativeType(JSTypeNative.NONE_TYPE); \n    }\n}\n\n/**\n * Two union types are equal if they have the same number of alternates\n * and all alternates are equal.\n */\n@Override\npublic boolean equals(Object object) {\n    if (object instanceof UnionType) {\n        UnionType that = (UnionType) object;\n        return alternates.equals(that.alternates);\n    } else {\n        return false;\n    }\n}\n\n@Override\npublic int hashCode() {\n    return alternates.hashCode();\n}\n\n@Override\npublic boolean isUnionType() {\n    return true;\n}\n\n@Override\npublic boolean isObject() {\n    for (JSType alternate : alternates) {\n        if (!alternate.isObject()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n@Override\npublic boolean isNoType() {\n    for (JSType alternate : alternates) {\n        if (!alternate.isNoType()) {\n            return false;\n        }\n    }\n    return true;\n}\n\n@Override\npublic String toString() {\n    return Joiner.on(\"|\").join(alternates);\n}\n\n@Override\npublic String toAnnotationString() {\n    Set<String> types = Sets.newHashSet();\n    for (JSType alternate : alternates) {\n        types.add(alternate.toAnnotationString());\n    }\n    return Joiner.on('|').join(types);\n}\n\nprivate JSType flatten() {\n    List<JSType> flatAlternates = Lists.newArrayList();\n    for (JSType alternate : alternates) {\n        if (alternate.isUnionType()) {\n            flatAlternates.addAll(((UnionType) alternate).flatten().alternates);\n        } else {\n            flatAlternates.add(alternate);\n        }\n    }\n    UnionBuilder builder = new UnionBuilder();\n    for (JSType flatAlternate : flatAlternates) {\n        builder.addAlternate(flatAlternate);\n    }\n    return builder.build();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex a9c9a0ae..fc68c91f 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -288,7 +288,120 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+private String getRemainingJSDocLine() {\n+    String result = stream.getRemainingJSDocLine();\n+    unreadToken = NO_UNREAD_TOKEN;\n+    return result;\n+}\n+\n+/**\n+ * Unifies this type and the given type into a new union type.\n+ */\n+@Override\n+public JSType getLeastSupertype(JSType that) {\n+    if (this.equals(that)) {\n+        return this;\n+    }\n+    UnionBuilder builder = new UnionBuilder();\n+    builder.addAlternate(this);\n+    if (that.isUnionType()) {\n+        for (JSType alternate : ((UnionType) that).alternates) {\n+            builder.addAlternate(alternate.getLeastSupertype(this));\n+        }\n+        JSType result = builder.build();\n+        if (result.isUnionType()) {\n+            return ((UnionType) result).flatten();\n+        }\n+        return result;\n+    } else if (that.isSubtype(this)) {\n+        builder.addAlternate(that);\n+        JSType result = builder.build();\n+        if (result.isUnionType()) {\n+            return ((UnionType) result).flatten();\n+        }\n+        return result;\n+    } else if (this.isObject() && that.isObject()) {\n+        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+    } else if (this.isNoType() || that.isNoType()) {\n+         return getNativeType(JSTypeNative.NO_TYPE);\n+    } else {\n+        return getNativeType(JSTypeNative.NONE_TYPE); \n+    }\n+}\n+\n+/**\n+ * Two union types are equal if they have the same number of alternates\n+ * and all alternates are equal.\n+ */\n+@Override\n+public boolean equals(Object object) {\n+    if (object instanceof UnionType) {\n+        UnionType that = (UnionType) object;\n+        return alternates.equals(that.alternates);\n+    } else {\n+        return false;\n+    }\n+}\n+\n+@Override\n+public int hashCode() {\n+    return alternates.hashCode();\n+}\n+\n+@Override\n+public boolean isUnionType() {\n+    return true;\n+}\n+\n+@Override\n+public boolean isObject() {\n+    for (JSType alternate : alternates) {\n+        if (!alternate.isObject()) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+@Override\n+public boolean isNoType() {\n+    for (JSType alternate : alternates) {\n+        if (!alternate.isNoType()) {\n+            return false;\n+        }\n+    }\n+    return true;\n+}\n+\n+@Override\n+public String toString() {\n+    return Joiner.on(\"|\").join(alternates);\n+}\n+\n+@Override\n+public String toAnnotationString() {\n+    Set<String> types = Sets.newHashSet();\n+    for (JSType alternate : alternates) {\n+        types.add(alternate.toAnnotationString());\n+    }\n+    return Joiner.on('|').join(types);\n+}\n+\n+private JSType flatten() {\n+    List<JSType> flatAlternates = Lists.newArrayList();\n+    for (JSType alternate : alternates) {\n+        if (alternate.isUnionType()) {\n+            flatAlternates.addAll(((UnionType) alternate).flatten().alternates);\n+        } else {\n+            flatAlternates.add(alternate);\n+        }\n+    }\n+    UnionBuilder builder = new UnionBuilder();\n+    for (JSType flatAlternate : flatAlternates) {\n+        builder.addAlternate(flatAlternate);\n+    }\n+    return builder.build();\n+}\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}