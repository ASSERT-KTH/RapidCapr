{
    "patch": "  private void inlineAliases(GlobalNamespace namespace) {\n    // Invariant: All the names in the worklist meet condition (a).\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    while (!workList.isEmpty()) {\n      Name name = workList.pop();\n\n      // Don't attempt to inline a getter or setter property as a variable.\n      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n        continue;\n      }\n\n      if ((name.globalSets == 1 || name.localSets == 1) &&\n          name.localGets == 0 && name.aliasingGets == 0) {\n        // {@code name} meets condition (b).\n        // Move up the global property if:\n        // 1. It's not aliased.\n        // 2. It's not got a child with the same name. This avoids shadowing.\n        // 3. There is no local variable with the same name.\n        //    TODO(johnlenz): In some cases the local should be inlined first.\n        // We also need to check if there is another alias of the global property that\n        // we should not inline. Here are the cases:\n        // 1. The alias is a getprop of an object that we do not know is in the\n        //    same scope.\n        // 2. There is a local variable with the same name as the alias\n        //\n        // Because of the second case we cannot do the usual approach of creating a\n        // new variable. Instead we need to rename any remaining access of the global\n        // property to use the local variable name directly.\n        Node refNode = Iterables.getOnlyElement(name.getRefs()).getNode();\n        Node parent = refNode.getParent();\n        if (parent != null) {\n          switch (parent.getToken()) {\n            case ASSIGN:\n            case VAR:\n            case LET:\n            case CONST:\n            case OBJECTLIT:\n            case CLASS:\n            case FUNCTION:\n              // OK to move it up.\n              break;\n            default:\n              continue;\n          }\n        }\n        List<Name> siblings = ImmutableList.of();\n        if (name.getParent() != null) {\n          siblings = name.getParent().props;\n        }\n        boolean shadowed = false;\n        for (Name sibling : siblings) {\n          if (sibling == name) {\n            continue;\n          }\n          if (sibling.getLocalSets() > 0 || sibling.getAliasingGets() > 0 ||\n              sibling.getLocalGets() > 0) {\n            shadowed = true;\n            break;\n          }\n        }\n        if (shadowed) {\n          continue;\n        }\n        boolean canRemoveVar = true;\n        if (name.getDeclaration() != null) {\n          canRemoveVar =\n              NodeUtil.canRemoveNameNode(name.getDeclaration(), /*keepFunctionName=*/true);\n        }\n        if (canRemoveVar) {\n          if (inlineGlobalAliasedPropertyIfPossible(name, namespace)) {\n            workList.addAll(siblings);\n          }\n        }\n      }\n\n      // Check if {@code name} meets condition (c).\n      if (name.globalSets == 0 && name.localSets == 0 &&\n          name.localGets == 0 && name.aliasingGets == 1) {\n        // Try to inline it.\n        if (inlineLocalAliasIfPossible(name, namespace)) {\n          // The only references to this name left are the inlined ones.\n          workList.remove(name);\n        }\n      }\n\n      // Check if {@code name} has any aliases left after the\n      // local-alias-inlining above.\n      if ((name.type == Name.Type.OBJECTLIT ||\n           name.type == Name.Type.FUNCTION) &&\n          name.aliasingGets == 0 && name.props != null) {\n        // All of {@code name}'s children meet condition (a), so they can be\n        // added to the worklist.\n        workList.addAll(name.props);\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..65408377 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,102 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+  private void inlineAliases(GlobalNamespace namespace) {\n+    // Invariant: All the names in the worklist meet condition (a).\n+    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n+    while (!workList.isEmpty()) {\n+      Name name = workList.pop();\n+\n+      // Don't attempt to inline a getter or setter property as a variable.\n+      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n+        continue;\n+      }\n+\n+      if ((name.globalSets == 1 || name.localSets == 1) &&\n+          name.localGets == 0 && name.aliasingGets == 0) {\n+        // {@code name} meets condition (b).\n+        // Move up the global property if:\n+        // 1. It's not aliased.\n+        // 2. It's not got a child with the same name. This avoids shadowing.\n+        // 3. There is no local variable with the same name.\n+        //    TODO(johnlenz): In some cases the local should be inlined first.\n+        // We also need to check if there is another alias of the global property that\n+        // we should not inline. Here are the cases:\n+        // 1. The alias is a getprop of an object that we do not know is in the\n+        //    same scope.\n+        // 2. There is a local variable with the same name as the alias\n+        //\n+        // Because of the second case we cannot do the usual approach of creating a\n+        // new variable. Instead we need to rename any remaining access of the global\n+        // property to use the local variable name directly.\n+        Node refNode = Iterables.getOnlyElement(name.getRefs()).getNode();\n+        Node parent = refNode.getParent();\n+        if (parent != null) {\n+          switch (parent.getToken()) {\n+            case ASSIGN:\n+            case VAR:\n+            case LET:\n+            case CONST:\n+            case OBJECTLIT:\n+            case CLASS:\n+            case FUNCTION:\n+              // OK to move it up.\n+              break;\n+            default:\n+              continue;\n+          }\n+        }\n+        List<Name> siblings = ImmutableList.of();\n+        if (name.getParent() != null) {\n+          siblings = name.getParent().props;\n+        }\n+        boolean shadowed = false;\n+        for (Name sibling : siblings) {\n+          if (sibling == name) {\n+            continue;\n+          }\n+          if (sibling.getLocalSets() > 0 || sibling.getAliasingGets() > 0 ||\n+              sibling.getLocalGets() > 0) {\n+            shadowed = true;\n+            break;\n+          }\n+        }\n+        if (shadowed) {\n+          continue;\n+        }\n+        boolean canRemoveVar = true;\n+        if (name.getDeclaration() != null) {\n+          canRemoveVar =\n+              NodeUtil.canRemoveNameNode(name.getDeclaration(), /*keepFunctionName=*/true);\n+        }\n+        if (canRemoveVar) {\n+          if (inlineGlobalAliasedPropertyIfPossible(name, namespace)) {\n+            workList.addAll(siblings);\n+          }\n+        }\n+      }\n+\n+      // Check if {@code name} meets condition (c).\n+      if (name.globalSets == 0 && name.localSets == 0 &&\n+          name.localGets == 0 && name.aliasingGets == 1) {\n+        // Try to inline it.\n+        if (inlineLocalAliasIfPossible(name, namespace)) {\n+          // The only references to this name left are the inlined ones.\n+          workList.remove(name);\n+        }\n+      }\n+\n+      // Check if {@code name} has any aliases left after the\n+      // local-alias-inlining above.\n+      if ((name.type == Name.Type.OBJECTLIT ||\n+           name.type == Name.Type.FUNCTION) &&\n+          name.aliasingGets == 0 && name.props != null) {\n+        // All of {@code name}'s children meet condition (a), so they can be\n+        // added to the worklist.\n+        workList.addAll(name.props);\n+      }\n+    }\n+  }\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}