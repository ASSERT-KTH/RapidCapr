{
    "patch": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n    // check inputs\n    verifyInterval(min, max);\n    verifySequence(min, initial, max);\n\n    // initialize\n    int iteration = 0;\n    double a = min;\n    double fa = f.value(a);\n    double b = max;\n    double fb = f.value(b);\n    double c = initial;\n    double fc = f.value(c);\n    double q, r, s;\n    double d = 0, e = 0;\n\n    while (true) {\n        iteration++;\n\n        // Check if we're close enough to the root\n        if (fc == 0) {\n            setResult(c, iteration);\n            return result;\n        }\n        if (iteration > maximalIterationCount) {\n            throw new MaxIterationsExceededException(maximalIterationCount);\n        }\n\n        // Attempt inverse quadratic interpolation\n        if (fc * fb < 0) {\n            // Interpolate last three points with inverse quadratic interpolation\n            double abc = (fa * fb * fc)\n                    / ((fa - fb) * (fa - fc)) + (fb * fc * fa)\n                    / ((fb - fa) * (fb - fc)) + (fc * fa * fb)\n                    / ((fc - fa) * (fc - fb));\n            double ab, ac, bc, sig;\n            if (a > c) {\n                ab = (fa - fb) / (a - b);\n                ac = (fa - fc) / (a - c);\n                bc = (fb - fc) / (b - c);\n                sig = bc + ac;\n                q = ab * ac * abc;\n                q = sig * q - (ac * q + bc * q);\n                r = (2 * q - sig * abc) * fb;\n                s = (abc - ac - bc) * fb;\n            } else {\n                ab = (fb - fa) / (b - a);\n                ac = (fc - fa) / (c - a);\n                bc = (fc - fb) / (c - b);\n                sig = bc + ac;\n                q = ab * ac * abc;\n                q = sig * q - (ac * q + bc * q);\n                r = (2 * q - sig * abc) * fb;\n                s = (abc - ac - bc) * fb;\n            }\n\n            // Check if we can use the interpolation\n            if ((q * (a - c) < -absoluteAccuracy || q * (b - c) < -absoluteAccuracy\n                    || q * (fc - fb) < -absoluteAccuracy || q * (fc - fa) < -absoluteAccuracy) || r * s < 0) {\n                // Use bisection method\n                if (c - b > b - a) {\n                    c = (a + b) / 2;\n                } else {\n                    c = (b + c) / 2;\n                }\n            } else {\n                // Use inverse quadratic interpolation\n                d = q / s;\n                double u = c + d;\n                if ((u - b) * (u - c) <= 0) {\n                    d = (c > b) ? -Math.abs(d) : Math.abs(d);\n                    u = c + d;\n                }\n                double fu = f.value(u);\n\n                if (fu < fc) {\n                    setResult(u, iteration);\n                    return result;\n                }\n                if (fu > fb) {\n                    if (c - b > b - a) {\n                        c = a;\n                    } else {\n                        c = b;\n                    }\n                    d = e = 0;   // don't use interpolation\n                } else {\n                    d = u - c;\n                    c = u;\n                    fc = fu;\n                    if (iteration%2 == 0) {\n                        d = d/2;\n                    }\n                }\n            }\n        } else {\n            // Use bisection method\n            if (c - b > b - a) {\n                c = (a + b) / 2;\n            } else {\n                c = (b + c) / 2;\n            }\n            d = e = 0;   // don't use interpolation\n        }\n\n        // Determine how far we want to move on the next iteration\n        double sgn;\n        if (fc < 0) {\n            sgn = 1.0;\n        } else {\n            sgn = -1.0;\n        }\n        double newTol = relativeAccuracy * Math.abs(c) + absoluteAccuracy;\n        double ratio = 2 * Math.abs(fc) / (fb + Math.abs(fc));\n        if (ratio > 0.5) {\n            ratio = 1.0 - ratio;\n        }\n        double tol = newTol + ratio * (tolerance - newTol);\n        if (Math.abs(sgn * tol) <= (0.5 * e)) {\n            e = d;\n        } else {\n            e = d;\n            d = sgn * tol;\n        }\n\n        // Set next guess\n        b = c;\n        fb = fc;\n        if (Math.abs(d) > absoluteAccuracy) {\n            c += d;\n        } else {\n            if (c > (a + b) / 2) {\n                c -= absoluteAccuracy;\n            } else {\n                c += absoluteAccuracy;\n            }\n        }\n        fc = f.value(c);\n\n        // Update end-points\n        if ((fc < 0 && fb < 0) || (fc > 0 && fb > 0)) {\n            a = b;\n            fa = fb;\n            b = c;\n            fb = fc;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..d07cb0e1e 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,53 +95,155 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n+public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n+    // check inputs\n+    verifyInterval(min, max);\n+    verifySequence(min, initial, max);\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+    // initialize\n+    int iteration = 0;\n+    double a = min;\n+    double fa = f.value(a);\n+    double b = max;\n+    double fb = f.value(b);\n+    double c = initial;\n+    double fc = f.value(c);\n+    double q, r, s;\n+    double d = 0, e = 0;\n \n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n-        }\n+    while (true) {\n+        iteration++;\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+        // Check if we're close enough to the root\n+        if (fc == 0) {\n+            setResult(c, iteration);\n             return result;\n         }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+        if (iteration > maximalIterationCount) {\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n         }\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        // Attempt inverse quadratic interpolation\n+        if (fc * fb < 0) {\n+            // Interpolate last three points with inverse quadratic interpolation\n+            double abc = (fa * fb * fc)\n+                    / ((fa - fb) * (fa - fc)) + (fb * fc * fa)\n+                    / ((fb - fa) * (fb - fc)) + (fc * fa * fb)\n+                    / ((fc - fa) * (fc - fb));\n+            double ab, ac, bc, sig;\n+            if (a > c) {\n+                ab = (fa - fb) / (a - b);\n+                ac = (fa - fc) / (a - c);\n+                bc = (fb - fc) / (b - c);\n+                sig = bc + ac;\n+                q = ab * ac * abc;\n+                q = sig * q - (ac * q + bc * q);\n+                r = (2 * q - sig * abc) * fb;\n+                s = (abc - ac - bc) * fb;\n+            } else {\n+                ab = (fb - fa) / (b - a);\n+                ac = (fc - fa) / (c - a);\n+                bc = (fc - fb) / (c - b);\n+                sig = bc + ac;\n+                q = ab * ac * abc;\n+                q = sig * q - (ac * q + bc * q);\n+                r = (2 * q - sig * abc) * fb;\n+                s = (abc - ac - bc) * fb;\n+            }\n+\n+            // Check if we can use the interpolation\n+            if ((q * (a - c) < -absoluteAccuracy || q * (b - c) < -absoluteAccuracy\n+                    || q * (fc - fb) < -absoluteAccuracy || q * (fc - fa) < -absoluteAccuracy) || r * s < 0) {\n+                // Use bisection method\n+                if (c - b > b - a) {\n+                    c = (a + b) / 2;\n+                } else {\n+                    c = (b + c) / 2;\n+                }\n+            } else {\n+                // Use inverse quadratic interpolation\n+                d = q / s;\n+                double u = c + d;\n+                if ((u - b) * (u - c) <= 0) {\n+                    d = (c > b) ? -Math.abs(d) : Math.abs(d);\n+                    u = c + d;\n+                }\n+                double fu = f.value(u);\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+                if (fu < fc) {\n+                    setResult(u, iteration);\n+                    return result;\n+                }\n+                if (fu > fb) {\n+                    if (c - b > b - a) {\n+                        c = a;\n+                    } else {\n+                        c = b;\n+                    }\n+                    d = e = 0;   // don't use interpolation\n+                } else {\n+                    d = u - c;\n+                    c = u;\n+                    fc = fu;\n+                    if (iteration%2 == 0) {\n+                        d = d/2;\n+                    }\n+                }\n+            }\n+        } else {\n+            // Use bisection method\n+            if (c - b > b - a) {\n+                c = (a + b) / 2;\n+            } else {\n+                c = (b + c) / 2;\n+            }\n+            d = e = 0;   // don't use interpolation\n         }\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+        // Determine how far we want to move on the next iteration\n+        double sgn;\n+        if (fc < 0) {\n+            sgn = 1.0;\n+        } else {\n+            sgn = -1.0;\n+        }\n+        double newTol = relativeAccuracy * Math.abs(c) + absoluteAccuracy;\n+        double ratio = 2 * Math.abs(fc) / (fb + Math.abs(fc));\n+        if (ratio > 0.5) {\n+            ratio = 1.0 - ratio;\n+        }\n+        double tol = newTol + ratio * (tolerance - newTol);\n+        if (Math.abs(sgn * tol) <= (0.5 * e)) {\n+            e = d;\n+        } else {\n+            e = d;\n+            d = sgn * tol;\n         }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        // Set next guess\n+        b = c;\n+        fb = fc;\n+        if (Math.abs(d) > absoluteAccuracy) {\n+            c += d;\n+        } else {\n+            if (c > (a + b) / 2) {\n+                c -= absoluteAccuracy;\n+            } else {\n+                c += absoluteAccuracy;\n+            }\n+        }\n+        fc = f.value(c);\n \n+        // Update end-points\n+        if ((fc < 0 && fb < 0) || (fc > 0 && fb > 0)) {\n+            a = b;\n+            fa = fb;\n+            b = c;\n+            fb = fc;\n+        }\n     }\n+}\n \n     /**\n      * Find a zero in the given interval.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}