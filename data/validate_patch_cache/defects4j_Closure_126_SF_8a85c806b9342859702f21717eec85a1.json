{
    "patch": "void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (n.isReturn() || n.isBreak() || n.isContinue() || n.isThrow()) {\n      boolean tryNestedBlock = false;\n      if (n.getBooleanProp(Node.LEAP_OUT_OF_TRY_BLOCK) != null) {\n        // if this is edge of an exception block, keep in original form\n        return;\n      }\n\n      if (n.isBreak() && n.getParent() != null && n.getParent().isLoop()) {\n        // Cannot convert breaks inside a while loop to continue.\n        return;\n      }\n\n      Node replacement = null;\n      if (exitType == Token.CONTINUE) {\n        if (NodeUtil.isIterationStatement(n.getParent())) {\n          replacement = IR.continueNode(labelName);\n        }\n      } else if (exitType == Token.BREAK) {\n        replacement = IR.breakNode(labelName);\n      } else if (exitType == Token.THROW) {\n        // There's no minimizing throw statements.\n        return;\n      } else if (exitType == Token.RETURN) {\n        Node parent = n.getParent();\n        if (parent != null && !parent.isScope()) {\n          // Methods body aren't scopes\n          tryNestedBlock = parent.isTry() ? true : tryNestedAnonBlock(parent);\n        }\n        if (labelName == null) {\n          replacement = IR.returnNode(n.getFirstChild().detach());\n        }\n      } else {\n        throw new IllegalStateException(\"Unexpected exit type: \" + Token.name(exitType));\n      }\n\n      // replace current node with IF (CONDITION) { replacement } else { }\n      Node ifNode = NodeUtil.getEnclosingIfStatement(n.getParent());\n      if (ifNode != null) {\n        Node condition = n.getBooleanProp(Node.LEAP_OUT_OF_TRY_BLOCK);\n        if (condition == null && n.hasChildren()) {\n          // Then, we do not have a plain break or continue statement,\n          // instead we have a keyword that takes an argument 'labelName',\n          // like break and continue. Both of these also do plain breaking\n          // or continuing when there's no label specified. And for return\n          // statements there is no label specified.\n          Node value = n.getFirstChild();\n          if (value != null && (labelName == null || !isLabel(value, labelName))) {\n            // We have a keyword with a value \u2013 check it against the label.\n            Node compareLabelNode =\n                NodeUtil.newStringNode(\n                    compiler, String.valueOf(value.getString()), n.getLineno(), n.getCharno());\n            if (exitType == Token.RETURN) {\n              condition = IR.strictNe(IR.name(\"result\"), compareLabelNode);\n            } else {\n              condition = IR.strictNotEq(value, compareLabelNode);\n            }\n          } else if (!tryNestedBlock) {\n            // We didn't create a comparison, but if the operation is not nested in a\n            // try block, then we can simply ignore the label and use the condition.\n            condition =\n                exitType == Token.CONTINUE\n                    ? NodeUtil.getContinueTarget(n.getParent())\n                    : NodeUtil.getBreakTarget(n.getParent(), labelName);\n          }\n        }\n\n        if (replacement == null) {\n          // We didn't create a replacement but still need to remove the node.\n          // happens in the case that we break or continue into a try catch\n          // works because we need to know if we will remain in a try-catch\n          NodeUtil.removeChild(n.getParent(), n);\n        } else {\n          if (condition == null) {\n            /",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..6e06742e 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -103,102 +103,83 @@ class MinimizeExitPoints\n    *   null otherwise.\n    * @nullable labelName non-null only for breaks within labels.\n    */\n-  void tryMinimizeExits(Node n, int exitType, String labelName) {\n+void tryMinimizeExits(Node n, int exitType, String labelName) {\n \n     // Just an 'exit'.\n-    if (matchingExitNode(n, exitType, labelName)) {\n-      NodeUtil.removeChild(n.getParent(), n);\n-      compiler.reportCodeChange();\n-      return;\n-    }\n-\n-    // Just an 'if'.\n-    if (n.isIf()) {\n-      Node ifBlock = n.getFirstChild().getNext();\n-      tryMinimizeExits(ifBlock, exitType, labelName);\n-      Node elseBlock = ifBlock.getNext();\n-      if (elseBlock != null) {\n-        tryMinimizeExits(elseBlock, exitType, labelName);\n+    if (n.isReturn() || n.isBreak() || n.isContinue() || n.isThrow()) {\n+      boolean tryNestedBlock = false;\n+      if (n.getBooleanProp(Node.LEAP_OUT_OF_TRY_BLOCK) != null) {\n+        // if this is edge of an exception block, keep in original form\n+        return;\n       }\n-      return;\n-    }\n \n-    // Just a 'try/catch/finally'.\n-    if (n.isTry()) {\n-      Node tryBlock = n.getFirstChild();\n-      tryMinimizeExits(tryBlock, exitType, labelName);\n-      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n-      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n-        Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n-      }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n-      if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+      if (n.isBreak() && n.getParent() != null && n.getParent().isLoop()) {\n+        // Cannot convert breaks inside a while loop to continue.\n+        return;\n       }\n-    }\n-\n-    // Just a 'label'.\n-    if (n.isLabel()) {\n-      Node labelBlock = n.getLastChild();\n-      tryMinimizeExits(labelBlock, exitType, labelName);\n-    }\n-\n-    // TODO(johnlenz): The last case of SWITCH statement?\n-\n-    // The rest assumes a block with at least one child, bail on anything else.\n-    if (!n.isBlock() || n.getLastChild() == null) {\n-      return;\n-    }\n-\n-    // Multiple if-exits can be converted in a single pass.\n-    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n \n-      // An 'if' block to process below.\n-      if (c.isIf()) {\n-        Node ifTree = c;\n-        Node trueBlock, falseBlock;\n-\n-        // First, the true condition block.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n-\n-        // Now the else block.\n-        // The if blocks may have changed, get them again.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n+      Node replacement = null;\n+      if (exitType == Token.CONTINUE) {\n+        if (NodeUtil.isIterationStatement(n.getParent())) {\n+          replacement = IR.continueNode(labelName);\n+        }\n+      } else if (exitType == Token.BREAK) {\n+        replacement = IR.breakNode(labelName);\n+      } else if (exitType == Token.THROW) {\n+        // There's no minimizing throw statements.\n+        return;\n+      } else if (exitType == Token.RETURN) {\n+        Node parent = n.getParent();\n+        if (parent != null && !parent.isScope()) {\n+          // Methods body aren't scopes\n+          tryNestedBlock = parent.isTry() ? true : tryNestedAnonBlock(parent);\n         }\n+        if (labelName == null) {\n+          replacement = IR.returnNode(n.getFirstChild().detach());\n+        }\n+      } else {\n+        throw new IllegalStateException(\"Unexpected exit type: \" + Token.name(exitType));\n       }\n \n-      if (c == n.getLastChild()) {\n-        break;\n-      }\n-    }\n+      // replace current node with IF (CONDITION) { replacement } else { }\n+      Node ifNode = NodeUtil.getEnclosingIfStatement(n.getParent());\n+      if (ifNode != null) {\n+        Node condition = n.getBooleanProp(Node.LEAP_OUT_OF_TRY_BLOCK);\n+        if (condition == null && n.hasChildren()) {\n+          // Then, we do not have a plain break or continue statement,\n+          // instead we have a keyword that takes an argument 'labelName',\n+          // like break and continue. Both of these also do plain breaking\n+          // or continuing when there's no label specified. And for return\n+          // statements there is no label specified.\n+          Node value = n.getFirstChild();\n+          if (value != null && (labelName == null || !isLabel(value, labelName))) {\n+            // We have a keyword with a value \u2013 check it against the label.\n+            Node compareLabelNode =\n+                NodeUtil.newStringNode(\n+                    compiler, String.valueOf(value.getString()), n.getLineno(), n.getCharno());\n+            if (exitType == Token.RETURN) {\n+              condition = IR.strictNe(IR.name(\"result\"), compareLabelNode);\n+            } else {\n+              condition = IR.strictNotEq(value, compareLabelNode);\n+            }\n+          } else if (!tryNestedBlock) {\n+            // We didn't create a comparison, but if the operation is not nested in a\n+            // try block, then we can simply ignore the label and use the condition.\n+            condition =\n+                exitType == Token.CONTINUE\n+                    ? NodeUtil.getContinueTarget(n.getParent())\n+                    : NodeUtil.getBreakTarget(n.getParent(), labelName);\n+          }\n+        }\n \n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n-    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n-        break;\n-      }\n-    }\n-  }\n+        if (replacement == null) {\n+          // We didn't create a replacement but still need to remove the node.\n+          // happens in the case that we break or continue into a try catch\n+          // works because we need to know if we will remain in a try-catch\n+          NodeUtil.removeChild(n.getParent(), n);\n+        } else {\n+          if (condition == null) {\n+            /\n \n   /**\n    * Look for exits (returns, breaks, or continues, depending on the context) at",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}