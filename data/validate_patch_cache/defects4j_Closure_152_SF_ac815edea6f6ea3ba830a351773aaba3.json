{
    "patch": "@Test\npublic void testIssue794b() {\n  Compiler compiler = new Compiler();\n  compiler.compile(\n      ImmutableList.of(\n          SourceFile.fromCode(\n              \"input\", \"try { throw new Error(); } catch (e) { e.toString() }\")),\n      ImmutableList.of(SourceFile.fromJS(\"externs\", \"var console = {};\")));\n  Node cfg = ControlFlowGraphBuilder.build(compiler, 0);\n\n  // Create verified CFG.\n  StringBuilder sb = new StringBuilder();\n  DotFormatter<Node, ControlFlowGraph.Branch> formatter =\n      new DotFormatter<Node, ControlFlowGraph.Branch>() {\n    @Override\n    public String getNodeLabel(Node node) {\n      return node.toString();\n    }\n\n    @Override\n    public Iterable<ControlFlowGraph.Branch> getEdgeLabels(\n        DiGraphEdge<Node, ControlFlowGraph.Branch> edge) {\n      return ImmutableList.of(edge.getValue());\n    }\n  };\n  sb.append(formatter.toDot(cfg));\n\n  assertThat(sb.toString()).contains(\"-> ExceptionHandler\\n\");\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/FunctionType.java b/src/com/google/javascript/rhino/jstype/FunctionType.java\nindex fc2578d8..eb4a7573 100644\n--- a/src/com/google/javascript/rhino/jstype/FunctionType.java\n+++ b/src/com/google/javascript/rhino/jstype/FunctionType.java\n@@ -859,37 +859,35 @@ public class FunctionType extends PrototypeObjectType {\n   }\n \n   @Override\n-  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> scope) {\n-    setResolvedTypeInternal(this);\n-\n-    call = (ArrowType) safeResolve(call, t, scope);\n-    prototype = (FunctionPrototypeType) safeResolve(prototype, t, scope);\n-\n-    // Warning about typeOfThis if it doesn't resolve to an ObjectType\n-    // is handled further upstream.\n-    // TODO(nicksantos): Handle this correctly if we have a UnionType.\n-    typeOfThis = (ObjectType) safeResolve(typeOfThis, t, scope);\n-\n-    boolean changed = false;\n-    ImmutableList.Builder<ObjectType> resolvedInterfaces =\n-        ImmutableList.builder();\n-    for (ObjectType iface : implementedInterfaces) {\n-      ObjectType resolvedIface = (ObjectType) iface.resolve(t, scope);\n-      resolvedInterfaces.add(resolvedIface);\n-      changed |= (resolvedIface != iface);\n-    }\n-    if (changed) {\n-      implementedInterfaces = resolvedInterfaces.build();\n-    }\n-\n-    if (subTypes != null) {\n-      for (int i = 0; i < subTypes.size(); i++) {\n-        subTypes.set(i, (FunctionType) subTypes.get(i).resolve(t, scope));\n-      }\n-    }\n-\n-    return super.resolveInternal(t, scope);\n-  }\n+@Test\n+public void testIssue794b() {\n+  Compiler compiler = new Compiler();\n+  compiler.compile(\n+      ImmutableList.of(\n+          SourceFile.fromCode(\n+              \"input\", \"try { throw new Error(); } catch (e) { e.toString() }\")),\n+      ImmutableList.of(SourceFile.fromJS(\"externs\", \"var console = {};\")));\n+  Node cfg = ControlFlowGraphBuilder.build(compiler, 0);\n+\n+  // Create verified CFG.\n+  StringBuilder sb = new StringBuilder();\n+  DotFormatter<Node, ControlFlowGraph.Branch> formatter =\n+      new DotFormatter<Node, ControlFlowGraph.Branch>() {\n+    @Override\n+    public String getNodeLabel(Node node) {\n+      return node.toString();\n+    }\n+\n+    @Override\n+    public Iterable<ControlFlowGraph.Branch> getEdgeLabels(\n+        DiGraphEdge<Node, ControlFlowGraph.Branch> edge) {\n+      return ImmutableList.of(edge.getValue());\n+    }\n+  };\n+  sb.append(formatter.toDot(cfg));\n+\n+  assertThat(sb.toString()).contains(\"-> ExceptionHandler\\n\");\n+}\n \n   @Override\n   public String toDebugHashCodeString() {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}