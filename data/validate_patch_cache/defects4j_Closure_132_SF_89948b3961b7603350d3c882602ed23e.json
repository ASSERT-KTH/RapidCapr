{
    "patch": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n\n    // !x if block has two children, skip it for now\n    Node cond = n.getFirstChild();\n    if (NodeUtil.isFalse(cond) && n.getLastChild().isEmpty()) {\n      return n;\n    }\n\n    Node thenBranch = n.getSecondChild();\n    Node elseBranch = n.getLastChild();\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n\n    if (hasBlockLevelSideEffect(thenBranch) ||\n        (elseBranch != null &&\n         hasBlockLevelSideEffect(elseBranch))) {\n      // can't optimize\n      if (!thenBranch.isEmpty()) {\n        tryMinimizeCondition(cond, thenBranch);\n      }\n      if (elseBranch != null && !elseBranch.isEmpty()) {\n        tryMinimizeCondition(\n            NodeUtil.getOpSiteConditional(n),\n            elseBranch);\n      }\n      return n;\n    }\n\n    boolean canOptimizeIfLogic = n.isIf() &&\n        elseBranch != null &&\n        hasBlockLevelSideEffect(elseBranch) &&\n        !(isExpressionBlock(thenBranch) ||\n          isExpressionBlock(elseBranch)) &&\n        (parent == null || parent.isExprResult());\n\n    Node newCond = NodeUtil.trySimplifyNode(cond);\n    if (!newCond.isEquivalentTo(cond)) {\n      // The value of the condition changed.\n      if (n.isIf()) {\n        Node notCond = NodeUtil.negateCondition(newCond);\n        n.replaceChild(cond, notCond);\n        notCond.srcrefTreeIfMissing(cond);\n        parent.replaceChild(n, IR.comma(notCond.detachFromParent(), n));\n        reportCodeChange();\n      } else {\n        n.replaceChild(cond, newCond);\n        newCond.srcrefTreeIfMissing(cond);\n        reportCodeChange();\n      }\n\n      cond = newCond;\n      thenBranch = n.getSecondChild();\n      elseBranch = n.getLastChild();\n      thenBranchIsVar = isVarBlock(thenBranch);\n      canOptimizeIfLogic = n.isIf() &&\n          elseBranch != null &&\n          hasBlockLevelSideEffect(elseBranch) &&\n          !(isExpressionBlock(thenBranch) ||\n            isExpressionBlock(elseBranch)) &&\n          (parent == null || parent.isExprResult());\n    }\n\n    if (!cond.isName() || !canOptimizeIfLogic) {\n      // Only try next optimization if the conditional is a name or\n      // wasn't the right form for try optimizeIfLogic.\n      tryMinimizeCondition(cond, thenBranch);\n      if (elseBranch != null) {\n        tryMinimizeCondition(\n            NodeUtil.getOpSiteConditional(n),\n            elseBranch);\n      }\n      return n;\n    }\n\n    Node maybeAssign = null;\n    Node maybeVar = null;\n    Node assignNameNode = null;\n\n    // Check to see if the variable is assigned before or after the\n    // if block and only once.\n    Node temp = n.getNext();\n    while (temp != null && isSyntheticBlock(temp)) {\n      temp = temp.getNext();\n    }\n    if (temp != null && isAssignmentTo(temp, cond.getString())) {\n      Node expr = temp.getFirstChild().getNext();\n\n      boolean otherUses = NodeUtil.hasReference(\n          NodeUtil.getEnclosingStatement(temp), cond.getString(),\n          n);\n      if (!otherUses && !mayHaveSideEffects(expr)) {\n        maybeAssign = temp;\n      }\n    } else {\n      temp = n.getPrevious();\n      while (temp != null && isSyntheticBlock(temp)) {\n        temp = temp.getPrevious();\n      }\n      if (temp != null && isAssignmentTo(temp, cond.getString())) {\n        Node expr = temp.getFirstChild().getNext();\n        if (!NodeUtil.hasReference(\n                NodeUtil.getEnclosingStatement(temp),\n                cond.getString(),\n                n) &&\n            !mayHaveSideEffects(expr)) {\n          maybeAssign = temp;\n        }\n      }\n\n      if (maybeAssign == null && thenBranchIsVar) {\n        // Skip checking\n        // var a = 123; if (a) { ... }\n        // but check where the block isn't only a variable initializer\n        // var a = 123, b, c;\n        // if (a) { ... }\n        Node maybeVarNode = this.getBlockVar(thenBranch);\n        if (maybeVarNode != null &&\n            maybeVarNode.getPrevious() == null) {\n          maybeVar = maybeVarNode;\n          assignNameNode = maybeVar.getFirstChild();\n        }\n      }\n    }\n\n    if (maybeAssign != null) {\n      // The variable is assigned somewhere outside of the if block and\n      // only once.\n      Node assign = maybeAssign.getFirstChild();\n      Node expr = assign.getNext().detach();\n      Node op = assign.getFirstChild();\n      Node nameNode = op.getNext().detach();\n\n      boolean canOptimize =\n          op.getType() == Token.ASSIGN &&\n          assignNameNode == null ||\n          assignNameNode.getString().equals(nameNode.getString());\n\n      if (canOptimize) {\n        Node replacementNode =\n            IR.assign(\n                  nameNode,\n                  IR.hook(\n                        IR.name(cond.getString()), thenBranch.detach(), expr)\n                      .srcref(n))\n                .srcref(n);\n        maybeAssign.getParent().replaceChild(maybeAssign,\n            replacementNode);\n        reportCodeChange();\n        return replacementNode;\n      }\n    } else if (maybeVar != null) {\n      Var var;\n\n      // Remove the variable declaration from before the block\n      Node insertAfter = NodeUtil.getEnclosingStatement(n);\n      Node block = n;\n\n      boolean isExpression = false;\n      Node maybeExprResult = parent != null ? parent : n;\n\n      if (maybeExprResult.isExprResult()) {\n        Node insertBefore = maybeExprResult;\n        for (Node temp = maybeExprResult.getParent();\n             temp.isExprResult() || temp.isBlock();\n             temp = temp.getParent()) {\n          insertBefore = temp;\n        }\n\n        if (parent == null) {\n          // Convert the IF node into an AND node\n          Node newNode = IR.and(\n              IR.name(cond.getString()),\n              block.detach())\n                  .srcref(n);\n\n          statementNodesToRemove.add(block);\n\n          parent = IR.exprResult(newNode).srcref(n);\n          isExpression = true;\n        } else {\n          // IF node is a child of a COMMA operator, replace it\n          // with an AND operator.\n          Node newNode = IR.and(\n              IR.name(cond.getString()),\n              block.detach())\n                  .srcref(n);\n          parent.replaceChild(n, newNode);\n          isExpression = true;\n        }\n\n        // Add the VAR node\n        Node varNode = maybeVar.cloneTree();\n        Node next = maybeVar.getNext();\n        Node detachedVarNode =\n            IR.var(varNode.getFirstChild().detach(), varNode)\n                .srcref(maybeVar);\n        if (isExpression) {\n          reportCodeChange();\n        }\n        parent.getParent().addChildAfter(\n            detachedVarNode, insertBefore);\n        var = scope.getVar(varNode.getString());\n        varNode.detachFromParent();\n        maybeVar.detachFromParent();\n\n        n = insertAfter;\n        while (n.getNext() != null && isSyntheticBlock(n.getNext())) {\n          n = n.getNext();\n        }\n\n        // Insert the variable into the while expression instead\n        Node lhs = IR.name(var.getName()).srcrefTreeIfMissing(\n            varNode);\n        Node rhs = maybeVar.getFirstFirstChild().detach();\n        Node newExpression = IR.exprResult(\n                IR.assign(lhs, rhs).srcref(maybeVar))\n            .srcref(maybeVar);\n        n.getParent().addChildAfter(newExpression, n);\n\n        if (var.isZapped()) {\n          var.clearZapped();\n        }\n\n        compiler.reportChangeToEnclosingScope(detachedVarNode);\n        return parent;\n      }\n    }\n\n    // If the block is too big, then this isn't worth it. We don't\n    // want to create a monster, if block cloning is expensive (which\n    // it is).\n    if (NodeUtil.countAstSize(thenBranch) +\n        (elseBranch == null ? 0 : NodeUtil.countAstSize(elseBranch)) >\n        MAX_STATEMENTS_TO_OPTIMIZE) {\n      return n;\n    }\n\n    // If the variable is read before the if block itself.\n    // var x = ...;\n    // if (x) { ... }\n    // ... x ...\n    // doesn't count for now since we don't have this information\n    // readily available. Instead, try optimizing anyway and issue\n    // a warning if we break something.\n    if (elseBranch == null && !thenBranchIsVar) {\n      // Optimize ternary-like logical expressions:\n      // x ? true : false  -> !! x\n      // x ? false : true  -> ! x\n      if (isExpressionBlock(thenBranch)) {\n        Node simple = tryFoldLogicalExpression(n);\n        if (simple != null) {\n          return simple;\n        }\n\n        // x ? expr : y ? expr2 : expr3\n        //   -> x ? expr : expr(y ? expr2 ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..ab992945 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -633,239 +633,262 @@ class PeepholeSubstituteAlternateSyntax\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n-  private Node tryMinimizeIf(Node n) {\n-\n+private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n \n+    // !x if block has two children, skip it for now\n     Node cond = n.getFirstChild();\n-\n-    /* If the condition is a literal, we'll let other\n-     * optimizations try to remove useless code.\n-     */\n-    if (NodeUtil.isLiteralValue(cond, true)) {\n+    if (NodeUtil.isFalse(cond) && n.getLastChild().isEmpty()) {\n       return n;\n     }\n \n-    Node thenBranch = cond.getNext();\n-    Node elseBranch = thenBranch.getNext();\n-\n-    if (elseBranch == null) {\n-      if (isFoldableExpressBlock(thenBranch)) {\n-        Node expr = getBlockExpression(thenBranch);\n-        if (!late && isPropertyAssignmentInExpression(expr)) {\n-          // Keep opportunities for CollapseProperties such as\n-          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-          // until CollapseProperties has been run.\n-          return n;\n-        }\n-\n-        if (cond.isNot()) {\n-          // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n-            return n;\n-          }\n-\n-          Node or = IR.or(\n-              cond.removeFirstChild(),\n-              expr.removeFirstChild()).srcref(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          reportCodeChange();\n-\n-          return newExpr;\n-        }\n+    Node thenBranch = n.getSecondChild();\n+    Node elseBranch = n.getLastChild();\n+    boolean thenBranchIsVar = isVarBlock(thenBranch);\n \n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses is worth the change even if\n-          // there is no immediate code size win. However, two extra pair of\n-          // {}, we would have to think twice. (unless we know for sure the\n-          // we can further optimize its parent.\n-          return n;\n-        }\n+    if (hasBlockLevelSideEffect(thenBranch) ||\n+        (elseBranch != null &&\n+         hasBlockLevelSideEffect(elseBranch))) {\n+      // can't optimize\n+      if (!thenBranch.isEmpty()) {\n+        tryMinimizeCondition(cond, thenBranch);\n+      }\n+      if (elseBranch != null && !elseBranch.isEmpty()) {\n+        tryMinimizeCondition(\n+            NodeUtil.getOpSiteConditional(n),\n+            elseBranch);\n+      }\n+      return n;\n+    }\n \n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n+    boolean canOptimizeIfLogic = n.isIf() &&\n+        elseBranch != null &&\n+        hasBlockLevelSideEffect(elseBranch) &&\n+        !(isExpressionBlock(thenBranch) ||\n+          isExpressionBlock(elseBranch)) &&\n+        (parent == null || parent.isExprResult());\n+\n+    Node newCond = NodeUtil.trySimplifyNode(cond);\n+    if (!newCond.isEquivalentTo(cond)) {\n+      // The value of the condition changed.\n+      if (n.isIf()) {\n+        Node notCond = NodeUtil.negateCondition(newCond);\n+        n.replaceChild(cond, notCond);\n+        notCond.srcrefTreeIfMissing(cond);\n+        parent.replaceChild(n, IR.comma(notCond.detachFromParent(), n));\n         reportCodeChange();\n-\n-        return newExpr;\n       } else {\n-\n-        // Try to combine two IF-ELSE\n-        if (NodeUtil.isStatementBlock(thenBranch) &&\n-            thenBranch.hasOneChild()) {\n-          Node innerIf = thenBranch.getFirstChild();\n-\n-          if (innerIf.isIf()) {\n-            Node innerCond = innerIf.getFirstChild();\n-            Node innerThenBranch = innerCond.getNext();\n-            Node innerElseBranch = innerThenBranch.getNext();\n-\n-            if (innerElseBranch == null &&\n-                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n-              n.detachChildren();\n-              n.addChildToBack(\n-                  IR.and(\n-                      cond,\n-                      innerCond.detachFromParent())\n-                      .srcref(cond));\n-              n.addChildrenToBack(innerThenBranch.detachFromParent());\n-              reportCodeChange();\n-              // Not worth trying to fold the current IF-ELSE into && because\n-              // the inner IF-ELSE wasn't able to be folded into && anyways.\n-              return n;\n-            }\n-          }\n-        }\n+        n.replaceChild(cond, newCond);\n+        newCond.srcrefTreeIfMissing(cond);\n+        reportCodeChange();\n       }\n \n-      return n;\n+      cond = newCond;\n+      thenBranch = n.getSecondChild();\n+      elseBranch = n.getLastChild();\n+      thenBranchIsVar = isVarBlock(thenBranch);\n+      canOptimizeIfLogic = n.isIf() &&\n+          elseBranch != null &&\n+          hasBlockLevelSideEffect(elseBranch) &&\n+          !(isExpressionBlock(thenBranch) ||\n+            isExpressionBlock(elseBranch)) &&\n+          (parent == null || parent.isExprResult());\n     }\n \n-    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n-     * peephole optimization. This should probably get moved to another pass.\n-     */\n-    tryRemoveRepeatedStatements(n);\n-\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      reportCodeChange();\n+    if (!cond.isName() || !canOptimizeIfLogic) {\n+      // Only try next optimization if the conditional is a name or\n+      // wasn't the right form for try optimizeIfLogic.\n+      tryMinimizeCondition(cond, thenBranch);\n+      if (elseBranch != null) {\n+        tryMinimizeCondition(\n+            NodeUtil.getOpSiteConditional(n),\n+            elseBranch);\n+      }\n       return n;\n     }\n \n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-      Node thenExpr = getBlockReturnExpression(thenBranch);\n-      Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n-                                .srcref(n));\n-      parent.replaceChild(n, returnNode);\n-      reportCodeChange();\n-      return returnNode;\n-    }\n+    Node maybeAssign = null;\n+    Node maybeVar = null;\n+    Node assignNameNode = null;\n \n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-      if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n-        if (NodeUtil.isAssignmentOp(thenOp)) {\n-          Node lhs = thenOp.getFirstChild();\n-          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n-            reportCodeChange();\n+    // Check to see if the variable is assigned before or after the\n+    // if block and only once.\n+    Node temp = n.getNext();\n+    while (temp != null && isSyntheticBlock(temp)) {\n+      temp = temp.getNext();\n+    }\n+    if (temp != null && isAssignmentTo(temp, cond.getString())) {\n+      Node expr = temp.getFirstChild().getNext();\n+\n+      boolean otherUses = NodeUtil.hasReference(\n+          NodeUtil.getEnclosingStatement(temp), cond.getString(),\n+          n);\n+      if (!otherUses && !mayHaveSideEffects(expr)) {\n+        maybeAssign = temp;\n+      }\n+    } else {\n+      temp = n.getPrevious();\n+      while (temp != null && isSyntheticBlock(temp)) {\n+        temp = temp.getPrevious();\n+      }\n+      if (temp != null && isAssignmentTo(temp, cond.getString())) {\n+        Node expr = temp.getFirstChild().getNext();\n+        if (!NodeUtil.hasReference(\n+                NodeUtil.getEnclosingStatement(temp),\n+                cond.getString(),\n+                n) &&\n+            !mayHaveSideEffects(expr)) {\n+          maybeAssign = temp;\n+        }\n+      }\n \n-            return expr;\n-          }\n+      if (maybeAssign == null && thenBranchIsVar) {\n+        // Skip checking\n+        // var a = 123; if (a) { ... }\n+        // but check where the block isn't only a variable initializer\n+        // var a = 123, b, c;\n+        // if (a) { ... }\n+        Node maybeVarNode = this.getBlockVar(thenBranch);\n+        if (maybeVarNode != null &&\n+            maybeVarNode.getPrevious() == null) {\n+          maybeVar = maybeVarNode;\n+          assignNameNode = maybeVar.getFirstChild();\n         }\n       }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n-      reportCodeChange();\n-      return expr;\n     }\n \n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n+    if (maybeAssign != null) {\n+      // The variable is assigned somewhere outside of the if block and\n+      // only once.\n+      Node assign = maybeAssign.getFirstChild();\n+      Node expr = assign.getNext().detach();\n+      Node op = assign.getFirstChild();\n+      Node nameNode = op.getNext().detach();\n+\n+      boolean canOptimize =\n+          op.getType() == Token.ASSIGN &&\n+          assignNameNode == null ||\n+          assignNameNode.getString().equals(nameNode.getString());\n+\n+      if (canOptimize) {\n+        Node replacementNode =\n+            IR.assign(\n+                  nameNode,\n+                  IR.hook(\n+                        IR.name(cond.getString()), thenBranch.detach(), expr)\n+                      .srcref(n))\n+                .srcref(n);\n+        maybeAssign.getParent().replaceChild(maybeAssign,\n+            replacementNode);\n         reportCodeChange();\n-        return var;\n+        return replacementNode;\n       }\n+    } else if (maybeVar != null) {\n+      Var var;\n+\n+      // Remove the variable declaration from before the block\n+      Node insertAfter = NodeUtil.getEnclosingStatement(n);\n+      Node block = n;\n+\n+      boolean isExpression = false;\n+      Node maybeExprResult = parent != null ? parent : n;\n+\n+      if (maybeExprResult.isExprResult()) {\n+        Node insertBefore = maybeExprResult;\n+        for (Node temp = maybeExprResult.getParent();\n+             temp.isExprResult() || temp.isBlock();\n+             temp = temp.getParent()) {\n+          insertBefore = temp;\n+        }\n \n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n+        if (parent == null) {\n+          // Convert the IF node into an AND node\n+          Node newNode = IR.and(\n+              IR.name(cond.getString()),\n+              block.detach())\n+                  .srcref(n);\n \n-        return var;\n+          statementNodesToRemove.add(block);\n+\n+          parent = IR.exprResult(newNode).srcref(n);\n+          isExpression = true;\n+        } else {\n+          // IF node is a child of a COMMA operator, replace it\n+          // with an AND operator.\n+          Node newNode = IR.and(\n+              IR.name(cond.getString()),\n+              block.detach())\n+                  .srcref(n);\n+          parent.replaceChild(n, newNode);\n+          isExpression = true;\n+        }\n+\n+        // Add the VAR node\n+        Node varNode = maybeVar.cloneTree();\n+        Node next = maybeVar.getNext();\n+        Node detachedVarNode =\n+            IR.var(varNode.getFirstChild().detach(), varNode)\n+                .srcref(maybeVar);\n+        if (isExpression) {\n+          reportCodeChange();\n+        }\n+        parent.getParent().addChildAfter(\n+            detachedVarNode, insertBefore);\n+        var = scope.getVar(varNode.getString());\n+        varNode.detachFromParent();\n+        maybeVar.detachFromParent();\n+\n+        n = insertAfter;\n+        while (n.getNext() != null && isSyntheticBlock(n.getNext())) {\n+          n = n.getNext();\n+        }\n+\n+        // Insert the variable into the while expression instead\n+        Node lhs = IR.name(var.getName()).srcrefTreeIfMissing(\n+            varNode);\n+        Node rhs = maybeVar.getFirstFirstChild().detach();\n+        Node newExpression = IR.exprResult(\n+                IR.assign(lhs, rhs).srcref(maybeVar))\n+            .srcref(maybeVar);\n+        n.getParent().addChildAfter(newExpression, n);\n+\n+        if (var.isZapped()) {\n+          var.clearZapped();\n+        }\n+\n+        compiler.reportChangeToEnclosingScope(detachedVarNode);\n+        return parent;\n       }\n     }\n \n-    return n;\n-  }\n+    // If the block is too big, then this isn't worth it. We don't\n+    // want to create a monster, if block cloning is expensive (which\n+    // it is).\n+    if (NodeUtil.countAstSize(thenBranch) +\n+        (elseBranch == null ? 0 : NodeUtil.countAstSize(elseBranch)) >\n+        MAX_STATEMENTS_TO_OPTIMIZE) {\n+      return n;\n+    }\n+\n+    // If the variable is read before the if block itself.\n+    // var x = ...;\n+    // if (x) { ... }\n+    // ... x ...\n+    // doesn't count for now since we don't have this information\n+    // readily available. Instead, try optimizing anyway and issue\n+    // a warning if we break something.\n+    if (elseBranch == null && !thenBranchIsVar) {\n+      // Optimize ternary-like logical expressions:\n+      // x ? true : false  -> !! x\n+      // x ? false : true  -> ! x\n+      if (isExpressionBlock(thenBranch)) {\n+        Node simple = tryFoldLogicalExpression(n);\n+        if (simple != null) {\n+          return simple;\n+        }\n+\n+        // x ? expr : y ? expr2 : expr3\n+        //   -> x ? expr : expr(y ? expr2 \n \n   /**\n    * Try to remove duplicate statements from IF blocks. For example:",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}