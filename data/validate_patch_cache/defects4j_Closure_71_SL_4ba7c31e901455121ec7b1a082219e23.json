{
    "patch": "  /**\n   * Checks the visibility of properties accessed via \"getprop\" nodes.\n   */\n  private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n    ObjectType objectType = ObjectType.cast(\n        dereference(getprop.getFirstChild().getJSType()));\n    String propertyName = getprop.getLastChild().getString();\n\n    if (objectType != null) {\n      // Determine if this is an attempt to override an existing property.\n      boolean isOverride =\n          parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop &&\n              // Don't report errors for `this.PROPERTY = someValue;` inside constructor.\n              (currentClass == null || !t.isConstructor()) &&\n              // Don't report errors for `Foo.prototype.PROPERTY = someValue;`.\n              (currentClass == null || !currentClass.isConstructor());\n\n      // Find the lowest property defined on a class with visibility information.\n      Visibility lowestVisibility = Visibility.INHERITED;\n      ObjectType lowestVisibilityObjectType = null;\n      for (ObjectType o = objectType; o != null && o.getImplicitPrototype() != null;\n           o = o.getImplicitPrototype()) {\n        JSDocInfo docInfo = o.getOwnPropertyJSDocInfo(propertyName);\n        if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n          lowestVisibility = docInfo.getVisibility();\n          lowestVisibilityObjectType = o;\n        }\n      }\n\n      if (lowestVisibility == Visibility.INHERITED) {\n        // We couldn't find a visibility modifier; assume it's public.\n        return;\n      }\n\n      if (isOverride) {\n        // Check an ASSIGN statement that's trying to override a property\n        // on a superclass.\n        JSDocInfo overridingInfo = parent.getJSDocInfo();\n        Visibility overridingVisibility = overridingInfo == null\n            ? Visibility.INHERITED : overridingInfo.getVisibility();\n        if (lowestVisibility == Visibility.PRIVATE && !t.getInput().getName()\n            .equals(lowestVisibilityObjectType.getSourceName())) {\n          compiler.report(\n              t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n        } else if (overridingVisibility != Visibility.INHERITED\n            && overridingVisibility != lowestVisibility) {\n          compiler.report(\n              t.makeError(getprop, VISIBILITY_MISMATCH, lowestVisibility.name(),\n                  objectType.toString(), overridingVisibility.name()));\n        }\n      } else {\n        if (lowestVisibility == Visibility.PRIVATE\n            && !t.getInput().getName().equals(lowestVisibilityObjectType.getSourceName())\n            && (currentClass == null\n                || !normalizeClassType(objectType).differsFrom(currentClass))) {\n          boolean accessFromValidOutOfRange =\n              isValidPrivateAccessFromEnclosingClass(objectType, t.getScope());\n          if (!accessFromValidOutOfRange) {\n            compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName,\n                validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n          }\n        } else if (lowestVisibility == Visibility.PROTECTED) {\n          if (currentClass == null || !currentClass.isSubtype(objectType)) {\n            compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName,\n                validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n          }\n        }\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckAccessControls.java b/src/com/google/javascript/jscomp/CheckAccessControls.java\nindex b23fd7af..d208e9fc 100644\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n@@ -413,7 +413,76 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+  /**\n+   * Checks the visibility of properties accessed via \"getprop\" nodes.\n+   */\n+  private void checkPropertyVisibility(NodeTraversal t, Node getprop, Node parent) {\n+    ObjectType objectType = ObjectType.cast(\n+        dereference(getprop.getFirstChild().getJSType()));\n+    String propertyName = getprop.getLastChild().getString();\n+\n+    if (objectType != null) {\n+      // Determine if this is an attempt to override an existing property.\n+      boolean isOverride =\n+          parent.getType() == Token.ASSIGN && parent.getFirstChild() == getprop &&\n+              // Don't report errors for `this.PROPERTY = someValue;` inside constructor.\n+              (currentClass == null || !t.isConstructor()) &&\n+              // Don't report errors for `Foo.prototype.PROPERTY = someValue;`.\n+              (currentClass == null || !currentClass.isConstructor());\n+\n+      // Find the lowest property defined on a class with visibility information.\n+      Visibility lowestVisibility = Visibility.INHERITED;\n+      ObjectType lowestVisibilityObjectType = null;\n+      for (ObjectType o = objectType; o != null && o.getImplicitPrototype() != null;\n+           o = o.getImplicitPrototype()) {\n+        JSDocInfo docInfo = o.getOwnPropertyJSDocInfo(propertyName);\n+        if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+          lowestVisibility = docInfo.getVisibility();\n+          lowestVisibilityObjectType = o;\n+        }\n+      }\n+\n+      if (lowestVisibility == Visibility.INHERITED) {\n+        // We couldn't find a visibility modifier; assume it's public.\n+        return;\n+      }\n+\n+      if (isOverride) {\n+        // Check an ASSIGN statement that's trying to override a property\n+        // on a superclass.\n+        JSDocInfo overridingInfo = parent.getJSDocInfo();\n+        Visibility overridingVisibility = overridingInfo == null\n+            ? Visibility.INHERITED : overridingInfo.getVisibility();\n+        if (lowestVisibility == Visibility.PRIVATE && !t.getInput().getName()\n+            .equals(lowestVisibilityObjectType.getSourceName())) {\n+          compiler.report(\n+              t.makeError(getprop, PRIVATE_OVERRIDE, objectType.toString()));\n+        } else if (overridingVisibility != Visibility.INHERITED\n+            && overridingVisibility != lowestVisibility) {\n+          compiler.report(\n+              t.makeError(getprop, VISIBILITY_MISMATCH, lowestVisibility.name(),\n+                  objectType.toString(), overridingVisibility.name()));\n+        }\n+      } else {\n+        if (lowestVisibility == Visibility.PRIVATE\n+            && !t.getInput().getName().equals(lowestVisibilityObjectType.getSourceName())\n+            && (currentClass == null\n+                || !normalizeClassType(objectType).differsFrom(currentClass))) {\n+          boolean accessFromValidOutOfRange =\n+              isValidPrivateAccessFromEnclosingClass(objectType, t.getScope());\n+          if (!accessFromValidOutOfRange) {\n+            compiler.report(t.makeError(getprop, BAD_PRIVATE_PROPERTY_ACCESS, propertyName,\n+                validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+          }\n+        } else if (lowestVisibility == Visibility.PROTECTED) {\n+          if (currentClass == null || !currentClass.isSubtype(objectType)) {\n+            compiler.report(t.makeError(getprop, BAD_PROTECTED_PROPERTY_ACCESS, propertyName,\n+                validator.getReadableJSTypeName(getprop.getFirstChild(), true)));\n+          }\n+        }\n+      }\n+    }\n+  }\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}