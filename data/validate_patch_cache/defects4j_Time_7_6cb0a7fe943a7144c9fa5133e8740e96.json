{
    "patch": "    public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n        Chronology chrono = bucket.getChronology();\n        int currentPos = position;\n        int[] savedFields = (iPivotYear == null ? null : new int[bucket.size()]);\n        \n        if (savedFields != null) {\n            for (int i = 0; i < savedFields.length; i++) {\n                DateTimeField field = bucket.getField(i);\n                if (field == null || !field.isSupported()) {\n                    savedFields[i] = Integer.MIN_VALUE;\n                } else {\n                    savedFields[i] = bucket.getValue(i);\n                }\n            }\n        }\n        \n        int newFieldPos = currentPos;\n        boolean complete = false;\n        while (currentPos < text.length()) {\n            if (savedFields != null && newFieldPos > currentPos) {\n                for (int i = 0; i < savedFields.length; i++) {\n                    DateTimeField field = bucket.getField(i);\n                    if (field != null && field.isSupported()) {\n                        int oldVal = bucket.setField(field, savedFields[i]);\n                        if (oldVal < savedFields[i]) {\n                            newFieldPos = currentPos;\n                            break;\n                        }\n                    }\n                }\n            }\n            \n            int parseStart = currentPos;\n            DateTimeParser current = parser;\n            int originalBucketSize = bucket.size();\n            int newPosition = current.parseInto(bucket, text, currentPos);\n            if (newPosition >= currentPos) {\n                if (newPosition > currentPos) {\n                    newFieldPos = newPosition;\n                } else if (newFieldPos <= currentPos) {\n                    // Allows a recursive parser to make no progress on second call.\n                    // e.g. \"\" + timeParser + simpleTime\n                    newFieldPos = currentPos + 1;\n                }\n                if (originalBucketSize == bucket.size()) {\n                    throw new IllegalArgumentException(\n                        \"No method to determine \" + bucket.getCurrentFieldName());\n                }\n                continue;\n            }\n            \n            if (newPosition < 0) {\n                currentPos = ~newPosition;\n                if (currentPos > parseStart + 1 && current.peekSigned()) {\n                    currentPos--;\n                }\n                if (current.isOptional()) {\n                    break;\n                }\n                return ~parseStart;\n            }\n            \n            if (!iPrintEmptyParser) {\n                if (parseStart == currentPos && !current.isOptional()) {\n                    return ~parseStart;\n                }\n            }\n            currentPos = newPosition;\n            \n            if (originalBucketSize + 1 == bucket.size()) {\n                DateTimeField addedField = bucket.getField(originalBucketSize);\n                if (currentPos < text.length() && (addedField == null || !addedField.isleap()) &&\n                    (iDefaultYear == null || !current.allowsVariableLength())) {\n                    // Cannot parse an isolated date or time if it has variable length\n                    // and we cannot infer the default year.\n                    current = current.withZone(UTC);\n                    currentPos = newPosition;\n                    continue;\n                }\n                complete = true;\n                continue;\n                \n            } else if (originalBucketSize == bucket.size()) {\n                continue;  // parsing did not add fields, try next parser\n            }\n            \n            if (bucket.getParsedMonthOfYear() != null && bucket.getParsedDayOfMonth() != null &&\n                bucket.getParsedMonthOfYear() == 2 && bucket.getParsedDayOfMonth() == 29) {\n                    int year = bucket.getParsedYear();\n                    if (year == iDefaultYear.intValue()) {\n                        //If it's 29 Feb of default year, let it pass, and don't assert leap year.\n                        continue;\n                    } else {\n                        Chronology cutover = selectChronology(getChronology(), iDefaultYear.intValue());\n                        if (!cutover.year().isLeap(year)) {\n                            String str = \"Invalid date 'February 29' as '\" + year + \"' is not a leap year\";\n                            throw new IllegalArgumentException(str);\n                        }\n                    }\n            }\n            current = current.withZone(UTC);\n            currentPos = newPosition;\n        }\n        \n        if (savedFields != null && newFieldPos > currentPos) {\n            for (int i = 0; i < savedFields.length; i++) {\n                DateTimeField field = bucket.getField(i);\n                if (field != null && field.isSupported()) {\n                    int oldVal = bucket.setField(field, savedFields[i]);\n                    if (oldVal < savedFields[i]) {\n                        throw new IllegalArgumentException(\n                            \"Field \" + field.getName() + \" cannot be set from \" + savedFields[i]);\n                    }\n                }\n            }\n            currentPos = newFieldPos;\n        }\n        \n        if (iDefaultYear != null && (!complete || !current.acceptsDefaultYear())) {\n            bucket.saveField(DateTimeFieldType.year(), iDefaultYear.intValue());\n        }\n        return complete ? currentPos : ~currentPos;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a2..611499a7 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -697,34 +697,128 @@ public class DateTimeFormatter {\n      * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    public int parseInto(ReadWritableInstant instant, String text, int position) {\n-        DateTimeParser parser = requireParser();\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"Instant must not be null\");\n+    public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        Chronology chrono = bucket.getChronology();\n+        int currentPos = position;\n+        int[] savedFields = (iPivotYear == null ? null : new int[bucket.size()]);\n+        \n+        if (savedFields != null) {\n+            for (int i = 0; i < savedFields.length; i++) {\n+                DateTimeField field = bucket.getField(i);\n+                if (field == null || !field.isSupported()) {\n+                    savedFields[i] = Integer.MIN_VALUE;\n+                } else {\n+                    savedFields[i] = bucket.getValue(i);\n+                }\n+            }\n         }\n         \n-        long instantMillis = instant.getMillis();\n-        Chronology chrono = instant.getChronology();\n-        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n-        chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+        int newFieldPos = currentPos;\n+        boolean complete = false;\n+        while (currentPos < text.length()) {\n+            if (savedFields != null && newFieldPos > currentPos) {\n+                for (int i = 0; i < savedFields.length; i++) {\n+                    DateTimeField field = bucket.getField(i);\n+                    if (field != null && field.isSupported()) {\n+                        int oldVal = bucket.setField(field, savedFields[i]);\n+                        if (oldVal < savedFields[i]) {\n+                            newFieldPos = currentPos;\n+                            break;\n+                        }\n+                    }\n+                }\n+            }\n+            \n+            int parseStart = currentPos;\n+            DateTimeParser current = parser;\n+            int originalBucketSize = bucket.size();\n+            int newPosition = current.parseInto(bucket, text, currentPos);\n+            if (newPosition >= currentPos) {\n+                if (newPosition > currentPos) {\n+                    newFieldPos = newPosition;\n+                } else if (newFieldPos <= currentPos) {\n+                    // Allows a recursive parser to make no progress on second call.\n+                    // e.g. \"\" + timeParser + simpleTime\n+                    newFieldPos = currentPos + 1;\n+                }\n+                if (originalBucketSize == bucket.size()) {\n+                    throw new IllegalArgumentException(\n+                        \"No method to determine \" + bucket.getCurrentFieldName());\n+                }\n+                continue;\n+            }\n+            \n+            if (newPosition < 0) {\n+                currentPos = ~newPosition;\n+                if (currentPos > parseStart + 1 && current.peekSigned()) {\n+                    currentPos--;\n+                }\n+                if (current.isOptional()) {\n+                    break;\n+                }\n+                return ~parseStart;\n+            }\n+            \n+            if (!iPrintEmptyParser) {\n+                if (parseStart == currentPos && !current.isOptional()) {\n+                    return ~parseStart;\n+                }\n+            }\n+            currentPos = newPosition;\n+            \n+            if (originalBucketSize + 1 == bucket.size()) {\n+                DateTimeField addedField = bucket.getField(originalBucketSize);\n+                if (currentPos < text.length() && (addedField == null || !addedField.isleap()) &&\n+                    (iDefaultYear == null || !current.allowsVariableLength())) {\n+                    // Cannot parse an isolated date or time if it has variable length\n+                    // and we cannot infer the default year.\n+                    current = current.withZone(UTC);\n+                    currentPos = newPosition;\n+                    continue;\n+                }\n+                complete = true;\n+                continue;\n+                \n+            } else if (originalBucketSize == bucket.size()) {\n+                continue;  // parsing did not add fields, try next parser\n+            }\n+            \n+            if (bucket.getParsedMonthOfYear() != null && bucket.getParsedDayOfMonth() != null &&\n+                bucket.getParsedMonthOfYear() == 2 && bucket.getParsedDayOfMonth() == 29) {\n+                    int year = bucket.getParsedYear();\n+                    if (year == iDefaultYear.intValue()) {\n+                        //If it's 29 Feb of default year, let it pass, and don't assert leap year.\n+                        continue;\n+                    } else {\n+                        Chronology cutover = selectChronology(getChronology(), iDefaultYear.intValue());\n+                        if (!cutover.year().isLeap(year)) {\n+                            String str = \"Invalid date 'February 29' as '\" + year + \"' is not a leap year\";\n+                            throw new IllegalArgumentException(str);\n+                        }\n+                    }\n+            }\n+            current = current.withZone(UTC);\n+            currentPos = newPosition;\n+        }\n         \n-        DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n-        int newPos = parser.parseInto(bucket, text, position);\n-        instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n-            int parsedOffset = bucket.getOffsetInteger();\n-            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n-            chrono = chrono.withZone(parsedZone);\n-        } else if (bucket.getZone() != null) {\n-            chrono = chrono.withZone(bucket.getZone());\n+        if (savedFields != null && newFieldPos > currentPos) {\n+            for (int i = 0; i < savedFields.length; i++) {\n+                DateTimeField field = bucket.getField(i);\n+                if (field != null && field.isSupported()) {\n+                    int oldVal = bucket.setField(field, savedFields[i]);\n+                    if (oldVal < savedFields[i]) {\n+                        throw new IllegalArgumentException(\n+                            \"Field \" + field.getName() + \" cannot be set from \" + savedFields[i]);\n+                    }\n+                }\n+            }\n+            currentPos = newFieldPos;\n         }\n-        instant.setChronology(chrono);\n-        if (iZone != null) {\n-            instant.setZone(iZone);\n+        \n+        if (iDefaultYear != null && (!complete || !current.acceptsDefaultYear())) {\n+            bucket.saveField(DateTimeFieldType.year(), iDefaultYear.intValue());\n         }\n-        return newPos;\n+        return complete ? currentPos : ~currentPos;\n     }\n \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}