{
    "patch": "    @Test\n    public void testOneType4() {\n      String js = lines(\"\",\n          \"var Foo = function () {};\",\n          \"Foo.prototype = {a: 1};\",\n          \"function use() {\",\n          \"  var obj = /** @type {!Object} */ ({});\",\n          \"  for (var prop in new Foo()) {\",\n          \"    if (prop == 'a') {\",\n          \"      obj[prop] = '';\",\n          \"    }\",\n          \"  }\",\n          \"}\",\n          \"use();\");\n\n      CompilerOptions options = new CompilerOptions();\n      options.setLanguageIn(LanguageMode.ECMASCRIPT3);\n      options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.WARNING);\n\n      TestErrorManager errorManager = new TestErrorManager();\n      List<SourceFile> inputs =\n          ImmutableList.of(SourceFile.fromCode(\"testcode\", js));\n      Compiler compiler = new Compiler();\n      compiler.disableThreads();\n      compiler.setErrorManager(errorManager);\n      Result result = compiler.compile(inputs, ImmutableList.<SourceFile>of(), options);\n\n      assertThat(compiler.getErrors()).isEmpty();\n\n      String expected = \"{a=[[Foo.prototype]]}\";\n      \n      Map<String, String> propertiesToErrorFor = ImmutableMap.of(\n          \"a\", expected\n      );\n      \n      assertThat(compiler.getWarnings())\n          .withMessageContaining(propertiesToErrorFor.toString())\n          .withMessageContaining(\n              \"invalidation of assignments to type-check suppressed properties\")\n          .hasSize(1);\n      JSError warning = Iterables.getOnlyElement(compiler.getWarnings());\n      assertThat(warning.description).contains(expected);\n\n      // Ensure that type checking still passes even if this specific warning is produced.\n      assertThat(result.success).isTrue();\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex b34921ed..09376ead 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -487,29 +487,51 @@ class DisambiguateProperties<T> implements CompilerPass {\n     /**\n      * Processes a OBJECTLIT node.\n      */\n-    private void handleObjectLit(NodeTraversal t, Node n) {\n-      for (Node child = n.getFirstChild();\n-          child != null;\n-          child = child.getNext()) {\n-        // Maybe STRING, GET, SET\n-\n-        // We should never see a mix of numbers and strings.\n-        String name = child.getString();\n-        T type = typeSystem.getType(getScope(), n, name);\n-\n-        Property prop = getProperty(name);\n-        if (!prop.scheduleRenaming(child,\n-                                   processProperty(t, prop, type, null))) {\n-          // TODO(user): It doesn't look like the user can do much in this\n-          // case right now.\n-          if (propertiesToErrorFor.containsKey(name)) {\n-            compiler.report(JSError.make(\n-                t.getSourceName(), child, propertiesToErrorFor.get(name),\n-                Warnings.INVALIDATION, name,\n-                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n-          }\n-        }\n-      }\n+    @Test\n+    public void testOneType4() {\n+      String js = lines(\"\",\n+          \"var Foo = function () {};\",\n+          \"Foo.prototype = {a: 1};\",\n+          \"function use() {\",\n+          \"  var obj = /** @type {!Object} */ ({});\",\n+          \"  for (var prop in new Foo()) {\",\n+          \"    if (prop == 'a') {\",\n+          \"      obj[prop] = '';\",\n+          \"    }\",\n+          \"  }\",\n+          \"}\",\n+          \"use();\");\n+\n+      CompilerOptions options = new CompilerOptions();\n+      options.setLanguageIn(LanguageMode.ECMASCRIPT3);\n+      options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.WARNING);\n+\n+      TestErrorManager errorManager = new TestErrorManager();\n+      List<SourceFile> inputs =\n+          ImmutableList.of(SourceFile.fromCode(\"testcode\", js));\n+      Compiler compiler = new Compiler();\n+      compiler.disableThreads();\n+      compiler.setErrorManager(errorManager);\n+      Result result = compiler.compile(inputs, ImmutableList.<SourceFile>of(), options);\n+\n+      assertThat(compiler.getErrors()).isEmpty();\n+\n+      String expected = \"{a=[[Foo.prototype]]}\";\n+      \n+      Map<String, String> propertiesToErrorFor = ImmutableMap.of(\n+          \"a\", expected\n+      );\n+      \n+      assertThat(compiler.getWarnings())\n+          .withMessageContaining(propertiesToErrorFor.toString())\n+          .withMessageContaining(\n+              \"invalidation of assignments to type-check suppressed properties\")\n+          .hasSize(1);\n+      JSError warning = Iterables.getOnlyElement(compiler.getWarnings());\n+      assertThat(warning.description).contains(expected);\n+\n+      // Ensure that type checking still passes even if this specific warning is produced.\n+      assertThat(result.success).isTrue();\n     }\n \n     private void printErrorLocations(List<String> errors, JSType t) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}