{
    "patch": "          if (outputCharsetEncoder != null) {\n            if (outputCharsetEncoder.canEncode(c)) {\n              sb.append(c);\n            } else if (c <= 0x7f) {\n              sb.append(\"\\\\x\").append(String.format(\"%02x\", (int) c));\n            } else {\n              appendHexJavaScriptRepresentation(sb, c);\n            }\n          } else {\n            // No charsetEncoder provided - pass straight latin characters\n            // through, and escape other characters. Doing the explicit\n            // character check is measurably faster than using the CharsetEncoder.\n            if (c > 0x1f && c <= 0x7e) {\n              // ASCII printable characters\n              if (c == '\\\\' || c == '\\\"' || c == '\\'' || c == '>') {\n                sb.append('\\\\');\n              }\n              sb.append(c);\n            } else {\n              if (c == '\\n') {\n                sb.append(\"\\\\n\");\n              } else if (c == '\\r') {\n                sb.append(\"\\\\r\");\n              } else if (c == '\\t') {\n                sb.append(\"\\\\t\");\n              } else if (c <= 0xff) {\n                //Latin-1\n                sb.append(\"\\\\x\").append(String.format(\"%02x\", (int) c));\n              } else {\n                // Other characters can be misinterpreted by some js parsers,\n                // or perhaps mangled by proxies along the way,\n                // so we play it safe and Unicode escape them.\n                appendHexJavaScriptRepresentation(sb, c);\n              }\n            }\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 558e74fe..cb994952 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -1042,7 +1042,42 @@ class CodeGenerator {\n             // No charsetEncoder provided - pass straight latin characters\n             // through, and escape the rest.  Doing the explicit character\n             // check is measurably faster than using the CharsetEncoder.\n-            if (c > 0x1f && c <= 0x7f) {\n+          if (outputCharsetEncoder != null) {\n+            if (outputCharsetEncoder.canEncode(c)) {\n+              sb.append(c);\n+            } else if (c <= 0x7f) {\n+              sb.append(\"\\\\x\").append(String.format(\"%02x\", (int) c));\n+            } else {\n+              appendHexJavaScriptRepresentation(sb, c);\n+            }\n+          } else {\n+            // No charsetEncoder provided - pass straight latin characters\n+            // through, and escape other characters. Doing the explicit\n+            // character check is measurably faster than using the CharsetEncoder.\n+            if (c > 0x1f && c <= 0x7e) {\n+              // ASCII printable characters\n+              if (c == '\\\\' || c == '\\\"' || c == '\\'' || c == '>') {\n+                sb.append('\\\\');\n+              }\n+              sb.append(c);\n+            } else {\n+              if (c == '\\n') {\n+                sb.append(\"\\\\n\");\n+              } else if (c == '\\r') {\n+                sb.append(\"\\\\r\");\n+              } else if (c == '\\t') {\n+                sb.append(\"\\\\t\");\n+              } else if (c <= 0xff) {\n+                //Latin-1\n+                sb.append(\"\\\\x\").append(String.format(\"%02x\", (int) c));\n+              } else {\n+                // Other characters can be misinterpreted by some js parsers,\n+                // or perhaps mangled by proxies along the way,\n+                // so we play it safe and Unicode escape them.\n+                appendHexJavaScriptRepresentation(sb, c);\n+              }\n+            }\n+          }\n               sb.append(c);\n             } else {\n               // Other characters can be misinterpreted by some js parsers,",
    "result_reason": "error: 'else' without 'if'",
    "test_result": "ERROR"
}