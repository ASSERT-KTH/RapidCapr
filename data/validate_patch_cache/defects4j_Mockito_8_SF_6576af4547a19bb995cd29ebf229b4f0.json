{
    "patch": "private void processParameterizedType(VariableElement element, Map<TypeVariable<?>, Type> contextualActualTypeParameters) {\n    TypeMirror type = element.asType();\n    if (!(type instanceof DeclaredType)) {\n        return;\n    }\n\n    DeclaredType declaredType = (DeclaredType) type;\n    TypeElement typeElement = (TypeElement) declaredType.asElement();\n\n    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();\n    List<? extends TypeParameterElement> typeParameters = typeElement.getTypeParameters();\n    for (int i = 0; i < typeParameters.size(); i++) {\n        TypeParameterElement typeParameter = typeParameters.get(i);\n        TypeMirror typeArgument = typeArguments.get(i);\n\n        Type resolvedTypeArgument = resolveType(typeArgument, contextualActualTypeParameters);\n\n        if (resolvedTypeArgument instanceof TypeVariable<?>) {\n            TypeVariable<?> resolvedTypeVariableArgument = (TypeVariable<?>) resolvedTypeArgument;\n            Type resolvedTypeVariableValue = contextualActualTypeParameters.get(resolvedTypeVariableArgument);\n            contextualActualTypeParameters.put(typeParameter,\n                    resolvedTypeVariableValue != null ? resolvedTypeVariableValue : resolvedTypeVariableArgument);\n        } else if (resolvedTypeArgument instanceof WildcardType) {\n            WildcardType wildcardTypeArgument = (WildcardType) resolvedTypeArgument;\n            Type extendsBound = wildcardTypeArgument.getExtendsBound();\n            Type superBound = wildcardTypeArgument.getSuperBound();\n            if (extendsBound != null) {\n                contextualActualTypeParameters.put(typeParameter, extendsBound);\n            } else if (superBound != null) {\n                contextualActualTypeParameters.put(typeParameter, superBound);\n            }\n        } else {\n            contextualActualTypeParameters.put(typeParameter, resolvedTypeArgument);\n        }\n    }\n}\n\nprivate Type resolveType(TypeMirror type, Map<TypeVariable<?>, Type> contextualActualTypeParameters) {\n    if (type instanceof TypeVariable<?>) {\n        TypeVariable<?> typeVariable = (TypeVariable<?>) type;\n        return contextualActualTypeParameters.getOrDefault(typeVariable, typeVariable);\n    } else if (type instanceof ParameterizedType) {\n        ParameterizedType parameterizedType = (ParameterizedType) type;\n        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n        Type[] resolvedTypeArguments = new Type[actualTypeArguments.length];\n        for (int i = 0; i < actualTypeArguments.length; i++) {\n            resolvedTypeArguments[i] = resolveType(actualTypeArguments[i], contextualActualTypeParameters);\n        }\n        return new ParameterizedTypeImpl((Class<?>) parameterizedType.getRawType(), resolvedTypeArguments);\n    } else if (type instanceof WildcardType) {\n        WildcardType wildcardType = (WildcardType) type;\n        Type[] upperBounds = wildcardType.getUpperBounds();\n        Type[] resolvedUpperBounds = new Type[upperBounds.length];\n        for (int i = 0; i < upperBounds.length; i++) {\n            resolvedUpperBounds[i] = resolveType(upperBounds[i], contextualActualTypeParameters);\n        }\n        Type[] lowerBounds = wildcardType.getLowerBounds();\n        Type[] resolvedLowerBounds = new Type[lowerBounds.length];\n        for (int i = 0; i < lowerBounds.length; i++) {\n            resolvedLowerBounds[i] = resolveType(lowerBounds[i], contextualActualTypeParameters);\n        }\n        return new WildcardTypeImpl(resolvedUpperBounds, resolvedLowerBounds);\n    } else {\n        return type;\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nindex 152e9424e..c929f2b14 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -64,23 +64,72 @@ public abstract class GenericMetadataSupport {\n \n \n     protected void registerTypeVariablesOn(Type classType) {\n-        if (!(classType instanceof ParameterizedType)) {\n-            return;\n-        }\n-        ParameterizedType parameterizedType = (ParameterizedType) classType;\n-        TypeVariable[] typeParameters = ((Class<?>) parameterizedType.getRawType()).getTypeParameters();\n-        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n-        for (int i = 0; i < actualTypeArguments.length; i++) {\n-            TypeVariable typeParameter = typeParameters[i];\n-            Type actualTypeArgument = actualTypeArguments[i];\n-\n-            if (actualTypeArgument instanceof WildcardType) {\n-                contextualActualTypeParameters.put(typeParameter, boundsOf((WildcardType) actualTypeArgument));\n-            } else {\n-                contextualActualTypeParameters.put(typeParameter, actualTypeArgument);\n-            }\n-            // logger.log(\"For '\" + parameterizedType + \"' found type variable : { '\" + typeParameter + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' : '\" + actualTypeArgument + \"(\" + System.identityHashCode(typeParameter) + \")\" + \"' }\");\n-        }\n+private void processParameterizedType(VariableElement element, Map<TypeVariable<?>, Type> contextualActualTypeParameters) {\n+    TypeMirror type = element.asType();\n+    if (!(type instanceof DeclaredType)) {\n+        return;\n+    }\n+\n+    DeclaredType declaredType = (DeclaredType) type;\n+    TypeElement typeElement = (TypeElement) declaredType.asElement();\n+\n+    List<? extends TypeMirror> typeArguments = declaredType.getTypeArguments();\n+    List<? extends TypeParameterElement> typeParameters = typeElement.getTypeParameters();\n+    for (int i = 0; i < typeParameters.size(); i++) {\n+        TypeParameterElement typeParameter = typeParameters.get(i);\n+        TypeMirror typeArgument = typeArguments.get(i);\n+\n+        Type resolvedTypeArgument = resolveType(typeArgument, contextualActualTypeParameters);\n+\n+        if (resolvedTypeArgument instanceof TypeVariable<?>) {\n+            TypeVariable<?> resolvedTypeVariableArgument = (TypeVariable<?>) resolvedTypeArgument;\n+            Type resolvedTypeVariableValue = contextualActualTypeParameters.get(resolvedTypeVariableArgument);\n+            contextualActualTypeParameters.put(typeParameter,\n+                    resolvedTypeVariableValue != null ? resolvedTypeVariableValue : resolvedTypeVariableArgument);\n+        } else if (resolvedTypeArgument instanceof WildcardType) {\n+            WildcardType wildcardTypeArgument = (WildcardType) resolvedTypeArgument;\n+            Type extendsBound = wildcardTypeArgument.getExtendsBound();\n+            Type superBound = wildcardTypeArgument.getSuperBound();\n+            if (extendsBound != null) {\n+                contextualActualTypeParameters.put(typeParameter, extendsBound);\n+            } else if (superBound != null) {\n+                contextualActualTypeParameters.put(typeParameter, superBound);\n+            }\n+        } else {\n+            contextualActualTypeParameters.put(typeParameter, resolvedTypeArgument);\n+        }\n+    }\n+}\n+\n+private Type resolveType(TypeMirror type, Map<TypeVariable<?>, Type> contextualActualTypeParameters) {\n+    if (type instanceof TypeVariable<?>) {\n+        TypeVariable<?> typeVariable = (TypeVariable<?>) type;\n+        return contextualActualTypeParameters.getOrDefault(typeVariable, typeVariable);\n+    } else if (type instanceof ParameterizedType) {\n+        ParameterizedType parameterizedType = (ParameterizedType) type;\n+        Type[] actualTypeArguments = parameterizedType.getActualTypeArguments();\n+        Type[] resolvedTypeArguments = new Type[actualTypeArguments.length];\n+        for (int i = 0; i < actualTypeArguments.length; i++) {\n+            resolvedTypeArguments[i] = resolveType(actualTypeArguments[i], contextualActualTypeParameters);\n+        }\n+        return new ParameterizedTypeImpl((Class<?>) parameterizedType.getRawType(), resolvedTypeArguments);\n+    } else if (type instanceof WildcardType) {\n+        WildcardType wildcardType = (WildcardType) type;\n+        Type[] upperBounds = wildcardType.getUpperBounds();\n+        Type[] resolvedUpperBounds = new Type[upperBounds.length];\n+        for (int i = 0; i < upperBounds.length; i++) {\n+            resolvedUpperBounds[i] = resolveType(upperBounds[i], contextualActualTypeParameters);\n+        }\n+        Type[] lowerBounds = wildcardType.getLowerBounds();\n+        Type[] resolvedLowerBounds = new Type[lowerBounds.length];\n+        for (int i = 0; i < lowerBounds.length; i++) {\n+            resolvedLowerBounds[i] = resolveType(lowerBounds[i], contextualActualTypeParameters);\n+        }\n+        return new WildcardTypeImpl(resolvedUpperBounds, resolvedLowerBounds);\n+    } else {\n+        return type;\n+    }\n+}\n     }\n \n     protected void registerTypeParametersOn(TypeVariable[] typeParameters) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}