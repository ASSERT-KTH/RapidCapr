{
    "patch": "  void tryMinimizeExits(Node n, int exitType, String labelName) {\n    boolean wasChanged = false;\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      // Fix for issue #2115. Do not try to remove the break statement from finally blocks\n      // as this can change the completion type of the finally block and potentially cause\n      // runtime errors.\n      boolean tryBlockChanged = tryMinimizeBlockExit(n.getFirstChild(), exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        wasChanged = tryMinimizeBlockExit(\n            allCatchNodes.getFirstChild().getLastChild(), exitType, labelName);\n      }\n      if (NodeUtil.hasFinally(n)) {\n        wasChanged = tryMinimizeBlockExit(n.getLastChild(), exitType, labelName);\n      }\n      if (wasChanged) {\n        n.setIsChanged();\n        compiler.reportCodeChange();\n      }\n      return;\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n      return;\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      wasChanged |= tryMinimizeBlockExit(c, exitType, labelName);\n    }\n\n    if (wasChanged) {\n      n.setIsChanged();\n      compiler.reportCodeChange();\n    }\n  }\n  \n  /**\n   * Try to minimize an exit of a block.\n   *\n   * @return Whether there was a change to the AST.\n   */\n  private boolean tryMinimizeBlockExit(Node n, int exitType, String labelName) {\n    return tryMinimizeBlockExit(n, exitType, labelName, false);\n  }\n\n  /**\n   * Try to minimize an exit of a block.\n   *\n   * @param allowFinallyExit If true, exits in finally blocks will be processed.\n   * @return Whether there was a change to the AST.\n   */\n  private boolean tryMinimizeBlockExit(\n      Node n, int exitType, String labelName, boolean allowFinallyExit) {\n    LabelNamePair label = null;\n    boolean wasChanged = false;\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      if (c.isLabel()) {\n        label = c.getFirstChild().getLabelNamePair();\n      }\n      wasChanged |= tryMinimizeBlockExit(c, exitType, labelName, allowFinallyExit);\n    }\n\n    if (n.isBlock()) {\n      if (matchingExitNode(n, exitType, labelName)) {\n        removeExit(n, allowFinallyExit);\n        wasChanged = true;\n      } else if (n.getFirstChild() != null && (n.hasOneChild() || isControlStructure(n))) {\n        // Only check for DEFAULT if we haven't already found a control structure.\n        // There are other situations that we don't want to check for,\n        // but there's no harm in trying to remove a control structure elsewhere.\n        LabelNamePair defaultLabel = LabelNamePair.DEFAULT;\n        if (label != null && label.isDefault()) {\n          defaultLabel = label;\n        }\n        if (!matchingExitNode(n, Token.CONTINUE, labelName, defaultLabel.yield())) {\n          wasChanged |= trySimplifyLoop(n, labelName);\n        }\n      }\n    }\n\n    return wasChanged;\n  }\n\n  private void removeExit(Node n, boolean allowFinallyExit) {\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      Node elseBlock = ifBlock.getNext();\n      if (matchingExitNode(ifBlock, Token.BREAK, null)\n          && (elseBlock == null || !matchingExitNode(elseBlock, Token.BREAK, null))) {\n        convertIfStatement(n, ifBlock, elseBlock);\n      } else if (elseBlock != null\n          && matchingExitNode(elseBlock, Token.BREAK, null)\n          && !matchingExitNode(ifBlock, Token.BREAK, null)) {\n        convertIfStatement(n, elseBlock, ifBlock);\n      }\n    }\n\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      if (matchingExitNode(c, Token.BREAK, null) ||\n          allowFinallyExit && isFinallyExit(c)) {\n        NodeUtil.removeChild(n, c);\n      } else {\n        break;\n      }\n\n    }\n  }\n  \n  private boolean isFinallyExit(Node n) {\n    if (n.getType() == Token.FUNCTION) {\n      // We shouldn't be trying to remove returns outside of functions.\n      throw new IllegalStateException();\n    }\n    if (!n.isBlock()) {\n      return false;\n    }\n    Node parent = n.getParent();\n    return parent.isTry() && NodeUtil.hasFinally((parent)) && parent.getLastChild() == n;\n  }\n\n  private boolean matchingExitNode(Node n, int exitType, String labelName, int yieldKind) {\n    if (n.getType() != exitType) {\n      return false;\n    }\n    if (labelName != null) {\n      if (n.getLabelName() == null || !n.getLabelName().equals(labelName)) {\n        return false;\n      }\n    } else {\n      if (n.getLabelName() != null) {\n        return false;\n      }\n    }\n    if (exitType == Token.BREAK && n.hasChildren()) {\n      // Note: the final \"y\" tells us if break was \"break label;\"\n      // (as opposed to \"break;\").\n      return n.getLastChild().getString().equals(\"\" + yieldKind);\n    }\n    return true;\n  }\n\n  private boolean matchingExitNode(Node n, int exitType, String labelName) {\n    return matchingExitNode(n, exitType, labelName, 'y');\n  }\n  \n  private boolean matchingExitNode(Node n, int exitType) {\n    return matchingExitNode(n, exitType, null);\n  }\n\n  private boolean trySimplifyLoop(Node n, String labelName) {\n    Node terminator = null;\n    Node loopNode = null;\n    boolean onlyHasContinue = true;\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      Node first = c.getFirstChild();\n      if (first == null || !matchingExitNode(first, Token.CONTINUE, labelName) ||\n          (first.hasMoreThanOneChild())) {\n        onlyHasContinue = false;\n        break;\n      }\n      if (terminator != null && !terminator.isEquivalentTo(c.getLastChild())) {\n        // Can't simplify this loop.\n        return false;\n      }\n      terminator = c.getLastChild();\n      loopNode = c;\n    }\n\n    if (onlyHasContinue && terminator != null && terminator.isBreak() &&\n        matchingExitNode(terminator, Token.BREAK, labelName)) {\n      // Found a loop that can be simplified.\n      Node newNode = IR.exprResult(\n          terminator.removeFirstChild().removeFirstChild()).setJSType(VOID_TYPE);\n      NodeUtil.insertBefore(n.getParent(), newNode, n);\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return true;\n    }\n    return false;\n  }\n\n  private void convertIfStatement(Node parent, Node ifBlock, Node elseBlock) {\n    Node cond = parent.removeFirstChild();\n    Node newIf = IR.ifNode(cond, ifBlock, elseBlock);\n    newIf.copyInformationFrom(parent);\n    NodeUtil.replaceNode(parent, newIf);\n    compiler.reportCodeChange();\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..1dfce088 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -104,6 +104,7 @@ class MinimizeExitPoints\n    * @nullable labelName non-null only for breaks within labels.\n    */\n   void tryMinimizeExits(Node n, int exitType, String labelName) {\n+    boolean wasChanged = false;\n \n     // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n@@ -125,29 +126,31 @@ class MinimizeExitPoints\n \n     // Just a 'try/catch/finally'.\n     if (n.isTry()) {\n-      Node tryBlock = n.getFirstChild();\n-      tryMinimizeExits(tryBlock, exitType, labelName);\n+      // Fix for issue #2115. Do not try to remove the break statement from finally blocks\n+      // as this can change the completion type of the finally block and potentially cause\n+      // runtime errors.\n+      boolean tryBlockChanged = tryMinimizeBlockExit(n.getFirstChild(), exitType, labelName);\n       Node allCatchNodes = NodeUtil.getCatchBlock(n);\n       if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n         Preconditions.checkState(allCatchNodes.hasOneChild());\n-        Node catchNode = allCatchNodes.getFirstChild();\n-        Node catchCodeBlock = catchNode.getLastChild();\n-        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n+        wasChanged = tryMinimizeBlockExit(\n+            allCatchNodes.getFirstChild().getLastChild(), exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n-       */\n       if (NodeUtil.hasFinally(n)) {\n-        Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        wasChanged = tryMinimizeBlockExit(n.getLastChild(), exitType, labelName);\n       }\n+      if (wasChanged) {\n+        n.setIsChanged();\n+        compiler.reportCodeChange();\n+      }\n+      return;\n     }\n \n     // Just a 'label'.\n     if (n.isLabel()) {\n       Node labelBlock = n.getLastChild();\n       tryMinimizeExits(labelBlock, exitType, labelName);\n+      return;\n     }\n \n     // TODO(johnlenz): The last case of SWITCH statement?\n@@ -157,47 +160,169 @@ class MinimizeExitPoints\n       return;\n     }\n \n-    // Multiple if-exits can be converted in a single pass.\n-    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n-    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n-    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n-    for (Node c : n.children()) {\n-\n-      // An 'if' block to process below.\n-      if (c.isIf()) {\n-        Node ifTree = c;\n-        Node trueBlock, falseBlock;\n-\n-        // First, the true condition block.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n-            ifTree, exitType, labelName);\n-\n-        // Now the else block.\n-        // The if blocks may have changed, get them again.\n-        trueBlock = ifTree.getFirstChild().getNext();\n-        falseBlock = trueBlock.getNext();\n-        if (falseBlock != null) {\n-          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n-              ifTree, exitType, labelName);\n+    // Now try to minimize the exits of the last child, if it is removed\n+    // look at what has become the last child.\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      wasChanged |= tryMinimizeBlockExit(c, exitType, labelName);\n+    }\n+\n+    if (wasChanged) {\n+      n.setIsChanged();\n+      compiler.reportCodeChange();\n+    }\n+  }\n+  \n+  /**\n+   * Try to minimize an exit of a block.\n+   *\n+   * @return Whether there was a change to the AST.\n+   */\n+  private boolean tryMinimizeBlockExit(Node n, int exitType, String labelName) {\n+    return tryMinimizeBlockExit(n, exitType, labelName, false);\n+  }\n+\n+  /**\n+   * Try to minimize an exit of a block.\n+   *\n+   * @param allowFinallyExit If true, exits in finally blocks will be processed.\n+   * @return Whether there was a change to the AST.\n+   */\n+  private boolean tryMinimizeBlockExit(\n+      Node n, int exitType, String labelName, boolean allowFinallyExit) {\n+    LabelNamePair label = null;\n+    boolean wasChanged = false;\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      if (c.isLabel()) {\n+        label = c.getFirstChild().getLabelNamePair();\n+      }\n+      wasChanged |= tryMinimizeBlockExit(c, exitType, labelName, allowFinallyExit);\n+    }\n+\n+    if (n.isBlock()) {\n+      if (matchingExitNode(n, exitType, labelName)) {\n+        removeExit(n, allowFinallyExit);\n+        wasChanged = true;\n+      } else if (n.getFirstChild() != null && (n.hasOneChild() || isControlStructure(n))) {\n+        // Only check for DEFAULT if we haven't already found a control structure.\n+        // There are other situations that we don't want to check for,\n+        // but there's no harm in trying to remove a control structure elsewhere.\n+        LabelNamePair defaultLabel = LabelNamePair.DEFAULT;\n+        if (label != null && label.isDefault()) {\n+          defaultLabel = label;\n+        }\n+        if (!matchingExitNode(n, Token.CONTINUE, labelName, defaultLabel.yield())) {\n+          wasChanged |= trySimplifyLoop(n, labelName);\n         }\n       }\n+    }\n \n-      if (c == n.getLastChild()) {\n-        break;\n+    return wasChanged;\n+  }\n+\n+  private void removeExit(Node n, boolean allowFinallyExit) {\n+    if (n.isIf()) {\n+      Node ifBlock = n.getFirstChild().getNext();\n+      Node elseBlock = ifBlock.getNext();\n+      if (matchingExitNode(ifBlock, Token.BREAK, null)\n+          && (elseBlock == null || !matchingExitNode(elseBlock, Token.BREAK, null))) {\n+        convertIfStatement(n, ifBlock, elseBlock);\n+      } else if (elseBlock != null\n+          && matchingExitNode(elseBlock, Token.BREAK, null)\n+          && !matchingExitNode(ifBlock, Token.BREAK, null)) {\n+        convertIfStatement(n, elseBlock, ifBlock);\n       }\n     }\n \n-    // Now try to minimize the exits of the last child, if it is removed\n-    // look at what has become the last child.\n     for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n-      tryMinimizeExits(c, exitType, labelName);\n-      // If the node is still the last child, we are done.\n-      if (c == n.getLastChild()) {\n+      if (matchingExitNode(c, Token.BREAK, null) ||\n+          allowFinallyExit && isFinallyExit(c)) {\n+        NodeUtil.removeChild(n, c);\n+      } else {\n+        break;\n+      }\n+\n+    }\n+  }\n+  \n+  private boolean isFinallyExit(Node n) {\n+    if (n.getType() == Token.FUNCTION) {\n+      // We shouldn't be trying to remove returns outside of functions.\n+      throw new IllegalStateException();\n+    }\n+    if (!n.isBlock()) {\n+      return false;\n+    }\n+    Node parent = n.getParent();\n+    return parent.isTry() && NodeUtil.hasFinally((parent)) && parent.getLastChild() == n;\n+  }\n+\n+  private boolean matchingExitNode(Node n, int exitType, String labelName, int yieldKind) {\n+    if (n.getType() != exitType) {\n+      return false;\n+    }\n+    if (labelName != null) {\n+      if (n.getLabelName() == null || !n.getLabelName().equals(labelName)) {\n+        return false;\n+      }\n+    } else {\n+      if (n.getLabelName() != null) {\n+        return false;\n+      }\n+    }\n+    if (exitType == Token.BREAK && n.hasChildren()) {\n+      // Note: the final \"y\" tells us if break was \"break label;\"\n+      // (as opposed to \"break;\").\n+      return n.getLastChild().getString().equals(\"\" + yieldKind);\n+    }\n+    return true;\n+  }\n+\n+  private boolean matchingExitNode(Node n, int exitType, String labelName) {\n+    return matchingExitNode(n, exitType, labelName, 'y');\n+  }\n+  \n+  private boolean matchingExitNode(Node n, int exitType) {\n+    return matchingExitNode(n, exitType, null);\n+  }\n+\n+  private boolean trySimplifyLoop(Node n, String labelName) {\n+    Node terminator = null;\n+    Node loopNode = null;\n+    boolean onlyHasContinue = true;\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      Node first = c.getFirstChild();\n+      if (first == null || !matchingExitNode(first, Token.CONTINUE, labelName) ||\n+          (first.hasMoreThanOneChild())) {\n+        onlyHasContinue = false;\n         break;\n       }\n+      if (terminator != null && !terminator.isEquivalentTo(c.getLastChild())) {\n+        // Can't simplify this loop.\n+        return false;\n+      }\n+      terminator = c.getLastChild();\n+      loopNode = c;\n     }\n+\n+    if (onlyHasContinue && terminator != null && terminator.isBreak() &&\n+        matchingExitNode(terminator, Token.BREAK, labelName)) {\n+      // Found a loop that can be simplified.\n+      Node newNode = IR.exprResult(\n+          terminator.removeFirstChild().removeFirstChild()).setJSType(VOID_TYPE);\n+      NodeUtil.insertBefore(n.getParent(), newNode, n);\n+      NodeUtil.removeChild(n.getParent(), n);\n+      compiler.reportCodeChange();\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private void convertIfStatement(Node parent, Node ifBlock, Node elseBlock) {\n+    Node cond = parent.removeFirstChild();\n+    Node newIf = IR.ifNode(cond, ifBlock, elseBlock);\n+    newIf.copyInformationFrom(parent);\n+    NodeUtil.replaceNode(parent, newIf);\n+    compiler.reportCodeChange();\n   }\n \n   /**",
    "result_reason": "error: method matchingExitNode(Node,int,String) is already defined in class MinimizeExitPoints",
    "test_result": "ERROR"
}