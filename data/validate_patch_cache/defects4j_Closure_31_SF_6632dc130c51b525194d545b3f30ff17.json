{
    "patch": "public class Compiler extends AbstractCompiler {\n\n  private ReverseAbstractInterpreter abstractInterpreter;\n  private TypeValidator typeValidator;\n\n  /**\n   * Constructor for the Compiler object.  Initializes the built-in\n   * externs and runs the passes.\n   */\n  public Compiler() {\n    super();\n    setTypeRegistry(new JSTypeRegistry(getTypeRegistry()));\n  }\n\n  /**\n   * Constructor for the Compiler object. Initializes the built-in\n   * externs.\n   *\n   * @param reporter The error stream (for reporting errors)\n   */\n  public Compiler(ErrorManager reporter) {\n    super(reporter);\n    setTypeRegistry(new JSTypeRegistry(getTypeRegistry()));\n  }\n\n  //------------------------------------------------------------------------\n  // Simple accessors/mutators\n  //------------------------------------------------------------------------\n\n  /**\n   * Gets an instance of the {@link NodeFactory} that can be used to create\n   * nodes.\n   */\n  public NodeFactory getNodeFactory() {\n    return new NodeFactory(getTokenFactory());\n  }\n\n  /**\n   * Sets an instance of {@link Node} to be the root of the parse tree.\n   * This is only intended to be called by {@link\n   * #parse(JsAst)} and {@link #parse(SourceFileSet)} and normally it\n   * should not be called at any other time.\n   *\n   * @param root The root node of the parse tree\n   */\n  @Override\n  public void setJsRoot(Node root) {\n    // Detach the old tree.\n    if (jsRoot != null) {\n      jsRoot.detachChildren();\n    }\n\n    jsRoot = root;\n\n    if (jsRoot != null) {\n      initCompilerOptionsForPass(jsRoot);\n    }\n  }\n\n  /**\n   * Gets the root node of the parse tree built by a call to\n   * {@link #parse(JsAst)} or {@link #parse(SourceFileSet)}, or null\n   * if no parse tree has been built yet.\n   *\n   * @return The root node\n   */\n  @Override\n  public Node getJsRoot() {\n    return jsRoot;\n  }\n\n  /**\n   * @return Whether some portion of the input has been parsed.\n   */\n  @Override\n  public boolean isParsingDone() {\n    return progress == Progress.PARSING_COMPLETE;\n  }\n\n  /**\n   * Create a {@link TypedScope} object of GLOBAL scope; all other scopes are\n   * nested within the global scope.\n   */\n  public TypedScope createScope() {\n    TypedScope scope = TypedScope.createGlobalScope(new Node(Token.GLOBAL_SCOPE));\n    scopeCreator = new Es6SyntacticScopeCreator(compiler);\n    return scope;\n  }\n\n  //------------------------------------------------------------------------\n  // Pass management\n  //------------------------------------------------------------------------\n\n  /**\n   * Resets the state of the compiler to its initial state, so that it\n   * can be used to compile a new script. Note that the compiler's error\n   * handlers are retained across resets, so this method does not silence\n   * errors or warnings generated by the previous compile.\n   */\n  public void reset() {\n    this.externs.clear();\n    this.inputs.clear();\n    this.topScope = null;\n    this.symtab = null;\n    this.codingConvention = null;\n    this.reporter = null;\n    this.defaultPassConfig.clearOptions();\n    this.partialCodingConvention = null;\n    this.reflectionHandler = null;\n    this.transformations.clear();\n    this.moduleGraph = null;\n    this.typeCheckingHasRun = false;\n    this.jsRoot = null;\n    this.externsRoot = null;\n    this.abstractInterpreter = null;\n    this.sourceMap = null;\n    this.typeValidator = null;\n    this.reportChangeToEnclosingScope = false;\n    this.esModulesThatNeedProcessing.clear();\n    this.syntaxTree.clear();\n    this.moduleLoader.clear();\n    this.scopeCreator = null;\n    this.inputIdGenerators.clear();\n    resetTimings();\n\n    initOptions(new CompilerOptions());\n\n    initBuiltins(this.typeRegistry);\n    initExternsRoot();\n    this.topScope = createScope();\n    initInputsById();\n  }\n\n  /**\n   * Sets up a listener that will be notified every time a new change\n   * is made to an internal compiler state. If the changes affect the\n   * external behavior of the compiler in any way, such as changing\n   * its error-handling mode or the set of enabled optimizations, then\n   * the listener's {@link CompilerPass#shouldRun} method should return\n   * true to force re-creation of all passes. If the changes affect only\n   * the internal behavior of the compiler, such as changing the subgraph\n   * on which a pass runs or inserting a compiler pass at a particular\n   * place in the pass pipeline, then the listener's\n   * {@link CompilerPass#shouldRun} method should return false to allow\n   * the compiler to re-use as many already-created passes as possible.\n   *\n   * @param handler The pass that will be notified of changes\n   */\n  public void addChangeHandler(CompilerPass handler) {\n    changeHandlers.add(handler);\n  }\n\n  /**\n   * Removes a change handler that was previously added with\n   * {@link #addChangeHandler}.\n   *\n   * @param handler The pass that was previously added\n   */\n  public void removeChangeHandler(CompilerPass handler) {\n    changeHandlers.remove(handler);\n  }\n\n  /**\n   * Internal API used to notify all registered change handlers that a\n   * change has been made to an internal state of the compiler. Clients\n   * of the Compiler API should call {@link #reportChange} instead.\n   */\n  void handleChange() {\n    for (CompilerPass pass : changeHandlers) {\n      if (pass.shouldRun(this)) {\n        invalidatePassResults(pass);\n      }\n    }\n  }\n\n  /**\n   * Invalidates any cached compiler results associated with a particular pass.\n   * This should be called whenever the compiler undergoes a change that could\n   * affect the behavior of a pass, such as a change to its error-handling mode\n   * or the set of enabled optimizations.\n   *\n   * @param pass The pass whose cached results should be invalidated\n   */\n  public void invalidatePassResults(CompilerPass pass) {\n    if (cachedResultsByPass == null) {\n      return;\n    }\n\n    for (Map.Entry<CompilerPass, Object> entry : cachedResultsByPass.entrySet()) {\n      if (entry.getKey().getClass() == pass.getClass()) {\n        cachedResultsByPass.put(entry.getKey(), null);\n      }\n    }\n  }\n\n  /**\n   * Requests that the compiler re-use previously-computed results for a\n   * particular pass, if available. Clients that request results from a\n   * pass should invoke this method just before invoking the pass, to give\n   * the Compiler a chance to re-use an earlier result instead o",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..e834f194 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1200,192 +1200,207 @@ public class Compiler extends AbstractCompiler {\n   }\n \n   @Override\n-  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n-    if (abstractInterpreter == null) {\n-      ChainableReverseAbstractInterpreter interpreter =\n-          new SemanticReverseAbstractInterpreter(\n-              getCodingConvention(), getTypeRegistry());\n-      if (options.closurePass) {\n-        interpreter = new ClosureReverseAbstractInterpreter(\n-            getCodingConvention(), getTypeRegistry())\n-            .append(interpreter).getFirst();\n-      }\n-      abstractInterpreter = interpreter;\n-    }\n-    return abstractInterpreter;\n+public class Compiler extends AbstractCompiler {\n+\n+  private ReverseAbstractInterpreter abstractInterpreter;\n+  private TypeValidator typeValidator;\n+\n+  /**\n+   * Constructor for the Compiler object.  Initializes the built-in\n+   * externs and runs the passes.\n+   */\n+  public Compiler() {\n+    super();\n+    setTypeRegistry(new JSTypeRegistry(getTypeRegistry()));\n   }\n \n-  @Override\n-  TypeValidator getTypeValidator() {\n-    if (typeValidator == null) {\n-      typeValidator = new TypeValidator(this);\n-    }\n-    return typeValidator;\n+  /**\n+   * Constructor for the Compiler object. Initializes the built-in\n+   * externs.\n+   *\n+   * @param reporter The error stream (for reporting errors)\n+   */\n+  public Compiler(ErrorManager reporter) {\n+    super(reporter);\n+    setTypeRegistry(new JSTypeRegistry(getTypeRegistry()));\n   }\n \n   //------------------------------------------------------------------------\n-  // Parsing\n+  // Simple accessors/mutators\n   //------------------------------------------------------------------------\n \n   /**\n-   * Parses the externs and main inputs.\n-   *\n-   * @return A synthetic root node whose two children are the externs root\n-   *     and the main root\n+   * Gets an instance of the {@link NodeFactory} that can be used to create\n+   * nodes.\n    */\n-  Node parseInputs() {\n-    boolean devMode = options.devMode != DevMode.OFF;\n+  public NodeFactory getNodeFactory() {\n+    return new NodeFactory(getTokenFactory());\n+  }\n \n-    // If old roots exist (we are parsing a second time), detach each of the\n-    // individual file parse trees.\n-    if (externsRoot != null) {\n-      externsRoot.detachChildren();\n-    }\n+  /**\n+   * Sets an instance of {@link Node} to be the root of the parse tree.\n+   * This is only intended to be called by {@link\n+   * #parse(JsAst)} and {@link #parse(SourceFileSet)} and normally it\n+   * should not be called at any other time.\n+   *\n+   * @param root The root node of the parse tree\n+   */\n+  @Override\n+  public void setJsRoot(Node root) {\n+    // Detach the old tree.\n     if (jsRoot != null) {\n       jsRoot.detachChildren();\n     }\n \n-    // Parse main js sources.\n-    jsRoot = IR.block();\n-    jsRoot.setIsSyntheticBlock(true);\n-\n-    externsRoot = IR.block();\n-    externsRoot.setIsSyntheticBlock(true);\n+    jsRoot = root;\n \n-    externAndJsRoot = IR.block(externsRoot, jsRoot);\n-    externAndJsRoot.setIsSyntheticBlock(true);\n-\n-    if (options.tracer.isOn()) {\n-      tracker = new PerformanceTracker(jsRoot, options.tracer);\n-      addChangeHandler(tracker.getCodeChangeHandler());\n+    if (jsRoot != null) {\n+      initCompilerOptionsForPass(jsRoot);\n     }\n+  }\n \n-    Tracer tracer = newTracer(\"parseInputs\");\n-\n-    try {\n-      // Parse externs sources.\n-      for (CompilerInput input : externs) {\n-        Node n = input.getAstRoot(this);\n-        if (hasErrors()) {\n-          return null;\n-        }\n-        externsRoot.addChildToBack(n);\n-      }\n-\n-      // Modules inferred in ProcessCommonJS pass.\n-      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n-        processAMDAndCommonJSModules();\n-      }\n-\n-      // Check if inputs need to be rebuilt from modules.\n-      boolean staleInputs = false;\n-\n-      // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n-          options.closurePass) {\n-        for (CompilerInput input : inputs) {\n-          // Forward-declare all the provided types, so that they\n-          // are not flagged even if they are dropped from the process.\n-          for (String provide : input.getProvides()) {\n-            getTypeRegistry().forwardDeclareType(provide);\n-          }\n-        }\n+  /**\n+   * Gets the root node of the parse tree built by a call to\n+   * {@link #parse(JsAst)} or {@link #parse(SourceFileSet)}, or null\n+   * if no parse tree has been built yet.\n+   *\n+   * @return The root node\n+   */\n+  @Override\n+  public Node getJsRoot() {\n+    return jsRoot;\n+  }\n \n-        try {\n-          inputs =\n-              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n-              .manageDependencies(options.dependencyOptions, inputs);\n-          staleInputs = true;\n-        } catch (CircularDependencyException e) {\n-          report(JSError.make(\n-              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n-\n-          // If in IDE mode, we ignore the error and keep going.\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        } catch (MissingProvideException e) {\n-          report(JSError.make(\n-              MISSING_ENTRY_ERROR, e.getMessage()));\n+  /**\n+   * @return Whether some portion of the input has been parsed.\n+   */\n+  @Override\n+  public boolean isParsingDone() {\n+    return progress == Progress.PARSING_COMPLETE;\n+  }\n \n-          // If in IDE mode, we ignore the error and keep going.\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        }\n-      }\n+  /**\n+   * Create a {@link TypedScope} object of GLOBAL scope; all other scopes are\n+   * nested within the global scope.\n+   */\n+  public TypedScope createScope() {\n+    TypedScope scope = TypedScope.createGlobalScope(new Node(Token.GLOBAL_SCOPE));\n+    scopeCreator = new Es6SyntacticScopeCreator(compiler);\n+    return scope;\n+  }\n \n-      for (CompilerInput input : inputs) {\n-        Node n = input.getAstRoot(this);\n+  //------------------------------------------------------------------------\n+  // Pass management\n+  //------------------------------------------------------------------------\n \n-        // Inputs can have a null AST during initial parse.\n-        if (n == null) {\n-          continue;\n-        }\n+  /**\n+   * Resets the state of the compiler to its initial state, so that it\n+   * can be used to compile a new script. Note that the compiler's error\n+   * handlers are retained across resets, so this method does not silence\n+   * errors or warnings generated by the previous compile.\n+   */\n+  public void reset() {\n+    this.externs.clear();\n+    this.inputs.clear();\n+    this.topScope = null;\n+    this.symtab = null;\n+    this.codingConvention = null;\n+    this.reporter = null;\n+    this.defaultPassConfig.clearOptions();\n+    this.partialCodingConvention = null;\n+    this.reflectionHandler = null;\n+    this.transformations.clear();\n+    this.moduleGraph = null;\n+    this.typeCheckingHasRun = false;\n+    this.jsRoot = null;\n+    this.externsRoot = null;\n+    this.abstractInterpreter = null;\n+    this.sourceMap = null;\n+    this.typeValidator = null;\n+    this.reportChangeToEnclosingScope = false;\n+    this.esModulesThatNeedProcessing.clear();\n+    this.syntaxTree.clear();\n+    this.moduleLoader.clear();\n+    this.scopeCreator = null;\n+    this.inputIdGenerators.clear();\n+    resetTimings();\n+\n+    initOptions(new CompilerOptions());\n+\n+    initBuiltins(this.typeRegistry);\n+    initExternsRoot();\n+    this.topScope = createScope();\n+    initInputsById();\n+  }\n+\n+  /**\n+   * Sets up a listener that will be notified every time a new change\n+   * is made to an internal compiler state. If the changes affect the\n+   * external behavior of the compiler in any way, such as changing\n+   * its error-handling mode or the set of enabled optimizations, then\n+   * the listener's {@link CompilerPass#shouldRun} method should return\n+   * true to force re-creation of all passes. If the changes affect only\n+   * the internal behavior of the compiler, such as changing the subgraph\n+   * on which a pass runs or inserting a compiler pass at a particular\n+   * place in the pass pipeline, then the listener's\n+   * {@link CompilerPass#shouldRun} method should return false to allow\n+   * the compiler to re-use as many already-created passes as possible.\n+   *\n+   * @param handler The pass that will be notified of changes\n+   */\n+  public void addChangeHandler(CompilerPass handler) {\n+    changeHandlers.add(handler);\n+  }\n \n-        if (n.getJSDocInfo() != null) {\n-          JSDocInfo info = n.getJSDocInfo();\n-          if (info.isExterns()) {\n-            // If the input file is explicitly marked as an externs file, then\n-            // assume the programmer made a mistake and throw it into\n-            // the externs pile anyways.\n-            externsRoot.addChildToBack(n);\n-            input.setIsExtern(true);\n-\n-            input.getModule().remove(input);\n-\n-            externs.add(input);\n-            staleInputs = true;\n-          } else if (info.isNoCompile()) {\n-            input.getModule().remove(input);\n-            staleInputs = true;\n-          }\n-        }\n-      }\n+  /**\n+   * Removes a change handler that was previously added with\n+   * {@link #addChangeHandler}.\n+   *\n+   * @param handler The pass that was previously added\n+   */\n+  public void removeChangeHandler(CompilerPass handler) {\n+    changeHandlers.remove(handler);\n+  }\n \n-      if (staleInputs) {\n-        fillEmptyModules(modules);\n-        rebuildInputsFromModules();\n+  /**\n+   * Internal API used to notify all registered change handlers that a\n+   * change has been made to an internal state of the compiler. Clients\n+   * of the Compiler API should call {@link #reportChange} instead.\n+   */\n+  void handleChange() {\n+    for (CompilerPass pass : changeHandlers) {\n+      if (pass.shouldRun(this)) {\n+        invalidatePassResults(pass);\n       }\n+    }\n+  }\n \n-      // Build the AST.\n-      for (CompilerInput input : inputs) {\n-        Node n = input.getAstRoot(this);\n-        if (n == null) {\n-          continue;\n-        }\n-\n-        if (devMode) {\n-          runSanityCheck();\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        }\n-\n-        if (options.sourceMapOutputPath != null ||\n-            options.nameReferenceReportPath != null) {\n-\n-          // Annotate the nodes in the tree with information from the\n-          // input file. This information is used to construct the SourceMap.\n-          SourceInformationAnnotator sia =\n-              new SourceInformationAnnotator(\n-                  input.getName(), options.devMode != DevMode.OFF);\n-          NodeTraversal.traverse(this, n, sia);\n-        }\n-\n-        jsRoot.addChildToBack(n);\n-      }\n+  /**\n+   * Invalidates any cached compiler results associated with a particular pass.\n+   * This should be called whenever the compiler undergoes a change that could\n+   * affect the behavior of a pass, such as a change to its error-handling mode\n+   * or the set of enabled optimizations.\n+   *\n+   * @param pass The pass whose cached results should be invalidated\n+   */\n+  public void invalidatePassResults(CompilerPass pass) {\n+    if (cachedResultsByPass == null) {\n+      return;\n+    }\n \n-      if (hasErrors()) {\n-        return null;\n+    for (Map.Entry<CompilerPass, Object> entry : cachedResultsByPass.entrySet()) {\n+      if (entry.getKey().getClass() == pass.getClass()) {\n+        cachedResultsByPass.put(entry.getKey(), null);\n       }\n-      return externAndJsRoot;\n-    } finally {\n-      stopTracer(tracer, \"parseInputs\");\n     }\n   }\n \n+  /**\n+   * Requests that the compiler re-use previously-computed results for a\n+   * particular pass, if available. Clients that request results from a\n+   * pass should invoke this method just before invoking the pass, to give\n+   * the Compiler a chance to re-use an earlier result instead o\n+\n   /**\n    * Transforms AMD and CJS modules to something closure compiler can\n    * process and creates JSModules and the corresponding dependency tree",
    "result_reason": "error: reached end of file while parsing",
    "test_result": "ERROR"
}