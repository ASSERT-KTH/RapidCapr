{
    "patch": "/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\nboolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n\n  // Make sure this assignment is not in a loop.\n  Reference firstRef = ref;\n  Set<BasicBlock> seenBlocks = new HashSet<BasicBlock>();\n  for (BasicBlock block = ref.getBasicBlock();\n        block != null && !block.isLoop && !block.isFunction && seenBlocks.add(block);\n        block = block.getParent()) {\n    firstRef = ref;\n    ref = getOneAndOnlyAssignmentBefore(block, ref);\n    if (ref == null) {\n      break;\n    }\n  }\n\n  // There may be further re-assignments of the variable after the first,\n  // so check that the value assigned at the first re-assignment is never\n  // read before the next write.\n  if (ref != null) {\n    Set<Reference> seenRefs = new HashSet<Reference>();\n    seenRefs.add(firstRef);\n    while (true) {\n      referenceLoop: for (Reference use : ref.getUses()) {\n        BasicBlock usingBlock = use.getBasicBlock();\n        if (usingBlock.isLoop || usingBlock.isFunction) {\n          return false;\n        }\n        for (BasicBlock block = ref.getBasicBlock().getParent();\n             block != usingBlock.getParent(); block = block.getParent()) {\n          if (block.isLoop || block.isFunction) {\n            return false;\n          }\n        }\n        if (!seenRefs.add(use)) {\n          continue;\n        }\n        for (Reference rewritten : use.getAliasReferences()) {\n          if (seenRefs.contains(rewritten)) {\n            continue referenceLoop;\n          }\n        }\n        ref = use;\n        break;\n      }\n      if (seenRefs.contains(ref)) {\n        break;\n      }\n    }\n  }\n\n  return true;\n}\n\n/**\n * @return The first reference that assigns to this variable exactly once\n *     in the specified basic block, or null.\n */\nprivate Reference getOneAndOnlyAssignmentBefore(\n    BasicBlock block, Reference lastAssignment) {\n  int index = lastAssignment == null ? -1 : references.lastIndexOf(lastAssignment);\n  int lastIndex = -1;\n  boolean seenAssignment = false;\n  while (++index < references.size()) {\n    Reference ref = references.get(index);\n    if (ref.getBasicBlock() == block) {\n      if (ref.isDeclaration()) {\n        seenAssignment = true;\n      } else if (seenAssignment && ref.isSimpleAssignmentToName()) {\n        if (lastIndex != -1) {\n          // More than one assignment.\n          return null;\n        }\n        lastIndex = index;\n      }\n    }\n    if (ref == lastAssignment) {\n      break;\n    }\n  }\n  return lastIndex == -1 ? null : references.get(lastIndex);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..541b9dff 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,95 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+/**\n+ * @return Whether the variable is only assigned a value once for its\n+ *     lifetime.\n+ */\n+boolean isAssignedOnceInLifetime() {\n+  Reference ref = getOneAndOnlyAssignment();\n+  if (ref == null) {\n+    return false;\n+  }\n+\n+  // Make sure this assignment is not in a loop.\n+  Reference firstRef = ref;\n+  Set<BasicBlock> seenBlocks = new HashSet<BasicBlock>();\n+  for (BasicBlock block = ref.getBasicBlock();\n+        block != null && !block.isLoop && !block.isFunction && seenBlocks.add(block);\n+        block = block.getParent()) {\n+    firstRef = ref;\n+    ref = getOneAndOnlyAssignmentBefore(block, ref);\n+    if (ref == null) {\n+      break;\n+    }\n+  }\n+\n+  // There may be further re-assignments of the variable after the first,\n+  // so check that the value assigned at the first re-assignment is never\n+  // read before the next write.\n+  if (ref != null) {\n+    Set<Reference> seenRefs = new HashSet<Reference>();\n+    seenRefs.add(firstRef);\n+    while (true) {\n+      referenceLoop: for (Reference use : ref.getUses()) {\n+        BasicBlock usingBlock = use.getBasicBlock();\n+        if (usingBlock.isLoop || usingBlock.isFunction) {\n+          return false;\n+        }\n+        for (BasicBlock block = ref.getBasicBlock().getParent();\n+             block != usingBlock.getParent(); block = block.getParent()) {\n+          if (block.isLoop || block.isFunction) {\n+            return false;\n+          }\n+        }\n+        if (!seenRefs.add(use)) {\n+          continue;\n+        }\n+        for (Reference rewritten : use.getAliasReferences()) {\n+          if (seenRefs.contains(rewritten)) {\n+            continue referenceLoop;\n+          }\n+        }\n+        ref = use;\n+        break;\n+      }\n+      if (seenRefs.contains(ref)) {\n+        break;\n+      }\n+    }\n+  }\n+\n+  return true;\n+}\n+\n+/**\n+ * @return The first reference that assigns to this variable exactly once\n+ *     in the specified basic block, or null.\n+ */\n+private Reference getOneAndOnlyAssignmentBefore(\n+    BasicBlock block, Reference lastAssignment) {\n+  int index = lastAssignment == null ? -1 : references.lastIndexOf(lastAssignment);\n+  int lastIndex = -1;\n+  boolean seenAssignment = false;\n+  while (++index < references.size()) {\n+    Reference ref = references.get(index);\n+    if (ref.getBasicBlock() == block) {\n+      if (ref.isDeclaration()) {\n+        seenAssignment = true;\n+      } else if (seenAssignment && ref.isSimpleAssignmentToName()) {\n+        if (lastIndex != -1) {\n+          // More than one assignment.\n+          return null;\n+        }\n+        lastIndex = index;\n+      }\n+    }\n+    if (ref == lastAssignment) {\n+      break;\n+    }\n+  }\n+  return lastIndex == -1 ? null : references.get(lastIndex);\n+}\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}