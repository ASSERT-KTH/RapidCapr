{
    "patch": "import java.util.Optional;\n\npublic class NumberUtils {\n\n    private static final double DEFAULT_EPSILON = 0.0001;\n\n    public static Optional<Integer> parseInt(String str) {\n        Optional<Integer> result;\n        try {\n            result = Optional.of(Integer.parseInt(str));\n        } catch (Exception e) {\n            result = Optional.empty();\n        }\n        return result;\n    }\n\n    public static boolean approxEquals(double a, double b) {\n        return approxEquals(a, b, DEFAULT_EPSILON);\n    }\n\n    public static boolean approxEquals(double a, double b, double epsilon) {\n        return Math.abs(a - b) < epsilon;\n    }\n\n    public static double truncate(double value, int precision) {\n        double multiplier = Math.pow(10, precision);\n>>> [ INFILL ] <<<\n        return Math.round(value * multiplier) / multiplier;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 8df302f9..e1c084d3 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -141,6 +141,36 @@ public class FastDateParser implements DateParser, Serializable {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n+import java.util.Optional;\n+\n+public class NumberUtils {\n+\n+    private static final double DEFAULT_EPSILON = 0.0001;\n+\n+    public static Optional<Integer> parseInt(String str) {\n+        Optional<Integer> result;\n+        try {\n+            result = Optional.of(Integer.parseInt(str));\n+        } catch (Exception e) {\n+            result = Optional.empty();\n+        }\n+        return result;\n+    }\n+\n+    public static boolean approxEquals(double a, double b) {\n+        return approxEquals(a, b, DEFAULT_EPSILON);\n+    }\n+\n+    public static boolean approxEquals(double a, double b, double epsilon) {\n+        return Math.abs(a - b) < epsilon;\n+    }\n+\n+    public static double truncate(double value, int precision) {\n+        double multiplier = Math.pow(10, precision);\n+>>> [ INFILL ] <<<\n+        return Math.round(value * multiplier) / multiplier;\n+    }\n+}\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}