{
    "patch": "  protected double initializeStep(final boolean forward, final int order, final double[] scales,\n                                   final double t0, final double[] y0, final double[] yDot0,\n                                   final double[] y1, final double[][] yDot) {\n\n        final double[] yMiddle = new double[y0.length];\n        final double h = initialStepSize == null ?\n                FastMath.abs(t0) * new double[]{1e-5, 0.001, 0.1, 0.5}[FastMath.min(order, 3)] :\n                initialStepSize.doubleValue();\n        double rh = 0;\n        final double[] tempDot1 = new double[y0.length];\n        final double[] tempDot2 = new double[y0.length];\n\n        while (rh == 0) {\n            final double y0a = y0[0] + h * 0.5;\n            final double y0b = y0[0] - h * 0.5;\n            computeDerivatives(t0 + h * 0.5, y0a, tempDot1);\n            computeDerivatives(t0 + h * 0.5, y0b, tempDot2);\n            for (int i = 0; i < y0.length; ++i) {\n                yMiddle[i] = y0[i] + h * (tempDot1[i] + tempDot2[i]) * 0.25;\n            }\n            computeDerivatives(t0 + h, yMiddle, yDot[1]);\n\n            for (int i = 0; i < y0.length; ++i) {\n                final double max = FastMath.max(FastMath.abs(y0[i]), FastMath.abs(y1[i]));\n                final double scaled = scales[i] / max;\n                final double tol = 2 * FastMath.max(FastMath.ulp(y0[i]), FastMath.ulp(y1[i])) / FastMath.abs(scaled);\n                double di = (yDot[1][i] - yDot0[i]) * h;\n                di = forward ? di : -di;\n                final double ratio = di / tol;\n                final double r = (ratio == 0) ? 0 : FastMath.abs(ratio);\n                if (rh == 0 || r > rh) {\n                    rh = r;\n                }\n            }\n            if (rh == 0) {\n                h *= 2;\n            }\n        }\n\n        h = FastMath.min(hMax, FastMath.max(hMin, h * FastMath.pow(rh, power)));\n\n        return forward ? h : -h;\n\n  }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..6fa94e788 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,50 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+  protected double initializeStep(final boolean forward, final int order, final double[] scales,\n+                                   final double t0, final double[] y0, final double[] yDot0,\n+                                   final double[] y1, final double[][] yDot) {\n+\n+        final double[] yMiddle = new double[y0.length];\n+        final double h = initialStepSize == null ?\n+                FastMath.abs(t0) * new double[]{1e-5, 0.001, 0.1, 0.5}[FastMath.min(order, 3)] :\n+                initialStepSize.doubleValue();\n+        double rh = 0;\n+        final double[] tempDot1 = new double[y0.length];\n+        final double[] tempDot2 = new double[y0.length];\n+\n+        while (rh == 0) {\n+            final double y0a = y0[0] + h * 0.5;\n+            final double y0b = y0[0] - h * 0.5;\n+            computeDerivatives(t0 + h * 0.5, y0a, tempDot1);\n+            computeDerivatives(t0 + h * 0.5, y0b, tempDot2);\n+            for (int i = 0; i < y0.length; ++i) {\n+                yMiddle[i] = y0[i] + h * (tempDot1[i] + tempDot2[i]) * 0.25;\n+            }\n+            computeDerivatives(t0 + h, yMiddle, yDot[1]);\n+\n+            for (int i = 0; i < y0.length; ++i) {\n+                final double max = FastMath.max(FastMath.abs(y0[i]), FastMath.abs(y1[i]));\n+                final double scaled = scales[i] / max;\n+                final double tol = 2 * FastMath.max(FastMath.ulp(y0[i]), FastMath.ulp(y1[i])) / FastMath.abs(scaled);\n+                double di = (yDot[1][i] - yDot0[i]) * h;\n+                di = forward ? di : -di;\n+                final double ratio = di / tol;\n+                final double r = (ratio == 0) ? 0 : FastMath.abs(ratio);\n+                if (rh == 0 || r > rh) {\n+                    rh = r;\n+                }\n+            }\n+            if (rh == 0) {\n+                h *= 2;\n+            }\n+        }\n+\n+        h = FastMath.min(hMax, FastMath.max(hMin, h * FastMath.pow(rh, power)));\n+\n+        return forward ? h : -h;\n+\n+  }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}