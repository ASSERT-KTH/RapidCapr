{
    "patch": "static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n  if (callNode == null) {\n    return false;\n  }\n\n  // Only function call Nodes have side effects.\n  if (callNode.getToken() != Token.CALL) {\n    return false;\n  }\n\n  // Functions that have been marked as having no side effects.\n  if (callNode.isNoSideEffectsCall()) {\n    return false;\n  }\n\n  // Built-in functions without side effects.\n  Node callee = callNode.getFirstChild();\n  if (callee.isQualifiedName()) {\n    String functionName = callee.getOriginalQualifiedName();\n    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(functionName)) {\n      return false;\n    }\n  }\n\n  // Only check the properties of GETPROP nodes.\n  if (callee.getToken() == Token.GETPROP) {\n    String propertyName = callee.getLastChild().getString();\n\n    // Object methods without side effects.\n    boolean isSingleChild = callNode.getChildCount() == 1;\n    if (isSingleChild && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(propertyName)) {\n      return false;\n    }\n\n    // Calls that only modify the \"this\" keyword and are accessing variables or functions on \"this\".\n    boolean isAccessingThis = callee.getFirstChild().isThis();\n    boolean isOnlyModifiesThisCall = callNode.isOnlyModifiesThisCall();\n    boolean isAccessingVariable =\n        isAccessingThis && callee.getLastChild().getToken() == Token.NAME;\n    boolean isAccessingFunction =\n        isAccessingThis && callee.getLastChild().getToken() == Token.GETPROP;\n    if (isAccessingThis\n        && isOnlyModifiesThisCall\n        && (isAccessingVariable || isAccessingFunction)) {\n      return false;\n    }\n\n    // The \"Math\" object has no side effects.\n    boolean isMathNamespace = callee.getFirstChild().isName()\n        && callee.getFirstChild().getString().equals(\"Math\");\n    if (isMathNamespace) {\n      return false;\n    }\n\n    // Regular expressions and string methods without side effects.\n    if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n      Node instance = callee.getFirstChild();\n      if (instance.getToken() == Token.REGEXP && REGEXP_METHODS.contains(propertyName)) {\n        return false;\n      }\n      if (instance.getToken() == Token.STRING\n          && STRING_REGEXP_METHODS.contains(propertyName)\n          && callNode.getChildCount() == 2) {\n        Node param = callee.getNext();\n        if (param != null && (param.isString() || param.getToken() == Token.REGEXP)) {\n          return false;\n        }\n      }\n    }\n  }\n\n  return true;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 1844b18a..7e83c25d 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -923,58 +923,80 @@ public final class NodeUtil {\n    * @param compiler A compiler object to provide program state changing\n    *     context information. Can be null.\n    */\n-  static boolean functionCallHasSideEffects(\n-      Node callNode, @Nullable AbstractCompiler compiler) {\n-    if (callNode.getType() != Token.CALL) {\n-      throw new IllegalStateException(\n-          \"Expected CALL node, got \" + Token.name(callNode.getType()));\n+static boolean functionCallHasSideEffects(Node callNode, @Nullable AbstractCompiler compiler) {\n+  if (callNode == null) {\n+    return false;\n+  }\n+\n+  // Only function call Nodes have side effects.\n+  if (callNode.getToken() != Token.CALL) {\n+    return false;\n+  }\n+\n+  // Functions that have been marked as having no side effects.\n+  if (callNode.isNoSideEffectsCall()) {\n+    return false;\n+  }\n+\n+  // Built-in functions without side effects.\n+  Node callee = callNode.getFirstChild();\n+  if (callee.isQualifiedName()) {\n+    String functionName = callee.getOriginalQualifiedName();\n+    if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(functionName)) {\n+      return false;\n     }\n+  }\n \n-    if (callNode.isNoSideEffectsCall()) {\n+  // Only check the properties of GETPROP nodes.\n+  if (callee.getToken() == Token.GETPROP) {\n+    String propertyName = callee.getLastChild().getString();\n+\n+    // Object methods without side effects.\n+    boolean isSingleChild = callNode.getChildCount() == 1;\n+    if (isSingleChild && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(propertyName)) {\n       return false;\n     }\n \n-    Node nameNode = callNode.getFirstChild();\n+    // Calls that only modify the \"this\" keyword and are accessing variables or functions on \"this\".\n+    boolean isAccessingThis = callee.getFirstChild().isThis();\n+    boolean isOnlyModifiesThisCall = callNode.isOnlyModifiesThisCall();\n+    boolean isAccessingVariable =\n+        isAccessingThis && callee.getLastChild().getToken() == Token.NAME;\n+    boolean isAccessingFunction =\n+        isAccessingThis && callee.getLastChild().getToken() == Token.GETPROP;\n+    if (isAccessingThis\n+        && isOnlyModifiesThisCall\n+        && (isAccessingVariable || isAccessingFunction)) {\n+      return false;\n+    }\n \n-    // Built-in functions with no side effects.\n-    if (nameNode.getType() == Token.NAME) {\n-      String name = nameNode.getString();\n-      if (BUILTIN_FUNCTIONS_WITHOUT_SIDEEFFECTS.contains(name)) {\n-        return false;\n-      }\n-    } else if (nameNode.getType() == Token.GETPROP) {\n-      if (callNode.hasOneChild()\n-          && OBJECT_METHODS_WITHOUT_SIDEEFFECTS.contains(\n-                nameNode.getLastChild().getString())) {\n-        return false;\n-      }\n+    // The \"Math\" object has no side effects.\n+    boolean isMathNamespace = callee.getFirstChild().isName()\n+        && callee.getFirstChild().getString().equals(\"Math\");\n+    if (isMathNamespace) {\n+      return false;\n+    }\n \n-      if (callNode.isOnlyModifiesThisCall()\n-          && evaluatesToLocalValue(nameNode.getFirstChild())) {\n+    // Regular expressions and string methods without side effects.\n+    if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n+      Node instance = callee.getFirstChild();\n+      if (instance.getToken() == Token.REGEXP && REGEXP_METHODS.contains(propertyName)) {\n         return false;\n       }\n-\n-      // Functions in the \"Math\" namespace have no side effects.\n-\n-      if (compiler != null && !compiler.hasRegExpGlobalReferences()) {\n-        if (nameNode.getFirstChild().getType() == Token.REGEXP\n-            && REGEXP_METHODS.contains(nameNode.getLastChild().getString())) {\n-          return false;\n-        } else if (nameNode.getFirstChild().getType() == Token.STRING\n-            && STRING_REGEXP_METHODS.contains(\n-                nameNode.getLastChild().getString())) {\n-          Node param = nameNode.getNext();\n-          if (param != null &&\n-              (param.getType() == Token.STRING\n-                  || param.getType() == Token.REGEXP))\n+      if (instance.getToken() == Token.STRING\n+          && STRING_REGEXP_METHODS.contains(propertyName)\n+          && callNode.getChildCount() == 2) {\n+        Node param = callee.getNext();\n+        if (param != null && (param.isString() || param.getToken() == Token.REGEXP)) {\n           return false;\n         }\n       }\n     }\n-\n-    return true;\n   }\n \n+  return true;\n+}\n+\n   /**\n    * @return Whether the call has a local result.\n    */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}