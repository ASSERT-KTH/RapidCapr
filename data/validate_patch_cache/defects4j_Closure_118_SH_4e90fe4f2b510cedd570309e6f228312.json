{
    "patch": "  private void handleObjectLit(NodeTraversal t, Node n) {\n    if (!renameObjectProperties) {\n      return;\n    }\n\n    NodeTraversal.Callback callback = this.getPropagateCallback(t);\n    NodeTraversal.traverseEs6(compiler, n, callback);\n\n    for (Node child = n.getFirstChild();\n        child != null;\n        child = child.getNext()) {\n      // Maybe STRING, GET, SET\n      if (child.isString()) {\n        // We should never see a mix of numbers and strings.\n        String name = child.getString();\n\n        T type = null;\n        if (n.getType() == Token.ASSIGN) {\n          CodingConvention convention = compiler.getCodingConvention();\n          String isConstantKey = convention.getExportProperty();\n          boolean isModule = isModuleExport(n);\n          if (isModule) {\n            type = moduleMap.<T>getExport(getModuleId(), name);\n          } else if (child.getNext() != null && isObjectLitKey(child)) {\n            // Symbols in the form a:b are not transformed.\n            // isObjectLitKey returns false for {a:x()[expr]} as well.\n            Node value = child.getNext();\n            if (value != null && value.getNext() == null) {\n              type = determineCalleeTypeFromContext(t, child, value);\n            }\n          } else {\n            Var var = getSymbolDeclaredBy(NodeUtil.getEnclosingScript(n), name);\n            if (var != null && var.isExtern()) {\n              if (child.getNext().isAssign()) {\n                boolean isConst = NodeUtil.isImmutableValue(child.getNext().getLastChild());\n                if (!isConst) {\n                  type = null;\n                }\n              }\n            } else {\n              type = typeSystem.getType(getScope(), n, name);\n            }\n          }\n        } else {\n          type = typeSystem.getType(getScope(), n, name);\n        }\n\n        Property prop = getProperty(name);\n        if (!prop.scheduleRenaming(child,\n                                   processProperty(t, prop, type, null))) {\n          // TODO(user): It doesn't look like the user can do much in this\n          // case right now.\n          if (propertiesToErrorFor.containsKey(name)) {\n            compiler.report(JSError.make(\n                t.getSourceName(), child, propertiesToErrorFor.get(name),\n                Warnings.INVALIDATION, name,\n                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n          }\n        }\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex b34921ed..d03e4543 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -492,6 +492,68 @@ class DisambiguateProperties<T> implements CompilerPass {\n           child != null;\n           child = child.getNext()) {\n         // Maybe STRING, GET, SET\n+  private void handleObjectLit(NodeTraversal t, Node n) {\n+    if (!renameObjectProperties) {\n+      return;\n+    }\n+\n+    NodeTraversal.Callback callback = this.getPropagateCallback(t);\n+    NodeTraversal.traverseEs6(compiler, n, callback);\n+\n+    for (Node child = n.getFirstChild();\n+        child != null;\n+        child = child.getNext()) {\n+      // Maybe STRING, GET, SET\n+      if (child.isString()) {\n+        // We should never see a mix of numbers and strings.\n+        String name = child.getString();\n+\n+        T type = null;\n+        if (n.getType() == Token.ASSIGN) {\n+          CodingConvention convention = compiler.getCodingConvention();\n+          String isConstantKey = convention.getExportProperty();\n+          boolean isModule = isModuleExport(n);\n+          if (isModule) {\n+            type = moduleMap.<T>getExport(getModuleId(), name);\n+          } else if (child.getNext() != null && isObjectLitKey(child)) {\n+            // Symbols in the form a:b are not transformed.\n+            // isObjectLitKey returns false for {a:x()[expr]} as well.\n+            Node value = child.getNext();\n+            if (value != null && value.getNext() == null) {\n+              type = determineCalleeTypeFromContext(t, child, value);\n+            }\n+          } else {\n+            Var var = getSymbolDeclaredBy(NodeUtil.getEnclosingScript(n), name);\n+            if (var != null && var.isExtern()) {\n+              if (child.getNext().isAssign()) {\n+                boolean isConst = NodeUtil.isImmutableValue(child.getNext().getLastChild());\n+                if (!isConst) {\n+                  type = null;\n+                }\n+              }\n+            } else {\n+              type = typeSystem.getType(getScope(), n, name);\n+            }\n+          }\n+        } else {\n+          type = typeSystem.getType(getScope(), n, name);\n+        }\n+\n+        Property prop = getProperty(name);\n+        if (!prop.scheduleRenaming(child,\n+                                   processProperty(t, prop, type, null))) {\n+          // TODO(user): It doesn't look like the user can do much in this\n+          // case right now.\n+          if (propertiesToErrorFor.containsKey(name)) {\n+            compiler.report(JSError.make(\n+                t.getSourceName(), child, propertiesToErrorFor.get(name),\n+                Warnings.INVALIDATION, name,\n+                (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n+          }\n+        }\n+      }\n+    }\n+  }\n \n         // We should never see a mix of numbers and strings.\n         String name = child.getString();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}