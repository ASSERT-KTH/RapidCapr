{
    "patch": "public Dfp multiply(final int x) {\n    Dfp result = newInstance();\n    boolean isNegative = false;\n    if (x < 0) {\n        isNegative = true;\n        x = -x;\n    }\n    result.exp = exp;\n    if (x != 0 && !isNaN()) {\n        final int[] product = new int[NUMP];\n        final int[] carry = new int[NUMP];\n\n        final int[] factor = new int[MTEN +1];\n        factor[1] = x;\n\n        for (int i = 2; i <= MTEN; i++) {\n            if (i == x) {\n                System.arraycopy(product, 0, carry, 0, NUMP);\n            }\n            int digit = 0;\n            int j = NUMP - 1;\n            int k = NUMP - 1 - i + 2;\n            while (k < NUMP) {\n                digit += data[k] * factor[i - j];\n                k++;\n                j--;\n            }\n            carry[NUMP - i + 1] = digit;\n        }\n        int digit = 0;\n        int j = NUMP - 1;\n        int k = NUMP - MTEN;\n        while (k < NUMP) {\n            digit += data[k] * factor[MTEN - j];\n            k++;\n            j--;\n        }\n        carry[NUMP - MTEN] = digit;\n\n        int rh = 0;\n        for (int i = NUMP - 1; i >= 0; i--) {\n            rh = carry[i] + product[i] + rh / RADIX;\n            result.data[i] = rh % RADIX;\n        }\n        result.exp = exp + 7;\n        while (result.exp > maximumField) {\n            final Dfp t = newInstance(isNegative ? -1 : 1);\n            t.exp = result.exp - maximumField;\n            if (t.exp > maximumField) {\n                t.exp = maximumField;\n            }\n            t.divideThis(result);\n            t.round(result);\n        }\n        result.checkCompact();\n    } else if (isNaN()) {\n        result = newInstance(this);\n    }\n    if (isNegative) {\n        result = result.negate();\n    }\n    return result;\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..171ad548b 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,69 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public Dfp multiply(final int x) {\n+    Dfp result = newInstance();\n+    boolean isNegative = false;\n+    if (x < 0) {\n+        isNegative = true;\n+        x = -x;\n+    }\n+    result.exp = exp;\n+    if (x != 0 && !isNaN()) {\n+        final int[] product = new int[NUMP];\n+        final int[] carry = new int[NUMP];\n+\n+        final int[] factor = new int[MTEN +1];\n+        factor[1] = x;\n+\n+        for (int i = 2; i <= MTEN; i++) {\n+            if (i == x) {\n+                System.arraycopy(product, 0, carry, 0, NUMP);\n+            }\n+            int digit = 0;\n+            int j = NUMP - 1;\n+            int k = NUMP - 1 - i + 2;\n+            while (k < NUMP) {\n+                digit += data[k] * factor[i - j];\n+                k++;\n+                j--;\n+            }\n+            carry[NUMP - i + 1] = digit;\n+        }\n+        int digit = 0;\n+        int j = NUMP - 1;\n+        int k = NUMP - MTEN;\n+        while (k < NUMP) {\n+            digit += data[k] * factor[MTEN - j];\n+            k++;\n+            j--;\n+        }\n+        carry[NUMP - MTEN] = digit;\n+\n+        int rh = 0;\n+        for (int i = NUMP - 1; i >= 0; i--) {\n+            rh = carry[i] + product[i] + rh / RADIX;\n+            result.data[i] = rh % RADIX;\n+        }\n+        result.exp = exp + 7;\n+        while (result.exp > maximumField) {\n+            final Dfp t = newInstance(isNegative ? -1 : 1);\n+            t.exp = result.exp - maximumField;\n+            if (t.exp > maximumField) {\n+                t.exp = maximumField;\n+            }\n+            t.divideThis(result);\n+            t.round(result);\n+        }\n+        result.checkCompact();\n+    } else if (isNaN()) {\n+        result = newInstance(this);\n+    }\n+    if (isNegative) {\n+        result = result.negate();\n+    }\n+    return result;\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}