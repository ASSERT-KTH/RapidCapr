{
    "patch": "import org.apache.commons.math3.analysis.UnivariateFunction;\nimport org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver;\nimport org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils;\nimport org.apache.commons.math3.exception.MaxIterationsExceededException;\nimport org.apache.commons.math3.exception.NoBracketingException;\n\npublic class MySolver extends BaseAbstractUnivariateSolver<UnivariateFunction> {\n\n    public final static double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n\n    public MySolver() {\n        super(DEFAULT_ABSOLUTE_ACCURACY);\n    }\n\n    public MySolver(final double absoluteAccuracy) {\n        super(absoluteAccuracy);\n    }\n\n    public MySolver(final double relativeAccuracy,\n                    final double absoluteAccuracy) {\n        super(relativeAccuracy, absoluteAccuracy);\n    }\n\n    public MySolver(final double relativeAccuracy,\n                    final double absoluteAccuracy,\n                    final double functionValueAccuracy) {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n    }\n    \n    @Override\n    protected double doSolve() throws MaxIterationsExceededException, NoBracketingException {\n        double min = getMin();\n        double max = getMax();\n        \n        clearResult();\n        verifyInterval(min, max);\n\n        double ret = Double.NaN;\n        \n        double yMin = computeObjectiveValue(min);\n        double yMax = computeObjectiveValue(max);\n        \n        // verify bracketing\n        double sign = yMin * yMax;\n        if (sign > 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n                ret = min;\n                setResult(ret, 0);\n                return ret;\n            }\n            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n                ret = max;\n                setResult(ret, 0);\n                return ret;\n            }\n\n            // neither value is close to zero and min and max do not bracket root.\n            throw new NoBracketingException(min, max, yMin, yMax);\n        } else if (sign < 0) {\n            // solve using only the first endpoint as initial guess\n            ret = solve(min, yMin, max, yMax, min, yMin);\n            // either min or max is a root\n        } else {\n            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n                ret = min;\n                setResult(ret, 0);\n                return ret;\n            }\n            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n                ret = max;\n                setResult(ret, 0);\n                return ret;\n            }\n\n            // sign == 0\n            ret = min;\n            setResult(ret, 0);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Compute the objective function value.\n     *\n     * @param point Point at which the objective function must be evaluated.\n     * @return the value of the objective function.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     */\n    protected double computeObjectiveValue(double point) {\n        incrementEvaluationCount();\n        return getFunctionValue(point);\n    }\n    \n    /**\n     * Solve for a root.\n     *\n     * @param x0 Initial point.\n     * @param y0 function value at x0 (ignored).\n     * @param x1 Bracket point.\n     * @param y1 function value at x1 (ignored).\n     * @param x2 Bracket point.\n     * @param y2 function value at x2 (ignored).\n     * @return the value where the function is zero.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     * @throws NoBracketingException if the function cannot be bracketed.\n     */\n    protected double solve(double x0, double y0,\n                           double x1, double y1,\n                           double x2, double y2)\n        throws NoBracketingException {\n        final double absoluteAccuracy = getAbsoluteAccuracy();\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n\n        // tolerance for termination\n        final double ftol = 1e-10;\n        \n        // Miller's algorithm requires that at least one endpoint be the root\n        if (Math.abs(y0) <= Math.abs(y1)) {\n            // swap\n            double tmp1 = x0;\n            x0 = x1;\n            x1 = tmp1;\n            \n            double tmp2 = y0;\n            y0 = y1;\n            y1 = tmp2;\n        }\n        if (Math.abs(y2) <= Math.abs(y1)) {\n            // swap\n            double tmp1 = x2;\n            x2 = x1;\n            x1 = tmp1;\n            \n            double tmp2 = y2;\n            y2 = y1;\n            y1 = tmp2;\n        }\n\n        // Miller's algorithm starts with x0 as root: verify that before\n        // doing anything else\n        if ((y0 < 0) && (y2 > 0) || (y0 > 0) && (y2 < 0)) {\n            return x0;\n        }\n        if (y0 == 0) {\n            return x0;\n        }\n\n        final double m;\n        double fm;\n\n        // check to see if bisection is forced\n        if ((y1 > 0 && y2 < 0) || (y1 < 0 && y2 > 0)) {\n            fm = f(x2);\n            m = x1;\n        } else {\n            fm = f(x1);\n            m = (y1 < 0 ? x1 - (x1 - x0) * y1 / (y0 - y1)\n                    : x1 - (x2 - x1) * y1 / (y2 - y1));\n        }\n        double fM;\n\n        // start Miller's iterations\n        for (;;) {\n            final double delta = absoluteAccuracy + functionValueAccuracy * Math.abs(m);\n            fM = f(m);\n            if (Math.abs(fM) <= delta ||\n                // force bisection\n                ((m - x0) / 2) < absoluteAccuracy) {\n                return m;\n            }\n            if (fm * fM > 0) {\n                fm = fM;\n                x1 = m;\n                y1 = fM;\n            } else {\n                y2 = fM;\n                x2 = m;\n            }\n            final double dm = (y2 - y1) / (y2 + y1);\n            final double dx;\n            if (fm * fM > 0) {\n                dx = x2 - x1;\n                y0 = fm;\n            } else {\n                dx = x1 - x0;\n                fm = f(x0);\n                y0 = fm;\n            }\n            if (Math.abs(dx) < ftol * Math.max(Math.abs(x1), 1.0)) {\n                // Miller's algorithm succeedded...\n                return m;\n            }\n            if (Math.abs(dm) <= ftol) {\n                // ...but convergence is slow, switch to bisection.\n                return 0.5 * (x0 + x2);\n            }\n            final double q = fM / fm;\n            final double T = y0 - y2;\n            final double S = y1 - y2;\n            final double R = fm - fM;\n            final double P = dx * (S * T * R - dx * q * (T - R * q));\n            final double D = (S + (2 * q - 1) * R) * (T - R * q) * dx;\n            if (P < 0) {\n                // This condition means that Miller's algorithm has\n                // failed to produce a better value than bisection.\n                // Switch to bisection in the next iteration.\n                P = -P;\n            } else {\n                // adjust step size\n                D = Math.sqrt(P) / (S - (2 * q - 1) * R);\n            }\n            // next estimate\n            final double x = m + D;\n            final double fx = f(x);\n            if (fx < 0) {\n                x0 = m;\n                fm = fM;\n                x1 = x;\n                y1 = fx;\n            } else {\n                x2 = x;\n                y2 = fx;\n            }\n            if (x1 > x2) {\n                // swap\n                double tmp1 = x1;\n                x1 = x2;\n                x2 = tmp1;\n                \n                double tmp2 = y1;\n                y1 = y2;\n                y2 = tmp2;\n            }\n            final double delta1 = Math.max(absoluteAccuracy, relativeAccuracy * Math.abs(x1));\n            if ((Math.abs(delta1 * (y2 / (y2 + y1))) < getAbsoluteAccuracy()) || UnivariateSolverUtils.isSequence(x2, x0, getMaximalOrder())) {\n                // the values appear to have converged\n                return 0.5 * (x1 + x2);\n            }\n            // prepare next iteration\n            m = x;\n            fm = fx;\n        }\n    }\n    \n    /**\n     * Compute the function value.\n     *\n     * @param x Point at which the function must be evaluated.\n     * @return the value of the function.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations\n     * is exceeded.\n     */\n    final double f(final double x) {\n        return computeObjectiveValue(x);\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..f62df9985 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,34 +122,266 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n+import org.apache.commons.math3.analysis.UnivariateFunction;\n+import org.apache.commons.math3.analysis.solvers.BaseAbstractUnivariateSolver;\n+import org.apache.commons.math3.analysis.solvers.UnivariateSolverUtils;\n+import org.apache.commons.math3.exception.MaxIterationsExceededException;\n+import org.apache.commons.math3.exception.NoBracketingException;\n+\n+public class MySolver extends BaseAbstractUnivariateSolver<UnivariateFunction> {\n+\n+    public final static double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+\n+    public MySolver() {\n+        super(DEFAULT_ABSOLUTE_ACCURACY);\n+    }\n+\n+    public MySolver(final double absoluteAccuracy) {\n+        super(absoluteAccuracy);\n+    }\n+\n+    public MySolver(final double relativeAccuracy,\n+                    final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+    }\n+\n+    public MySolver(final double relativeAccuracy,\n+                    final double absoluteAccuracy,\n+                    final double functionValueAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+    }\n+    \n+    @Override\n+    protected double doSolve() throws MaxIterationsExceededException, NoBracketingException {\n+        double min = getMin();\n+        double max = getMax();\n         \n         clearResult();\n         verifyInterval(min, max);\n-        \n+\n         double ret = Double.NaN;\n         \n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n+        double yMin = computeObjectiveValue(min);\n+        double yMax = computeObjectiveValue(max);\n         \n-        // Verify bracketing\n+        // verify bracketing\n         double sign = yMin * yMax;\n-        if (sign >= 0) {\n+        if (sign > 0) {\n             // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n-        } else {\n+            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n+                ret = min;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n+                ret = max;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+\n+            // neither value is close to zero and min and max do not bracket root.\n+            throw new NoBracketingException(min, max, yMin, yMax);\n+        } else if (sign < 0) {\n             // solve using only the first endpoint as initial guess\n             ret = solve(min, yMin, max, yMax, min, yMin);\n             // either min or max is a root\n+        } else {\n+            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n+                ret = min;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+            if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n+                ret = max;\n+                setResult(ret, 0);\n+                return ret;\n+            }\n+\n+            // sign == 0\n+            ret = min;\n+            setResult(ret, 0);\n         }\n \n         return ret;\n     }\n+\n+    /**\n+     * Compute the objective function value.\n+     *\n+     * @param point Point at which the objective function must be evaluated.\n+     * @return the value of the objective function.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    protected double computeObjectiveValue(double point) {\n+        incrementEvaluationCount();\n+        return getFunctionValue(point);\n+    }\n+    \n+    /**\n+     * Solve for a root.\n+     *\n+     * @param x0 Initial point.\n+     * @param y0 function value at x0 (ignored).\n+     * @param x1 Bracket point.\n+     * @param y1 function value at x1 (ignored).\n+     * @param x2 Bracket point.\n+     * @param y2 function value at x2 (ignored).\n+     * @return the value where the function is zero.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     * @throws NoBracketingException if the function cannot be bracketed.\n+     */\n+    protected double solve(double x0, double y0,\n+                           double x1, double y1,\n+                           double x2, double y2)\n+        throws NoBracketingException {\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        // tolerance for termination\n+        final double ftol = 1e-10;\n+        \n+        // Miller's algorithm requires that at least one endpoint be the root\n+        if (Math.abs(y0) <= Math.abs(y1)) {\n+            // swap\n+            double tmp1 = x0;\n+            x0 = x1;\n+            x1 = tmp1;\n+            \n+            double tmp2 = y0;\n+            y0 = y1;\n+            y1 = tmp2;\n+        }\n+        if (Math.abs(y2) <= Math.abs(y1)) {\n+            // swap\n+            double tmp1 = x2;\n+            x2 = x1;\n+            x1 = tmp1;\n+            \n+            double tmp2 = y2;\n+            y2 = y1;\n+            y1 = tmp2;\n+        }\n+\n+        // Miller's algorithm starts with x0 as root: verify that before\n+        // doing anything else\n+        if ((y0 < 0) && (y2 > 0) || (y0 > 0) && (y2 < 0)) {\n+            return x0;\n+        }\n+        if (y0 == 0) {\n+            return x0;\n+        }\n+\n+        final double m;\n+        double fm;\n+\n+        // check to see if bisection is forced\n+        if ((y1 > 0 && y2 < 0) || (y1 < 0 && y2 > 0)) {\n+            fm = f(x2);\n+            m = x1;\n+        } else {\n+            fm = f(x1);\n+            m = (y1 < 0 ? x1 - (x1 - x0) * y1 / (y0 - y1)\n+                    : x1 - (x2 - x1) * y1 / (y2 - y1));\n+        }\n+        double fM;\n+\n+        // start Miller's iterations\n+        for (;;) {\n+            final double delta = absoluteAccuracy + functionValueAccuracy * Math.abs(m);\n+            fM = f(m);\n+            if (Math.abs(fM) <= delta ||\n+                // force bisection\n+                ((m - x0) / 2) < absoluteAccuracy) {\n+                return m;\n+            }\n+            if (fm * fM > 0) {\n+                fm = fM;\n+                x1 = m;\n+                y1 = fM;\n+            } else {\n+                y2 = fM;\n+                x2 = m;\n+            }\n+            final double dm = (y2 - y1) / (y2 + y1);\n+            final double dx;\n+            if (fm * fM > 0) {\n+                dx = x2 - x1;\n+                y0 = fm;\n+            } else {\n+                dx = x1 - x0;\n+                fm = f(x0);\n+                y0 = fm;\n+            }\n+            if (Math.abs(dx) < ftol * Math.max(Math.abs(x1), 1.0)) {\n+                // Miller's algorithm succeedded...\n+                return m;\n+            }\n+            if (Math.abs(dm) <= ftol) {\n+                // ...but convergence is slow, switch to bisection.\n+                return 0.5 * (x0 + x2);\n+            }\n+            final double q = fM / fm;\n+            final double T = y0 - y2;\n+            final double S = y1 - y2;\n+            final double R = fm - fM;\n+            final double P = dx * (S * T * R - dx * q * (T - R * q));\n+            final double D = (S + (2 * q - 1) * R) * (T - R * q) * dx;\n+            if (P < 0) {\n+                // This condition means that Miller's algorithm has\n+                // failed to produce a better value than bisection.\n+                // Switch to bisection in the next iteration.\n+                P = -P;\n+            } else {\n+                // adjust step size\n+                D = Math.sqrt(P) / (S - (2 * q - 1) * R);\n+            }\n+            // next estimate\n+            final double x = m + D;\n+            final double fx = f(x);\n+            if (fx < 0) {\n+                x0 = m;\n+                fm = fM;\n+                x1 = x;\n+                y1 = fx;\n+            } else {\n+                x2 = x;\n+                y2 = fx;\n+            }\n+            if (x1 > x2) {\n+                // swap\n+                double tmp1 = x1;\n+                x1 = x2;\n+                x2 = tmp1;\n+                \n+                double tmp2 = y1;\n+                y1 = y2;\n+                y2 = tmp2;\n+            }\n+            final double delta1 = Math.max(absoluteAccuracy, relativeAccuracy * Math.abs(x1));\n+            if ((Math.abs(delta1 * (y2 / (y2 + y1))) < getAbsoluteAccuracy()) || UnivariateSolverUtils.isSequence(x2, x0, getMaximalOrder())) {\n+                // the values appear to have converged\n+                return 0.5 * (x1 + x2);\n+            }\n+            // prepare next iteration\n+            m = x;\n+            fm = fx;\n+        }\n+    }\n+    \n+    /**\n+     * Compute the function value.\n+     *\n+     * @param x Point at which the function must be evaluated.\n+     * @return the value of the function.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations\n+     * is exceeded.\n+     */\n+    final double f(final double x) {\n+        return computeObjectiveValue(x);\n+    }\n+}\n         \n     /**\n      * Find a zero starting search according to the three provided points.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}