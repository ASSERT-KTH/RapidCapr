{
    "patch": "      if (value.isFunction()) {\n        Node callNode = reference.getParent();\n        if (callNode != null && callNode.isCall()) {\n          if (NodeUtil.isFunctionExpression(value)) {\n            // Do not inline into a function expression being called\n            // Example: (function() { ... })()\n            if (callNode.getParent().isCall()) {\n              return false;\n            }\n          } else {\n            // This is a function call site. Check if it is a reference to a\n            // singleton getter method.\n            CodingConvention convention = compiler.getCodingConvention();\n            String className = convention.getSingletonGetterClassName(value);\n            if (className != null) {\n              // Do not inline singleton getter methods into class defining calls\n              // as this confuses class removing logic.\n              SubclassRelationship relationship =\n                  convention.getClassesDefinedByCall(callNode);\n              if (relationship != null &&\n                  relationship.isDerivedFrom(className)) {\n                return false;\n              }\n            }\n          }\n        }\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..ddfd99d8 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,33 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+      if (value.isFunction()) {\n+        Node callNode = reference.getParent();\n+        if (callNode != null && callNode.isCall()) {\n+          if (NodeUtil.isFunctionExpression(value)) {\n+            // Do not inline into a function expression being called\n+            // Example: (function() { ... })()\n+            if (callNode.getParent().isCall()) {\n+              return false;\n+            }\n+          } else {\n+            // This is a function call site. Check if it is a reference to a\n+            // singleton getter method.\n+            CodingConvention convention = compiler.getCodingConvention();\n+            String className = convention.getSingletonGetterClassName(value);\n+            if (className != null) {\n+              // Do not inline singleton getter methods into class defining calls\n+              // as this confuses class removing logic.\n+              SubclassRelationship relationship =\n+                  convention.getClassesDefinedByCall(callNode);\n+              if (relationship != null &&\n+                  relationship.isDerivedFrom(className)) {\n+                return false;\n+              }\n+            }\n+          }\n+        }\n+      }\n         }\n       }\n ",
    "result_reason": "error: variable callNode is already defined in method canInline(Reference,Reference,Reference)",
    "test_result": "ERROR"
}