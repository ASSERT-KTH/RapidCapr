{
    "patch": "public Dfp multiply(final int x) {\n    if (x >= 0 && x < RADIX) {\n        return multiplyFast(x);\n    } else {\n        final DfpField field = getField();\n        final int precision = field.getRadixDigits();\n        final int RADIX = field.getRadix();\n        final int len = 1 + (int) (1.2 * (double) precision / DFPBase.LOG10_2);\n        final Dfp[] r = new Dfp[len];\n        final boolean[] e = new boolean[len];\n        final int mult[] = new int[len];\n        final BigInteger q = BigInteger.valueOf((long) x);\n        \n        boolean anyNonZero = false;\n        for (int i = 0; i < len; i++) {\n            final BigInteger[] divrem = field.getDivideAndRemainder(q, BigInteger.valueOf(RADIX));\n            mult[i] = divrem[1].intValue();\n            e[i] = anyNonZero;\n            anyNonZero |= (mult[i] != 0);\n            q = divrem[0];\n        }\n        Dfp power = newInstance(10).pow(e[0] ? 1 : 0);\n        r[0] = multiplyFast(mult[0]);\n        for (int i = 1; i < len; i++) {\n            power = power.multiply(power);\n            r[i] = multiplyFast(mult[i]);\n            if (e[i]) {\n                r[i] = r[i].multiply(power);\n            }\n        }\n        Dfp result = r[len - 1];\n        for (int i = len - 2; i >= 0; i--) {\n            result = result.multiply(power);\n            result = result.add(r[i]);\n        }\n        return result;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..830a258e6 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,42 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+public Dfp multiply(final int x) {\n+    if (x >= 0 && x < RADIX) {\n+        return multiplyFast(x);\n+    } else {\n+        final DfpField field = getField();\n+        final int precision = field.getRadixDigits();\n+        final int RADIX = field.getRadix();\n+        final int len = 1 + (int) (1.2 * (double) precision / DFPBase.LOG10_2);\n+        final Dfp[] r = new Dfp[len];\n+        final boolean[] e = new boolean[len];\n+        final int mult[] = new int[len];\n+        final BigInteger q = BigInteger.valueOf((long) x);\n+        \n+        boolean anyNonZero = false;\n+        for (int i = 0; i < len; i++) {\n+            final BigInteger[] divrem = field.getDivideAndRemainder(q, BigInteger.valueOf(RADIX));\n+            mult[i] = divrem[1].intValue();\n+            e[i] = anyNonZero;\n+            anyNonZero |= (mult[i] != 0);\n+            q = divrem[0];\n+        }\n+        Dfp power = newInstance(10).pow(e[0] ? 1 : 0);\n+        r[0] = multiplyFast(mult[0]);\n+        for (int i = 1; i < len; i++) {\n+            power = power.multiply(power);\n+            r[i] = multiplyFast(mult[i]);\n+            if (e[i]) {\n+                r[i] = r[i].multiply(power);\n+            }\n+        }\n+        Dfp result = r[len - 1];\n+        for (int i = len - 2; i >= 0; i--) {\n+            result = result.multiply(power);\n+            result = result.add(r[i]);\n+        }\n+        return result;\n     }\n }\n+}",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}