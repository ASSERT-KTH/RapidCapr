{
    "patch": "private void inlineAliases(GlobalNamespace namespace) {\n  // Invariant: All the names in the worklist meet condition (a).\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n\n    // Don't attempt to inline a getter or setter property as a variable.\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n\n    if (name.globalSets == 1 && name.localSets == 0 &&\n        name.aliasingGets == 0) {\n      // {@code name} meets condition (a).\n      // Add all children of {@code name} to the worklist, since they will\n      // necessarily be invoked as {@code name}.\n      if (name.props != null) {\n        workList.addAll(name.props);\n      }\n    } else if (name.type == Name.Type.OBJECTLIT && name.props == null &&\n               name.aliasingGets > 1 && name.localSets == 0) {\n      // We can turn {@code name} into a simple alias or a no-op var.\n      //\n      // If {@code name} is assigned to more than once in the function\n      // scope, then there might be cases that we can't handle (such as\n      // when the name is used in an expression). So ignore aliases that\n      // have multiple assignments.\n      //\n      // If {@code name} has any local mutation, then it will be difficult\n      // to inline its values. So ignore them.\n      if (name.getDeclaration() == null) {\n        // {@code name} has no declaration because it's an alias.\n        Node node = name.getAliasingNode();\n        Node parent = node.getParent();\n        if (node.isName()) {\n          parent.replaceChild(node, IR.name(name.getBaseName()));\n        } else if (node.isGetProp()) {\n          parent.replaceChild(node, IR.getprop(IR.name(name.getBaseName()),\n              IR.string(node.getLastChild().getString())));\n        } else {\n          continue;\n        }\n        name.flattenLocalSets();\n        compiler.reportCodeChange();\n      }\n    } else if (name.globalSets == 0 && name.localSets == 1 &&\n               name.aliasingGets == 0) {\n      // Replace the local definition site of {@code name} with its value.\n      Ref ref = name.getRefs().iterator().next();\n      Node definingValue = ref.node.getLastChild();\n      Node parent = ref.node.getParent();\n      if (parent == null) {\n        continue;\n      }\n      switch (ref.type) {\n        case SET_FROM_GLOBAL:\n          parent.replaceChild(ref.node, IR.exprResult(definingValue));\n          break;\n\n        case SET_FROM_LOCAL:\n        case VAR_INIT:\n          if (isLValueAllowedHere(definingValue)) {\n            parent.replaceChild(ref.node, definingValue.detach());\n          } else {\n            // We can't inline the definition of {@code name} here,\n            // so keep trying to inline its aliases.\n            continue;\n          }\n\n          break;\n\n        default:\n          continue;\n      }\n      name.removeRef(ref);\n      compiler.reportCodeChange();\n    } else if (name.globalSets >= 1 || name.localSets >= 1 ||\n               name.aliasingGets >= 1) {\n      // {@code name} has a complicated definition. So don't try to\n      // inline it, or any of its aliases.\n    }\n\n    // Check if {@code name} has any aliases left after the\n    // local-alias-inlining above.\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      // All of {@code name}'s children meet condition (a), so they can be\n      // added to the worklist.\n      workList.addAll(name.props);\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..0d7fb6a6 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,99 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+private void inlineAliases(GlobalNamespace namespace) {\n+  // Invariant: All the names in the worklist meet condition (a).\n+  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n+  while (!workList.isEmpty()) {\n+    Name name = workList.pop();\n+\n+    // Don't attempt to inline a getter or setter property as a variable.\n+    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n+      continue;\n+    }\n+\n+    if (name.globalSets == 1 && name.localSets == 0 &&\n+        name.aliasingGets == 0) {\n+      // {@code name} meets condition (a).\n+      // Add all children of {@code name} to the worklist, since they will\n+      // necessarily be invoked as {@code name}.\n+      if (name.props != null) {\n+        workList.addAll(name.props);\n+      }\n+    } else if (name.type == Name.Type.OBJECTLIT && name.props == null &&\n+               name.aliasingGets > 1 && name.localSets == 0) {\n+      // We can turn {@code name} into a simple alias or a no-op var.\n+      //\n+      // If {@code name} is assigned to more than once in the function\n+      // scope, then there might be cases that we can't handle (such as\n+      // when the name is used in an expression). So ignore aliases that\n+      // have multiple assignments.\n+      //\n+      // If {@code name} has any local mutation, then it will be difficult\n+      // to inline its values. So ignore them.\n+      if (name.getDeclaration() == null) {\n+        // {@code name} has no declaration because it's an alias.\n+        Node node = name.getAliasingNode();\n+        Node parent = node.getParent();\n+        if (node.isName()) {\n+          parent.replaceChild(node, IR.name(name.getBaseName()));\n+        } else if (node.isGetProp()) {\n+          parent.replaceChild(node, IR.getprop(IR.name(name.getBaseName()),\n+              IR.string(node.getLastChild().getString())));\n+        } else {\n+          continue;\n+        }\n+        name.flattenLocalSets();\n+        compiler.reportCodeChange();\n+      }\n+    } else if (name.globalSets == 0 && name.localSets == 1 &&\n+               name.aliasingGets == 0) {\n+      // Replace the local definition site of {@code name} with its value.\n+      Ref ref = name.getRefs().iterator().next();\n+      Node definingValue = ref.node.getLastChild();\n+      Node parent = ref.node.getParent();\n+      if (parent == null) {\n+        continue;\n+      }\n+      switch (ref.type) {\n+        case SET_FROM_GLOBAL:\n+          parent.replaceChild(ref.node, IR.exprResult(definingValue));\n+          break;\n+\n+        case SET_FROM_LOCAL:\n+        case VAR_INIT:\n+          if (isLValueAllowedHere(definingValue)) {\n+            parent.replaceChild(ref.node, definingValue.detach());\n+          } else {\n+            // We can't inline the definition of {@code name} here,\n+            // so keep trying to inline its aliases.\n+            continue;\n+          }\n+\n+          break;\n+\n+        default:\n+          continue;\n+      }\n+      name.removeRef(ref);\n+      compiler.reportCodeChange();\n+    } else if (name.globalSets >= 1 || name.localSets >= 1 ||\n+               name.aliasingGets >= 1) {\n+      // {@code name} has a complicated definition. So don't try to\n+      // inline it, or any of its aliases.\n+    }\n+\n+    // Check if {@code name} has any aliases left after the\n+    // local-alias-inlining above.\n+    if ((name.type == Name.Type.OBJECTLIT ||\n+         name.type == Name.Type.FUNCTION) &&\n+        name.aliasingGets == 0 && name.props != null) {\n+      // All of {@code name}'s children meet condition (a), so they can be\n+      // added to the worklist.\n+      workList.addAll(name.props);\n+    }\n+  }\n+}\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}