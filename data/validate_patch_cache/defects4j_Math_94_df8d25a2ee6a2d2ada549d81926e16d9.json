{
    "patch": "\tpublic static int gcd(int u, int v) {\n\t    if (u == 0) {\n\t        return Math.abs(v);\n\t    } else if (v == 0) {\n\t        return Math.abs(u);\n\t    } else {\n\t        // keep u and v negative, as negative integers range down to\n\t        // -2^31, while positive numbers can only be as large as 2^31-1\n\t        // (i.e. we can't necessarily negate a negative number without\n\t        // overflow)\n\t        /* assert u!=0 && v!=0; */\n\t        if (u > 0) {\n\t            u = -u;\n\t        } // make u negative\n\t        if (v > 0) {\n\t            v = -v;\n\t        } // make v negative\n\t        // B1. [Find power of 2]\n\t        int k = 0;\n\t        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n\t                                                            // both even...\n\t            u /= 2;\n\t            v /= 2;\n\t            k++; // cast out twos.\n\t        }\n\t        if (k == 31) {\n\t            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n\t        }\n\t        // B2. Initialize: u and v have been divided by 2^k and at least\n\t        // one is odd.\n\t        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n\t        // t negative: u was odd, v may be even (t replaces v)\n\t        // t positive: u was even, v is odd (t replaces u)\n\t        do {\n\t            /* assert u<0 && v<0; */\n\t            // B4/B3: cast out twos from t.\n\t            while ((t & 1) == 0) { // while t is even..\n\t                t /= 2; // cast out twos\n\t            }\n\t            // B5 [reset max(u,v)]\n\t            if (t > 0) {\n\t                u = -t;\n\t            } else {\n\t                v = t;\n\t            }\n\t            // B6/B3. at this point both u and v should be odd.\n\t            t = (v - u) / 2;\n\t            // |u| larger: t positive (replace u)\n\t            // |v| larger: t negative (replace v)\n\t        } while (t != 0);\n\t        return -u * (1 << k); // gcd is u*2^k\n\t    }\n\t}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/util/MathUtils.java b/src/java/org/apache/commons/math/util/MathUtils.java\nindex c5342aeb3..aeb9d2a3d 100644\n--- a/src/java/org/apache/commons/math/util/MathUtils.java\n+++ b/src/java/org/apache/commons/math/util/MathUtils.java\n@@ -409,7 +409,59 @@ public final class MathUtils {\n      * @since 1.1\n      */\n     public static int gcd(int u, int v) {\n-        if (u * v == 0) {\n+\tpublic static int gcd(int u, int v) {\n+\t    if (u == 0) {\n+\t        return Math.abs(v);\n+\t    } else if (v == 0) {\n+\t        return Math.abs(u);\n+\t    } else {\n+\t        // keep u and v negative, as negative integers range down to\n+\t        // -2^31, while positive numbers can only be as large as 2^31-1\n+\t        // (i.e. we can't necessarily negate a negative number without\n+\t        // overflow)\n+\t        /* assert u!=0 && v!=0; */\n+\t        if (u > 0) {\n+\t            u = -u;\n+\t        } // make u negative\n+\t        if (v > 0) {\n+\t            v = -v;\n+\t        } // make v negative\n+\t        // B1. [Find power of 2]\n+\t        int k = 0;\n+\t        while ((u & 1) == 0 && (v & 1) == 0 && k < 31) { // while u and v are\n+\t                                                            // both even...\n+\t            u /= 2;\n+\t            v /= 2;\n+\t            k++; // cast out twos.\n+\t        }\n+\t        if (k == 31) {\n+\t            throw new ArithmeticException(\"overflow: gcd is 2^31\");\n+\t        }\n+\t        // B2. Initialize: u and v have been divided by 2^k and at least\n+\t        // one is odd.\n+\t        int t = ((u & 1) == 1) ? v : -(u / 2)/* B3 */;\n+\t        // t negative: u was odd, v may be even (t replaces v)\n+\t        // t positive: u was even, v is odd (t replaces u)\n+\t        do {\n+\t            /* assert u<0 && v<0; */\n+\t            // B4/B3: cast out twos from t.\n+\t            while ((t & 1) == 0) { // while t is even..\n+\t                t /= 2; // cast out twos\n+\t            }\n+\t            // B5 [reset max(u,v)]\n+\t            if (t > 0) {\n+\t                u = -t;\n+\t            } else {\n+\t                v = t;\n+\t            }\n+\t            // B6/B3. at this point both u and v should be odd.\n+\t            t = (v - u) / 2;\n+\t            // |u| larger: t positive (replace u)\n+\t            // |v| larger: t negative (replace v)\n+\t        } while (t != 0);\n+\t        return -u * (1 << k); // gcd is u*2^k\n+\t    }\n+\t}\n             return (Math.abs(u) + Math.abs(v));\n         }\n         // keep u and v negative, as negative integers range down to",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}