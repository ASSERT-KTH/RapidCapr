{
    "patch": "public TypePair getTypesUnderInequality(JSType that) {\n    // unions types\n    if (that instanceof UnionType) {\n        TypePair p = that.getTypesUnderInequality(this);\n        return new TypePair(p.typeB, p.typeA);\n    }\n\n    // This method is only used in type analysis, so it's reasonable to assume\n    // that we are not dealing with any other non-primitive types.\n    JSType widerType = getLeastCommonAncestor(that);\n    boolean thisTruthiness = widerType.isTruthy();\n    boolean thatTruthiness = that.isTruthy();\n\n    // other types\n    switch (testForUnequalObjects(that)) {\n    case MUST_BE_TRUE:\n    case NON_PRIMITIVE:\n      return new TypePair(null, null);\n\n    case MUST_BE_FALSE:\n      if (!thisTruthiness || !thatTruthiness) {\n        // If one of the types can't be true, this will never be called, because\n        // the method will either return {}, {X, undefined}, or {undefined, X},\n        // depending on which type is X.\n        // If both types can be true, this will be called when we are looking\n        // for inequal types, and one of the types is falsey, but we don't know\n        // which one.\n        return new TypePair(widerType, widerType);\n      }\n\n      // This method is only used in two places:\n      // - in old type inference code in the IDE (not in production code)\n      // - during type analysis (in production code)\n      // In production code, a type mismatch in a comparison tree means that\n      // we are probably going to throw a runtime exception. As such, we can\n      // assume that if the types are compared for equality, they are not\n      // incompatible.\n      // Note that if \"widerType\" is a loose subtype of either \"this\" or \"that\",\n      // we will not return null as we normally would; instead, we will return\n      // the loosest type that subsumes both types.\n      return new TypePair(null, widerType);\n\n      // switch case is exhaustive\n    default:\n      throw new IllegalStateException();\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex aa8c7bc9..be94436c 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -693,25 +693,52 @@ public abstract class JSType implements Serializable {\n    *         element. The returned pair is never {@code null} even though its\n    *         components may be {@code null}\n    */\n-  public TypePair getTypesUnderInequality(JSType that) {\n+public TypePair getTypesUnderInequality(JSType that) {\n     // unions types\n     if (that instanceof UnionType) {\n-      TypePair p = that.getTypesUnderInequality(this);\n-      return new TypePair(p.typeB, p.typeA);\n+        TypePair p = that.getTypesUnderInequality(this);\n+        return new TypePair(p.typeB, p.typeA);\n     }\n \n+    // This method is only used in type analysis, so it's reasonable to assume\n+    // that we are not dealing with any other non-primitive types.\n+    JSType widerType = getLeastCommonAncestor(that);\n+    boolean thisTruthiness = widerType.isTruthy();\n+    boolean thatTruthiness = that.isTruthy();\n+\n     // other types\n-    switch (this.testForEquality(that)) {\n-      case TRUE:\n-        return new TypePair(null, null);\n+    switch (testForUnequalObjects(that)) {\n+    case MUST_BE_TRUE:\n+    case NON_PRIMITIVE:\n+      return new TypePair(null, null);\n \n-      case FALSE:\n-      case UNKNOWN:\n-        return new TypePair(this, that);\n-    }\n+    case MUST_BE_FALSE:\n+      if (!thisTruthiness || !thatTruthiness) {\n+        // If one of the types can't be true, this will never be called, because\n+        // the method will either return {}, {X, undefined}, or {undefined, X},\n+        // depending on which type is X.\n+        // If both types can be true, this will be called when we are looking\n+        // for inequal types, and one of the types is falsey, but we don't know\n+        // which one.\n+        return new TypePair(widerType, widerType);\n+      }\n \n-    // switch case is exhaustive\n-    throw new IllegalStateException();\n+      // This method is only used in two places:\n+      // - in old type inference code in the IDE (not in production code)\n+      // - during type analysis (in production code)\n+      // In production code, a type mismatch in a comparison tree means that\n+      // we are probably going to throw a runtime exception. As such, we can\n+      // assume that if the types are compared for equality, they are not\n+      // incompatible.\n+      // Note that if \"widerType\" is a loose subtype of either \"this\" or \"that\",\n+      // we will not return null as we normally would; instead, we will return\n+      // the loosest type that subsumes both types.\n+      return new TypePair(null, widerType);\n+\n+      // switch case is exhaustive\n+    default:\n+      throw new IllegalStateException();\n+    }\n   }\n \n   /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}