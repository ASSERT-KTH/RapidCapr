{
    "patch": "if (n.isFunction()) {\n  return false; // skip functions, since they don't have side-effects themselves\n}\n\nCompiler compiler = secondArg;\nPredicate<Node> canBeSideEffected = new Predicate<Node>() {\n  @Override\n  public boolean apply(Node node) {\n    if (NodeUtil.isImmutableValue(node)) {\n      return false;\n    }\n\n    if (node.isCall() || node.isNew()) {\n      if (NodeUtil.nodeTypeMayHaveSideEffects(node)) {\n        return true;\n      }\n      if (NodeUtil.functionCallHasSideEffects(node)) {\n        return true;\n      }\n      if (NodeUtil.constructorCallHasSideEffects(node)) {\n        return true;\n      }\n    } else {\n      return NodeUtil.mayHaveSideEffects(node, compiler);\n    }\n\n    return false;\n  }\n};\nFindSideEffectCalls finder = new FindSideEffectCalls(compiler, canBeSideEffected);\nNodeTraversal.traverse(compiler, n, finder);\nreturn finder.hasFoundSideEffects();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex a8e92fcc..2e38fabd 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,6 +99,38 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n+if (n.isFunction()) {\n+  return false; // skip functions, since they don't have side-effects themselves\n+}\n+\n+Compiler compiler = secondArg;\n+Predicate<Node> canBeSideEffected = new Predicate<Node>() {\n+  @Override\n+  public boolean apply(Node node) {\n+    if (NodeUtil.isImmutableValue(node)) {\n+      return false;\n+    }\n+\n+    if (node.isCall() || node.isNew()) {\n+      if (NodeUtil.nodeTypeMayHaveSideEffects(node)) {\n+        return true;\n+      }\n+      if (NodeUtil.functionCallHasSideEffects(node)) {\n+        return true;\n+      }\n+      if (NodeUtil.constructorCallHasSideEffects(node)) {\n+        return true;\n+      }\n+    } else {\n+      return NodeUtil.mayHaveSideEffects(node, compiler);\n+    }\n+\n+    return false;\n+  }\n+};\n+FindSideEffectCalls finder = new FindSideEffectCalls(compiler, canBeSideEffected);\n+NodeTraversal.traverse(compiler, n, finder);\n+return finder.hasFoundSideEffects();\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}