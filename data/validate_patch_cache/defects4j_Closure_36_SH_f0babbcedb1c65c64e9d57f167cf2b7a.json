{
    "patch": "          Node callTarget = reference.getFirstChild();\n          if (callTarget.isGetProp() && callTarget.getNext() == null) {\n            // As well as the special case of the singleton getter, ignore \"class\" and \"super\"\n            // and properties called \"then\" and \"catch\" on Promises.\n            boolean isPropertyNameValid =\n                !callTarget.getLastChild().getString().equals(\"class\")\n                    && !callTarget.getLastChild().getString().equals(\"super\")\n                    && !(value.isCall() && (callTarget.getLastChild().getString().equals(\"then\")\n                        || callTarget.getLastChild().getString().equals(\"catch\")));\n            if (isPropertyNameValid) {\n              Node targetObject = callTarget.getFirstChild();\n              ObjectType promiseType = compiler.getTypeRegistry()\n                  .getNativeObjectType(JSTypeNative.PROMISE_TYPE);\n              if (targetObject.matchesQualifiedName(\"google3.third_party.javascript\" +\n                      \".babel.src.main.core.jsc.jvm.binding.JavaScriptPromiseBindings\")\n                  || targetObject.getJSType().isSubtypeOf(promiseType)) {\n                return false;\n              }\n            }\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..8c6301ef 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,26 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+          Node callTarget = reference.getFirstChild();\n+          if (callTarget.isGetProp() && callTarget.getNext() == null) {\n+            // As well as the special case of the singleton getter, ignore \"class\" and \"super\"\n+            // and properties called \"then\" and \"catch\" on Promises.\n+            boolean isPropertyNameValid =\n+                !callTarget.getLastChild().getString().equals(\"class\")\n+                    && !callTarget.getLastChild().getString().equals(\"super\")\n+                    && !(value.isCall() && (callTarget.getLastChild().getString().equals(\"then\")\n+                        || callTarget.getLastChild().getString().equals(\"catch\")));\n+            if (isPropertyNameValid) {\n+              Node targetObject = callTarget.getFirstChild();\n+              ObjectType promiseType = compiler.getTypeRegistry()\n+                  .getNativeObjectType(JSTypeNative.PROMISE_TYPE);\n+              if (targetObject.matchesQualifiedName(\"google3.third_party.javascript\" +\n+                      \".babel.src.main.core.jsc.jvm.binding.JavaScriptPromiseBindings\")\n+                  || targetObject.getJSType().isSubtypeOf(promiseType)) {\n+                return false;\n+              }\n+            }\n+          }\n         }\n       }\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}