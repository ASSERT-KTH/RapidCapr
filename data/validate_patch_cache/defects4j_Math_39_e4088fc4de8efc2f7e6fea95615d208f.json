{
    "patch": "        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n\n        if (!isLastStep) {\n            // prepare next step\n            interpolator.storeTime(stepStart);\n\n            if (fsal) {\n                // save the last evaluation for the next step\n                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n            }\n\n            // stepsize control for next step\n            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n            double scaledH = stepSize * factor;\n            if (scaledH > remainingTime) {\n              scaledH = remainingTime;\n            }\n            final double filteredNextT = stepStart + scaledH;\n            final boolean filteredNextIsLast = forward ? filteredNextT >= t : filteredNextT <= t;\n            if (filteredNextIsLast) {\n                scaledH = forward ? t - stepStart : t - stepStart;\n            }\n            remainingTime -= scaledH;\n            hNew = scaledH;\n\n            if (remainingTime <= 0) {\n                isLastStep = true;\n                hNew += remainingTime;\n            }\n        }\n\n    } while (!isLastStep);\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..41bc3a6f3 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,45 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+        stepStart = acceptStep(interpolator, y, yDotTmp, t);\n+        System.arraycopy(y, 0, yTmp, 0, y.length);\n+\n+        if (!isLastStep) {\n+            // prepare next step\n+            interpolator.storeTime(stepStart);\n+\n+            if (fsal) {\n+                // save the last evaluation for the next step\n+                System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n+            }\n+\n+            // stepsize control for next step\n+            final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+            double scaledH = stepSize * factor;\n+            if (scaledH > remainingTime) {\n+              scaledH = remainingTime;\n+            }\n+            final double filteredNextT = stepStart + scaledH;\n+            final boolean filteredNextIsLast = forward ? filteredNextT >= t : filteredNextT <= t;\n+            if (filteredNextIsLast) {\n+                scaledH = forward ? t - stepStart : t - stepStart;\n+            }\n+            remainingTime -= scaledH;\n+            hNew = scaledH;\n+\n+            if (remainingTime <= 0) {\n+                isLastStep = true;\n+                hNew += remainingTime;\n+            }\n+        }\n+\n+    } while (!isLastStep);\n+\n+    // dispatch results\n+    equations.setTime(stepStart);\n+    equations.setCompleteState(y);\n+\n+    resetInternalState();\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: while expected",
    "test_result": "ERROR"
}