{
    "patch": "  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      Branch branch = edge.getValue();\n      if (branch == null) {\n        continue;\n      }\n      if (branch.getType() == Token.TRY) {\n         return true;\n      }\n      Node succ = edge.getDestination().getValue();\n      if (succ.getType() == Token.CATCH || succ.getType() == Token.FINALLY) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private boolean isDirective(AstNode n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    if (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) {\n      n = ((AstNode)n.getFirstChild()); // MOVED THIS LINE\n      // because this fix added an additional check for empty child nodes,\n      // which is now invoked on the correct node type\n      if (nType != Token.STRING) {\n        return false;\n      }\n      String directive = n.getString().trim();\n      return ALLOWED_DIRECTIVES.contains(directive);\n    }\n    return false;\n  }\n\n  @Override\n  Node processBlock(Block blockNode) {\n    return processGenericBlock(blockNode); // RENAMED METHOD\n  }\n\n  private Node processGenericBlock(ScriptNode blockNode) { // ADDED THIS METHOD\n    Node result = newNode(Token.BLOCK);\n    Node child = blockNode.getFirstChild();\n    while (child != null) {\n      if (!isDirective(child)) {\n        result.addChildToBack(transform(child));\n      }\n      child = child.getNext();\n    }\n    return result;\n  }\n\n  @Override\n  Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  @Override\n  Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  @Override\n  Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  Node processForInLoop(ForInLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getIterator()),\n        transform(loopNode.getIteratedObject()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  Node processForLoop(ForLoop loopNode) {\n    Node node = newNode(\n        Token.FOR,\n        transform(loopNode.getInitializer()),\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement()));\n    node.addChildToBack(transformBlock(loopNode.getBody()));\n    return node;\n  }\n\n  @Override\n  Node processFunctionCall(FunctionCall callNode) {\n    Node node = newNode(transformTokenType(callNode.getType()),\n                         transform(callNode.getTarget()));\n    for (AstNode child : callNode.getArguments()) {\n      node.addChildToBack(transform(child));\n    }\n\n    int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n    node.setLineno(callNode.getLineno());\n    node.setCharno(position2charno(leftParamPos));\n    return node;\n  }\n\n  @Override\n  Node processFunctionNode(FunctionNode functionNode) {\n    Name functionName = functionNode.getFunctionName();\n    if (functionName == null) {\n      functionName = new Name();\n      functionName.setIdentifier(\"\");\n      functionName.setLineno(functionNode.getLineno());\n      functionName.setCharno(functionNode.getAbsolutePosition() + \"function\".length());\n    }\n\n    Node functionNodeAst = newNode(Token.FUNCTION);\n    Node functionNameAst = transform(functionName);\n    functionNodeAst.addChildToBack(functionNameAst);\n\n    Node lpAst = newNode(Token.LP);\n    lpAst.setLineno(functionNameAst.getLineno());\n    lpAst.setCharno(functionNameAst.getCharno() + functionNameAst.getLength());\n\n    for (AstNode param : functionNode.getParams()) {\n      lpAst.addChildToFront(transform(param));\n    }\n\n    Node bodyNode = transform(functionNode.getBody());\n    parseDirectives(bodyNode);\n    lpAst.addChildToBack(processGenericBlock(functionNode));\n\n    Node rpAst = newNode(Token.RP);\n    rpAst.setLineno(lpAst.getLineno());\n    rpAst.setCharno(lpAst.getCharno() + lpAst.getLength() + 1);\n\n    functionNodeAst.addChildToBack(lpAst);\n    functionNodeAst.addChildToBack(rpAst);\n    return functionNodeAst;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..486a3675 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,6 +514,202 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      Branch branch = edge.getValue();\n+      if (branch == null) {\n+        continue;\n+      }\n+      if (branch.getType() == Token.TRY) {\n+         return true;\n+      }\n+      Node succ = edge.getDestination().getValue();\n+      if (succ.getType() == Token.CATCH || succ.getType() == Token.FINALLY) {\n+        return true;\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private boolean isDirective(AstNode n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    if (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) {\n+      n = ((AstNode)n.getFirstChild()); // MOVED THIS LINE\n+      // because this fix added an additional check for empty child nodes,\n+      // which is now invoked on the correct node type\n+      if (nType != Token.STRING) {\n+        return false;\n+      }\n+      String directive = n.getString().trim();\n+      return ALLOWED_DIRECTIVES.contains(directive);\n+    }\n+    return false;\n+  }\n+\n+  @Override\n+  Node processBlock(Block blockNode) {\n+    return processGenericBlock(blockNode); // RENAMED METHOD\n+  }\n+\n+  private Node processGenericBlock(ScriptNode blockNode) { // ADDED THIS METHOD\n+    Node result = newNode(Token.BLOCK);\n+    Node child = blockNode.getFirstChild();\n+    while (child != null) {\n+      if (!isDirective(child)) {\n+        result.addChildToBack(transform(child));\n+      }\n+      child = child.getNext();\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processForInLoop(ForInLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getIterator()),\n+        transform(loopNode.getIteratedObject()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  Node processForLoop(ForLoop loopNode) {\n+    Node node = newNode(\n+        Token.FOR,\n+        transform(loopNode.getInitializer()),\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement()));\n+    node.addChildToBack(transformBlock(loopNode.getBody()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processFunctionCall(FunctionCall callNode) {\n+    Node node = newNode(transformTokenType(callNode.getType()),\n+                         transform(callNode.getTarget()));\n+    for (AstNode child : callNode.getArguments()) {\n+      node.addChildToBack(transform(child));\n+    }\n+\n+    int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n+    node.setLineno(callNode.getLineno());\n+    node.setCharno(position2charno(leftParamPos));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processFunctionNode(FunctionNode functionNode) {\n+    Name functionName = functionNode.getFunctionName();\n+    if (functionName == null) {\n+      functionName = new Name();\n+      functionName.setIdentifier(\"\");\n+      functionName.setLineno(functionNode.getLineno());\n+      functionName.setCharno(functionNode.getAbsolutePosition() + \"function\".length());\n+    }\n+\n+    Node functionNodeAst = newNode(Token.FUNCTION);\n+    Node functionNameAst = transform(functionName);\n+    functionNodeAst.addChildToBack(functionNameAst);\n+\n+    Node lpAst = newNode(Token.LP);\n+    lpAst.setLineno(functionNameAst.getLineno());\n+    lpAst.setCharno(functionNameAst.getCharno() + functionNameAst.getLength());\n+\n+    for (AstNode param : functionNode.getParams()) {\n+      lpAst.addChildToFront(transform(param));\n+    }\n+\n+    Node bodyNode = transform(functionNode.getBody());\n+    parseDirectives(bodyNode);\n+    lpAst.addChildToBack(processGenericBlock(functionNode));\n+\n+    Node rpAst = newNode(Token.RP);\n+    rpAst.setLineno(lpAst.getLineno());\n+    rpAst.setCharno(lpAst.getCharno() + lpAst.getLength() + 1);\n+\n+    functionNodeAst.addChildToBack(lpAst);\n+    functionNodeAst.addChildToBack(rpAst);\n+    return functionNodeAst;\n+  }\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}