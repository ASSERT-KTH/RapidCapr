{
    "patch": "\u00a0\u00a0Node parseInputs() {\n\u00a0\u00a0\u00a0\u00a0boolean devMode = options.devMode != DevMode.OFF;\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (options.instrumentForCoverage) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0instrumentationBuilder = new CoverageInstrumentationBuilder(this, codingConvention);\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (options.processCommonJSModules) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0commonJs = new ProcessCommonJSModules(this, modules, options);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0commonJs.process();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!options.skipAllPasses) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inputs = updatedInputs(commonJs.getInputs(), inputs, options.dependencyOptions, modules);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (externsRoot != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0externsRoot.detachChildren();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0if (jsRoot != null) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jsRoot.detachChildren();\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0jsRoot = IR.block();\n\u00a0\u00a0\u00a0\u00a0jsRoot.setIsSyntheticBlock(true);\n\u00a0\u00a0\u00a0\u00a0externsRoot = IR.block();\n\u00a0\u00a0\u00a0\u00a0externsRoot.setIsSyntheticBlock(true);\n\u00a0\u00a0\u00a0\u00a0unorderedExternsRoot = IR.block();\n\u00a0\u00a0\u00a0\u00a0unorderedExternsRoot.setIsSyntheticBlock(true);\n\u00a0\u00a0\u00a0\u00a0unorderedJsRoot = IR.block();\n\u00a0\u00a0\u00a0\u00a0unorderedJsRoot.setIsSyntheticBlock(true);\n\u00a0\u00a0\u00a0\u00a0externAndJsRoot = IR.block(externsRoot, jsRoot);\n\u00a0\u00a0\u00a0\u00a0externAndJsRoot.setIsSyntheticBlock(true);\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0if (options.tracer.isOn()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Poor-man's exclusive time tracking: don't bother instrumenting\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the time spent in the first read of the sources, because\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the disk access overheads tend to skew the results.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tracker = new PerformanceTracker(jsRoot, options.tracer);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addChangeHandler(tracker.getCodeChangeHandler());\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0boolean parseJsDocDocumentation = options.parseJsDocDocumentation;\n\u00a0\u00a0\u00a0\u00a0if (options.jsDocParsingMode == Options.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0options.parseJsDocDocumentation = true;\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0try {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parseInputsInternal(inputs, externs, jsRoot, externsRoot,\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unorderedJsRoot, unorderedExternsRoot);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.findTypesForLocalOptimization) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Call the type inference algorithm.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ArrayList<Node> typeRoots = Lists.newArrayList();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0typeRoots.add(jsRoot);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TypeInferencePass inferencePass =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new TypeInferencePass(this, typeRoots);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inferencePass.process(null);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (CompilerInput input : inputs) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0InputId inputId = input.getInputId();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (inputId.isModule()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Double check to make sure that we've ruled out all invalid\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// module declarations.\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!commonJs.getAllModuleIds().contains(inputId.getId())) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0report(JSError.make(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0INVALID_MODULE_DECLARATION, input.getName()));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.dependencyOptions.needsManagement() &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0!options.skipAllPasses &&\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0options.closurePass) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0buildDependenciesFromInputs(\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inputs, options.dependencyOptions, modules);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.warningLevel.verbose && options.checkGlobalThisLevel.isOn()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CheckGlobalThis checkGlobalThis =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new CheckGlobalThis(this, options.checkGlobalThisLevel, options.languageIn);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NodeTraversal.traverse(this, jsRoot, checkGlobalThis);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.checkSymbols) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CheckSymbols symbolChecker =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new CheckSymbols(this, options.enforceAccessControlCodingConventions);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NodeTraversal.traverse(this, jsRoot, symbolChecker);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.enableTypedInference) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TypeInferencePass inferencePass =\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new TypeInferencePass(this, ImmutableList.of(jsRoot));\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inferencePass.process(null);\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.newTypeInference) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inferTypes();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.instrumentForCoverage) {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0instrumentationBuilder.process();\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return externAndJsRoot;\n\u00a0\u00a0\u00a0\u00a0} finally {\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0options.parseJsDocDocumentation = parseJsDocDocumentation;\n\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n\u00a0\u00a0\u00a0\u00a0}\n\u00a0\u00a0}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..441f0871 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1200,191 +1200,146 @@ public class Compiler extends AbstractCompiler {\n   }\n \n   @Override\n-  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n-    if (abstractInterpreter == null) {\n-      ChainableReverseAbstractInterpreter interpreter =\n-          new SemanticReverseAbstractInterpreter(\n-              getCodingConvention(), getTypeRegistry());\n-      if (options.closurePass) {\n-        interpreter = new ClosureReverseAbstractInterpreter(\n-            getCodingConvention(), getTypeRegistry())\n-            .append(interpreter).getFirst();\n-      }\n-      abstractInterpreter = interpreter;\n-    }\n-    return abstractInterpreter;\n-  }\n-\n-  @Override\n-  TypeValidator getTypeValidator() {\n-    if (typeValidator == null) {\n-      typeValidator = new TypeValidator(this);\n-    }\n-    return typeValidator;\n-  }\n-\n-  //------------------------------------------------------------------------\n-  // Parsing\n-  //------------------------------------------------------------------------\n-\n-  /**\n-   * Parses the externs and main inputs.\n-   *\n-   * @return A synthetic root node whose two children are the externs root\n-   *     and the main root\n-   */\n-  Node parseInputs() {\n-    boolean devMode = options.devMode != DevMode.OFF;\n-\n-    // If old roots exist (we are parsing a second time), detach each of the\n-    // individual file parse trees.\n-    if (externsRoot != null) {\n-      externsRoot.detachChildren();\n-    }\n-    if (jsRoot != null) {\n-      jsRoot.detachChildren();\n-    }\n-\n-    // Parse main js sources.\n-    jsRoot = IR.block();\n-    jsRoot.setIsSyntheticBlock(true);\n-\n-    externsRoot = IR.block();\n-    externsRoot.setIsSyntheticBlock(true);\n-\n-    externAndJsRoot = IR.block(externsRoot, jsRoot);\n-    externAndJsRoot.setIsSyntheticBlock(true);\n-\n-    if (options.tracer.isOn()) {\n-      tracker = new PerformanceTracker(jsRoot, options.tracer);\n-      addChangeHandler(tracker.getCodeChangeHandler());\n-    }\n-\n-    Tracer tracer = newTracer(\"parseInputs\");\n-\n-    try {\n-      // Parse externs sources.\n-      for (CompilerInput input : externs) {\n-        Node n = input.getAstRoot(this);\n-        if (hasErrors()) {\n-          return null;\n-        }\n-        externsRoot.addChildToBack(n);\n-      }\n-\n-      // Modules inferred in ProcessCommonJS pass.\n-      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n-        processAMDAndCommonJSModules();\n-      }\n-\n-      // Check if inputs need to be rebuilt from modules.\n-      boolean staleInputs = false;\n-\n-      // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n-          options.closurePass) {\n-        for (CompilerInput input : inputs) {\n-          // Forward-declare all the provided types, so that they\n-          // are not flagged even if they are dropped from the process.\n-          for (String provide : input.getProvides()) {\n-            getTypeRegistry().forwardDeclareType(provide);\n-          }\n-        }\n-\n-        try {\n-          inputs =\n-              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n-              .manageDependencies(options.dependencyOptions, inputs);\n-          staleInputs = true;\n-        } catch (CircularDependencyException e) {\n-          report(JSError.make(\n-              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n-\n-          // If in IDE mode, we ignore the error and keep going.\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        } catch (MissingProvideException e) {\n-          report(JSError.make(\n-              MISSING_ENTRY_ERROR, e.getMessage()));\n-\n-          // If in IDE mode, we ignore the error and keep going.\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        }\n-      }\n-\n-      for (CompilerInput input : inputs) {\n-        Node n = input.getAstRoot(this);\n-\n-        // Inputs can have a null AST during initial parse.\n-        if (n == null) {\n-          continue;\n-        }\n-\n-        if (n.getJSDocInfo() != null) {\n-          JSDocInfo info = n.getJSDocInfo();\n-          if (info.isExterns()) {\n-            // If the input file is explicitly marked as an externs file, then\n-            // assume the programmer made a mistake and throw it into\n-            // the externs pile anyways.\n-            externsRoot.addChildToBack(n);\n-            input.setIsExtern(true);\n-\n-            input.getModule().remove(input);\n-\n-            externs.add(input);\n-            staleInputs = true;\n-          } else if (info.isNoCompile()) {\n-            input.getModule().remove(input);\n-            staleInputs = true;\n-          }\n-        }\n-      }\n-\n-      if (staleInputs) {\n-        fillEmptyModules(modules);\n-        rebuildInputsFromModules();\n-      }\n-\n-      // Build the AST.\n-      for (CompilerInput input : inputs) {\n-        Node n = input.getAstRoot(this);\n-        if (n == null) {\n-          continue;\n-        }\n-\n-        if (devMode) {\n-          runSanityCheck();\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        }\n-\n-        if (options.sourceMapOutputPath != null ||\n-            options.nameReferenceReportPath != null) {\n-\n-          // Annotate the nodes in the tree with information from the\n-          // input file. This information is used to construct the SourceMap.\n-          SourceInformationAnnotator sia =\n-              new SourceInformationAnnotator(\n-                  input.getName(), options.devMode != DevMode.OFF);\n-          NodeTraversal.traverse(this, n, sia);\n-        }\n-\n-        jsRoot.addChildToBack(n);\n-      }\n-\n-      if (hasErrors()) {\n-        return null;\n-      }\n-      return externAndJsRoot;\n-    } finally {\n-      stopTracer(tracer, \"parseInputs\");\n-    }\n-  }\n+\u00a0\u00a0Node parseInputs() {\n+\u00a0\u00a0\u00a0\u00a0boolean devMode = options.devMode != DevMode.OFF;\n+\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0if (options.instrumentForCoverage) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0instrumentationBuilder = new CoverageInstrumentationBuilder(this, codingConvention);\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0if (options.processCommonJSModules) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0commonJs = new ProcessCommonJSModules(this, modules, options);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0commonJs.process();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!options.skipAllPasses) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inputs = updatedInputs(commonJs.getInputs(), inputs, options.dependencyOptions, modules);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0if (externsRoot != null) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0externsRoot.detachChildren();\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0if (jsRoot != null) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0jsRoot.detachChildren();\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0jsRoot = IR.block();\n+\u00a0\u00a0\u00a0\u00a0jsRoot.setIsSyntheticBlock(true);\n+\u00a0\u00a0\u00a0\u00a0externsRoot = IR.block();\n+\u00a0\u00a0\u00a0\u00a0externsRoot.setIsSyntheticBlock(true);\n+\u00a0\u00a0\u00a0\u00a0unorderedExternsRoot = IR.block();\n+\u00a0\u00a0\u00a0\u00a0unorderedExternsRoot.setIsSyntheticBlock(true);\n+\u00a0\u00a0\u00a0\u00a0unorderedJsRoot = IR.block();\n+\u00a0\u00a0\u00a0\u00a0unorderedJsRoot.setIsSyntheticBlock(true);\n+\u00a0\u00a0\u00a0\u00a0externAndJsRoot = IR.block(externsRoot, jsRoot);\n+\u00a0\u00a0\u00a0\u00a0externAndJsRoot.setIsSyntheticBlock(true);\n+\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0if (options.tracer.isOn()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Poor-man's exclusive time tracking: don't bother instrumenting\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the time spent in the first read of the sources, because\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// the disk access overheads tend to skew the results.\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0tracker = new PerformanceTracker(jsRoot, options.tracer);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0addChangeHandler(tracker.getCodeChangeHandler());\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0boolean parseJsDocDocumentation = options.parseJsDocDocumentation;\n+\u00a0\u00a0\u00a0\u00a0if (options.jsDocParsingMode == Options.JsDocParsing.INCLUDE_DESCRIPTIONS_NO_WHITESPACE) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0options.parseJsDocDocumentation = true;\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0try {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0parseInputsInternal(inputs, externs, jsRoot, externsRoot,\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0unorderedJsRoot, unorderedExternsRoot);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.findTypesForLocalOptimization) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Call the type inference algorithm.\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0ArrayList<Node> typeRoots = Lists.newArrayList();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0typeRoots.add(jsRoot);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TypeInferencePass inferencePass =\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new TypeInferencePass(this, typeRoots);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inferencePass.process(null);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0for (CompilerInput input : inputs) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0InputId inputId = input.getInputId();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (inputId.isModule()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// Double check to make sure that we've ruled out all invalid\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0// module declarations.\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (!commonJs.getAllModuleIds().contains(inputId.getId())) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0report(JSError.make(\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0INVALID_MODULE_DECLARATION, input.getName()));\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.dependencyOptions.needsManagement() &&\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0!options.skipAllPasses &&\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0options.closurePass) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0buildDependenciesFromInputs(\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inputs, options.dependencyOptions, modules);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.warningLevel.verbose && options.checkGlobalThisLevel.isOn()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CheckGlobalThis checkGlobalThis =\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new CheckGlobalThis(this, options.checkGlobalThisLevel, options.languageIn);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NodeTraversal.traverse(this, jsRoot, checkGlobalThis);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.checkSymbols) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0CheckSymbols symbolChecker =\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new CheckSymbols(this, options.enforceAccessControlCodingConventions);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0NodeTraversal.traverse(this, jsRoot, symbolChecker);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.enableTypedInference) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0TypeInferencePass inferencePass =\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0new TypeInferencePass(this, ImmutableList.of(jsRoot));\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inferencePass.process(null);\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.newTypeInference) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0inferTypes();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (hasErrors()) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0reportCodeChange();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return null;\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0if (options.instrumentForCoverage) {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0instrumentationBuilder.process();\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0return externAndJsRoot;\n+\u00a0\u00a0\u00a0\u00a0} finally {\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0options.parseJsDocDocumentation = parseJsDocDocumentation;\n+\u00a0\u00a0\u00a0\u00a0\u00a0\u00a0stopTracer(tracer, \"parseInputs\");\n+\u00a0\u00a0\u00a0\u00a0}\n+\u00a0\u00a0}\n \n   /**\n    * Transforms AMD and CJS modules to something closure compiler can",
    "result_reason": "error: illegal character: \\160",
    "test_result": "ERROR"
}