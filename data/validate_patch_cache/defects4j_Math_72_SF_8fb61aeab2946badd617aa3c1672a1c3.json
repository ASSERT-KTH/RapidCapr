{
    "patch": "    public double solve(final UnivariateRealFunction f,\n                        final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // return the initial guess if it is good enough\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // return the first endpoint if it is good enough\n        double yMin = f.value(min);\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n\n        // reduce interval if min and initial bracket the root\n        if (yInitial * yMin < 0) {\n            return solve(f, min, initial, yMin, yInitial, min, yMin);\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // reduce interval if initial and max bracket the root\n        if (yInitial * yMax < 0) {\n            return solve(f, initial, max, yInitial, yMax, initial, yInitial);\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        int i = 1;\n        while (true) {\n            double x0 = (min + max) * 0.5;\n            double y0 = f.value(x0);\n            double x1;\n            double y1;\n            double x2;\n            double y2;\n\n            if (Math.abs(y0) <= functionValueAccuracy) {\n                setResult(x0, i);\n                return result;\n            }\n\n            if (i >= maximumIterations) {\n                throw new MaxIterationsExceededException(maximumIterations);\n            }\n            ++i;\n\n            if (((x0 - min) * y0 > 0 ) == ((initial - min) * yInitial > 0)) {\n                x1 = initial;\n                y1 = yInitial;\n                x2 = x0;\n                y2 = y0;\n            } else {\n                x1 = x0;\n                y1 = y0;\n                x2 = initial;\n                y2 = yInitial;\n            }\n\n            double x3 = 0.5 * (min + max);\n            double y3 = f.value(x3);\n\n            double delta = 0;\n            double oldDelta = Double.MAX_VALUE;\n            double previousDY = y2 - y1;\n            double previousDX = x2 - x1;\n            double rightX = x2;\n            double rightY = y2;\n            double leftX = x1;\n            double leftY = y1;\n            double middleX = x3;\n            double middleY = y3;\n            boolean isInitialInterval = true;\n\n            outer: while (true) {\n\n                double dxBu = 0;\n                double dyBu = 0;\n                double scale = 1.0;\n                boolean doSwitch = false;\n                boolean triedAggressive = false;\n                boolean retryReflect = false;\n\n                while ((previousDY / scale > functionValueAccuracy || previousDX > functionValueAccuracy) && scale > MIN_SCALE) {\n\n                    recomputeInterval:\n                    do { // recompute infinitely scaling interval\n                        double dx = rightX - leftX;\n                        delta = (rightY - leftY) / dx;\n                        if (delta == 0) {\n                            break recomputeInterval;\n                        }\n                        double gamma = middleX - leftX;\n                        double beta = middleY - leftY;\n                        double alpha = dx * (y2 - middleY);\n                        double a = (alpha - beta) / (gamma - rightX);\n                        double b = delta - a;\n                        double d = gamma + dx * (a + b);\n                        if (d == rightX || d == middleX) {\n                            break recomputeInterval;\n                        }\n                        double y4 = f.value(d);\n                        if (Math.abs(y4) <= functionValueAccuracy) {\n                            setResult(d, i);\n                            return result;\n                        }\n                        if (d < middleX) {\n                            if (y2 * y4 < 0) {\n                                leftX = x2;\n                                leftY = y2;\n                                rightX = d;\n                                rightY = y4;\n                                break recomputeInterval;\n                            } else if (y1 * y4 < 0) {\n                                rightX = d;\n                                rightY = y4;\n                                newX = leftX;\n                                newY = leftY;\n                                x2 = middleX;\n                                y2 = middleY;\n                                middleX = rightX - F * (rightX - leftX);\n                                middleY = f.value(middleX);\n\n                                // Check for convergence\n                                if ((newX - rightX)*(rightX - x2) <= 0) {\n                                    if (Math.abs(f.value(newX)) < Math.abs(f.value(rightX))) {\n                                        setResult(newX, i);\n                                    } else {\n                                        setResult(rightX, i);\n                                    }\n                                    return result;\n                                }\n                                triedAggressive = true;\n                                break recomputeInterval;\n                            }\n                        } else {\n                            if (y4 * y1 < 0) {\n                                leftX = d;\n                                leftY = y4;\n                                rightX = x1;\n                                rightY = y1;\n                                break recomputeInterval;\n                            } else if (y4 * y2 < 0 ) {\n                                rightX = d;\n                                rightY = y4;\n                                newX = leftX;\n                                newY = leftY;\n                                x1 = middleX;\n                                y1 = middleY;\n                                middleX = rightX - F * (rightX - leftX);\n                                middleY = f.value(middleX);\n\n                                // Check for convergence\n                                if ((newX - rightX)*(rightX - x1) <= 0) {\n                                    if (f.value(newX) * f.value(rightX) < 0) {\n                                        setResult(newX, i);\n                                    } else if (Math.abs(f.value(newX)) < Math.abs(f.value(rightX))) {\n                                        setResult(newX, i);\n                                    } else {\n                                        setResult(rightX, i);\n                                    }\n                                    return result;\n                                }\n\n                                triedAggressive = true;\n                                break recomputeInterval;\n                            }\n                        }\n                    } while (false);\n\n                    do { // now bounded\n                        double dx = rightX - leftX;\n                        delta = (rightY - leftY) / dx;\n                        if (delta == 0) {\n                            break;\n                        }\n                        double d1 = middleX - leftX;\n                        double d2 = rightX - middleX;\n                        double[] bounds;\n                        double x;\n                        if (d1 >= d2) {\n                            bounds = Contract.precond(largeBounds(middleX - G * (middleX - leftX), middleX, delta));\n                            x = brent(f, bounds[0], middleX, bounds[1], ABSOLUTE_ACCURACY, GoalType.MINIMIZE);\n                        } else {\n                            bounds = Contract.precond(largeBounds(middleX, middleX + G * (rightX - middleX), delta));\n                            x = brent(f, bounds[0], middleX, bounds[1], ABSOLUTE_ACCURACY, GoalType.MINIMIZE);\n                        }\n                        if (Math.abs(x - middleX) < functionValueAccuracy) {\n                            setResult(x, i);\n                            return result;\n                        }\n                        double y = f.value(x);\n                        if (Math.abs(y) <= functionValueAccuracy) {\n                            setResult(x, i);\n                            return result;\n                        }\n\n                        if (y * y1 < 0) {\n                            rightX = middleX;\n                            rightY = middleY;\n                        } else if (y * y2 < 0) {\n                            leftX = middleX;\n                            leftY = middleY;\n                        } else {\n                            break;\n                        }\n                        if (rightY - leftY < oldDelta) {\n                            double tmp = previousDY;\n                            previousDY = -previousDX;\n                            previousDX = tmp;\n                            isInitialInterval = true;\n                            scale = 1.0;\n                        } else {\n                            isInitialInterval = false;\n                            scale = TWO;\n                        }\n                        if (triedAggressive) {\n                            scale *= 0.5;\n                            triedAggressive = false;\n                        }\n                        double mml = middleX + scale * (rightX - middleX);\n                        middleY = f.value(mml);\n                        middleX = (Double.isNaN(middleY) || Double.isInfinite(middleY)) ? 0.5 * (leftX + rightX) : mml;\n                    } while (false);\n\n                }\n\n                if (!(previousDY / scale > functionValueAccuracy) || !(previousDX > functionValueAccuracy)) {\n                    doSwitch = true;\n                }\n                if (doSwitch) {\n                    if (middleX-x1 > x2-middleX) {\n                        double xa = middleX - 0.5 * (middleX - leftX);\n                        double ya = f.value(xa);\n                        if (Math.abs(ya) < Math.abs(middleY)) {\n                            setResult(xa, i);\n                        } else {\n                            setResult(middleX, i);\n                        }\n                    } else {\n                        double xb = middleX + 0.5 * (rightX - middleX);\n                        double yb = f.value(xb);\n                        if (Math.abs(yb) < Math.abs(middleY)) {\n                            setResult(xb, i);\n                        } else {\n                            setResult(middleX, i);\n                        }\n                    }\n                    return result;\n                }\n\n                if (Math.abs(previousDY) < functionValueAccuracy && isInitialInterval) {\n                    double dx = middleX - initial;\n                    if (Math.abs(dx) < ABSOLUTE_ACCURACY) {\n                        setResult(initial, i);\n                        return result;\n                    }\n\n                }\n\n                if (Math.abs(delta) > 0.0) {\n                    double d1 = y2 - y1;\n                    double d2 = y3 - y2;\n                    double d3 = rightY - y3;\n                    double a = (d2 - d1) / (x2 - x1);\n                    double b = (d3 - d2) / (rightX - x2);\n                    double p = (a * (rightX - x2) - b * (x2 - x1)) / (rightX - x1);\n                    double q = (a - p) * (x2 - x1);\n                    double r = b * (rightX - x2) * (rightX - x1);\n                    if (q <= r) {\n                        newX = x1 + q;\n                    } else {\n                        newX = x2 + r;\n                    }\n                } else {\n                    newX = middleX + GOLDEN_SECTION * (middleX - x1);\n                }\n\n                double eps = Math.abs(newX) * relativeAccuracy + absoluteAccuracy;\n                double atol = absoluteAccuracy + relativeAccuracy * Math.max(Math.abs(middleX), Math.max(Math.abs(leftX), Math.abs(rightX)));\n                if (Math.abs(newX - middleX) <= (atol + eps)) {\n                    newY = f.value(newX);\n                    if (Math.abs(newY) <= functionValueAccuracy) {\n                        setResult(newX, i);\n                        return result;\n                    }\n                    if (newY * middleY < 0) {\n                        leftX = middleX;\n                        leftY = middleY;\n                        rightX = newX;\n                        rightY = newY;\n                    } else if (newY * y1 < 0) {\n                        rightX = middleX;\n                        rightY = middleY;\n                        newX = leftX;\n                        newY = leftY;\n                        leftX = newX;\n                        leftY = newY;\n                    } else {\n                        rightX = newX;\n                        rightY = newY;\n                    }\n                    middleX = newX;\n                    middleY = newY;\n\n                } else {\n\n                    // The point is not converged yet: we choose a new trial point.\n                    if (previousDX >= 0) {\n                        newX = middleX + 0.5 * (rightX - middleX);\n                    } else {\n                        newX = middleX + 0.5 * (leftX - middleX);\n                    }\n\n                    newY = f.value(newX);\n                    if (Math.abs(newY) <= functionValueAccuracy) {\n                        setResult(newX, i);\n                        return result;\n                    }\n\n                    if (newY * middleY < 0) {\n                        rightX = middleX;\n                        rightY = middleY;\n                    } else if (newY * y1 < 0) {\n                        rightX = middleX;\n                        rightY = middleY;\n                        newX = leftX;\n                        newY = leftY;\n                    } else if (y2 * newY < 0) {\n                        leftX = middleX;\n                        leftY = middleY;\n                    } else {\n                        rightX = newX;\n                        rightY = newY;\n                    }\n\n                    if (rightY - leftY < oldDelta) {\n                        double tmp = previousDY;\n                        previousDY = -previousDX;\n                        previousDX = tmp;\n                        isInitialInterval = true;\n                    } else {\n                        isInitialInterval = false;\n                    }\n\n                    middleX = newX;\n                    middleY = newY;\n                }\n\n            } // end while: try to converge to root\n\n        } // end main while loop\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..85b0228f0 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -112,25 +112,25 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n         // return the first endpoint if it is good enough\n         double yMin = f.value(min);\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n         // reduce interval if min and initial bracket the root\n         if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+            return solve(f, min, initial, yMin, yInitial, min, yMin);\n         }\n \n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n         // reduce interval if initial and max bracket the root\n         if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+            return solve(f, initial, max, yInitial, yMax, initial, yInitial);\n         }\n \n         if (yMin * yMax > 0) {\n@@ -138,9 +138,330 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n                   NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n         }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        int i = 1;\n+        while (true) {\n+            double x0 = (min + max) * 0.5;\n+            double y0 = f.value(x0);\n+            double x1;\n+            double y1;\n+            double x2;\n+            double y2;\n \n+            if (Math.abs(y0) <= functionValueAccuracy) {\n+                setResult(x0, i);\n+                return result;\n+            }\n+\n+            if (i >= maximumIterations) {\n+                throw new MaxIterationsExceededException(maximumIterations);\n+            }\n+            ++i;\n+\n+            if (((x0 - min) * y0 > 0 ) == ((initial - min) * yInitial > 0)) {\n+                x1 = initial;\n+                y1 = yInitial;\n+                x2 = x0;\n+                y2 = y0;\n+            } else {\n+                x1 = x0;\n+                y1 = y0;\n+                x2 = initial;\n+                y2 = yInitial;\n+            }\n+\n+            double x3 = 0.5 * (min + max);\n+            double y3 = f.value(x3);\n+\n+            double delta = 0;\n+            double oldDelta = Double.MAX_VALUE;\n+            double previousDY = y2 - y1;\n+            double previousDX = x2 - x1;\n+            double rightX = x2;\n+            double rightY = y2;\n+            double leftX = x1;\n+            double leftY = y1;\n+            double middleX = x3;\n+            double middleY = y3;\n+            boolean isInitialInterval = true;\n+\n+            outer: while (true) {\n+\n+                double dxBu = 0;\n+                double dyBu = 0;\n+                double scale = 1.0;\n+                boolean doSwitch = false;\n+                boolean triedAggressive = false;\n+                boolean retryReflect = false;\n+\n+                while ((previousDY / scale > functionValueAccuracy || previousDX > functionValueAccuracy) && scale > MIN_SCALE) {\n+\n+                    recomputeInterval:\n+                    do { // recompute infinitely scaling interval\n+                        double dx = rightX - leftX;\n+                        delta = (rightY - leftY) / dx;\n+                        if (delta == 0) {\n+                            break recomputeInterval;\n+                        }\n+                        double gamma = middleX - leftX;\n+                        double beta = middleY - leftY;\n+                        double alpha = dx * (y2 - middleY);\n+                        double a = (alpha - beta) / (gamma - rightX);\n+                        double b = delta - a;\n+                        double d = gamma + dx * (a + b);\n+                        if (d == rightX || d == middleX) {\n+                            break recomputeInterval;\n+                        }\n+                        double y4 = f.value(d);\n+                        if (Math.abs(y4) <= functionValueAccuracy) {\n+                            setResult(d, i);\n+                            return result;\n+                        }\n+                        if (d < middleX) {\n+                            if (y2 * y4 < 0) {\n+                                leftX = x2;\n+                                leftY = y2;\n+                                rightX = d;\n+                                rightY = y4;\n+                                break recomputeInterval;\n+                            } else if (y1 * y4 < 0) {\n+                                rightX = d;\n+                                rightY = y4;\n+                                newX = leftX;\n+                                newY = leftY;\n+                                x2 = middleX;\n+                                y2 = middleY;\n+                                middleX = rightX - F * (rightX - leftX);\n+                                middleY = f.value(middleX);\n+\n+                                // Check for convergence\n+                                if ((newX - rightX)*(rightX - x2) <= 0) {\n+                                    if (Math.abs(f.value(newX)) < Math.abs(f.value(rightX))) {\n+                                        setResult(newX, i);\n+                                    } else {\n+                                        setResult(rightX, i);\n+                                    }\n+                                    return result;\n+                                }\n+                                triedAggressive = true;\n+                                break recomputeInterval;\n+                            }\n+                        } else {\n+                            if (y4 * y1 < 0) {\n+                                leftX = d;\n+                                leftY = y4;\n+                                rightX = x1;\n+                                rightY = y1;\n+                                break recomputeInterval;\n+                            } else if (y4 * y2 < 0 ) {\n+                                rightX = d;\n+                                rightY = y4;\n+                                newX = leftX;\n+                                newY = leftY;\n+                                x1 = middleX;\n+                                y1 = middleY;\n+                                middleX = rightX - F * (rightX - leftX);\n+                                middleY = f.value(middleX);\n+\n+                                // Check for convergence\n+                                if ((newX - rightX)*(rightX - x1) <= 0) {\n+                                    if (f.value(newX) * f.value(rightX) < 0) {\n+                                        setResult(newX, i);\n+                                    } else if (Math.abs(f.value(newX)) < Math.abs(f.value(rightX))) {\n+                                        setResult(newX, i);\n+                                    } else {\n+                                        setResult(rightX, i);\n+                                    }\n+                                    return result;\n+                                }\n+\n+                                triedAggressive = true;\n+                                break recomputeInterval;\n+                            }\n+                        }\n+                    } while (false);\n+\n+                    do { // now bounded\n+                        double dx = rightX - leftX;\n+                        delta = (rightY - leftY) / dx;\n+                        if (delta == 0) {\n+                            break;\n+                        }\n+                        double d1 = middleX - leftX;\n+                        double d2 = rightX - middleX;\n+                        double[] bounds;\n+                        double x;\n+                        if (d1 >= d2) {\n+                            bounds = Contract.precond(largeBounds(middleX - G * (middleX - leftX), middleX, delta));\n+                            x = brent(f, bounds[0], middleX, bounds[1], ABSOLUTE_ACCURACY, GoalType.MINIMIZE);\n+                        } else {\n+                            bounds = Contract.precond(largeBounds(middleX, middleX + G * (rightX - middleX), delta));\n+                            x = brent(f, bounds[0], middleX, bounds[1], ABSOLUTE_ACCURACY, GoalType.MINIMIZE);\n+                        }\n+                        if (Math.abs(x - middleX) < functionValueAccuracy) {\n+                            setResult(x, i);\n+                            return result;\n+                        }\n+                        double y = f.value(x);\n+                        if (Math.abs(y) <= functionValueAccuracy) {\n+                            setResult(x, i);\n+                            return result;\n+                        }\n+\n+                        if (y * y1 < 0) {\n+                            rightX = middleX;\n+                            rightY = middleY;\n+                        } else if (y * y2 < 0) {\n+                            leftX = middleX;\n+                            leftY = middleY;\n+                        } else {\n+                            break;\n+                        }\n+                        if (rightY - leftY < oldDelta) {\n+                            double tmp = previousDY;\n+                            previousDY = -previousDX;\n+                            previousDX = tmp;\n+                            isInitialInterval = true;\n+                            scale = 1.0;\n+                        } else {\n+                            isInitialInterval = false;\n+                            scale = TWO;\n+                        }\n+                        if (triedAggressive) {\n+                            scale *= 0.5;\n+                            triedAggressive = false;\n+                        }\n+                        double mml = middleX + scale * (rightX - middleX);\n+                        middleY = f.value(mml);\n+                        middleX = (Double.isNaN(middleY) || Double.isInfinite(middleY)) ? 0.5 * (leftX + rightX) : mml;\n+                    } while (false);\n+\n+                }\n+\n+                if (!(previousDY / scale > functionValueAccuracy) || !(previousDX > functionValueAccuracy)) {\n+                    doSwitch = true;\n+                }\n+                if (doSwitch) {\n+                    if (middleX-x1 > x2-middleX) {\n+                        double xa = middleX - 0.5 * (middleX - leftX);\n+                        double ya = f.value(xa);\n+                        if (Math.abs(ya) < Math.abs(middleY)) {\n+                            setResult(xa, i);\n+                        } else {\n+                            setResult(middleX, i);\n+                        }\n+                    } else {\n+                        double xb = middleX + 0.5 * (rightX - middleX);\n+                        double yb = f.value(xb);\n+                        if (Math.abs(yb) < Math.abs(middleY)) {\n+                            setResult(xb, i);\n+                        } else {\n+                            setResult(middleX, i);\n+                        }\n+                    }\n+                    return result;\n+                }\n+\n+                if (Math.abs(previousDY) < functionValueAccuracy && isInitialInterval) {\n+                    double dx = middleX - initial;\n+                    if (Math.abs(dx) < ABSOLUTE_ACCURACY) {\n+                        setResult(initial, i);\n+                        return result;\n+                    }\n+\n+                }\n+\n+                if (Math.abs(delta) > 0.0) {\n+                    double d1 = y2 - y1;\n+                    double d2 = y3 - y2;\n+                    double d3 = rightY - y3;\n+                    double a = (d2 - d1) / (x2 - x1);\n+                    double b = (d3 - d2) / (rightX - x2);\n+                    double p = (a * (rightX - x2) - b * (x2 - x1)) / (rightX - x1);\n+                    double q = (a - p) * (x2 - x1);\n+                    double r = b * (rightX - x2) * (rightX - x1);\n+                    if (q <= r) {\n+                        newX = x1 + q;\n+                    } else {\n+                        newX = x2 + r;\n+                    }\n+                } else {\n+                    newX = middleX + GOLDEN_SECTION * (middleX - x1);\n+                }\n+\n+                double eps = Math.abs(newX) * relativeAccuracy + absoluteAccuracy;\n+                double atol = absoluteAccuracy + relativeAccuracy * Math.max(Math.abs(middleX), Math.max(Math.abs(leftX), Math.abs(rightX)));\n+                if (Math.abs(newX - middleX) <= (atol + eps)) {\n+                    newY = f.value(newX);\n+                    if (Math.abs(newY) <= functionValueAccuracy) {\n+                        setResult(newX, i);\n+                        return result;\n+                    }\n+                    if (newY * middleY < 0) {\n+                        leftX = middleX;\n+                        leftY = middleY;\n+                        rightX = newX;\n+                        rightY = newY;\n+                    } else if (newY * y1 < 0) {\n+                        rightX = middleX;\n+                        rightY = middleY;\n+                        newX = leftX;\n+                        newY = leftY;\n+                        leftX = newX;\n+                        leftY = newY;\n+                    } else {\n+                        rightX = newX;\n+                        rightY = newY;\n+                    }\n+                    middleX = newX;\n+                    middleY = newY;\n+\n+                } else {\n+\n+                    // The point is not converged yet: we choose a new trial point.\n+                    if (previousDX >= 0) {\n+                        newX = middleX + 0.5 * (rightX - middleX);\n+                    } else {\n+                        newX = middleX + 0.5 * (leftX - middleX);\n+                    }\n+\n+                    newY = f.value(newX);\n+                    if (Math.abs(newY) <= functionValueAccuracy) {\n+                        setResult(newX, i);\n+                        return result;\n+                    }\n+\n+                    if (newY * middleY < 0) {\n+                        rightX = middleX;\n+                        rightY = middleY;\n+                    } else if (newY * y1 < 0) {\n+                        rightX = middleX;\n+                        rightY = middleY;\n+                        newX = leftX;\n+                        newY = leftY;\n+                    } else if (y2 * newY < 0) {\n+                        leftX = middleX;\n+                        leftY = middleY;\n+                    } else {\n+                        rightX = newX;\n+                        rightY = newY;\n+                    }\n+\n+                    if (rightY - leftY < oldDelta) {\n+                        double tmp = previousDY;\n+                        previousDY = -previousDX;\n+                        previousDX = tmp;\n+                        isInitialInterval = true;\n+                    } else {\n+                        isInitialInterval = false;\n+                    }\n+\n+                    middleX = newX;\n+                    middleY = newY;\n+                }\n+\n+            } // end while: try to converge to root\n+\n+        } // end main while loop\n     }\n \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}