{
    "patch": "public static double linearCombination(final double[] a, final double[] b)\n    throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..022478829 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -811,65 +811,11 @@ public class MathArrays {\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n-    public static double linearCombination(final double[] a, final double[] b)\n-        throws DimensionMismatchException {\n-        final int len = a.length;\n-        if (len != b.length) {\n-            throw new DimensionMismatchException(len, b.length);\n-        }\n-\n-            // Revert to scalar multiplication.\n-\n-        final double[] prodHigh = new double[len];\n-        double prodLowSum = 0;\n-\n-        for (int i = 0; i < len; i++) {\n-            final double ai = a[i];\n-            final double ca = SPLIT_FACTOR * ai;\n-            final double aHigh = ca - (ca - ai);\n-            final double aLow = ai - aHigh;\n-\n-            final double bi = b[i];\n-            final double cb = SPLIT_FACTOR * bi;\n-            final double bHigh = cb - (cb - bi);\n-            final double bLow = bi - bHigh;\n-            prodHigh[i] = ai * bi;\n-            final double prodLow = aLow * bLow - (((prodHigh[i] -\n-                                                    aHigh * bHigh) -\n-                                                   aLow * bHigh) -\n-                                                  aHigh * bLow);\n-            prodLowSum += prodLow;\n-        }\n-\n-\n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n-\n-        final int lenMinusOne = len - 1;\n-        for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n-            final double sHighCur = sHighPrev + prodHighNext;\n-            sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n-            sHighPrev = sHighCur;\n-        }\n-\n-        double result = sHighPrev + (prodLowSum + sLowSum);\n-\n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = 0;\n-            for (int i = 0; i < len; ++i) {\n-                result += a[i] * b[i];\n-            }\n-        }\n-\n-        return result;\n-    }\n+public static double linearCombination(final double[] a, final double[] b)\n+    throws DimensionMismatchException {\n+    final int len = a.length;\n+    if (len != b.length) {\n+        throw new DimensionMismatchException(len, \n \n     /**\n      * Compute a linear combination accurately.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}