{
    "patch": "    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n            throws MaxIterationsExceededException, FunctionEvaluationException {\n        \n        double yInitial, yMin, yMax;\n        \n        // compute initial values\n        yInitial = f.value(initial);\n        yMin = f.value(min);\n        yMax = f.value(max);\n        \n        // if one of the bounds is the root, return the bound\n        verifyBracketing(min, max, f);\n        if (yMin == 0.0) {\n            return min;\n        }\n        if (yMax == 0.0) {\n            return max;\n        }\n        \n        verifySequence(min, initial, max);\n        \n        double x0 = initial;\n        double x1 = max;\n\n        double y = yMax;\n        double x2 = yMin < yMax ? min : max;\n        double y2 = yMin < yMax ? yMin : yMax;\n        double oldDelta = FastMath.abs(max - min);\n        double delta = oldDelta;\n        \n        int i = 0;\n        while (i < maximalIterationCount) {\n            double a = (y - y2) / (x2 - x1) - (y - y1) / (x1 - x0);\n            double b = (y - y1) / (x1 - x0) + a * (x1 - x0);\n            double c = y1 - a * x0 * x0 - b * x0;\n\n            double det = b * b - 4.0 * a * c;\n\n            if (det >= 0.0) {          \n                double dxb = (-b + FastMath.sqrt(det)) / (2.0 * a);\n                double dxa = (-b - FastMath.sqrt(det)) / (2.0 * a);\n\n                double dx;\n                if (FastMath.abs(dxa) < FastMath.abs(dxb)) {\n                    dx = dxa;\n                } else {\n                    dx = dxb;\n                }\n                \n                double x = x1 + dx;\n                y = f.value(x);\n                \n                if (y == 0.0) {\n                    return x;\n                }\n                \n                // reorganize the brackets\n                if (y < 0.0) {\n                    if (y1 < 0.0) {\n                        x0 = x1;\n                        y = y1;\n                    }\n                    x1 = x;\n                    y1 = y;\n                } else {\n                    if (y2 > 0.0) {\n                        x0 = x1;\n                        y = y1;\n                    }\n                    x1 = x;\n                    y1 = y;\n                }\n                if (FastMath.abs(x1 - x0) < functionValueAccuracy) {\n                    double ftol = 2.0 * absoluteAccuracy + 0.5 * FastMath.abs(x1);\n                    // if (FastMath.abs(y1) <= ftol || FastMath.abs(y) <= ftol) {\n                    if (FastMath.abs(y) <= ftol) {\n                        return x;\n                    }\n                    // the root is converged\n                } else if (FastMath.abs(y) <= functionValueAccuracy) {\n                    return x;\n                }\n            } else {\n                // no real solution : just take the middle of the bracket\n                delta = 0.5 * (x2 - x0);\n                x = x1 + delta;\n                y = f.value(x);\n\n                if (y == 0.0) {\n                    return x;\n                }\n\n                // reorganize the brackets around the mid-point\n                if (y > 0.0) {\n                    y2 = y;\n                    x2 = x;\n                } else {\n                    y1 = y;\n                    x1 = x;\n                }\n            }\n            \n            // prepare next iteration\n            i++;\n            if (FastMath.abs(y) < FastMath.abs(y1)) {\n                x0 = x1;\n                x1 = x;\n                y2 = y1;\n                y1 = y;\n            } else {\n                x2 = x1;\n                x1 = x;\n                y2 = y1;\n                y1 = y;\n            }\n            oldDelta = delta;\n            delta = FastMath.abs(x1 - x0);\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..4f36f6b2f 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -68,8 +68,125 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n \n     /** {@inheritDoc} */\n     public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+            throws MaxIterationsExceededException, FunctionEvaluationException {\n+        \n+        double yInitial, yMin, yMax;\n+        \n+        // compute initial values\n+        yInitial = f.value(initial);\n+        yMin = f.value(min);\n+        yMax = f.value(max);\n+        \n+        // if one of the bounds is the root, return the bound\n+        verifyBracketing(min, max, f);\n+        if (yMin == 0.0) {\n+            return min;\n+        }\n+        if (yMax == 0.0) {\n+            return max;\n+        }\n+        \n+        verifySequence(min, initial, max);\n+        \n+        double x0 = initial;\n+        double x1 = max;\n+\n+        double y = yMax;\n+        double x2 = yMin < yMax ? min : max;\n+        double y2 = yMin < yMax ? yMin : yMax;\n+        double oldDelta = FastMath.abs(max - min);\n+        double delta = oldDelta;\n+        \n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            double a = (y - y2) / (x2 - x1) - (y - y1) / (x1 - x0);\n+            double b = (y - y1) / (x1 - x0) + a * (x1 - x0);\n+            double c = y1 - a * x0 * x0 - b * x0;\n+\n+            double det = b * b - 4.0 * a * c;\n+\n+            if (det >= 0.0) {          \n+                double dxb = (-b + FastMath.sqrt(det)) / (2.0 * a);\n+                double dxa = (-b - FastMath.sqrt(det)) / (2.0 * a);\n+\n+                double dx;\n+                if (FastMath.abs(dxa) < FastMath.abs(dxb)) {\n+                    dx = dxa;\n+                } else {\n+                    dx = dxb;\n+                }\n+                \n+                double x = x1 + dx;\n+                y = f.value(x);\n+                \n+                if (y == 0.0) {\n+                    return x;\n+                }\n+                \n+                // reorganize the brackets\n+                if (y < 0.0) {\n+                    if (y1 < 0.0) {\n+                        x0 = x1;\n+                        y = y1;\n+                    }\n+                    x1 = x;\n+                    y1 = y;\n+                } else {\n+                    if (y2 > 0.0) {\n+                        x0 = x1;\n+                        y = y1;\n+                    }\n+                    x1 = x;\n+                    y1 = y;\n+                }\n+                if (FastMath.abs(x1 - x0) < functionValueAccuracy) {\n+                    double ftol = 2.0 * absoluteAccuracy + 0.5 * FastMath.abs(x1);\n+                    // if (FastMath.abs(y1) <= ftol || FastMath.abs(y) <= ftol) {\n+                    if (FastMath.abs(y) <= ftol) {\n+                        return x;\n+                    }\n+                    // the root is converged\n+                } else if (FastMath.abs(y) <= functionValueAccuracy) {\n+                    return x;\n+                }\n+            } else {\n+                // no real solution : just take the middle of the bracket\n+                delta = 0.5 * (x2 - x0);\n+                x = x1 + delta;\n+                y = f.value(x);\n+\n+                if (y == 0.0) {\n+                    return x;\n+                }\n+\n+                // reorganize the brackets around the mid-point\n+                if (y > 0.0) {\n+                    y2 = y;\n+                    x2 = x;\n+                } else {\n+                    y1 = y;\n+                    x1 = x;\n+                }\n+            }\n+            \n+            // prepare next iteration\n+            i++;\n+            if (FastMath.abs(y) < FastMath.abs(y1)) {\n+                x0 = x1;\n+                x1 = x;\n+                y2 = y1;\n+                y1 = y;\n+            } else {\n+                x2 = x1;\n+                x1 = x;\n+                y2 = y1;\n+                y1 = y;\n+            }\n+            oldDelta = delta;\n+            delta = FastMath.abs(x1 - x0);\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n     /** {@inheritDoc} */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}