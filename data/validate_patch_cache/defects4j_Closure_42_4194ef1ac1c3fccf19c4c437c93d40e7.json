{
    "patch": "class TransformDispatcher implements IRFactory.TransformDispatcher {\n\n    @Override\n    public Node process(FunctionNode functionNode) {\n        return newNode(Token.FUNCTION, transform(functionNode.getName()), transform(functionNode.getParams()), transform(functionNode.getBody()));\n    }\n\n    @Override\n    public Node process(PropertyGet propertyGetNode) {\n        return newNode(Token.GETPROP, transform(propertyGetNode.getTarget()), IR.name(propertyGetNode.getProperty().getIdentifier()), IR.bool(propertyGetNode.isElision()));\n    }\n\n    @Override\n    public Node process(PropertySet propertySetNode) {\n        return newNode(Token.SETELEM, transform(propertySetNode.getTarget()), transform(propertySetNode.getProperty()), transform(propertySetNode.getValue()));\n    }\n\n    @Override\n    public Node process(ArrayLiteral arrayLiteralNode) {\n        List<Node> elements = Lists.newArrayList();\n        for (AstNode element : arrayLiteralNode.getElements()) {\n            elements.add(transform(element));\n        }\n        return IR.arraylit(elements.toArray(new Node[0]));\n    }\n\n    @Override\n    public Node process(NumberLiteral numberLiteralNode) {\n        return IR.number(numberLiteralNode.getNumber());\n    }\n\n    @Override\n    public Node process(FunctionCall functionCallNode) {\n        Node target = transform(functionCallNode.getTarget());\n        NodeList<Node> arguments = transform(functionCallNode.getArguments());\n        return newNode(Token.CALL, target, arguments);\n    }\n\n    @Override\n    public Node process(StringLiteral stringLiteralNode) {\n        return IR.string(stringLiteralNode.getValue());\n    }\n\n    @Override\n    public Node process(Name nameNode) {\n        if (nameNode.getIdentifier() != null) {\n            return IR.name(nameNode.getIdentifier());\n        } else {\n            return null;\n        }\n    }\n\n    @Override\n    public Node process(InfixExpression infixExpressionNode) {\n        return newNode(Token.newFromType(infixExpressionNode.getType()), transform(infixExpressionNode.getLeft()), transform(infixExpressionNode.getRight()));\n    }\n\n    @Override\n    public Node process(BooleanLiteral booleanLiteralNode) {\n        return IR.bool(booleanLiteralNode.getBooleanValue());\n    }\n\n    @Override\n    public Node process(UnaryExpression unaryExpressionNode) {\n        return newNode(Token.newFromType(unaryExpressionNode.getType()), transform(unaryExpressionNode.getOperand()));\n    }\n\n    @Override\n    public Node process(VariableDeclaration variableDeclarationNode) {\n        Node node = new Node(Token.VAR);\n        for (VariableInitializer var : variableDeclarationNode.getVariables()) {\n            node.addChildToBack(newNode(Token.NAME, IR.name(var.getTarget().getIdentifier()), transform(var.getInitializer())));\n        }\n        return node;\n    }\n\n    @Override\n    public Node process(ParenthesizedExpression parenthesizedExpressionNode) {\n        return transform(parenthesizedExpressionNode.getExpression());\n    }\n\n    @Override\n    public Node process(ReturnStatement returnStatementNode) {\n        Node node = newNode(Token.RETURN);\n        if (returnStatementNode.getReturnValue() != null) {\n            node.addChildToBack(transform(returnStatementNode.getReturnValue()));\n        }\n        return node;\n    }\n\n    @Override\n    public Node process(LabeledStatement labeledStatementNode) {\n        return newNode(Token.LABEL, IR.name(labeledStatementNode.getLabelName()), transform(labeledStatementNode.getStatement()));\n    }\n\n    @Override\n    public Node process(BreakStatement breakStatementNode) {\n        Node breakNode = IR.breakNode();\n        if (breakStatementNode.getBreakLabel() != null) {\n            breakNode.setLabelName(breakStatementNode.getBreakLabel().getIdentifier());\n        }\n        return breakNode;\n    }\n\n    @Override\n    public Node process(IfStatement ifStatementNode) {\n        return newNode(Token.IF, transform(ifStatementNode.getCondition()), transform(ifStatementNode.getThenPart()), transform(ifStatementNode.getElsePart()));\n    }\n\n    @Override\n    public Node process(ForLoop forLoopNode) {\n        return newNode(Token.FOR, transform(forLoopNode.getInitializer()), transform(forLoopNode.getCondition()), transform(forLoopNode.getIncrement()), transformBlock(forLoopNode.getBody()));\n    }\n\n    @Override\n    public Node process(WhileLoop whileLoopNode) {\n        return newNode(Token.WHILE, transform(whileLoopNode.getCondition()), transform(whileLoopNode.getBody()));\n    }\n\n    @Override\n    public Node process(SwitchStatement switchStatementNode) {\n        Node caseList = newNode(Token.BLOCK);\n        Node defaultCase = null;\n        for (SwitchCase switchCase : switchStatementNode.getCases()) {\n            if (switchCase.getExpression() == null) {\n                defaultCase = transform(switchCase);\n            } else {\n                caseList.addChildToBack(transform(switchCase));\n            }\n        }\n        return newNode(Token.SWITCH, transform(switchStatementNode.getExpression()), caseList, defaultCase);\n    }\n\n    @Override\n    public Node process(SwitchCase switchCaseNode) {\n        Node caseLabel = newNode(Token.CASE, transform(switchCaseNode.getExpression()));\n        NodeList<Node> statements = transform(switchCaseNode.getStatements());\n        Node caseBlock = newNode(Token.BLOCK, statements.toArray(new Node[0]));\n        return newNode(Token.LABEL, caseLabel, caseBlock);\n    }\n\n    @Override\n    public Node process(ThrowStatement throwStatementNode) {\n        return newNode(Token.THROW, transform(throwStatementNode.getExpression()));\n    }\n\n    @Override\n    public Node process(TryStatement tryStatementNode) {\n        return newNode(Token.TRY, transformBlock(tryStatementNode.getTryBlock()), transform(tryStatementNode.getCatchBlock()), transformBlock(tryStatementNode.getFinallyBlock()));\n    }\n\n    @Override\n    public Node process(CatchClause catchClauseNode) {\n        Node name = transform(catchClauseNode.getVarName());\n        Node body = transformBlock(catchClauseNode.getBody());\n        return newNode(Token.CATCH, name, body);\n    }\n\n    @Override\n    public Node process(NewExpression newExpressionNode) {\n        return newNode(Token.NEW, transform(newExpressionNode.getTarget()), transform(newExpressionNode.getArguments()));\n    }\n\n    @Override\n    public Node process(ArrayAccess arrayAccessNode) {\n        return newNode(Token.GETELEM, transform(arrayAccessNode.getTarget()), transform(arrayAccessNode.getIndex()));\n    }\n\n    @Override\n    public Node process(XmlString xmlString) {\n        StringBuilder builder = new StringBuilder();\n        for (int i = 0; i < xmlString.getFragments().size(); i++) {\n            Object fragment = xmlString.getFragments().get(i);\n            if (fragment instanceof XmlFragment) {\n                builder.append(((XmlFragment) fragment).toCode());\n            } else {\n                AstNode astFragment = (AstNode) fragment;\n                builder.append(astFragment.toSource(0));\n            }\n        }\n        return IR.string(builder.toString());\n    }\n\n    @Override\n    public Node process(XmlLiteral xmlLiteral) {\n        return IR.xmlLiteral(xmlLiteral.toSource());\n    }\n\n    @Override\n    public Node process(ExpressionStatement expressionStatementNode) {\n        Node node = transform(expressionStatementNode.getExpression());\n        if (node != null) {\n            int type = node.getType();\n            if (type == Token.CALL || type == Token.NEW) {\n                return node;\n            }\n            return newNode(Token.EXPR_RESULT, node);\n        }\n        return null;\n    }\n\n    @Override\n    public Node process(VariableInitializer variableInitializerNode) {\n        Node node = newNode(Token.NAME, IR.name(variableInitializerNode.getTarget().getIdentifier()));\n        if (variableInitializerNode.getInitializer() != null) {\n            node.addChildToFront(transform(variableInitializerNode.getInitializer()));\n        }\n        return node;\n    }\n\n    @Override\n    public Node process(Comment comment) {\n        return null;\n    }\n\n    @Override\n    public Node process(XmlRef xmlRef) {\n        return IR.xmlRef(xmlRef.toSource());\n    }\n\n    @Override\n    public Node process(XmlElemRef xmlElemRef) {\n        return IR.xmlElemRef(transform(xmlElemRef.getExpression()), transform(xmlElemRef.getRefName()));\n    }\n\n    @Override\n    public Node process(XmlPropRef xmlPropRef) {\n        return IR.xmlPropRef(transform(xmlPropRef.getExpression()), transform(xmlPropRef.getPropName()));\n    }\n\n    private NodeList<Node> transform(Block node) {\n        NodeList<Node> children = transform(node.getStatements());\n        return children != null ? children : new NodeList<>(0);\n    }\n\n    private NodeList<Node> transform(List<? extends AstNode> nodes) {\n        NodeList<Node> children = null;\n        for (AstNode node : nodes) {\n            Node transformedNode = transform(node);\n            if (transformedNode != null) {\n                if (children == null) {\n                    children = new NodeList<>();\n                }\n            \n                if (transformedNode.getType() == Token.LABEL) {\n                    // Special handling for label nodes, which should be added directly to the parent.\n                    children.addAll(transformedNode.removeChildren());\n                } else {\n                    children.add(transformedNode);\n                }\n            }\n        }\n        return children;\n    }\n\n    private Node transform(AstNode node) {\n        if (node == null) {\n            return null;\n        }\n        return IRFactory.transform(node, this);\n    }\n\n    private Node transformBlock(AstNode node) {\n        return newNode(Token.BLOCK, transform(node));\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..129ec690 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -472,108 +472,273 @@ class IRFactory {\n         node.setDirectives(directives);\n       }\n     }\n+class TransformDispatcher implements IRFactory.TransformDispatcher {\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+    @Override\n+    public Node process(FunctionNode functionNode) {\n+        return newNode(Token.FUNCTION, transform(functionNode.getName()), transform(functionNode.getParams()), transform(functionNode.getBody()));\n+    }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    @Override\n+    public Node process(PropertyGet propertyGetNode) {\n+        return newNode(Token.GETPROP, transform(propertyGetNode.getTarget()), IR.name(propertyGetNode.getProperty().getIdentifier()), IR.bool(propertyGetNode.isElision()));\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node process(PropertySet propertySetNode) {\n+        return newNode(Token.SETELEM, transform(propertySetNode.getTarget()), transform(propertySetNode.getProperty()), transform(propertySetNode.getValue()));\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node process(ArrayLiteral arrayLiteralNode) {\n+        List<Node> elements = Lists.newArrayList();\n+        for (AstNode element : arrayLiteralNode.getElements()) {\n+            elements.add(transform(element));\n+        }\n+        return IR.arraylit(elements.toArray(new Node[0]));\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    public Node process(NumberLiteral numberLiteralNode) {\n+        return IR.number(numberLiteralNode.getNumber());\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public Node process(FunctionCall functionCallNode) {\n+        Node target = transform(functionCallNode.getTarget());\n+        NodeList<Node> arguments = transform(functionCallNode.getArguments());\n+        return newNode(Token.CALL, target, arguments);\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node process(StringLiteral stringLiteralNode) {\n+        return IR.string(stringLiteralNode.getValue());\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node process(Name nameNode) {\n+        if (nameNode.getIdentifier() != null) {\n+            return IR.name(nameNode.getIdentifier());\n+        } else {\n+            return null;\n+        }\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node process(InfixExpression infixExpressionNode) {\n+        return newNode(Token.newFromType(infixExpressionNode.getType()), transform(infixExpressionNode.getLeft()), transform(infixExpressionNode.getRight()));\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node process(BooleanLiteral booleanLiteralNode) {\n+        return IR.bool(booleanLiteralNode.getBooleanValue());\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node process(UnaryExpression unaryExpressionNode) {\n+        return newNode(Token.newFromType(unaryExpressionNode.getType()), transform(unaryExpressionNode.getOperand()));\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node process(VariableDeclaration variableDeclarationNode) {\n+        Node node = new Node(Token.VAR);\n+        for (VariableInitializer var : variableDeclarationNode.getVariables()) {\n+            node.addChildToBack(newNode(Token.NAME, IR.name(var.getTarget().getIdentifier()), transform(var.getInitializer())));\n+        }\n+        return node;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    @Override\n+    public Node process(ParenthesizedExpression parenthesizedExpressionNode) {\n+        return transform(parenthesizedExpressionNode.getExpression());\n+    }\n+\n+    @Override\n+    public Node process(ReturnStatement returnStatementNode) {\n+        Node node = newNode(Token.RETURN);\n+        if (returnStatementNode.getReturnValue() != null) {\n+            node.addChildToBack(transform(returnStatementNode.getReturnValue()));\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    public Node process(LabeledStatement labeledStatementNode) {\n+        return newNode(Token.LABEL, IR.name(labeledStatementNode.getLabelName()), transform(labeledStatementNode.getStatement()));\n+    }\n+\n+    @Override\n+    public Node process(BreakStatement breakStatementNode) {\n+        Node breakNode = IR.breakNode();\n+        if (breakStatementNode.getBreakLabel() != null) {\n+            breakNode.setLabelName(breakStatementNode.getBreakLabel().getIdentifier());\n+        }\n+        return breakNode;\n+    }\n+\n+    @Override\n+    public Node process(IfStatement ifStatementNode) {\n+        return newNode(Token.IF, transform(ifStatementNode.getCondition()), transform(ifStatementNode.getThenPart()), transform(ifStatementNode.getElsePart()));\n+    }\n+\n+    @Override\n+    public Node process(ForLoop forLoopNode) {\n+        return newNode(Token.FOR, transform(forLoopNode.getInitializer()), transform(forLoopNode.getCondition()), transform(forLoopNode.getIncrement()), transformBlock(forLoopNode.getBody()));\n+    }\n+\n+    @Override\n+    public Node process(WhileLoop whileLoopNode) {\n+        return newNode(Token.WHILE, transform(whileLoopNode.getCondition()), transform(whileLoopNode.getBody()));\n+    }\n+\n+    @Override\n+    public Node process(SwitchStatement switchStatementNode) {\n+        Node caseList = newNode(Token.BLOCK);\n+        Node defaultCase = null;\n+        for (SwitchCase switchCase : switchStatementNode.getCases()) {\n+            if (switchCase.getExpression() == null) {\n+                defaultCase = transform(switchCase);\n+            } else {\n+                caseList.addChildToBack(transform(switchCase));\n+            }\n+        }\n+        return newNode(Token.SWITCH, transform(switchStatementNode.getExpression()), caseList, defaultCase);\n+    }\n+\n+    @Override\n+    public Node process(SwitchCase switchCaseNode) {\n+        Node caseLabel = newNode(Token.CASE, transform(switchCaseNode.getExpression()));\n+        NodeList<Node> statements = transform(switchCaseNode.getStatements());\n+        Node caseBlock = newNode(Token.BLOCK, statements.toArray(new Node[0]));\n+        return newNode(Token.LABEL, caseLabel, caseBlock);\n+    }\n+\n+    @Override\n+    public Node process(ThrowStatement throwStatementNode) {\n+        return newNode(Token.THROW, transform(throwStatementNode.getExpression()));\n+    }\n+\n+    @Override\n+    public Node process(TryStatement tryStatementNode) {\n+        return newNode(Token.TRY, transformBlock(tryStatementNode.getTryBlock()), transform(tryStatementNode.getCatchBlock()), transformBlock(tryStatementNode.getFinallyBlock()));\n+    }\n+\n+    @Override\n+    public Node process(CatchClause catchClauseNode) {\n+        Node name = transform(catchClauseNode.getVarName());\n+        Node body = transformBlock(catchClauseNode.getBody());\n+        return newNode(Token.CATCH, name, body);\n+    }\n+\n+    @Override\n+    public Node process(NewExpression newExpressionNode) {\n+        return newNode(Token.NEW, transform(newExpressionNode.getTarget()), transform(newExpressionNode.getArguments()));\n+    }\n+\n+    @Override\n+    public Node process(ArrayAccess arrayAccessNode) {\n+        return newNode(Token.GETELEM, transform(arrayAccessNode.getTarget()), transform(arrayAccessNode.getIndex()));\n+    }\n+\n+    @Override\n+    public Node process(XmlString xmlString) {\n+        StringBuilder builder = new StringBuilder();\n+        for (int i = 0; i < xmlString.getFragments().size(); i++) {\n+            Object fragment = xmlString.getFragments().get(i);\n+            if (fragment instanceof XmlFragment) {\n+                builder.append(((XmlFragment) fragment).toCode());\n+            } else {\n+                AstNode astFragment = (AstNode) fragment;\n+                builder.append(astFragment.toSource(0));\n+            }\n+        }\n+        return IR.string(builder.toString());\n+    }\n+\n+    @Override\n+    public Node process(XmlLiteral xmlLiteral) {\n+        return IR.xmlLiteral(xmlLiteral.toSource());\n+    }\n+\n+    @Override\n+    public Node process(ExpressionStatement expressionStatementNode) {\n+        Node node = transform(expressionStatementNode.getExpression());\n+        if (node != null) {\n+            int type = node.getType();\n+            if (type == Token.CALL || type == Token.NEW) {\n+                return node;\n+            }\n+            return newNode(Token.EXPR_RESULT, node);\n+        }\n+        return null;\n+    }\n+\n+    @Override\n+    public Node process(VariableInitializer variableInitializerNode) {\n+        Node node = newNode(Token.NAME, IR.name(variableInitializerNode.getTarget().getIdentifier()));\n+        if (variableInitializerNode.getInitializer() != null) {\n+            node.addChildToFront(transform(variableInitializerNode.getInitializer()));\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    public Node process(Comment comment) {\n+        return null;\n+    }\n+\n+    @Override\n+    public Node process(XmlRef xmlRef) {\n+        return IR.xmlRef(xmlRef.toSource());\n     }\n \n+    @Override\n+    public Node process(XmlElemRef xmlElemRef) {\n+        return IR.xmlElemRef(transform(xmlElemRef.getExpression()), transform(xmlElemRef.getRefName()));\n+    }\n+\n+    @Override\n+    public Node process(XmlPropRef xmlPropRef) {\n+        return IR.xmlPropRef(transform(xmlPropRef.getExpression()), transform(xmlPropRef.getPropName()));\n+    }\n+\n+    private NodeList<Node> transform(Block node) {\n+        NodeList<Node> children = transform(node.getStatements());\n+        return children != null ? children : new NodeList<>(0);\n+    }\n+\n+    private NodeList<Node> transform(List<? extends AstNode> nodes) {\n+        NodeList<Node> children = null;\n+        for (AstNode node : nodes) {\n+            Node transformedNode = transform(node);\n+            if (transformedNode != null) {\n+                if (children == null) {\n+                    children = new NodeList<>();\n+                }\n+            \n+                if (transformedNode.getType() == Token.LABEL) {\n+                    // Special handling for label nodes, which should be added directly to the parent.\n+                    children.addAll(transformedNode.removeChildren());\n+                } else {\n+                    children.add(transformedNode);\n+                }\n+            }\n+        }\n+        return children;\n+    }\n+\n+    private Node transform(AstNode node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        return IRFactory.transform(node, this);\n+    }\n+\n+    private Node transformBlock(AstNode node) {\n+        return newNode(Token.BLOCK, transform(node));\n+    }\n+}\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}