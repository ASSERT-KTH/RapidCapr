{
    "patch": "      // Check if inputs need to be rebuilt from modules.\n      boolean staleInputs = false;\n\n      // Check if the sources need to be re-ordered.\n      if (options.dependencyOptions != null && options.dependencyOptions.needsManagement()) {\n        if (options.closurePass) {\n          for (CompilerInput input : inputs) {\n            // Forward-declare all the provided types, so that they\n            // are not flagged even if they are dropped from the process.\n            for (String provide : input.getProvides()) {\n              getTypeRegistry().forwardDeclareType(provide);\n            }\n          }\n\n          try {\n            inputs =\n                (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n                .manageDependencies(options.dependencyOptions, inputs);\n            staleInputs = true;\n          } catch (CircularDependencyException e) {\n            report(JSError.make(\n                JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n            // If in IDE mode, we ignore the error and keep going.\n            if (hasErrors()) {\n              return null;\n            }\n          } catch (MissingProvideException e) {\n            report(JSError.make(\n                MISSING_ENTRY_ERROR, e.getMessage()));\n\n            // If in IDE mode, we ignore the error and keep going.\n            if (hasErrors()) {\n              return null;\n            }\n          }\n        } else {\n          report(JSError.make(\n              CLOSURE_COMPILED_WITHOUT_CLOSURE_LIBRARY_ERROR));\n\n          // If in IDE mode, we ignore the error and keep going.\n          if (hasErrors()) {\n            return null;\n          }\n        }\n      }\n\n      for (CompilerInput input : inputs) {\n        Node n = input.getAstRoot(this);\n        // Inputs can have a null AST during initial parse.\n        if (n == null) {\n          continue;\n        }\n\n        if (n.getJSDocInfo() != null) {\n          JSDocInfo info = n.getJSDocInfo();\n          if (info.isExterns()) {\n            // If the input file is explicitly marked as an externs file, then\n            // assume the programmer made a mistake and throw it into\n            // the externs pile anyways.\n            externsRoot.addChildToBack(n);\n            input.setIsExtern(true);\n\n            input.getModule().remove(input);\n\n            externs.add(input);\n            staleInputs = true;\n          } else if (info.isNoCompile()) {\n            input.getModule().remove(input);\n            staleInputs = true;\n          }\n        }\n      }\n\n      if (staleInputs) {\n        fillEmptyModules(modules);\n        rebuildInputsFromModules();\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..5907eb03 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,84 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+      // Check if inputs need to be rebuilt from modules.\n+      boolean staleInputs = false;\n+\n+      // Check if the sources need to be re-ordered.\n+      if (options.dependencyOptions != null && options.dependencyOptions.needsManagement()) {\n+        if (options.closurePass) {\n+          for (CompilerInput input : inputs) {\n+            // Forward-declare all the provided types, so that they\n+            // are not flagged even if they are dropped from the process.\n+            for (String provide : input.getProvides()) {\n+              getTypeRegistry().forwardDeclareType(provide);\n+            }\n+          }\n+\n+          try {\n+            inputs =\n+                (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n+                .manageDependencies(options.dependencyOptions, inputs);\n+            staleInputs = true;\n+          } catch (CircularDependencyException e) {\n+            report(JSError.make(\n+                JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n+\n+            // If in IDE mode, we ignore the error and keep going.\n+            if (hasErrors()) {\n+              return null;\n+            }\n+          } catch (MissingProvideException e) {\n+            report(JSError.make(\n+                MISSING_ENTRY_ERROR, e.getMessage()));\n+\n+            // If in IDE mode, we ignore the error and keep going.\n+            if (hasErrors()) {\n+              return null;\n+            }\n+          }\n+        } else {\n+          report(JSError.make(\n+              CLOSURE_COMPILED_WITHOUT_CLOSURE_LIBRARY_ERROR));\n+\n+          // If in IDE mode, we ignore the error and keep going.\n+          if (hasErrors()) {\n+            return null;\n+          }\n+        }\n+      }\n+\n+      for (CompilerInput input : inputs) {\n+        Node n = input.getAstRoot(this);\n+        // Inputs can have a null AST during initial parse.\n+        if (n == null) {\n+          continue;\n+        }\n+\n+        if (n.getJSDocInfo() != null) {\n+          JSDocInfo info = n.getJSDocInfo();\n+          if (info.isExterns()) {\n+            // If the input file is explicitly marked as an externs file, then\n+            // assume the programmer made a mistake and throw it into\n+            // the externs pile anyways.\n+            externsRoot.addChildToBack(n);\n+            input.setIsExtern(true);\n+\n+            input.getModule().remove(input);\n+\n+            externs.add(input);\n+            staleInputs = true;\n+          } else if (info.isNoCompile()) {\n+            input.getModule().remove(input);\n+            staleInputs = true;\n+          }\n+        }\n+      }\n+\n+      if (staleInputs) {\n+        fillEmptyModules(modules);\n+        rebuildInputsFromModules();\n+      }\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
    "result_reason": "error: '.class' expected",
    "test_result": "ERROR"
}