{
    "patch": "  private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    List<Node> parametersList = functionType.getParameters();\n    int numFormals = parametersList.size();\n\n    int offset = 0;\n    if (NodeUtil.isGetOrSetKey(call)) {\n      offset = 1;\n    }\n\n    int numArgs = call.getChildCount() - 1 - offset;\n    if (functionType.isVarArgs() && numArgs >= numFormals - 1) {\n      // Okay.\n    } else if (numArgs < functionType.getMinArguments()) {\n      report(t, call, TypeValidator.WRONG_ARGUMENT_COUNT,\n          String.valueOf(numArgs), String.valueOf(functionType.getMinArguments()));\n      return;\n    } else if (numArgs > functionType.getMaxArguments()) {\n      int maxArgs = functionType.getMaxArguments();\n      if (functionType.isVarArgsConstructor()) {\n        maxArgs = Integer.MAX_VALUE;\n      }\n      report(t, call, TypeValidator.WRONG_ARGUMENT_COUNT,\n          String.valueOf(numArgs), String.valueOf(functionType.getMinArguments()),\n          String.valueOf(maxArgs));\n      return;\n    }\n\n    ListIterator<Node> formalIter = parametersList.listIterator();\n\n    int argumentNumber = 0;\n    Node previousFormal = null;\n\n    if (formalIter.hasNext()\n        && formalIter.next().getJSDocInfo() != null\n        && formalIter.previousIndex() == 0) {\n      // Skip the first formal if it has a JSDoc annotation -- e.g. \"@this\".\n      previousFormal = formalIter.next();\n      previousFormal.getJSDocInfo().getParameterTypeUsages().get(0).setDeclaredType(\n          getJSType(previousFormal.getJSDocInfo().getParameterTypeUsages().get(0).getNode()));\n      argumentNumber++;\n    }\n\n    while (formalIter.hasNext()) {\n      Node formal = formalIter.next();\n\n      if (formal.isRest()) {\n        // rest argument\n        checkVarArgs(call, formal, arguments, argumentNumber);\n        continue;\n      }\n\n      Node argument = null;\n      if (arguments.hasNext()) {\n        argument = arguments.next();\n        argumentNumber++;\n      } else if (formal.hasChildren() && formal.getFirstChild().isDefaultValue()) {\n        // use default value, if no argument\n        continue;\n      } else {\n        return;\n      }\n\n      boolean isOptionalParameter = false;\n      if (previousFormal != null\n          && NodeUtil.getZeroBasedParameterIndex(previousFormal) == argumentNumber - 2\n          && previousFormal.getJSDocInfo() != null\n          && previousFormal.getJSDocInfo().isOptionalParam(getTypeParser())) {\n        isOptionalParameter = true;\n      }\n      previousFormal = formal;\n\n      validator.expectArgumentMatchesParameter(t, argument,\n          getJSType(argument), getJSType(formal), call, argumentNumber, isOptionalParameter);\n    }\n  }\n\n  private void checkVarArgs(Node call, Node formal, Iterator<Node> argumentsIterator,\n      int argumentNumber) {\n    while (argumentsIterator.hasNext()) {\n      Node argument = argumentsIterator.next();\n      validator.expectArgumentMatchesParameter(\n          null, argument, getJSType(argument), getJSType(formal), call, argumentNumber);\n      argumentNumber++;\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 8077e0d8..6b6906b2 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1401,31 +1401,88 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     Iterator<Node> arguments = call.children().iterator();\n     arguments.next(); // skip the function name\n \n-    Iterator<Node> parameters = functionType.getParameters().iterator();\n-    int ordinal = 0;\n-    Node parameter = null;\n-    Node argument = null;\n-    while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n-      // If there are no parameters left in the list, then the while loop\n-      // above implies that this must be a var_args function.\n-        parameter = parameters.next();\n-      argument = arguments.next();\n-      ordinal++;\n+    List<Node> parametersList = functionType.getParameters();\n+    int numFormals = parametersList.size();\n+\n+    int offset = 0;\n+    if (NodeUtil.isGetOrSetKey(call)) {\n+      offset = 1;\n+    }\n+\n+    int numArgs = call.getChildCount() - 1 - offset;\n+    if (functionType.isVarArgs() && numArgs >= numFormals - 1) {\n+      // Okay.\n+    } else if (numArgs < functionType.getMinArguments()) {\n+      report(t, call, TypeValidator.WRONG_ARGUMENT_COUNT,\n+          String.valueOf(numArgs), String.valueOf(functionType.getMinArguments()));\n+      return;\n+    } else if (numArgs > functionType.getMaxArguments()) {\n+      int maxArgs = functionType.getMaxArguments();\n+      if (functionType.isVarArgsConstructor()) {\n+        maxArgs = Integer.MAX_VALUE;\n+      }\n+      report(t, call, TypeValidator.WRONG_ARGUMENT_COUNT,\n+          String.valueOf(numArgs), String.valueOf(functionType.getMinArguments()),\n+          String.valueOf(maxArgs));\n+      return;\n+    }\n+\n+    ListIterator<Node> formalIter = parametersList.listIterator();\n+\n+    int argumentNumber = 0;\n+    Node previousFormal = null;\n+\n+    if (formalIter.hasNext()\n+        && formalIter.next().getJSDocInfo() != null\n+        && formalIter.previousIndex() == 0) {\n+      // Skip the first formal if it has a JSDoc annotation -- e.g. \"@this\".\n+      previousFormal = formalIter.next();\n+      previousFormal.getJSDocInfo().getParameterTypeUsages().get(0).setDeclaredType(\n+          getJSType(previousFormal.getJSDocInfo().getParameterTypeUsages().get(0).getNode()));\n+      argumentNumber++;\n+    }\n+\n+    while (formalIter.hasNext()) {\n+      Node formal = formalIter.next();\n+\n+      if (formal.isRest()) {\n+        // rest argument\n+        checkVarArgs(call, formal, arguments, argumentNumber);\n+        continue;\n+      }\n+\n+      Node argument = null;\n+      if (arguments.hasNext()) {\n+        argument = arguments.next();\n+        argumentNumber++;\n+      } else if (formal.hasChildren() && formal.getFirstChild().isDefaultValue()) {\n+        // use default value, if no argument\n+        continue;\n+      } else {\n+        return;\n+      }\n+\n+      boolean isOptionalParameter = false;\n+      if (previousFormal != null\n+          && NodeUtil.getZeroBasedParameterIndex(previousFormal) == argumentNumber - 2\n+          && previousFormal.getJSDocInfo() != null\n+          && previousFormal.getJSDocInfo().isOptionalParam(getTypeParser())) {\n+        isOptionalParameter = true;\n+      }\n+      previousFormal = formal;\n \n       validator.expectArgumentMatchesParameter(t, argument,\n-          getJSType(argument), getJSType(parameter), call, ordinal);\n+          getJSType(argument), getJSType(formal), call, argumentNumber, isOptionalParameter);\n     }\n+  }\n \n-    int numArgs = call.getChildCount() - 1;\n-    int minArgs = functionType.getMinArguments();\n-    int maxArgs = functionType.getMaxArguments();\n-    if (minArgs > numArgs || maxArgs < numArgs) {\n-      report(t, call, WRONG_ARGUMENT_COUNT,\n-              validator.getReadableJSTypeName(call.getFirstChild(), false),\n-              String.valueOf(numArgs), String.valueOf(minArgs),\n-              maxArgs != Integer.MAX_VALUE ?\n-              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+  private void checkVarArgs(Node call, Node formal, Iterator<Node> argumentsIterator,\n+      int argumentNumber) {\n+    while (argumentsIterator.hasNext()) {\n+      Node argument = argumentsIterator.next();\n+      validator.expectArgumentMatchesParameter(\n+          null, argument, getJSType(argument), getJSType(formal), call, argumentNumber);\n+      argumentNumber++;\n     }\n   }\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}