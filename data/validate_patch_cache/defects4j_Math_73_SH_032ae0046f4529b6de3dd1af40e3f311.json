{
    "patch": "        double lastMidpoint = initial;\n        double oldDelta = initial - min;\n        double delta = max - initial;\n        int numIterations = 0;\n\n        double yMid = f.value(lastMidpoint);\n        double yPrev = yInitial;\n        double yyMin = yMin;\n        double yyMax = yMax;\n\n        while (numIterations++ < maximalIterationCount) {\n            if (yMid * yyMin <= 0.0) {\n                max = lastMidpoint;\n                yyMax = yMid;\n            } else {\n                min = lastMidpoint;\n                yyMin = yMid;\n            }\n\n            if ((Math.abs(yyMin) < Math.abs(yyMax)) || Double.isNaN(yyMax)) {\n                lastMidpoint = min + 0.5 * (max - min);\n                yMid = f.value(lastMidpoint);\n            } else if ((Math.abs(yMid) < Math.abs(yyMin)) || Double.isNaN(yyMin) || Double.isInfinite(yyMin)) {\n                lastMidpoint = oldDelta * 0.5 + lastMidpoint;\n                yMid = f.value(lastMidpoint);\n            } else if ((Math.abs(yMid) < Math.abs(yyMax)) || Double.isNaN(yyMax) || Double.isInfinite(yyMax)) {\n                lastMidpoint = lastMidpoint + 0.5 * delta;\n                yMid = f.value(lastMidpoint);\n            } else {\n                // last resort; this never happened before, but who knows?\n                lastMidpoint = 0.5 * (min + max);\n                yMid = f.value(lastMidpoint);\n                yyMin = yPrev;\n                yyMax = yMax;\n            }\n\n            delta = max - min;\n            double rtol = 2 * functionValueAccuracy + relativeAccuracy * Math.max(Math.abs(lastMidpoint), Math.abs(max));\n            if (Math.abs(yMid) <= rtol) {\n                setResult(lastMidpoint, numIterations);\n                return result;\n            }\n\n            if (numIterations > 1 && Math.abs(lastMidpoint - oldMidpoint) < relativeAccuracy * Math.max(Math.abs(lastMidpoint),\n                    Math.abs(oldMidpoint)) - functionValueAccuracy) {\n                setResult(lastMidpoint, numIterations);\n                return result;\n            }\n\n            oldMidpoint = lastMidpoint;\n            yPrev = yMid;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..6477fc443 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,59 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double lastMidpoint = initial;\n+        double oldDelta = initial - min;\n+        double delta = max - initial;\n+        int numIterations = 0;\n+\n+        double yMid = f.value(lastMidpoint);\n+        double yPrev = yInitial;\n+        double yyMin = yMin;\n+        double yyMax = yMax;\n+\n+        while (numIterations++ < maximalIterationCount) {\n+            if (yMid * yyMin <= 0.0) {\n+                max = lastMidpoint;\n+                yyMax = yMid;\n+            } else {\n+                min = lastMidpoint;\n+                yyMin = yMid;\n+            }\n+\n+            if ((Math.abs(yyMin) < Math.abs(yyMax)) || Double.isNaN(yyMax)) {\n+                lastMidpoint = min + 0.5 * (max - min);\n+                yMid = f.value(lastMidpoint);\n+            } else if ((Math.abs(yMid) < Math.abs(yyMin)) || Double.isNaN(yyMin) || Double.isInfinite(yyMin)) {\n+                lastMidpoint = oldDelta * 0.5 + lastMidpoint;\n+                yMid = f.value(lastMidpoint);\n+            } else if ((Math.abs(yMid) < Math.abs(yyMax)) || Double.isNaN(yyMax) || Double.isInfinite(yyMax)) {\n+                lastMidpoint = lastMidpoint + 0.5 * delta;\n+                yMid = f.value(lastMidpoint);\n+            } else {\n+                // last resort; this never happened before, but who knows?\n+                lastMidpoint = 0.5 * (min + max);\n+                yMid = f.value(lastMidpoint);\n+                yyMin = yPrev;\n+                yyMax = yMax;\n+            }\n+\n+            delta = max - min;\n+            double rtol = 2 * functionValueAccuracy + relativeAccuracy * Math.max(Math.abs(lastMidpoint), Math.abs(max));\n+            if (Math.abs(yMid) <= rtol) {\n+                setResult(lastMidpoint, numIterations);\n+                return result;\n+            }\n+\n+            if (numIterations > 1 && Math.abs(lastMidpoint - oldMidpoint) < relativeAccuracy * Math.max(Math.abs(lastMidpoint),\n+                    Math.abs(oldMidpoint)) - functionValueAccuracy) {\n+                setResult(lastMidpoint, numIterations);\n+                return result;\n+            }\n+\n+            oldMidpoint = lastMidpoint;\n+            yPrev = yMid;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}