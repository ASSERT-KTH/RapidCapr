{
    "patch": "public void integrate(final ExpandableStatefulODE equations, final double t)\n        throws MathIllegalStateException, MathIllegalArgumentException {\n    sanityChecks(equations, t);\n    setEquations(equations);\n    final boolean forward = t > equations.getTime();\n\n    // create some internal working arrays\n    final double[] y0  = equations.getCompleteState();\n    final double[] y = y0.clone();\n    final int stages = c.length + 1;\n    final double[][] yDotK = new double[stages][y.length];\n    final double[] yTmp    = y0.clone();\n    final double[] yDotTmp = new double[y.length];\n\n    // set up an interpolator sharing the integrator arrays\n    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n    interpolator.reinitialize(this, yTmp, yDotK, forward,\n            equations.getPrimaryMapper(), equations.getSecondaryMappers());\n    interpolator.storeTime(equations.getTime());\n\n    // set up integration control objects\n    stepStart         = equations.getTime();\n    double  hNew      = 0;\n    boolean firstTime = true;\n    initIntegration(stepStart, y0, t);\n\n    // initialize the step handler\n    for (final StepHandler handler : stepHandlers) {\n        handler.init(switches, equations.getTime(), y0, t);\n    }\n\n    // main integration loop\n    isLastStep = false;\n    while (!isLastStep) {\n\n        double error = 10;\n        while (error >= 1.0) {\n\n            if (firstTime) {\n                computeDerivatives(stepStart, y, yDotK[0]);\n            }\n\n            if (firstTime || !fsal) {\n                // first stage\n                for (int j = 0; j < y0.length; ++j) {\n                    double sum = a[0][0] * yDotK[0][j];\n                    for (int l = 1; l < stages; ++l) {\n                        sum += a[l][0] * yDotK[l][j];\n                    }\n                    yTmp[j] = y[j] + stepSize * sum;\n                }\n                computeDerivatives(stepStart + c[0] * stepSize, yTmp, yDotK[1]);\n            }\n\n            stepSize = hNew;\n            for (int k = 1; k < stages; ++k) {\n\n                if (!fsal || k != 1) {\n                    for (int j = 0; j < y0.length; ++j) {\n                        double sum = a[k-1][0] * yDotK[0][j];\n                        for (int l = 1; l < k; ++l) {\n                            sum += a[k-1][l] * yDotK[l][j];\n                        }\n                        yTmp[j] = y[j] + stepSize * sum;\n                    }\n                    computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n                }\n\n            }\n\n            for (int j = 0; j < y0.length; ++j) {\n                double sum    = b[0] * yDotK[0][j];\n                for (int l = 1; l < stages; ++l) {\n                    sum    += b[l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n\n            error = estimateError(yDotK, y, yTmp, stepSize);\n            if (error >= 1.0) {\n                // reject the step and attempt to reduce error by stepsize control\n                final double factor =\n                        FastMath.min(maxGrowth,\n                                FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n                hNew = filterStep(stepSize * factor, forward, false);\n            }\n\n        }\n\n        final double nextStep = stepStart + stepSize;\n        if ((forward ? nextStep >= t : nextStep <= t) || firstStepAlreadyComputed) {\n            isLastStep = true;\n            stepSize   = t - stepStart;\n        }\n\n        interpolator.storeTime(stepStart + stepSize);\n        for (int j = 0; j < y0.length; ++j) {\n            y[j] = yTmp[j];\n        }\n        computeDerivatives(stepStart + stepSize, y, yDotTmp);\n        System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n\n        if (fsal) {\n            // save the last evaluation for the next step\n            final double[] tmp = yDotK[0];\n            yDotK[0] = yDotK[stages - 1];\n            yDotK[stages - 1] = tmp;\n        }\n\n        // handle step in step handler\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n\n        // prepare next step\n        stepStart = acceptStep(interpolator, y, yDotK[0], t);\n        System.arraycopy(y, 0, yTmp, 0, y.length);\n        System.arraycopy(yDotK[0], 0, yDotTmp, 0, y0.length);\n\n        // check convergence\n        hNew = initializeStep(forward, getOrder(), scales,\n                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n\n        if (firstStepAlreadyComputed) {\n            for (final StepHandler handler : stepHandlers) {\n                handler.init(switches, stepStart, y, t);\n            }\n        }\n\n        firstStepAlreadyComputed = true;\n\n    }\n\n    // dispatch results\n    equations.setTime(stepStart);\n    equations.setCompleteState(y);\n\n    resetInternalState();\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..8fa122731 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,146 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+public void integrate(final ExpandableStatefulODE equations, final double t)\n+        throws MathIllegalStateException, MathIllegalArgumentException {\n+    sanityChecks(equations, t);\n+    setEquations(equations);\n+    final boolean forward = t > equations.getTime();\n+\n+    // create some internal working arrays\n+    final double[] y0  = equations.getCompleteState();\n+    final double[] y = y0.clone();\n+    final int stages = c.length + 1;\n+    final double[][] yDotK = new double[stages][y.length];\n+    final double[] yTmp    = y0.clone();\n+    final double[] yDotTmp = new double[y.length];\n+\n+    // set up an interpolator sharing the integrator arrays\n+    final RungeKuttaStepInterpolator interpolator = (RungeKuttaStepInterpolator) prototype.copy();\n+    interpolator.reinitialize(this, yTmp, yDotK, forward,\n+            equations.getPrimaryMapper(), equations.getSecondaryMappers());\n+    interpolator.storeTime(equations.getTime());\n+\n+    // set up integration control objects\n+    stepStart         = equations.getTime();\n+    double  hNew      = 0;\n+    boolean firstTime = true;\n+    initIntegration(stepStart, y0, t);\n+\n+    // initialize the step handler\n+    for (final StepHandler handler : stepHandlers) {\n+        handler.init(switches, equations.getTime(), y0, t);\n+    }\n+\n+    // main integration loop\n+    isLastStep = false;\n+    while (!isLastStep) {\n+\n+        double error = 10;\n+        while (error >= 1.0) {\n+\n+            if (firstTime) {\n+                computeDerivatives(stepStart, y, yDotK[0]);\n+            }\n+\n+            if (firstTime || !fsal) {\n+                // first stage\n+                for (int j = 0; j < y0.length; ++j) {\n+                    double sum = a[0][0] * yDotK[0][j];\n+                    for (int l = 1; l < stages; ++l) {\n+                        sum += a[l][0] * yDotK[l][j];\n+                    }\n+                    yTmp[j] = y[j] + stepSize * sum;\n+                }\n+                computeDerivatives(stepStart + c[0] * stepSize, yTmp, yDotK[1]);\n+            }\n+\n+            stepSize = hNew;\n+            for (int k = 1; k < stages; ++k) {\n+\n+                if (!fsal || k != 1) {\n+                    for (int j = 0; j < y0.length; ++j) {\n+                        double sum = a[k-1][0] * yDotK[0][j];\n+                        for (int l = 1; l < k; ++l) {\n+                            sum += a[k-1][l] * yDotK[l][j];\n+                        }\n+                        yTmp[j] = y[j] + stepSize * sum;\n+                    }\n+                    computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+                }\n+\n+            }\n+\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum    = b[0] * yDotK[0][j];\n+                for (int l = 1; l < stages; ++l) {\n+                    sum    += b[l] * yDotK[l][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            error = estimateError(yDotK, y, yTmp, stepSize);\n+            if (error >= 1.0) {\n+                // reject the step and attempt to reduce error by stepsize control\n+                final double factor =\n+                        FastMath.min(maxGrowth,\n+                                FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+                hNew = filterStep(stepSize * factor, forward, false);\n+            }\n+\n+        }\n+\n+        final double nextStep = stepStart + stepSize;\n+        if ((forward ? nextStep >= t : nextStep <= t) || firstStepAlreadyComputed) {\n+            isLastStep = true;\n+            stepSize   = t - stepStart;\n+        }\n+\n+        interpolator.storeTime(stepStart + stepSize);\n+        for (int j = 0; j < y0.length; ++j) {\n+            y[j] = yTmp[j];\n+        }\n+        computeDerivatives(stepStart + stepSize, y, yDotTmp);\n+        System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n+\n+        if (fsal) {\n+            // save the last evaluation for the next step\n+            final double[] tmp = yDotK[0];\n+            yDotK[0] = yDotK[stages - 1];\n+            yDotK[stages - 1] = tmp;\n+        }\n+\n+        // handle step in step handler\n+        for (final StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, isLastStep);\n+        }\n+\n+        // prepare next step\n+        stepStart = acceptStep(interpolator, y, yDotK[0], t);\n+        System.arraycopy(y, 0, yTmp, 0, y.length);\n+        System.arraycopy(yDotK[0], 0, yDotTmp, 0, y0.length);\n+\n+        // check convergence\n+        hNew = initializeStep(forward, getOrder(), scales,\n+                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n+\n+        if (firstStepAlreadyComputed) {\n+            for (final StepHandler handler : stepHandlers) {\n+                handler.init(switches, stepStart, y, t);\n+            }\n+        }\n+\n+        firstStepAlreadyComputed = true;\n+\n+    }\n+\n+    // dispatch results\n+    equations.setTime(stepStart);\n+    equations.setCompleteState(y);\n+\n+    resetInternalState();\n+\n+}\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}