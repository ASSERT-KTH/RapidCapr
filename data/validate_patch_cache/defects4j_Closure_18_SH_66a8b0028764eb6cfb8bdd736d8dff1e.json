{
    "patch": "      boolean manageDependencies =\n          options.dependencyOptions.needsManagement() && options.manageClosureDependencies;\n\n      if (manageDependencies) {\n        // Do the pre-Closure things that the old code below does,\n        // except for managing dependencies.\n        if (astValidationEnabled) {\n          // At this point, externsRoot and jsRoot contain the entire\n          // program, so it's safe to check them for errors.\n          // This check must happen BEFORE the Normalize pass, because\n          // Normalize changes some nodes (e.g. nameless function declarations\n          // become nameless function expressions).\n          sanityCheck();\n        }\n\n        cleanupPasses.executeCleanupPasses(externsRoot, jsRoot);\n      }\n\n      if (options.dependencyOptions.needsManagement()) {\n        // Collect Provides and Requires before adding missing goog.requires.\n        collectProvidedNames();\n        collectExternExports();\n\n        // Check if the sources need to be re-ordered.\n        boolean staleInputs = false;\n        if (manageDependencies) {\n          for (CompilerInput input : inputs) {\n            // Forward-declare all the provided types, so that they\n            // are not flagged even if they are dropped from the process.\n            for (String provide : input.getProvides()) {\n              getTypeRegistry().forwardDeclareType(provide);\n            }\n          }\n\n          try {\n            inputs =\n                (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n                .manageDependencies(options.dependencyOptions, inputs);\n            staleInputs = true;\n          } catch (CircularDependencyException e) {\n            report(JSError.make(\n                JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n\n            // If in IDE mode, we ignore the error and keep going.\n            if (hasErrors()) {\n              return null;\n            }\n          } catch (MissingProvideException e) {\n            report(JSError.make(\n                MISSING_ENTRY_ERROR, e.getMessage()));\n\n            // If in IDE mode, we ignore the error and keep going.\n            if (hasErrors()) {\n              return null;\n            }\n          }\n        }\n\n        hoistNoCompileFiles();\n\n        if (staleInputs) {\n          repartitionInputs();\n        }\n\n        // First lookup externs, then look up the rest of the generated files.\n        var resolvedInputs = inputs\n          .stream()\n          .peek(input -> resolveFileHelper(input))\n          .collect(Collectors.toList());\n\n        // Build the AST.\n        for (CompilerInput input : resolvedInputs) {\n          if (input.isExtern()) {\n            Node n = input.getAstRoot(this);\n            if (n == null) {\n              continue;\n            }\n            externsRoot.addChildToBack(n);\n          } else if (input.getSourceFile().isModuleType()) {\n            // We avoid processing module files until later in the pipeline.\n            moduleGraph.addModule(input);\n          } else {\n            Node n = input.getAstRoot(this);\n            if (devMode) {\n              runSanityCheck();\n              if (hasErrors()) {\n                return null;\n              }\n            }\n\n            if (options.sourceMapOutputPath != null ||\n                options.nameReferenceReportPath != null) {\n\n              // Annotate the nodes in the tree with information from the\n              // input file. This information is used to construct the SourceMap.\n              SourceInformationAnnotator sia =\n                  new SourceInformationAnnotator(\n                      input.getName(), options.devMode != DevMode.OFF);\n              NodeTraversal.traverse(this, n, sia);\n            }\n\n            jsRoot.addChildToBack(n);\n          }\n        }\n\n        moduleGraphManageDependencies();\n      } else {\n        // Old Closure-agnostic logic, not as feature-filled as the Closure-dependent logic above.\n        // The new code above does not even require this, because even standalone mode can\n        // handle Rename/Killing. The only logic that really requires DependencyMode is\n        // the unmatchedProvides logic in CollectNamedTypes.\n        //\n        // TODO(morelli): simplify this in a future commit.\n\n        // Goog.require() adding must be done before we've created a\n        // single Node for the entire program, because doing it later\n        // would put the goog.require()s in the wrong place.\n        if (astValidationEnabled) {\n          // At this point, externsRoot and jsRoot contain the entire\n          // program, so it's safe to check them for errors.\n          // This check must happen BEFORE the Normalize pass, because\n          // Normalize changes some nodes (e.g. nameless function declarations\n          // become nameless function expressions).\n          sanityCheck();\n        }\n        addImplicitExterns();\n        addCustomPassesBeforeNormalizing();\n        if (options.devMode == DevMode.OFF) {\n          new RemoveScriptNodes().setCompiler(this).process(externsRoot, jsRoot);\n        }\n        applyCustomPassesAfterNormalization();\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex 8898f77f..134ad5ce 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1285,7 +1285,138 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       boolean staleInputs = false;\n-      if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+      boolean manageDependencies =\n+          options.dependencyOptions.needsManagement() && options.manageClosureDependencies;\n+\n+      if (manageDependencies) {\n+        // Do the pre-Closure things that the old code below does,\n+        // except for managing dependencies.\n+        if (astValidationEnabled) {\n+          // At this point, externsRoot and jsRoot contain the entire\n+          // program, so it's safe to check them for errors.\n+          // This check must happen BEFORE the Normalize pass, because\n+          // Normalize changes some nodes (e.g. nameless function declarations\n+          // become nameless function expressions).\n+          sanityCheck();\n+        }\n+\n+        cleanupPasses.executeCleanupPasses(externsRoot, jsRoot);\n+      }\n+\n+      if (options.dependencyOptions.needsManagement()) {\n+        // Collect Provides and Requires before adding missing goog.requires.\n+        collectProvidedNames();\n+        collectExternExports();\n+\n+        // Check if the sources need to be re-ordered.\n+        boolean staleInputs = false;\n+        if (manageDependencies) {\n+          for (CompilerInput input : inputs) {\n+            // Forward-declare all the provided types, so that they\n+            // are not flagged even if they are dropped from the process.\n+            for (String provide : input.getProvides()) {\n+              getTypeRegistry().forwardDeclareType(provide);\n+            }\n+          }\n+\n+          try {\n+            inputs =\n+                (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n+                .manageDependencies(options.dependencyOptions, inputs);\n+            staleInputs = true;\n+          } catch (CircularDependencyException e) {\n+            report(JSError.make(\n+                JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n+\n+            // If in IDE mode, we ignore the error and keep going.\n+            if (hasErrors()) {\n+              return null;\n+            }\n+          } catch (MissingProvideException e) {\n+            report(JSError.make(\n+                MISSING_ENTRY_ERROR, e.getMessage()));\n+\n+            // If in IDE mode, we ignore the error and keep going.\n+            if (hasErrors()) {\n+              return null;\n+            }\n+          }\n+        }\n+\n+        hoistNoCompileFiles();\n+\n+        if (staleInputs) {\n+          repartitionInputs();\n+        }\n+\n+        // First lookup externs, then look up the rest of the generated files.\n+        var resolvedInputs = inputs\n+          .stream()\n+          .peek(input -> resolveFileHelper(input))\n+          .collect(Collectors.toList());\n+\n+        // Build the AST.\n+        for (CompilerInput input : resolvedInputs) {\n+          if (input.isExtern()) {\n+            Node n = input.getAstRoot(this);\n+            if (n == null) {\n+              continue;\n+            }\n+            externsRoot.addChildToBack(n);\n+          } else if (input.getSourceFile().isModuleType()) {\n+            // We avoid processing module files until later in the pipeline.\n+            moduleGraph.addModule(input);\n+          } else {\n+            Node n = input.getAstRoot(this);\n+            if (devMode) {\n+              runSanityCheck();\n+              if (hasErrors()) {\n+                return null;\n+              }\n+            }\n+\n+            if (options.sourceMapOutputPath != null ||\n+                options.nameReferenceReportPath != null) {\n+\n+              // Annotate the nodes in the tree with information from the\n+              // input file. This information is used to construct the SourceMap.\n+              SourceInformationAnnotator sia =\n+                  new SourceInformationAnnotator(\n+                      input.getName(), options.devMode != DevMode.OFF);\n+              NodeTraversal.traverse(this, n, sia);\n+            }\n+\n+            jsRoot.addChildToBack(n);\n+          }\n+        }\n+\n+        moduleGraphManageDependencies();\n+      } else {\n+        // Old Closure-agnostic logic, not as feature-filled as the Closure-dependent logic above.\n+        // The new code above does not even require this, because even standalone mode can\n+        // handle Rename/Killing. The only logic that really requires DependencyMode is\n+        // the unmatchedProvides logic in CollectNamedTypes.\n+        //\n+        // TODO(morelli): simplify this in a future commit.\n+\n+        // Goog.require() adding must be done before we've created a\n+        // single Node for the entire program, because doing it later\n+        // would put the goog.require()s in the wrong place.\n+        if (astValidationEnabled) {\n+          // At this point, externsRoot and jsRoot contain the entire\n+          // program, so it's safe to check them for errors.\n+          // This check must happen BEFORE the Normalize pass, because\n+          // Normalize changes some nodes (e.g. nameless function declarations\n+          // become nameless function expressions).\n+          sanityCheck();\n+        }\n+        addImplicitExterns();\n+        addCustomPassesBeforeNormalizing();\n+        if (options.devMode == DevMode.OFF) {\n+          new RemoveScriptNodes().setCompiler(this).process(externsRoot, jsRoot);\n+        }\n+        applyCustomPassesAfterNormalization();\n+      }\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they\n           // are not flagged even if they are dropped from the process.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}