{
    "patch": "    public double solve(final UnivariateRealFunction f, double min, double max, final double startValue)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (f == null) throw new NullArgumentException(LocalizedFormats.FUNCTION);\n        if (min >= max) {\n            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n                                                min, max, false);\n        }\n        final double absoluteAccuracy = getAbsoluteAccuracy();\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n        final double lowerBound = min;\n        final double upperBound = max;\n        final double start = startValue;\n        verifySequence(min, start, max);\n        int i = 0;\n        while (true) {\n            final double oldx = start;\n            final double fmin = f.value(lowerBound);\n            final double fmax = f.value(upperBound);\n            final double fstart = f.value(start);\n            final double width = FastMath.max(FastMath.abs(upperBound - start),\n                                               FastMath.abs(start - lowerBound));\n            final double dtest = FastMath.max(functionValueAccuracy,\n                                              absoluteAccuracy * FastMath.max(FastMath.abs(fmax),\n                                                                              FastMath.abs(fmin)));\n            if (i++ > maximalIterationCount) {\n                throw new MaxIterationsExceededException(maximalIterationCount);\n            }\n            if (FastMath.abs(fstart) <= functionValueAccuracy) {\n                return start;\n            }\n            if (FastMath.abs(oldx - start) < absoluteAccuracy) {\n                return start;\n            }\n            if (((fstart > 0) && (fmin > 0)) || ((fstart < 0) && (fmin < 0))) {\n                start = ((start * fmin) - (lowerBound * fstart)) / (fmin - fstart);\n            } else if (((fstart > 0) && (fmax > 0)) || ((fstart < 0) && (fmax < 0))) {\n                start = ((start * fmax) - (upperBound * fstart)) / (fmax - fstart);\n            } else {\n                start = (lowerBound + upperBound) / 2;\n            }\n            if (FastMath.abs(start - oldx) < dtest) {\n                final double ftest = f.value(start);\n                if (FastMath.abs(ftest) <= functionValueAccuracy) {\n                    return start;\n                } else if (ftest > 0) {\n                    if (fstart < 0) {\n                        upperBound = start;\n                        fmax = fstart;\n                    } else {\n                        lowerBound = start;\n                        fmin = fstart;\n                    }\n                } else {\n                    if (fstart < 0) {\n                        lowerBound = start;\n                        fmin = fstart;\n                    } else {\n                        upperBound = start;\n                        fmax = fstart;\n                    }\n                }\n                width = FastMath.max(FastMath.abs(upperBound - start),\n                                       FastMath.abs(start - lowerBound));\n                if (width <= absoluteAccuracy) {\n                    return start;\n                }\n            }\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..aa01071d8 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -67,9 +67,74 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+    public double solve(final UnivariateRealFunction f, double min, double max, final double startValue)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        if (f == null) throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        if (min >= max) {\n+            throw new NumberIsTooLargeException(LocalizedFormats.ENDPOINTS_NOT_AN_INTERVAL,\n+                                                min, max, false);\n+        }\n+        final double absoluteAccuracy = getAbsoluteAccuracy();\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+        final double lowerBound = min;\n+        final double upperBound = max;\n+        final double start = startValue;\n+        verifySequence(min, start, max);\n+        int i = 0;\n+        while (true) {\n+            final double oldx = start;\n+            final double fmin = f.value(lowerBound);\n+            final double fmax = f.value(upperBound);\n+            final double fstart = f.value(start);\n+            final double width = FastMath.max(FastMath.abs(upperBound - start),\n+                                               FastMath.abs(start - lowerBound));\n+            final double dtest = FastMath.max(functionValueAccuracy,\n+                                              absoluteAccuracy * FastMath.max(FastMath.abs(fmax),\n+                                                                              FastMath.abs(fmin)));\n+            if (i++ > maximalIterationCount) {\n+                throw new MaxIterationsExceededException(maximalIterationCount);\n+            }\n+            if (FastMath.abs(fstart) <= functionValueAccuracy) {\n+                return start;\n+            }\n+            if (FastMath.abs(oldx - start) < absoluteAccuracy) {\n+                return start;\n+            }\n+            if (((fstart > 0) && (fmin > 0)) || ((fstart < 0) && (fmin < 0))) {\n+                start = ((start * fmin) - (lowerBound * fstart)) / (fmin - fstart);\n+            } else if (((fstart > 0) && (fmax > 0)) || ((fstart < 0) && (fmax < 0))) {\n+                start = ((start * fmax) - (upperBound * fstart)) / (fmax - fstart);\n+            } else {\n+                start = (lowerBound + upperBound) / 2;\n+            }\n+            if (FastMath.abs(start - oldx) < dtest) {\n+                final double ftest = f.value(start);\n+                if (FastMath.abs(ftest) <= functionValueAccuracy) {\n+                    return start;\n+                } else if (ftest > 0) {\n+                    if (fstart < 0) {\n+                        upperBound = start;\n+                        fmax = fstart;\n+                    } else {\n+                        lowerBound = start;\n+                        fmin = fstart;\n+                    }\n+                } else {\n+                    if (fstart < 0) {\n+                        lowerBound = start;\n+                        fmin = fstart;\n+                    } else {\n+                        upperBound = start;\n+                        fmax = fstart;\n+                    }\n+                }\n+                width = FastMath.max(FastMath.abs(upperBound - start),\n+                                       FastMath.abs(start - lowerBound));\n+                if (width <= absoluteAccuracy) {\n+                    return start;\n+                }\n+            }\n+        }\n     }\n \n     /** {@inheritDoc} */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}