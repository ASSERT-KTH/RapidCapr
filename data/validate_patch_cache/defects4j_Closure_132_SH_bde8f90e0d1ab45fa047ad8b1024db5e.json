{
    "patch": "/**\n * Tries to minimize an \"IF\" statement, if possible.\n *\n * @param n An IF statement.\n * @return Node The replacement node, or the original node if no change was made.\n */\nprivate Node tryMinimizeIf(Node n) {\n  Node parent = n.getParent();\n  Node cond = n.getFirstChild();\n  Node thenBranch = cond.getNext();\n  Node elseBranch = thenBranch.getNext();\n\n  // if it has an ELSE and there are no further nodes, then remove the ELSE\n  if (elseBranch == null) {\n    if (isFoldableExpressBlock(thenBranch)) {\n      // if(x)foo(); -> x&&foo();\n      if (cond.isAnd()) {\n        Node expr = getBlockExpression(thenBranch);\n        Node newExpr = IR.exprResult(expr.removeFirstChild()).srcref(n);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n\n      // if(!x)bar(); -> x||bar();\n      } else if (cond.isNot() && isPropertyAssignmentInExpression(getBlockExpression(thenBranch))) {\n        Node or = IR.or(cond.removeFirstChild(), getBlockExpression(thenBranch).removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(or);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n\n      // if(x)foo(); -> x&&foo();\n      } else if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                 isLowerPrecedenceInExpression(getBlockExpression(thenBranch).getFirstChild(), AND_PRECEDENCE)) {\n        Node and = IR.and(cond.removeFirstChild(), getBlockExpression(thenBranch).removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n\n      // if(x)bar(); -> bar(); and 'x' has no side effect\n      } else if (!isJumpStatement(thenBranch) && isExpressionResultStatement(thenBranch) && !doesNodeAffectControlFlow(cond) && !mayHaveSideEffects(cond)) {\n        Node expr = getBlockExpression(thenBranch);\n        Node newExpr = IR.exprResult(expr.removeFirstChild()).srcref(n);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n        return newExpr;\n      }\n    }\n    return n;\n  }\n\n  // if(x)return 1;else return 2; -> return x?1:2;\n  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n    Node thenExpr = getBlockReturnExpression(thenBranch);\n    Node elseExpr = getBlockReturnExpression(elseBranch);\n    Node hookNode = IR.hook(cond, thenExpr.cloneTree(), elseExpr.cloneTree()).srcref(n);\n    Node newExpr = IR.returnNode(hookNode).srcref(n);\n    parent.replaceChild(n, newExpr);\n    reportCodeChange();\n    return newExpr;\n  }\n\n  // if(!x)y=1;else var y=2  ->  var y=x?2:1\n  // if(x)var y=1;else y=2  ->  var y=x?1:2\n  if (isVarBlock(thenBranch) ^ isVarBlock(elseBranch)) {\n    Node exprBlock = isVarBlock(thenBranch) ? elseBranch : thenBranch;\n    Node declBlock = isVarBlock(thenBranch) ? thenBranch : elseBranch;\n    if (isFoldableExpressBlock(exprBlock) && getBlockExpression(exprBlock).isAssign()) {\n      Node assign = getBlockExpression(exprBlock);\n      Node newExpr = IR.var(\n          assign.removeFirstChild().detachFromParent(),\n          IR.hook(cond, assign.removeFirstChild(), assign.getLastChild())\n              .srcref(n)).srcref(n);\n      declBlock.replaceWith(newExpr);\n      reportCodeChange();\n      return newExpr;\n    }\n  } else if (isFoldableExpressBlock(thenBranch) && isFoldableExpressBlock(elseBranch)) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (NodeUtil.isAssignmentOp(thenOp) &&\n        areNodesEqualForInlining(thenOp.getFirstChild(), elseOp.getFirstChild()) &&\n        !mayEffectMutableState(thenOp.getFirstChild())) {\n      boolean isConst = NodeUtil.isImmutableValue(thenOp.getLastChild());\n      Node hookNode = IR.hook(cond, thenOp.removeLastChild(), elseOp.getLastChild()).srcref(n);\n      Node assignNode = IR.assign(thenOp.getFirstChild().detachFromParent(), hookNode)\n                            .srcref(thenOp);\n      assignNode.putBooleanProp(Node.IS_CONSTANT_NAME, isConst);\n      Node newExpr = NodeUtil.newExpr(assignNode);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    } else if (thenOp.getType() == elseOp.getType() && !mayHaveSideEffects(elseOp)) {\n      Node expr = thenOp.cloneNode();\n      expr.addChildrenToBack(IR.hook(cond, thenOp.removeFirstChild(), elseOp.removeFirstChild()).srcref(n));\n      Node newExpr = NodeUtil.newExpr(expr);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    }\n  }\n\n  // if(x)y=1;else y=2; -> y=x?1:2;\n  if (isAssignmentBlock(thenBranch) && isAssignmentBlock(elseBranch)) {\n    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n    if (areNodesEqualForInlining(thenAssign.getFirstChild(), elseAssign.getFirstChild()) &&\n        !mayEffectMutableState(thenAssign.getFirstChild())) {\n      Node newExpr = IR.exprResult(IR.assign(\n          thenAssign.getFirstChild().detachFromParent(),\n          IR.hook(cond, thenAssign.getLastChild().detachFromParent(), elseAssign.getLastChild().detachFromParent())\n              .srcref(n)).srcref(n)).srcref(n);\n      parent.replaceChild(n, newExpr);\n      reportCodeChange();\n      return newExpr;\n    }\n  }\n\n  return n;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..80aa8be7 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,127 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+/**\n+ * Tries to minimize an \"IF\" statement, if possible.\n+ *\n+ * @param n An IF statement.\n+ * @return Node The replacement node, or the original node if no change was made.\n+ */\n+private Node tryMinimizeIf(Node n) {\n+  Node parent = n.getParent();\n+  Node cond = n.getFirstChild();\n+  Node thenBranch = cond.getNext();\n+  Node elseBranch = thenBranch.getNext();\n+\n+  // if it has an ELSE and there are no further nodes, then remove the ELSE\n+  if (elseBranch == null) {\n+    if (isFoldableExpressBlock(thenBranch)) {\n+      // if(x)foo(); -> x&&foo();\n+      if (cond.isAnd()) {\n+        Node expr = getBlockExpression(thenBranch);\n+        Node newExpr = IR.exprResult(expr.removeFirstChild()).srcref(n);\n+        parent.replaceChild(n, newExpr);\n+        reportCodeChange();\n+        return newExpr;\n+\n+      // if(!x)bar(); -> x||bar();\n+      } else if (cond.isNot() && isPropertyAssignmentInExpression(getBlockExpression(thenBranch))) {\n+        Node or = IR.or(cond.removeFirstChild(), getBlockExpression(thenBranch).removeFirstChild()).srcref(n);\n+        Node newExpr = NodeUtil.newExpr(or);\n+        parent.replaceChild(n, newExpr);\n+        reportCodeChange();\n+        return newExpr;\n+\n+      // if(x)foo(); -> x&&foo();\n+      } else if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n+                 isLowerPrecedenceInExpression(getBlockExpression(thenBranch).getFirstChild(), AND_PRECEDENCE)) {\n+        Node and = IR.and(cond.removeFirstChild(), getBlockExpression(thenBranch).removeFirstChild()).srcref(n);\n+        Node newExpr = NodeUtil.newExpr(and);\n+        parent.replaceChild(n, newExpr);\n+        reportCodeChange();\n+        return newExpr;\n+\n+      // if(x)bar(); -> bar(); and 'x' has no side effect\n+      } else if (!isJumpStatement(thenBranch) && isExpressionResultStatement(thenBranch) && !doesNodeAffectControlFlow(cond) && !mayHaveSideEffects(cond)) {\n+        Node expr = getBlockExpression(thenBranch);\n+        Node newExpr = IR.exprResult(expr.removeFirstChild()).srcref(n);\n+        parent.replaceChild(n, newExpr);\n+        reportCodeChange();\n+        return newExpr;\n+      }\n+    }\n+    return n;\n+  }\n+\n+  // if(x)return 1;else return 2; -> return x?1:2;\n+  if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+    Node thenExpr = getBlockReturnExpression(thenBranch);\n+    Node elseExpr = getBlockReturnExpression(elseBranch);\n+    Node hookNode = IR.hook(cond, thenExpr.cloneTree(), elseExpr.cloneTree()).srcref(n);\n+    Node newExpr = IR.returnNode(hookNode).srcref(n);\n+    parent.replaceChild(n, newExpr);\n+    reportCodeChange();\n+    return newExpr;\n+  }\n+\n+  // if(!x)y=1;else var y=2  ->  var y=x?2:1\n+  // if(x)var y=1;else y=2  ->  var y=x?1:2\n+  if (isVarBlock(thenBranch) ^ isVarBlock(elseBranch)) {\n+    Node exprBlock = isVarBlock(thenBranch) ? elseBranch : thenBranch;\n+    Node declBlock = isVarBlock(thenBranch) ? thenBranch : elseBranch;\n+    if (isFoldableExpressBlock(exprBlock) && getBlockExpression(exprBlock).isAssign()) {\n+      Node assign = getBlockExpression(exprBlock);\n+      Node newExpr = IR.var(\n+          assign.removeFirstChild().detachFromParent(),\n+          IR.hook(cond, assign.removeFirstChild(), assign.getLastChild())\n+              .srcref(n)).srcref(n);\n+      declBlock.replaceWith(newExpr);\n+      reportCodeChange();\n+      return newExpr;\n+    }\n+  } else if (isFoldableExpressBlock(thenBranch) && isFoldableExpressBlock(elseBranch)) {\n+    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+    if (NodeUtil.isAssignmentOp(thenOp) &&\n+        areNodesEqualForInlining(thenOp.getFirstChild(), elseOp.getFirstChild()) &&\n+        !mayEffectMutableState(thenOp.getFirstChild())) {\n+      boolean isConst = NodeUtil.isImmutableValue(thenOp.getLastChild());\n+      Node hookNode = IR.hook(cond, thenOp.removeLastChild(), elseOp.getLastChild()).srcref(n);\n+      Node assignNode = IR.assign(thenOp.getFirstChild().detachFromParent(), hookNode)\n+                            .srcref(thenOp);\n+      assignNode.putBooleanProp(Node.IS_CONSTANT_NAME, isConst);\n+      Node newExpr = NodeUtil.newExpr(assignNode);\n+      parent.replaceChild(n, newExpr);\n+      reportCodeChange();\n+      return newExpr;\n+    } else if (thenOp.getType() == elseOp.getType() && !mayHaveSideEffects(elseOp)) {\n+      Node expr = thenOp.cloneNode();\n+      expr.addChildrenToBack(IR.hook(cond, thenOp.removeFirstChild(), elseOp.removeFirstChild()).srcref(n));\n+      Node newExpr = NodeUtil.newExpr(expr);\n+      parent.replaceChild(n, newExpr);\n+      reportCodeChange();\n+      return newExpr;\n+    }\n+  }\n+\n+  // if(x)y=1;else y=2; -> y=x?1:2;\n+  if (isAssignmentBlock(thenBranch) && isAssignmentBlock(elseBranch)) {\n+    Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n+    Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n+    if (areNodesEqualForInlining(thenAssign.getFirstChild(), elseAssign.getFirstChild()) &&\n+        !mayEffectMutableState(thenAssign.getFirstChild())) {\n+      Node newExpr = IR.exprResult(IR.assign(\n+          thenAssign.getFirstChild().detachFromParent(),\n+          IR.hook(cond, thenAssign.getLastChild().detachFromParent(), elseAssign.getLastChild().detachFromParent())\n+              .srcref(n)).srcref(n)).srcref(n);\n+      parent.replaceChild(n, newExpr);\n+      reportCodeChange();\n+      return newExpr;\n+    }\n+  }\n+\n+  return n;\n+}\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}