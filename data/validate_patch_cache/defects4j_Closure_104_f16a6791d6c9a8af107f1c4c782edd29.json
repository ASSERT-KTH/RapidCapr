{
    "patch": "  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  @Override\n  public JSType greatestSubtype(JSType that) {\n    if (this.equals(that)) {\n      return this;\n    }\n    if (this.isUnknownType() || this.isAllType()) {\n      return that;\n    }\n    if (that.isUnknownType() || that.isAllType() || that.isNoType()) {\n      return this;\n    }\n    if (this.isNoObjectType() || that.isNoObjectType()) {\n      return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n\n    // Union type\n    if (this.isUnionType()) {\n      Builder builder = new Builder();\n      for (JSType alternate : ((UnionType) this).getAlternates()) {\n        JSType greatestSubtype = alternate.greatestSubtype(that);\n        if (greatestSubtype != null) {\n          builder.addAlternate(greatestSubtype);\n        }\n      }\n      JSType result = builder.build();\n      if (result.isUnknownType()) {\n        return null;\n      }\n      if (((UnionType) result).getAlternates().size() == 1) {\n        return ((UnionType) result).getAlternates().iterator().next();\n      }\n      return result;\n\n    // Non union type\n    } else {\n      if (that.isUnionType()) {\n        return that.greatestSubtype(this);\n      }\n      if (this.isNumberValueType() && that.isNumberValueType()) {\n        if (this.isSubtype(that)) {\n          return this;\n        }\n        if (that.isSubtype(this)) {\n          return that;\n        }\n        if (this.equals(that)) {\n          return this;\n        }\n        return getNativeType(JSTypeNative.NUMBER_TYPE);\n      }\n      if (this.isBooleanValueType() && that.isBooleanValueType()) {\n        if (this.isSubtype(that)) {\n          return this;\n        }\n        if (that.isSubtype(this)) {\n          return that;\n        }\n        if (this.equals(that)) {\n          return this;\n        }\n        return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n      }\n      if (this.isStringValueType() && that.isStringValueType()) {\n        if (this.isSubtype(that)) {\n          return this;\n        }\n        if (that.isSubtype(this)) {\n          return that;\n        }\n        if (this.equals(that)) {\n          return this;\n        }\n        return getNativeType(JSTypeNative.STRING_TYPE);\n      }\n      if (this.isEnumElementType() && that.isEnumElementType()\n          && this.getEnumeratedType().equals(that.getEnumeratedType())) {\n        return this;\n      }\n      if (this.isNoObjectType() && that.isNoObjectType()) {\n        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n      }\n      if (this.isFunctionType() && that.isFunctionType()) {\n        ObjectType objType = getNativeObjectType(OBJECT_TYPE);\n        ObjectType greatestObj = objType.greatestSubtype(that.toObjectType());\n        if (greatestObj != null) {\n          FunctionType f1 = this.toMaybeFunctionType();\n          FunctionType f2 = that.toMaybeFunctionType();\n          JSType returnType = f1.getReturnType().greatestSubtype(f2.getReturnType());\n          List<JSType> parameters = new ArrayList<>();\n          for (int i = 0; i < Math.min(f1.getParameterTypes().size(), f2.getParameterTypes().size()); i++) {\n            JSType p1 = f1.getParameterType(i);\n            JSType p2 = f2.getParameterType(i);\n            JSType subtype = p1.greatestSubtype(p2);\n            if (subtype == null) {\n              return null;\n            }\n            parameters.add(subtype);\n          }\n          ObjectType obj = greatestObj;\n          FunctionType.Builder builder = FunctionType.builder().setReturnType(returnType);\n          for (JSType parameter : parameters) {\n            builder.addParameter(parameter);\n          }\n          for (Slot slot : obj.getSlots()) {\n            if (!slot.isBuiltinObjectSlot() || !builder.canAddSlot(slot.getName(), slot.getType())) {\n              continue;\n            }\n            JSType slotType = slot.getType().greatestSubtype(f1.getThisType().evaluate(null));\n            if (slotType == null) {\n              return null;\n            }\n            builder.addReceiverType(slotType);\n          }\n          return builder.buildDeclaration();\n        }\n      }\n      if (this.isObjectType() && that.isObjectType()) {\n        ObjectType thisObjectType = this.toObjectType();\n        ObjectType thatObjectType = that.toObjectType();\n        ObjectType greatestObj = thisObjectType.greatestSubtype(thatObjectType);\n        if (greatestObj != null) {\n          ObjectType.Builder builder = ObjectType.builder();\n          for (Slot slot : greatestObj.getSlots()) {\n            if (!slot.isBuiltinObjectSlot() || !builder.canAddSlot(slot.getName(), slot.getType())) {\n              continue;\n            }\n            JSType type1 = thisObjectType.getSlot(slot.getName()).getType();\n            JSType type2 = thatObjectType.getSlot(slot.getName()).getType();\n            JSType subtype = type1.greatestSubtype(type2);\n            if (subtype == null) {\n              return null;\n            }\n            builder.addProperty(slot.getName(), subtype, slot.getJSDocInfo());\n          }\n          if (builder.hasBrand()) {\n            greatestObj = builder.buildWithBrand();\n          } else {\n            greatestObj = builder.build();\n          }\n        }\n        if (greatestObj == null) {\n          return null;\n        }\n        if (greatestObj.isEmptyType()) {\n          return getNativeType(JSTypeNative.NO_TYPE);\n        }\n        return greatestObj;\n      }\n      return null;\n    }\n  }\n\n  /**\n   * Two union types are equal if they have the same number of alternates\n   * and all alternates are equal.\n   */\n  @Override\n  public boolean equals(Object object) {\n    if (object instanceof UnionType) {\n      UnionType that = (UnionType) object;\n      return alternates.equals(that.alternates);\n    } else {\n      return false;\n    }\n  }\n\n  @Override\n  public int hashCode() {\n    return alternates.hashCode();\n  }\n\n  @Override\n  public boolean isUnionType() {\n    return true;\n  }\n\n  @Override\n  public boolean isObject() {\n    for (JSType alternate : alternates) {\n      if (!alternate.isObject()) {\n        return false;\n      }\n    }\n    return true;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex a9c9a0ae..13337d64 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -279,21 +279,165 @@ public class UnionType extends JSType {\n     }\n \n     if (that instanceof UnionType) {\n-      for (JSType otherAlternate : ((UnionType) that).alternates) {\n-        if (otherAlternate.isSubtype(this)) {\n-          builder.addAlternate(otherAlternate);\n-        }\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n       }\n-    } else if (that.isSubtype(this)) {\n-      builder.addAlternate(that);\n     }\n-    JSType result = builder.build();\n-    if (result != null) {\n-      return result;\n-    } else if (this.isObject() && that.isObject()) {\n+    return false;\n+  }\n+\n+  @Override\n+  public JSType greatestSubtype(JSType that) {\n+    if (this.equals(that)) {\n+      return this;\n+    }\n+    if (this.isUnknownType() || this.isAllType()) {\n+      return that;\n+    }\n+    if (that.isUnknownType() || that.isAllType() || that.isNoType()) {\n+      return this;\n+    }\n+    if (this.isNoObjectType() || that.isNoObjectType()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+    }\n+\n+    // Union type\n+    if (this.isUnionType()) {\n+      Builder builder = new Builder();\n+      for (JSType alternate : ((UnionType) this).getAlternates()) {\n+        JSType greatestSubtype = alternate.greatestSubtype(that);\n+        if (greatestSubtype != null) {\n+          builder.addAlternate(greatestSubtype);\n+        }\n+      }\n+      JSType result = builder.build();\n+      if (result.isUnknownType()) {\n+        return null;\n+      }\n+      if (((UnionType) result).getAlternates().size() == 1) {\n+        return ((UnionType) result).getAlternates().iterator().next();\n+      }\n+      return result;\n+\n+    // Non union type\n     } else {\n-      return getNativeType(JSTypeNative.NO_TYPE);\n+      if (that.isUnionType()) {\n+        return that.greatestSubtype(this);\n+      }\n+      if (this.isNumberValueType() && that.isNumberValueType()) {\n+        if (this.isSubtype(that)) {\n+          return this;\n+        }\n+        if (that.isSubtype(this)) {\n+          return that;\n+        }\n+        if (this.equals(that)) {\n+          return this;\n+        }\n+        return getNativeType(JSTypeNative.NUMBER_TYPE);\n+      }\n+      if (this.isBooleanValueType() && that.isBooleanValueType()) {\n+        if (this.isSubtype(that)) {\n+          return this;\n+        }\n+        if (that.isSubtype(this)) {\n+          return that;\n+        }\n+        if (this.equals(that)) {\n+          return this;\n+        }\n+        return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n+      }\n+      if (this.isStringValueType() && that.isStringValueType()) {\n+        if (this.isSubtype(that)) {\n+          return this;\n+        }\n+        if (that.isSubtype(this)) {\n+          return that;\n+        }\n+        if (this.equals(that)) {\n+          return this;\n+        }\n+        return getNativeType(JSTypeNative.STRING_TYPE);\n+      }\n+      if (this.isEnumElementType() && that.isEnumElementType()\n+          && this.getEnumeratedType().equals(that.getEnumeratedType())) {\n+        return this;\n+      }\n+      if (this.isNoObjectType() && that.isNoObjectType()) {\n+        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+      }\n+      if (this.isFunctionType() && that.isFunctionType()) {\n+        ObjectType objType = getNativeObjectType(OBJECT_TYPE);\n+        ObjectType greatestObj = objType.greatestSubtype(that.toObjectType());\n+        if (greatestObj != null) {\n+          FunctionType f1 = this.toMaybeFunctionType();\n+          FunctionType f2 = that.toMaybeFunctionType();\n+          JSType returnType = f1.getReturnType().greatestSubtype(f2.getReturnType());\n+          List<JSType> parameters = new ArrayList<>();\n+          for (int i = 0; i < Math.min(f1.getParameterTypes().size(), f2.getParameterTypes().size()); i++) {\n+            JSType p1 = f1.getParameterType(i);\n+            JSType p2 = f2.getParameterType(i);\n+            JSType subtype = p1.greatestSubtype(p2);\n+            if (subtype == null) {\n+              return null;\n+            }\n+            parameters.add(subtype);\n+          }\n+          ObjectType obj = greatestObj;\n+          FunctionType.Builder builder = FunctionType.builder().setReturnType(returnType);\n+          for (JSType parameter : parameters) {\n+            builder.addParameter(parameter);\n+          }\n+          for (Slot slot : obj.getSlots()) {\n+            if (!slot.isBuiltinObjectSlot() || !builder.canAddSlot(slot.getName(), slot.getType())) {\n+              continue;\n+            }\n+            JSType slotType = slot.getType().greatestSubtype(f1.getThisType().evaluate(null));\n+            if (slotType == null) {\n+              return null;\n+            }\n+            builder.addReceiverType(slotType);\n+          }\n+          return builder.buildDeclaration();\n+        }\n+      }\n+      if (this.isObjectType() && that.isObjectType()) {\n+        ObjectType thisObjectType = this.toObjectType();\n+        ObjectType thatObjectType = that.toObjectType();\n+        ObjectType greatestObj = thisObjectType.greatestSubtype(thatObjectType);\n+        if (greatestObj != null) {\n+          ObjectType.Builder builder = ObjectType.builder();\n+          for (Slot slot : greatestObj.getSlots()) {\n+            if (!slot.isBuiltinObjectSlot() || !builder.canAddSlot(slot.getName(), slot.getType())) {\n+              continue;\n+            }\n+            JSType type1 = thisObjectType.getSlot(slot.getName()).getType();\n+            JSType type2 = thatObjectType.getSlot(slot.getName()).getType();\n+            JSType subtype = type1.greatestSubtype(type2);\n+            if (subtype == null) {\n+              return null;\n+            }\n+            builder.addProperty(slot.getName(), subtype, slot.getJSDocInfo());\n+          }\n+          if (builder.hasBrand()) {\n+            greatestObj = builder.buildWithBrand();\n+          } else {\n+            greatestObj = builder.build();\n+          }\n+        }\n+        if (greatestObj == null) {\n+          return null;\n+        }\n+        if (greatestObj.isEmptyType()) {\n+          return getNativeType(JSTypeNative.NO_TYPE);\n+        }\n+        return greatestObj;\n+      }\n+      return null;\n     }\n   }\n \n@@ -330,6 +474,9 @@ public class UnionType extends JSType {\n     }\n     return true;\n   }\n+    }\n+    return true;\n+  }\n \n   /**\n    * A {@link UnionType} contains a given type (alternate) iff the member",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}