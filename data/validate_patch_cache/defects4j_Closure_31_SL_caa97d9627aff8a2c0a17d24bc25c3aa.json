{
    "patch": "// Check if the sources need to be re-ordered.\nif (options.dependencyOptions.needsManagement() && options.closurePass) {\n  inputs = sortInputs(inputs, options.dependencyOptions);\n}\nfor (CompilerInput input : inputs) {\n  Node n = input.getAstRoot(this);\n  if (n == null) {\n    continue;\n  }\n  // Annotate the nodes in the tree with information from the input file.\n  if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\n    SourceInformationAnnotator annotator = new SourceInformationAnnotator(\n        input.getName(), options.devMode != DevMode.OFF);\n    NodeTraversal.traverse(this, n, annotator);\n  }\n  if (isIdeMode) {\n    // Verify the correctness of the AST before proceeding in IDE mode.\n    sanityCheck();\n  }\n  if (options.dependencyOptions.needsManagement() && !options.closurePass) {\n    input.setAstRoot(replaceRequiresWithImports(input));\n    n = input.getAstRoot(this);\n  }\n  jsRoot.addChildToBack(n);\n}\nif (options.dependencyOptions.needsManagement() && !options.closurePass) {\n  addImplicitNamespaces(options.dependencyOptions.getEntryPoints());\n  addRequireTypeDeclarations();\n  processClosurePrimitives(jsRoot, externsRoot);\n  NodeTraversal.traverse(\n      this, jsRoot, new ProcessCommonJSModules(this, options.moduleResolutionMode));\n}\nif (options.googInherits && !inputs.isEmpty()) {\n  Node last = inputs.get(inputs.size() - 1).getAstRoot(this);\n  if (!NodeUtil.isCallTo(last.getFirstChild(), \"goog.inherits\")) {\n    report(JSError.make(MISSING_GOOG_INHERITS_ERROR, \"The last input file must have a call to goog.inherits()\"));\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..a8ab7c7d 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1282,7 +1282,44 @@ public class Compiler extends AbstractCompiler {\n \n       // Check if the sources need to be re-ordered.\n       if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n+// Check if the sources need to be re-ordered.\n+if (options.dependencyOptions.needsManagement() && options.closurePass) {\n+  inputs = sortInputs(inputs, options.dependencyOptions);\n+}\n+for (CompilerInput input : inputs) {\n+  Node n = input.getAstRoot(this);\n+  if (n == null) {\n+    continue;\n+  }\n+  // Annotate the nodes in the tree with information from the input file.\n+  if (options.sourceMapOutputPath != null || options.nameReferenceReportPath != null) {\n+    SourceInformationAnnotator annotator = new SourceInformationAnnotator(\n+        input.getName(), options.devMode != DevMode.OFF);\n+    NodeTraversal.traverse(this, n, annotator);\n+  }\n+  if (isIdeMode) {\n+    // Verify the correctness of the AST before proceeding in IDE mode.\n+    sanityCheck();\n+  }\n+  if (options.dependencyOptions.needsManagement() && !options.closurePass) {\n+    input.setAstRoot(replaceRequiresWithImports(input));\n+    n = input.getAstRoot(this);\n+  }\n+  jsRoot.addChildToBack(n);\n+}\n+if (options.dependencyOptions.needsManagement() && !options.closurePass) {\n+  addImplicitNamespaces(options.dependencyOptions.getEntryPoints());\n+  addRequireTypeDeclarations();\n+  processClosurePrimitives(jsRoot, externsRoot);\n+  NodeTraversal.traverse(\n+      this, jsRoot, new ProcessCommonJSModules(this, options.moduleResolutionMode));\n+}\n+if (options.googInherits && !inputs.isEmpty()) {\n+  Node last = inputs.get(inputs.size() - 1).getAstRoot(this);\n+  if (!NodeUtil.isCallTo(last.getFirstChild(), \"goog.inherits\")) {\n+    report(JSError.make(MISSING_GOOG_INHERITS_ERROR, \"The last input file must have a call to goog.inherits()\"));\n+  }\n+}\n           options.closurePass) {\n         for (CompilerInput input : inputs) {\n           // Forward-declare all the provided types, so that they",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}