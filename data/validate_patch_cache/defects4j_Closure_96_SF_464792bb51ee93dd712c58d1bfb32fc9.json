{
    "patch": " private void visitParameterList(NodeTraversal t, Node call,\n      FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int argumentCount = 0;\n    int ordinal = -1;\n  \n    while (parameters.hasNext()) {\n      Node parameterNode = parameters.next();\n      if (parameterNode.isRest()) {\n        if (parameters.hasNext()) {\n          throw new IllegalStateException(\"Rest parameter cannot be followed by other named parameters\");\n        }\n        TypeInfo typeInfo = functionType.getRestFormalsType();\n        parameterNode.replaceWith(new Node(Token.PARAM_LIST, parameterNode).srcref(parameterNode));\n        parameterNode.addChildrenToFront(IR.name(\"\").setJSType(typeInfo.getType()).srcref(call));\n        break;\n      }\n      \n      ordinal++;\n      argumentCount++;\n\n      if (!arguments.hasNext() && !Validator.isOptionalParameter(parameterNode)) {\n        reportMissingArgument(t, call, functionType, argumentCount, ordinal, parameterNode);\n        continue;\n      }\n\n      Node argumentNode;\n      if (arguments.hasNext()) {\n        argumentNode = arguments.next();\n      } else {\n        argumentNode = new Node(Token.DEFAULT_VALUE,\n            parameterNode.cloneNode(),\n            IR.number(0));\n        argumentNode.setJSType(getNativeType(VOID_TYPE));\n        t.reportCodeChange();\n      }\n      \n      if (argumentNode.isSpread()) {\n        validateSpreadArgument(t, call, functionType, argumentNode, argumentCount, ordinal);\n        \n        TypeInfo typeInfo = TypeInfo.splitAndGetRestFormals(argumentNode.getJSType());\n        parameterNode.replaceWith(typeInfo.getFormalParam());\n        parameterNode = getNextParameter(parameters);\n        while (parameters.hasNext()) {\n          parameterNode.detach();\n          parameterNode = getNextParameter(parameters);\n        }\n        parameterNode.detach();\n        parameterNode = typeInfo.getRestFormalsNode();\n        if (parameterNode == null) {\n          parameterNode = IR.empty().setJSType(getNativeType(NULL_TYPE));\n        }\n        call.addChildAfter(parameterNode, argumentNode);\n        t.reportCodeChange();\n        break;\n      } else {\n        validateNonSpreadArgument(t, call, functionType,\n            argumentNode, argumentCount, ordinal,\n            parameterNode);\n      }\n    }\n\n    int numArgs = argumentCount + (functionType.hasRestFormals() ? 1 : 0);\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n    if (minArgs > numArgs || maxArgs < numArgs) {\n      reportWrongArgumentCount(t, call, functionType,\n              validator.getReadableJSTypeName(call.getFirstChild(), false),\n              numArgs, minArgs, maxArgs);\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 8077e0d8..9da2e8ad 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1396,36 +1396,78 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n   /**\n    * Visits the parameters of a CALL or a NEW node.\n    */\n-  private void visitParameterList(NodeTraversal t, Node call,\n+ private void visitParameterList(NodeTraversal t, Node call,\n       FunctionType functionType) {\n     Iterator<Node> arguments = call.children().iterator();\n     arguments.next(); // skip the function name\n \n     Iterator<Node> parameters = functionType.getParameters().iterator();\n-    int ordinal = 0;\n-    Node parameter = null;\n-    Node argument = null;\n-    while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n-      // If there are no parameters left in the list, then the while loop\n-      // above implies that this must be a var_args function.\n-        parameter = parameters.next();\n-      argument = arguments.next();\n+    int argumentCount = 0;\n+    int ordinal = -1;\n+  \n+    while (parameters.hasNext()) {\n+      Node parameterNode = parameters.next();\n+      if (parameterNode.isRest()) {\n+        if (parameters.hasNext()) {\n+          throw new IllegalStateException(\"Rest parameter cannot be followed by other named parameters\");\n+        }\n+        TypeInfo typeInfo = functionType.getRestFormalsType();\n+        parameterNode.replaceWith(new Node(Token.PARAM_LIST, parameterNode).srcref(parameterNode));\n+        parameterNode.addChildrenToFront(IR.name(\"\").setJSType(typeInfo.getType()).srcref(call));\n+        break;\n+      }\n+      \n       ordinal++;\n+      argumentCount++;\n \n-      validator.expectArgumentMatchesParameter(t, argument,\n-          getJSType(argument), getJSType(parameter), call, ordinal);\n+      if (!arguments.hasNext() && !Validator.isOptionalParameter(parameterNode)) {\n+        reportMissingArgument(t, call, functionType, argumentCount, ordinal, parameterNode);\n+        continue;\n+      }\n+\n+      Node argumentNode;\n+      if (arguments.hasNext()) {\n+        argumentNode = arguments.next();\n+      } else {\n+        argumentNode = new Node(Token.DEFAULT_VALUE,\n+            parameterNode.cloneNode(),\n+            IR.number(0));\n+        argumentNode.setJSType(getNativeType(VOID_TYPE));\n+        t.reportCodeChange();\n+      }\n+      \n+      if (argumentNode.isSpread()) {\n+        validateSpreadArgument(t, call, functionType, argumentNode, argumentCount, ordinal);\n+        \n+        TypeInfo typeInfo = TypeInfo.splitAndGetRestFormals(argumentNode.getJSType());\n+        parameterNode.replaceWith(typeInfo.getFormalParam());\n+        parameterNode = getNextParameter(parameters);\n+        while (parameters.hasNext()) {\n+          parameterNode.detach();\n+          parameterNode = getNextParameter(parameters);\n+        }\n+        parameterNode.detach();\n+        parameterNode = typeInfo.getRestFormalsNode();\n+        if (parameterNode == null) {\n+          parameterNode = IR.empty().setJSType(getNativeType(NULL_TYPE));\n+        }\n+        call.addChildAfter(parameterNode, argumentNode);\n+        t.reportCodeChange();\n+        break;\n+      } else {\n+        validateNonSpreadArgument(t, call, functionType,\n+            argumentNode, argumentCount, ordinal,\n+            parameterNode);\n+      }\n     }\n \n-    int numArgs = call.getChildCount() - 1;\n+    int numArgs = argumentCount + (functionType.hasRestFormals() ? 1 : 0);\n     int minArgs = functionType.getMinArguments();\n     int maxArgs = functionType.getMaxArguments();\n     if (minArgs > numArgs || maxArgs < numArgs) {\n-      report(t, call, WRONG_ARGUMENT_COUNT,\n+      reportWrongArgumentCount(t, call, functionType,\n               validator.getReadableJSTypeName(call.getFirstChild(), false),\n-              String.valueOf(numArgs), String.valueOf(minArgs),\n-              maxArgs != Integer.MAX_VALUE ?\n-              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+              numArgs, minArgs, maxArgs);\n     }\n   }\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}