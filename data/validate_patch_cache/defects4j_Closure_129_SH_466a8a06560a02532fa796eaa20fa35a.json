{
    "patch": "      Node callee = NodeUtil.getFunctionNameNode(n);\n      Node parent = n.getParent();\n      if (parent.isExprResult()) {\n        // special case for expressions like `new foo().bar()`\n        parent = parent.getParent();\n      }\n      String calleeName = null;\n      if (callee != null) {\n        switch (callee.getToken()) {\n          case NAME:\n            calleeName = callee.getString();\n            break;\n          case GETPROP:\n            Node propNode = callee.getLastChild();\n            if (propNode.isString()) {\n              calleeName = propNode.getString();\n            }\n            break;\n          default:\n            break;\n        }\n      }\n      if (calleeName != null) {\n        Var calleeVar = getScope().getVar(calleeName);\n        if (calleeVar != null) {\n          // The call is to a function that is declared in the current scope.\n          calleeVar.setMarkAssignedExactlyOnce();\n          // consider aliases as well\n          for (Var alias : calleeVar.getAliasedVars()) {\n            alias.setMarkAssignedExactlyOnce();\n          }\n        }\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PrepareAst.java b/src/com/google/javascript/jscomp/PrepareAst.java\nindex d993bee7..2cf8683b 100644\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n@@ -163,6 +163,39 @@ class PrepareAst implements CompilerPass {\n       Node first = n.getFirstChild();\n \n       // ignore cast nodes.\n+      Node callee = NodeUtil.getFunctionNameNode(n);\n+      Node parent = n.getParent();\n+      if (parent.isExprResult()) {\n+        // special case for expressions like `new foo().bar()`\n+        parent = parent.getParent();\n+      }\n+      String calleeName = null;\n+      if (callee != null) {\n+        switch (callee.getToken()) {\n+          case NAME:\n+            calleeName = callee.getString();\n+            break;\n+          case GETPROP:\n+            Node propNode = callee.getLastChild();\n+            if (propNode.isString()) {\n+              calleeName = propNode.getString();\n+            }\n+            break;\n+          default:\n+            break;\n+        }\n+      }\n+      if (calleeName != null) {\n+        Var calleeVar = getScope().getVar(calleeName);\n+        if (calleeVar != null) {\n+          // The call is to a function that is declared in the current scope.\n+          calleeVar.setMarkAssignedExactlyOnce();\n+          // consider aliases as well\n+          for (Var alias : calleeVar.getAliasedVars()) {\n+            alias.setMarkAssignedExactlyOnce();\n+          }\n+        }\n+      }\n \n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}