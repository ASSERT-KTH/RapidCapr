{
    "patch": "    public double solve(final UnivariateRealFunction f, final double min, final double max,\n                        final double startValue)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n        if (f == null) {\n            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n        }\n\n        double targetY = 0;\n        double xMin = min;\n        double yMin = f.value(xMin);\n        double xMax = max;\n        double yMax = f.value(xMax);\n        double x1 = Double.NaN;\n        double y1 = Double.NaN;\n        double x2 = Double.NaN;\n        double y2 = Double.NaN;\n        double midX = Double.NaN;\n        double midY = Double.NaN;\n\n        // Verify bracketing\n        verifyBracketing(min, max, f);\n\n        // Get initial solution\n        verifySequence(min, startValue, max);\n        x1 = startValue;\n        y1 = f.value(x1);\n        x2 = x1;\n        y2 = y1;\n\n        // Set up iteration procedure\n        int i = 0;\n        while (i < maximalIterationCount) {\n\n            // calculate the intermediary point\n            midX = 0.5 * (x1 + x2);\n            midY = f.value(midX);\n\n            if (Math.abs(midY - targetY) <= functionValueAccuracy) {\n                setResult(midX, i);\n                return result;\n            }\n\n            incrementIterationCount();\n\n            // update the bounds with the intermediary point\n            if (((midY > y1) && (midY > y2)) || ((midY < y1) && (midY < y2))) {\n                // choose the extremity of the interval which is closest\n                // to yTarget\n                final double delta1 = Math.abs(midY - y1);\n                final double delta2 = Math.abs(midY - y2);\n                if (delta1 < delta2) {\n                    y2 = midY;\n                    x2 = midX;\n                } else {\n                    y1 = midY;\n                    x1 = midX;\n                }\n            } else {\n                if (y2 < y1) {\n                    y1 = midY;\n                    x1 = midX;\n                } else {\n                    y2 = midY;\n                    x2 = midX;\n                }\n            }\n            i++;\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\nindex 3f669271a..396b44a64 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BisectionSolver.java\n@@ -67,9 +67,76 @@ public class BisectionSolver extends UnivariateRealSolverImpl {\n     }\n \n     /** {@inheritDoc} */\n-    public double solve(final UnivariateRealFunction f, double min, double max, double initial)\n+    public double solve(final UnivariateRealFunction f, final double min, final double max,\n+                        final double startValue)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n-        return solve(min, max);\n+        if (f == null) {\n+            throw new NullArgumentException(LocalizedFormats.FUNCTION);\n+        }\n+\n+        double targetY = 0;\n+        double xMin = min;\n+        double yMin = f.value(xMin);\n+        double xMax = max;\n+        double yMax = f.value(xMax);\n+        double x1 = Double.NaN;\n+        double y1 = Double.NaN;\n+        double x2 = Double.NaN;\n+        double y2 = Double.NaN;\n+        double midX = Double.NaN;\n+        double midY = Double.NaN;\n+\n+        // Verify bracketing\n+        verifyBracketing(min, max, f);\n+\n+        // Get initial solution\n+        verifySequence(min, startValue, max);\n+        x1 = startValue;\n+        y1 = f.value(x1);\n+        x2 = x1;\n+        y2 = y1;\n+\n+        // Set up iteration procedure\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+\n+            // calculate the intermediary point\n+            midX = 0.5 * (x1 + x2);\n+            midY = f.value(midX);\n+\n+            if (Math.abs(midY - targetY) <= functionValueAccuracy) {\n+                setResult(midX, i);\n+                return result;\n+            }\n+\n+            incrementIterationCount();\n+\n+            // update the bounds with the intermediary point\n+            if (((midY > y1) && (midY > y2)) || ((midY < y1) && (midY < y2))) {\n+                // choose the extremity of the interval which is closest\n+                // to yTarget\n+                final double delta1 = Math.abs(midY - y1);\n+                final double delta2 = Math.abs(midY - y2);\n+                if (delta1 < delta2) {\n+                    y2 = midY;\n+                    x2 = midX;\n+                } else {\n+                    y1 = midY;\n+                    x1 = midX;\n+                }\n+            } else {\n+                if (y2 < y1) {\n+                    y1 = midY;\n+                    x1 = midX;\n+                } else {\n+                    y2 = midY;\n+                    x2 = midX;\n+                }\n+            }\n+            i++;\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n     /** {@inheritDoc} */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}