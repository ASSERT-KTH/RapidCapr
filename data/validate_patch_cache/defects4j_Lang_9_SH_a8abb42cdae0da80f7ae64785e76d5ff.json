{
    "patch": "    public static void parallelInvoke(final Collection<? extends Runnable> tasks) throws InterruptedException {\n        final CountDownLatch latch = new CountDownLatch(tasks.size());\n        final List<Throwable> exceptions = new ArrayList<>();\n        for (final Runnable task : tasks) {\n            new Thread(new Runnable() {\n                @Override\n                public void run() {\n                    try {\n                        task.run();\n                    } catch (Throwable ex) {\n                        synchronized (exceptions) {\n                            exceptions.add(ex);\n                        }\n                    } finally {\n                        latch.countDown();\n                    }\n                }\n            }).start();\n        }\n        latch.await();\n        if (!exceptions.isEmpty()) {\n            throw new RuntimeException(\"Exceptions occurred during parallel execution\", exceptions.get(0));\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 8df302f9..3524adbf 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -141,6 +141,30 @@ public class FastDateParser implements DateParser, Serializable {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n+    public static void parallelInvoke(final Collection<? extends Runnable> tasks) throws InterruptedException {\n+        final CountDownLatch latch = new CountDownLatch(tasks.size());\n+        final List<Throwable> exceptions = new ArrayList<>();\n+        for (final Runnable task : tasks) {\n+            new Thread(new Runnable() {\n+                @Override\n+                public void run() {\n+                    try {\n+                        task.run();\n+                    } catch (Throwable ex) {\n+                        synchronized (exceptions) {\n+                            exceptions.add(ex);\n+                        }\n+                    } finally {\n+                        latch.countDown();\n+                    }\n+                }\n+            }).start();\n+        }\n+        latch.await();\n+        if (!exceptions.isEmpty()) {\n+            throw new RuntimeException(\"Exceptions occurred during parallel execution\", exceptions.get(0));\n+        }\n+    }\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}