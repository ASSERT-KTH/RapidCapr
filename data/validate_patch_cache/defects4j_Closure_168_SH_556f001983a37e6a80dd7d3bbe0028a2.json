{
    "patch": "    private boolean shouldAddExport(NodeTraversal t, Node node) {\n      if (!hasEs6Modules(t.getScope())) {\n        return false;\n      }\n\n      String name = null;\n      switch (node.getToken()) {\n        case MEMBER_FUNCTION_DEF: // Fallthrough\n        case FUNCTION:\n          if (!node.isArrowFunction()) {\n            // Only non-arrow functions might have an `export Foo;` declaration associated with\n            // them.\n            return false;\n          }\n\n          // Arrow functions might be assigned to a variable, in which case they still need to\n          // be considered for bundling. For example, given the following module:\n          //\n          // ```\n          // export default () => { ... }\n          // ```\n          //\n          // We need to bundle the arrow function as a named export, so that it can be imported\n          // like so:\n          //\n          // ```\n          // import foo from '/path/to/module';\n          // console.log(foo());\n          // ```\n          // Note that `foo` is not anonymous, hence why we consider it a named export.\n          Node parent = node.getParent();\n          if (NodeUtil.isNameDeclaration(parent) || NodeUtil.isVarDeclaration(parent)) {\n            name = parent.getFirstChild().getString();\n          }\n          break;\n\n        case CLASS:\n          name = NodeUtil.getNameNode(node).getString();\n          break;\n\n        case ASSIGN:\n          if (node.getFirstChild().isQualifiedName()) {\n            name = node.getFirstChild().getQualifiedName();\n          }\n          break;\n\n        default:\n          break;\n      }\n\n>>> [ INFILL ] <<<\n      return false;\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..f150fe2f 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1983,7 +1983,6 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.put(n, new AstFunctionContents(n));\n       }\n     }\n-\n     @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       if (t.inGlobalScope()) {\n         return;\n@@ -1993,7 +1992,59 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n-      if (t.getScopeDepth() <= 2) {\n+    private boolean shouldAddExport(NodeTraversal t, Node node) {\n+      if (!hasEs6Modules(t.getScope())) {\n+        return false;\n+      }\n+\n+      String name = null;\n+      switch (node.getToken()) {\n+        case MEMBER_FUNCTION_DEF: // Fallthrough\n+        case FUNCTION:\n+          if (!node.isArrowFunction()) {\n+            // Only non-arrow functions might have an `export Foo;` declaration associated with\n+            // them.\n+            return false;\n+          }\n+\n+          // Arrow functions might be assigned to a variable, in which case they still need to\n+          // be considered for bundling. For example, given the following module:\n+          //\n+          // ```\n+          // export default () => { ... }\n+          // ```\n+          //\n+          // We need to bundle the arrow function as a named export, so that it can be imported\n+          // like so:\n+          //\n+          // ```\n+          // import foo from '/path/to/module';\n+          // console.log(foo());\n+          // ```\n+          // Note that `foo` is not anonymous, hence why we consider it a named export.\n+          Node parent = node.getParent();\n+          if (NodeUtil.isNameDeclaration(parent) || NodeUtil.isVarDeclaration(parent)) {\n+            name = parent.getFirstChild().getString();\n+          }\n+          break;\n+\n+        case CLASS:\n+          name = NodeUtil.getNameNode(node).getString();\n+          break;\n+\n+        case ASSIGN:\n+          if (node.getFirstChild().isQualifiedName()) {\n+            name = node.getFirstChild().getQualifiedName();\n+          }\n+          break;\n+\n+        default:\n+          break;\n+      }\n+\n+>>> [ INFILL ] <<<\n+      return false;\n+    }\n         // The first-order function analyzer looks at two types of variables:\n         //\n         // 1) Local variables that are assigned in inner scopes (\"escaped vars\")",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}