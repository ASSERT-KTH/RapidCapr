{
    "patch": "  @Override public void visit(NodeTraversal t, Node n, Node parent) {\n      if (t.inGlobalScope()) {\n          return;\n      }\n\n      if (n.isReturn() && n.getFirstChild() != null) {\n          data.get(t.getScopeRoot()).recordNonEmptyReturn();\n      }\n\n      if (t.getScopeDepth() <= 2) {\n          // The first-order function analyzer looks at two types of variables:\n          //\n          // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n          //\n          // 2) Local variables that are assigned more than once.\n          //\n          // We treat all global variables as escaped by default, so there's\n          // no reason to do this extra computation for them.\n          return;\n      }\n\n      if (n.isName() && NodeUtil.isLValue(n) &&\n              // Be careful of bleeding functions, which create variables\n              // in the inner scope, not the scope where the name appears.\n              !NodeUtil.isBleedingFunctionName(n)) {\n          String name = n.getString();\n          Scope scope = t.getScope();\n          Var var = scope.getVar(name);\n          if (var != null) {\n              Scope ownerScope = var.getScope();\n              if (ownerScope.isLocal()) {\n                  data.get(ownerScope.getRootNode()).recordAssignedName(name);\n              }\n\n              if (scope != ownerScope && ownerScope.isLocal()) {\n                  data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n              }\n          }\n      } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n              NodeUtil.isLValue(n)) {\n          String name = NodeUtil.getRootOfQualifiedName(n).getString();\n          Scope scope = t.getScope();\n          Var var = scope.getVar(name);\n          if (var != null) {\n              Scope ownerScope = var.getScope();\n              if (scope != ownerScope && ownerScope.isLocal()) {\n                  data.get(ownerScope.getRootNode())\n                          .recordEscapedQualifiedName(n.getQualifiedName());\n\n                  // record a warning\n                  JSError warning = JSError.make(\n                          \"Unscoped qualified name escapes its original scope.\",\n                          n);\n                  t.getCompiler().report(warning);\n              }\n          }\n      }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex cf87eaaf..3def5ad6 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1983,59 +1983,64 @@ final class TypedScopeCreator implements ScopeCreator {\n         data.put(n, new AstFunctionContents(n));\n       }\n     }\n-\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+  @Override public void visit(NodeTraversal t, Node n, Node parent) {\n       if (t.inGlobalScope()) {\n-        return;\n+          return;\n       }\n \n       if (n.isReturn() && n.getFirstChild() != null) {\n-        data.get(t.getScopeRoot()).recordNonEmptyReturn();\n+          data.get(t.getScopeRoot()).recordNonEmptyReturn();\n       }\n \n       if (t.getScopeDepth() <= 2) {\n-        // The first-order function analyzer looks at two types of variables:\n-        //\n-        // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n-        //\n-        // 2) Local variables that are assigned more than once.\n-        //\n-        // We treat all global variables as escaped by default, so there's\n-        // no reason to do this extra computation for them.\n-        return;\n+          // The first-order function analyzer looks at two types of variables:\n+          //\n+          // 1) Local variables that are assigned in inner scopes (\"escaped vars\")\n+          //\n+          // 2) Local variables that are assigned more than once.\n+          //\n+          // We treat all global variables as escaped by default, so there's\n+          // no reason to do this extra computation for them.\n+          return;\n       }\n \n       if (n.isName() && NodeUtil.isLValue(n) &&\n-          // Be careful of bleeding functions, which create variables\n-          // in the inner scope, not the scope where the name appears.\n-          !NodeUtil.isBleedingFunctionName(n)) {\n-        String name = n.getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordAssignedName(name);\n-          }\n+              // Be careful of bleeding functions, which create variables\n+              // in the inner scope, not the scope where the name appears.\n+              !NodeUtil.isBleedingFunctionName(n)) {\n+          String name = n.getString();\n+          Scope scope = t.getScope();\n+          Var var = scope.getVar(name);\n+          if (var != null) {\n+              Scope ownerScope = var.getScope();\n+              if (ownerScope.isLocal()) {\n+                  data.get(ownerScope.getRootNode()).recordAssignedName(name);\n+              }\n \n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n+              if (scope != ownerScope && ownerScope.isLocal()) {\n+                  data.get(ownerScope.getRootNode()).recordEscapedVarName(name);\n+              }\n           }\n-        }\n       } else if (n.isGetProp() && n.isUnscopedQualifiedName() &&\n-          NodeUtil.isLValue(n)) {\n-        String name = NodeUtil.getRootOfQualifiedName(n).getString();\n-        Scope scope = t.getScope();\n-        Var var = scope.getVar(name);\n-        if (var != null) {\n-          Scope ownerScope = var.getScope();\n-          if (scope != ownerScope && ownerScope.isLocal()) {\n-            data.get(ownerScope.getRootNode())\n-                .recordEscapedQualifiedName(n.getQualifiedName());\n+              NodeUtil.isLValue(n)) {\n+          String name = NodeUtil.getRootOfQualifiedName(n).getString();\n+          Scope scope = t.getScope();\n+          Var var = scope.getVar(name);\n+          if (var != null) {\n+              Scope ownerScope = var.getScope();\n+              if (scope != ownerScope && ownerScope.isLocal()) {\n+                  data.get(ownerScope.getRootNode())\n+                          .recordEscapedQualifiedName(n.getQualifiedName());\n+\n+                  // record a warning\n+                  JSError warning = JSError.make(\n+                          \"Unscoped qualified name escapes its original scope.\",\n+                          n);\n+                  t.getCompiler().report(warning);\n+              }\n           }\n-        }\n       }\n-    }\n+  }\n   }\n \n   private AstFunctionContents getFunctionAnalysisResults(@Nullable Node n) {",
    "result_reason": "error: no suitable method found for make(String,Node)",
    "test_result": "ERROR"
}