{
    "patch": "public static double regularizedGamma(double a, double x) {\n    double gamma = gamma(a);\n    double upperIncomplete = upperIncompleteGamma(a, x);\n    return upperIncomplete / gamma;\n}\n\npublic static double gamma(double x) {\n    final double[] COF = {\n            76.18009172947146, -86.50532032941677, 24.01409824083091,\n            -1.231739572450155, 0.001208650973866179,-0.000005395239384953\n    };\n    double y = x;\n    double tmp = x + 5.5;\n    tmp -= (x + 0.5) * Math.log(tmp);\n    double ser = 1.000000000190015;\n    for (int j = 0; j < 6; j++) {\n        y++;\n        ser += COF[j] / y;\n    }\n    return Math.exp(-tmp + Math.log(2.5066282746310007 * ser / x));\n}\n\npublic static double upperIncompleteGamma(double a, double x) {\n    if (x == 0.0) {\n        return 1.0;\n    } else if (x < a + 1.0) {\n        double temp = a * Math.log(x) - x;\n        double sum = 1.0;\n        double denom = a + 1.0;\n        double term = 1.0 / denom;\n        while (temp != sum) {\n            temp = sum;\n            ++denom;\n            term *= x / denom;\n            sum += term;\n        }\n        return sum * Math.exp(a * Math.log(x) - x - logGamma(a));\n    } else {\n        double b0 = 0.0;\n        double b1 = 1.0;\n        double bm = b1;\n        double a0 = 1.0;\n        double a1 = x;\n        double am = a1;\n        double aold;\n        int m = 0;\n        double term = 1.0;\n        double sum = b1;\n        while (Math.abs(bm - b0) > 1e-15 * Math.abs(bm)) {\n            ++m;\n            b0 = b1;\n            b1 = bm;\n            term *= a / m;\n            am = term * (a1 + a0) - am;\n            aold = a1;\n            a1 = am;\n            a0 = aold;\n            bm = b1 + am * term;\n            sum += bm;\n            if (m > 1000) {\n                throw new RuntimeException(\"Upper Incomplete Gamma overflow\");\n            }\n        }\n        return 1.0 - (sum * Math.exp(a * Math.log(x) - x - logGamma(a)));\n    }\n}\n\npublic static double logGamma(double x) {\n    final double[] COF = {\n            0.6781186548170795, -0.3276825387159573,\n            0.02012439409055156, -0.006878829686200462,\n            0.0009703158166600896, -0.0001028768982139054,\n            0.0000083757030032798, -0.0000005867932381781,\n            0.00000003302319641437, -0.00000000149247360486,\n            0.00000000005639200383, -0.0000000000018802944,\n            0.00000000000005588956,-0.000000000000001454, \n            0.0000000000000000337,-0.000000000000000001\n    };\n    double tmp = x + 4.5;\n    tmp -= (x - 0.5) * Math.log(tmp);\n    double ser = 1.000000000190015;\n    for (int j = 0; j < 16; j++) {\n        x++;\n        ser += COF[j] / x;\n    }\n    return Math.log(2.5066282746310007 * ser / tmp);\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..6099f90c4 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,93 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGamma(double a, double x) {\n+    double gamma = gamma(a);\n+    double upperIncomplete = upperIncompleteGamma(a, x);\n+    return upperIncomplete / gamma;\n+}\n+\n+public static double gamma(double x) {\n+    final double[] COF = {\n+            76.18009172947146, -86.50532032941677, 24.01409824083091,\n+            -1.231739572450155, 0.001208650973866179,-0.000005395239384953\n+    };\n+    double y = x;\n+    double tmp = x + 5.5;\n+    tmp -= (x + 0.5) * Math.log(tmp);\n+    double ser = 1.000000000190015;\n+    for (int j = 0; j < 6; j++) {\n+        y++;\n+        ser += COF[j] / y;\n+    }\n+    return Math.exp(-tmp + Math.log(2.5066282746310007 * ser / x));\n+}\n+\n+public static double upperIncompleteGamma(double a, double x) {\n+    if (x == 0.0) {\n+        return 1.0;\n+    } else if (x < a + 1.0) {\n+        double temp = a * Math.log(x) - x;\n+        double sum = 1.0;\n+        double denom = a + 1.0;\n+        double term = 1.0 / denom;\n+        while (temp != sum) {\n+            temp = sum;\n+            ++denom;\n+            term *= x / denom;\n+            sum += term;\n+        }\n+        return sum * Math.exp(a * Math.log(x) - x - logGamma(a));\n+    } else {\n+        double b0 = 0.0;\n+        double b1 = 1.0;\n+        double bm = b1;\n+        double a0 = 1.0;\n+        double a1 = x;\n+        double am = a1;\n+        double aold;\n+        int m = 0;\n+        double term = 1.0;\n+        double sum = b1;\n+        while (Math.abs(bm - b0) > 1e-15 * Math.abs(bm)) {\n+            ++m;\n+            b0 = b1;\n+            b1 = bm;\n+            term *= a / m;\n+            am = term * (a1 + a0) - am;\n+            aold = a1;\n+            a1 = am;\n+            a0 = aold;\n+            bm = b1 + am * term;\n+            sum += bm;\n+            if (m > 1000) {\n+                throw new RuntimeException(\"Upper Incomplete Gamma overflow\");\n+            }\n+        }\n+        return 1.0 - (sum * Math.exp(a * Math.log(x) - x - logGamma(a)));\n+    }\n+}\n+\n+public static double logGamma(double x) {\n+    final double[] COF = {\n+            0.6781186548170795, -0.3276825387159573,\n+            0.02012439409055156, -0.006878829686200462,\n+            0.0009703158166600896, -0.0001028768982139054,\n+            0.0000083757030032798, -0.0000005867932381781,\n+            0.00000003302319641437, -0.00000000149247360486,\n+            0.00000000005639200383, -0.0000000000018802944,\n+            0.00000000000005588956,-0.000000000000001454, \n+            0.0000000000000000337,-0.000000000000000001\n+    };\n+    double tmp = x + 4.5;\n+    tmp -= (x - 0.5) * Math.log(tmp);\n+    double ser = 1.000000000190015;\n+    for (int j = 0; j < 16; j++) {\n+        x++;\n+        ser += COF[j] / x;\n+    }\n+    return Math.log(2.5066282746310007 * ser / tmp);\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}