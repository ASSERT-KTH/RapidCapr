{
    "patch": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    if (valueToAdd == 0) {\n        return values;\n    }\n\n    // Get the instant value based on the given partial\n    long instant = 0L;\n    for (int i = 0, size = partial.size(); i < size; i++) {\n        instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n    }\n\n    // Get the maximum value for the day of month\n    int maxDayOfMonth = iChronology.dayOfMonth().getMaximumValue(instant);\n\n    DateTimeField targetField = partial.getField(fieldIndex);\n    int targetValue = targetField.get(instant);\n\n    // Add the given value to the field at the fieldIndex\n    int resultValue = targetField.add(targetValue, valueToAdd);\n    if (resultValue == targetValue) {\n        return values;\n    }\n\n    int[] newValues = new int[values.length];\n    System.arraycopy(values, 0, newValues, 0, values.length);\n\n    if (fieldIndex == 0) {\n        // Disjoint partial - set the field value and reset the minimum values of all the fields after this field\n        for (int i = 0, size = partial.size(); i < size; i++) {\n            if (i == fieldIndex) {\n                newValues[i] = resultValue;\n            } else if (i > fieldIndex) {\n                newValues[i] = partial.getFieldType(i).getField(iChronology).getMinimumValue(instant);\n            }\n        }\n    } else if (DateTimeUtils.isContiguous(partial)) {\n        // Contiguous partial - validate the day and month values\n        int currentMonth = partial.getField(fieldIndex - 1).get(instant);\n        int currentDay = targetField.get(instant);\n\n        if (resultValue != targetField.getMaximumValue() + 1) {\n            // Valid day value - set the field value and handle the leap year issue\n            newValues[fieldIndex] = resultValue;\n            boolean isLeapYear = iChronology.year().isLeap(instant);\n            int newMaxDayOfMonth = iChronology.dayOfMonth().getMaximumValue(instant);\n            if (currentMonth == 2 && currentDay == maxDayOfMonth) {\n                // Current date is 29th Feb - handle leap year issue\n                if (!isLeapYear) {\n                    newValues[fieldIndex] = Math.min(resultValue, newMaxDayOfMonth);\n                }\n            } else if (currentDay == maxDayOfMonth) {\n                // Current date is end of month - set to new maximum value\n                newValues[fieldIndex] = Math.min(resultValue, newMaxDayOfMonth);\n            }\n            if (currentMonth != partial.getField(fieldIndex - 1).get(instant + DateTimeConstants.MILLIS_PER_DAY)) {\n                // Month has changed - reset the day value to 1\n                newValues[fieldIndex] = 1;\n            }\n        } else {\n            // Invalid day value - reset the day and month values\n            newValues[fieldIndex] = 1;\n            newValues[fieldIndex - 1] = partial.getFieldType(fieldIndex - 1).getField(iChronology).addWrapField(instant, 1);\n        }\n    } else if (targetField.isLeap(instant)) {\n        // Leap year partial - set the field value and handle leap year issue\n        newValues[fieldIndex] = resultValue;\n        int newMaxDayOfMonth = iChronology.dayOfMonth().getMaximumValue(instant);\n        if (targetField.getMaximumValue() == 2 && resultValue == 29 && maxDayOfMonth < 29) {\n            newValues[fieldIndex] = maxDayOfMonth;\n        } else if (resultValue > newMaxDayOfMonth) {\n            newValues[fieldIndex] = newMaxDayOfMonth;\n        }\n    } else {\n        // Non-leap year partial - set the field value\n        newValues[fieldIndex] = resultValue;\n    }\n\n    return newValues;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\nindex afca44e6..0557ef84 100644\n--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -200,25 +200,86 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n     }\n \n     //-----------------------------------------------------------------------\n-    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n-        // overridden as superclass algorithm can't handle\n-        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n-        if (valueToAdd == 0) {\n-            return values;\n+public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n+    if (valueToAdd == 0) {\n+        return values;\n+    }\n+\n+    // Get the instant value based on the given partial\n+    long instant = 0L;\n+    for (int i = 0, size = partial.size(); i < size; i++) {\n+        instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+    }\n+\n+    // Get the maximum value for the day of month\n+    int maxDayOfMonth = iChronology.dayOfMonth().getMaximumValue(instant);\n+\n+    DateTimeField targetField = partial.getField(fieldIndex);\n+    int targetValue = targetField.get(instant);\n+\n+    // Add the given value to the field at the fieldIndex\n+    int resultValue = targetField.add(targetValue, valueToAdd);\n+    if (resultValue == targetValue) {\n+        return values;\n+    }\n+\n+    int[] newValues = new int[values.length];\n+    System.arraycopy(values, 0, newValues, 0, values.length);\n+\n+    if (fieldIndex == 0) {\n+        // Disjoint partial - set the field value and reset the minimum values of all the fields after this field\n+        for (int i = 0, size = partial.size(); i < size; i++) {\n+            if (i == fieldIndex) {\n+                newValues[i] = resultValue;\n+            } else if (i > fieldIndex) {\n+                newValues[i] = partial.getFieldType(i).getField(iChronology).getMinimumValue(instant);\n+            }\n         }\n-            // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n-            long instant = 0L;\n-            for (int i = 0, isize = partial.size(); i < isize; i++) {\n-                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+    } else if (DateTimeUtils.isContiguous(partial)) {\n+        // Contiguous partial - validate the day and month values\n+        int currentMonth = partial.getField(fieldIndex - 1).get(instant);\n+        int currentDay = targetField.get(instant);\n+\n+        if (resultValue != targetField.getMaximumValue() + 1) {\n+            // Valid day value - set the field value and handle the leap year issue\n+            newValues[fieldIndex] = resultValue;\n+            boolean isLeapYear = iChronology.year().isLeap(instant);\n+            int newMaxDayOfMonth = iChronology.dayOfMonth().getMaximumValue(instant);\n+            if (currentMonth == 2 && currentDay == maxDayOfMonth) {\n+                // Current date is 29th Feb - handle leap year issue\n+                if (!isLeapYear) {\n+                    newValues[fieldIndex] = Math.min(resultValue, newMaxDayOfMonth);\n+                }\n+            } else if (currentDay == maxDayOfMonth) {\n+                // Current date is end of month - set to new maximum value\n+                newValues[fieldIndex] = Math.min(resultValue, newMaxDayOfMonth);\n+            }\n+            if (currentMonth != partial.getField(fieldIndex - 1).get(instant + DateTimeConstants.MILLIS_PER_DAY)) {\n+                // Month has changed - reset the day value to 1\n+                newValues[fieldIndex] = 1;\n             }\n-            instant = add(instant, valueToAdd);\n-            return iChronology.get(partial, instant);\n         } else {\n-            return super.add(partial, fieldIndex, values, valueToAdd);\n+            // Invalid day value - reset the day and month values\n+            newValues[fieldIndex] = 1;\n+            newValues[fieldIndex - 1] = partial.getFieldType(fieldIndex - 1).getField(iChronology).addWrapField(instant, 1);\n         }\n+    } else if (targetField.isLeap(instant)) {\n+        // Leap year partial - set the field value and handle leap year issue\n+        newValues[fieldIndex] = resultValue;\n+        int newMaxDayOfMonth = iChronology.dayOfMonth().getMaximumValue(instant);\n+        if (targetField.getMaximumValue() == 2 && resultValue == 29 && maxDayOfMonth < 29) {\n+            newValues[fieldIndex] = maxDayOfMonth;\n+        } else if (resultValue > newMaxDayOfMonth) {\n+            newValues[fieldIndex] = newMaxDayOfMonth;\n+        }\n+    } else {\n+        // Non-leap year partial - set the field value\n+        newValues[fieldIndex] = resultValue;\n     }\n \n+    return newValues;\n+}\n+\n     //-----------------------------------------------------------------------\n     /**\n      * Add to the Month component of the specified time instant",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}