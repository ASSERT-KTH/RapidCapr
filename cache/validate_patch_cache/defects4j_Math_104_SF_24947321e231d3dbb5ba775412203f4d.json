{
    "patch": "public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n\n    if (a < 0 || x <= 0) {\n        throw new IllegalArgumentException(\"Invalid argument\");\n    }\n\n    if (x < a + 1) { // use series representation\n        double n = 0;\n        double an = 1 / a;\n        double sum = an;\n        while (Math.abs(an) > epsilon && n < maxIterations) {\n            n++;\n            an *= x / (a + n);\n            sum += an;\n        }\n        return Math.exp(-x + a * Math.log(x) - LogGamma.logGamma(a)) * sum;\n    } else { // use continued fraction representation\n        double b0 = 0;\n        double b1 = 1;\n        double bm = b1;\n        double a0 = 1;\n        double a1 = x;\n        double am = a1;\n        double term = 1;\n        double sum = bm / am;\n        int n = 0;\n        boolean continued = true;\n\n        while (continued && n < maxIterations) {\n            n++;\n            double a2 = (n - a) * a1 + x * a0;\n            double b2 = (n - a) * b1 + x * b0;\n            if (b2 != 0) {\n                double c = am / Math.sqrt(a1 * a1 + am * bm);\n                term = c * b2 / a2;\n                sum += term;\n                b0 = b1;\n                b1 = b2;\n                bm = am;\n                a0 = a1;\n                a1 = a2;\n                am = c;\n            } else {\n                continued = false;\n            }\n        }\n      \n        double p = Math.exp(-x + a * Math.log(x) - LogGamma.logGamma(a)) / am;\n        return p * sum;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..cca783254 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,57 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n+\n+    if (a < 0 || x <= 0) {\n+        throw new IllegalArgumentException(\"Invalid argument\");\n+    }\n+\n+    if (x < a + 1) { // use series representation\n+        double n = 0;\n+        double an = 1 / a;\n+        double sum = an;\n+        while (Math.abs(an) > epsilon && n < maxIterations) {\n+            n++;\n+            an *= x / (a + n);\n+            sum += an;\n+        }\n+        return Math.exp(-x + a * Math.log(x) - LogGamma.logGamma(a)) * sum;\n+    } else { // use continued fraction representation\n+        double b0 = 0;\n+        double b1 = 1;\n+        double bm = b1;\n+        double a0 = 1;\n+        double a1 = x;\n+        double am = a1;\n+        double term = 1;\n+        double sum = bm / am;\n+        int n = 0;\n+        boolean continued = true;\n+\n+        while (continued && n < maxIterations) {\n+            n++;\n+            double a2 = (n - a) * a1 + x * a0;\n+            double b2 = (n - a) * b1 + x * b0;\n+            if (b2 != 0) {\n+                double c = am / Math.sqrt(a1 * a1 + am * bm);\n+                term = c * b2 / a2;\n+                sum += term;\n+                b0 = b1;\n+                b1 = b2;\n+                bm = am;\n+                a0 = a1;\n+                a1 = a2;\n+                am = c;\n+            } else {\n+                continued = false;\n+            }\n+        }\n+      \n+        double p = Math.exp(-x + a * Math.log(x) - LogGamma.logGamma(a)) / am;\n+        return p * sum;\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}