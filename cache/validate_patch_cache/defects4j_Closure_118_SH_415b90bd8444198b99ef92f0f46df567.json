{
    "patch": " switch (child.getToken()) {\n   case STRING_KEY:\n     String name = child.getString();\n     T type = typeSystem.getType(getScope(), n, name);\n\n     Property prop = getProperty(name);\n     if (!prop.scheduleRenaming(child,\n                                processProperty(t, prop, type, null))) {\n       // TODO(user): It doesn't look like the user can do much in this\n       // case right now.\n       if (propertiesToErrorFor.containsKey(name)) {\n         compiler.report(JSError.make(\n             t.getSourceName(), child, propertiesToErrorFor.get(name),\n             Warnings.INVALIDATION, name,\n             (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n       }\n     }\n     break;\n   case GETTER_DEF:\n   case SETTER_DEF:\n     String accessorName = child.getString();\n     Property accessorProp = getProperty(accessorName);\n     T accessorType = typeSystem.getType(getScope(), n, accessorName);\n     if (!accessorProp.scheduleAttachAccessors(child, processProperty(t,\n         accessorProp, accessorType, null))) {\n       if (propertiesToErrorFor.containsKey(accessorName)) {\n         compiler.report(JSError.make(\n             t.getSourceName(), child, propertiesToErrorFor.get(accessorName),\n             Warnings.INVALIDATION, accessorName,\n             (accessorType == null ? \"null\" : accessorType.toString()),\n             n.toString(), \"\"));\n       }\n     }\n     break;\n }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex b34921ed..1d01d9ba 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -492,6 +492,41 @@ class DisambiguateProperties<T> implements CompilerPass {\n           child != null;\n           child = child.getNext()) {\n         // Maybe STRING, GET, SET\n+ switch (child.getToken()) {\n+   case STRING_KEY:\n+     String name = child.getString();\n+     T type = typeSystem.getType(getScope(), n, name);\n+\n+     Property prop = getProperty(name);\n+     if (!prop.scheduleRenaming(child,\n+                                processProperty(t, prop, type, null))) {\n+       // TODO(user): It doesn't look like the user can do much in this\n+       // case right now.\n+       if (propertiesToErrorFor.containsKey(name)) {\n+         compiler.report(JSError.make(\n+             t.getSourceName(), child, propertiesToErrorFor.get(name),\n+             Warnings.INVALIDATION, name,\n+             (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n+       }\n+     }\n+     break;\n+   case GETTER_DEF:\n+   case SETTER_DEF:\n+     String accessorName = child.getString();\n+     Property accessorProp = getProperty(accessorName);\n+     T accessorType = typeSystem.getType(getScope(), n, accessorName);\n+     if (!accessorProp.scheduleAttachAccessors(child, processProperty(t,\n+         accessorProp, accessorType, null))) {\n+       if (propertiesToErrorFor.containsKey(accessorName)) {\n+         compiler.report(JSError.make(\n+             t.getSourceName(), child, propertiesToErrorFor.get(accessorName),\n+             Warnings.INVALIDATION, accessorName,\n+             (accessorType == null ? \"null\" : accessorType.toString()),\n+             n.toString(), \"\"));\n+       }\n+     }\n+     break;\n+ }\n \n         // We should never see a mix of numbers and strings.\n         String name = child.getString();",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}