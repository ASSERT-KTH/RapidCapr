{
    "patch": "  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n      return new ExtractionInfo(\"\", token);\n    }\n\n    stream.update();\n    int startLineno = stream.getLineno();\n    int startCharno = stream.getCharno() + 1;\n\n    StringBuilder builder = new StringBuilder();\n    boolean isFirstLine = true;\n    boolean lastTokenWasSpaceOrStar = false;\n    boolean isSingleLine = false;\n\n    do {\n      String line = stream.getRemainingJSDocLine();\n      if (line != null) {\n        int lineLen = line.length();\n        boolean ignoreSpaces = false;\n        boolean ignoreStars = false;\n\n        for (int i = 0; i < lineLen; i++) {\n          char c = line.charAt(i);\n\n          switch (c) {\n            case '/':\n              if (i < lineLen - 1 && line.charAt(i + 1) == '*') {\n                int endChar = i + 2;\n                int level = 1;\n                while (endChar < lineLen && level > 0) {\n                  if (line.charAt(endChar) == '*') {\n                    if (endChar < lineLen - 1 && line.charAt(endChar + 1) == '/') {\n                      endChar++;\n                      level--;\n                    } else {\n                      endChar++;\n                    }\n                  } else if (line.charAt(endChar) == '/') {\n                    if (endChar < lineLen - 1 && line.charAt(endChar + 1) == '*') {\n                      endChar++;\n                      level++;\n                    } else {\n                      endChar++;\n                    }\n                  } else {\n                    endChar++;\n                  }\n                }\n\n                builder.append(line, i, endChar + 1);\n                i = endChar;\n                lastTokenWasSpaceOrStar = false;\n                ignoreStars = true;\n                ignoreSpaces = true;\n                break;\n              }\n              // fall through.\n            case '*':\n              if (!ignoreStars) {\n                if (!lastTokenWasSpaceOrStar) {\n                  builder.append(' ');\n                  lastTokenWasSpaceOrStar = true;\n                }\n                builder.append(c);\n              }\n              break;\n            case ' ':\n            case '\\t':\n            case '\\f':\n              if (!ignoreSpaces && !lastTokenWasSpaceOrStar) {\n                builder.append(' ');\n                lastTokenWasSpaceOrStar = true;\n              }\n              break;\n            case '\\r':\n              // Ignore CRs. Windows uses CR LF instead of just LF.\n              break;\n            case '\\n':\n              if (isFirstLine) {\n                isSingleLine = true;\n              }\n              isFirstLine = false;\n              if (!ignoreSpaces && !lastTokenWasSpaceOrStar) {\n                builder.append(' ');\n                lastTokenWasSpaceOrStar = true;\n              }\n              builder.append('\\n');\n              lastTokenWasSpaceOrStar = false;\n              ignoreSpaces = false;\n              ignoreStars = false;\n              break;\n            default:\n              if (lastTokenWasSpaceOrStar) {\n                builder.append(c);\n                lastTokenWasSpaceOrStar = false;\n              } else {\n                builder.append(c);\n              }\n              ignoreStars = false;\n              ignoreSpaces = false;\n          }\n        }\n      }\n\n      token = next();\n\n      boolean endOfFile = (token == JsDocToken.EOF) || (token == JsDocToken.EOC) || (token == JsDocToken.EOL);\n\n      if (endOfFile || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n        String multilineText = builder.toString();\n\n        if (option != WhitespaceOption.PRESERVE) {\n          multilineText = multilineText.trim().replaceAll(\" *\\n \", \"\\n\");\n        }\n\n        int endLineno = stream.getLineno();\n        int endCharno;\n        if (isSingleLine) {\n          if (multilineText.endsWith(\"\\n\")) {\n            multilineText = multilineText.substring(0, multilineText.length() - 1);\n          }\n          endCharno = startCharno + multilineText.length();\n        } else {\n          endCharno = builder.length() - 1;\n        }\n\n        if (multilineText.length() > 0) {\n          jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n        }\n\n        return new ExtractionInfo(multilineText, token);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex f6a64007..e6e5c259 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1326,11 +1326,8 @@ public final class JsDocInfoParser {\n    * @return The extraction information.\n    */\n   @SuppressWarnings(\"fallthrough\")\n-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n-                                                      WhitespaceOption option) {\n-\n-    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n-        token == JsDocToken.EOF) {\n+  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token, WhitespaceOption option) {\n+    if (token == JsDocToken.EOC || token == JsDocToken.EOL || token == JsDocToken.EOF) {\n       return new ExtractionInfo(\"\", token);\n     }\n \n@@ -1338,95 +1335,128 @@ public final class JsDocInfoParser {\n     int startLineno = stream.getLineno();\n     int startCharno = stream.getCharno() + 1;\n \n-    // Read the content from the first line.\n-    String line = stream.getRemainingJSDocLine();\n-    if (option != WhitespaceOption.PRESERVE) {\n-      line = line.trim();\n-    }\n-\n     StringBuilder builder = new StringBuilder();\n-    builder.append(line);\n-\n-    state = State.SEARCHING_ANNOTATION;\n-    token = next();\n-\n-    boolean ignoreStar = false;\n-\n-    // Track the start of the line to count whitespace that\n-    // the tokenizer skipped. Because this case is rare, it's easier\n-    // to do this here than in the tokenizer.\n+    boolean isFirstLine = true;\n+    boolean lastTokenWasSpaceOrStar = false;\n+    boolean isSingleLine = false;\n \n     do {\n-      switch (token) {\n-        case STAR:\n-          if (ignoreStar) {\n-            // Mark the position after the star as the new start of the line.\n-          } else {\n-            // The star is part of the comment.\n-            if (builder.length() > 0) {\n-              builder.append(' ');\n-            }\n-\n-            builder.append('*');\n-          }\n-\n-          token = next();\n-          continue;\n-\n-        case EOL:\n-          if (option != WhitespaceOption.SINGLE_LINE) {\n-            builder.append(\"\\n\");\n+      String line = stream.getRemainingJSDocLine();\n+      if (line != null) {\n+        int lineLen = line.length();\n+        boolean ignoreSpaces = false;\n+        boolean ignoreStars = false;\n+\n+        for (int i = 0; i < lineLen; i++) {\n+          char c = line.charAt(i);\n+\n+          switch (c) {\n+            case '/':\n+              if (i < lineLen - 1 && line.charAt(i + 1) == '*') {\n+                int endChar = i + 2;\n+                int level = 1;\n+                while (endChar < lineLen && level > 0) {\n+                  if (line.charAt(endChar) == '*') {\n+                    if (endChar < lineLen - 1 && line.charAt(endChar + 1) == '/') {\n+                      endChar++;\n+                      level--;\n+                    } else {\n+                      endChar++;\n+                    }\n+                  } else if (line.charAt(endChar) == '/') {\n+                    if (endChar < lineLen - 1 && line.charAt(endChar + 1) == '*') {\n+                      endChar++;\n+                      level++;\n+                    } else {\n+                      endChar++;\n+                    }\n+                  } else {\n+                    endChar++;\n+                  }\n+                }\n+\n+                builder.append(line, i, endChar + 1);\n+                i = endChar;\n+                lastTokenWasSpaceOrStar = false;\n+                ignoreStars = true;\n+                ignoreSpaces = true;\n+                break;\n+              }\n+              // fall through.\n+            case '*':\n+              if (!ignoreStars) {\n+                if (!lastTokenWasSpaceOrStar) {\n+                  builder.append(' ');\n+                  lastTokenWasSpaceOrStar = true;\n+                }\n+                builder.append(c);\n+              }\n+              break;\n+            case ' ':\n+            case '\\t':\n+            case '\\f':\n+              if (!ignoreSpaces && !lastTokenWasSpaceOrStar) {\n+                builder.append(' ');\n+                lastTokenWasSpaceOrStar = true;\n+              }\n+              break;\n+            case '\\r':\n+              // Ignore CRs. Windows uses CR LF instead of just LF.\n+              break;\n+            case '\\n':\n+              if (isFirstLine) {\n+                isSingleLine = true;\n+              }\n+              isFirstLine = false;\n+              if (!ignoreSpaces && !lastTokenWasSpaceOrStar) {\n+                builder.append(' ');\n+                lastTokenWasSpaceOrStar = true;\n+              }\n+              builder.append('\\n');\n+              lastTokenWasSpaceOrStar = false;\n+              ignoreSpaces = false;\n+              ignoreStars = false;\n+              break;\n+            default:\n+              if (lastTokenWasSpaceOrStar) {\n+                builder.append(c);\n+                lastTokenWasSpaceOrStar = false;\n+              } else {\n+                builder.append(c);\n+              }\n+              ignoreStars = false;\n+              ignoreSpaces = false;\n           }\n+        }\n+      }\n \n-          ignoreStar = true;\n-          token = next();\n-          continue;\n-\n-        default:\n-          ignoreStar = false;\n-          state = State.SEARCHING_ANNOTATION;\n-\n-              // All tokens must be separated by a space.\n-\n-          if (token == JsDocToken.EOC ||\n-              token == JsDocToken.EOF ||\n-              // When we're capturing a license block, annotations\n-              // in the block are ok.\n-              (token == JsDocToken.ANNOTATION &&\n-               option != WhitespaceOption.PRESERVE)) {\n-            String multilineText = builder.toString();\n+      token = next();\n \n-            if (option != WhitespaceOption.PRESERVE) {\n-              multilineText = multilineText.trim();\n-            }\n+      boolean endOfFile = (token == JsDocToken.EOF) || (token == JsDocToken.EOC) || (token == JsDocToken.EOL);\n \n-            int endLineno = stream.getLineno();\n-            int endCharno = stream.getCharno();\n+      if (endOfFile || (token == JsDocToken.ANNOTATION && option != WhitespaceOption.PRESERVE)) {\n+        String multilineText = builder.toString();\n \n-            if (multilineText.length() > 0) {\n-              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n-                  endLineno, endCharno);\n-            }\n-\n-            return new ExtractionInfo(multilineText, token);\n-          }\n+        if (option != WhitespaceOption.PRESERVE) {\n+          multilineText = multilineText.trim().replaceAll(\" *\\n \", \"\\n\");\n+        }\n \n-          if (builder.length() > 0) {\n-            builder.append(' ');\n+        int endLineno = stream.getLineno();\n+        int endCharno;\n+        if (isSingleLine) {\n+          if (multilineText.endsWith(\"\\n\")) {\n+            multilineText = multilineText.substring(0, multilineText.length() - 1);\n           }\n-          builder.append(toString(token));\n-\n-          line = stream.getRemainingJSDocLine();\n+          endCharno = startCharno + multilineText.length();\n+        } else {\n+          endCharno = builder.length() - 1;\n+        }\n \n-          if (option != WhitespaceOption.PRESERVE) {\n-            line = trimEnd(line);\n-          }\n+        if (multilineText.length() > 0) {\n+          jsdocBuilder.markText(multilineText, startLineno, startCharno, endLineno, endCharno);\n+        }\n \n-          builder.append(line);\n-          token = next();\n-      }\n-    } while (true);\n-  }\n+        return new ExtractionInfo(multilineText, token);\n \n \n   /**",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}