{
    "patch": "import org.apache.commons.math3.util.Precision;\nimport org.apache.commons.math3.util.FastMath;\n\npublic class Gamma {\n    \n    private static final double DEFAULT_EPSILON = 1e-9;\n\n    private Gamma() {}\n\n    public static double gamma(double x) {\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            return Double.NaN;\n        }\n        double ret;\n        double absX = FastMath.abs(x);\n        if (absX <= 20.0) {\n            if (x >= 1.0) {\n                double prod = 1.0;\n                double fact = 1.0;\n                double nxp1 = x + 1.0;\n                while (nxp1 > prod) {\n                    fact += 1.0;\n                    prod *= fact/nxp1;\n                    nxp1 = x + fact;\n                }\n                ret = prod/fact;\n            } else {\n                double prod = ((((((+1.60119522476751861407E-4  * x \n                                            - 1.19135147006586384913E-3) * x \n                                            + 1.04213797561761569935E-2) * x \n                                            - 4.76367800457137231464E-2) * x \n                                            + 2.07448227648435975150E-1) * x\n                                            - 4.76367800457137231464E-2) * x \n                                            + 9.99999999999999996796E-1;\n                double fact = FastMath.floor(x);\n                if (fact == x) {\n                    ret = Double.NaN;\n                } else {\n                    double apn = absX - fact;\n                    double gnp = apn + 0.5;\n                    double gl = lanczos(apn);\n                    double gp = lanczos(gnp);\n                    double sqrtTwoPi = FastMath.sqrt(2 * FastMath.PI);\n                    ret = sqrtTwoPi * gp / gl / FastMath.sqrt(apn);\n                }\n            }\n        } else {\n            double g = 7;\n            double coeffs[] = {0.99999999999980993, 676.5203681218851, -1259.1392167224028,\n                771.32342877765313, -176.61502916214059, 12.507343278686905,\n                -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7};\n            double a = coeffs[0];\n            double xNum = coeffs[8];\n            for (int i = 1; i < g + 2; ++i) {\n                a += coeffs[i] / (x + i);\n                xNum *= x - i;\n            }\n            ret = Math.exp((x + 0.5) * Math.log(x + g + 0.5) - x - g - 0.5 +\n                           Math.log(sqrtTwoPi * a / xNum));\n        }\n        if (x < 1.0) {\n            double ap = x;\n            double sum = 1.0 / x;\n            double del = sum;\n            while (del > sum * DEFAULT_EPSILON) {\n                ap += 1.0;\n                del *= x / ap;\n                sum += del;\n            }\n            ret /= sum;\n        }\n        return ret;\n    }\n\n    public static double regularizedGammaP(double a, double x) {\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            return Double.NaN;\n        }\n        if (x == 0.0) {\n            return 0.0;\n        }\n        if (x >= a + 1.0) {\n            return 1.0 - regularizedGammaQ(a, x);\n        }\n        double gln = lanczos(a);\n        double[] hv = generalizedContinuedFraction(a, x, gln);\n        return 1.0 / hv[0];\n    }\n\n    public static double regularizedGammaQ(double a, double x) {\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            return Double.NaN;\n        }\n        if (x == 0) {\n            return 1.0;\n        }\n        if (x < a + 1.0) {\n            return 1.0 - regularizedGammaP(a, x);\n        }\n        double gln = lanczos(a);\n        double[] hv = generalizedContinuedFraction(a, x, gln);\n        double ret = hv[0] / hv[1];\n        return ret;\n    }\n\n    public static double lanczos(double x) {\n        double coeffs[] = { 0.99999999999999709182,\n                            57.156235665862923517,\n                            -59.597960355475491248,\n                            14.136097974741747174,\n                            -0.49191381609762019978,\n                            3.3994649984811888699e-5,\n                            4.6523628927048575665e-5,\n                            -9.8374475304879564677e-5,\n                            1.5808870322491250259e-4,\n                            -1.8622733818427526132e-4,\n                            +1.4118201453848472225e-4,\n                            -4.6660985003153371522e-5,\n                            +3.3322226318082329678e-6,\n                            +7.2134752059985566069e-7,\n                            -1.4286074008232876647e-6,\n                            +9.3675193958252607914e-8,\n                            -1.0230451416490723346e-9,\n                            +1.7201074326816182882e-10,\n                            -9.5079754178749398172e-12 };\n        if (x < 0.5) {\n            return Math.PI / (Math.sin(Math.PI * x) * lanczos(1.0 - x));\n        } else {\n            x -= 1.0;\n            double sum = 0;\n            for (int i = 0; i < coeffs.length; ++i) {\n                sum += coeffs[i] / (x + i);\n            }\n            double tmp = x + coeffs.length - 0.5;\n            return Math.sqrt(2 * Math.PI) * Math.pow(tmp, x + 0.5) * Math.exp(-tmp) * sum;\n        }\n    }\n\n    public static double[] generalizedContinuedFraction(double a, double x, double gln) {\n        double small = 1e-15;\n        double big = 4.503599627370496e15;\n        double bigInv = 2.22044604925031308085e-16;\n        double[] ret = new double[2];\n        double fab = a + x + 1.0 - gln;\n        double[] ps = new double[2];\n        ps[0] = 1.0;\n        ps[1] = x;\n        double[] pss = new double[2];\n        pss[0] = x + 1.0;\n        pss[1] = x * fab + 1.0;\n        double[] zs = new double[2];\n        zs[0] = 0.0;\n        zs[1] = 1.0;\n        double[] zss = new double[2];\n        zss[0] = 1.0;\n        zss[1] = 1.0;\n        boolean stop = false;\n        int iterationCount = 0;\n        while ((!stop) && iterationCount < 500) {\n            ++iterationCount;\n            double lambda = 0;\n            for (int i = 0; i < 2; ++i) {\n                lambda += zs[i] * ps[i] / (pss[i] + zs[i]);\n            }\n            double t = a + iterationCount;\n            if (Math.abs(lambda) > big) {\n                for (int i = 0; i < 2; ++i) {\n                    ret[i] *= bigInv;\n                    ps[i] *= bigInv;\n                    pss[i] *= bigInv;\n                    zs[i] *= bigInv;\n                    zss[i] *= bigInv;\n                }\n            }\n            ps[0] = pss[0];\n            ps[1] = pss[1];\n            pss[0] = lambda;\n            pss[1] = t;\n            zs[0] = zss[0];\n            zs[1] = zss[1];\n            zss[0] = lambda;\n            zss[1] = t;\n            if (zss[1] != 0) {\n                ret[0] = pss[1] / zss[1];\n            }\n            if (ret[0] != 0) {\n                double delta = Math.abs((ret[1] - ret[0]) / ret[0]);\n                if (delta < small) {\n                    stop = true;\n                }\n                ret[1] = ret[0];\n            } else {\n                ret[1] = ret[0] = small;\n            }\n        }\n        if (iterationCount >= 500) {\n            throw new RuntimeException(\"Maximal number of iterations reached\");\n        }\n        return ret;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}