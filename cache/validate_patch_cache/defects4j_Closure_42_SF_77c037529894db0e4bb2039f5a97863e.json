{
    "patch": "public static class TransformDispatcher implements TypeSafeDispatcher {\n    private final String sourceName;\n    private final ErrorReporter errorReporter;\n\n    public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n      this.sourceName = sourceName;\n      this.errorReporter = errorReporter;\n    }\n\n    @Override\n    public Node processBooleanLiteral(BooleanLiteral literalNode) {\n      return new Node(literalNode.getType());\n    }\n\n    @Override\n    public Node processNumberLiteral(NumberLiteral literalNode) {\n      return new Node(literalNode.getType(), literalNode.getNumber());\n    }\n\n    @Override\n    public Node processStringLiteral(StringLiteral literalNode) {\n      return new Node(literalNode.getType(), literalNode.getValue());\n    }\n\n    @Override\n    public Node processNullLiteral(NullLiteral literalNode) {\n      return new Node(literalNode.getType());\n    }\n\n    @Override\n    public Node processThisLiteral(ThisLiteral literalNode) {\n      return new Node(literalNode.getType());\n    }\n\n    @Override\n    public Node processRegExpLiteral(RegExpLiteral literalNode) {\n      return new Node(literalNode.getType(), literalNode.getValue(), literalNode.getFlags());\n    }\n\n    @Override\n    public Node processName(Name nameNode) {\n      return new Node(Token.NAME, nameNode.getIdentifier());\n    }\n\n    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    @Override\n    public Node processBlock(Block blockNode) {\n      return processGeneric(blockNode);\n    }\n\n    @Override\n    public Node processBreakStatement(BreakStatement statementNode) {\n      Node node = newNode(Token.BREAK);\n      if (statementNode.getBreakLabel() != null) {\n        Node labelName = transform(statementNode.getBreakLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    public Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            \"Catch clauses are not supported\",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    @Override\n    public Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n          Token.HOOK,\n          transform(exprNode.getTestExpression()),\n          transform(exprNode.getTrueExpression()),\n          transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    public Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = transform(statementNode.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    public Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n          Token.DO,\n          transformBlock(loopNode.getBody()),\n          transform(loopNode.getCondition()));\n    }\n\n    @Override\n    public Node processElementGet(ElementGet getNode) {\n      return newNode(\n          Token.GETELEM,\n          transform(getNode.getTarget()),\n          transform(getNode.getElement()));\n    }\n\n    @Override\n    public Node processEmptyExpression(EmptyExpression exprNode) {\n      Node node = newNode(Token.EMPTY);\n      return node;\n    }\n\n    @Override\n    public Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(Token.EXPR_RESULT, transform(statementNode.getExpression()));\n      return node;\n    }\n\n    @Override\n    public Node processForInLoop(ForInLoop loopNode) {\n      Node iterChild = transform(loopNode.getIterator());\n      Node targetChild = transform(loopNode.getIteratedObject());\n      Node bodyChild = transformBlock(loopNode.getBody());\n      return new Node(Token.FORIN, iterChild, targetChild, bodyChild);\n    }\n\n    @Override\n    public Node processForLoop(ForLoop loopNode) {\n      Node cond = transform(loopNode.getCondition());\n      Node incr = transform(loopNode.getIncrement());\n      Node init = transform(loopNode.getInitializer());\n      Node body = transformBlock(loopNode.getBody());\n\n      Node forNode = newNode(Token.FOR, cond, incr, init, body);\n      if (loopNode.isForEach()) {\n        forNode.addChildToFront(newNode(Token.FOR_OF, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject())));\n      }\n      return forNode;\n    }\n\n    @Override\n    public Node processFunctionCall(FunctionCall callNode) {\n      Node callArgs = processChildren(callNode.getArguments());\n      Node callTarget = transform(callNode.getTarget());\n      return newNode(Token.CALL, callTarget, callArgs);\n    }\n\n    @Override\n    public Node processFunctionNode(FunctionNode functionNode) {\n      Node functionArgs = processChildren(functionNode.getParams());\n      Node functionBody = transform(functionNode.getBody());\n      Node functionName = null;\n      if (functionNode.getFunctionName() != null) {\n        functionName = transform(functionNode.getFunctionName());\n      }\n      return new Node(Token.FUNCTION, functionName, functionBody, functionArgs);\n    }\n\n    @Override\n    public Node processIfStatement(IfStatement ifNode) {\n      Node ifBlock = transform(ifNode.getThenPart());\n      Node elseBlock = null;\n      if (ifNode.getElsePart() != null) {\n        elseBlock = transform(ifNode.getElsePart());\n      }\n      return new Node(Token.IF, transform(ifNode.getCondition()), ifBlock, elseBlock);\n    }\n\n    @Override\n    public Node processInfixExpression(InfixExpression infixNode) {\n      return newNode(\n          transformTokenType(infixNode.getType()),\n          transform(infixNode.getLeft()),\n          transform(infixNode.getRight()));\n    }\n\n    @Override\n    public Node processKeywordLiteral(KeywordLiteral literalNode) {\n      return newNode(literalNode.getType());\n    }\n\n    @Override\n    public Node processLabel(Label labelNode) {\n      return newNode(Token.LABEL_NAME, labelNode.getName());\n    }\n\n    @Override\n    public Node processNewExpression(NewExpression newExprNode) {\n      Node newArgs = processChildren(newExprNode.getArguments());\n      Node newTarget = transform(newExprNode.getTarget());\n      return new Node(Token.NEW, newTarget, newArgs);\n    }\n\n    @Override\n    public Node processObjectLiteral(ObjectLiteral literalNode) {\n      Node objNode = new Node(Token.OBJECTLIT);\n      for (ObjectProperty property : literalNode.getElements()) {\n        objNode.addChildToBack(transform(property));\n      }\n      return objNode;\n    }\n\n    @Override\n    public Node processObjectProperty(ObjectProperty propNode) {\n      Node valueNode = transform(propNode.getRight());\n      if (propNode.isGetter()) {\n        valueNode = new Node(Token.GETTER_DEF, valueNode);\n      } else if (propNode.isSetter()) {\n        valueNode = new Node(Token.SETTER_DEF, valueNode);\n      }\n      return newNode(\n          Token.STRING,\n          propNode.getLeft().getString(),\n          valueNode);\n    }\n\n    @Override\n    public Node processParenthesizedExpression(ParenthesizedExpression parenNode) {\n      Node expression = transform(parenNode.getExpression());\n      return new Node(Token.LP, expression);\n    }\n\n    @Override\n    public Node processRegExp(RegExpLiteral regExpLiteral) {\n      return newNode(Token.REGEXP, regExpLiteral.getValue(), regExpLiteral.getFlags());\n    }\n\n    @Override\n    public Node processReturnStatement(ReturnStatement returnNode) {\n      Node returnValue = null;\n      if (returnNode.getReturnValue() != null) {\n        returnValue = transform(returnNode.getReturnValue());\n      }\n      return new Node(Token.RETURN, returnValue);\n    }\n\n    @Override\n    public Node processSwitchCase(SwitchCase switchCaseNode) {\n      Node switchExpr = null;\n      if (!switchCaseNode.isDefault()) {\n        switchExpr = transform(switchCaseNode.getExpression());\n      }\n      Node switchStatements = transformBlock(switchCaseNode.getStatements());\n      return new Node(Token.CASE, switchExpr, switchStatements);\n    }\n\n    @Override\n    public Node processSwitchStatement(SwitchStatement switchNode) {\n      Node switchExpr = transform(switchNode.getExpression());\n      Node switchBlock = new Node(Token.BLOCK);\n      for (SwitchCase caseNode : switchNode.getCases()) {\n        Node newChild = transform(caseNode);\n        switchBlock.addChildToBack(newChild);\n      }\n      return new Node(Token.SWITCH, switchExpr, switchBlock);\n    }\n\n    @Override\n    public Node processThrowStatement(ThrowStatement throwNode) {\n      return new Node(Token.THROW, transform(throwNode.getExpression()));\n    }\n\n    @Override\n    public Node processTryStatement(TryStatement tryNode) {\n      Node tryBlock = transform(tryNode.getTryBlock());\n      Node catchBlock = null;\n      if (tryNode.getCatchClause() != null) {\n        catchBlock = transform(tryNode.getCatchClause()); \n      }\n      Node finallyBlock = null;\n      if (tryNode.getFinallyBlock() != null) {\n        finallyBlock = transform(tryNode.getFinallyBlock());\n      }\n      return newNode(\n          Token.TRY,\n          tryBlock,\n          catchBlock,\n          finallyBlock);\n    }\n\n    @Override\n    public Node processUnaryExpression(UnaryExpression unaryNode) {\n      return newNode(transformTokenType(unaryNode.getType()), transform(unaryNode.getOperand()));\n    }\n\n    @Override\n    public Node processVariableDeclaration(VariableDeclaration declNode) {\n      Node varNode = new Node(Token.VAR);\n      for (VariableInitializer childNode : declNode.getVariables()) {\n        Node binding;\n        if (childNode.getTarget() instanceof Name) {\n          binding = processName((Name) childNode.getTarget());\n        } else {\n          throw new RuntimeException(\"Only names allowed as variable initializers\");\n        }\n        Node init = null;\n        if (childNode.getInitializer() != null) {\n          init = transform(childNode.getInitializer());\n        }\n        Node varExpr = newNode(Token.VAR, binding, init);\n        varNode.addChildToBack(varExpr);\n      }\n      return varNode;\n    }\n\n    @Override\n    public Node processWhileLoop(WhileLoop loopNode) {\n      return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    public Node processWithStatement(WithStatement withNode) {\n      return newNode(Token.WITH, transform(withNode.getExpression()), transform(withNode.getStatement()));\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..7d398bb9 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,6 +473,50 @@ class IRFactory {\n       }\n     }\n \n+public static class TransformDispatcher implements TypeSafeDispatcher {\n+    private final String sourceName;\n+    private final ErrorReporter errorReporter;\n+\n+    public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n+      this.sourceName = sourceName;\n+      this.errorReporter = errorReporter;\n+    }\n+\n+    @Override\n+    public Node processBooleanLiteral(BooleanLiteral literalNode) {\n+      return new Node(literalNode.getType());\n+    }\n+\n+    @Override\n+    public Node processNumberLiteral(NumberLiteral literalNode) {\n+      return new Node(literalNode.getType(), literalNode.getNumber());\n+    }\n+\n+    @Override\n+    public Node processStringLiteral(StringLiteral literalNode) {\n+      return new Node(literalNode.getType(), literalNode.getValue());\n+    }\n+\n+    @Override\n+    public Node processNullLiteral(NullLiteral literalNode) {\n+      return new Node(literalNode.getType());\n+    }\n+\n+    @Override\n+    public Node processThisLiteral(ThisLiteral literalNode) {\n+      return new Node(literalNode.getType());\n+    }\n+\n+    @Override\n+    public Node processRegExpLiteral(RegExpLiteral literalNode) {\n+      return new Node(literalNode.getType(), literalNode.getValue(), literalNode.getFlags());\n+    }\n+\n+    @Override\n+    public Node processName(Name nameNode) {\n+      return new Node(Token.NAME, nameNode.getIdentifier());\n+    }\n+\n     private boolean isDirective(Node n) {\n       if (n == null) return false;\n \n@@ -483,12 +527,12 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n+    public Node processBlock(Block blockNode) {\n       return processGeneric(blockNode);\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n+    public Node processBreakStatement(BreakStatement statementNode) {\n       Node node = newNode(Token.BREAK);\n       if (statementNode.getBreakLabel() != null) {\n         Node labelName = transform(statementNode.getBreakLabel());\n@@ -500,7 +544,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n+    public Node processCatchClause(CatchClause clauseNode) {\n       AstNode catchVar = clauseNode.getVarName();\n       Node node = newNode(Token.CATCH, transform(catchVar));\n       if (clauseNode.getCatchCondition() != null) {\n@@ -514,7 +558,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+    public Node processConditionalExpression(ConditionalExpression exprNode) {\n       return newNode(\n           Token.HOOK,\n           transform(exprNode.getTestExpression()),\n@@ -523,7 +567,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n+    public Node processContinueStatement(ContinueStatement statementNode) {\n       Node node = newNode(Token.CONTINUE);\n       if (statementNode.getLabel() != null) {\n         Node labelName = transform(statementNode.getLabel());\n@@ -535,7 +579,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n+    public Node processDoLoop(DoLoop loopNode) {\n       return newNode(\n           Token.DO,\n           transformBlock(loopNode.getBody()),\n@@ -543,7 +587,7 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n+    public Node processElementGet(ElementGet getNode) {\n       return newNode(\n           Token.GETELEM,\n           transform(getNode.getTarget()),\n@@ -551,29 +595,215 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n+    public Node processEmptyExpression(EmptyExpression exprNode) {\n       Node node = newNode(Token.EMPTY);\n       return node;\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n+    public Node processExpressionStatement(ExpressionStatement statementNode) {\n+      Node node = newNode(Token.EXPR_RESULT, transform(statementNode.getExpression()));\n       return node;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node processForInLoop(ForInLoop loopNode) {\n+      Node iterChild = transform(loopNode.getIterator());\n+      Node targetChild = transform(loopNode.getIteratedObject());\n+      Node bodyChild = transformBlock(loopNode.getBody());\n+      return new Node(Token.FORIN, iterChild, targetChild, bodyChild);\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n+    @Override\n+    public Node processForLoop(ForLoop loopNode) {\n+      Node cond = transform(loopNode.getCondition());\n+      Node incr = transform(loopNode.getIncrement());\n+      Node init = transform(loopNode.getInitializer());\n+      Node body = transformBlock(loopNode.getBody());\n+\n+      Node forNode = newNode(Token.FOR, cond, incr, init, body);\n+      if (loopNode.isForEach()) {\n+        forNode.addChildToFront(newNode(Token.FOR_OF, transform(loopNode.getIterator()), transform(loopNode.getIteratedObject())));\n+      }\n+      return forNode;\n+    }\n+\n+    @Override\n+    public Node processFunctionCall(FunctionCall callNode) {\n+      Node callArgs = processChildren(callNode.getArguments());\n+      Node callTarget = transform(callNode.getTarget());\n+      return newNode(Token.CALL, callTarget, callArgs);\n+    }\n+\n+    @Override\n+    public Node processFunctionNode(FunctionNode functionNode) {\n+      Node functionArgs = processChildren(functionNode.getParams());\n+      Node functionBody = transform(functionNode.getBody());\n+      Node functionName = null;\n+      if (functionNode.getFunctionName() != null) {\n+        functionName = transform(functionNode.getFunctionName());\n+      }\n+      return new Node(Token.FUNCTION, functionName, functionBody, functionArgs);\n+    }\n+\n+    @Override\n+    public Node processIfStatement(IfStatement ifNode) {\n+      Node ifBlock = transform(ifNode.getThenPart());\n+      Node elseBlock = null;\n+      if (ifNode.getElsePart() != null) {\n+        elseBlock = transform(ifNode.getElsePart());\n+      }\n+      return new Node(Token.IF, transform(ifNode.getCondition()), ifBlock, elseBlock);\n+    }\n+\n+    @Override\n+    public Node processInfixExpression(InfixExpression infixNode) {\n       return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+          transformTokenType(infixNode.getType()),\n+          transform(infixNode.getLeft()),\n+          transform(infixNode.getRight()));\n     }\n \n+    @Override\n+    public Node processKeywordLiteral(KeywordLiteral literalNode) {\n+      return newNode(literalNode.getType());\n+    }\n+\n+    @Override\n+    public Node processLabel(Label labelNode) {\n+      return newNode(Token.LABEL_NAME, labelNode.getName());\n+    }\n+\n+    @Override\n+    public Node processNewExpression(NewExpression newExprNode) {\n+      Node newArgs = processChildren(newExprNode.getArguments());\n+      Node newTarget = transform(newExprNode.getTarget());\n+      return new Node(Token.NEW, newTarget, newArgs);\n+    }\n+\n+    @Override\n+    public Node processObjectLiteral(ObjectLiteral literalNode) {\n+      Node objNode = new Node(Token.OBJECTLIT);\n+      for (ObjectProperty property : literalNode.getElements()) {\n+        objNode.addChildToBack(transform(property));\n+      }\n+      return objNode;\n+    }\n+\n+    @Override\n+    public Node processObjectProperty(ObjectProperty propNode) {\n+      Node valueNode = transform(propNode.getRight());\n+      if (propNode.isGetter()) {\n+        valueNode = new Node(Token.GETTER_DEF, valueNode);\n+      } else if (propNode.isSetter()) {\n+        valueNode = new Node(Token.SETTER_DEF, valueNode);\n+      }\n+      return newNode(\n+          Token.STRING,\n+          propNode.getLeft().getString(),\n+          valueNode);\n+    }\n+\n+    @Override\n+    public Node processParenthesizedExpression(ParenthesizedExpression parenNode) {\n+      Node expression = transform(parenNode.getExpression());\n+      return new Node(Token.LP, expression);\n+    }\n+\n+    @Override\n+    public Node processRegExp(RegExpLiteral regExpLiteral) {\n+      return newNode(Token.REGEXP, regExpLiteral.getValue(), regExpLiteral.getFlags());\n+    }\n+\n+    @Override\n+    public Node processReturnStatement(ReturnStatement returnNode) {\n+      Node returnValue = null;\n+      if (returnNode.getReturnValue() != null) {\n+        returnValue = transform(returnNode.getReturnValue());\n+      }\n+      return new Node(Token.RETURN, returnValue);\n+    }\n+\n+    @Override\n+    public Node processSwitchCase(SwitchCase switchCaseNode) {\n+      Node switchExpr = null;\n+      if (!switchCaseNode.isDefault()) {\n+        switchExpr = transform(switchCaseNode.getExpression());\n+      }\n+      Node switchStatements = transformBlock(switchCaseNode.getStatements());\n+      return new Node(Token.CASE, switchExpr, switchStatements);\n+    }\n+\n+    @Override\n+    public Node processSwitchStatement(SwitchStatement switchNode) {\n+      Node switchExpr = transform(switchNode.getExpression());\n+      Node switchBlock = new Node(Token.BLOCK);\n+      for (SwitchCase caseNode : switchNode.getCases()) {\n+        Node newChild = transform(caseNode);\n+        switchBlock.addChildToBack(newChild);\n+      }\n+      return new Node(Token.SWITCH, switchExpr, switchBlock);\n+    }\n+\n+    @Override\n+    public Node processThrowStatement(ThrowStatement throwNode) {\n+      return new Node(Token.THROW, transform(throwNode.getExpression()));\n+    }\n+\n+    @Override\n+    public Node processTryStatement(TryStatement tryNode) {\n+      Node tryBlock = transform(tryNode.getTryBlock());\n+      Node catchBlock = null;\n+      if (tryNode.getCatchClause() != null) {\n+        catchBlock = transform(tryNode.getCatchClause()); \n+      }\n+      Node finallyBlock = null;\n+      if (tryNode.getFinallyBlock() != null) {\n+        finallyBlock = transform(tryNode.getFinallyBlock());\n+      }\n+      return newNode(\n+          Token.TRY,\n+          tryBlock,\n+          catchBlock,\n+          finallyBlock);\n+    }\n+\n+    @Override\n+    public Node processUnaryExpression(UnaryExpression unaryNode) {\n+      return newNode(transformTokenType(unaryNode.getType()), transform(unaryNode.getOperand()));\n+    }\n+\n+    @Override\n+    public Node processVariableDeclaration(VariableDeclaration declNode) {\n+      Node varNode = new Node(Token.VAR);\n+      for (VariableInitializer childNode : declNode.getVariables()) {\n+        Node binding;\n+        if (childNode.getTarget() instanceof Name) {\n+          binding = processName((Name) childNode.getTarget());\n+        } else {\n+          throw new RuntimeException(\"Only names allowed as variable initializers\");\n+        }\n+        Node init = null;\n+        if (childNode.getInitializer() != null) {\n+          init = transform(childNode.getInitializer());\n+        }\n+        Node varExpr = newNode(Token.VAR, binding, init);\n+        varNode.addChildToBack(varExpr);\n+      }\n+      return varNode;\n+    }\n+\n+    @Override\n+    public Node processWhileLoop(WhileLoop loopNode) {\n+      return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n+    }\n+\n+    @Override\n+    public Node processWithStatement(WithStatement withNode) {\n+      return newNode(Token.WITH, transform(withNode.getExpression()), transform(withNode.getStatement()));\n+    }\n+  }\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: class IRFactory.TransformDispatcher is already defined in class IRFactory",
    "test_result": "ERROR"
}