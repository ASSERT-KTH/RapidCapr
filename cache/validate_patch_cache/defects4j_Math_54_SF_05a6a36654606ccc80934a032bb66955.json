{
    "patch": "public double toDouble() {\n    if (isNaN()) {\n        return Double.NaN;\n    }\n\n    if (isInfinite()) {\n        return sign > 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n\n    if (equals(getZero())) {\n        return 0.0;\n    }\n\n    Dfp y = this;\n\n    boolean negate = false;\n    if (lessThan(getZero())) {\n        y = this.negate();\n        negate = true;\n    }\n\n    int exponent = 0;\n    Dfp yp = y;\n    while (yp.greaterThan(getOne())) {\n        exponent++;\n        yp = yp.divide(getTwo());\n    }\n    while (yp.lessThan(1.0)) {\n        exponent--;\n        yp = yp.multiply(getTwo());\n    }\n\n    // Exponent check.\n    if (exponent + Double.MAX_EXPONENT <= 0) {\n        if (negate) {\n            return -0.0;\n        }\n        return 0.0;\n    }\n\n    if (exponent + Double.MAX_EXPONENT >= Double.MAX_EXPONENT*2) {\n        if (negate) {\n            return Double.NEGATIVE_INFINITY;\n        }\n        return Double.POSITIVE_INFINITY;\n    }\n\n    // normalize\n    y = y.divide(DfpMath.pow(getTwo(), exponent));\n\n    // subnormal number\n    if (exponent + Double.MAX_EXPONENT <= 1) {\n        if (negate && y.ulp().equals(y)) { // negative and is the smallest\n            return -0.0;\n        }\n        return negate ? -y.toDouble() : y.toDouble();\n    }\n\n    long bits = ((long)(exponent + Double.MAX_EXPONENT)) << 52;\n\n    y = y.multiply(DfpMath.pow(unsafeNewInstance(4607182418800017408L), -exponent));\n\n    String tmp = y.toString().toUpperCase(Locale.ENGLISH);\n    boolean error = false;\n\n    if (tmp.indexOf('E') != -1) {\n        error = true;\n    }\n\n    int sp = tmp.indexOf('.');\n\n    if (sp == -1) {\n        // No decimal point, just adding zeroes.\n        tmp = tmp + \".0\";\n        sp = tmp.indexOf('.');\n    } else {\n        // Remove trailing zeroes.\n        int nb = tmp.length() - 1;\n        while (tmp.charAt(nb) == '0') {\n            nb--;\n        }\n        if (nb != tmp.length() - 1) {\n            error = true;\n        }\n        tmp = tmp.substring(0, nb + 1);\n    }\n\n    int len = Math.min(18, tmp.length() - 1); // 18 = 17 digits + \".\"\n    long mantissa = 0;\n    for (int i = 0; i < len; i++) {\n        char c = tmp.charAt(i);\n        if (c == '.') {\n            continue;\n        }\n        int digit = c - '0';\n        mantissa = mantissa * 10 + digit;\n    }\n\n    int rndDigit = tmp.charAt(len) - '0';\n\n    boolean leastBit = (mantissa & 1) != 0;\n    boolean round = false;\n    if (rndDigit > 5) {\n        round = true;\n    }\n    if (rndDigit < 5) {\n        round = false;\n    }\n    if (rndDigit == 5) {\n        round = leastBit;\n    }\n\n    if (mantissa == 0 && !round) {\n        return 0.0;\n    }\n\n    if (round) {\n        mantissa++;\n        if (mantissa == 1000000000000000000L) { // increment lead into the exponent.\n            bits += 1L << 52;\n            mantissa = 100000000000000000L;     // strip off the carry bit.\n        }\n    }\n\n    bits |= mantissa;\n    double value = Double.longBitsToDouble(negate ? -bits : bits);\n    if (error && StrictMath.abs(value - y.toDouble()) > Math.ulp(value)) {\n        throw new ArithmeticException(\"Conversion error: \" + y.toString() + \" to \" + value);\n    }\n    return value;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/dfp/Dfp.java b/src/main/java/org/apache/commons/math/dfp/Dfp.java\nindex 73f1ea3e8..cdb372b66 100644\n--- a/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n@@ -253,88 +253,137 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param field field to which this instance belongs\n      * @param x value to convert to an instance\n      */\n-    protected Dfp(final DfpField field, double x) {\n+public double toDouble() {\n+    if (isNaN()) {\n+        return Double.NaN;\n+    }\n \n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n-        this.field = field;\n+    if (isInfinite()) {\n+        return sign > 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n+    }\n \n-        long bits = Double.doubleToLongBits(x);\n-        long mantissa = bits & 0x000fffffffffffffL;\n-        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n+    if (equals(getZero())) {\n+        return 0.0;\n+    }\n \n-        if (exponent == -1023) {\n-            // Zero or sub-normal\n-            if (x == 0) {\n-                // make sure 0 has the right sign\n-                return;\n-            }\n+    Dfp y = this;\n \n-            exponent++;\n+    boolean negate = false;\n+    if (lessThan(getZero())) {\n+        y = this.negate();\n+        negate = true;\n+    }\n \n-            // Normalize the subnormal number\n-            while ( (mantissa & 0x0010000000000000L) == 0) {\n-                exponent--;\n-                mantissa <<= 1;\n-            }\n-            mantissa &= 0x000fffffffffffffL;\n+    int exponent = 0;\n+    Dfp yp = y;\n+    while (yp.greaterThan(getOne())) {\n+        exponent++;\n+        yp = yp.divide(getTwo());\n+    }\n+    while (yp.lessThan(1.0)) {\n+        exponent--;\n+        yp = yp.multiply(getTwo());\n+    }\n+\n+    // Exponent check.\n+    if (exponent + Double.MAX_EXPONENT <= 0) {\n+        if (negate) {\n+            return -0.0;\n         }\n+        return 0.0;\n+    }\n \n-        if (exponent == 1024) {\n-            // infinity or NAN\n-            if (x != x) {\n-                sign = (byte) 1;\n-                nans = QNAN;\n-            } else if (x < 0) {\n-                sign = (byte) -1;\n-                nans = INFINITE;\n-            } else {\n-                sign = (byte) 1;\n-                nans = INFINITE;\n-            }\n-            return;\n+    if (exponent + Double.MAX_EXPONENT >= Double.MAX_EXPONENT*2) {\n+        if (negate) {\n+            return Double.NEGATIVE_INFINITY;\n         }\n+        return Double.POSITIVE_INFINITY;\n+    }\n \n-        Dfp xdfp = new Dfp(field, mantissa);\n-        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n-        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n+    // normalize\n+    y = y.divide(DfpMath.pow(getTwo(), exponent));\n \n-        if ((bits & 0x8000000000000000L) != 0) {\n-            xdfp = xdfp.negate();\n+    // subnormal number\n+    if (exponent + Double.MAX_EXPONENT <= 1) {\n+        if (negate && y.ulp().equals(y)) { // negative and is the smallest\n+            return -0.0;\n         }\n+        return negate ? -y.toDouble() : y.toDouble();\n+    }\n \n-        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n-        sign = xdfp.sign;\n-        exp  = xdfp.exp;\n-        nans = xdfp.nans;\n+    long bits = ((long)(exponent + Double.MAX_EXPONENT)) << 52;\n \n+    y = y.multiply(DfpMath.pow(unsafeNewInstance(4607182418800017408L), -exponent));\n+\n+    String tmp = y.toString().toUpperCase(Locale.ENGLISH);\n+    boolean error = false;\n+\n+    if (tmp.indexOf('E') != -1) {\n+        error = true;\n     }\n \n-    /** Copy constructor.\n-     * @param d instance to copy\n-     */\n-    public Dfp(final Dfp d) {\n-        mant  = d.mant.clone();\n-        sign  = d.sign;\n-        exp   = d.exp;\n-        nans  = d.nans;\n-        field = d.field;\n+    int sp = tmp.indexOf('.');\n+\n+    if (sp == -1) {\n+        // No decimal point, just adding zeroes.\n+        tmp = tmp + \".0\";\n+        sp = tmp.indexOf('.');\n+    } else {\n+        // Remove trailing zeroes.\n+        int nb = tmp.length() - 1;\n+        while (tmp.charAt(nb) == '0') {\n+            nb--;\n+        }\n+        if (nb != tmp.length() - 1) {\n+            error = true;\n+        }\n+        tmp = tmp.substring(0, nb + 1);\n     }\n \n-    /** Create an instance from a String representation.\n-     * @param field field to which this instance belongs\n-     * @param s string representation of the instance\n-     */\n-    protected Dfp(final DfpField field, final String s) {\n+    int len = Math.min(18, tmp.length() - 1); // 18 = 17 digits + \".\"\n+    long mantissa = 0;\n+    for (int i = 0; i < len; i++) {\n+        char c = tmp.charAt(i);\n+        if (c == '.') {\n+            continue;\n+        }\n+        int digit = c - '0';\n+        mantissa = mantissa * 10 + digit;\n+    }\n \n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n+    int rndDigit = tmp.charAt(len) - '0';\n+\n+    boolean leastBit = (mantissa & 1) != 0;\n+    boolean round = false;\n+    if (rndDigit > 5) {\n+        round = true;\n+    }\n+    if (rndDigit < 5) {\n+        round = false;\n+    }\n+    if (rndDigit == 5) {\n+        round = leastBit;\n+    }\n+\n+    if (mantissa == 0 && !round) {\n+        return 0.0;\n+    }\n+\n+    if (round) {\n+        mantissa++;\n+        if (mantissa == 1000000000000000000L) { // increment lead into the exponent.\n+            bits += 1L << 52;\n+            mantissa = 100000000000000000L;     // strip off the carry bit.\n+        }\n+    }\n+\n+    bits |= mantissa;\n+    double value = Double.longBitsToDouble(negate ? -bits : bits);\n+    if (error && StrictMath.abs(value - y.toDouble()) > Math.ulp(value)) {\n+        throw new ArithmeticException(\"Conversion error: \" + y.toString() + \" to \" + value);\n+    }\n+    return value;\n+}\n         this.field = field;\n \n         boolean decimalFound = false;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}