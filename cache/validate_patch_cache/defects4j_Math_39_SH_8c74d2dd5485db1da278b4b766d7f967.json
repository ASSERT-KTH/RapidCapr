{
    "patch": "    if (firstTime) {\n      final double[] scale = new double[mainSetDimension];\n      if (vecAbsoluteTolerance == null) {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n          }\n      } else {\n          for (int i = 0; i < scale.length; ++i) {\n            scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n          }\n      }\n      hNew = initializeStep(forward, getOrder(), scale,\n                            stepStart, y, yDotK[0], yTmp, yDotK[1]);\n      initIntegration(stepStart, y, t);\n      firstTime = false;\n    }\n\n    // Correctly update step size if it overshoots the final time\n    if (forward) {\n      final double projectedFinalStep = FastMath.abs(t - stepStart) * maxStep;\n      if (hNew > projectedFinalStep) {\n        hNew = projectedFinalStep;\n      }\n      if (stepStart + hNew > t) {\n          hNew = t - stepStart;\n      }\n    } else {\n      final double projectedFinalStep = FastMath.abs(t - stepStart) * maxStep;\n      if (hNew > projectedFinalStep) {\n        hNew = projectedFinalStep;\n      }\n      if (stepStart + hNew < t) {\n          hNew = t - stepStart;\n      }\n    }\n    stepSize = hNew;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..8e1b012c0 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,42 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+    if (firstTime) {\n+      final double[] scale = new double[mainSetDimension];\n+      if (vecAbsoluteTolerance == null) {\n+          for (int i = 0; i < scale.length; ++i) {\n+            scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n+          }\n+      } else {\n+          for (int i = 0; i < scale.length; ++i) {\n+            scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n+          }\n+      }\n+      hNew = initializeStep(forward, getOrder(), scale,\n+                            stepStart, y, yDotK[0], yTmp, yDotK[1]);\n+      initIntegration(stepStart, y, t);\n+      firstTime = false;\n+    }\n+\n+    // Correctly update step size if it overshoots the final time\n+    if (forward) {\n+      final double projectedFinalStep = FastMath.abs(t - stepStart) * maxStep;\n+      if (hNew > projectedFinalStep) {\n+        hNew = projectedFinalStep;\n+      }\n+      if (stepStart + hNew > t) {\n+          hNew = t - stepStart;\n+      }\n+    } else {\n+      final double projectedFinalStep = FastMath.abs(t - stepStart) * maxStep;\n+      if (hNew > projectedFinalStep) {\n+        hNew = projectedFinalStep;\n+      }\n+      if (stepStart + hNew < t) {\n+          hNew = t - stepStart;\n+      }\n+    }\n+    stepSize = hNew;\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: maxStep has private access in AdaptiveStepsizeIntegrator",
    "test_result": "ERROR"
}