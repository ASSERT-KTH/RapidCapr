{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final int n = m.getRowDimension(); // get number of rows (assuming square matrix)\n    final int threshold = 100; // set a threshold to divide large matrices\n    if (n > threshold) {\n        // divide the matrix into smaller sub-matrices\n        final EigenDecomposition[] decomposition = new EigenDecomposition[n / threshold + 1];\n        for (int i = 0; i < n; i += threshold) {\n            final int size = Math.min(threshold, n - i); // get size of sub-matrix\n            final RealMatrix subMatrix = m.getSubMatrix(i, i + size - 1, i, i + size - 1);\n            decomposition[i / threshold] = new EigenDecomposition(subMatrix);\n        }\n        // combine the square roots of sub-matrices\n        RealMatrix result = MatrixUtils.createRealMatrix(n, n);\n        for (int i = 0; i < n; i += threshold) {\n            final int size = Math.min(threshold, n - i); // get size of sub-matrix\n            final RealMatrix subMatrix = MatrixUtils.createRealMatrix(size, size);\n            final RealMatrix v = decomposition[i / threshold].getV();\n            final RealMatrix d = decomposition[i / threshold].getD();\n            for (int j = 0; j < size; j++) {\n                final double lambda = d.getEntry(j, j);\n                if (lambda < 0) {\n                    throw new IllegalArgumentException(\"Matrix must be positive definite\");\n                }\n                final double sqrtLambda = Math.sqrt(lambda);\n                for (int k = 0; k < size; k++) {\n                    subMatrix.setEntry(k, j, v.getEntry(k, j) * sqrtLambda);\n                }\n            }\n            result.setSubMatrix(subMatrix.getData(), i, i);\n        }\n        return result;\n    } else {\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..11b3272ea 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,40 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final int n = m.getRowDimension(); // get number of rows (assuming square matrix)\n+    final int threshold = 100; // set a threshold to divide large matrices\n+    if (n > threshold) {\n+        // divide the matrix into smaller sub-matrices\n+        final EigenDecomposition[] decomposition = new EigenDecomposition[n / threshold + 1];\n+        for (int i = 0; i < n; i += threshold) {\n+            final int size = Math.min(threshold, n - i); // get size of sub-matrix\n+            final RealMatrix subMatrix = m.getSubMatrix(i, i + size - 1, i, i + size - 1);\n+            decomposition[i / threshold] = new EigenDecomposition(subMatrix);\n+        }\n+        // combine the square roots of sub-matrices\n+        RealMatrix result = MatrixUtils.createRealMatrix(n, n);\n+        for (int i = 0; i < n; i += threshold) {\n+            final int size = Math.min(threshold, n - i); // get size of sub-matrix\n+            final RealMatrix subMatrix = MatrixUtils.createRealMatrix(size, size);\n+            final RealMatrix v = decomposition[i / threshold].getV();\n+            final RealMatrix d = decomposition[i / threshold].getD();\n+            for (int j = 0; j < size; j++) {\n+                final double lambda = d.getEntry(j, j);\n+                if (lambda < 0) {\n+                    throw new IllegalArgumentException(\"Matrix must be positive definite\");\n+                }\n+                final double sqrtLambda = Math.sqrt(lambda);\n+                for (int k = 0; k < size; k++) {\n+                    subMatrix.setEntry(k, j, v.getEntry(k, j) * sqrtLambda);\n+                }\n+            }\n+            result.setSubMatrix(subMatrix.getData(), i, i);\n+        }\n+        return result;\n+    } else {\n+        final EigenDecomposition dec = new EigenDecomposition(m);\n+        return dec.getSquareRoot();\n     }\n }\n+}",
    "result_reason": "org.apache.commons.math3.exception.MathUnsupportedOperationException: unsupported operation",
    "test_result": "FAIL"
}