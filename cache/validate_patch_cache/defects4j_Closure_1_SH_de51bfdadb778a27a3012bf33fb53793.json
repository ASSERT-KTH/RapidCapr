{
    "patch": "      Node child = argList.getFirstChild();\n      while (child != null) {\n        Node next = child.getNext();\n        Var var = fnScope.getVar(child.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(child);\n          compiler.reportCodeChange();\n        } else {\n          // Removing arguments from the middle of the list and also\n          // the right side of the list results in index changes and\n          // therefore all subsequent unreferenced variables are\n          // removed properly. For example:\n          //\n          // function f(a, b, c, d) {} // scope.getVars() =\n          // //   a -> param\n          // //   b -> param\n          // //   c -> param\n          // //   d -> param\n          // f(1, 2, 3, 4);\n          //\n          // After inlining f onto f's call site, the \"a\" and \"b\"\n          // parameters need to be removed but we also want to\n          // remove \"d\". This is the state of the function and\n          // scope before processing the parameters.\n          //\n          // Node: function f(a, b, c, d) {}\n          // Scope.getVars(): a -> param\n          //                  b -> param\n          //                  c -> param\n          //                  d -> param\n          //\n          // We start processing the parameters from left to right. We\n          // remove \"a\" because it isn't referenced but leave \"b\" and\n          // \"c\" in place because they are referenced. This is the\n          // state after processing \"a\".\n          //\n          // Node: function f(b, c, d) {}\n          // Scope.getVars(): b -> param\n          //                  c -> param\n          //                  d -> param\n          //\n          // We move on to process \"b\" but \"c\" has already been seen\n          // to be referenced so this parameter should be removed too.\n          // This is the state after processing \"b\".\n          //\n          // Node: function f(c, d) {}\n          // Scope.getVars(): c -> param\n          //                  d -> param\n          //\n          // Finally, \"c\" and \"d\" are processed and no more parameters\n          // are removed.\n\n          // Remove right parameters if the child was the second to last.\n          if (child.getNext() == null) {\n            Node sibling = child.getPrevious();\n            while (sibling != null) {\n              Node previous = sibling.getPrevious();\n              Var siblingVar = fnScope.getVar(sibling.getString());\n              if (!referenced.contains(siblingVar)) {\n                argList.removeChild(sibling);\n                compiler.reportCodeChange();\n              } else {\n                // Stop removing elements because we got to the first\n                // referenced variable in the list.\n                break;\n              }\n              sibling = previous;\n            }\n          }\n\n          // IMPORTANT: do not remove this!\n          break;\n        }\n        child = next;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..10e53340 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,80 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+      Node child = argList.getFirstChild();\n+      while (child != null) {\n+        Node next = child.getNext();\n+        Var var = fnScope.getVar(child.getString());\n+        if (!referenced.contains(var)) {\n+          argList.removeChild(child);\n+          compiler.reportCodeChange();\n+        } else {\n+          // Removing arguments from the middle of the list and also\n+          // the right side of the list results in index changes and\n+          // therefore all subsequent unreferenced variables are\n+          // removed properly. For example:\n+          //\n+          // function f(a, b, c, d) {} // scope.getVars() =\n+          // //   a -> param\n+          // //   b -> param\n+          // //   c -> param\n+          // //   d -> param\n+          // f(1, 2, 3, 4);\n+          //\n+          // After inlining f onto f's call site, the \"a\" and \"b\"\n+          // parameters need to be removed but we also want to\n+          // remove \"d\". This is the state of the function and\n+          // scope before processing the parameters.\n+          //\n+          // Node: function f(a, b, c, d) {}\n+          // Scope.getVars(): a -> param\n+          //                  b -> param\n+          //                  c -> param\n+          //                  d -> param\n+          //\n+          // We start processing the parameters from left to right. We\n+          // remove \"a\" because it isn't referenced but leave \"b\" and\n+          // \"c\" in place because they are referenced. This is the\n+          // state after processing \"a\".\n+          //\n+          // Node: function f(b, c, d) {}\n+          // Scope.getVars(): b -> param\n+          //                  c -> param\n+          //                  d -> param\n+          //\n+          // We move on to process \"b\" but \"c\" has already been seen\n+          // to be referenced so this parameter should be removed too.\n+          // This is the state after processing \"b\".\n+          //\n+          // Node: function f(c, d) {}\n+          // Scope.getVars(): c -> param\n+          //                  d -> param\n+          //\n+          // Finally, \"c\" and \"d\" are processed and no more parameters\n+          // are removed.\n+\n+          // Remove right parameters if the child was the second to last.\n+          if (child.getNext() == null) {\n+            Node sibling = child.getPrevious();\n+            while (sibling != null) {\n+              Node previous = sibling.getPrevious();\n+              Var siblingVar = fnScope.getVar(sibling.getString());\n+              if (!referenced.contains(siblingVar)) {\n+                argList.removeChild(sibling);\n+                compiler.reportCodeChange();\n+              } else {\n+                // Stop removing elements because we got to the first\n+                // referenced variable in the list.\n+                break;\n+              }\n+              sibling = previous;\n+            }\n+          }\n+\n+          // IMPORTANT: do not remove this!\n+          break;\n+        }\n+        child = next;\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}