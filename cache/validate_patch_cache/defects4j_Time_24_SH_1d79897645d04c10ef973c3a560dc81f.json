{
    "patch": "        boolean restarted = false;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (e.getIllegalFieldValueFailure() != null) {\n                boolean isDate = savedFields[count - 1].isSavedFieldDate();\n                if (isDate) {\n                    int year = savedFields[count - 1].iDate.year().get(millis);\n                    DurationField years = DurationFieldType.years().getField(iChrono);\n                    int difference = e.getIllegalFieldValueFailure().getDurationField().getField(iChrono).getDifferenceAsInt(year, savedFields[count - 1].getSavedValue());\n                    millis = years.add(millis, difference);\n                    if (!restarted) {\n                        for (int i = count - 1; i >= 0; i--) {\n                            savedFields[i].save();\n                        }\n                        restarted = true;\n                    }\n                    millis = computeMillis(resetFields, text);\n                } else {\n                    if (text != null) {\n                        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                    }\n                    throw e;\n                }\n            } else {\n                if (text != null) {\n                    e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                }\n                throw e;\n            }\n        }\n\n        if (!restarted && iSavedFieldsCount > count) {\n            // some fields not parsed, so safe to use defaults\n            // (or save the current state of parsing)\n            savedFields = iSavedFields;\n            int savedFieldsCount = iSavedFieldsCount;\n            boolean savedFieldsShared = iSavedFieldsShared;\n            iSavedFieldsCount = count;  // reduce the unparsed fields count\n            iSavedFields = new SavedField[savedFieldsCount];  // allow size to be reduced\n            System.arraycopy(savedFields, 0, iSavedFields, 0, count);\n            iSavedFieldsShared = false;\n\n            // roll back first\n            millis = computeMillis(resetFields, text);\n            iSavedFieldsCount = savedFieldsCount;\n            iSavedFields = savedFields;\n            iSavedFieldsShared = savedFieldsShared;\n\n            // then try again\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..35c154e5 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,62 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+        boolean restarted = false;\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                millis = savedFields[i].set(millis, resetFields);\n+            }\n+        } catch (IllegalFieldValueException e) {\n+            if (e.getIllegalFieldValueFailure() != null) {\n+                boolean isDate = savedFields[count - 1].isSavedFieldDate();\n+                if (isDate) {\n+                    int year = savedFields[count - 1].iDate.year().get(millis);\n+                    DurationField years = DurationFieldType.years().getField(iChrono);\n+                    int difference = e.getIllegalFieldValueFailure().getDurationField().getField(iChrono).getDifferenceAsInt(year, savedFields[count - 1].getSavedValue());\n+                    millis = years.add(millis, difference);\n+                    if (!restarted) {\n+                        for (int i = count - 1; i >= 0; i--) {\n+                            savedFields[i].save();\n+                        }\n+                        restarted = true;\n+                    }\n+                    millis = computeMillis(resetFields, text);\n+                } else {\n+                    if (text != null) {\n+                        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                    }\n+                    throw e;\n+                }\n+            } else {\n+                if (text != null) {\n+                    e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                }\n+                throw e;\n+            }\n+        }\n+\n+        if (!restarted && iSavedFieldsCount > count) {\n+            // some fields not parsed, so safe to use defaults\n+            // (or save the current state of parsing)\n+            savedFields = iSavedFields;\n+            int savedFieldsCount = iSavedFieldsCount;\n+            boolean savedFieldsShared = iSavedFieldsShared;\n+            iSavedFieldsCount = count;  // reduce the unparsed fields count\n+            iSavedFields = new SavedField[savedFieldsCount];  // allow size to be reduced\n+            System.arraycopy(savedFields, 0, iSavedFields, 0, count);\n+            iSavedFieldsShared = false;\n+\n+            // roll back first\n+            millis = computeMillis(resetFields, text);\n+            iSavedFieldsCount = savedFieldsCount;\n+            iSavedFields = savedFields;\n+            iSavedFieldsShared = savedFieldsShared;\n+\n+            // then try again\n+            for (int i = 0; i < count; i++) {\n+                millis = savedFields[i].set(millis, resetFields);\n+            }\n+        }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}