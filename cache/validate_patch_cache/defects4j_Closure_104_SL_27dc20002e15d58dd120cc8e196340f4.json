{
    "patch": "  /**\n   * Calculates the greatest subtype of the two types with respect to <:.\n   * For non-subtypes, returns null.\n   */\n  static JSType greatestSubtype(JSType type1, JSType type2) {\n    if (type1.isUnknownType() || type2.isUnknownType()) {\n      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    if (type1.isBottom()) {\n      return type2;\n    }\n    if (type2.isBottom()) {\n      return type1;\n    }\n    if (type1.equals(type2)) {\n      return type1;\n    }\n    if (type1.isSubtype(type2)) {\n      return type1;\n    }\n    if (type2.isSubtype(type1)) {\n      return type2;\n    }\n    if (type1.isNumberValueType() && type2.isNumberValueType()) {\n      return getNativeType(JSTypeNative.NUMBER_TYPE);\n    }\n    if (type1.isBooleanValueType() && type2.isBooleanValueType()) {\n      return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n    }\n    if (type1.isStringValueType() && type2.isStringValueType()) {\n      return getNativeType(JSTypeNative.STRING_TYPE);\n    }\n    if (type1.isEnumElementType() && type2.isEnumElementType()) {\n      EnumType e1 = (EnumType) type1;\n      EnumType e2 = (EnumType) type2;\n      return getEnumElementType(e1.getElementsInCommonWith(e2));\n    }\n    if (type1.isAllType() || type2.isAllType()) {\n      return getNativeType(JSTypeNative.ALL_TYPE);\n    }\n    if (type1.isNoneType()) {\n      return type2;\n    }\n    if (type2.isNoneType()) {\n      return type1;\n    }\n\n    UnionType.Builder builder = new UnionType.Builder();\n    if (type1.isUnionType()) {\n      for (JSType alternate : ((UnionType) type1).getAlternates()) {\n        JSType greatestSubtype = greatestSubtype(alternate, type2);\n        if (greatestSubtype != null) {\n          builder.addAlternate(greatestSubtype);\n        }\n      }\n    } else {\n      JSType greatestSubtype = greatestSubtype(type2, type1);\n      if (greatestSubtype != null) {\n        return greatestSubtype;\n      }\n      builder.addAlternate(type1);\n    }\n\n    if (type2.isUnionType()) {\n      for (JSType alternate : ((UnionType) type2).getAlternates()) {\n        JSType greatestSubtype = greatestSubtype(alternate, type1);\n        if (greatestSubtype != null) {\n          builder.addAlternate(greatestSubtype);\n        }\n      }\n    } else {\n      builder.addAlternate(type2);\n    }\n    return builder.build();\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex a9c9a0ae..42fd7112 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -288,7 +288,81 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+  /**\n+   * Calculates the greatest subtype of the two types with respect to <:.\n+   * For non-subtypes, returns null.\n+   */\n+  static JSType greatestSubtype(JSType type1, JSType type2) {\n+    if (type1.isUnknownType() || type2.isUnknownType()) {\n+      return getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+    }\n+    if (type1.isBottom()) {\n+      return type2;\n+    }\n+    if (type2.isBottom()) {\n+      return type1;\n+    }\n+    if (type1.equals(type2)) {\n+      return type1;\n+    }\n+    if (type1.isSubtype(type2)) {\n+      return type1;\n+    }\n+    if (type2.isSubtype(type1)) {\n+      return type2;\n+    }\n+    if (type1.isNumberValueType() && type2.isNumberValueType()) {\n+      return getNativeType(JSTypeNative.NUMBER_TYPE);\n+    }\n+    if (type1.isBooleanValueType() && type2.isBooleanValueType()) {\n+      return getNativeType(JSTypeNative.BOOLEAN_TYPE);\n+    }\n+    if (type1.isStringValueType() && type2.isStringValueType()) {\n+      return getNativeType(JSTypeNative.STRING_TYPE);\n+    }\n+    if (type1.isEnumElementType() && type2.isEnumElementType()) {\n+      EnumType e1 = (EnumType) type1;\n+      EnumType e2 = (EnumType) type2;\n+      return getEnumElementType(e1.getElementsInCommonWith(e2));\n+    }\n+    if (type1.isAllType() || type2.isAllType()) {\n+      return getNativeType(JSTypeNative.ALL_TYPE);\n+    }\n+    if (type1.isNoneType()) {\n+      return type2;\n+    }\n+    if (type2.isNoneType()) {\n+      return type1;\n+    }\n+\n+    UnionType.Builder builder = new UnionType.Builder();\n+    if (type1.isUnionType()) {\n+      for (JSType alternate : ((UnionType) type1).getAlternates()) {\n+        JSType greatestSubtype = greatestSubtype(alternate, type2);\n+        if (greatestSubtype != null) {\n+          builder.addAlternate(greatestSubtype);\n+        }\n+      }\n+    } else {\n+      JSType greatestSubtype = greatestSubtype(type2, type1);\n+      if (greatestSubtype != null) {\n+        return greatestSubtype;\n+      }\n+      builder.addAlternate(type1);\n+    }\n+\n+    if (type2.isUnionType()) {\n+      for (JSType alternate : ((UnionType) type2).getAlternates()) {\n+        JSType greatestSubtype = greatestSubtype(alternate, type1);\n+        if (greatestSubtype != null) {\n+          builder.addAlternate(greatestSubtype);\n+        }\n+      }\n+    } else {\n+      builder.addAlternate(type2);\n+    }\n+    return builder.build();\n+  }\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}