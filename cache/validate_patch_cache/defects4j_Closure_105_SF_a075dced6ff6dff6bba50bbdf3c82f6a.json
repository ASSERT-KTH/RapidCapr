{
    "patch": "void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n    if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n        return;\n    }\n\n    Node arrayNode = left.getFirstChild();\n    Node functionName = arrayNode.getNext();\n\n    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n        return;\n    }\n\n    String joinString = NodeUtil.getStringValue(right);\n    List<Node> arrayFoldedChildren = Lists.newLinkedList();\n    int foldedSize = 0;\n    int numStringElements = 0; //Track number of string elements in array\n    int numNonNullPrimitiveElements = 0; //Track number of non-null primitive elements in array\n    boolean canFold = true; //Whether we're able to fold the arrays\n    Node elem = arrayNode.getFirstChild();\n    while (elem != null) {\n        if (elem.getType() == Token.STRING) {\n            //If it's a string literal, add to folded string and add its length\n            ++numStringElements;\n            foldedSize += elem.getString().length() + 2; //Add 2 for quotes\n            arrayFoldedChildren.add(Node.newString(elem.getString()));\n        } else if(NodeUtil.isImmutableValue(elem) && NodeUtil.getStringValue(elem) != null) {\n            //If it's a non-null primitive element, add to folded string and increment primitive count\n            ++numNonNullPrimitiveElements;\n            String elementValue = NodeUtil.getStringValue(elem);\n            foldedSize += elementValue.length() + 2; //Add 2 for quotes\n            arrayFoldedChildren.add(Node.newString(elementValue));\n        } else {\n            //Otherwise, we can't fold the array\n            canFold = false;\n            break;\n        }\n        foldedSize += joinString.length(); //Add one for the comma, -1 to skip the last comma\n        elem = elem.getNext();\n    }\n\n    if (!canFold) {\n        return;\n    }\n\n    int originalSize = InlineCostEstimator.getCost(n);\n    if (numStringElements + numNonNullPrimitiveElements == 0) {\n        //If the array is empty, replace with empty string\n        Node emptyStringNode = Node.newString(\"\");\n        parent.replaceChild(n, emptyStringNode);\n        t.getCompiler().reportCodeChange();\n        return;\n    } else if (numStringElements + numNonNullPrimitiveElements == 1) {\n        Node foldedStringNode = arrayFoldedChildren.remove(0);\n        if (foldedSize > originalSize) {\n            return;\n        }\n\n        Node foldedNode;\n        if (foldedStringNode.getType() != Token.STRING) {\n            //If only one non-string element, create a new string node containing it and use that as the folded node\n            foldedNode = Node.newString(NodeUtil.getStringValue(foldedStringNode));\n        } else {\n            foldedNode = foldedStringNode;\n        }\n\n        arrayNode.detachChildren();\n        parent.replaceChild(n, foldedNode);\n        t.getCompiler().reportCodeChange();\n        return;\n    } else {\n        Node foldedNode = Node.newString(\"\");\n        for (Node stringNode : arrayFoldedChildren) {\n            //Add each string node to new folded node\n            foldedNode.addChildToBack(stringNode);\n        }\n\n        //Add quotes to folded string\n        Node quoteNode = new Node(Token.STRING, \"\\\"\");\n        Node foldedNodeWithQuotes = new Node(Token.ADD, quoteNode, foldedNode);\n        foldedNodeWithQuotes.addChildToBack(quoteNode);\n        foldedNodeWithQuotes.useSourceInfoIfMissingFromForTree(arrayNode);\n\n        //Concatenate folded string with join string\n        int foldedStringLength = foldedSize - joinString.length(); //Don't count the join string the last time\n        for (int i = 0; i < arrayFoldedChildren.size() - 2; ++i) {\n            //Add the join string length (accounting for numStringElements - 1 commas each time)\n            foldedStringLength += joinString.length() - joinString.length() / numStringElements;\n        }\n        int foldedSizeWithJoin = foldedSize + foldedStringLength;\n        if (foldedSizeWithJoin > originalSize) {\n            return;\n        }\n\n        //Create new folded node with join string\n        Node foldedNodeWithJoin = new Node(Token.ADD, foldedNodeWithQuotes, right.cloneTree());\n        foldedNodeWithJoin.useSourceInfoIfMissingFromForTree(arrayNode);\n\n        //Replace node with folded node with join string\n        arrayNode.detachChildren();\n        parent.replaceChild(n, foldedNodeWithJoin);\n        t.getCompiler().reportCodeChange();\n        return;\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FoldConstants.java b/src/com/google/javascript/jscomp/FoldConstants.java\nindex f6d6a27f..20b0fb17 100644\n--- a/src/com/google/javascript/jscomp/FoldConstants.java\n+++ b/src/com/google/javascript/jscomp/FoldConstants.java\n@@ -1458,95 +1458,110 @@ class FoldConstants extends AbstractPostOrderCallback\n   /**\n    * Try to fold an array join: ['a', 'b', 'c'].join('') -> 'abc';\n    */\n-  void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right,\n-                         Node parent) {\n+void tryFoldStringJoin(NodeTraversal t, Node n, Node left, Node right, Node parent) {\n     if (!NodeUtil.isGetProp(left) || !NodeUtil.isImmutableValue(right)) {\n-      return;\n+        return;\n     }\n \n     Node arrayNode = left.getFirstChild();\n     Node functionName = arrayNode.getNext();\n \n-    if ((arrayNode.getType() != Token.ARRAYLIT) ||\n-        !functionName.getString().equals(\"join\")) {\n-      return;\n+    if ((arrayNode.getType() != Token.ARRAYLIT) || !functionName.getString().equals(\"join\")) {\n+        return;\n     }\n \n     String joinString = NodeUtil.getStringValue(right);\n     List<Node> arrayFoldedChildren = Lists.newLinkedList();\n-    StringBuilder sb = new StringBuilder();\n     int foldedSize = 0;\n+    int numStringElements = 0; //Track number of string elements in array\n+    int numNonNullPrimitiveElements = 0; //Track number of non-null primitive elements in array\n+    boolean canFold = true; //Whether we're able to fold the arrays\n     Node elem = arrayNode.getFirstChild();\n-    // Merges adjacent String nodes.\n     while (elem != null) {\n-      if (NodeUtil.isImmutableValue(elem)) {\n-        if (sb.length() > 0) {\n-          sb.append(joinString);\n-        }\n-        sb.append(NodeUtil.getStringValue(elem));\n-      } else {\n-        if (sb.length() > 0) {\n-          // + 2 for the quotes.\n-          foldedSize += sb.length() + 2;\n-          arrayFoldedChildren.add(Node.newString(sb.toString()));\n-          sb = new StringBuilder();\n+        if (elem.getType() == Token.STRING) {\n+            //If it's a string literal, add to folded string and add its length\n+            ++numStringElements;\n+            foldedSize += elem.getString().length() + 2; //Add 2 for quotes\n+            arrayFoldedChildren.add(Node.newString(elem.getString()));\n+        } else if(NodeUtil.isImmutableValue(elem) && NodeUtil.getStringValue(elem) != null) {\n+            //If it's a non-null primitive element, add to folded string and increment primitive count\n+            ++numNonNullPrimitiveElements;\n+            String elementValue = NodeUtil.getStringValue(elem);\n+            foldedSize += elementValue.length() + 2; //Add 2 for quotes\n+            arrayFoldedChildren.add(Node.newString(elementValue));\n+        } else {\n+            //Otherwise, we can't fold the array\n+            canFold = false;\n+            break;\n         }\n-        foldedSize += InlineCostEstimator.getCost(elem);\n-        arrayFoldedChildren.add(elem);\n-      }\n-      elem = elem.getNext();\n+        foldedSize += joinString.length(); //Add one for the comma, -1 to skip the last comma\n+        elem = elem.getNext();\n     }\n \n-    if (sb.length() > 0) {\n-      // + 2 for the quotes.\n-      foldedSize += sb.length() + 2;\n-      arrayFoldedChildren.add(Node.newString(sb.toString()));\n+    if (!canFold) {\n+        return;\n     }\n-    // one for each comma.\n-    foldedSize += arrayFoldedChildren.size() - 1;\n \n     int originalSize = InlineCostEstimator.getCost(n);\n-    switch (arrayFoldedChildren.size()) {\n-      case 0:\n+    if (numStringElements + numNonNullPrimitiveElements == 0) {\n+        //If the array is empty, replace with empty string\n         Node emptyStringNode = Node.newString(\"\");\n         parent.replaceChild(n, emptyStringNode);\n-        break;\n-\n-      case 1:\n+        t.getCompiler().reportCodeChange();\n+        return;\n+    } else if (numStringElements + numNonNullPrimitiveElements == 1) {\n         Node foldedStringNode = arrayFoldedChildren.remove(0);\n         if (foldedSize > originalSize) {\n-          return;\n+            return;\n         }\n-        arrayNode.detachChildren();\n+\n+        Node foldedNode;\n         if (foldedStringNode.getType() != Token.STRING) {\n-          // If the Node is not a string literal, ensure that\n-          // it is coerced to a string.\n-          Node replacement = new Node(Token.ADD,\n-              Node.newString(\"\"), foldedStringNode);\n-          foldedStringNode = replacement;\n+            //If only one non-string element, create a new string node containing it and use that as the folded node\n+            foldedNode = Node.newString(NodeUtil.getStringValue(foldedStringNode));\n+        } else {\n+            foldedNode = foldedStringNode;\n         }\n-        parent.replaceChild(n, foldedStringNode);\n-        break;\n \n-      default:\n-        // No folding could actually be performed.\n-        if (arrayFoldedChildren.size() == arrayNode.getChildCount()) {\n-          return;\n+        arrayNode.detachChildren();\n+        parent.replaceChild(n, foldedNode);\n+        t.getCompiler().reportCodeChange();\n+        return;\n+    } else {\n+        Node foldedNode = Node.newString(\"\");\n+        for (Node stringNode : arrayFoldedChildren) {\n+            //Add each string node to new folded node\n+            foldedNode.addChildToBack(stringNode);\n         }\n-        int kJoinOverhead = \"[].join()\".length();\n-        foldedSize += kJoinOverhead;\n-        foldedSize += InlineCostEstimator.getCost(right);\n-        if (foldedSize > originalSize) {\n-          return;\n+\n+        //Add quotes to folded string\n+        Node quoteNode = new Node(Token.STRING, \"\\\"\");\n+        Node foldedNodeWithQuotes = new Node(Token.ADD, quoteNode, foldedNode);\n+        foldedNodeWithQuotes.addChildToBack(quoteNode);\n+        foldedNodeWithQuotes.useSourceInfoIfMissingFromForTree(arrayNode);\n+\n+        //Concatenate folded string with join string\n+        int foldedStringLength = foldedSize - joinString.length(); //Don't count the join string the last time\n+        for (int i = 0; i < arrayFoldedChildren.size() - 2; ++i) {\n+            //Add the join string length (accounting for numStringElements - 1 commas each time)\n+            foldedStringLength += joinString.length() - joinString.length() / numStringElements;\n         }\n-        arrayNode.detachChildren();\n-        for (Node node : arrayFoldedChildren) {\n-          arrayNode.addChildToBack(node);\n+        int foldedSizeWithJoin = foldedSize + foldedStringLength;\n+        if (foldedSizeWithJoin > originalSize) {\n+            return;\n         }\n-        break;\n+\n+        //Create new folded node with join string\n+        Node foldedNodeWithJoin = new Node(Token.ADD, foldedNodeWithQuotes, right.cloneTree());\n+        foldedNodeWithJoin.useSourceInfoIfMissingFromForTree(arrayNode);\n+\n+        //Replace node with folded node with join string\n+        arrayNode.detachChildren();\n+        parent.replaceChild(n, foldedNodeWithJoin);\n+        t.getCompiler().reportCodeChange();\n+        return;\n     }\n-    t.getCompiler().reportCodeChange();\n-  }\n+}\n \n   /**\n    * Try to fold array-element. e.g [1, 2, 3][10];",
    "result_reason": "error: no suitable constructor found for Node(int,String)",
    "test_result": "ERROR"
}