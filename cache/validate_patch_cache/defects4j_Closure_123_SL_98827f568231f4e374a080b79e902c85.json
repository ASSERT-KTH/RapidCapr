{
    "patch": "import com.github.javaparser.ast.expr.BinaryExpr.Operator;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.MethodCallExpr;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.NullLiteralExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ForStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.ast.type.PrimitiveType.Primitive;\nimport com.github.javaparser.ast.visitor.GenericVisitor;\nimport com.github.javaparser.ast.visitor.GenericVisitorAdapter;\nimport com.github.javaparser.ast.visitor.ModifierVisitor;\nimport com.github.javaparser.ast.visitor.VoidVisitor;\nimport com.github.javaparser.utils.CodeGenerationUtils;\nimport com.github.javaparser.utils.SourceRoot;\n\nimport java.io.IOException;\nimport java.nio.file.Path;\nimport java.nio.file.Paths;\nimport java.util.List;\nimport java.util.Optional;\n\nimport com.github.javaparser.ast.expr.BinaryExpr;\nimport com.github.javaparser.ast.expr.BooleanLiteralExpr;\nimport com.github.javaparser.ast.expr.CharLiteralExpr;\nimport com.github.javaparser.ast.expr.EnclosedExpr;\nimport com.github.javaparser.ast.expr.Expression;\nimport com.github.javaparser.ast.expr.FieldAccessExpr;\nimport com.github.javaparser.ast.expr.InstanceOfExpr;\nimport com.github.javaparser.ast.expr.IntegerLiteralExpr;\nimport com.github.javaparser.ast.expr.LiteralExpr;\nimport com.github.javaparser.ast.expr.LongLiteralExpr;\nimport com.github.javaparser.ast.expr.Name;\nimport com.github.javaparser.ast.expr.NameExpr;\nimport com.github.javaparser.ast.expr.NullLiteralExpr;\nimport com.github.javaparser.ast.expr.ObjectCreationExpr;\nimport com.github.javaparser.ast.expr.StringLiteralExpr;\nimport com.github.javaparser.ast.expr.ThisExpr;\nimport com.github.javaparser.ast.stmt.BlockStmt;\nimport com.github.javaparser.ast.stmt.ExpressionStmt;\nimport com.github.javaparser.ast.stmt.ForStmt;\nimport com.github.javaparser.ast.stmt.IfStmt;\nimport com.github.javaparser.ast.stmt.Statement;\nimport com.github.javaparser.ast.type.ClassOrInterfaceType;\nimport com.github.javaparser.ast.type.Type;\nimport com.github.javaparser.ast.type.VoidType;\nimport com.github.javaparser.ast.type.WildcardType;\nimport com.github.javaparser.ast.type.WildcardType.WildcardBounds;\nimport com.github.javaparser.ast.type.PrimitiveType;\nimport com.github.javaparser.ast.type.ReferenceType;\nimport com.github.javaparser.ast.visitor.VoidVisitorAdapter;\nimport com.github.javaparser.printer.YamlPrinter;\nimport com.github.javaparser.symbolsolver.JavaSymbolSolver;\nimport com.github.javaparser.symbolsolver.javaparser.Navigator;\nimport com.github.javaparser.symbolsolver.javaparser.Navigator.DIRECTION;\nimport com.github.javaparser.symbolsolver.model.resolution.SymbolReference;\nimport com.github.javaparser.symbolsolver.model.typesystem.ReferenceTypeImpl;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.CombinedTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.JreTypeSolver;\nimport com.github.javaparser.symbolsolver.resolution.typesolvers.ReflectionTypeSolver;\nimport com.github.javaparser.utils.Log;\n\npublic class SimplifyVisitor extends ModifierVisitor<Void> {\n    \n    public static final String SIMPLE_NAME_SEPARATOR = \"_\";\n\n\n    public enum Context {\n        START_OF_EXPR,\n        INSIDE_CONDITION,\n        START_OF_UPDATE,\n        START_OF_INIT,\n        START_OF_FOR,\n        START_OF_WHILE\n    }\n\n    private Context lhsContext = Context.START_OF_EXPR;\n    private Context rhsContext = Context.START_OF_EXPR;\n    private boolean inCondition = false;\n    private boolean inForInit;\n\n    \n    public SimplifyVisitor() {\n        this(null);\n    }\n\n    public SimplifyVisitor(final CompilationUnit cu) {\n        if (cu != null) {\n            inCondition = false;\n        }\n    }\n\n    public SimplifyVisitor(final CombinedTypeSolver typeSolver) {\n        setDefaults(typeSolver);\n        inCondition = false;\n    }\n\n    @Override\n    public MethodCallExpr visit(MethodCallExpr n, Void arg) {\n        if (n.getScope() instanceof NameExpr && ((NameExpr) n.getScope()).getName().getIdentifier().equals(\"system\")) {\n            Optional<Expression> arg0 = n.getArgument(0);\n            if (arg0.isPresent() && arg0.get() instanceof StringLiteralExpr) {\n                StringLiteralExpr slogane = (StringLiteralExpr) arg0.get();\n                if (slogane.getValue().toLowerCase().contains(\"hey\")) {\n                    arg0.get().replace(new StringLiteralExpr(slogane.getValue().toUpperCase()));\n                }\n            }\n        }\n        return super.visit(n, arg);\n    }\n\n    @Override\n    public Expression visit(BinaryExpr n, Void arg) {\n        boolean changeLhs = false;\n        boolean changeRhs = false;\n        lhsContext = rhsContext;\n        inCondition = lhsContext == Context.INSIDE_CONDITION;\n\n        switch (n.getOperator()) {\n            case AND:\n                changeLhs = true;\n                changeRhs = true;\n                rhsContext = Context.INSIDE_CONDITION;\n                break;\n\n            case OR:\n                changeLhs = true;\n                changeRhs = true;\n                rhsContext = Context.INSIDE_CONDITION;\n                break;\n\n            case BINARY_AND:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case BINARY_OR:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case BINARY_XOR:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case LEFT_SHIFT:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case UNSIGNED_RIGHT_SHIFT:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case SIGNED_RIGHT_SHIFT:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case DIVIDE:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case EQUALS:\n                changeRhs = true;\n                break;\n\n            case GREATER:\n                changeRhs = true;\n                break;\n\n            case GREATER_EQUALS:\n                changeRhs = true;\n                break;\n\n            case LESS:\n                changeRhs = true;\n                break;\n\n            case LESS_EQUALS:\n                changeRhs = true;\n                break;\n\n            case MINUS:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case NOT_EQUALS:\n                changeRhs = true;\n                break;\n\n            case PLUS:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case REMAINDER:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            case TIMES:\n                changeLhs = true;\n                changeRhs = true;\n                break;\n\n            default:\n                break;\n        }\n\n        if (changeLhs) {\n            n.setLeft(n.getLeft().accept(this, arg));\n        }\n        if (changeRhs) {\n            n.setRight(n.getRight().accept(this, arg));\n        }\n        /*\n         * don't bother simplifying identity operations with boolean literals\n         */\n        if (inCondition && (n.getOperator() == Operator.AND || n.getOperator() == Operator.OR)) {\n            Expression lhs = n.getLeft();\n            Expression rhs = n.getRight();\n            Optional<BooleanLiteralExpr> lhsBool = lhs.findFirst(BooleanLiteralExpr.class);\n            Optional<BooleanLiteralExpr> rhsBool = rhs.findFirst(BooleanLiteralExpr.class);\n            if (lhsBool.isPresent() && rhsBool.isPresent()) {\n                boolean lhsVal = lhsBool.get().getValue();\n                boolean rhsVal = rhsBool.get().getValue();\n                if ((lhsVal && n.getOperator() == Operator.OR) || (!lhsVal && n.getOperator() == Operator.AND)) {\n                    return new BooleanLiteralExpr(rhsVal);\n                } else {\n                    return new BooleanLiteralExpr(lhsVal);\n                }\n            }\n        }\n        return n;\n    }\n\n    @Override\n    public Expression visit(BooleanLiteralExpr n, Void arg) {\n        if (inCondition) {\n            return n;\n        } else {\n            return super.visit(n, arg);\n        }\n    }\n\n    @Override\n    public Statement visit(ForStmt n, Void arg) {\n        inForInit = true;\n        n.setInitialization(n.getInitialization().accept(this, arg));\n        inForInit = false;\n        n.setCompare(n.getCompare().map(c -> c.accept(this, arg)));\n        n.setUpdate(n.getUpdate().stream().map(u -> u.accept(this, arg)).collect(Collectors.toList()));\n        n.setBody(n.getBody().accept(this, arg));\n        return n;\n    }\n\n    @Override\n    public Expression visit(InstanceOfExpr n, Void arg) {\n        return new BooleanLiteralExpr(!n.checkType().isErroneous());\n    }\n\n    /**\n     * Don't bother with unnecessary ternaries\n     *\n     * @param n an EnclosedExpr node\n     */\n    @Override\n    public Expression visit(EnclosedExpr n, Void arg) {\n        if (n.getInner() == null || n.getInner().isNameExpr() || n.getInner().isLiteralExpr() || \n                n.getInner().isNullLiteralExpr() || n.getInner().isInstanceOfExpr() || \n                n.getInner().isFieldAccessExpr() || n.getInner().isInstanceOfExpr()) {\n            return super.visit(n, arg);\n        }\n        if (n.getParentNode().isPresent() && n.getParentNode().get().isConditionalExpr()) {\n            return super.visit(n, arg);\n        }\n        return n.getInner().accept(this, arg);\n    }\n\n    @Override\n    public Expression visit(IntegerLiteralExpr n, Void arg) {\n        if (inCondition) {\n            return n;\n        } else {\n            return super.visit(n, arg);\n        }\n    }\n\n    public static String toSimpleName(NameExpr n) {\n        String id = n.getNameAsString();\n        if (id.contains(\".\")) {\n            return \"_\" + id.replaceAll(\"\\\\.\", SIMPLE_NAME_SEPARATOR);\n        } else {\n            return id;\n        }\n\n    }\n\n    public static String toSimpleName(String id) {\n        if (id.contains(\".\")) {\n            return \"_\" + id.replaceAll(\"\\\\.\", SIMPLE_NAME_SEPARATOR);\n        } else {\n            return id;\n        }\n    }\n\n    public static NameExpr toNameExpr(String id) {\n        if (id.contains(SIMPLE_NAME_SEPARATOR)) {\n            return new NameExpr(id.replaceAll(SIMPLE_NAME_SEPARATOR, \"\\\\.\"));\n        } else {\n            return new NameExpr(id);\n        }\n    }\n\n    public static NameExpr toNameExpr(String id, int beginLine, int beginColumn, int endLine, int endColumn) {\n        NameExpr n = toNameExpr(id);\n        n.setBegin(new Position(beginLine, beginColumn));\n        n.setEnd(new Position(endLine, endColumn));\n        return n;\n    }\n\n    public static SimpleName toSimpleName(String id, int beginLine, int beginColumn, int endLine, int endColumn) {\n        SimpleName n = new SimpleName(id);\n        n.setBegin(new Position(beginLine, beginColumn));\n        n.setEnd(new Position(endLine, endColumn));\n        return n;\n    }\n\n    public static ClassOrInterfaceType toClassOrInterfaceType(String id) {\n        if (id.contains(\".\")) {\n            String[] ids = id.split(\"\\\\.\");\n            String simpleName = ids[ids.length - 1];\n            String packageName = id.substring(0, id.length() - simpleName.length() - 1);\n            return new ClassOrInterfaceType(null, toSimpleName(simpleName), toClassOrInterfaceType(packageName));\n        } else {\n            return new ClassOrInterfaceType(null, toSimpleName(id), null);\n        }\n    }\n\n    public static Expression getCondition(Statement n) {\n        if (n instanceof IfStmt) {\n            return ((IfStmt) n).getCondition();\n        } else if (n instanceof ForStmt) {\n            return ((ForStmt) n).getCompare().get();\n        } else if (n instanceof WhileStmt) {\n            return ((WhileStmt) n).getCondition();\n        } else {\n            return null;\n        }\n    }\n\n    public static List<Statement> getStatements(Statement n) {\n        if (n instanceof BlockStmt) {\n            return ((BlockStmt) n).getStatements();\n        } else if (n instanceof ForStmt) {\n            return ((ForStmt) n).getBody().asBlockStmt().getStatements();\n        } else if (n instanceof WhileStmt) {\n            return ((WhileStmt) n).getBody().asBlockStmt().getStatements();\n        } else {\n            return null;\n        }\n    }\n\n    public static boolean isNop(Statement s) {\n        if (s instanceof ExpressionStmt) {\n            Expression e = ((ExpressionStmt) s).getExpression();\n            return e instanceof LiteralExpr || e instanceof NameExpr && ((NameExpr) e).getNameAsString().equals(\"this\");\n        }\n        return false;\n    }\n\n    /**\n     * Replace the given node with a throw statement that throws the given throwable object.\n     * \n     * @param throwable throwable object to throw\n     * @param node node to replace with throw statement\n     * @return replaced throw statement\n     */\n    public static ThrowStmt surroundWithThrowStmt(Throwable throwable, Node node) {\n        return new ThrowStmt(new ObjectCreationExpr(null, toClassOrInterfaceType(throwable.getClass().getName()), \n                new NodeList<>(), new NodeList<>(), null));\n    }\n\n    private void setDefaults(CombinedTypeSolver typeSolver) {\n        if (typeSolver == null) {\n            // combine multiple type solvers to get the correct results\n            ReflectionTypeSolver reflectionTypeSolver = new ReflectionTypeSolver();\n            JreTypeSolver jreTypeSolver = new JreTypeSolver();\n            CombinedTypeSolver combinedTypeSolver = new CombinedTypeSolver();\n            combinedTypeSolver.add(reflectionTypeSolver);\n            combinedTypeSolver.add(jreTypeSolver);\n            JavaSymbolSolver symbolSolver = new JavaSymbolSolver(combinedTypeSolver);\n            getContext().put(JavaSymbolSolver.class, symbolSolver);\n        } else {\n            getContext().put(JavaSymbolSolver.class, new JavaSymbolSolver(typeSolver));\n        }\n        // by default no comments are printed\n        setShouldPrintComments(false);\n    }\n\n    public static CompilationUnit parse(Path path) throws IOException {\n        CombinedTypeSolver typeSolver = new CombinedTypeSolver();\n        typeSolver.add(new ReflectionTypeSolver());\n        return CodeGenerationUtils.parseFile(path, typeSolver);\n    }\n}  ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 54eb5cf8..6267f6c9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -104,7 +104,7 @@ class CodeGenerator {\n     add(n, Context.OTHER);\n   }\n \n-  void add(Node n, Context context) {\n+\n     if (!cc.continueProcessing()) {\n       return;\n     }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}