{
    "patch": "import com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\n\nimport java.util.HashSet;\nimport java.util.Set;\n\npublic class IRFactory {\n    private static final Set<String> ALLOWED_DIRECTIVES = new HashSet<>();\n\n    static {\n        ALLOWED_DIRECTIVES.add(\"use strict\");\n    }\n\n    private class TransformDispatcher implements TypeSafeDispatcher {\n        @Override\n        public Node processArrayAccess(ArrayAccess arrayAccess) {\n            return newNode(\n                Token.GETELEM,\n                transform(arrayAccess.getTarget()),\n                transform(arrayAccess.getIndex()));\n        }\n\n        @Override\n        public Node processBinaryExpr(BinaryExpr binaryExpr) {\n            return newNode(\n                transformTokenType(binaryExpr.getOperator()),\n                transform(binaryExpr.getLeft()),\n                transform(binaryExpr.getRight()));\n        }\n\n        @Override\n        public Node processBlock(Block blockNode) {\n            return processGeneric(blockNode);\n        }\n\n        @Override\n        public Node processBooleanLiteral(BooleanLiteral boolNode) {\n            return newNode(boolNode.getValue() ? Token.TRUE : Token.FALSE);\n        }\n\n        @Override\n        public Node processBreakStatement(BreakStatement statementNode) {\n            Node node = newNode(Token.BREAK);\n            if (statementNode.getBreakLabel() != null) {\n                Node labelName = transform(statementNode.getBreakLabel());\n                // Change the NAME to LABEL_NAME\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        public Node processCatchClause(CatchClause clauseNode) {\n            AstNode catchVar = clauseNode.getVarName();\n            Node node = newNode(Token.CATCH, transform(catchVar));\n            if (clauseNode.getCatchCondition() != null) {\n                errorReporter.error(\n                    \"Catch clauses are not supported\",\n                    sourceName,\n                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n            }\n            node.addChildToBack(transformBlock(clauseNode.getBody()));\n            return node;\n        }\n\n        @Override\n        public Node processConditionalExpression(ConditionalExpression exprNode) {\n            return newNode(\n                Token.HOOK,\n                transform(exprNode.getTestExpression()),\n                transform(exprNode.getTrueExpression()),\n                transform(exprNode.getFalseExpression()));\n        }\n\n        @Override\n        public Node processContinueStatement(ContinueStatement statementNode) {\n            Node node = newNode(Token.CONTINUE);\n            if (statementNode.getLabel() != null) {\n                Node labelName = transform(statementNode.getLabel());\n                // Change the NAME to LABEL_NAME\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        public Node processDoLoop(DoLoop loopNode) {\n            return newNode(\n                Token.DO,\n                transformBlock(loopNode.getBody()),\n                transform(loopNode.getCondition()));\n        }\n\n        @Override\n        public Node processElementGet(ElementGet getNode) {\n            return newNode(\n                Token.GETELEM,\n                transform(getNode.getTarget()),\n                transform(getNode.getElement()));\n        }\n\n        @Override\n        public Node processEmptyExpression(EmptyExpression exprNode) {\n            Node node = newNode(Token.EMPTY);\n            return node;\n        }\n\n        @Override\n        public Node processExpressionStatement(ExpressionStatement statementNode) {\n            Node node = newNode(transformTokenType(statementNode.getType()));\n            node.addChildToBack(transform(statementNode.getExpression()));\n            return node;\n        }\n\n        @Override\n        public Node processForInLoop(ForInLoop loopNode) {\n            // Create a new FOR node\n            Node node = newNode(Token.FOR);\n\n            // Create a new VAR node for the loop variable\n            Node varNode = newNode(Token.VAR);\n\n            // Create a new NAME node for the loop variable\n            Node loopVarNode = newNode(Token.NAME, loopNode.getIterator().toSource());\n\n            // Add the NAME node to the VAR node\n            varNode.addChildToBack(loopVarNode);\n\n            // Create a new IN node\n            Node inNode = newNode(Token.IN);\n\n            // Add the VAR node and the iterated object to the FOR node\n            node.addChildToBack(varNode);\n            node.addChildToBack(transform(loopNode.getIteratedObject(), inNode));\n\n            // Transform the loop body using the `transformBlock` function\n            node.addChildToBack(transformBlock(loopNode.getBody()));\n\n            return node;\n        }\n\n        @Override\n        public Node processFunctionCall(FunctionCall callNode) {\n            // Special handling for \"use strict\" directive\n            if (isDirective(callNode.getTarget())) {\n                String directive = callNode.getArguments().iterator().next().toSource();\n                if (!ALLOWED_DIRECTIVES.contains(directive)) {\n                    errorReporter.warning(\n                        \"Illegal 'use strict' directive\",\n                        sourceName,\n                        callNode.getLineno(),\n                        callNode.getCharno());\n                }\n            }\n\n            return newNode(Token.CALL, transform(callNode.getTarget()), transform(callNode.getArguments()));\n        }\n\n        @Override\n        public Node processFunctionNode(FunctionNode functionNode) {\n            Node node = createFunctionNode(functionNode.isExpressionClosure());\n            if (functionNode.getFunctionName() != null) {\n                node.addChildToBack(transform(functionNode.getFunctionName()));\n            }\n            for (AstNode param : functionNode.getParams()) {\n                node.addChildToBack(transform(param));\n            }\n            node.addChildToBack(transform(functionNode.getBody()));\n            return node;\n        }\n\n        @Override\n        public Node processIfStatement(IfStatement statementNode) {\n            Node node = newNode(Token.IF, transform(statementNode.getCondition()));\n            node.addChildToBack(transform(statementNode.getThenPart()));\n            if (statementNode.getElsePart() != null) {\n                node.addChildToBack(transform(statementNode.getElsePart()));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processInfixExpression(InfixExpression infixExpression) {\n            Node left = transform(infixExpression.getLeft());\n            Node right = transform(infixExpression.getRight());\n            Token operator = transformTokenType(infixExpression.getOperator());\n            if (infixExpression.isAssignment()) {\n                return newNode(Token.ASSIGN, left, newNode(operator, left, right));\n            } else {\n                return newNode(operator, left, right);\n            }\n        }\n\n        @Override\n        public Node processKeywordLiteral(KeywordLiteral literalNode) {\n            int tokenType;\n            switch (literalNode.getType()) {\n                case Token.NULL:\n                    tokenType = Token.NULL;\n                    break;\n                case Token.THIS:\n                    tokenType = Token.THIS;\n                    break;\n                default:\n                    throw new IllegalArgumentException(\"Unsupported keyword literal: \" + literalNode.toSource());\n            }\n            return newNode(tokenType);\n        }\n\n        @Override\n        public Node processName(Name nameNode) {\n            return newNode(Token.NAME, nameNode.getIdentifier());\n        }\n\n        @Override\n        public Node processNewExpression(NewExpression newExpression) {\n            return newNode(Token.NEW, transform(newExpression.getTarget()), transform(newExpression.getArguments()));\n        }\n\n        @Override\n        public Node processNumberLiteral(NumberLiteral numberNode) {\n            return newNode(Token.NUMBER, numberNode.getValue());\n        }\n\n        @Override\n        public Node processObjectLiteral(ObjectLiteral objNode) {\n            Node node = newNode(Token.OBJECTLIT);\n            for (ObjectProperty prop : objNode.getElements()) {\n                node.addChildToBack(transform(prop));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processObjectProperty(ObjectProperty propNode) {\n            Node key = transform(propNode.getLeft());\n            Node val = transform(propNode.getRight());\n            return newNode(Token.OBJECT_PROP, key, val);\n        }\n\n        @Override\n        public Node processParenthesizedExpression(ParenthesizedExpression parenthesizedExpression) {\n            return transform(parenthesizedExpression.getExpression());\n        }\n\n        @Override\n        public Node processRegExpLiteral(RegExpLiteral regexpNode) {\n            return newNode(Token.REGEXP, regexpNode.getValue(), regexpNode.getFlags());\n        }\n\n        @Override\n        public Node processReturnStatement(ReturnStatement statementNode) {\n            Node node = newNode(Token.RETURN);\n            if (statementNode.getReturnValue() != null) {\n                node.addChildToBack(transform(statementNode.getReturnValue()));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processStringLiteral(StringLiteral stringNode) {\n            return newNode(Token.STRING, stringNode.getValue());\n        }\n\n        @Override\n        public Node processSwitchCase(SwitchCase switchCase) {\n            Node node;\n            if (switchCase.getExpression() == null) {\n                node = newNode(Token.DEFAULT);\n            } else {\n                node = newNode(Token.CASE, transform(switchCase.getExpression()));\n            }\n            for (AstNode stmt : switchCase.getStatements()) {\n                node.addChildToBack(transform(stmt));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processSwitchStatement(SwitchStatement statementNode) {\n            Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n            for (SwitchCase switchCase : statementNode.getCases()) {\n                node.addChildToBack(transform(switchCase));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processThrowStatement(ThrowStatement statementNode) {\n            return newNode(Token.THROW, transform(statementNode.getExpression()));\n        }\n\n        @Override\n        public Node processTryStatement(TryStatement statementNode) {\n            Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n            if (statementNode.getCatchBlock() != null) {\n                node.addChildToBack(transform(statementNode.getCatchBlock()));\n            }\n            if (statementNode.getFinallyBlock() != null) {\n                node.addChildToBack(\n                    newNode(Token.BLOCK, transformBlock(statementNode.getFinallyBlock())));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processUnaryExpression(UnaryExpression unaryExpression) {\n            Token type = transformTokenType(unaryExpression.getOperator());\n            if (unaryExpression.isPrefix()) {\n                return newNode(type, transform(unaryExpression.getOperand()));\n            } else {\n                return newNode(type, transform(unaryExpression.getOperand()), null);\n            }\n        }\n\n        @Override\n        public Node processVariableDeclaration(VariableDeclaration decl) {\n            Node node = newNode(Token.VAR);\n            for (VariableInitializer init : decl.getVariables()) {\n                node.addChildToBack(transform(init));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processVariableInitializer(VariableInitializer initializer) {\n            Node node = newNode(Token.NAME, initializer.getTarget().getIdentifier());\n            if (initializer.getInitializer() != null) {\n                node.addChildToBack(transform(initializer.getInitializer()));\n            }\n            return newNode(Token.VAR, node);\n        }\n\n        @Override\n        public Node processWhileLoop(WhileLoop loopNode) {\n            return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n        }\n    }\n\n    private final TransformDispatcher transformDispatcher = new TransformDispatcher();\n\n    private Node processGeneric(AstNode node) {\n        Node newNode = newNode(transformTokenType(node.getType()));\n        for (AstNode child : node) {\n            newNode.addChildToBack(transform(child));\n        }\n        return newNode;\n    }\n\n    private boolean isDirective(AstNode node) {\n        if (node == null) {\n            return false;\n        }\n\n        int type = node.getType();\n        if (type != Token.EXPR_RESULT) {\n            return false;\n        }\n\n        AstNode expr = ((ExpressionStatement) node).getExpression();\n        if (expr.getType() != Token.STRING) {\n            return false;\n        }\n\n        return ALLOWED_DIRECTIVES.contains(expr.getString());\n    }\n\n    Node transform(AstNode node) {\n        return node == null ? null : node.dispatch(transformDispatcher);\n    }\n\n    Node transform(AstNode node, Node newNode) {\n        Node result = transform(node);\n        if (result != null) {\n            newNode.addChildToBack(result);\n        }\n        return newNode;\n    }\n\n    Token transformTokenType(int type) {\n        return Token.valueOf(AstNode.operatorToString(type));\n    }\n\n    Node createFunctionNode(boolean isExpressionClosure) {\n        return isExpressionClosure ? newNode(Token.FUNCTION) : newNode(Token.FUNCTION_STATEMENT);\n    }\n\n    Node newNode(Token token) {\n        return new Node(token);\n    }\n\n    Node newNode(Token token, String value) {\n        return new Node(token, new Node(value));\n    }\n\n    Node newNode(Token token, Node... children) {\n        Node node = new Node(token);\n        for (Node child : children) {\n            if (child != null) {\n                node.addChildToBack(child);\n            }\n        }\n        return node;\n    }\n\n    Node transformBlock(AstNode node) {\n        if (node instanceof Block) {\n            node = node.getFirstChild(); // unwrap BLOCK node\n        }\n        return newNode(Token.BLOCK, transform(node));\n    }\n\n    Node transformBlock(Block blockNode) {\n        Node block = newNode(Token.BLOCK);\n        for (AstNode child : blockNode) {\n            block.addChildToBack(transform(child));\n        }\n        return block;\n    }\n\n    Node transformName(Name nameNode) {\n        return newNode(Token.NAME, nameNode.getIdentifier());\n    }\n\n    Node transformString(String stringNode) {\n        return newNode(Token.STRING, stringNode);\n    }\n\n    Node transformInitializer(VariableInitializer varInitNode) {\n        if (varInitNode.getInitializer() == null) {\n            return transformName(varInitNode.getTarget());\n        } else {\n            return newNode(\n                Token.ASSIGN,\n                transformName(varInitNode.getTarget()),\n                transform(varInitNode.getInitializer()));\n        }\n    }\n\n    Node transformFunctio",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..daeed23a 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,449 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+\n+import java.util.HashSet;\n+import java.util.Set;\n+\n+public class IRFactory {\n+    private static final Set<String> ALLOWED_DIRECTIVES = new HashSet<>();\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    static {\n+        ALLOWED_DIRECTIVES.add(\"use strict\");\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    private class TransformDispatcher implements TypeSafeDispatcher {\n+        @Override\n+        public Node processArrayAccess(ArrayAccess arrayAccess) {\n+            return newNode(\n+                Token.GETELEM,\n+                transform(arrayAccess.getTarget()),\n+                transform(arrayAccess.getIndex()));\n+        }\n+\n+        @Override\n+        public Node processBinaryExpr(BinaryExpr binaryExpr) {\n+            return newNode(\n+                transformTokenType(binaryExpr.getOperator()),\n+                transform(binaryExpr.getLeft()),\n+                transform(binaryExpr.getRight()));\n+        }\n+\n+        @Override\n+        public Node processBlock(Block blockNode) {\n+            return processGeneric(blockNode);\n+        }\n+\n+        @Override\n+        public Node processBooleanLiteral(BooleanLiteral boolNode) {\n+            return newNode(boolNode.getValue() ? Token.TRUE : Token.FALSE);\n+        }\n+\n+        @Override\n+        public Node processBreakStatement(BreakStatement statementNode) {\n+            Node node = newNode(Token.BREAK);\n+            if (statementNode.getBreakLabel() != null) {\n+                Node labelName = transform(statementNode.getBreakLabel());\n+                // Change the NAME to LABEL_NAME\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processCatchClause(CatchClause clauseNode) {\n+            AstNode catchVar = clauseNode.getVarName();\n+            Node node = newNode(Token.CATCH, transform(catchVar));\n+            if (clauseNode.getCatchCondition() != null) {\n+                errorReporter.error(\n+                    \"Catch clauses are not supported\",\n+                    sourceName,\n+                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+            }\n+            node.addChildToBack(transformBlock(clauseNode.getBody()));\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processConditionalExpression(ConditionalExpression exprNode) {\n+            return newNode(\n+                Token.HOOK,\n+                transform(exprNode.getTestExpression()),\n+                transform(exprNode.getTrueExpression()),\n+                transform(exprNode.getFalseExpression()));\n+        }\n+\n+        @Override\n+        public Node processContinueStatement(ContinueStatement statementNode) {\n+            Node node = newNode(Token.CONTINUE);\n+            if (statementNode.getLabel() != null) {\n+                Node labelName = transform(statementNode.getLabel());\n+                // Change the NAME to LABEL_NAME\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processDoLoop(DoLoop loopNode) {\n+            return newNode(\n+                Token.DO,\n+                transformBlock(loopNode.getBody()),\n+                transform(loopNode.getCondition()));\n+        }\n+\n+        @Override\n+        public Node processElementGet(ElementGet getNode) {\n+            return newNode(\n+                Token.GETELEM,\n+                transform(getNode.getTarget()),\n+                transform(getNode.getElement()));\n+        }\n+\n+        @Override\n+        public Node processEmptyExpression(EmptyExpression exprNode) {\n+            Node node = newNode(Token.EMPTY);\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processExpressionStatement(ExpressionStatement statementNode) {\n+            Node node = newNode(transformTokenType(statementNode.getType()));\n+            node.addChildToBack(transform(statementNode.getExpression()));\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processForInLoop(ForInLoop loopNode) {\n+            // Create a new FOR node\n+            Node node = newNode(Token.FOR);\n+\n+            // Create a new VAR node for the loop variable\n+            Node varNode = newNode(Token.VAR);\n+\n+            // Create a new NAME node for the loop variable\n+            Node loopVarNode = newNode(Token.NAME, loopNode.getIterator().toSource());\n+\n+            // Add the NAME node to the VAR node\n+            varNode.addChildToBack(loopVarNode);\n+\n+            // Create a new IN node\n+            Node inNode = newNode(Token.IN);\n+\n+            // Add the VAR node and the iterated object to the FOR node\n+            node.addChildToBack(varNode);\n+            node.addChildToBack(transform(loopNode.getIteratedObject(), inNode));\n+\n+            // Transform the loop body using the `transformBlock` function\n+            node.addChildToBack(transformBlock(loopNode.getBody()));\n+\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processFunctionCall(FunctionCall callNode) {\n+            // Special handling for \"use strict\" directive\n+            if (isDirective(callNode.getTarget())) {\n+                String directive = callNode.getArguments().iterator().next().toSource();\n+                if (!ALLOWED_DIRECTIVES.contains(directive)) {\n+                    errorReporter.warning(\n+                        \"Illegal 'use strict' directive\",\n+                        sourceName,\n+                        callNode.getLineno(),\n+                        callNode.getCharno());\n+                }\n+            }\n+\n+            return newNode(Token.CALL, transform(callNode.getTarget()), transform(callNode.getArguments()));\n+        }\n+\n+        @Override\n+        public Node processFunctionNode(FunctionNode functionNode) {\n+            Node node = createFunctionNode(functionNode.isExpressionClosure());\n+            if (functionNode.getFunctionName() != null) {\n+                node.addChildToBack(transform(functionNode.getFunctionName()));\n+            }\n+            for (AstNode param : functionNode.getParams()) {\n+                node.addChildToBack(transform(param));\n+            }\n+            node.addChildToBack(transform(functionNode.getBody()));\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processIfStatement(IfStatement statementNode) {\n+            Node node = newNode(Token.IF, transform(statementNode.getCondition()));\n+            node.addChildToBack(transform(statementNode.getThenPart()));\n+            if (statementNode.getElsePart() != null) {\n+                node.addChildToBack(transform(statementNode.getElsePart()));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processInfixExpression(InfixExpression infixExpression) {\n+            Node left = transform(infixExpression.getLeft());\n+            Node right = transform(infixExpression.getRight());\n+            Token operator = transformTokenType(infixExpression.getOperator());\n+            if (infixExpression.isAssignment()) {\n+                return newNode(Token.ASSIGN, left, newNode(operator, left, right));\n+            } else {\n+                return newNode(operator, left, right);\n+            }\n+        }\n+\n+        @Override\n+        public Node processKeywordLiteral(KeywordLiteral literalNode) {\n+            int tokenType;\n+            switch (literalNode.getType()) {\n+                case Token.NULL:\n+                    tokenType = Token.NULL;\n+                    break;\n+                case Token.THIS:\n+                    tokenType = Token.THIS;\n+                    break;\n+                default:\n+                    throw new IllegalArgumentException(\"Unsupported keyword literal: \" + literalNode.toSource());\n+            }\n+            return newNode(tokenType);\n+        }\n+\n+        @Override\n+        public Node processName(Name nameNode) {\n+            return newNode(Token.NAME, nameNode.getIdentifier());\n+        }\n+\n+        @Override\n+        public Node processNewExpression(NewExpression newExpression) {\n+            return newNode(Token.NEW, transform(newExpression.getTarget()), transform(newExpression.getArguments()));\n+        }\n+\n+        @Override\n+        public Node processNumberLiteral(NumberLiteral numberNode) {\n+            return newNode(Token.NUMBER, numberNode.getValue());\n+        }\n+\n+        @Override\n+        public Node processObjectLiteral(ObjectLiteral objNode) {\n+            Node node = newNode(Token.OBJECTLIT);\n+            for (ObjectProperty prop : objNode.getElements()) {\n+                node.addChildToBack(transform(prop));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processObjectProperty(ObjectProperty propNode) {\n+            Node key = transform(propNode.getLeft());\n+            Node val = transform(propNode.getRight());\n+            return newNode(Token.OBJECT_PROP, key, val);\n+        }\n+\n+        @Override\n+        public Node processParenthesizedExpression(ParenthesizedExpression parenthesizedExpression) {\n+            return transform(parenthesizedExpression.getExpression());\n+        }\n+\n+        @Override\n+        public Node processRegExpLiteral(RegExpLiteral regexpNode) {\n+            return newNode(Token.REGEXP, regexpNode.getValue(), regexpNode.getFlags());\n+        }\n+\n+        @Override\n+        public Node processReturnStatement(ReturnStatement statementNode) {\n+            Node node = newNode(Token.RETURN);\n+            if (statementNode.getReturnValue() != null) {\n+                node.addChildToBack(transform(statementNode.getReturnValue()));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processStringLiteral(StringLiteral stringNode) {\n+            return newNode(Token.STRING, stringNode.getValue());\n+        }\n+\n+        @Override\n+        public Node processSwitchCase(SwitchCase switchCase) {\n+            Node node;\n+            if (switchCase.getExpression() == null) {\n+                node = newNode(Token.DEFAULT);\n+            } else {\n+                node = newNode(Token.CASE, transform(switchCase.getExpression()));\n+            }\n+            for (AstNode stmt : switchCase.getStatements()) {\n+                node.addChildToBack(transform(stmt));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processSwitchStatement(SwitchStatement statementNode) {\n+            Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+            for (SwitchCase switchCase : statementNode.getCases()) {\n+                node.addChildToBack(transform(switchCase));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processThrowStatement(ThrowStatement statementNode) {\n+            return newNode(Token.THROW, transform(statementNode.getExpression()));\n+        }\n+\n+        @Override\n+        public Node processTryStatement(TryStatement statementNode) {\n+            Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+            if (statementNode.getCatchBlock() != null) {\n+                node.addChildToBack(transform(statementNode.getCatchBlock()));\n+            }\n+            if (statementNode.getFinallyBlock() != null) {\n+                node.addChildToBack(\n+                    newNode(Token.BLOCK, transformBlock(statementNode.getFinallyBlock())));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processUnaryExpression(UnaryExpression unaryExpression) {\n+            Token type = transformTokenType(unaryExpression.getOperator());\n+            if (unaryExpression.isPrefix()) {\n+                return newNode(type, transform(unaryExpression.getOperand()));\n+            } else {\n+                return newNode(type, transform(unaryExpression.getOperand()), null);\n+            }\n+        }\n+\n+        @Override\n+        public Node processVariableDeclaration(VariableDeclaration decl) {\n+            Node node = newNode(Token.VAR);\n+            for (VariableInitializer init : decl.getVariables()) {\n+                node.addChildToBack(transform(init));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processVariableInitializer(VariableInitializer initializer) {\n+            Node node = newNode(Token.NAME, initializer.getTarget().getIdentifier());\n+            if (initializer.getInitializer() != null) {\n+                node.addChildToBack(transform(initializer.getInitializer()));\n+            }\n+            return newNode(Token.VAR, node);\n+        }\n+\n+        @Override\n+        public Node processWhileLoop(WhileLoop loopNode) {\n+            return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n+        }\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private final TransformDispatcher transformDispatcher = new TransformDispatcher();\n+\n+    private Node processGeneric(AstNode node) {\n+        Node newNode = newNode(transformTokenType(node.getType()));\n+        for (AstNode child : node) {\n+            newNode.addChildToBack(transform(child));\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    private boolean isDirective(AstNode node) {\n+        if (node == null) {\n+            return false;\n+        }\n+\n+        int type = node.getType();\n+        if (type != Token.EXPR_RESULT) {\n+            return false;\n+        }\n+\n+        AstNode expr = ((ExpressionStatement) node).getExpression();\n+        if (expr.getType() != Token.STRING) {\n+            return false;\n+        }\n+\n+        return ALLOWED_DIRECTIVES.contains(expr.getString());\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    Node transform(AstNode node) {\n+        return node == null ? null : node.dispatch(transformDispatcher);\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    Node transform(AstNode node, Node newNode) {\n+        Node result = transform(node);\n+        if (result != null) {\n+            newNode.addChildToBack(result);\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    Token transformTokenType(int type) {\n+        return Token.valueOf(AstNode.operatorToString(type));\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    Node createFunctionNode(boolean isExpressionClosure) {\n+        return isExpressionClosure ? newNode(Token.FUNCTION) : newNode(Token.FUNCTION_STATEMENT);\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    Node newNode(Token token) {\n+        return new Node(token);\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    Node newNode(Token token, String value) {\n+        return new Node(token, new Node(value));\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    Node newNode(Token token, Node... children) {\n+        Node node = new Node(token);\n+        for (Node child : children) {\n+            if (child != null) {\n+                node.addChildToBack(child);\n+            }\n+        }\n+        return node;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    Node transformBlock(AstNode node) {\n+        if (node instanceof Block) {\n+            node = node.getFirstChild(); // unwrap BLOCK node\n+        }\n+        return newNode(Token.BLOCK, transform(node));\n+    }\n+\n+    Node transformBlock(Block blockNode) {\n+        Node block = newNode(Token.BLOCK);\n+        for (AstNode child : blockNode) {\n+            block.addChildToBack(transform(child));\n+        }\n+        return block;\n+    }\n+\n+    Node transformName(Name nameNode) {\n+        return newNode(Token.NAME, nameNode.getIdentifier());\n+    }\n+\n+    Node transformString(String stringNode) {\n+        return newNode(Token.STRING, stringNode);\n+    }\n+\n+    Node transformInitializer(VariableInitializer varInitNode) {\n+        if (varInitNode.getInitializer() == null) {\n+            return transformName(varInitNode.getTarget());\n+        } else {\n+            return newNode(\n+                Token.ASSIGN,\n+                transformName(varInitNode.getTarget()),\n+                transform(varInitNode.getInitializer()));\n+        }\n     }\n \n+    Node transformFunctio\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}