{
    "patch": "private static final ImmutableSet<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n\nprivate static class TransformDispatcher extends IRFactory.TypeSafeDispatcher<Node> {\n\n  private String sourceName;\n  private ErrorReporter errorReporter;\n\n  public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.errorReporter = errorReporter;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n      n.getFirstChild().isString() &&\n      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  @Override\n  public Node visit(AstNode node) {\n    throw new UnsupportedOperationException(\n      \"visit(\" + node.getClass().getName() + \")\");\n  }\n\n  @Override\n  public Node visitArrayComprehension(ArrayComprehension node) {\n    // Array comprehensions are not supported.\n    return null;\n  }\n\n  @Override\n  public Node visitArrayLiteral(ArrayLiteral node) {\n    Node newNode = newNode(Token.ARRAYLIT);\n    for (AstNode child : node.getElements()) {\n      if (child instanceof EmptyExpression) {\n        // Transform EmptyExpression to a hole (null).\n        newNode.addChildToBack(newNode(Token.NULL));\n      } else {\n        newNode.addChildToBack(transform(child));\n      }\n    }\n    return newNode;\n  }\n\n  @Override\n  public Node visitAssignment(Assignment node) {\n    Node target = transform(node.getLeft());\n    Node value = transform(node.getRight());\n    return newNode(node.getType(), target, value);\n  }\n\n  @Override\n  public Node visitAstRoot(AstRoot node) {\n    return transform(node.getFirstChild());\n  }\n\n  @Override\n  public Node visitBlock(Block node) {\n    Node result = newNode(Token.BLOCK);\n    for (Node child : node) {\n      result.addChildToBack(transform(child));\n    }\n    return result;\n  }\n\n  @Override\n  public Node visitBreakStatement(BreakStatement node) {\n    Node result = newNode(Token.BREAK);\n    if (node.getBreakLabel() != null) {\n      Node labelName = transform(node.getBreakLabel());\n      labelName.setType(Token.LABEL_NAME);\n      result.addChildToBack(labelName);\n    }\n    return result;\n  }\n\n  @Override\n  public Node visitConditionalExpression(ConditionalExpression node) {\n    return newNode(\n      Token.HOOK,\n      transform(node.getTestExpression()),\n      transform(node.getTrueExpression()),\n      transform(node.getFalseExpression()));\n  }\n\n  @Override\n  public Node visitContinueStatement(ContinueStatement node) {\n    Node result = newNode(Token.CONTINUE);\n    if (node.getLabel() != null) {\n      Node labelName = transform(node.getLabel());\n      labelName.setType(Token.LABEL_NAME);\n      result.addChildToBack(labelName);\n    }\n    return result;\n  }\n\n  @Override\n  public Node visitDoLoop(DoLoop node) {\n    return newNode(Token.DO, transform(node.getBody()), transform(node.getCondition()));\n  }\n\n  @Override\n  public Node visitElementGet(ElementGet node) {\n    return newNode(Token.GETELEM, transform(node.getTarget()), transform(node.getElement()));\n  }\n\n  @Override\n  public Node visitEmptyExpression(EmptyExpression node) {\n    return newNode(Token.EMPTY);\n  }\n\n  @Override\n  public Node visitExpressionStatement(ExpressionStatement node) {\n    Node result = newNode(Token.EXPR_RESULT);\n    result.addChildToBack(transform(node.getExpression()));\n    return result;\n  }\n\n  @Override\n  public Node visitForInLoop(ForInLoop node) {\n    Node lhsNode = transform(node.getIterator());\n    Node rhsNode = transform(node.getIteratedObject());\n    Node bodyNode = transform(node.getBody());\n    Node result = newNode(Token.FOR_IN, lhsNode, rhsNode, bodyNode);\n    return result;\n  }\n  \n  @Override\n  public Node visitForLoop(ForLoop node) {\n    Node initNode = transform(node.getInitializer());\n    Node testNode = transform(node.getCondition());\n    Node incrNode = transform(node.getIncrement());\n    Node bodyNode = transform(node.getBody());\n    return newNode(Token.FOR, initNode, testNode, incrNode, bodyNode);\n  }\n\n  @Override\n  public Node visitFunctionCall(FunctionCall node) {\n    Node target = transform(node.getTarget());\n    Node newNode = newNode(Token.CALL, target);\n    for (AstNode child : node.getArguments()) {\n      newNode.addChildToBack(transform(child));\n    }\n    return newNode;\n  }\n\n  @Override\n  public Node visitFunctionNode(FunctionNode node) {\n    Node result = newNode(\n      Token.FUNCTION,\n      node.getFunctionName() == null ? null : transform(node.getFunctionName()),\n      transform(node.getParams()),\n      transform(node.getBody()));\n    result.setIsArrowFunction(node.isArrowFunction());\n    return result;\n  }\n\n  @Override\n  public Node visitGeneratorExpression(GeneratorExpression node) {\n    // Generator expressions are not supported.\n    return null;\n  }\n\n  @Override\n  public Node visitGetProp(GetProp node) {\n    return newNode(Token.GETPROP, transform(node.getTarget()), newNode(Token.STRING, node.getProperty()));\n  }\n\n  @Override\n  public Node visitIfStatement(IfStatement node) {\n    Node condition = transform(node.getCondition());\n    Node thenPart = transform(node.getThenPart());\n    Node elsePart = null;\n    if (node.getElsePart() != null) {\n      elsePart = transform(node.getElsePart());\n    }\n    return newNode(Token.IF, condition, thenPart, elsePart);\n  }\n\n  @Override\n  public Node visitInfixExpression(InfixExpression node) {\n    Node left = transform(node.getLeft());\n    Node right = transform(node.getRight());\n    // not that all bitwise operations are transformed to arithmentic operations\n    switch (node.getType()) {\n      case Token.BITAND:\n        return new Node(Token.BITAND, left, right);\n      case Token.BITOR:\n        return new Node(Token.BITOR, left, right);\n      case Token.BITXOR:\n        return new Node(Token.BITXOR, left, right);\n      default:\n        return new Node(node.getType(), left, right);\n    }\n  }\n\n  @Override\n  public Node visitKeywordLiteral(KeywordLiteral node) {\n    return newNode(node.getType());\n  }\n\n  @Override\n  public Node visitName(Name node) {\n    Node newNode = newNode(Token.NAME, newNode(Token.STRING, node.getIdentifier()));\n    newNode.setType(node.getType());\n    return newNode;\n  }\n\n  @Override\n  public Node visitNewExpression(NewExpression node) throws RuntimeException {\n    errorReporter.error(\n      \"Cannot translate new expressions. Line \" + node.getLineno(),\n      sourceName,\n      node.getLineno());\n    return null;\n  }\n\n  @Override\n  public Node visitNumberLiteral(NumberLiteral node) {\n    Node newNode = newNode(Token.NUMBER, node.getNumber());\n    newNode.setLineno(node.getLineno());\n    return newNode;\n  }\n\n  @Override\n  public Node visitObjectLiteral(ObjectLiteral node) {\n    Node newNode = newNode(Token.OBJECTLIT);\n    for (ObjectProperty op : node.getElements()) {\n      Node child;\n      if (op.getType() == Token.STRING) {\n        child = op.getLeft();\n      } else {\n        // transform non-string computed property\n        child = newNode(Token.COMPUTED_PROP, transform(op.getLeft()), transform(op.getRight()));\n      }\n      newNode.addChildToBack(child);\n    }\n    return newNode;\n  }\n\n  @Override\n  public Node visitParenthesizedExpression(ParenthesizedExpression node) {\n    if (node.getExpression() != null) {\n      return transform(node.getExpression());\n    }\n    return newNode(Token.EMPTY);\n  }\n\n  @Override\n  public Node visitPropertyGet(PropertyGet node) {\n    return newNode(Token.GETPROP, transform(node.getTarget()), newNode(Token.STRING, node.getProperty()));\n  }\n\n  @Override\n  public Node visitRegExpLiteral(RegExpLiteral node) {\n    Node newNode = newNode(Token.REGEXP, node.getValue(), node.getFlags());\n    newNode.setLineno(node.getLineno());\n    return newNode;\n  }\n\n  @Override\n  public Node visitReturnStatement(ReturnStatement node) {\n    if (node.getReturnValue() == null) {\n      return newNode(Token.RETURN);\n    } else {\n      return newNode(Token.RETURN, transform(node.getReturnValue()));\n    }\n  }\n\n  @Override\n  public Node visitStringLiteral(StringLiteral node) {\n    Node newNode = newNode(Token.STRING, node.getValue());\n    newNode.setLineno(node.getLineno());\n    return newNode;\n  }\n\n  @Override\n  public Node visitSwitchCase(SwitchCase node) {\n    Node result = newNode(Token.CASE, transform(node.getExpression()));\n    for (AstNode stmt : node.getStatements()) {\n      result.addChildToBack(transform(stmt));\n    }\n    return result;\n  }\n\n  @Override\n  public Node visitSwitchStatement(SwitchStatement node) {\n    Node result = newNode(Token.SWITCH, transform(node.getExpression()));\n    Node lastCases = null;\n    for (SwitchCase caseNode : node.getCases()) {\n      Node child = transform(caseNode);\n      if (child.getType() == Token.CASE) {\n        result.addChildToBack(child);\n        lastCases = child;\n      } else {\n        // We hit the \"default:\" case.\n        if (lastCases == null) {\n          // If there was no explicit \"case\" statement before this\n          // \"default\" statement, make sure we create one.\n          lastCases = newNode(Token.CASE);\n          result.addChildToBack(lastCases);\n        }\n\n        lastCases.addChildToBack(child);\n      }\n    }\n    return result;\n  }\n\n  @Override\n  public Node visitThrowStatement(ThrowStatement node) {\n    return newNode(Token.THROW, transform(node.getExpression()));\n  }\n\n  @Override\n  public Node visitTryStatement(TryStatement node) {\n    Node tryBlock = transform(node.getTryBlock());\n    Node catchBlocks = null;\n    for (CatchClause catchClause : node.getCatchClauses()) {\n      Node child = transform(catchClause);\n      if (catchBlocks == null) {\n        catchBlocks = child;\n      } else {\n        catchBlocks.addChildToBack(child);\n      }\n    }\n    Node finallyBlock = null;\n    if (node.getFinallyBlock() != null) {\n      finallyBlock = transform(node.getFinallyBlock());\n    }\n    return newNode(Token.TRY, tryBlock, catchBlocks, finallyBlock);\n  }\n\n  @Override\n  public Node visitUnaryExpression(UnaryExpression node) {\n    Node child = transform(node.getOperand());\n    // not that all bitwise operations are transformed to arithmentic operations\n    switch (node.getType()) {\n      case Token.BITNOT:\n        return new Node(Token.BITNOT, child);\n      default:\n        return new Node(node.getType(), child);\n    }\n  }\n\n  @Override\n  public Node visitVariableDeclaration(VariableDeclaration node) {\n    Node newNode = newNode(Token.VAR);\n    for (VariableInitializer initializer : node.getVariables()) {\n      newNode.addChildToBack(\n          newNode(Token.NAME, newNode(Token.STRING, initializer.getTarget().getIdentifier())),\n          initializer.getInitializer() != null ? transform(initializer.getInitializer()) : newNode(Token.EMPTY));\n    }\n    return newNode;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..5fafb25b 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,365 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+private static final ImmutableSet<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+private static class TransformDispatcher extends IRFactory.TypeSafeDispatcher<Node> {\n+\n+  private String sourceName;\n+  private ErrorReporter errorReporter;\n+\n+  public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+      n.getFirstChild().isString() &&\n+      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  @Override\n+  public Node visit(AstNode node) {\n+    throw new UnsupportedOperationException(\n+      \"visit(\" + node.getClass().getName() + \")\");\n+  }\n+\n+  @Override\n+  public Node visitArrayComprehension(ArrayComprehension node) {\n+    // Array comprehensions are not supported.\n+    return null;\n+  }\n+\n+  @Override\n+  public Node visitArrayLiteral(ArrayLiteral node) {\n+    Node newNode = newNode(Token.ARRAYLIT);\n+    for (AstNode child : node.getElements()) {\n+      if (child instanceof EmptyExpression) {\n+        // Transform EmptyExpression to a hole (null).\n+        newNode.addChildToBack(newNode(Token.NULL));\n+      } else {\n+        newNode.addChildToBack(transform(child));\n+      }\n     }\n+    return newNode;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  @Override\n+  public Node visitAssignment(Assignment node) {\n+    Node target = transform(node.getLeft());\n+    Node value = transform(node.getRight());\n+    return newNode(node.getType(), target, value);\n+  }\n+\n+  @Override\n+  public Node visitAstRoot(AstRoot node) {\n+    return transform(node.getFirstChild());\n+  }\n+\n+  @Override\n+  public Node visitBlock(Block node) {\n+    Node result = newNode(Token.BLOCK);\n+    for (Node child : node) {\n+      result.addChildToBack(transform(child));\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  @Override\n+  public Node visitBreakStatement(BreakStatement node) {\n+    Node result = newNode(Token.BREAK);\n+    if (node.getBreakLabel() != null) {\n+      Node labelName = transform(node.getBreakLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      result.addChildToBack(labelName);\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  @Override\n+  public Node visitConditionalExpression(ConditionalExpression node) {\n+    return newNode(\n+      Token.HOOK,\n+      transform(node.getTestExpression()),\n+      transform(node.getTrueExpression()),\n+      transform(node.getFalseExpression()));\n+  }\n+\n+  @Override\n+  public Node visitContinueStatement(ContinueStatement node) {\n+    Node result = newNode(Token.CONTINUE);\n+    if (node.getLabel() != null) {\n+      Node labelName = transform(node.getLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      result.addChildToBack(labelName);\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  @Override\n+  public Node visitDoLoop(DoLoop node) {\n+    return newNode(Token.DO, transform(node.getBody()), transform(node.getCondition()));\n+  }\n+\n+  @Override\n+  public Node visitElementGet(ElementGet node) {\n+    return newNode(Token.GETELEM, transform(node.getTarget()), transform(node.getElement()));\n+  }\n+\n+  @Override\n+  public Node visitEmptyExpression(EmptyExpression node) {\n+    return newNode(Token.EMPTY);\n+  }\n+\n+  @Override\n+  public Node visitExpressionStatement(ExpressionStatement node) {\n+    Node result = newNode(Token.EXPR_RESULT);\n+    result.addChildToBack(transform(node.getExpression()));\n+    return result;\n+  }\n+\n+  @Override\n+  public Node visitForInLoop(ForInLoop node) {\n+    Node lhsNode = transform(node.getIterator());\n+    Node rhsNode = transform(node.getIteratedObject());\n+    Node bodyNode = transform(node.getBody());\n+    Node result = newNode(Token.FOR_IN, lhsNode, rhsNode, bodyNode);\n+    return result;\n+  }\n+  \n+  @Override\n+  public Node visitForLoop(ForLoop node) {\n+    Node initNode = transform(node.getInitializer());\n+    Node testNode = transform(node.getCondition());\n+    Node incrNode = transform(node.getIncrement());\n+    Node bodyNode = transform(node.getBody());\n+    return newNode(Token.FOR, initNode, testNode, incrNode, bodyNode);\n+  }\n+\n+  @Override\n+  public Node visitFunctionCall(FunctionCall node) {\n+    Node target = transform(node.getTarget());\n+    Node newNode = newNode(Token.CALL, target);\n+    for (AstNode child : node.getArguments()) {\n+      newNode.addChildToBack(transform(child));\n     }\n+    return newNode;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  @Override\n+  public Node visitFunctionNode(FunctionNode node) {\n+    Node result = newNode(\n+      Token.FUNCTION,\n+      node.getFunctionName() == null ? null : transform(node.getFunctionName()),\n+      transform(node.getParams()),\n+      transform(node.getBody()));\n+    result.setIsArrowFunction(node.isArrowFunction());\n+    return result;\n+  }\n+\n+  @Override\n+  public Node visitGeneratorExpression(GeneratorExpression node) {\n+    // Generator expressions are not supported.\n+    return null;\n+  }\n+\n+  @Override\n+  public Node visitGetProp(GetProp node) {\n+    return newNode(Token.GETPROP, transform(node.getTarget()), newNode(Token.STRING, node.getProperty()));\n+  }\n+\n+  @Override\n+  public Node visitIfStatement(IfStatement node) {\n+    Node condition = transform(node.getCondition());\n+    Node thenPart = transform(node.getThenPart());\n+    Node elsePart = null;\n+    if (node.getElsePart() != null) {\n+      elsePart = transform(node.getElsePart());\n+    }\n+    return newNode(Token.IF, condition, thenPart, elsePart);\n+  }\n+\n+  @Override\n+  public Node visitInfixExpression(InfixExpression node) {\n+    Node left = transform(node.getLeft());\n+    Node right = transform(node.getRight());\n+    // not that all bitwise operations are transformed to arithmentic operations\n+    switch (node.getType()) {\n+      case Token.BITAND:\n+        return new Node(Token.BITAND, left, right);\n+      case Token.BITOR:\n+        return new Node(Token.BITOR, left, right);\n+      case Token.BITXOR:\n+        return new Node(Token.BITXOR, left, right);\n+      default:\n+        return new Node(node.getType(), left, right);\n+    }\n+  }\n+\n+  @Override\n+  public Node visitKeywordLiteral(KeywordLiteral node) {\n+    return newNode(node.getType());\n+  }\n+\n+  @Override\n+  public Node visitName(Name node) {\n+    Node newNode = newNode(Token.NAME, newNode(Token.STRING, node.getIdentifier()));\n+    newNode.setType(node.getType());\n+    return newNode;\n+  }\n+\n+  @Override\n+  public Node visitNewExpression(NewExpression node) throws RuntimeException {\n+    errorReporter.error(\n+      \"Cannot translate new expressions. Line \" + node.getLineno(),\n+      sourceName,\n+      node.getLineno());\n+    return null;\n+  }\n+\n+  @Override\n+  public Node visitNumberLiteral(NumberLiteral node) {\n+    Node newNode = newNode(Token.NUMBER, node.getNumber());\n+    newNode.setLineno(node.getLineno());\n+    return newNode;\n+  }\n+\n+  @Override\n+  public Node visitObjectLiteral(ObjectLiteral node) {\n+    Node newNode = newNode(Token.OBJECTLIT);\n+    for (ObjectProperty op : node.getElements()) {\n+      Node child;\n+      if (op.getType() == Token.STRING) {\n+        child = op.getLeft();\n+      } else {\n+        // transform non-string computed property\n+        child = newNode(Token.COMPUTED_PROP, transform(op.getLeft()), transform(op.getRight()));\n       }\n-      return node;\n+      newNode.addChildToBack(child);\n     }\n+    return newNode;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  @Override\n+  public Node visitParenthesizedExpression(ParenthesizedExpression node) {\n+    if (node.getExpression() != null) {\n+      return transform(node.getExpression());\n     }\n+    return newNode(Token.EMPTY);\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  public Node visitPropertyGet(PropertyGet node) {\n+    return newNode(Token.GETPROP, transform(node.getTarget()), newNode(Token.STRING, node.getProperty()));\n+  }\n+\n+  @Override\n+  public Node visitRegExpLiteral(RegExpLiteral node) {\n+    Node newNode = newNode(Token.REGEXP, node.getValue(), node.getFlags());\n+    newNode.setLineno(node.getLineno());\n+    return newNode;\n+  }\n+\n+  @Override\n+  public Node visitReturnStatement(ReturnStatement node) {\n+    if (node.getReturnValue() == null) {\n+      return newNode(Token.RETURN);\n+    } else {\n+      return newNode(Token.RETURN, transform(node.getReturnValue()));\n     }\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node visitStringLiteral(StringLiteral node) {\n+    Node newNode = newNode(Token.STRING, node.getValue());\n+    newNode.setLineno(node.getLineno());\n+    return newNode;\n+  }\n+\n+  @Override\n+  public Node visitSwitchCase(SwitchCase node) {\n+    Node result = newNode(Token.CASE, transform(node.getExpression()));\n+    for (AstNode stmt : node.getStatements()) {\n+      result.addChildToBack(transform(stmt));\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  public Node visitSwitchStatement(SwitchStatement node) {\n+    Node result = newNode(Token.SWITCH, transform(node.getExpression()));\n+    Node lastCases = null;\n+    for (SwitchCase caseNode : node.getCases()) {\n+      Node child = transform(caseNode);\n+      if (child.getType() == Token.CASE) {\n+        result.addChildToBack(child);\n+        lastCases = child;\n+      } else {\n+        // We hit the \"default:\" case.\n+        if (lastCases == null) {\n+          // If there was no explicit \"case\" statement before this\n+          // \"default\" statement, make sure we create one.\n+          lastCases = newNode(Token.CASE);\n+          result.addChildToBack(lastCases);\n+        }\n+\n+        lastCases.addChildToBack(child);\n+      }\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  public Node visitThrowStatement(ThrowStatement node) {\n+    return newNode(Token.THROW, transform(node.getExpression()));\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  public Node visitTryStatement(TryStatement node) {\n+    Node tryBlock = transform(node.getTryBlock());\n+    Node catchBlocks = null;\n+    for (CatchClause catchClause : node.getCatchClauses()) {\n+      Node child = transform(catchClause);\n+      if (catchBlocks == null) {\n+        catchBlocks = child;\n+      } else {\n+        catchBlocks.addChildToBack(child);\n+      }\n+    }\n+    Node finallyBlock = null;\n+    if (node.getFinallyBlock() != null) {\n+      finallyBlock = transform(node.getFinallyBlock());\n+    }\n+    return newNode(Token.TRY, tryBlock, catchBlocks, finallyBlock);\n+  }\n+\n+  @Override\n+  public Node visitUnaryExpression(UnaryExpression node) {\n+    Node child = transform(node.getOperand());\n+    // not that all bitwise operations are transformed to arithmentic operations\n+    switch (node.getType()) {\n+      case Token.BITNOT:\n+        return new Node(Token.BITNOT, child);\n+      default:\n+        return new Node(node.getType(), child);\n     }\n+  }\n+\n+  @Override\n+  public Node visitVariableDeclaration(VariableDeclaration node) {\n+    Node newNode = newNode(Token.VAR);\n+    for (VariableInitializer initializer : node.getVariables()) {\n+      newNode.addChildToBack(\n+          newNode(Token.NAME, newNode(Token.STRING, initializer.getTarget().getIdentifier())),\n+          initializer.getInitializer() != null ? transform(initializer.getInitializer()) : newNode(Token.EMPTY));\n+    }\n+    return newNode;\n+  }\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: class IRFactory.TransformDispatcher is already defined in class IRFactory",
    "test_result": "ERROR"
}