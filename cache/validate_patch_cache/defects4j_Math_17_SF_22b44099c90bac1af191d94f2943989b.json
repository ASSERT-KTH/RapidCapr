{
    "patch": "        if (isNaN() || Double.isNaN(x)) {\n            return newInstance(getField().getNaN());\n        }\n        if (x == 0) {\n            return newInstance(getField().getZero());\n        }\n        Dfp result = newInstance(this);\n\n        int[] product = new int[7];\n\n        int xi = Math.abs(x);\n\n        product[0] = xi % 10000000;\n        xi /= 10000000;\n\n        product[1] = xi % 10000000;\n        xi /= 10000000;\n\n        product[2] = xi % 10000;\n        xi /= 10000;\n\n        product[3] = xi % 10000;\n        xi /= 10000;\n\n        product[4] = xi % 10000;\n        xi /= 10000;\n\n        product[5] = xi % 10000;\n        xi /= 10000;\n\n        product[6] = xi;\n\n        int[] res = new int[13];\n        int lostdigit = 0;\n\n        for (int i = 0; i < 7; i++) {\n\n            if (product[i] == 0) {\n                continue;\n            }\n\n            res[i] = lostdigit + digit(i, product[i], res);\n\n            int k = i + 5;\n            while (res[k] >= 10000) {\n                lostdigit = res[k] / 10000;\n                res[k] = res[k] - 10000 * lostdigit;\n                res[k + 1] += lostdigit;\n                k++;\n            }\n        }\n\n        // normalize\n        final int be = getRadixDigits() - 1;\n        final int bd = getOrder() + 1;\n        int vr;\n\n        lostdigit = 0;\n        for (int i = be; i >= 0; i--) {\n            vr = (res[i] + lostdigit) / 10000;\n            lostdigit = (res[i] + lostdigit) - 10000 * vr;\n            result.mant[i + bd] = (char) lostdigit;\n            lostdigit = vr;\n        }\n\n        result.exp = exp + bd;\n        result.sign = (byte) (sign ^ ((x < 0) ? 0x80 : 0));\n\n        result.round(res[be + 1] >= 5000);\n\n        return result;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..3bf74d3d6 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1599,9 +1599,77 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param x multiplicand\n      * @return product of this and x\n      */\n-    public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n-    }\n+        if (isNaN() || Double.isNaN(x)) {\n+            return newInstance(getField().getNaN());\n+        }\n+        if (x == 0) {\n+            return newInstance(getField().getZero());\n+        }\n+        Dfp result = newInstance(this);\n+\n+        int[] product = new int[7];\n+\n+        int xi = Math.abs(x);\n+\n+        product[0] = xi % 10000000;\n+        xi /= 10000000;\n+\n+        product[1] = xi % 10000000;\n+        xi /= 10000000;\n+\n+        product[2] = xi % 10000;\n+        xi /= 10000;\n+\n+        product[3] = xi % 10000;\n+        xi /= 10000;\n+\n+        product[4] = xi % 10000;\n+        xi /= 10000;\n+\n+        product[5] = xi % 10000;\n+        xi /= 10000;\n+\n+        product[6] = xi;\n+\n+        int[] res = new int[13];\n+        int lostdigit = 0;\n+\n+        for (int i = 0; i < 7; i++) {\n+\n+            if (product[i] == 0) {\n+                continue;\n+            }\n+\n+            res[i] = lostdigit + digit(i, product[i], res);\n+\n+            int k = i + 5;\n+            while (res[k] >= 10000) {\n+                lostdigit = res[k] / 10000;\n+                res[k] = res[k] - 10000 * lostdigit;\n+                res[k + 1] += lostdigit;\n+                k++;\n+            }\n+        }\n+\n+        // normalize\n+        final int be = getRadixDigits() - 1;\n+        final int bd = getOrder() + 1;\n+        int vr;\n+\n+        lostdigit = 0;\n+        for (int i = be; i >= 0; i--) {\n+            vr = (res[i] + lostdigit) / 10000;\n+            lostdigit = (res[i] + lostdigit) - 10000 * vr;\n+            result.mant[i + bd] = (char) lostdigit;\n+            lostdigit = vr;\n+        }\n+\n+        result.exp = exp + bd;\n+        result.sign = (byte) (sign ^ ((x < 0) ? 0x80 : 0));\n+\n+        result.round(res[be + 1] >= 5000);\n+\n+        return result;\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n      * There are speed advantages in this special case.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}