{
    "patch": "public class IRFactory extends CfgIrBuilder<Void> {\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n  \n  public IRFactory(AstRoot astRoot, ErrorReporter errorReporter, String sourceName) {\n    super(astRoot);\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  abstract class TransformDispatcher extends NodeTraversal.AbstractShallowCallback\n      implements TypeSafeDispatcher {\n\n    abstract Node processBlock(Block blockNode);\n\n    abstract Node processVarDeclaration(VariableDeclaration declaration);\n\n    abstract Node processFunction(FunctionNode functionNode);\n\n    abstract Node processPropertyGet(PropertyGet get);\n\n    abstract Node processName(Name name);\n\n    abstract Node processNumber(NumberLiteral number);\n\n    abstract Node processRegExp(RegExpLiteral regExpLiteral);\n\n    abstract Node processString(StringLiteral str);\n\n    abstract Node processUnary(UnaryExpression unary);\n\n    abstract Node processBinary(BinaryExpression binary);\n\n    abstract Node processAssign(Assignment operation);\n\n    abstract Node processExprStmt(ExpressionStatement statementNode);\n\n    abstract Node processSymbol(Symbol symbolNode);\n\n    abstract Node processTemplateLiteral(TemplateLiteral node);\n\n    abstract Node processComputedProp(PropListItem node);\n\n    @Override\n    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n      switch (n.getToken()) {\n        case FUNCTION:\n          Node firstChild = n.getFirstChild();\n          // We don't want to transform getter and setter\n          if (firstChild.getNext().getString().equals(\"get\")\n              || firstChild.getNext().getString().equals(\"set\")) {\n            return false;\n          }\n          return true;\n\n        case VAR:\n          if (isDirective(parent)) {\n            return true;\n          }\n          return false;\n\n        case FUNCTION_NAME:\n        case CLASS_NAME:\n          return false;\n\n        case OBJECTLIT:\n          for (Node child : n.children()) {\n            if (child.isComputedProp()) {\n              return true;\n            }\n          }\n          return false;\n\n        default:\n          return true;\n      }\n    }\n\n    @Override\n    public final void visit(\n        NodeTraversal t, Node n, Node parent) {\n      Node replacement = getReplacement(n);\n      if (replacement != null) {\n        parent.replaceChild(n, replacement);\n      }\n      if (n.isName()) {\n        String name = n.getString();\n        if (isDirective(parent) && ALLOWED_DIRECTIVES.contains(name)) {\n          n.setType(Token.LABEL_NAME);\n        }\n      }\n    }\n\n    private Node getReplacement(Node n) {\n      switch (n.getToken()) {\n        case BLOCK:\n          return processBlock((Block) n);\n\n        case SCRIPT:\n          return processBlock((Block) n);\n\n        case VAR:\n          return processVarDeclaration((VariableDeclaration) n);\n\n        case FUNCTION:\n          return processFunction((FunctionNode) n);\n\n        case GETPROP:\n          return processPropertyGet((PropertyGet) n);\n\n        case NAME:\n          return processName(n);\n\n        case NUMBER:\n          return processNumber((NumberLiteral) n);\n\n        case REGEXP:\n          return processRegExp((RegExpLiteral) n);\n\n        case STRING:\n          return processString((StringLiteral) n);\n\n        case TEMPLATELIT:\n          return processTemplateLiteral((TemplateLiteral) n);\n\n        case TEMPLATELIT_SUB:\n          return null;\n\n        case POS:\n        case NEG:\n        case NOT:\n        case BITNOT:\n        case TYPEOF:\n        case VOID:\n        case INC:\n        case DEC:\n          return processUnary((UnaryExpression) n);\n\n        case CM:\n        case OR:\n        case AND:\n        case BITOR:\n        case BITXOR:\n        case BITAND:\n        case EQ:\n        case NE:\n        case SHEQ:\n        case SHNE:\n        case LT:\n        case GT:\n        case LE:\n        case GE:\n        case INSTANCEOF:\n        case IN:\n        case LSH:\n        case RSH:\n        case URSH:\n        case ADD:\n        case SUB:\n        case MUL:\n        case DIV:\n        case MOD:\n          return processBinary((BinaryExpression) n);\n\n        case ASSIGN:\n        case ASSIGN_LSH:\n        case ASSIGN_RSH:\n        case ASSIGN_URSH:\n        case ASSIGN_ADD:\n        case ASSIGN_SUB:\n        case ASSIGN_MUL:\n        case ASSIGN_DIV:\n        case ASSIGN_MOD:\n        case ASSIGN_BITOR:\n        case ASSIGN_BITXOR:\n        case ASSIGN_BITAND:\n          return processAssign((Assignment) n);\n\n        case EXPR_RESULT:\n          return processExprStmt((ExpressionStatement) n);\n\n        case SYMBOL:\n          return processSymbol((Symbol) n);\n\n        case COMPUTED_PROP:\n          return processComputedProp((PropListItem) n);\n\n        default:\n          throw new IllegalStateException(\"Unexpected node: \" + n);\n      }\n    }\n  }\n\n  // This is necessary to allow testing without needing to mock ErrorReporter\n  public final TransformDispatcher getTransformDispatcher() {\n    return new TransformDispatcher() {\n\n      @Override\n      Node processBlock(Block blockNode) {\n        return processGeneric(blockNode);\n      }\n\n      @Override\n      Node processVarDeclaration(VariableDeclaration declaration) {\n        return processGeneric(declaration);\n      }\n\n      @Override\n      Node processFunction(FunctionNode functionNode) {\n        return processGeneric(functionNode);\n      }\n\n      @Override\n      Node processPropertyGet(PropertyGet get) {\n        return processGeneric(get);\n      }\n\n      @Override\n      Node processName(Name name) {\n        return processGeneric(name);\n      }\n\n      @Override\n      Node processNumber(NumberLiteral number) {\n        return processGeneric(number);\n      }\n\n      @Override\n      Node processRegExp(RegExpLiteral regExpLiteral) {\n        return processGeneric(regExpLiteral);\n      }\n\n      @Override\n      Node processString(StringLiteral str) {\n        return processGeneric(str);\n      }\n\n      @Override\n      Node processUnary(UnaryExpression unary) {\n        return processGeneric(unary);\n      }\n\n      @Override\n      Node processBinary(BinaryExpression binary) {\n        return processGeneric(binary);\n      }\n\n      @Override\n      Node processAssign(Assignment operation) {\n        return processGeneric(operation);\n      }\n\n      @Override\n      Node processExprStmt(ExpressionStatement statementNode) {\n        return processGeneric(statementNode);\n      }\n\n      @Override\n      Node processSymbol(Symbol symbolNode) {\n        return processGeneric(symbolNode);\n      }\n\n      @Override\n      Node processTemplateLiteral(TemplateLiteral node) {\n        return processGeneric(node);\n      }\n\n      @Override\n      Node processComputedProp(PropListItem node) {\n        return processGeneric(node);\n      }\n    };\n  }\n\n  protected class BlockTransformDispatcher extends TransformDispatcher {\n    @Override\n    Node processBlock(Block blockNode) {\n      Node newBlockNode = newNode(blockNode.getToken());\n      for (Node child = blockNode.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.isFunction()) {\n          Node newFunction = processFunction((FunctionNode) child);\n          newBlockNode.addChildToBack(newFunction);\n        } else {\n          Node genericChild = processGeneric(child);\n          newBlockNode.addChildToBack(genericChild);\n        }\n      }\n      return newBlockNode;\n    }\n  }\n\n  // This is necessary to allow testing without needing to mock ErrorReporter\n  public final Node transform() {\n    NodeTraversal.traverseEs6(compiler, getTransformDispatcher(), astRoot);\n    return astRoot;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..b0535a40 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,303 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory extends CfgIrBuilder<Void> {\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+  \n+  public IRFactory(AstRoot astRoot, ErrorReporter errorReporter, String sourceName) {\n+    super(astRoot);\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  abstract class TransformDispatcher extends NodeTraversal.AbstractShallowCallback\n+      implements TypeSafeDispatcher {\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+    abstract Node processBlock(Block blockNode);\n+\n+    abstract Node processVarDeclaration(VariableDeclaration declaration);\n+\n+    abstract Node processFunction(FunctionNode functionNode);\n+\n+    abstract Node processPropertyGet(PropertyGet get);\n+\n+    abstract Node processName(Name name);\n+\n+    abstract Node processNumber(NumberLiteral number);\n+\n+    abstract Node processRegExp(RegExpLiteral regExpLiteral);\n+\n+    abstract Node processString(StringLiteral str);\n+\n+    abstract Node processUnary(UnaryExpression unary);\n+\n+    abstract Node processBinary(BinaryExpression binary);\n+\n+    abstract Node processAssign(Assignment operation);\n+\n+    abstract Node processExprStmt(ExpressionStatement statementNode);\n+\n+    abstract Node processSymbol(Symbol symbolNode);\n+\n+    abstract Node processTemplateLiteral(TemplateLiteral node);\n+\n+    abstract Node processComputedProp(PropListItem node);\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public final boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n+      switch (n.getToken()) {\n+        case FUNCTION:\n+          Node firstChild = n.getFirstChild();\n+          // We don't want to transform getter and setter\n+          if (firstChild.getNext().getString().equals(\"get\")\n+              || firstChild.getNext().getString().equals(\"set\")) {\n+            return false;\n+          }\n+          return true;\n+\n+        case VAR:\n+          if (isDirective(parent)) {\n+            return true;\n+          }\n+          return false;\n+\n+        case FUNCTION_NAME:\n+        case CLASS_NAME:\n+          return false;\n+\n+        case OBJECTLIT:\n+          for (Node child : n.children()) {\n+            if (child.isComputedProp()) {\n+              return true;\n+            }\n+          }\n+          return false;\n+\n+        default:\n+          return true;\n       }\n-      return node;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    public final void visit(\n+        NodeTraversal t, Node n, Node parent) {\n+      Node replacement = getReplacement(n);\n+      if (replacement != null) {\n+        parent.replaceChild(n, replacement);\n+      }\n+      if (n.isName()) {\n+        String name = n.getString();\n+        if (isDirective(parent) && ALLOWED_DIRECTIVES.contains(name)) {\n+          n.setType(Token.LABEL_NAME);\n+        }\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    private Node getReplacement(Node n) {\n+      switch (n.getToken()) {\n+        case BLOCK:\n+          return processBlock((Block) n);\n+\n+        case SCRIPT:\n+          return processBlock((Block) n);\n+\n+        case VAR:\n+          return processVarDeclaration((VariableDeclaration) n);\n+\n+        case FUNCTION:\n+          return processFunction((FunctionNode) n);\n+\n+        case GETPROP:\n+          return processPropertyGet((PropertyGet) n);\n+\n+        case NAME:\n+          return processName(n);\n+\n+        case NUMBER:\n+          return processNumber((NumberLiteral) n);\n+\n+        case REGEXP:\n+          return processRegExp((RegExpLiteral) n);\n+\n+        case STRING:\n+          return processString((StringLiteral) n);\n+\n+        case TEMPLATELIT:\n+          return processTemplateLiteral((TemplateLiteral) n);\n+\n+        case TEMPLATELIT_SUB:\n+          return null;\n+\n+        case POS:\n+        case NEG:\n+        case NOT:\n+        case BITNOT:\n+        case TYPEOF:\n+        case VOID:\n+        case INC:\n+        case DEC:\n+          return processUnary((UnaryExpression) n);\n+\n+        case CM:\n+        case OR:\n+        case AND:\n+        case BITOR:\n+        case BITXOR:\n+        case BITAND:\n+        case EQ:\n+        case NE:\n+        case SHEQ:\n+        case SHNE:\n+        case LT:\n+        case GT:\n+        case LE:\n+        case GE:\n+        case INSTANCEOF:\n+        case IN:\n+        case LSH:\n+        case RSH:\n+        case URSH:\n+        case ADD:\n+        case SUB:\n+        case MUL:\n+        case DIV:\n+        case MOD:\n+          return processBinary((BinaryExpression) n);\n+\n+        case ASSIGN:\n+        case ASSIGN_LSH:\n+        case ASSIGN_RSH:\n+        case ASSIGN_URSH:\n+        case ASSIGN_ADD:\n+        case ASSIGN_SUB:\n+        case ASSIGN_MUL:\n+        case ASSIGN_DIV:\n+        case ASSIGN_MOD:\n+        case ASSIGN_BITOR:\n+        case ASSIGN_BITXOR:\n+        case ASSIGN_BITAND:\n+          return processAssign((Assignment) n);\n+\n+        case EXPR_RESULT:\n+          return processExprStmt((ExpressionStatement) n);\n+\n+        case SYMBOL:\n+          return processSymbol((Symbol) n);\n+\n+        case COMPUTED_PROP:\n+          return processComputedProp((PropListItem) n);\n+\n+        default:\n+          throw new IllegalStateException(\"Unexpected node: \" + n);\n+      }\n     }\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  // This is necessary to allow testing without needing to mock ErrorReporter\n+  public final TransformDispatcher getTransformDispatcher() {\n+    return new TransformDispatcher() {\n+\n+      @Override\n+      Node processBlock(Block blockNode) {\n+        return processGeneric(blockNode);\n       }\n-      return node;\n-    }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+      @Override\n+      Node processVarDeclaration(VariableDeclaration declaration) {\n+        return processGeneric(declaration);\n+      }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n+      @Override\n+      Node processFunction(FunctionNode functionNode) {\n+        return processGeneric(functionNode);\n+      }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+      @Override\n+      Node processPropertyGet(PropertyGet get) {\n+        return processGeneric(get);\n+      }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n-    }\n+      @Override\n+      Node processName(Name name) {\n+        return processGeneric(name);\n+      }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+      @Override\n+      Node processNumber(NumberLiteral number) {\n+        return processGeneric(number);\n+      }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+      @Override\n+      Node processRegExp(RegExpLiteral regExpLiteral) {\n+        return processGeneric(regExpLiteral);\n+      }\n+\n+      @Override\n+      Node processString(StringLiteral str) {\n+        return processGeneric(str);\n+      }\n+\n+      @Override\n+      Node processUnary(UnaryExpression unary) {\n+        return processGeneric(unary);\n+      }\n+\n+      @Override\n+      Node processBinary(BinaryExpression binary) {\n+        return processGeneric(binary);\n+      }\n+\n+      @Override\n+      Node processAssign(Assignment operation) {\n+        return processGeneric(operation);\n+      }\n+\n+      @Override\n+      Node processExprStmt(ExpressionStatement statementNode) {\n+        return processGeneric(statementNode);\n+      }\n+\n+      @Override\n+      Node processSymbol(Symbol symbolNode) {\n+        return processGeneric(symbolNode);\n+      }\n+\n+      @Override\n+      Node processTemplateLiteral(TemplateLiteral node) {\n+        return processGeneric(node);\n+      }\n+\n+      @Override\n+      Node processComputedProp(PropListItem node) {\n+        return processGeneric(node);\n+      }\n+    };\n+  }\n+\n+  protected class BlockTransformDispatcher extends TransformDispatcher {\n+    @Override\n+    Node processBlock(Block blockNode) {\n+      Node newBlockNode = newNode(blockNode.getToken());\n+      for (Node child = blockNode.getFirstChild(); child != null; child = child.getNext()) {\n+        if (child.isFunction()) {\n+          Node newFunction = processFunction((FunctionNode) child);\n+          newBlockNode.addChildToBack(newFunction);\n+        } else {\n+          Node genericChild = processGeneric(child);\n+          newBlockNode.addChildToBack(genericChild);\n+        }\n+      }\n+      return newBlockNode;\n     }\n+  }\n+\n+  // This is necessary to allow testing without needing to mock ErrorReporter\n+  public final Node transform() {\n+    NodeTraversal.traverseEs6(compiler, getTransformDispatcher(), astRoot);\n+    return astRoot;\n+  }\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: class IRFactory is already defined in package com.google.javascript.jscomp.parsing",
    "test_result": "ERROR"
}