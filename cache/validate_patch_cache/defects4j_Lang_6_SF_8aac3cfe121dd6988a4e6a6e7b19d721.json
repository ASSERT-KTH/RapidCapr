{
    "patch": "public static String unescape(final CharSequence input) {\n    if (input == null) {\n        return null;\n    }\n    final int leng = input.length();\n    final StringBuilder sb = new StringBuilder(leng);\n    boolean inEscape = false;\n    char ch = 0;\n    for (int i = 0; i < leng; i++) {\n        final char nextChar = input.charAt(i);\n\n        if (inEscape) {\n            inEscape = false;\n            switch (nextChar) {\n            case '\\\\':\n                ch = '\\\\';\n                break;\n            case '\\'':\n                ch = '\\'';\n                break;\n            case '\\\"':\n                ch = '\\\"';\n                break;\n            case 'r':\n                ch = '\\r';\n                break;\n            case 'f':\n                ch = '\\f';\n                break;\n            case 't':\n                ch = '\\t';\n                break;\n            case 'n':\n                ch = '\\n';\n                break;\n            case 'b': \n                ch = '\\b'; \n                break;\n            case 'u':\n                if (i + 4 < leng) {\n                    char uni = (char) Integer.parseInt(input.subSequence(i + 1, i + 5).toString(), 16);\n                    sb.append(uni);\n                    i += 4;\n                    continue;\n                }\n                break;\n            default:\n                break;\n            }\n            sb.append(ch);\n        } else if (nextChar == '\\\\') {\n            inEscape = true;\n        } else {\n            sb.append(nextChar);\n        }\n\n    }\n    if (inEscape) {\n        sb.append('\\\\');\n    }\n    return sb.toString();\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010eaf..c6eb1d5e 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -72,30 +72,68 @@ public abstract class CharSequenceTranslator {\n      * @param out Writer to translate the text to\n      * @throws IOException if and only if the Writer produces an IOException\n      */\n-    public final void translate(CharSequence input, Writer out) throws IOException {\n-        if (out == null) {\n-            throw new IllegalArgumentException(\"The Writer must not be null\");\n-        }\n-        if (input == null) {\n-            return;\n-        }\n-        int pos = 0;\n-        int len = input.length();\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n-                out.write(c);\n-                pos+= c.length;\n-                continue;\n-            }\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+public static String unescape(final CharSequence input) {\n+    if (input == null) {\n+        return null;\n+    }\n+    final int leng = input.length();\n+    final StringBuilder sb = new StringBuilder(leng);\n+    boolean inEscape = false;\n+    char ch = 0;\n+    for (int i = 0; i < leng; i++) {\n+        final char nextChar = input.charAt(i);\n+\n+        if (inEscape) {\n+            inEscape = false;\n+            switch (nextChar) {\n+            case '\\\\':\n+                ch = '\\\\';\n+                break;\n+            case '\\'':\n+                ch = '\\'';\n+                break;\n+            case '\\\"':\n+                ch = '\\\"';\n+                break;\n+            case 'r':\n+                ch = '\\r';\n+                break;\n+            case 'f':\n+                ch = '\\f';\n+                break;\n+            case 't':\n+                ch = '\\t';\n+                break;\n+            case 'n':\n+                ch = '\\n';\n+                break;\n+            case 'b': \n+                ch = '\\b'; \n+                break;\n+            case 'u':\n+                if (i + 4 < leng) {\n+                    char uni = (char) Integer.parseInt(input.subSequence(i + 1, i + 5).toString(), 16);\n+                    sb.append(uni);\n+                    i += 4;\n+                    continue;\n+                }\n+                break;\n+            default:\n+                break;\n             }\n+            sb.append(ch);\n+        } else if (nextChar == '\\\\') {\n+            inEscape = true;\n+        } else {\n+            sb.append(nextChar);\n         }\n+\n     }\n+    if (inEscape) {\n+        sb.append('\\\\');\n+    }\n+    return sb.toString();\n+}\n \n     /**\n      * Helper method to create a merger of this translator with another set of ",
    "result_reason": "error: no suitable method found for translate(CharSequence,StringWriter)",
    "test_result": "ERROR"
}