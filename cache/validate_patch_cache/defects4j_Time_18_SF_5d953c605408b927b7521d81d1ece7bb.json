{
    "patch": "    public long getDateTimeMillis(int year, int monthOfYear, int dayOfMonth,\n                                  int hourOfDay, int minuteOfHour,\n                                  int secondOfMinute, int millisOfSecond)\n        throws IllegalArgumentException\n    {\n        Chronology base;\n        if ((base = getBase()) != null) {\n            return base.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n        }\n\n        // Assume date is Gregorian.\n        long instant = iGregorianChronology.getDateTimeMillis\n            (year, monthOfYear, dayOfMonth,\n             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n        if (instant < iCutoverMillis) {\n            // Maybe it's Julian.\n            long julianInstant = iJulianChronology.getDateTimeMillis\n                (year, monthOfYear, dayOfMonth,\n                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n\n            if (julianInstant >= iCutoverMillis) {\n                // Okay, it's in the illegal cutover gap.\n                throw new IllegalArgumentException(\"Specified date does not exist\");\n            }\n            else {\n                // Adjust for Gregorian/Julian cutover.\n                // This may involve adding or removing 10 days from the month,\n                // so ComputeJulianFields should be called with the original day\n                // of month value to avoid missing local midnight.\n                int days = ComputeJulianDayOfYear(year, monthOfYear, dayOfMonth);\n                instant = iGregorianChronology.getDateTimeMillis\n                         (year, monthOfYear, days,\n                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n                if (instant < iCutoverMillis) {\n                    instant = iJulianChronology.getDateTimeMillis\n                             (year, monthOfYear, days,\n                              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n                }\n            }\n        }\n\n        return instant;\n    }\n    \n    // Helper method to compute the day of year in the Julian calendar.\n    private int ComputeJulianDayOfYear(int year, int month, int day) {\n        int julianLeapYear = year % 4;\n        boolean isJulianLeapYear = julianLeapYear == 0;\n        if (month < 3 || month == 3 && day < 1) {\n            return day + (isJulianLeapYear ? 60 : 59);\n        }\n        else {\n            int eclipsedDays = isJulianLeapYear ? 60 : 59;\n            switch (month) {\n                case 3:\n                    return day + eclipsedDays;\n                case 4:\n                    return day + eclipsedDays + 31;\n                case 5:\n                    return day + eclipsedDays + 61;\n                case 6:\n                    return day + eclipsedDays + 92;\n                case 7:\n                    return day + eclipsedDays + 122;\n                case 8:\n                    return day + eclipsedDays + 153;\n                case 9:\n                    return day + eclipsedDays + 184;\n                case 10:\n                    return day + eclipsedDays + 214;\n                case 11:\n                    return day + eclipsedDays + 245;\n                default:\n                    return day + eclipsedDays + 275;\n            }\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/chrono/GJChronology.java b/src/main/java/org/joda/time/chrono/GJChronology.java\nindex 29e559d4..abb73d18 100644\n--- a/src/main/java/org/joda/time/chrono/GJChronology.java\n+++ b/src/main/java/org/joda/time/chrono/GJChronology.java\n@@ -360,22 +360,73 @@ public final class GJChronology extends AssembledChronology {\n         }\n \n         // Assume date is Gregorian.\n-        long instant;\n-            instant = iGregorianChronology.getDateTimeMillis\n-                (year, monthOfYear, dayOfMonth,\n-                 hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+        long instant = iGregorianChronology.getDateTimeMillis\n+            (year, monthOfYear, dayOfMonth,\n+             hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+\n         if (instant < iCutoverMillis) {\n             // Maybe it's Julian.\n-            instant = iJulianChronology.getDateTimeMillis\n+            long julianInstant = iJulianChronology.getDateTimeMillis\n                 (year, monthOfYear, dayOfMonth,\n                  hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n-            if (instant >= iCutoverMillis) {\n+\n+            if (julianInstant >= iCutoverMillis) {\n                 // Okay, it's in the illegal cutover gap.\n                 throw new IllegalArgumentException(\"Specified date does not exist\");\n             }\n+            else {\n+                // Adjust for Gregorian/Julian cutover.\n+                // This may involve adding or removing 10 days from the month,\n+                // so ComputeJulianFields should be called with the original day\n+                // of month value to avoid missing local midnight.\n+                int days = ComputeJulianDayOfYear(year, monthOfYear, dayOfMonth);\n+                instant = iGregorianChronology.getDateTimeMillis\n+                         (year, monthOfYear, days,\n+                          hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+                if (instant < iCutoverMillis) {\n+                    instant = iJulianChronology.getDateTimeMillis\n+                             (year, monthOfYear, days,\n+                              hourOfDay, minuteOfHour, secondOfMinute, millisOfSecond);\n+                }\n+            }\n         }\n+\n         return instant;\n     }\n+    \n+    // Helper method to compute the day of year in the Julian calendar.\n+    private int ComputeJulianDayOfYear(int year, int month, int day) {\n+        int julianLeapYear = year % 4;\n+        boolean isJulianLeapYear = julianLeapYear == 0;\n+        if (month < 3 || month == 3 && day < 1) {\n+            return day + (isJulianLeapYear ? 60 : 59);\n+        }\n+        else {\n+            int eclipsedDays = isJulianLeapYear ? 60 : 59;\n+            switch (month) {\n+                case 3:\n+                    return day + eclipsedDays;\n+                case 4:\n+                    return day + eclipsedDays + 31;\n+                case 5:\n+                    return day + eclipsedDays + 61;\n+                case 6:\n+                    return day + eclipsedDays + 92;\n+                case 7:\n+                    return day + eclipsedDays + 122;\n+                case 8:\n+                    return day + eclipsedDays + 153;\n+                case 9:\n+                    return day + eclipsedDays + 184;\n+                case 10:\n+                    return day + eclipsedDays + 214;\n+                case 11:\n+                    return day + eclipsedDays + 245;\n+                default:\n+                    return day + eclipsedDays + 275;\n+            }\n+        }\n+    }\n \n     /**\n      * Gets the cutover instant between Gregorian and Julian chronologies.",
    "result_reason": "org.joda.time.IllegalFieldValueException: Value 60 for dayOfMonth must be in the range [1,31]",
    "test_result": "FAIL"
}