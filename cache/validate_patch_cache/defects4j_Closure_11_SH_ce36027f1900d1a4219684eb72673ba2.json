{
    "patch": " } else if (!VarCheck.isImmediatelyInFunctionBlock(n) &&\n              parent.getType() == Token.ASSIGN &&\n              parent.getFirstChild() == n) {\n    /*\n     * Warn if assigning the result of a function invocation to a var and\n     * that var is only used inside a function. If the function is only\n     * called in one place, this may just be poor factoring.\n     */\n    Node rval = n.getLastChild();\n    if (rval != null && rval.isCall()) {\n      String functionName = null;\n      Node fnNameNode = rval.getFirstChild();\n      if (fnNameNode.isGetProp()) {\n        functionName = fnNameNode.getLastChild().getString();\n      } else if (fnNameNode.isName()) {\n        functionName = fnNameNode.getString();\n      }\n\n      if (functionName != null && !isConstructor(functionName, n) && !isInWhitespaceOrComment(fnNameNode)) {\n        boolean isInFunction = false;\n        Node block = n.getNext();\n        checkBlock:\n        while (block != null) {\n          switch (block.getType()) {\n            case Token.BLOCK:\n              block = block.getFirstChild();\n              break;\n            case Token.FUNCTION:\n              if (functionName.equals(getFunctionName(block))) {\n                isInFunction = true;\n                break checkBlock;\n              }\n              block = null; // immediately leave loop\n              break;\n            default: // all other types of Nodes cannot contain functions\n              block = null; // immediately leave loop\n              break;\n          }\n        }\n        if (isInFunction) {\n          boolean canFix = false;\n          Node blockNode = NodeUtil.getEnclosingBlock(n);\n          if (blockNode.getFirstChild() == n && NodeUtil.isControlStructure(blockNode.getParent())) {\n            // Wrap the RHS in parens\n            String fix =\n                OutputFormat.BUNDLE.getString(\"varAssignmentBadPracticeUseParens\",\n                    NodeUtil.getSourceName(n), n.getLineno(), n.getCharno(), functionName);\n            tokens.add(newSimpleToken(Token.LPAREN, \"(\", n));\n            List<JsToken> subTokens = processSubtreeAsTokens(rval);\n            tokens.addAll(subTokens);\n            tokens.add(newSimpleToken(Token.RPAREN, \")\", rval));\n            subWarnings.add(makeLintWarning(fix, n));\n            canFix = true;\n          } else {\n            // change the var to a let. any uids need updating\n            Node blockType = blockNode.getParent();\n            Preconditions.checkState(NodeUtil.isValidBlockType(blockType.getType()));\n            String fix =\n                OutputFormat.BUNDLE.getString(\"varAssignmentBadPracticeVarToLet\",\n                    NodeUtil.getSourceName(n), n.getLineno(), n.getCharno(), functionName);\n\n            Node letNode = new Node(Token.LET);\n            if (NodeUtil.isLoopBlock(blockType)) {\n              tokens.addAll(processSubtreeAsTokens(new Node(Token.SEMI)));\n              letNode.putProp(Node.IS_LOOP, true);\n            }\n            needsUidChangeInBlock(blockNode, letNode);\n            Node parentAssign = parent.getParent();\n            Node varNameNode = NodeUtil.getBestLValueNameNode(parentAssign.getFirstChild());\n            Node letNameNode = varNameNode.cloneNode();\n            letNameNode.setType(Token.NAME);\n            letNameNode.putBooleanProp(Node.IS_DECLARED, true);\n            letNameNode.setJSDocInfo(varNameNode.getJSDocInfo());\n            letNode.addChildToFront(letNameNode);\n            parentAssign.replaceChild(parent.getFirstChild(), letNode);\n            for (Node valueNode = rval.getFirstChild(); valueNode != null; valueNode = valueNode.getNext()) {\n              if (isValidDestructuringLhs(valueNode)) {\n                needsUidChangeInBlock(valueNode.getFirstChild(), letNode);\n              }\n            }\n            subWarnings.add(makeLintWarning(fix, n));\n            canFix = true;\n          }\n          if (canFix) {\n            // Since we fixed this error, we're going to throw an exception\n            // to immediately skip the remaining checks on this function.\n            throw new FoundFixableError();\n          }\n        }\n      }\n    }\n  } else if (n.getJSType() != null && parent.isAssign()) {\n    return;\n  } else if (!n.isQualifiedName()) {\n    warnings.add(makeLintWarning(\"Suspicious code. Did you mean: \" +\n        NodeUtil.getGetpropImplicitCast(n.getFirstChild()), n));\n    return;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex ae8a3200..2b3f4991 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1300,7 +1300,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * @param n The node being visited.\n    * @param parent The parent of <code>n</code>\n    */\n-  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n+\n     // obj.prop or obj.method()\n     // Lots of types can appear on the left, a call to a void function can\n     // never be on the left. getPropertyType will decide what is acceptable",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}