{
    "patch": "    protected UnivariatePointValuePair doOptimize() {\n        // Get the goal type\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n\n        // Get the bounds and initial guess\n        final double lo = getMin();\n        final double hi = getMax();\n        final double mid = getStartValue();\n\n        // Optional additional convergence criteria\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n        // Initialize variables\n        double a, b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        // Initialize best point encountered so far\n        UnivariatePointValuePair bestPoint = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current = bestPoint;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Default stopping criterion\n            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n\n            // If the stopping criterion is not met\n            if (!stop) {\n                double p = 0;\n                double q = 0;\n                double r = 0;\n                double u = 0;\n\n                if (FastMath.abs(e) > tol1) { // Fit a parabola\n                    r = (x - w) * (fx - fv);\n                    q = (x - v) * (fx - fw);\n                    p = (x - v) * q - (x - w) * r;\n                    q = 2 * (q - r);\n\n                    if (q > 0) {\n                        p = -p;\n                    } else {\n                        q = -q;\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n                        // Parabolic interpolation step\n                        d = p / q;\n                        u = x + d;\n\n                        // Ensure \"u\" is not too close to \"a\" or \"b\"\n                        if (u - a < tol2 || b - u < tol2) {\n                            d = FastMath.signum(m - x) * tol1;\n                        }\n                    } else {\n                        // Golden section step",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex 5136a1401..45961d2d9 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -113,17 +113,19 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n     /** {@inheritDoc} */\n     @Override\n     protected UnivariatePointValuePair doOptimize() {\n+        // Get the goal type\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n+\n+        // Get the bounds and initial guess\n         final double lo = getMin();\n-        final double mid = getStartValue();\n         final double hi = getMax();\n+        final double mid = getStartValue();\n \n-        // Optional additional convergence criteria.\n-        final ConvergenceChecker<UnivariatePointValuePair> checker\n-            = getConvergenceChecker();\n+        // Optional additional convergence criteria\n+        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n \n-        double a;\n-        double b;\n+        // Initialize variables\n+        double a, b;\n         if (lo < hi) {\n             a = lo;\n             b = hi;\n@@ -131,7 +133,6 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n             a = hi;\n             b = lo;\n         }\n-\n         double x = mid;\n         double v = x;\n         double w = x;\n@@ -144,10 +145,11 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n         double fv = fx;\n         double fw = fx;\n \n+        // Initialize best point encountered so far\n+        UnivariatePointValuePair bestPoint = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+\n         UnivariatePointValuePair previous = null;\n-        UnivariatePointValuePair current\n-            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-        // Best point encountered so far (which is the initial guess).\n+        UnivariatePointValuePair current = bestPoint;\n \n         int iter = 0;\n         while (true) {\n@@ -155,15 +157,17 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n             final double tol2 = 2 * tol1;\n \n-            // Default stopping criterion.\n+            // Default stopping criterion\n             final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n+\n+            // If the stopping criterion is not met\n             if (!stop) {\n                 double p = 0;\n                 double q = 0;\n                 double r = 0;\n                 double u = 0;\n \n-                if (FastMath.abs(e) > tol1) { // Fit parabola.\n+                if (FastMath.abs(e) > tol1) { // Fit a parabola\n                     r = (x - w) * (fx - fv);\n                     q = (x - v) * (fx - fw);\n                     p = (x - v) * q - (x - w) * r;\n@@ -178,107 +182,17 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                     r = e;\n                     e = d;\n \n-                    if (p > q * (a - x) &&\n-                        p < q * (b - x) &&\n-                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n-                        // Parabolic interpolation step.\n+                    if (p > q * (a - x) && p < q * (b - x) && FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n+                        // Parabolic interpolation step\n                         d = p / q;\n                         u = x + d;\n \n-                        // f must not be evaluated too close to a or b.\n+                        // Ensure \"u\" is not too close to \"a\" or \"b\"\n                         if (u - a < tol2 || b - u < tol2) {\n-                            if (x <= m) {\n-                                d = tol1;\n-                            } else {\n-                                d = -tol1;\n-                            }\n+                            d = FastMath.signum(m - x) * tol1;\n                         }\n                     } else {\n-                        // Golden section step.\n-                        if (x < m) {\n-                            e = b - x;\n-                        } else {\n-                            e = a - x;\n-                        }\n-                        d = GOLDEN_SECTION * e;\n-                    }\n-                } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n-                }\n-\n-                // Update by at least \"tol1\".\n-                if (FastMath.abs(d) < tol1) {\n-                    if (d >= 0) {\n-                        u = x + tol1;\n-                    } else {\n-                        u = x - tol1;\n-                    }\n-                } else {\n-                    u = x + d;\n-                }\n-\n-                double fu = computeObjectiveValue(u);\n-                if (!isMinim) {\n-                    fu = -fu;\n-                }\n-\n-                // User-defined convergence checker.\n-                previous = current;\n-                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n-\n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return best(current, previous, isMinim);\n-                    }\n-                }\n-\n-                // Update a, b, v, w and x.\n-                if (fu <= fx) {\n-                    if (u < x) {\n-                        b = x;\n-                    } else {\n-                        a = x;\n-                    }\n-                    v = w;\n-                    fv = fw;\n-                    w = x;\n-                    fw = fx;\n-                    x = u;\n-                    fx = fu;\n-                } else {\n-                    if (u < x) {\n-                        a = u;\n-                    } else {\n-                        b = u;\n-                    }\n-                    if (fu <= fw ||\n-                        Precision.equals(w, x)) {\n-                        v = w;\n-                        fv = fw;\n-                        w = u;\n-                        fw = fu;\n-                    } else if (fu <= fv ||\n-                               Precision.equals(v, x) ||\n-                               Precision.equals(v, w)) {\n-                        v = u;\n-                        fv = fu;\n-                    }\n-                }\n-            } else { // Default termination (Brent's criterion).\n-                return\n-                            best(current,\n-                                 previous,\n-                            isMinim);\n-            }\n-            ++iter;\n-        }\n-    }\n+                        // Golden section step\n \n     /**\n      * Selects the best of two points.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}