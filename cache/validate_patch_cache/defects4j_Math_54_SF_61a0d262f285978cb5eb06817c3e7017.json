{
    "patch": "public double toDouble() {\n    if (isInfinite()) {\n        return signum() > 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    if (isNaN()) {\n        return Double.NaN;\n    }\n    if (lessThan(Dfp.ZERO)) {\n        return -negate().toDouble();\n    }\n    \n    String str = toString();\n    if (str.charAt(0) == '-') {\n        str = str.substring(1);\n    }\n    int exponent = str.indexOf('E');\n    if (exponent == -1) {\n        exponent = str.indexOf('e');\n    }\n    if (exponent > -1) {\n        int exp = Integer.parseInt(str.substring(exponent + 1));\n        str = str.substring(0, exponent);\n        if (exp > 0) {\n            if (exp < INFINITE_POWER.length) {\n                str = new StringBuffer(str).append(INFINITE_POWER[exp]).toString();\n            } else {\n                StringBuffer s = new StringBuffer(str);\n                for (int i = INFINITE_POWER.length; i <= exp; i++) {\n                    s.append('0');\n                }\n                str = s.toString();\n            }\n        } else if (exp < 0) {\n            int zeros = -exp - 1;\n            str = new StringBuffer(\"0.\").append(MIN_SUBNORMAL).append(str);\n            for (int i = zeros - INFINITE_POWER.length; i > 0; i -= INFINITE_POWER.length) {\n                str = new StringBuffer(\"0.\").append(INFINITE_POWER[Math.min(i, INFINITE_POWER.length)]).append(str);\n            }\n            str = new StringBuffer(\"0.\").append(INFINITE_POWER[INFINITE_POWER.length + Math.min(0, i)]).append(str);\n        }\n        return Double.parseDouble(str);\n    }\n    \n    if (equals(Dfp.ZERO)) {\n        return 0.0;\n    }\n    if (getPrecision() < 16) {\n        return Double.parseDouble(toBigDecimal().toString());\n    }\n    if (greaterThan(MAX_DOUBLE)) {\n        return signum() > 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n    }\n    \n    String dStr = toString();\n    int p = dStr.indexOf('.');\n    if (p == -1) {\n        p = dStr.indexOf(',');\n    }\n    if (p == -1) {\n        p = dStr.length();\n    }\n    int integerDigits = p;\n    str = dStr.replace(\".\", \"\");\n    str = str.replace(\",\", \"\");\n    if (integerDigits - exponent >= 18) {\n        str = str.substring(0, p) + str.substring(p + 1);\n    } else if (integerDigits == str.length()) {\n        str += '0';\n    }\n    if (str.length() > 17) {\n        str = str.substring(0, 17) +\n            (needsCarry(str.substring(17)) ?\n             increment1(str.substring(0, 17)) : str.substring(17));\n    } else if (str.length() < 17) {\n        str += '.' + MANTISSA_ZEROS.substring(str.length()) + '0';\n    } else {\n        str += \".0\";\n    }\n    if (intValueExact() == 0 && signum() == -1) {\n        str = '-' + str;\n    }\n    return Double.parseDouble(str);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/dfp/Dfp.java b/src/main/java/org/apache/commons/math/dfp/Dfp.java\nindex 73f1ea3e8..38be908e6 100644\n--- a/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n@@ -253,88 +253,89 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param field field to which this instance belongs\n      * @param x value to convert to an instance\n      */\n-    protected Dfp(final DfpField field, double x) {\n-\n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n-        this.field = field;\n-\n-        long bits = Double.doubleToLongBits(x);\n-        long mantissa = bits & 0x000fffffffffffffL;\n-        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n-\n-        if (exponent == -1023) {\n-            // Zero or sub-normal\n-            if (x == 0) {\n-                // make sure 0 has the right sign\n-                return;\n-            }\n-\n-            exponent++;\n-\n-            // Normalize the subnormal number\n-            while ( (mantissa & 0x0010000000000000L) == 0) {\n-                exponent--;\n-                mantissa <<= 1;\n-            }\n-            mantissa &= 0x000fffffffffffffL;\n-        }\n-\n-        if (exponent == 1024) {\n-            // infinity or NAN\n-            if (x != x) {\n-                sign = (byte) 1;\n-                nans = QNAN;\n-            } else if (x < 0) {\n-                sign = (byte) -1;\n-                nans = INFINITE;\n+public double toDouble() {\n+    if (isInfinite()) {\n+        return signum() > 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n+    }\n+    if (isNaN()) {\n+        return Double.NaN;\n+    }\n+    if (lessThan(Dfp.ZERO)) {\n+        return -negate().toDouble();\n+    }\n+    \n+    String str = toString();\n+    if (str.charAt(0) == '-') {\n+        str = str.substring(1);\n+    }\n+    int exponent = str.indexOf('E');\n+    if (exponent == -1) {\n+        exponent = str.indexOf('e');\n+    }\n+    if (exponent > -1) {\n+        int exp = Integer.parseInt(str.substring(exponent + 1));\n+        str = str.substring(0, exponent);\n+        if (exp > 0) {\n+            if (exp < INFINITE_POWER.length) {\n+                str = new StringBuffer(str).append(INFINITE_POWER[exp]).toString();\n             } else {\n-                sign = (byte) 1;\n-                nans = INFINITE;\n+                StringBuffer s = new StringBuffer(str);\n+                for (int i = INFINITE_POWER.length; i <= exp; i++) {\n+                    s.append('0');\n+                }\n+                str = s.toString();\n             }\n-            return;\n-        }\n-\n-        Dfp xdfp = new Dfp(field, mantissa);\n-        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n-        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n-\n-        if ((bits & 0x8000000000000000L) != 0) {\n-            xdfp = xdfp.negate();\n+        } else if (exp < 0) {\n+            int zeros = -exp - 1;\n+            str = new StringBuffer(\"0.\").append(MIN_SUBNORMAL).append(str);\n+            for (int i = zeros - INFINITE_POWER.length; i > 0; i -= INFINITE_POWER.length) {\n+                str = new StringBuffer(\"0.\").append(INFINITE_POWER[Math.min(i, INFINITE_POWER.length)]).append(str);\n+            }\n+            str = new StringBuffer(\"0.\").append(INFINITE_POWER[INFINITE_POWER.length + Math.min(0, i)]).append(str);\n         }\n-\n-        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n-        sign = xdfp.sign;\n-        exp  = xdfp.exp;\n-        nans = xdfp.nans;\n-\n+        return Double.parseDouble(str);\n     }\n-\n-    /** Copy constructor.\n-     * @param d instance to copy\n-     */\n-    public Dfp(final Dfp d) {\n-        mant  = d.mant.clone();\n-        sign  = d.sign;\n-        exp   = d.exp;\n-        nans  = d.nans;\n-        field = d.field;\n+    \n+    if (equals(Dfp.ZERO)) {\n+        return 0.0;\n     }\n-\n-    /** Create an instance from a String representation.\n-     * @param field field to which this instance belongs\n-     * @param s string representation of the instance\n-     */\n-    protected Dfp(final DfpField field, final String s) {\n-\n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n+    if (getPrecision() < 16) {\n+        return Double.parseDouble(toBigDecimal().toString());\n+    }\n+    if (greaterThan(MAX_DOUBLE)) {\n+        return signum() > 0 ? Double.POSITIVE_INFINITY : Double.NEGATIVE_INFINITY;\n+    }\n+    \n+    String dStr = toString();\n+    int p = dStr.indexOf('.');\n+    if (p == -1) {\n+        p = dStr.indexOf(',');\n+    }\n+    if (p == -1) {\n+        p = dStr.length();\n+    }\n+    int integerDigits = p;\n+    str = dStr.replace(\".\", \"\");\n+    str = str.replace(\",\", \"\");\n+    if (integerDigits - exponent >= 18) {\n+        str = str.substring(0, p) + str.substring(p + 1);\n+    } else if (integerDigits == str.length()) {\n+        str += '0';\n+    }\n+    if (str.length() > 17) {\n+        str = str.substring(0, 17) +\n+            (needsCarry(str.substring(17)) ?\n+             increment1(str.substring(0, 17)) : str.substring(17));\n+    } else if (str.length() < 17) {\n+        str += '.' + MANTISSA_ZEROS.substring(str.length()) + '0';\n+    } else {\n+        str += \".0\";\n+    }\n+    if (intValueExact() == 0 && signum() == -1) {\n+        str = '-' + str;\n+    }\n+    return Double.parseDouble(str);\n+}\n         this.field = field;\n \n         boolean decimalFound = false;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}