{
    "patch": "import org.apache.commons.math.MathInternalError;\nimport org.apache.commons.math.exception.MaxCountExceededException;\nimport org.apache.commons.math.exception.TooManyEvaluationsException;\nimport org.apache.commons.math.util.FastMath;\n\npublic class BrentSolver extends AbstractUnivariateSolver {\n\n    /**\n     * The maximum age of cached values.\n     */\n    private static final int MAXIMAL_AGING = 2;\n\n    /**\n     * The default value of the {@link #setReductionFactor(double) reduction factor}.\n     */\n    private static final double DEFAULT_REDUCTION_FACTOR = 1 / 1024d;\n\n    /**\n     * An arbitrary high iteration count for supporting termination on function value.\n     */\n    private static final int MAXIMAL_ITERATIONS_COUNT = 1000000;\n\n    /**\n     * The values.\n     */\n    private double[] f;\n\n    /**\n     * The point with the smallest value.\n     */\n    private int lastIntervalIndex;\n\n    /**\n     * Index of the top of the stack.\n     */\n    private int topIndex;\n\n    /**\n     * Abscissae.\n     */\n    private double[] x;\n\n    /**\n     * Constructor for solver.\n     *\n     * @param relativeAccuracy Maximum relative error.\n     * @param absoluteAccuracy Maximum absolute error.\n     */\n    public BrentSolver(final double relativeAccuracy,\n                       final double absoluteAccuracy) {\n        super(relativeAccuracy, absoluteAccuracy, FunctionEvaluation.MAX_EVALuations);\n    }\n\n    /**\n     * Constructor using default values for relative and absolute accuracies.\n     */\n    public BrentSolver() {\n        super(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY, FunctionEvaluation.MAX_EVALuations);\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() throws TooManyEvaluationsException {\n        // Get initial function values at endpoints of interval.\n        double a = getMin();\n        double b = getMax();\n        double fa = computeObjectiveValue(a);\n        double fb = computeObjectiveValue(b);\n\n        // Verify bracketing, compute a and b such that f(a) < 0 < f(b)\n        verifyBracketing(a, b);\n\n        // Prepare for iterations\n        double c = a;\n        double fc = fa;\n        double e = b - a;\n        double d = e;\n\n        // Main iteration loop\n        double s, fs;\n        while (getEvaluations() < getMaxEvaluations()) {\n            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            // Check for convergence\n            final double tol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.abs(b);\n            final double m = 0.5 * (c - b);\n            if (FastMath.abs(m) <= tol || FastMath.abs(fb) <= getFunctionValueAccuracy()) {\n                return b;\n            }\n\n            // Attempt inverse quadratic interpolation\n            if (FastMath.abs(e) >= tol && FastMath.abs(fa) > FastMath.abs(fb)) {\n                final double s1 = fb / fa;\n                if (FastMath.abs(a - c) < getRelativeAccuracy()) {\n                    // If we're close enough to the limit of the floating point precision,\n                    // sqrt will round to 0 and not provide a real answer. This will only happen\n                    // if both pairs of x, y values were identical to the limit of precision:\n                    // lower limit + 2^k ulps and upper limit - 2^(k + 1) ulps. Since that issue\n                    // occurs for both a, b and a, c, we need to make sure to choose a slightly larger \"smallest\"\n                    // value to avoid that issue here.\n                    s = b - fb * (b - c) / FastMath.max(s1 - 1, 0.25);\n                } else {\n                    s = b - (b - a) * s1 / (s1 - (fb / fc) * ((c - b) / d));\n                }\n                if (((s - b) >= (0.5 * e)) || ((a - s) >= (0.5 * e)) ||\n                        (FastMath.abs(s - b) < tol) || (FastMath.abs(a - s) < tol)) {\n                    // Cannot do an interpolation, must do a bisection\n                    s = 0.5 * (a + b);\n                    e = b - s;\n                }\n            } else {\n                // Limit quadratic extrapolation to fall within the bounds\n                if (b >= c) {\n                    s = b - (fb / fa) * (c - b);\n                } else {\n                    s = b + (fb / fa) * (b - a);\n                }\n                if (((s - b) < (0.5 * tol)) || ((b - c) < (0.5 * tol))) {\n                    // Cannot do an extrapolation outside the bounds\n                    s = 0.5 * (a + b);\n                    e = b - s;\n                }\n            }\n\n            // Recompute minimal bracketing values if interpolation results in new minimum\n            if (FastMath.abs(s - c) < FastMath.abs(0.5 * e)) {\n                // If new point s is too close to c, move it towards b\n                if ((s >= c)) {\n                    e = a - s;\n                } else {\n                    e = b - s;\n                }\n                d = 0.5 * e;\n            } else {\n                // New bracketing values are the bounds or s\n                d = e;\n            }\n            a = b;\n            fa = fb;\n            if (FastMath.abs(d) > tol) {\n                b = s;\n                fb = computeObjectiveValue(b);\n            } else if (m > 0) {\n                b = b - tol;\n                fb = computeObjectiveValue(b);\n                if (fb * fc > 0) {\n                    return a;\n                }\n            } else {\n                b = b + tol;\n                fb = computeObjectiveValue(b);\n                if (fb * fc > 0) {\n                    return a;\n                }\n            }\n            if (FastMath.abs(fb) <= getFunctionValueAccuracy()) {\n                return b;\n            }\n            if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {\n                c = a;\n                fc = fa;\n                e = b - a;\n                d = e;\n            }\n        }\n\n        // Didn't converge within maximum iterations count\n        throw new MaxCountExceededExceptio",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..f138f5370 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,209 +140,183 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n-            return x[1];\n-        }\n-\n-        // evaluate first  endpoint\n-        y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n-            return x[0];\n-        }\n-\n-        int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n+import org.apache.commons.math.MathInternalError;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.util.FastMath;\n \n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n+public class BrentSolver extends AbstractUnivariateSolver {\n \n-        } else {\n+    /**\n+     * The maximum age of cached values.\n+     */\n+    private static final int MAXIMAL_AGING = 2;\n \n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n-            }\n+    /**\n+     * The default value of the {@link #setReductionFactor(double) reduction factor}.\n+     */\n+    private static final double DEFAULT_REDUCTION_FACTOR = 1 / 1024d;\n \n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n-            } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n-            }\n+    /**\n+     * An arbitrary high iteration count for supporting termination on function value.\n+     */\n+    private static final int MAXIMAL_ITERATIONS_COUNT = 1000000;\n \n-        }\n+    /**\n+     * The values.\n+     */\n+    private double[] f;\n \n-        // prepare a work array for inverse polynomial interpolation\n-        final double[] tmpX = new double[x.length];\n-\n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n-        while (true) {\n-\n-            // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n-                switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n-                }\n-            }\n+    /**\n+     * The point with the smallest value.\n+     */\n+    private int lastIntervalIndex;\n \n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n-            } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n-            }\n+    /**\n+     * Index of the top of the stack.\n+     */\n+    private int topIndex;\n \n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n-                    }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n+    /**\n+     * Abscissae.\n+     */\n+    private double[] x;\n \n-                }\n+    /**\n+     * Constructor for solver.\n+     *\n+     * @param relativeAccuracy Maximum relative error.\n+     * @param absoluteAccuracy Maximum absolute error.\n+     */\n+    public BrentSolver(final double relativeAccuracy,\n+                       final double absoluteAccuracy) {\n+        super(relativeAccuracy, absoluteAccuracy, FunctionEvaluation.MAX_EVALuations);\n+    }\n \n-            } while (Double.isNaN(nextX) && (end - start > 1));\n+    /**\n+     * Constructor using default values for relative and absolute accuracies.\n+     */\n+    public BrentSolver() {\n+        super(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY, FunctionEvaluation.MAX_EVALuations);\n+    }\n \n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected double doSolve() throws TooManyEvaluationsException {\n+        // Get initial function values at endpoints of interval.\n+        double a = getMin();\n+        double b = getMax();\n+        double fa = computeObjectiveValue(a);\n+        double fb = computeObjectiveValue(b);\n+\n+        // Verify bracketing, compute a and b such that f(a) < 0 < f(b)\n+        verifyBracketing(a, b);\n+\n+        // Prepare for iterations\n+        double c = a;\n+        double fc = fa;\n+        double e = b - a;\n+        double d = e;\n+\n+        // Main iteration loop\n+        double s, fs;\n+        while (getEvaluations() < getMaxEvaluations()) {\n+            if (FastMath.abs(fc) < FastMath.abs(fb)) {\n+                a = b;\n+                b = c;\n+                c = a;\n+                fa = fb;\n+                fb = fc;\n+                fc = fa;\n             }\n \n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n+            // Check for convergence\n+            final double tol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.abs(b);\n+            final double m = 0.5 * (c - b);\n+            if (FastMath.abs(m) <= tol || FastMath.abs(fb) <= getFunctionValueAccuracy()) {\n+                return b;\n             }\n \n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n-\n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n+            // Attempt inverse quadratic interpolation\n+            if (FastMath.abs(e) >= tol && FastMath.abs(fa) > FastMath.abs(fb)) {\n+                final double s1 = fb / fa;\n+                if (FastMath.abs(a - c) < getRelativeAccuracy()) {\n+                    // If we're close enough to the limit of the floating point precision,\n+                    // sqrt will round to 0 and not provide a real answer. This will only happen\n+                    // if both pairs of x, y values were identical to the limit of precision:\n+                    // lower limit + 2^k ulps and upper limit - 2^(k + 1) ulps. Since that issue\n+                    // occurs for both a, b and a, c, we need to make sure to choose a slightly larger \"smallest\"\n+                    // value to avoid that issue here.\n+                    s = b - fb * (b - c) / FastMath.max(s1 - 1, 0.25);\n+                } else {\n+                    s = b - (b - a) * s1 / (s1 - (fb / fc) * ((c - b) / d));\n+                }\n+                if (((s - b) >= (0.5 * e)) || ((a - s) >= (0.5 * e)) ||\n+                        (FastMath.abs(s - b) < tol) || (FastMath.abs(a - s) < tol)) {\n+                    // Cannot do an interpolation, must do a bisection\n+                    s = 0.5 * (a + b);\n+                    e = b - s;\n+                }\n+            } else {\n+                // Limit quadratic extrapolation to fall within the bounds\n+                if (b >= c) {\n+                    s = b - (fb / fa) * (c - b);\n+                } else {\n+                    s = b + (fb / fa) * (b - a);\n+                }\n+                if (((s - b) < (0.5 * tol)) || ((b - c) < (0.5 * tol))) {\n+                    // Cannot do an extrapolation outside the bounds\n+                    s = 0.5 * (a + b);\n+                    e = b - s;\n                 }\n-\n             }\n \n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n+            // Recompute minimal bracketing values if interpolation results in new minimum\n+            if (FastMath.abs(s - c) < FastMath.abs(0.5 * e)) {\n+                // If new point s is too close to c, move it towards b\n+                if ((s >= c)) {\n+                    e = a - s;\n+                } else {\n+                    e = b - s;\n+                }\n+                d = 0.5 * e;\n             } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n+                // New bracketing values are the bounds or s\n+                d = e;\n+            }\n+            a = b;\n+            fa = fb;\n+            if (FastMath.abs(d) > tol) {\n+                b = s;\n+                fb = computeObjectiveValue(b);\n+            } else if (m > 0) {\n+                b = b - tol;\n+                fb = computeObjectiveValue(b);\n+                if (fb * fc > 0) {\n+                    return a;\n+                }\n+            } else {\n+                b = b + tol;\n+                fb = computeObjectiveValue(b);\n+                if (fb * fc > 0) {\n+                    return a;\n+                }\n+            }\n+            if (FastMath.abs(fb) <= getFunctionValueAccuracy()) {\n+                return b;\n+            }\n+            if ((fb > 0 && fc > 0) || (fb < 0 && fc < 0)) {\n+                c = a;\n+                fc = fa;\n+                e = b - a;\n+                d = e;\n             }\n-\n         }\n \n-    }\n+        // Didn't converge within maximum iterations count\n+        throw new MaxCountExceededExceptio\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}