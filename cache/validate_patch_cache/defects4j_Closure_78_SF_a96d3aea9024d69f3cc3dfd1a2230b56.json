{
    "patch": "  private Node performArithmeticOp(int opType, Node left, Node right) {\n    // Unlike other operations, ADD operands are not always converted\n    // to Number.\n    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n      return null;\n    }\n\n    double result;\n\n    // TODO(johnlenz): Handle NaN with unknown value. BIT ops convert NaN\n    // to zero so this is a little akward here.\n\n    Double lValObj = NodeUtil.getNumberValue(left);\n    if (lValObj == null) {\n      return null;\n    }\n    Double rValObj = NodeUtil.getNumberValue(right);\n    if (rValObj == null) {\n      return null;\n    }\n\n    double lval = lValObj;\n    double rval = rValObj;\n\n    switch (opType) {\n      case Token.BITAND:\n        result = ScriptRuntime.toInt32(lval) & ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITOR:\n        result = ScriptRuntime.toInt32(lval) | ScriptRuntime.toInt32(rval);\n        break;\n      case Token.BITXOR:\n        result = ScriptRuntime.toInt32(lval) ^ ScriptRuntime.toInt32(rval);\n        break;\n      case Token.ADD:\n        result = lval + rval;\n        break;\n      case Token.SUB:\n        result = lval - rval;\n        break;\n      case Token.MUL:\n        result = lval * rval;\n        break;\n      case Token.MOD:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return new Node(Token.NEG, Node.newNumber(Double.NaN));\n        }\n        result = lval % rval;\n        break;\n      case Token.DIV:\n        if (rval == 0) {\n          error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n          return new Node(Token.NEG, Node.newNumber(Double.NEGATIVE_INFINITY));\n        }\n        result = lval / rval;\n        break;\n      default:\n        throw new Error(\"Unexpected arithmetic operator\");\n    }\n\n    // TODO(johnlenz): consider removing the result length check.\n    // length of the left and right value plus 1 byte for the operator.\n    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n\n        // Do not try to fold arithmetic for numbers > 2^53. After that\n        // point, fixed-point math starts to break down and become inaccurate.\n        Math.abs(result) <= MAX_FOLD_NUMBER) {\n      Node newNumber = Node.newNumber(result);\n      return newNumber;\n    } else if (Double.isNaN(result)) {\n      return Node.newString(Token.NAME, \"NaN\");\n    } else if (result == Double.POSITIVE_INFINITY) {\n      return Node.newString(Token.NAME, \"Infinity\");\n    } else if (result == Double.NEGATIVE_INFINITY) {\n      return Node.newUnary(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n    }\n\n    return null;\n  }\n\n  private void error(DiagnosticType type, String message, Node n, String... parameters) {\n    JSError error = JSError.make(n.getSourceFileName(), n.getLineno(), n.getCharno(),\n        type, message, (Object[]) parameters);\n\n    if (getErrorManager() == null) {\n      throw new RuntimeException(error.toString(), null);\n    }\n\n    getErrorManager().report(error);\n  }\n\n  private void error(DiagnosticType type, String message, Node n) {\n    error(type, message, n, new String[0]);\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex c5ef4b0f..a7f388dc 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -664,9 +664,7 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n   private Node performArithmeticOp(int opType, Node left, Node right) {\n     // Unlike other operations, ADD operands are not always converted\n     // to Number.\n-    if (opType == Token.ADD\n-        && (NodeUtil.mayBeString(left, false)\n-            || NodeUtil.mayBeString(right, false))) {\n+    if (opType == Token.ADD && (NodeUtil.mayBeString(left, false) || NodeUtil.mayBeString(right, false))) {\n       return null;\n     }\n \n@@ -709,14 +707,14 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n       case Token.MOD:\n         if (rval == 0) {\n           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n+          return new Node(Token.NEG, Node.newNumber(Double.NaN));\n         }\n         result = lval % rval;\n         break;\n       case Token.DIV:\n         if (rval == 0) {\n           error(DiagnosticType.error(\"JSC_DIVIDE_BY_0_ERROR\", \"Divide by 0\"), right);\n-          return null;\n+          return new Node(Token.NEG, Node.newNumber(Double.NEGATIVE_INFINITY));\n         }\n         result = lval / rval;\n         break;\n@@ -726,8 +724,7 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n \n     // TODO(johnlenz): consider removing the result length check.\n     // length of the left and right value plus 1 byte for the operator.\n-    if (String.valueOf(result).length() <=\n-        String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n+    if (String.valueOf(result).length() <= String.valueOf(lval).length() + String.valueOf(rval).length() + 1 &&\n \n         // Do not try to fold arithmetic for numbers > 2^53. After that\n         // point, fixed-point math starts to break down and become inaccurate.\n@@ -739,12 +736,27 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     } else if (result == Double.POSITIVE_INFINITY) {\n       return Node.newString(Token.NAME, \"Infinity\");\n     } else if (result == Double.NEGATIVE_INFINITY) {\n-      return new Node(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n+      return Node.newUnary(Token.NEG, Node.newString(Token.NAME, \"Infinity\"));\n     }\n \n     return null;\n   }\n \n+  private void error(DiagnosticType type, String message, Node n, String... parameters) {\n+    JSError error = JSError.make(n.getSourceFileName(), n.getLineno(), n.getCharno(),\n+        type, message, (Object[]) parameters);\n+\n+    if (getErrorManager() == null) {\n+      throw new RuntimeException(error.toString(), null);\n+    }\n+\n+    getErrorManager().report(error);\n+  }\n+\n+  private void error(DiagnosticType type, String message, Node n) {\n+    error(type, message, n, new String[0]);\n+  }\n+\n   /**\n    * Expressions such as [foo() * 10 * 20] generate parse trees\n    * where no node has two const children ((foo() * 10) * 20), so",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}