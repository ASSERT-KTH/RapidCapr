{
    "patch": "        // check if endpoints bracket the root\n        if (yMin * yMax >= 0) {\n            throw new IllegalArgumentException(\"The provided interval [\" + min + \", \" + max + \"] does not bracket a root.\");\n        }\n        \n        // Full Brent algorithm starting with provided initial guess\n        double a = (yMin < 0) ? min : max;\n        double b = (a == min) ? max : min;\n        double fa = (a == min) ? yMin : yMax;\n        double fb = yInitial;\n        double c = a;\n        double fc = fa;\n        boolean mflag = true;\n        double d = 0;\n        double e = 0;\n        int iter = 0;\n        while (iter < MAX_ITERATIONS) {\n            if (fa != fc && fb != fc) {\n                // Use inverse quadratic interpolation.\n                double denom = (fa - fb) * (fa - fc) * (fb - fc);\n                double num = a * (fa - fb) * (fb - fc) + b * (fb - fc) * (fc - fa) + c * (fc - fa) * (fa - fb);\n                d = num / denom;\n                if (isBounded(d, a, b)) {\n                    if (isBetter(d, (a + b) / 2, b)) {\n                        e = d;\n                    } else {\n                        e = (a + b) / 2;\n                    }\n                    mflag = false;\n                } else {\n                    mflag = true;\n                }\n            } else {\n                // Use bisection.\n                e = (a + b) / 2;\n                mflag = true;\n            }\n            double tol = 2 * EPSILON * Math.max(Math.abs(e), 1);\n            if (Math.abs(f.value(e)) <= functionValueAccuracy || (mflag && (b - a) < tol)) {\n                setResult(e, iter + 1);\n                return result;\n            }\n            if (isBetter(e, initial, b)) {\n                fb = f.value(e);\n                if (isBetter(fa, fb, 0)) {\n                    b = e;\n                    yMax = fb;\n                } else {\n                    a = initial;\n                    b = e;\n                }\n            } else {\n                fa = f.value(e);\n                if (isBetter(fa, fb, 0)) {\n                    b = initial;\n                    a = e;\n                    yMin = fa;\n                } else {\n                    a = e;\n                    yMin = fa;\n                }\n            }\n            if (mflag) {\n                fc = fa;\n                d = e;\n                e = (a + b) / 2;\n                fb = f.value(e);\n            }\n            iter++;\n        }\n        setResult(Double.NaN, iter);\n        throw new MaxIterationsExceededException(MAX_ITERATIONS);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..d84abccd7 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,78 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        // check if endpoints bracket the root\n+        if (yMin * yMax >= 0) {\n+            throw new IllegalArgumentException(\"The provided interval [\" + min + \", \" + max + \"] does not bracket a root.\");\n+        }\n+        \n+        // Full Brent algorithm starting with provided initial guess\n+        double a = (yMin < 0) ? min : max;\n+        double b = (a == min) ? max : min;\n+        double fa = (a == min) ? yMin : yMax;\n+        double fb = yInitial;\n+        double c = a;\n+        double fc = fa;\n+        boolean mflag = true;\n+        double d = 0;\n+        double e = 0;\n+        int iter = 0;\n+        while (iter < MAX_ITERATIONS) {\n+            if (fa != fc && fb != fc) {\n+                // Use inverse quadratic interpolation.\n+                double denom = (fa - fb) * (fa - fc) * (fb - fc);\n+                double num = a * (fa - fb) * (fb - fc) + b * (fb - fc) * (fc - fa) + c * (fc - fa) * (fa - fb);\n+                d = num / denom;\n+                if (isBounded(d, a, b)) {\n+                    if (isBetter(d, (a + b) / 2, b)) {\n+                        e = d;\n+                    } else {\n+                        e = (a + b) / 2;\n+                    }\n+                    mflag = false;\n+                } else {\n+                    mflag = true;\n+                }\n+            } else {\n+                // Use bisection.\n+                e = (a + b) / 2;\n+                mflag = true;\n+            }\n+            double tol = 2 * EPSILON * Math.max(Math.abs(e), 1);\n+            if (Math.abs(f.value(e)) <= functionValueAccuracy || (mflag && (b - a) < tol)) {\n+                setResult(e, iter + 1);\n+                return result;\n+            }\n+            if (isBetter(e, initial, b)) {\n+                fb = f.value(e);\n+                if (isBetter(fa, fb, 0)) {\n+                    b = e;\n+                    yMax = fb;\n+                } else {\n+                    a = initial;\n+                    b = e;\n+                }\n+            } else {\n+                fa = f.value(e);\n+                if (isBetter(fa, fb, 0)) {\n+                    b = initial;\n+                    a = e;\n+                    yMin = fa;\n+                } else {\n+                    a = e;\n+                    yMin = fa;\n+                }\n+            }\n+            if (mflag) {\n+                fc = fa;\n+                d = e;\n+                e = (a + b) / 2;\n+                fb = f.value(e);\n+            }\n+            iter++;\n+        }\n+        setResult(Double.NaN, iter);\n+        throw new MaxIterationsExceededException(MAX_ITERATIONS);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}