{
    "patch": "    /**\n     * Computes a root of the function in the given interval.\n     *\n     * @param maxEval Maximum number of evaluations.\n     * @param f Function to solve.\n     * @param min Lower bound of the search interval.\n     * @param max Upper bound of the search interval.\n     * @throws TooManyEvaluationsException if the maximum evaluations number is exceeded.\n     * @throws IllegalArgumentException if the endpoints do not satisfy the requirements of the algorithm\n     *   or the function is not bracketing the root with opposite signs.\n     * @throws ConvergenceException if the algorithm fails to converge.\n     * @return the point at which the function value is zero.\n     */\n    public double solve(int maxEval, UnivariateFunction f, double min, double max)\n        throws TooManyEvaluationsException, ConvergenceException {\n        clearResult();\n        // Compute initial solution\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (yMin * yMax >= 0) {\n            throw new IllegalArgumentException(\n                            \"Function values at endpoints do not have different signs.\"\n                            + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n        }\n\n        // Get accuracies.\n        final double ftol = getFunctionValueAccuracy();\n        final double atol = getAbsoluteAccuracy();\n        final double rtol = getRelativeAccuracy();\n\n        // Keep track of inverted intervals, meaning that the left bound is\n        // larger than the right bound.\n        boolean inverted = false;\n\n        // Keep finding better approximations.\n        while (getEvaluations() < maxEval) {\n            final double x;\n            final double y;\n            if (FastMath.abs(yMin) < FastMath.abs(yMax)) {\n                // Lower bound is closer to a root, replace it.\n                x = min;\n                y = yMin;\n            } else {\n                // Upper bound is closer to a root, replace it.\n                x = max;\n                y = yMax;\n                max = min;\n                min = x;\n                final double tmp = yMax;\n                yMax = yMin;\n                yMin = tmp;\n                inverted = !inverted;\n            }\n\n            // If either of the current bounds is an exact root, we can return it\n            // immediately since these are not under-approximations or over-approximations.\n            if (y == 0.0) {\n                setResult(x, getEvaluations());\n                return x;\n            }\n\n            // Calculate the new approximation.\n            final double delta;\n            if (Double.isInfinite(y) || Double.isNaN(y)) {\n                // Use bisection for infinite or NaN function values.\n                delta = 0.5 * (max - min);\n            } else {\n                delta = y * (max - min) / (yMax - yMin);\n            }\n            final double oldX = x;\n            final double newX = x - delta;\n\n            // If the new approximation is the same as the old one, it means we are trapped\n            // by a numerical imprecision. We refuse to fool ourselves by returning a root\n            // without correctness guarantees, we will throw away this value and start again.\n            if (newX == oldX) {\n                yMin = f.value(min);\n                yMax = f.value(max);\n                if (yMin * yMax >= 0) {\n                    throw new ConvergenceException(\n                                    \"Unable to find a solution within given max iterations\"\n                                    + \" and accuracy \" + getFunctionValueAccuracy());\n                }\n                setResult(Double.NaN, getEvaluations());\n                continue;\n            }\n\n            final double newY = f.value(newX);\n\n            // If the new function value has the same sign as the endpoint that we replaced, it means\n            // our endpoint is still a valid point for our bracketing, therefore we keep it.\n            if (newY * y < 0.0) {\n                max = oldX;\n//                yMax = y; // Use y with opposite sign from current yMin / yMax\n                yMax = newY;\n            } else {\n                min = oldX;\n//                yMin = y;  // Use y with opposite sign from current yMin / yMax\n                yMin = newY;\n            }\n\n            // If the function value of the last approximation is too small,\n            // given the function value accuracy, then we can't get closer to\n            // the root than we already are.\n            if (FastMath.abs(y) <= ftol) {\n                setResult(x, getEvaluations());\n                return x;\n            }\n\n            // If the current interval is within the given accuracies, we\n            // are satisfied with the current approximation.\n            if (FastMath.abs(max - min) < FastMath.max(rtol * FastMath.max(FastMath.abs(max), FastMath.abs(min)),\n                                                     atol)) {\n                x = 0.5 * (min + max);\n                setResult(x, getEvaluations());\n                return x;\n            }\n        }\n        throw new TooManyEvaluationsException(maxEval);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex 8a667dad3..a39cafb63 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -126,26 +126,31 @@ public abstract class BaseSecantSolver\n     }\n \n     /** {@inheritDoc} */\n-    protected final double doSolve() {\n-        // Get initial solution\n-        double x0 = getMin();\n-        double x1 = getMax();\n-        double f0 = computeObjectiveValue(x0);\n-        double f1 = computeObjectiveValue(x1);\n-\n-        // If one of the bounds is the exact root, return it. Since these are\n-        // not under-approximations or over-approximations, we can return them\n-        // regardless of the allowed solutions.\n-        if (f0 == 0.0) {\n-            return x0;\n-        }\n-        if (f1 == 0.0) {\n-            return x1;\n+    /**\n+     * Computes a root of the function in the given interval.\n+     *\n+     * @param maxEval Maximum number of evaluations.\n+     * @param f Function to solve.\n+     * @param min Lower bound of the search interval.\n+     * @param max Upper bound of the search interval.\n+     * @throws TooManyEvaluationsException if the maximum evaluations number is exceeded.\n+     * @throws IllegalArgumentException if the endpoints do not satisfy the requirements of the algorithm\n+     *   or the function is not bracketing the root with opposite signs.\n+     * @throws ConvergenceException if the algorithm fails to converge.\n+     * @return the point at which the function value is zero.\n+     */\n+    public double solve(int maxEval, UnivariateFunction f, double min, double max)\n+        throws TooManyEvaluationsException, ConvergenceException {\n+        clearResult();\n+        // Compute initial solution\n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n+        if (yMin * yMax >= 0) {\n+            throw new IllegalArgumentException(\n+                            \"Function values at endpoints do not have different signs.\"\n+                            + \"  Endpoints: [\" + min + \",\" + max + \"]\" + \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n         }\n \n-        // Verify bracketing of initial solution.\n-        verifyBracketing(x0, x1);\n-\n         // Get accuracies.\n         final double ftol = getFunctionValueAccuracy();\n         final double atol = getAbsoluteAccuracy();\n@@ -156,98 +161,90 @@ public abstract class BaseSecantSolver\n         boolean inverted = false;\n \n         // Keep finding better approximations.\n-        while (true) {\n-            // Calculate the next approximation.\n-            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n-            final double fx = computeObjectiveValue(x);\n+        while (getEvaluations() < maxEval) {\n+            final double x;\n+            final double y;\n+            if (FastMath.abs(yMin) < FastMath.abs(yMax)) {\n+                // Lower bound is closer to a root, replace it.\n+                x = min;\n+                y = yMin;\n+            } else {\n+                // Upper bound is closer to a root, replace it.\n+                x = max;\n+                y = yMax;\n+                max = min;\n+                min = x;\n+                final double tmp = yMax;\n+                yMax = yMin;\n+                yMin = tmp;\n+                inverted = !inverted;\n+            }\n \n-            // If the new approximation is the exact root, return it. Since\n-            // this is not an under-approximation or an over-approximation,\n-            // we can return it regardless of the allowed solutions.\n-            if (fx == 0.0) {\n+            // If either of the current bounds is an exact root, we can return it\n+            // immediately since these are not under-approximations or over-approximations.\n+            if (y == 0.0) {\n+                setResult(x, getEvaluations());\n                 return x;\n             }\n \n-            // Update the bounds with the new approximation.\n-            if (f1 * fx < 0) {\n-                // The value of x1 has switched to the other bound, thus inverting\n-                // the interval.\n-                x0 = x1;\n-                f0 = f1;\n-                inverted = !inverted;\n+            // Calculate the new approximation.\n+            final double delta;\n+            if (Double.isInfinite(y) || Double.isNaN(y)) {\n+                // Use bisection for infinite or NaN function values.\n+                delta = 0.5 * (max - min);\n             } else {\n-                switch (method) {\n-                case ILLINOIS:\n-                    f0 *= 0.5;\n-                    break;\n-                case PEGASUS:\n-                    f0 *= f1 / (f1 + fx);\n-                    break;\n-                case REGULA_FALSI:\n-                    // Detect early that algorithm is stuck, instead of waiting\n-                    // for the maximum number of iterations to be exceeded.\n-                    break;\n-                default:\n-                    // Should never happen.\n-                    throw new MathInternalError();\n+                delta = y * (max - min) / (yMax - yMin);\n+            }\n+            final double oldX = x;\n+            final double newX = x - delta;\n+\n+            // If the new approximation is the same as the old one, it means we are trapped\n+            // by a numerical imprecision. We refuse to fool ourselves by returning a root\n+            // without correctness guarantees, we will throw away this value and start again.\n+            if (newX == oldX) {\n+                yMin = f.value(min);\n+                yMax = f.value(max);\n+                if (yMin * yMax >= 0) {\n+                    throw new ConvergenceException(\n+                                    \"Unable to find a solution within given max iterations\"\n+                                    + \" and accuracy \" + getFunctionValueAccuracy());\n                 }\n+                setResult(Double.NaN, getEvaluations());\n+                continue;\n+            }\n+\n+            final double newY = f.value(newX);\n+\n+            // If the new function value has the same sign as the endpoint that we replaced, it means\n+            // our endpoint is still a valid point for our bracketing, therefore we keep it.\n+            if (newY * y < 0.0) {\n+                max = oldX;\n+//                yMax = y; // Use y with opposite sign from current yMin / yMax\n+                yMax = newY;\n+            } else {\n+                min = oldX;\n+//                yMin = y;  // Use y with opposite sign from current yMin / yMax\n+                yMin = newY;\n             }\n-            // Update from [x0, x1] to [x0, x].\n-            x1 = x;\n-            f1 = fx;\n \n             // If the function value of the last approximation is too small,\n             // given the function value accuracy, then we can't get closer to\n             // the root than we already are.\n-            if (FastMath.abs(f1) <= ftol) {\n-                switch (allowed) {\n-                case ANY_SIDE:\n-                    return x1;\n-                case LEFT_SIDE:\n-                    if (inverted) {\n-                        return x1;\n-                    }\n-                    break;\n-                case RIGHT_SIDE:\n-                    if (!inverted) {\n-                        return x1;\n-                    }\n-                    break;\n-                case BELOW_SIDE:\n-                    if (f1 <= 0) {\n-                        return x1;\n-                    }\n-                    break;\n-                case ABOVE_SIDE:\n-                    if (f1 >= 0) {\n-                        return x1;\n-                    }\n-                    break;\n-                default:\n-                    throw new MathInternalError();\n-                }\n+            if (FastMath.abs(y) <= ftol) {\n+                setResult(x, getEvaluations());\n+                return x;\n             }\n \n             // If the current interval is within the given accuracies, we\n             // are satisfied with the current approximation.\n-            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n+            if (FastMath.abs(max - min) < FastMath.max(rtol * FastMath.max(FastMath.abs(max), FastMath.abs(min)),\n                                                      atol)) {\n-                switch (allowed) {\n-                case ANY_SIDE:\n-                    return x1;\n-                case LEFT_SIDE:\n-                    return inverted ? x1 : x0;\n-                case RIGHT_SIDE:\n-                    return inverted ? x0 : x1;\n-                case BELOW_SIDE:\n-                    return (f1 <= 0) ? x1 : x0;\n-                case ABOVE_SIDE:\n-                    return (f1 >= 0) ? x1 : x0;\n-                default:\n-                    throw new MathInternalError();\n-                }\n+                x = 0.5 * (min + max);\n+                setResult(x, getEvaluations());\n+                return x;\n             }\n         }\n+        throw new TooManyEvaluationsException(maxEval);\n     }\n \n     /** <em>Secant</em>-based root-finding methods. */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}