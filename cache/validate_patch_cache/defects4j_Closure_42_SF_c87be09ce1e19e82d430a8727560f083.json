{
    "patch": "private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\");\n\n  private static class TransformDispatcher extends IRFactory.TypeSafeDispatcher<Node> {\n\n    private String sourceName;\n    private ErrorReporter errorReporter;\n\n    public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n      this.sourceName = sourceName;\n      this.errorReporter = errorReporter;\n    }\n\n    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getType();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    @Override\n    public Node visit(AstNode node) {\n      throw new UnsupportedOperationException(\n          \"visit(\" + node.getClass().getName() + \")\");\n    }\n\n    @Override\n    public Node visitArrayComprehension(ArrayComprehension node) {\n      // Array comprehensions are not supported.\n      return null;\n    }\n\n    @Override\n    public Node visitArrayLiteral(ArrayLiteral node) {\n      Node newNode = newNode(Token.ARRAYLIT);\n      for (AstNode child : node.getElements()) {\n        if (child instanceof EmptyExpression) {\n          // Transform EmptyExpression to a hole (null).\n          newNode.addChildToBack(newNode(Token.NULL));\n        } else {\n          newNode.addChildToBack(transform(child));\n        }\n      }\n      return newNode;\n    }\n\n    @Override\n    public Node visitAssignment(Assignment node) {\n      Node target = transform(node.getLeft());\n      Node value = transform(node.getRight());\n      return newNode(node.getType(), target, value);\n    }\n\n    @Override\n    public Node visitAstRoot(AstRoot node) {\n      return transform(node.getFirstChild());\n    }\n\n    @Override\n    public Node visitBlock(Block node) {\n      Node result = newNode(Token.BLOCK);\n      for (Node child : node) {\n        result.addChildToBack(transform(child));\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitBreakStatement(BreakStatement node) {\n      Node result = newNode(Token.BREAK);\n      if (node.getBreakLabel() != null) {\n        Node labelName = transform(node.getBreakLabel());\n        labelName.setType(Token.LABEL_NAME);\n        result.addChildToBack(labelName);\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitConditionalExpression(ConditionalExpression node) {\n      return newNode(\n          Token.HOOK,\n          transform(node.getTestExpression()),\n          transform(node.getTrueExpression()),\n          transform(node.getFalseExpression()));\n    }\n\n    @Override\n    public Node visitContinueStatement(ContinueStatement node) {\n      Node result = newNode(Token.CONTINUE);\n      if (node.getLabel() != null) {\n        Node labelName = transform(node.getLabel());\n        labelName.setType(Token.LABEL_NAME);\n        result.addChildToBack(labelName);\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitDoLoop(DoLoop node) {\n      return newNode(Token.DO, transform(node.getBody()), transform(node.getCondition()));\n    }\n\n    @Override\n    public Node visitElementGet(ElementGet node) {\n      return newNode(Token.GETELEM, transform(node.getTarget()), transform(node.getElement()));\n    }\n\n    @Override\n    public Node visitEmptyExpression(EmptyExpression node) {\n      return newNode(Token.EMPTY);\n    }\n\n    @Override\n    public Node visitExpressionStatement(ExpressionStatement node) {\n      Node result = newNode(Token.EXPR_RESULT);\n      result.addChildToBack(transform(node.getExpression()));\n      return result;\n    }\n\n    @Override\n    public Node visitForInLoop(ForInLoop node) {\n      Node lhsNode = transform(node.getIterator());\n      Node rhsNode = transform(node.getIteratedObject());\n      Node bodyNode = transform(node.getBody());\n      Node result = newNode(Token.FOR_IN, lhsNode, rhsNode, bodyNode);\n      result.addChildToBack(newNode(Token.EMPTY)); // Fix here\n      return result;\n    }\n\n    @Override\n    public Node visitForLoop(ForLoop node) {\n      Node initial = transform(node.getInitializer());\n      Node condition = transform(node.getCondition());\n      Node increment = transform(node.getIncrement());\n      return newNode(Token.FOR, initial, condition, increment, transform(node.getBody()));\n    }\n\n    @Override\n    public Node visitFunctionCall(FunctionCall node) {\n      Node target = transform(node.getTarget());\n      Node result = newNode(Token.CALL, target);\n      for (AstNode arg : node.getArguments()) {\n        result.addChildToBack(transform(arg));\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitFunctionNode(FunctionNode node) {\n      Node result = newNode(Token.FUNCTION);\n      if (node.getFunctionName() != null) {\n        Node name = newNode(Token.NAME, node.getFunctionName());\n        result.addChildToBack(name);\n      }\n      Node params = newNode(Token.PARAM_LIST);\n      for (Node param : node.getParams()) {\n        params.addChildToBack(transform(param));\n      }\n      result.addChildToBack(params);\n      result.addChildToBack(transform(node.getBody()));\n      return result;\n    }\n\n    @Override\n    public Node visitIfStatement(IfStatement node) {\n      Node condition = transform(node.getCondition());\n      Node ifTrue = transform(node.getThenPart());\n      Node ifFalse = transform(node.getElsePart());\n      return newNode(Token.IF, condition, ifTrue, ifFalse);\n    }\n\n    @Override\n    public Node visitInfixExpression(InfixExpression node) {\n      Node left = transform(node.getLeft());\n      Node right = transform(node.getRight());\n      return newNode(node.getType(), left, right);\n    }\n\n    @Override\n    public Node visitKeywordLiteral(KeywordLiteral node) {\n      return newNode(node.getType());\n    }\n\n    @Override\n    public Node visitName(Name node) {\n      return newNode(Token.NAME, node.getIdentifier());\n    }\n\n    @Override\n    public Node visitNumberLiteral(NumberLiteral node) {\n      return newNode(Token.NUMBER, node.getValue());\n    }\n\n    @Override\n    public Node visitObjectLiteral(ObjectLiteral node) {\n      Node result = newNode(Token.OBJECTLIT);\n      for (ObjectProperty prop : node.getElements()) {\n        AstNode left = prop.getLeft();\n        Node right = transform(prop.getRight());\n        Node member = null;\n        if (left instanceof StringLiteral) {\n          member = newNode(Token.STRING, ((StringLiteral) left).getValue());\n        } else if (left instanceof Name) {\n          member = newNode(Token.STRING, left.getString());\n        } else if (left instanceof NumberLiteral) {\n          member = newNode(Token.NUMBER, left.getDouble());\n        } else {\n          throw new AssertionError(\"Unexpected object literal property type \" + left.getClass());\n        }\n        member.addChildToBack(right);\n        result.addChildToBack(member);\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitRegExpLiteral(RegExpLiteral node) {\n      return newNode(Token.REGEXP, node.getValue(), node.getFlags());\n    }\n\n    @Override\n    public Node visitReturnStatement(ReturnStatement node) {\n      return newNode(Token.RETURN, transform(node.getReturnValue()));\n    }\n\n    @Override\n    public Node visitStringLiteral(StringLiteral node) {\n      return newNode(Token.STRING, node.getValue());\n    }\n\n    @Override\n    public Node visitSwitchCase(SwitchCase node) {\n      Node result;\n      if (node.getExpression() != null) {\n        result = newNode(Token.CASE, transform(node.getExpression()));\n      } else {\n        result = newNode(Token.DEFAULT);\n      }\n      for (AstNode stmt : node.getStatements()) {\n        result.addChildToBack(transform(stmt));\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitSwitchStatement(SwitchStatement node) {\n      Node result = newNode(Token.SWITCH, transform(node.getExpression()));\n      for (SwitchCase switchCase : node.getCases()) {\n        result.addChildToBack(transform(switchCase));\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitThrowStatement(ThrowStatement node) {\n      return newNode(Token.THROW, transform(node.getExpression()));\n    }\n\n    @Override\n    public Node visitTryStatement(TryStatement node) {\n      Node result = newNode(Token.TRY, transform(node.getTryBlock()));\n      if (node.getCatchClause() != null) {\n        Node catchNode = newNode(Token.CATCH);\n        catchNode.addChildToBack(transform(node.getCatchCondition()));\n        catchNode.addChildToBack(transform(node.getCatchBody()));\n        result.addChildToBack(catchNode);\n      }\n      if (node.getFinallyBlock() != null) {\n        result.addChildToBack(transform(node.getFinallyBlock()));\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitUnaryExpression(UnaryExpression node) {\n      Node child = transform(node.getOperand());\n      return newNode(node.getType(), child);\n    }\n\n    @Override\n    public Node visitVariableDeclaration(VariableDeclaration node) {\n      Node result = newNode(Token.VAR);\n      for (VariableInitializer var : node.getVariableInitializer()) {\n        AstNode target = var.getTarget();\n        Node initializer = transform(var.getInitializer());\n        if (target instanceof Name) {\n          Node name = newNode(Token.NAME, target.getIdentifier());\n          name.addChildToBack(initializer);\n          result.addChildToBack(name);\n        } else if (target instanceof DestructuringForm) {\n          result.addChildToBack(transformDestructuringForm((DestructuringForm) target, initializer));\n        } else {\n          throw new AssertionError(\"Unexpected variable declaration type \" + target.getClass());\n        }\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitWhileLoop(WhileLoop node) {\n      return newNode(Token.WHILE, transform(node.getCondition()), transform(node.getBody()));\n    }\n\n    @Override\n    public Node visitWithStatement(WithStatement node) {\n      return newNode(Token.WITH, transform(node.getExpression()), transform(node.getStatement()));\n    }\n\n    private Node transform(AstNode node) {\n      if (node == null) {\n        return null;\n      }\n      return node.accept(this);\n    }\n\n    private Node transformDestructuringForm(DestructuringForm target, Node initializer) {\n      Node result = newNode(Token.DESTRUCTURING_VAR);\n      for (AstNode element : target) {\n        if (element instanceof Name) {\n          Node name = newNode(Token.NAME, element.getIdentifier());\n          if (initializer != null) {\n            name.addChildToBack(initializer);\n          }\n          result.addChildToBack(name);\n        } else if (element instanceof ArrayLiteral) {\n          Node arr = newNode(Token.ARRAYLIT);\n          for (AstNode arrElement : element) {\n            arr.addChildToBack(transformDestructuringForm((DestructuringForm)arrElement, initializer));\n          }\n          result.addChildToBack(arr);\n        } else if (element instanceof ObjectLiteral) {\n          Node obj = newNode(Token.OBJECTLIT);\n          for (ObjectProperty prop : ((ObjectLiteral) element).getElements()) {\n            Node value = prop.getRight() != null ? transformDestructuringForm((DestructuringForm)prop.getLeft(), initializer) : null;\n            Node member;\n            if (prop.getLeft() instanceof StringLiteral) {\n              member = newNode(Token.STRING, ((StringLiteral) prop.getLeft()).getValue());\n            } else if (prop.getLeft() instanceof Name) {\n              member = newNode(Token.STRING, prop.getLeft().getString());\n            } else if (prop.getLeft() instanceof DestructuringForm) {\n              member = transformDestructuringForm((DestructuringForm)prop.getLeft(), initializer);\n            } else {\n              throw new AssertionError(\"Unexpected object literal property type \" + prop.getLeft().getClass());\n            }\n            if (value != null) {\n              member.addChildToBack(value);\n            }\n            obj.addChildToBack(member);\n          }\n          result.addChildToBack(obj);\n        } else {\n          throw new AssertionError(\"Unexpected node type for destructuring target \" + element.getClass());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..b73143b9 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,6 +473,19 @@ class IRFactory {\n       }\n     }\n \n+private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\");\n+\n+  private static class TransformDispatcher extends IRFactory.TypeSafeDispatcher<Node> {\n+\n+    private String sourceName;\n+    private ErrorReporter errorReporter;\n+\n+    public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n+      this.sourceName = sourceName;\n+      this.errorReporter = errorReporter;\n+    }\n+\n     private boolean isDirective(Node n) {\n       if (n == null) return false;\n \n@@ -483,97 +496,339 @@ class IRFactory {\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node visit(AstNode node) {\n+      throw new UnsupportedOperationException(\n+          \"visit(\" + node.getClass().getName() + \")\");\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public Node visitArrayComprehension(ArrayComprehension node) {\n+      // Array comprehensions are not supported.\n+      return null;\n+    }\n+\n+    @Override\n+    public Node visitArrayLiteral(ArrayLiteral node) {\n+      Node newNode = newNode(Token.ARRAYLIT);\n+      for (AstNode child : node.getElements()) {\n+        if (child instanceof EmptyExpression) {\n+          // Transform EmptyExpression to a hole (null).\n+          newNode.addChildToBack(newNode(Token.NULL));\n+        } else {\n+          newNode.addChildToBack(transform(child));\n+        }\n       }\n-      return node;\n+      return newNode;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    public Node visitAssignment(Assignment node) {\n+      Node target = transform(node.getLeft());\n+      Node value = transform(node.getRight());\n+      return newNode(node.getType(), target, value);\n+    }\n+\n+    @Override\n+    public Node visitAstRoot(AstRoot node) {\n+      return transform(node.getFirstChild());\n+    }\n+\n+    @Override\n+    public Node visitBlock(Block node) {\n+      Node result = newNode(Token.BLOCK);\n+      for (Node child : node) {\n+        result.addChildToBack(transform(child));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+      return result;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+    public Node visitBreakStatement(BreakStatement node) {\n+      Node result = newNode(Token.BREAK);\n+      if (node.getBreakLabel() != null) {\n+        Node labelName = transform(node.getBreakLabel());\n+        labelName.setType(Token.LABEL_NAME);\n+        result.addChildToBack(labelName);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitConditionalExpression(ConditionalExpression node) {\n       return newNode(\n           Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+          transform(node.getTestExpression()),\n+          transform(node.getTrueExpression()),\n+          transform(node.getFalseExpression()));\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n+    public Node visitContinueStatement(ContinueStatement node) {\n+      Node result = newNode(Token.CONTINUE);\n+      if (node.getLabel() != null) {\n+        Node labelName = transform(node.getLabel());\n         labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+        result.addChildToBack(labelName);\n       }\n-      return node;\n+      return result;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node visitDoLoop(DoLoop node) {\n+      return newNode(Token.DO, transform(node.getBody()), transform(node.getCondition()));\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node visitElementGet(ElementGet node) {\n+      return newNode(Token.GETELEM, transform(node.getTarget()), transform(node.getElement()));\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node visitEmptyExpression(EmptyExpression node) {\n+      return newNode(Token.EMPTY);\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node visitExpressionStatement(ExpressionStatement node) {\n+      Node result = newNode(Token.EXPR_RESULT);\n+      result.addChildToBack(transform(node.getExpression()));\n+      return result;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node visitForInLoop(ForInLoop node) {\n+      Node lhsNode = transform(node.getIterator());\n+      Node rhsNode = transform(node.getIteratedObject());\n+      Node bodyNode = transform(node.getBody());\n+      Node result = newNode(Token.FOR_IN, lhsNode, rhsNode, bodyNode);\n+      result.addChildToBack(newNode(Token.EMPTY)); // Fix here\n+      return result;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    @Override\n+    public Node visitForLoop(ForLoop node) {\n+      Node initial = transform(node.getInitializer());\n+      Node condition = transform(node.getCondition());\n+      Node increment = transform(node.getIncrement());\n+      return newNode(Token.FOR, initial, condition, increment, transform(node.getBody()));\n+    }\n+\n+    @Override\n+    public Node visitFunctionCall(FunctionCall node) {\n+      Node target = transform(node.getTarget());\n+      Node result = newNode(Token.CALL, target);\n+      for (AstNode arg : node.getArguments()) {\n+        result.addChildToBack(transform(arg));\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitFunctionNode(FunctionNode node) {\n+      Node result = newNode(Token.FUNCTION);\n+      if (node.getFunctionName() != null) {\n+        Node name = newNode(Token.NAME, node.getFunctionName());\n+        result.addChildToBack(name);\n+      }\n+      Node params = newNode(Token.PARAM_LIST);\n+      for (Node param : node.getParams()) {\n+        params.addChildToBack(transform(param));\n+      }\n+      result.addChildToBack(params);\n+      result.addChildToBack(transform(node.getBody()));\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitIfStatement(IfStatement node) {\n+      Node condition = transform(node.getCondition());\n+      Node ifTrue = transform(node.getThenPart());\n+      Node ifFalse = transform(node.getElsePart());\n+      return newNode(Token.IF, condition, ifTrue, ifFalse);\n+    }\n+\n+    @Override\n+    public Node visitInfixExpression(InfixExpression node) {\n+      Node left = transform(node.getLeft());\n+      Node right = transform(node.getRight());\n+      return newNode(node.getType(), left, right);\n+    }\n+\n+    @Override\n+    public Node visitKeywordLiteral(KeywordLiteral node) {\n+      return newNode(node.getType());\n+    }\n+\n+    @Override\n+    public Node visitName(Name node) {\n+      return newNode(Token.NAME, node.getIdentifier());\n     }\n \n+    @Override\n+    public Node visitNumberLiteral(NumberLiteral node) {\n+      return newNode(Token.NUMBER, node.getValue());\n+    }\n+\n+    @Override\n+    public Node visitObjectLiteral(ObjectLiteral node) {\n+      Node result = newNode(Token.OBJECTLIT);\n+      for (ObjectProperty prop : node.getElements()) {\n+        AstNode left = prop.getLeft();\n+        Node right = transform(prop.getRight());\n+        Node member = null;\n+        if (left instanceof StringLiteral) {\n+          member = newNode(Token.STRING, ((StringLiteral) left).getValue());\n+        } else if (left instanceof Name) {\n+          member = newNode(Token.STRING, left.getString());\n+        } else if (left instanceof NumberLiteral) {\n+          member = newNode(Token.NUMBER, left.getDouble());\n+        } else {\n+          throw new AssertionError(\"Unexpected object literal property type \" + left.getClass());\n+        }\n+        member.addChildToBack(right);\n+        result.addChildToBack(member);\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitRegExpLiteral(RegExpLiteral node) {\n+      return newNode(Token.REGEXP, node.getValue(), node.getFlags());\n+    }\n+\n+    @Override\n+    public Node visitReturnStatement(ReturnStatement node) {\n+      return newNode(Token.RETURN, transform(node.getReturnValue()));\n+    }\n+\n+    @Override\n+    public Node visitStringLiteral(StringLiteral node) {\n+      return newNode(Token.STRING, node.getValue());\n+    }\n+\n+    @Override\n+    public Node visitSwitchCase(SwitchCase node) {\n+      Node result;\n+      if (node.getExpression() != null) {\n+        result = newNode(Token.CASE, transform(node.getExpression()));\n+      } else {\n+        result = newNode(Token.DEFAULT);\n+      }\n+      for (AstNode stmt : node.getStatements()) {\n+        result.addChildToBack(transform(stmt));\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitSwitchStatement(SwitchStatement node) {\n+      Node result = newNode(Token.SWITCH, transform(node.getExpression()));\n+      for (SwitchCase switchCase : node.getCases()) {\n+        result.addChildToBack(transform(switchCase));\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitThrowStatement(ThrowStatement node) {\n+      return newNode(Token.THROW, transform(node.getExpression()));\n+    }\n+\n+    @Override\n+    public Node visitTryStatement(TryStatement node) {\n+      Node result = newNode(Token.TRY, transform(node.getTryBlock()));\n+      if (node.getCatchClause() != null) {\n+        Node catchNode = newNode(Token.CATCH);\n+        catchNode.addChildToBack(transform(node.getCatchCondition()));\n+        catchNode.addChildToBack(transform(node.getCatchBody()));\n+        result.addChildToBack(catchNode);\n+      }\n+      if (node.getFinallyBlock() != null) {\n+        result.addChildToBack(transform(node.getFinallyBlock()));\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitUnaryExpression(UnaryExpression node) {\n+      Node child = transform(node.getOperand());\n+      return newNode(node.getType(), child);\n+    }\n+\n+    @Override\n+    public Node visitVariableDeclaration(VariableDeclaration node) {\n+      Node result = newNode(Token.VAR);\n+      for (VariableInitializer var : node.getVariableInitializer()) {\n+        AstNode target = var.getTarget();\n+        Node initializer = transform(var.getInitializer());\n+        if (target instanceof Name) {\n+          Node name = newNode(Token.NAME, target.getIdentifier());\n+          name.addChildToBack(initializer);\n+          result.addChildToBack(name);\n+        } else if (target instanceof DestructuringForm) {\n+          result.addChildToBack(transformDestructuringForm((DestructuringForm) target, initializer));\n+        } else {\n+          throw new AssertionError(\"Unexpected variable declaration type \" + target.getClass());\n+        }\n+      }\n+      return result;\n+    }\n+\n+    @Override\n+    public Node visitWhileLoop(WhileLoop node) {\n+      return newNode(Token.WHILE, transform(node.getCondition()), transform(node.getBody()));\n+    }\n+\n+    @Override\n+    public Node visitWithStatement(WithStatement node) {\n+      return newNode(Token.WITH, transform(node.getExpression()), transform(node.getStatement()));\n+    }\n+\n+    private Node transform(AstNode node) {\n+      if (node == null) {\n+        return null;\n+      }\n+      return node.accept(this);\n+    }\n+\n+    private Node transformDestructuringForm(DestructuringForm target, Node initializer) {\n+      Node result = newNode(Token.DESTRUCTURING_VAR);\n+      for (AstNode element : target) {\n+        if (element instanceof Name) {\n+          Node name = newNode(Token.NAME, element.getIdentifier());\n+          if (initializer != null) {\n+            name.addChildToBack(initializer);\n+          }\n+          result.addChildToBack(name);\n+        } else if (element instanceof ArrayLiteral) {\n+          Node arr = newNode(Token.ARRAYLIT);\n+          for (AstNode arrElement : element) {\n+            arr.addChildToBack(transformDestructuringForm((DestructuringForm)arrElement, initializer));\n+          }\n+          result.addChildToBack(arr);\n+        } else if (element instanceof ObjectLiteral) {\n+          Node obj = newNode(Token.OBJECTLIT);\n+          for (ObjectProperty prop : ((ObjectLiteral) element).getElements()) {\n+            Node value = prop.getRight() != null ? transformDestructuringForm((DestructuringForm)prop.getLeft(), initializer) : null;\n+            Node member;\n+            if (prop.getLeft() instanceof StringLiteral) {\n+              member = newNode(Token.STRING, ((StringLiteral) prop.getLeft()).getValue());\n+            } else if (prop.getLeft() instanceof Name) {\n+              member = newNode(Token.STRING, prop.getLeft().getString());\n+            } else if (prop.getLeft() instanceof DestructuringForm) {\n+              member = transformDestructuringForm((DestructuringForm)prop.getLeft(), initializer);\n+            } else {\n+              throw new AssertionError(\"Unexpected object literal property type \" + prop.getLeft().getClass());\n+            }\n+            if (value != null) {\n+              member.addChildToBack(value);\n+            }\n+            obj.addChildToBack(member);\n+          }\n+          result.addChildToBack(obj);\n+        } else {\n+          throw new AssertionError(\"Unexpected node type for destructuring target \" + element.getClass());\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}