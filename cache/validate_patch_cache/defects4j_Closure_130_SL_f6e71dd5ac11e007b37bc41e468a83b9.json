{
    "patch": "private void inlineAliases(GlobalNamespace namespace) {\n  // Invariant: All the names in the worklist meet condition (a).\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n    Name name = workList.pop();\n\n    // Don't attempt to inline a getter or setter property as a variable.\n    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n      continue;\n    }\n\n    // When should we *not* inline an alias?  In general, if it's not safe.\n    // Safe means one of two things:\n    // (a) it's side-effect-free, or\n    // (b) it's provably executed only once.\n    //\n    // A name that fails to meet those conditions is \"unsafe\".\n    //\n    // The term \"unsafe\" is used in a different way below, so I'm using\n    // \"inappropriate\" here instead.\n    if (name.getDeclaration() != null &&\n        (name.isLocal() ||\n         (name.getGlobalSets() == 1 &&\n          name.getLocalSets() == 0 &&\n          name.getDeclaration().getJSDocInfo().isConstant()))) {\n      // Continue anyway.\n    } else if (name.aliasingGets > 0) {\n      // {@code name} meets condition (b).\n      if (name.getDeclaration() == null &&\n          name.getRefs().size() == name.aliasingGets) {\n        Ref declRef = null;\n        // Determine if all references can be resolved to a declaration.\n        boolean allRefsResolved = true;\n        for (Ref ref : name.getRefs()) {\n          if (ref.getDecl() == null) {\n            allRefsResolved = false;\n            break;\n          } else if (declRef == null) {\n            declRef = ref;\n          }\n        }\n\n        // Determine if all aliases are appropriate for inlining.\n        boolean allAliasesAppropriate = allRefsResolved;\n        if (allRefsResolved) {\n          for (Ref ref : name.getRefs()) {\n            Node n = NodeUtil.getEnclosingStatement(ref.getNode());\n            if (n == null ||\n                NodeUtil.isExecutedExactlyOnce(n)) {\n              // Appropriateness condition (a) or (b) respectively.\n            } else {\n              allAliasesAppropriate = false;\n              break;\n            }\n          }\n        }\n\n        if (allRefsResolved && allAliasesAppropriate) {\n          // Inline all aliases.\n          for (Ref ref : name.getRefs()) {\n            if (ref == declRef) {\n              continue;\n            }\n            Node parent = ref.getNode().getParent();\n            Preconditions.checkState(parent.isAssign() ||\n                parent.isName() ||\n                parent.isStringKey());\n            Node rhs = parent.isAssign()\n                ? parent.getLastChild() : ref.getNode().getFirstChild();\n            Node newNode = rhs.cloneTree();\n            ref.getNode().replaceWith(newNode);\n            compiler.reportCodeChange();\n          }\n          // If name has no more references, it's safe to remove it too,\n          // to avoid leaving cruft around, additionally check for empty\n          // object literals.\n          name.removeRefs(name.getRefs());\n          Node parent = name.getParent();\n          if (name.props != null && parent != null &&\n              name.props.isEmpty() &&\n              parent.isObjectLit()) {\n            Node gramps = parent.getParent();\n            if (gramps.isAssign()) {\n              Node greatgramps = gramps.getParent();\n              Preconditions.checkState(greatgramps.isExprResult());\n              greatgramps.detachFromParent();\n            } else {\n              Preconditions.checkState(gramps.isExprResult());\n              gramps.detachFromParent();\n            }\n          } else {\n            Preconditions.checkState(name.getRefs().isEmpty());\n            name.removeProp();\n          }\n        }\n      } else {\n        // {@code name} meets condition (c). Find all of its local aliases\n        // and try to inline them.\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        for (Ref ref : refs) {\n          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n            // {@code name} meets condition (d).\n            if (inlineAliasIfPossible(ref, namespace)) {\n              name.removeRef(ref);\n            }\n          }\n        }\n      }\n    }\n\n    // Check if {@code name} has any aliases left after the\n    // local-alias-inlining above.\n    if ((name.type == Name.Type.OBJECTLIT ||\n         name.type == Name.Type.FUNCTION) &&\n        name.aliasingGets == 0 && name.props != null) {\n      // All of {@code name}'s children meet condition (a), so they can be\n      // added to the worklist.\n      workList.addAll(name.props);\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..459203e0 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,127 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+private void inlineAliases(GlobalNamespace namespace) {\n+  // Invariant: All the names in the worklist meet condition (a).\n+  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n+  while (!workList.isEmpty()) {\n+    Name name = workList.pop();\n+\n+    // Don't attempt to inline a getter or setter property as a variable.\n+    if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n+      continue;\n+    }\n+\n+    // When should we *not* inline an alias?  In general, if it's not safe.\n+    // Safe means one of two things:\n+    // (a) it's side-effect-free, or\n+    // (b) it's provably executed only once.\n+    //\n+    // A name that fails to meet those conditions is \"unsafe\".\n+    //\n+    // The term \"unsafe\" is used in a different way below, so I'm using\n+    // \"inappropriate\" here instead.\n+    if (name.getDeclaration() != null &&\n+        (name.isLocal() ||\n+         (name.getGlobalSets() == 1 &&\n+          name.getLocalSets() == 0 &&\n+          name.getDeclaration().getJSDocInfo().isConstant()))) {\n+      // Continue anyway.\n+    } else if (name.aliasingGets > 0) {\n+      // {@code name} meets condition (b).\n+      if (name.getDeclaration() == null &&\n+          name.getRefs().size() == name.aliasingGets) {\n+        Ref declRef = null;\n+        // Determine if all references can be resolved to a declaration.\n+        boolean allRefsResolved = true;\n+        for (Ref ref : name.getRefs()) {\n+          if (ref.getDecl() == null) {\n+            allRefsResolved = false;\n+            break;\n+          } else if (declRef == null) {\n+            declRef = ref;\n+          }\n+        }\n+\n+        // Determine if all aliases are appropriate for inlining.\n+        boolean allAliasesAppropriate = allRefsResolved;\n+        if (allRefsResolved) {\n+          for (Ref ref : name.getRefs()) {\n+            Node n = NodeUtil.getEnclosingStatement(ref.getNode());\n+            if (n == null ||\n+                NodeUtil.isExecutedExactlyOnce(n)) {\n+              // Appropriateness condition (a) or (b) respectively.\n+            } else {\n+              allAliasesAppropriate = false;\n+              break;\n+            }\n+          }\n+        }\n+\n+        if (allRefsResolved && allAliasesAppropriate) {\n+          // Inline all aliases.\n+          for (Ref ref : name.getRefs()) {\n+            if (ref == declRef) {\n+              continue;\n+            }\n+            Node parent = ref.getNode().getParent();\n+            Preconditions.checkState(parent.isAssign() ||\n+                parent.isName() ||\n+                parent.isStringKey());\n+            Node rhs = parent.isAssign()\n+                ? parent.getLastChild() : ref.getNode().getFirstChild();\n+            Node newNode = rhs.cloneTree();\n+            ref.getNode().replaceWith(newNode);\n+            compiler.reportCodeChange();\n+          }\n+          // If name has no more references, it's safe to remove it too,\n+          // to avoid leaving cruft around, additionally check for empty\n+          // object literals.\n+          name.removeRefs(name.getRefs());\n+          Node parent = name.getParent();\n+          if (name.props != null && parent != null &&\n+              name.props.isEmpty() &&\n+              parent.isObjectLit()) {\n+            Node gramps = parent.getParent();\n+            if (gramps.isAssign()) {\n+              Node greatgramps = gramps.getParent();\n+              Preconditions.checkState(greatgramps.isExprResult());\n+              greatgramps.detachFromParent();\n+            } else {\n+              Preconditions.checkState(gramps.isExprResult());\n+              gramps.detachFromParent();\n+            }\n+          } else {\n+            Preconditions.checkState(name.getRefs().isEmpty());\n+            name.removeProp();\n+          }\n+        }\n+      } else {\n+        // {@code name} meets condition (c). Find all of its local aliases\n+        // and try to inline them.\n+        List<Ref> refs = Lists.newArrayList(name.getRefs());\n+        for (Ref ref : refs) {\n+          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n+            // {@code name} meets condition (d).\n+            if (inlineAliasIfPossible(ref, namespace)) {\n+              name.removeRef(ref);\n+            }\n+          }\n+        }\n+      }\n+    }\n+\n+    // Check if {@code name} has any aliases left after the\n+    // local-alias-inlining above.\n+    if ((name.type == Name.Type.OBJECTLIT ||\n+         name.type == Name.Type.FUNCTION) &&\n+        name.aliasingGets == 0 && name.props != null) {\n+      // All of {@code name}'s children meet condition (a), so they can be\n+      // added to the worklist.\n+      workList.addAll(name.props);\n+    }\n+  }\n+}\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}