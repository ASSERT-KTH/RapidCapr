{
    "patch": "import java.util.HashSet;\nimport java.util.Set;\nimport org.mozilla.javascript.ErrorReporter;\nimport org.mozilla.javascript.Node;\nimport org.mozilla.javascript.Token;\nimport org.mozilla.javascript.ast.*;\n\npublic class IRFactory {\n    private static final Set<String> ALLOWED_DIRECTIVES = new HashSet<>();\n\n    static {\n        ALLOWED_DIRECTIVES.add(\"use strict\");\n    }\n\n    private final ErrorReporter errorReporter;\n    private final String sourceName;\n\n    IRFactory(ErrorReporter errorReporter, String sourceName) {\n        this.errorReporter = errorReporter;\n        this.sourceName = sourceName;\n    }\n\n    private Node newNode(int type) {\n        return new Node(type);\n    }\n\n    private Node newNode(int type, Node child) {\n        Node node = new Node(type);\n        node.addChildToBack(child);\n        return node;\n    }\n\n    private Node newNode(int type, Node left, Node right) {\n        Node node = new Node(type);\n        node.addChildToBack(left);\n        node.addChildToBack(right);\n        return node;\n    }\n\n    private Node newNode(int type, Node child1, Node child2, Node child3) {\n        Node node = new Node(type);\n        node.addChildToBack(child1);\n        node.addChildToBack(child2);\n        node.addChildToBack(child3);\n        return node;\n    }\n\n    private Node transform(AstNode n) {\n        return n == null ? null : n.accept(this);\n    }\n\n    private Node transformBlock(AstNode n) {\n        return n == null ? null : new IRFactory(errorReporter, sourceName).processBlock((Block) n);\n    }\n\n    private int transformTokenType(int type) {\n        switch(type){\n            case Token.FUNCTION:\n                return Token.PROP_GET;\n            case Token.LE:\n                return Token.IN;\n            case Token.GE:\n                return Token.INSTANCEOF;\n            case Token.STRING:\n            case Token.NUMBER:\n            case Token.NAME:\n            case Token.THIS:\n            case Token.NULL:\n            case Token.TRUE:\n            case Token.FALSE:\n            case Token.REGEXP:\n            case Token.GET:\n                return type;\n            default:\n                throw new UnsupportedOperationException(\"Unsupported token: \" + Token.name(type));\n        }\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) return false;\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n                n.getFirstChild().isString() &&\n                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    Node processBlock(Block blockNode) {\n        Node block = newNode(Token.BLOCK);\n        for (Node child = blockNode.getFirstChild(); child != null; child = child.getNext()) {\n            if (isDirective(child)) {\n                block.addChildToBack(processDirective(child));\n            } else {\n                Node newChild = child.accept(this);\n                if (newChild != null) {\n                    block.addChildToBack(newChild);\n                }\n            }\n        }\n        return block;\n    }\n\n    private Node processDirective(Node n) {\n        Node expr = n.getFirstChild();\n        return newNode(Token.EXPR_RESULT, transform(expr));\n    }\n\n    private boolean isIteration(AstNode node) {\n        int type = node.getType();\n        return type == Token.FOR || type == Token.DO || type == Token.WHILE;\n    }\n\n    private class TransformDispatcher implements NodeVisitor<Node>, TypeSafeDispatcher<Node> {\n        @Override\n        public Node visit(AstNode node) {\n            throw new UnsupportedOperationException(\"Unsupported node type: \" + node.getClass().getSimpleName());\n        }\n\n        @Override\n        public Node accept(AstNode node) {\n            return node == null ? null : node.accept(this);\n        }\n\n        @Override\n        public Node processArrayComprehension(ArrayComprehension node) {\n            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n        }\n\n        @Override\n        public Node processArrayComprehensionLoop(ArrayComprehensionLoop node) {\n            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n        }\n\n        @Override\n        public Node processAssignment(Assignment node) {\n            Node left = transform(node.getLeft()), right = transform(node.getRight());\n            if (left == null) {\n                return right;\n            } else if (node.getType() != Token.ASSIGN) {\n                // Compound assignments like += require an extra \"=\" node\n                left.addChildToBack(newNode(Token.ASSIGN, left, right));\n                return newNode(Token.COMMA, left, right);\n            } else {\n                return newNode(Token.ASSIGN, left, right);\n            }\n        }\n\n        @Override\n        public Node processAstRoot(AstRoot node) {\n            return processBlock(node);\n        }\n\n        @Override\n        public Node processBlock(Block blockNode) {\n            return IRFactory.this.processBlock(blockNode);\n        }\n\n        @Override\n        public Node processBreakStatement(BreakStatement statementNode) {\n            Node node = newNode(Token.BREAK);\n            if (statementNode.getBreakLabel() != null) {\n                Node labelName = transform(statementNode.getBreakLabel());\n                // Change the NAME to LABEL_NAME\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        public Node processCaseClause(CaseClause clauseNode) {\n            return newNode(\n                    Token.CASE,\n                    clauseNode.getExpression() == null ? null : transform(clauseNode.getExpression()),\n                    processBlock(clauseNode)\n            );\n        }\n\n        @Override\n        public Node processCatchClause(CatchClause clauseNode) {\n            AstNode catchVar = clauseNode.getVarName();\n            Node node = newNode(Token.CATCH, transform(catchVar));\n            if (clauseNode.getCatchCondition() != null) {\n                errorReporter.error(\n                        \"Catch clauses are not supported\",\n                        sourceName,\n                        clauseNode.getCatchCondition().getLineno(), \"\", 0\n                );\n            }\n            node.addChildToBack(transformBlock(clauseNode.getBody()));\n            return node;\n        }\n\n        @Override\n        public Node processComment(Comment commentNode) {\n            return null;\n        }\n\n        @Override\n        public Node processConditionalExpression(ConditionalExpression exprNode) {\n            return newNode(\n                    Token.HOOK,\n                    transform(exprNode.getTestExpression()),\n                    transform(exprNode.getTrueExpression()),\n                    transform(exprNode.getFalseExpression())\n            );\n        }\n\n        @Override\n        public Node processContinueStatement(ContinueStatement statementNode) {\n            Node node = newNode(Token.CONTINUE);\n            if (statementNode.getLabel() != null) {\n                Node labelName = transform(statementNode.getLabel());\n                // Change the NAME to LABEL_NAME\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        public Node processDefaultClause(DefaultClause clauseNode) {\n            return newNode(Token.DEFAULT, processBlock(clauseNode));\n        }\n\n        @Override\n        public Node processDoLoop(DoLoop loopNode) {\n            return newNode(\n                    Token.DO,\n                    transformBlock(loopNode.getBody()),\n                    transform(loopNode.getCondition())\n            );\n        }\n\n        @Override\n        public Node processElementGet(ElementGet getNode) {\n            return newNode(\n                    Token.GETELEM,\n                    transform(getNode.getTarget()),\n                    transform(getNode.getElement())\n            );\n        }\n\n        @Override\n        public Node processEmptyExpression(EmptyExpression exprNode) {\n            return newNode(Token.EMPTY);\n        }\n\n        @Override\n        public Node processExpressionStatement(ExpressionStatement statementNode) {\n            Node node = newNode(transformTokenType(statementNode.getType()));\n            node.addChildToBack(transform(statementNode.getExpression()));\n            return node;\n        }\n\n        @Override\n        public Node processForInLoop(ForInLoop loopNode) {\n            Node varNode = transform(loopNode.getIterator());\n            if (varNode == null) {\n                varNode = newNode(Token.VAR);\n            }\n            return newNode(\n                    Token.FOR,\n                    varNode,\n                    transform(loopNode.getIteratedObject()),\n                    transformBlock(loopNode.getBody())\n            );\n        }\n\n        @Override\n        public Node processForLoop(ForLoop loopNode) {\n            Node init = transform(loopNode.getInitializer());\n            if (isIteration(loopNode.getInitializer())) {\n                // wrap the init in a block to separate the iteration from\n                // the new loop variable's scope\n                init = newNode(Token.BLOCK, init);\n            }\n            return newNode(\n                    Token.FOR,\n                    init,\n                    transform(loopNode.getCondition()),\n                    transform(loopNode.getIncrement()),\n                    transformBlock(loopNode.getBody())\n            );\n        }\n\n        @Override\n        public Node processFunctionCall(FunctionCall callNode) {\n            return newNode(\n                    Token.CALL,\n                    transform(callNode.getTarget()),\n                    callNode.getArguments() == null ? null : transform(callNode.getArguments())\n            );\n        }\n\n        @Override\n        public Node processFunctionNode(FunctionNode functionNode) {\n            Node fnNode = newNode(Token.FUNCTION, new Node(Token.NAME, functionNode.getName()));\n            fnNode.putProp(Node.FUNCTION_PROP, functionNode);\n            fnNode.addChildToBack(transform(functionNode.getParams()));\n            fnNode.addChildToBack(transformBlock(functionNode.getBody()));\n            return fnNode;\n        }\n\n        @Override\n        public Node processGeneratorExpression(GeneratorExpression node) {\n            throw new UnsupportedOperationException(\"Generator expressions not supported\");\n        }\n\n        @Override\n        public Node processIfStatement(IfStatement statementNode) {\n            Node ifNode;\n            if (statementNode.getElsePart() == null) {\n                ifNode = newNode(Token.IF);\n                ifNode.addChildToBack(transform(statementNode.getCondition()));\n                ifNode.addChildToBack(transformBlock(statementNode.getThenPart()));\n            } else {\n                ifNode = newNode(\n                        Token.HOOK,\n                        transform(statementNode.getCondition()),\n                        transformBlock(statementNode.getThenPart()),\n                        transformBlock(statementNode.getElsePart())\n                );\n            }\n            return ifNode;\n        }\n\n        @Override\n        public Node processLabeledStatement(LabeledStatement statementNode) {\n            Node node = transform(statementNode.getStatement());\n            if (node == null) {\n                return null;\n            }\n            Node labelName = transform(statementNode.getLabel());\n            labelName.setType(Token.LABEL_NAME);\n            return newNode(Token.LABEL, labelName, node);\n        }\n\n        @Override\n        public Node processLetNode(LetNode node) {\n            throw new UnsupportedOperationException(\"Let blocks not supported\");\n        }\n\n        @Override\n        public Node processName(Name nameNode) {\n            return new Node(Token.NAME, nameNode.getIdentifier());\n        }\n\n        @Override\n        public Node processNewExpression(NewExpression newExpressionNode) {\n            return newNode(Token.NEW, transform(newExpressionNode.getTarget()), transform(newExpressionNode.getArguments()));\n        }\n\n        @Override\n        public Node processNumberLiteral(NumberLiteral numberNode) {\n            return new Node(Token.NUMBER, numberNode.getNumber());\n        }\n\n        @Override\n        public Node processObjectLiteral(ObjectLiteral objectNode) {\n            Node objNode = newNode(Token.OBJECTLIT);\n            for(ObjectProperty propNode : objectNode.getElements()){\n                objNode.addChildToBack(propNode.accept(this));\n            }\n            return objNode;\n        }\n\n        @Override\n        public Node processObjectProperty(ObjectProperty propNode) {\n            Node key;\n            if(propNode.getLeft() instanceof Name) {\n                key = new Node(Token.STRING, ((Name) propNode.getLeft()).getIdentifier());\n            } else {\n                key = transform(propNode.getLeft());\n            }\n            return newNode(Token.COLON, key, transform(propNode.getRight()));\n        }\n\n        @Override\n        public Node processParenthesizedExpression(ParenthesizedExpression node) {\n            return newNode(Token.PARENTHESIZED, transform(node.getExpression()));\n        }\n\n        @Override\n        public Node processRegExpLiteral(RegExpLiteral regexpNode) {\n            return new Node(Token.REGEXP, regexpNode.getValue());\n        }\n\n        @Override\n        public Node processReturnStatement(ReturnStatement statementNode) {\n            Node node = newNode(Token.RETURN);\n            if (statementNode.getReturnValue() != null) {\n                node.addChildToBack(transform(statementNode.getReturnValue()));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processStringLiteral(StringLiteral stringNode) {\n            return new Node(Token.STRING, stringNode.getValue());\n        }\n\n        @Override\n        public Node processSwitchCase(SwitchCase clauseNode) {\n            if(clauseNode.getExpression() == null){\n                return newNode(Token.DEFAULT, processBlock(clauseNode));\n            } else {\n                return newNode(Token.CASE, transform(clauseNode.getExpression()), processBlock(clauseNode));\n            }\n        }\n\n        @Override\n        public Node processSwitchStatement(SwitchStatement statementNode) {\n            Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n            for (SwitchCase switchCase : statementNode.getCases()) {\n                node.addChildToBack(transform(switchCase));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processThrowStatement(ThrowStatement statementNode) {\n            return newNode(Token.THROW, transform(statementNode.getExpression()));\n        }\n\n        @Override\n        public Node processTryStatement(TryStatement statementNode) {\n            Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n            if (statementNode.getCatchClauses() != null) {\n                for (CatchClause clauseNode : statementNode.getCatchClauses()) {\n                    node.addChildToBack(transform(clauseNode));\n                }\n            }\n            if (statementNode.getFinallyBlock() != null) {\n                node.addChildToBack(newNode(Token.BLOCK, transformBlock(statementNode.getFinallyBlock())));\n            }\n            return node;\n        }\n\n        @Override\n        public Node processUnaryExpression(UnaryExpression unaryNode) {\n            return newNode(unaryNode.getType(), transform(unaryNode.getOperand()));\n        }\n\n        @Override\n        public Node processVariableDeclaration(VariableDeclaration declNode) {\n            Node decl = newNode(Token.VAR);\n            for (VariableInitializer initNode : declNode.getVariables()) {\n                Node varNode = transform(initNode.getTarget());\n                Node init = null;\n                if (initNode.getInitializer() != null) {\n                    init = transform(initNode.getInitializer());\n                }\n                if (varNode != null) {\n                    if (init != null) {\n                        decl.addChildToBack(newNode(Token.ASSIGN, varNode, init));\n                    } else {\n                        decl.addChildToBack(varNode);\n                    }\n                }\n            }\n            return decl;\n        }\n\n        @Override\n        public Node processVariableInitializer(VariableInitializer node) {\n            throw new UnsupportedOperationException(\"Variable initializers not supported\");\n        }\n\n        @Override\n        public Node processWhileLoop(WhileLoop loopNode) {\n            return newNode(\n                    Token.WHILE,\n                    transform(loopNode.getCondition()),\n                    transformBlock(loopNode.getBody())\n            );\n        }\n",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..27243027 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,485 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+import org.mozilla.javascript.ast.*;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+public class IRFactory {\n+    private static final Set<String> ALLOWED_DIRECTIVES = new HashSet<>();\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    static {\n+        ALLOWED_DIRECTIVES.add(\"use strict\");\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private final ErrorReporter errorReporter;\n+    private final String sourceName;\n+\n+    IRFactory(ErrorReporter errorReporter, String sourceName) {\n+        this.errorReporter = errorReporter;\n+        this.sourceName = sourceName;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    private Node newNode(int type) {\n+        return new Node(type);\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    private Node newNode(int type, Node child) {\n+        Node node = new Node(type);\n+        node.addChildToBack(child);\n+        return node;\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private Node newNode(int type, Node left, Node right) {\n+        Node node = new Node(type);\n+        node.addChildToBack(left);\n+        node.addChildToBack(right);\n+        return node;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    private Node newNode(int type, Node child1, Node child2, Node child3) {\n+        Node node = new Node(type);\n+        node.addChildToBack(child1);\n+        node.addChildToBack(child2);\n+        node.addChildToBack(child3);\n+        return node;\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    private Node transform(AstNode n) {\n+        return n == null ? null : n.accept(this);\n+    }\n+\n+    private Node transformBlock(AstNode n) {\n+        return n == null ? null : new IRFactory(errorReporter, sourceName).processBlock((Block) n);\n+    }\n+\n+    private int transformTokenType(int type) {\n+        switch(type){\n+            case Token.FUNCTION:\n+                return Token.PROP_GET;\n+            case Token.LE:\n+                return Token.IN;\n+            case Token.GE:\n+                return Token.INSTANCEOF;\n+            case Token.STRING:\n+            case Token.NUMBER:\n+            case Token.NAME:\n+            case Token.THIS:\n+            case Token.NULL:\n+            case Token.TRUE:\n+            case Token.FALSE:\n+            case Token.REGEXP:\n+            case Token.GET:\n+                return type;\n+            default:\n+                throw new UnsupportedOperationException(\"Unsupported token: \" + Token.name(type));\n+        }\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    private boolean isDirective(Node n) {\n+        if (n == null) return false;\n+\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+                n.getFirstChild().isString() &&\n+                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    Node processBlock(Block blockNode) {\n+        Node block = newNode(Token.BLOCK);\n+        for (Node child = blockNode.getFirstChild(); child != null; child = child.getNext()) {\n+            if (isDirective(child)) {\n+                block.addChildToBack(processDirective(child));\n+            } else {\n+                Node newChild = child.accept(this);\n+                if (newChild != null) {\n+                    block.addChildToBack(newChild);\n+                }\n+            }\n+        }\n+        return block;\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    private Node processDirective(Node n) {\n+        Node expr = n.getFirstChild();\n+        return newNode(Token.EXPR_RESULT, transform(expr));\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    private boolean isIteration(AstNode node) {\n+        int type = node.getType();\n+        return type == Token.FOR || type == Token.DO || type == Token.WHILE;\n     }\n \n+    private class TransformDispatcher implements NodeVisitor<Node>, TypeSafeDispatcher<Node> {\n+        @Override\n+        public Node visit(AstNode node) {\n+            throw new UnsupportedOperationException(\"Unsupported node type: \" + node.getClass().getSimpleName());\n+        }\n+\n+        @Override\n+        public Node accept(AstNode node) {\n+            return node == null ? null : node.accept(this);\n+        }\n+\n+        @Override\n+        public Node processArrayComprehension(ArrayComprehension node) {\n+            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n+        }\n+\n+        @Override\n+        public Node processArrayComprehensionLoop(ArrayComprehensionLoop node) {\n+            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n+        }\n+\n+        @Override\n+        public Node processAssignment(Assignment node) {\n+            Node left = transform(node.getLeft()), right = transform(node.getRight());\n+            if (left == null) {\n+                return right;\n+            } else if (node.getType() != Token.ASSIGN) {\n+                // Compound assignments like += require an extra \"=\" node\n+                left.addChildToBack(newNode(Token.ASSIGN, left, right));\n+                return newNode(Token.COMMA, left, right);\n+            } else {\n+                return newNode(Token.ASSIGN, left, right);\n+            }\n+        }\n+\n+        @Override\n+        public Node processAstRoot(AstRoot node) {\n+            return processBlock(node);\n+        }\n+\n+        @Override\n+        public Node processBlock(Block blockNode) {\n+            return IRFactory.this.processBlock(blockNode);\n+        }\n+\n+        @Override\n+        public Node processBreakStatement(BreakStatement statementNode) {\n+            Node node = newNode(Token.BREAK);\n+            if (statementNode.getBreakLabel() != null) {\n+                Node labelName = transform(statementNode.getBreakLabel());\n+                // Change the NAME to LABEL_NAME\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processCaseClause(CaseClause clauseNode) {\n+            return newNode(\n+                    Token.CASE,\n+                    clauseNode.getExpression() == null ? null : transform(clauseNode.getExpression()),\n+                    processBlock(clauseNode)\n+            );\n+        }\n+\n+        @Override\n+        public Node processCatchClause(CatchClause clauseNode) {\n+            AstNode catchVar = clauseNode.getVarName();\n+            Node node = newNode(Token.CATCH, transform(catchVar));\n+            if (clauseNode.getCatchCondition() != null) {\n+                errorReporter.error(\n+                        \"Catch clauses are not supported\",\n+                        sourceName,\n+                        clauseNode.getCatchCondition().getLineno(), \"\", 0\n+                );\n+            }\n+            node.addChildToBack(transformBlock(clauseNode.getBody()));\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processComment(Comment commentNode) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Node processConditionalExpression(ConditionalExpression exprNode) {\n+            return newNode(\n+                    Token.HOOK,\n+                    transform(exprNode.getTestExpression()),\n+                    transform(exprNode.getTrueExpression()),\n+                    transform(exprNode.getFalseExpression())\n+            );\n+        }\n+\n+        @Override\n+        public Node processContinueStatement(ContinueStatement statementNode) {\n+            Node node = newNode(Token.CONTINUE);\n+            if (statementNode.getLabel() != null) {\n+                Node labelName = transform(statementNode.getLabel());\n+                // Change the NAME to LABEL_NAME\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processDefaultClause(DefaultClause clauseNode) {\n+            return newNode(Token.DEFAULT, processBlock(clauseNode));\n+        }\n+\n+        @Override\n+        public Node processDoLoop(DoLoop loopNode) {\n+            return newNode(\n+                    Token.DO,\n+                    transformBlock(loopNode.getBody()),\n+                    transform(loopNode.getCondition())\n+            );\n+        }\n+\n+        @Override\n+        public Node processElementGet(ElementGet getNode) {\n+            return newNode(\n+                    Token.GETELEM,\n+                    transform(getNode.getTarget()),\n+                    transform(getNode.getElement())\n+            );\n+        }\n+\n+        @Override\n+        public Node processEmptyExpression(EmptyExpression exprNode) {\n+            return newNode(Token.EMPTY);\n+        }\n+\n+        @Override\n+        public Node processExpressionStatement(ExpressionStatement statementNode) {\n+            Node node = newNode(transformTokenType(statementNode.getType()));\n+            node.addChildToBack(transform(statementNode.getExpression()));\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processForInLoop(ForInLoop loopNode) {\n+            Node varNode = transform(loopNode.getIterator());\n+            if (varNode == null) {\n+                varNode = newNode(Token.VAR);\n+            }\n+            return newNode(\n+                    Token.FOR,\n+                    varNode,\n+                    transform(loopNode.getIteratedObject()),\n+                    transformBlock(loopNode.getBody())\n+            );\n+        }\n+\n+        @Override\n+        public Node processForLoop(ForLoop loopNode) {\n+            Node init = transform(loopNode.getInitializer());\n+            if (isIteration(loopNode.getInitializer())) {\n+                // wrap the init in a block to separate the iteration from\n+                // the new loop variable's scope\n+                init = newNode(Token.BLOCK, init);\n+            }\n+            return newNode(\n+                    Token.FOR,\n+                    init,\n+                    transform(loopNode.getCondition()),\n+                    transform(loopNode.getIncrement()),\n+                    transformBlock(loopNode.getBody())\n+            );\n+        }\n+\n+        @Override\n+        public Node processFunctionCall(FunctionCall callNode) {\n+            return newNode(\n+                    Token.CALL,\n+                    transform(callNode.getTarget()),\n+                    callNode.getArguments() == null ? null : transform(callNode.getArguments())\n+            );\n+        }\n+\n+        @Override\n+        public Node processFunctionNode(FunctionNode functionNode) {\n+            Node fnNode = newNode(Token.FUNCTION, new Node(Token.NAME, functionNode.getName()));\n+            fnNode.putProp(Node.FUNCTION_PROP, functionNode);\n+            fnNode.addChildToBack(transform(functionNode.getParams()));\n+            fnNode.addChildToBack(transformBlock(functionNode.getBody()));\n+            return fnNode;\n+        }\n+\n+        @Override\n+        public Node processGeneratorExpression(GeneratorExpression node) {\n+            throw new UnsupportedOperationException(\"Generator expressions not supported\");\n+        }\n+\n+        @Override\n+        public Node processIfStatement(IfStatement statementNode) {\n+            Node ifNode;\n+            if (statementNode.getElsePart() == null) {\n+                ifNode = newNode(Token.IF);\n+                ifNode.addChildToBack(transform(statementNode.getCondition()));\n+                ifNode.addChildToBack(transformBlock(statementNode.getThenPart()));\n+            } else {\n+                ifNode = newNode(\n+                        Token.HOOK,\n+                        transform(statementNode.getCondition()),\n+                        transformBlock(statementNode.getThenPart()),\n+                        transformBlock(statementNode.getElsePart())\n+                );\n+            }\n+            return ifNode;\n+        }\n+\n+        @Override\n+        public Node processLabeledStatement(LabeledStatement statementNode) {\n+            Node node = transform(statementNode.getStatement());\n+            if (node == null) {\n+                return null;\n+            }\n+            Node labelName = transform(statementNode.getLabel());\n+            labelName.setType(Token.LABEL_NAME);\n+            return newNode(Token.LABEL, labelName, node);\n+        }\n+\n+        @Override\n+        public Node processLetNode(LetNode node) {\n+            throw new UnsupportedOperationException(\"Let blocks not supported\");\n+        }\n+\n+        @Override\n+        public Node processName(Name nameNode) {\n+            return new Node(Token.NAME, nameNode.getIdentifier());\n+        }\n+\n+        @Override\n+        public Node processNewExpression(NewExpression newExpressionNode) {\n+            return newNode(Token.NEW, transform(newExpressionNode.getTarget()), transform(newExpressionNode.getArguments()));\n+        }\n+\n+        @Override\n+        public Node processNumberLiteral(NumberLiteral numberNode) {\n+            return new Node(Token.NUMBER, numberNode.getNumber());\n+        }\n+\n+        @Override\n+        public Node processObjectLiteral(ObjectLiteral objectNode) {\n+            Node objNode = newNode(Token.OBJECTLIT);\n+            for(ObjectProperty propNode : objectNode.getElements()){\n+                objNode.addChildToBack(propNode.accept(this));\n+            }\n+            return objNode;\n+        }\n+\n+        @Override\n+        public Node processObjectProperty(ObjectProperty propNode) {\n+            Node key;\n+            if(propNode.getLeft() instanceof Name) {\n+                key = new Node(Token.STRING, ((Name) propNode.getLeft()).getIdentifier());\n+            } else {\n+                key = transform(propNode.getLeft());\n+            }\n+            return newNode(Token.COLON, key, transform(propNode.getRight()));\n+        }\n+\n+        @Override\n+        public Node processParenthesizedExpression(ParenthesizedExpression node) {\n+            return newNode(Token.PARENTHESIZED, transform(node.getExpression()));\n+        }\n+\n+        @Override\n+        public Node processRegExpLiteral(RegExpLiteral regexpNode) {\n+            return new Node(Token.REGEXP, regexpNode.getValue());\n+        }\n+\n+        @Override\n+        public Node processReturnStatement(ReturnStatement statementNode) {\n+            Node node = newNode(Token.RETURN);\n+            if (statementNode.getReturnValue() != null) {\n+                node.addChildToBack(transform(statementNode.getReturnValue()));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processStringLiteral(StringLiteral stringNode) {\n+            return new Node(Token.STRING, stringNode.getValue());\n+        }\n+\n+        @Override\n+        public Node processSwitchCase(SwitchCase clauseNode) {\n+            if(clauseNode.getExpression() == null){\n+                return newNode(Token.DEFAULT, processBlock(clauseNode));\n+            } else {\n+                return newNode(Token.CASE, transform(clauseNode.getExpression()), processBlock(clauseNode));\n+            }\n+        }\n+\n+        @Override\n+        public Node processSwitchStatement(SwitchStatement statementNode) {\n+            Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+            for (SwitchCase switchCase : statementNode.getCases()) {\n+                node.addChildToBack(transform(switchCase));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processThrowStatement(ThrowStatement statementNode) {\n+            return newNode(Token.THROW, transform(statementNode.getExpression()));\n+        }\n+\n+        @Override\n+        public Node processTryStatement(TryStatement statementNode) {\n+            Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+            if (statementNode.getCatchClauses() != null) {\n+                for (CatchClause clauseNode : statementNode.getCatchClauses()) {\n+                    node.addChildToBack(transform(clauseNode));\n+                }\n+            }\n+            if (statementNode.getFinallyBlock() != null) {\n+                node.addChildToBack(newNode(Token.BLOCK, transformBlock(statementNode.getFinallyBlock())));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node processUnaryExpression(UnaryExpression unaryNode) {\n+            return newNode(unaryNode.getType(), transform(unaryNode.getOperand()));\n+        }\n+\n+        @Override\n+        public Node processVariableDeclaration(VariableDeclaration declNode) {\n+            Node decl = newNode(Token.VAR);\n+            for (VariableInitializer initNode : declNode.getVariables()) {\n+                Node varNode = transform(initNode.getTarget());\n+                Node init = null;\n+                if (initNode.getInitializer() != null) {\n+                    init = transform(initNode.getInitializer());\n+                }\n+                if (varNode != null) {\n+                    if (init != null) {\n+                        decl.addChildToBack(newNode(Token.ASSIGN, varNode, init));\n+                    } else {\n+                        decl.addChildToBack(varNode);\n+                    }\n+                }\n+            }\n+            return decl;\n+        }\n+\n+        @Override\n+        public Node processVariableInitializer(VariableInitializer node) {\n+            throw new UnsupportedOperationException(\"Variable initializers not supported\");\n+        }\n+\n+        @Override\n+        public Node processWhileLoop(WhileLoop loopNode) {\n+            return newNode(\n+                    Token.WHILE,\n+                    transform(loopNode.getCondition()),\n+                    transformBlock(loopNode.getBody())\n+            );\n+        }\n+\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}