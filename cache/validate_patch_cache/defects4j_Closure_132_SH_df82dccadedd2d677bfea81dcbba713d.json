{
    "patch": "  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n      ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..bdf0ff0b 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,25 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+  private Node tryMinimizeIf(Node n) {\n+\n+    Node parent = n.getParent();\n+\n+    Node cond = n.getFirstChild();\n+\n+    /* If the condition is a literal, we'll let other\n+     * optimizations try to remove useless code.\n+     */\n+    if (NodeUtil.isLiteralValue(cond, true)) {\n+      return n;\n+    }\n+\n+    Node thenBranch = cond.getNext();\n+    Node elseBranch = thenBranch.getNext();\n+\n+    if (elseBranch == null) {\n+      if (isFoldableExpressBlock(thenBranch)) {\n+      \n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}