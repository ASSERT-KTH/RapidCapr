{
    "patch": "@SuppressWarnings(\"unchecked\")\n@Override\npublic <T> T execute(MockitoInvocation invocation, MethodInfo methodInfo) {\n    ReturnValues values = getReturnValues(invocation, methodInfo);\n    if (values.hasThrowable()) {\n        Throwable throwable = values.returnValueFor(Throwable.class);\n        if (throwable instanceof RuntimeException) {\n            throw (RuntimeException) throwable;\n        }\n        throw new MockitoException(\"Checked exception is thrown from a Mockito mock : \" + throwable.getClass() + \".\\n\" +\n                \"This exception is not being thrown to the calling code.\\n\" +\n                \"It's an indication that you have a bug in your code if the calling code doesn't expect this exception type.\" +\n                \"For example, if you're mocking a method that doesn't throw IOException and return a mock IOException, calling code that doesn't expect an IOException will fail by unexpected Exception.\", throwable);\n    } else if (values.hasReturnValue()) {\n        return (T) values.returnValue();\n    } else if (Iterable.class.isAssignableFrom(methodInfo.returnType())) {\n        return (T) Collections.emptyList(); // return empty Iterable without throwing Exception\n    } else {\n        throw new AssertionError(\"Method with return type \" + methodInfo.returnType() + \" was called but no result was either returned or thrown.\");\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\nindex 06697e527..cddcbdc6b 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n@@ -84,7 +84,7 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n             //new instances are used instead of Collections.emptyList(), etc.\n             //to avoid UnsupportedOperationException if code under test modifies returned collection\n-        } else if (type == Collection.class) {\n+\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {\n             return new HashSet<Object>();",
    "result_reason": "error: unreachable statement",
    "test_result": "ERROR"
}