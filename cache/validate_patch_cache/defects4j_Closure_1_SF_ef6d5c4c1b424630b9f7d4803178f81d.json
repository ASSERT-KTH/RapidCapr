{
    "patch": "private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The param object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg = argList.getLastChild();\n      while (lastArg != null\n          && !referenced.contains(fnScope.getVar(lastArg.getString()))) {\n        argList.removeChild(lastArg);\n        compiler.reportCodeChange();\n        lastArg = argList.getLastChild();\n      }\n      if (lastArg == null) {\n        // The function declaration has no unreferenced parameters.\n        return;\n      }\n      Node fnBlock = function.getLastChild();\n      NodeUtil.visitPostOrder(fnBlock, new NodeUtil.Visitor() {\n        @Override\n        public void visit(Node node) {\n          if (!NodeUtil.isFunctionDeclaration(node.getParent())) {\n            removeUnusedFnArgFromCall(node.getLastChild(), lastArg);\n            removeUnusedFnArgFromnew(node.getLastChild(), lastArg);\n          }\n        }\n      });\n      fnScope.removeVar(fnScope.getVar(lastArg.getString()));\n      argList.removeChild(lastArg);\n      compiler.reportCodeChange();\n\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n  }\n  ```\nNotice that we now check if the last argument is both non-null and has no references in the function block before removing it. Also we make sure to remove the unused argument from any function calls or object creations that reference it",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..d71f86c9 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -366,22 +366,12 @@ class RemoveUnusedVars\n    *\n    * @param fnScope The scope inside the function\n    */\n-  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n-\n+private void removeUnreferencedFunctionArgs(Scope fnScope) {\n     Node function = fnScope.getRootNode();\n-\n     Preconditions.checkState(function.isFunction());\n+\n     if (NodeUtil.isGetOrSetKey(function.getParent())) {\n-      // The parameters object literal setters can not be removed.\n+      // The param object literal setters can not be removed.\n       return;\n     }\n \n@@ -390,20 +380,37 @@ class RemoveUnusedVars\n         && callSiteOptimizer.canModifyCallers(function);\n     if (!modifyCallers) {\n       // Strip unreferenced args off the end of the function declaration.\n-      Node lastArg;\n-      while ((lastArg = argList.getLastChild()) != null) {\n-        Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n-          argList.removeChild(lastArg);\n-          compiler.reportCodeChange();\n-        } else {\n-          break;\n-        }\n+      Node lastArg = argList.getLastChild();\n+      while (lastArg != null\n+          && !referenced.contains(fnScope.getVar(lastArg.getString()))) {\n+        argList.removeChild(lastArg);\n+        compiler.reportCodeChange();\n+        lastArg = argList.getLastChild();\n+      }\n+      if (lastArg == null) {\n+        // The function declaration has no unreferenced parameters.\n+        return;\n       }\n+      Node fnBlock = function.getLastChild();\n+      NodeUtil.visitPostOrder(fnBlock, new NodeUtil.Visitor() {\n+        @Override\n+        public void visit(Node node) {\n+          if (!NodeUtil.isFunctionDeclaration(node.getParent())) {\n+            removeUnusedFnArgFromCall(node.getLastChild(), lastArg);\n+            removeUnusedFnArgFromnew(node.getLastChild(), lastArg);\n+          }\n+        }\n+      });\n+      fnScope.removeVar(fnScope.getVar(lastArg.getString()));\n+      argList.removeChild(lastArg);\n+      compiler.reportCodeChange();\n+\n     } else {\n       callSiteOptimizer.optimize(fnScope, referenced);\n     }\n   }\n+  ```\n+Notice that we now check if the last argument is both non-null and has no references in the function block before removing it. Also we make sure to remove the unused argument from any function calls or object creations that reference it\n \n \n   /**",
    "result_reason": "error: illegal character: \\96",
    "test_result": "ERROR"
}