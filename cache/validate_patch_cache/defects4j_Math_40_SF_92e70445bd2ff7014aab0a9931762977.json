{
    "patch": "protected double doSolve() throws TooManyEvaluationsException, NoBracketingException {\n        // Prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // Evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (isEqual(y[1], 0.0, functionValueAccuracy)) {\n            // Return the initial guess if it is a root\n            return x[1];\n        }\n\n        // Evaluate the first endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (isEqual(y[0], 0.0, functionValueAccuracy)) {\n            // Return the first endpoint if it is a root\n            return x[0];\n        }\n\n        // Evaluate the second endpoint\n        y[2] = computeObjectiveValue(x[2]);\n        if (isEqual(y[2], 0.0, functionValueAccuracy)) {\n            // Return the second endpoint if it is a root\n            return x[2];\n        }\n\n        // Variables for the search loop\n        int nbPoints = 3;\n        int signChangeIndex;\n        double targetY = 0;\n        double nextX;\n        double nextY = Double.NaN;\n        int start;\n        int end = nbPoints;\n\n        // Handling variables for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n        double xA = Double.NaN;\n        double yA = Double.POSITIVE_INFINITY;\n        int agingA = 0;\n        double xB = Double.NaN;\n        double yB = Double.POSITIVE_INFINITY;\n        int agingB = 0;\n\n        while (true) {\n            // Check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                 getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.abs(yB) < functionValueAccuracy)) {\n                switch (allowed) {\n                    case ANY_SIDE:\n                        return (FastMath.abs(yA) < FastMath.abs(yB)) ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return (yA <= 0) ? xA : xB;\n                    case ABOVE_SIDE:\n                        return (yA < 0) ? xB : xA;\n                    default:\n                        throw new MathInternalError();\n                }\n            }\n\n            start = 0;\n            signChangeIndex = 1;\n            end = nbPoints;\n\n            // Target for the next evaluation point\n            if (agingA >= MAXIMAL_AGING) {\n                // We keep updating the high bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // We keep updating the low bracket, try to compensate this\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                // Bracketing is balanced, try to find the root itself\n                targetY = 0;\n            }\n\n            // Make a few attempts to guess a root\n            boolean bisectFlag = false;\n            nextX = Double.NaN;\n            do {\n                System.arraycopy(x, start, tmpX, start, end - start);\n                try {\n                    nextX = UnivariateSolverUtils.solve(UnivariateSolverUtils\n                                  .bracket(new UnivariateFunction() {\n                                      /** {@inheritDoc} */\n                                      public double value(double x) {\n                                          return computeObjectiveValue(x) - targetY;\n                                      }\n                                  }, x[start], x[end - 1], y[start], y[end - 1], initial: false, functionValueAccuracy: functionValueAccuracy, maxEvaluations: getMaxEvaluations(), result: null);\n                } catch (NoBracketingException e) {\n                    // No sign change\n                    continue;\n                }\n\n                // Check for convergence\n                if (Double.isNaN(nextX) || (FastMath.abs(nextX - xA) < functionValueAccuracy) || (FastMath.abs(xB - nextX) < functionValueAccuracy)) {\n                    double fx;\n                    if (Double.isNaN(nextX)) {\n                        bisectFlag = true;\n                    } else if (FastMath.abs(nextX - xA) < FastMath.abs(xB - nextX)) {\n                        fx = computeObjectiveValue(xA = nextX);\n                    } else {\n                        fx = computeObjectiveValue(xB = nextX);\n                    }\n                    if (isEqual(fx, 0.0, functionValueAccuracy)) {\n                        // We have found a root, return it\n                        return fx;\n                    }\n                    break;\n                }\n\n                // Evaluate the function at the guessed root\n                nextY = computeObjectiveValue(nextX);\n                if (isEqual(nextY, 0.0, functionValueAccuracy)) {\n                    // We have found a root, return it\n                    return nextX;\n                }\n\n                // Update the tightest bracketing interval and the endpoints\n                if ((nbPoints > 2) && (end - start != nbPoints)) {\n                    // We have been forced to ignore some points to keep bracketing,\n                    // they are probably too far from the root,\n                    // drop them from now on\n                    nbPoints = end - start;\n                    System.arraycopy(x, start, x, 0, nbPoints);\n                    System.arraycopy(y, start, y, 0, nbPoints);\n                    signChangeIndex -= start;\n                }\n\n                if (isEqual(nextY, yA, functionValueAccuracy)) {\n                    xA = nextX;\n                    yA = nextY;\n                    agingA++;\n                    break;\n                } else if (nextY * yA < 0) {\n                    xB = nextX;\n                    yB = nextY;\n                    agingB = 0;\n                    if (Double.isNaN(xA)) {\n                        // First iteration (other values not yet initialized)\n                        signChangeIndex = 1;\n                        end = 2;\n                    } else if (signChangeIndex == start) {\n                        // Tighten the bracketing on the lower side\n                        ++signChangeIndex;\n                    }\n                    x[signChangeIndex] = nextX;\n                    y[signChangeIndex] = nextY;\n                    ++signChangeIndex;\n                } else {\n                    xA = nextX;\n                    yA = nextY;\n                    agingA = 0;\n                    if (Double.isNaN(xB)) {\n                        // First iteration (other values not yet initialized)\n                        signChangeIndex = 1;\n                        end = 2;\n                    } else if (signChangeIndex == end - 1) {\n                        // Tighten the bracketing on the upper side\n                        --signChangeIndex;\n                    }\n                    x[signChangeIndex - 1] = nextX;\n                    y[signChangeIndex - 1] = nextY;\n                }\n            } while (Double.isNaN(nextX) || bisectFlag ||\n                     ((FastMath.abs(x[end - 1] - x[start]) > FastMath.max(relativeAccuracy * FastMath.abs(nextX), absoluteAccuracy)) &&\n                      (FastMath.abs(x[start] - x[end - 1]) > FastMath.max(relativeAccuracy * FastMath.abs(nextX), absoluteAccuracy))));\n\n            // Too many evaluations (function is very ill-behaved or the\n            // bracketing interval is too small or too large)\n            if (Double.isNaN(nextX)) {\n                throw new TooManyEvaluationsException();\n            }\n\n            // Update the list of extra points\n            if (nbPoints == x.length) {\n                // Remove the oldest point\n                if (signChangeIndex <= nbPoints / 2) {\n                    System.arraycopy(x, 1, x, 0, nbPoints - 1);\n                    System.arraycopy(y, 1, y, 0, nbPoints - 1);\n                    --signChangeIndex;\n                } else {\n                    System.arraycopy(x, signChangeIndex, x, signChangeIndex - 1, nbPoints - signChangeIndex);\n                    System.arraycopy(y, signChangeIndex, y, signChangeIndex - 1, nbPoints - signChangeIndex);\n                    ++signChangeIndex;\n                }\n                // Update the number of extra points\n                --nbPoints;\n            }\n\n            // Insert the latest point\n            x[end] = nextX;\n            y[end] = nextY;\n            ++nbPoints;\n            if (nextY * yA < 0) {",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..03c38ef6d 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,9 +140,8 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n+protected double doSolve() throws TooManyEvaluationsException, NoBracketingException {\n+        // Prepare arrays with the first points\n         final double[] x = new double[maximalOrder + 1];\n         final double[] y = new double[maximalOrder + 1];\n         x[0] = getMin();\n@@ -150,199 +149,201 @@ public class BracketingNthOrderBrentSolver\n         x[2] = getMax();\n         verifySequence(x[0], x[1], x[2]);\n \n-        // evaluate initial guess\n+        // Evaluate initial guess\n         y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n+        if (isEqual(y[1], 0.0, functionValueAccuracy)) {\n+            // Return the initial guess if it is a root\n             return x[1];\n         }\n \n-        // evaluate first  endpoint\n+        // Evaluate the first endpoint\n         y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n+        if (isEqual(y[0], 0.0, functionValueAccuracy)) {\n+            // Return the first endpoint if it is a root\n             return x[0];\n         }\n \n-        int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n-\n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n-\n-        } else {\n-\n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n-            }\n-\n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n-            } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n-            }\n-\n+        // Evaluate the second endpoint\n+        y[2] = computeObjectiveValue(x[2]);\n+        if (isEqual(y[2], 0.0, functionValueAccuracy)) {\n+            // Return the second endpoint if it is a root\n+            return x[2];\n         }\n \n-        // prepare a work array for inverse polynomial interpolation\n+        // Variables for the search loop\n+        int nbPoints = 3;\n+        int signChangeIndex;\n+        double targetY = 0;\n+        double nextX;\n+        double nextY = Double.NaN;\n+        int start;\n+        int end = nbPoints;\n+\n+        // Handling variables for inverse polynomial interpolation\n         final double[] tmpX = new double[x.length];\n+        double xA = Double.NaN;\n+        double yA = Double.POSITIVE_INFINITY;\n+        int agingA = 0;\n+        double xB = Double.NaN;\n+        double yB = Double.POSITIVE_INFINITY;\n+        int agingB = 0;\n \n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n         while (true) {\n-\n-            // check convergence of bracketing interval\n+            // Check convergence of bracketing interval\n             final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n+                                 getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n+            if (((xB - xA) <= xTol) || (FastMath.abs(yB) < functionValueAccuracy)) {\n                 switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n+                    case ANY_SIDE:\n+                        return (FastMath.abs(yA) < FastMath.abs(yB)) ? xA : xB;\n+                    case LEFT_SIDE:\n+                        return xA;\n+                    case RIGHT_SIDE:\n+                        return xB;\n+                    case BELOW_SIDE:\n+                        return (yA <= 0) ? xA : xB;\n+                    case ABOVE_SIDE:\n+                        return (yA < 0) ? xB : xA;\n+                    default:\n+                        throw new MathInternalError();\n                 }\n             }\n \n-            // target for the next evaluation point\n-            double targetY;\n+            start = 0;\n+            signChangeIndex = 1;\n+            end = nbPoints;\n+\n+            // Target for the next evaluation point\n             if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n+                // We keep updating the high bracket, try to compensate this\n                 targetY = -REDUCTION_FACTOR * yB;\n             } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n+                // We keep updating the low bracket, try to compensate this\n                 targetY = -REDUCTION_FACTOR * yA;\n             } else {\n-                // bracketing is balanced, try to find the root itself\n+                // Bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n \n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n+            // Make a few attempts to guess a root\n+            boolean bisectFlag = false;\n+            nextX = Double.NaN;\n             do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n                 System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n+                try {\n+                    nextX = UnivariateSolverUtils.solve(UnivariateSolverUtils\n+                                  .bracket(new UnivariateFunction() {\n+                                      /** {@inheritDoc} */\n+                                      public double value(double x) {\n+                                          return computeObjectiveValue(x) - targetY;\n+                                      }\n+                                  }, x[start], x[end - 1], y[start], y[end - 1], initial: false, functionValueAccuracy: functionValueAccuracy, maxEvaluations: getMaxEvaluations(), result: null);\n+                } catch (NoBracketingException e) {\n+                    // No sign change\n+                    continue;\n+                }\n \n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n+                // Check for convergence\n+                if (Double.isNaN(nextX) || (FastMath.abs(nextX - xA) < functionValueAccuracy) || (FastMath.abs(xB - nextX) < functionValueAccuracy)) {\n+                    double fx;\n+                    if (Double.isNaN(nextX)) {\n+                        bisectFlag = true;\n+                    } else if (FastMath.abs(nextX - xA) < FastMath.abs(xB - nextX)) {\n+                        fx = computeObjectiveValue(xA = nextX);\n                     } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n+                        fx = computeObjectiveValue(xB = nextX);\n                     }\n+                    if (isEqual(fx, 0.0, functionValueAccuracy)) {\n+                        // We have found a root, return it\n+                        return fx;\n+                    }\n+                    break;\n+                }\n \n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n+                // Evaluate the function at the guessed root\n+                nextY = computeObjectiveValue(nextX);\n+                if (isEqual(nextY, 0.0, functionValueAccuracy)) {\n+                    // We have found a root, return it\n+                    return nextX;\n+                }\n \n+                // Update the tightest bracketing interval and the endpoints\n+                if ((nbPoints > 2) && (end - start != nbPoints)) {\n+                    // We have been forced to ignore some points to keep bracketing,\n+                    // they are probably too far from the root,\n+                    // drop them from now on\n+                    nbPoints = end - start;\n+                    System.arraycopy(x, start, x, 0, nbPoints);\n+                    System.arraycopy(y, start, y, 0, nbPoints);\n+                    signChangeIndex -= start;\n                 }\n \n-            } while (Double.isNaN(nextX) && (end - start > 1));\n+                if (isEqual(nextY, yA, functionValueAccuracy)) {\n+                    xA = nextX;\n+                    yA = nextY;\n+                    agingA++;\n+                    break;\n+                } else if (nextY * yA < 0) {\n+                    xB = nextX;\n+                    yB = nextY;\n+                    agingB = 0;\n+                    if (Double.isNaN(xA)) {\n+                        // First iteration (other values not yet initialized)\n+                        signChangeIndex = 1;\n+                        end = 2;\n+                    } else if (signChangeIndex == start) {\n+                        // Tighten the bracketing on the lower side\n+                        ++signChangeIndex;\n+                    }\n+                    x[signChangeIndex] = nextX;\n+                    y[signChangeIndex] = nextY;\n+                    ++signChangeIndex;\n+                } else {\n+                    xA = nextX;\n+                    yA = nextY;\n+                    agingA = 0;\n+                    if (Double.isNaN(xB)) {\n+                        // First iteration (other values not yet initialized)\n+                        signChangeIndex = 1;\n+                        end = 2;\n+                    } else if (signChangeIndex == end - 1) {\n+                        // Tighten the bracketing on the upper side\n+                        --signChangeIndex;\n+                    }\n+                    x[signChangeIndex - 1] = nextX;\n+                    y[signChangeIndex - 1] = nextY;\n+                }\n+            } while (Double.isNaN(nextX) || bisectFlag ||\n+                     ((FastMath.abs(x[end - 1] - x[start]) > FastMath.max(relativeAccuracy * FastMath.abs(nextX), absoluteAccuracy)) &&\n+                      (FastMath.abs(x[start] - x[end - 1]) > FastMath.max(relativeAccuracy * FastMath.abs(nextX), absoluteAccuracy))));\n \n+            // Too many evaluations (function is very ill-behaved or the\n+            // bracketing interval is too small or too large)\n             if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n-            }\n-\n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n+                throw new TooManyEvaluationsException();\n             }\n \n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n-\n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n+            // Update the list of extra points\n+            if (nbPoints == x.length) {\n+                // Remove the oldest point\n+                if (signChangeIndex <= nbPoints / 2) {\n+                    System.arraycopy(x, 1, x, 0, nbPoints - 1);\n+                    System.arraycopy(y, 1, y, 0, nbPoints - 1);\n                     --signChangeIndex;\n+                } else {\n+                    System.arraycopy(x, signChangeIndex, x, signChangeIndex - 1, nbPoints - signChangeIndex);\n+                    System.arraycopy(y, signChangeIndex, y, signChangeIndex - 1, nbPoints - signChangeIndex);\n+                    ++signChangeIndex;\n                 }\n-\n+                // Update the number of extra points\n+                --nbPoints;\n             }\n \n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n+            // Insert the latest point\n+            x[end] = nextX;\n+            y[end] = nextY;\n             ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n-            } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n-            }\n-\n-        }\n-\n-    }\n+            if (nextY * yA < 0) {\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}