{
    "patch": "Set<Var> referenced = fix.getReferencedVars();\nfor (Var var : fnScope.getVars()) {\n  if (var.getParentNode() == null || var.isParam() || referenced.contains(var)) {\n    continue;\n  }\n  if (isNamedFunctionExpression(function) && var.getNameNode() == argList.getFirstChild()) {\n    // Check if the first parameter is used as the name of a named function expression.\n    continue;\n  }\n  Node nameNode = var.getNameNode();\n  Preconditions.checkNotNull(nameNode);\n  if (nameNode != null &&\n      NodeUtil.isLhsOfAssign(nameNode) &&\n      !nameNode.getParent().isDelProp()) {\n    // Do not remove references to named function expressions\n    // which are being assigned to a property -\n    // e.g. ns.Foo = function() {}; alert(ns.Foo);\n    // Deleting the function would break the code.\n    continue;\n  }\n  if (var.isExtern()) {\n    // Do not remove extern vars\n    continue;\n  }\n  Node valueNode = var.getInitialValue();\n  if (valueNode != null && NodeUtil.isFunctionExpression(valueNode)) {\n    // Do not remove named function expressions.\n    // We may still need the name for the stack trace\n    // and the function expression may reference variables\n    // we cannot see.\n    continue;\n  }\n  nameNode.getParent().removeChild(nameNode);\n  compiler.reportCodeChange();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..04158b15 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,41 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+Set<Var> referenced = fix.getReferencedVars();\n+for (Var var : fnScope.getVars()) {\n+  if (var.getParentNode() == null || var.isParam() || referenced.contains(var)) {\n+    continue;\n+  }\n+  if (isNamedFunctionExpression(function) && var.getNameNode() == argList.getFirstChild()) {\n+    // Check if the first parameter is used as the name of a named function expression.\n+    continue;\n+  }\n+  Node nameNode = var.getNameNode();\n+  Preconditions.checkNotNull(nameNode);\n+  if (nameNode != null &&\n+      NodeUtil.isLhsOfAssign(nameNode) &&\n+      !nameNode.getParent().isDelProp()) {\n+    // Do not remove references to named function expressions\n+    // which are being assigned to a property -\n+    // e.g. ns.Foo = function() {}; alert(ns.Foo);\n+    // Deleting the function would break the code.\n+    continue;\n+  }\n+  if (var.isExtern()) {\n+    // Do not remove extern vars\n+    continue;\n+  }\n+  Node valueNode = var.getInitialValue();\n+  if (valueNode != null && NodeUtil.isFunctionExpression(valueNode)) {\n+    // Do not remove named function expressions.\n+    // We may still need the name for the stack trace\n+    // and the function expression may reference variables\n+    // we cannot see.\n+    continue;\n+  }\n+  nameNode.getParent().removeChild(nameNode);\n+  compiler.reportCodeChange();\n+}\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}