{
    "patch": "        double min = getMin();\n        double max = getMax();\n        double startValue = getStartValue();\n\n        verifySequence(min, startValue, max);\n        double targetY;\n        double xA;\n        double yA;\n        double absYA;\n        double xB;\n        double yB;\n        double absYB;\n        int agingA;\n        int agingB;\n        int signChangeIndex;\n\n        double[] x = new double[maximalOrder + 1];\n        double[] y = new double[maximalOrder + 1];\n\n        x[0] = min;\n        x[1] = startValue;\n        x[2] = max;\n\n        y[0] = computeObjectiveValue(x[0]);\n        y[1] = computeObjectiveValue(x[1]);\n        y[2] = computeObjectiveValue(x[2]);\n\n        signChangeIndex = 1;\n        absYA = FastMath.abs(y[1]);\n        absYB = FastMath.abs(y[2]);\n        xA = x[signChangeIndex - 1];\n        yA = y[signChangeIndex - 1];\n        agingA = 0;\n        xB = x[signChangeIndex];\n        yB = y[signChangeIndex];\n        agingB = 0;\n\n        int nbEval = 3;\n        while (true) {\n            // check convergence of bracketing interval\n            double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (FastMath.abs(xB - xA) <= xTol || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                    case ANY_SIDE:\n                        return absYA < absYB ? xA : xB;\n                    case LEFT_SIDE:\n                        return xA;\n                    case RIGHT_SIDE:\n                        return xB;\n                    case BELOW_SIDE:\n                        return yA <= 0 ? xA : xB;\n                    case ABOVE_SIDE:\n                        return yA < 0 ? xB : xA;\n                    default:\n                        // this should never happen\n                        throw new MathInternalError();\n                }\n            }\n            if (--maximalEvaluations <= 0) {\n                throw new TooManyEvaluationsException(maximalEvaluations + 1);\n            }\n            unsetResult();\n            ++nbEval;\n            if (agingA >= MAXIMAL_AGING) {\n                targetY = -REDUCTION_FACTOR * yB;\n            } else if (agingB >= MAXIMAL_AGING) {\n                targetY = -REDUCTION_FACTOR * yA;\n            } else {\n                targetY = 0;\n            }\n            x[nbEval] = next(x, y, nbEval, signChangeIndex, agingA, agingB, targetY);\n            final double yval = computeObjectiveValue(x[nbEval]);\n            if (FastMath.abs(yval) <= functionValueAccuracy) {\n                setResult(x[nbEval], nbEval);\n                return getResult();\n            }\n\n            if (++nbEval >= x.length) {\n                // a new entry is required in arrays\n                final double[] tmp = new double[1 + maximalOrder + nbEval];\n                System.arraycopy(x, 0, tmp, 0, nbEval);\n                x = tmp;\n                System.arraycopy(y, 0, tmp, 0, nbEval);\n                y = tmp;\n            }\n\n            y[nbEval] = yval;\n            if (y[nbEval] * yB <= 0) {\n                xA = xB;\n                yA = yB;\n                absYA = absYB;\n                agingA = agingB;\n\n                // Bisect [xA, xb]\n                xB = x[nbEval];\n                yB = y[nbEval];\n                absYB = FastMath.abs(yB);\n                agingB = 0;\n\n            } else {\n                agingB++;\n                if (FastMath.abs(y[nbEval]) < FastMath.abs(yA)) {\n                    // Tighten brackets on the left side\n                    xB = xA;\n                    xA = x[nbEval];\n                    yB = yA;\n                    yA = y[nbEval];\n                    absYB = absYA;\n                    absYA = FastMath.abs(yA);\n                    agingA = 0;\n                } else {\n                    // Tighten brackets on the right side\n                    agingA++;\n                    xB = x[nbEval];\n                    yB = y[nbEval];\n                    absYB = FastMath.abs(yB);\n                }\n            }\n        }\n    }\n\n    private double next(double[] x, double[] y, int pos, int signChangeIndex, int agingA, int agingB, double targetY) {\n        if (signChangeIndex == pos - 1) {\n            // polynomial Interpolation\n\n            return lagrange(x, y, pos, signChangeIndex);\n\n        } else {\n            // inverse quadratic interpolation\n\n            double denominator = (y[signChangeIndex - 1] - y[signChangeIndex]) * (y[signChangeIndex - 1] - y[pos]);\n            denominator *= (y[signChangeIndex] - y[pos]);\n            double a = (x[signChangeIndex] - x[signChangeIndex - 1]) * (y[signChangeIndex] - y[pos]);\n            a *= y[signChangeIndex - 1];\n            double b = (x[signChangeIndex - 1] - x[pos]) * (y[signChangeIndex - 1] - y[signChangeIndex]);\n            b *= y[signChangeIndex];\n            double c = (x[pos] - x[signChangeIndex]) * (y[pos] - y[signChangeIndex - 1]);\n            c *= y[pos];\n            double numerator = a + b + c;\n\n            return numerator / denominator;\n        }\n    }\n\n    private double lagrange(double[] x, double[] y, int pos, int signChangeIndex) {\n        double x0 = x[signChangeIndex - 1];\n        double y0 = y[signChangeIndex - 1];\n\n        double x1 = x[signChangeIndex];\n        double y1 = y[signChangeIndex];\n\n        double x2 = x[pos];\n        double y2 = y[pos];\n\n        double l0 = ((x2 - x1) * y0 - (x2 - x0) * y1) / ((x1 - x0) * (x2 - x0));\n        double l1 = ((x2 - x0) * y1 - (x2 - x1) * y0) / ((x0 - x1) * (x2 - x1));\n        double l2 = y2 - l0 - l1;\n        if (l2 == 0) {\n            // By Murphy's law, it happens\n            return 0.5 * (x1 + x2);\n        } else {\n            return 0.5 * ((x2 * x2 - x1 * x1) * l0 + (x0 * x0 - x2 * x2) * l1 + (x1 * x1 - x0 * x0) * l2) / (l0 * x2 + l1 * x0 + l2 * x1);\n        }\n    }\n\n    protected void setResult(double result, int iterationCount) {\n        this.result = result;\n        this.iterationCount = iterationCount;\n    }\n\n    protected void unsetResult() {\n        result = Double.NaN;\n        iterationCount = 0;\n    }\n\n    protected double getResult() {\n        return result;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..e18697f85 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,210 +140,184 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n-            return x[1];\n-        }\n-\n-        // evaluate first  endpoint\n-        y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n-            return x[0];\n-        }\n-\n-        int nbPoints;\n+        double min = getMin();\n+        double max = getMax();\n+        double startValue = getStartValue();\n+\n+        verifySequence(min, startValue, max);\n+        double targetY;\n+        double xA;\n+        double yA;\n+        double absYA;\n+        double xB;\n+        double yB;\n+        double absYB;\n+        int agingA;\n+        int agingB;\n         int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n-\n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n \n-        } else {\n+        double[] x = new double[maximalOrder + 1];\n+        double[] y = new double[maximalOrder + 1];\n \n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n-            }\n+        x[0] = min;\n+        x[1] = startValue;\n+        x[2] = max;\n \n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n-            } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n-            }\n-\n-        }\n-\n-        // prepare a work array for inverse polynomial interpolation\n-        final double[] tmpX = new double[x.length];\n-\n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n+        y[0] = computeObjectiveValue(x[0]);\n+        y[1] = computeObjectiveValue(x[1]);\n+        y[2] = computeObjectiveValue(x[2]);\n+\n+        signChangeIndex = 1;\n+        absYA = FastMath.abs(y[1]);\n+        absYB = FastMath.abs(y[2]);\n+        xA = x[signChangeIndex - 1];\n+        yA = y[signChangeIndex - 1];\n+        agingA = 0;\n+        xB = x[signChangeIndex];\n+        yB = y[signChangeIndex];\n+        agingB = 0;\n+\n+        int nbEval = 3;\n         while (true) {\n-\n             // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n+            double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n+            if (FastMath.abs(xB - xA) <= xTol || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                 switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n+                    case ANY_SIDE:\n+                        return absYA < absYB ? xA : xB;\n+                    case LEFT_SIDE:\n+                        return xA;\n+                    case RIGHT_SIDE:\n+                        return xB;\n+                    case BELOW_SIDE:\n+                        return yA <= 0 ? xA : xB;\n+                    case ABOVE_SIDE:\n+                        return yA < 0 ? xB : xA;\n+                    default:\n+                        // this should never happen\n+                        throw new MathInternalError();\n                 }\n             }\n-\n-            // target for the next evaluation point\n-            double targetY;\n+            if (--maximalEvaluations <= 0) {\n+                throw new TooManyEvaluationsException(maximalEvaluations + 1);\n+            }\n+            unsetResult();\n+            ++nbEval;\n             if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n                 targetY = -REDUCTION_FACTOR * yB;\n             } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n                 targetY = -REDUCTION_FACTOR * yA;\n             } else {\n-                // bracketing is balanced, try to find the root itself\n                 targetY = 0;\n             }\n-\n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n-                    }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n-                }\n-\n-            } while (Double.isNaN(nextX) && (end - start > 1));\n-\n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n+            x[nbEval] = next(x, y, nbEval, signChangeIndex, agingA, agingB, targetY);\n+            final double yval = computeObjectiveValue(x[nbEval]);\n+            if (FastMath.abs(yval) <= functionValueAccuracy) {\n+                setResult(x[nbEval], nbEval);\n+                return getResult();\n             }\n \n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n+            if (++nbEval >= x.length) {\n+                // a new entry is required in arrays\n+                final double[] tmp = new double[1 + maximalOrder + nbEval];\n+                System.arraycopy(x, 0, tmp, 0, nbEval);\n+                x = tmp;\n+                System.arraycopy(y, 0, tmp, 0, nbEval);\n+                y = tmp;\n             }\n \n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n+            y[nbEval] = yval;\n+            if (y[nbEval] * yB <= 0) {\n+                xA = xB;\n+                yA = yB;\n+                absYA = absYB;\n+                agingA = agingB;\n \n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n+                // Bisect [xA, xb]\n+                xB = x[nbEval];\n+                yB = y[nbEval];\n+                absYB = FastMath.abs(yB);\n+                agingB = 0;\n \n-            } else  if (nbPoints == x.length) {\n+            } else {\n+                agingB++;\n+                if (FastMath.abs(y[nbEval]) < FastMath.abs(yA)) {\n+                    // Tighten brackets on the left side\n+                    xB = xA;\n+                    xA = x[nbEval];\n+                    yB = yA;\n+                    yA = y[nbEval];\n+                    absYB = absYA;\n+                    absYA = FastMath.abs(yA);\n+                    agingA = 0;\n+                } else {\n+                    // Tighten brackets on the right side\n+                    agingA++;\n+                    xB = x[nbEval];\n+                    yB = y[nbEval];\n+                    absYB = FastMath.abs(yB);\n+                }\n+            }\n+        }\n+    }\n \n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n+    private double next(double[] x, double[] y, int pos, int signChangeIndex, int agingA, int agingB, double targetY) {\n+        if (signChangeIndex == pos - 1) {\n+            // polynomial Interpolation\n \n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n+            return lagrange(x, y, pos, signChangeIndex);\n \n-            }\n+        } else {\n+            // inverse quadratic interpolation\n+\n+            double denominator = (y[signChangeIndex - 1] - y[signChangeIndex]) * (y[signChangeIndex - 1] - y[pos]);\n+            denominator *= (y[signChangeIndex] - y[pos]);\n+            double a = (x[signChangeIndex] - x[signChangeIndex - 1]) * (y[signChangeIndex] - y[pos]);\n+            a *= y[signChangeIndex - 1];\n+            double b = (x[signChangeIndex - 1] - x[pos]) * (y[signChangeIndex - 1] - y[signChangeIndex]);\n+            b *= y[signChangeIndex];\n+            double c = (x[pos] - x[signChangeIndex]) * (y[pos] - y[signChangeIndex - 1]);\n+            c *= y[pos];\n+            double numerator = a + b + c;\n+\n+            return numerator / denominator;\n+        }\n+    }\n \n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n-            } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n+    private double lagrange(double[] x, double[] y, int pos, int signChangeIndex) {\n+        double x0 = x[signChangeIndex - 1];\n+        double y0 = y[signChangeIndex - 1];\n \n-                // update the sign change index\n-                signChangeIndex++;\n+        double x1 = x[signChangeIndex];\n+        double y1 = y[signChangeIndex];\n \n-            }\n+        double x2 = x[pos];\n+        double y2 = y[pos];\n \n+        double l0 = ((x2 - x1) * y0 - (x2 - x0) * y1) / ((x1 - x0) * (x2 - x0));\n+        double l1 = ((x2 - x0) * y1 - (x2 - x1) * y0) / ((x0 - x1) * (x2 - x1));\n+        double l2 = y2 - l0 - l1;\n+        if (l2 == 0) {\n+            // By Murphy's law, it happens\n+            return 0.5 * (x1 + x2);\n+        } else {\n+            return 0.5 * ((x2 * x2 - x1 * x1) * l0 + (x0 * x0 - x2 * x2) * l1 + (x1 * x1 - x0 * x0) * l2) / (l0 * x2 + l1 * x0 + l2 * x1);\n         }\n+    }\n \n+    protected void setResult(double result, int iterationCount) {\n+        this.result = result;\n+        this.iterationCount = iterationCount;\n     }\n \n+    protected void unsetResult() {\n+        result = Double.NaN;\n+        iterationCount = 0;\n+    }\n+\n+    protected double getResult() {\n+        return result;\n+\n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>\n      * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q",
    "result_reason": "error: invalid method declaration; return type required",
    "test_result": "ERROR"
}