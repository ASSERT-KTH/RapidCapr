{
    "patch": "    private String convertInfixToPostfix(String infixExpression) throws ParseException{\n        StringBuilder postfixExpression = new StringBuilder();\n        Stack<String> operatorStack = new Stack<>();\n        Node infixRootNode = new ASTParser(new StringProvider(infixExpression)).parseExpression();\n        infixRootNode.accept(new VoidVisitorAdapter<Void>() {\n            @Override\n            public void visit(BinaryExpr n, Void arg) {\n                try {\n                    convertBinaryInfixToPostfix(n, postfixExpression, operatorStack);\n                } catch (ParseException e) {\n                    throw new RuntimeException(e);\n                }\n                super.visit(n, arg);\n            }\n        });\n        while(!operatorStack.isEmpty()) {\n            postfixExpression.append(operatorStack.pop()).append(' ');\n        }\n        return postfixExpression.toString().trim();\n    }\n\n    private void convertBinaryInfixToPostfix(BinaryExpr binaryExpr, StringBuilder postfixExpression, Stack<String> operatorStack) throws ParseException {\n        String operatorSymbol = binaryExpr.getOperator().asString();\n        Expression rhsNode = binaryExpr.getRight();\n        String lhsName = \"\";\n        if (binaryExpr.getLeft() instanceof NameExpr) {\n            lhsName = ((NameExpr) binaryExpr.getLeft()).getNameAsString();\n        } else {\n            throw new ParseException(\"Expected LHS of binary expression to be a name\");\n        }\n        boolean rhsIsArray = rhsNode instanceof ArrayAccessExpr;\n        Object rhsValue = rhsIsArray ? rhsNode.toString() : rhsNode.accept(new ToStringVisitor());\n        String infixExpr = String.format(\"%s %s %s\", rhsValue, operatorSymbol, lhsName);\n        if (rhsIsArray) {\n            infixExpr = String.format(\"(%s)\", infixExpr);\n        }\n        int newOperatorPrecedence = binaryExpr.getOperator().getPrecedence();\n        while (!operatorStack.isEmpty() && operatorStack.peek().startsWith(\"(\") == false) {\n            int existingOperatorPrecedence = Operator.getPrecedence(operatorStack.peek());\n            if (existingOperatorPrecedence > newOperatorPrecedence\n                    || (existingOperatorPrecedence == newOperatorPrecedence && binaryExpr.getOperator().isLeftAssociative())) {\n                postfixExpression.append(operatorStack.pop()).append(' ');\n            } else {\n                break;\n            }\n        }\n        operatorStack.push(infixExpr);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 54eb5cf8..6267f6c9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -104,7 +104,7 @@ class CodeGenerator {\n     add(n, Context.OTHER);\n   }\n \n-  void add(Node n, Context context) {\n+\n     if (!cc.continueProcessing()) {\n       return;\n     }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}