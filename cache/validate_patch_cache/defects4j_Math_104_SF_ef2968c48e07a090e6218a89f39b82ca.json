{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Pair;\nimport org.apache.commons.math3.util.FastMath;\n\npublic class GammaFunction {\n\n  /**\n   * This implementation is based on the same implementation as used in Apache Math.\n   * It uses Lanczos approximation to calculate the gamma function.\n   * Reference: http://mathworld.wolfram.com/LanczosApproximation.html\n   *\n   * @param x The input value.\n   * @return The calculated gamma value.\n   */\n  public static double gamma(double x) {\n\n    if (Double.isNaN(x) || (x <= 0.0)) {\n      return Double.NaN;\n    }\n\n    double g = 7;\n    double[] coefficients = {0.9999999999998099, 676.5203681218851, -1259.1392167224028,\n        771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012,\n        9.9843695780195716e-6, 1.5056327351493116e-7};\n\n    double a = coefficients[0];\n    double t = x + g + 0.5;\n    for (int i = 1; i < coefficients.length; i++) {\n      a += coefficients[i] / (x + i);\n    }\n\n    return Math.sqrt(2 * MathUtils.PI) * FastMath.pow(t, (x + 0.5)) * FastMath.exp(-t) * a;\n  }\n\n  /**\n   * This implementation calculates the regularized gamma function P(a, x).\n   * It is calculated as (1 / gamma(a)) * integral (0 to x) t^(a-1) * e^(-t) dt.\n   * The implementation uses the series expansion of the incomplete gamma function to\n   * calculate P(a, x) with the series continued till the desired level of accuracy.\n   * Reference: http://mathworld.wolfram.com/RegularizedGammaFunction.html\n   *\n   * @param a Shape parameter.\n   * @param x The upper limit of the integral.\n   * @param maxIter Maximum iterations for convergence.\n   * @param eps Desired level of accuracy.\n   * @return The calculated regularized gamma function value.\n   */\n  public static double regularizedGamma(double a, double x, int maxIter, double eps) {\n\n    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n      return Double.NaN;\n    }\n\n    if (x == 0.0) {\n      return 0.0;\n    }\n\n    if (x < a + 1.0) {\n      return incompleteSeries(a, x, maxIter, eps);\n    } else {\n      Pair<Double, Double> continuedFraction = incompleteFraction(a, x, maxIter, eps);\n      return 1.0 - (FastMath.exp(-x) * FastMath.pow(x, a) * continuedFraction.getB()) / Gamma\n          .gamma(a);\n    }\n  }\n\n  /**\n   * Calculate the infinite sum part of the incomplete gamma function.\n   *\n   * @param a Shape parameter.\n   * @param x The upper limit of the integral.\n   * @param maxIter Maximum iterations for convergence.\n   * @param eps Desired level of accuracy.\n   * @return The calculated incomplete gamma function value.\n   */\n  private static double incompleteSeries(double a, double x, int maxIter, double eps) {\n\n    double n = 0.0;\n    double sum = 1.0 / a;\n    double an = sum;\n\n    while (FastMath.abs(an) > eps * FastMath.abs(sum) && n < maxIter && sum != 0.0) {\n      n += 1.0;\n      an = an * (x / (a + n));\n      sum += an;\n    }\n\n    return FastMath.exp(-x) * FastMath.pow(x, a) * sum / Gamma.gamma(a);\n  }\n\n  /**\n   * Calculate the continued fraction part of the incomplete gamma function.\n   *\n   * @param a Shape parameter.\n   * @param x The upper limit of the integral.\n   * @param maxIter Maximum iterations for convergence.\n   * @param eps Desired level of accuracy.\n   * @return a pair of {value, last_term} for the incomplete gamma function value and the last term.\n   * The value is calculated as (1 / gamma(a)) * integral (0 to x) t^(a-1) * e^(-t) dt.\n   */\n  private static Pair<Double, Double> incompleteFraction(double a, double x, int maxIter,\n                                                         double eps) {\n\n    double big = Double.MAX_VALUE * 2.0;\n\n    double b1 = 1.0;\n    double b2 = x + 1.0 - a;\n    double b3 = x;\n    double d1 = 0.0;\n    double d2 = 1.0;\n    double d3 = 1.0;\n    double h1 = b2;\n    double h2 = b1;\n    double h3 = 0.0;\n    double q1 = b2;\n    double q2 = b2 * b3 - b1;\n    double a1 = q1 / q2;\n    double a2 = b3;\n    double n = 1.0;\n\n    while (n <= maxIter) {\n      double a_n = (n - a) * a1 + x;\n      double b_n = b2 + (n - 1.0) * (b1 - b2) / (n + 1.0);\n      double d_n = a_n * d2 + b_n * d1;\n      if (FastMath.abs(d_n) > big) {\n        d1 /= big;\n        d2 /= big;\n        d3 /= big;\n        h1 /= big;\n        h2 /= big;\n      }\n      d1 = d2;\n      d2 = d3;\n      d3 = d_n;\n      h3 = h2;\n      h2 = h1;\n      h1 = d_n;\n      a3 = a2;\n      a2 = a1;\n      a1 = d_n != 0.0 ? b_n / d_n : Double.MAX_VALUE;\n\n      if (FastMath.abs(a1 * a3 - 1.0) < eps) {\n        return new Pair<>(\n            1.0 - (FastMath.exp(-x) * FastMath.pow(x, a) * a1) / Gamma.gamma(a),\n            FastMath.abs(a1 * a3 - 1.0));\n      }\n\n      n += 1.0;\n    }\n\n    return new Pair<>(\n        1.0 - (FastMath.exp(-x) * FastMath.pow(x, a) * a1) / Gamma.gamma(a),\n        FastMath.abs(a1 * a3 - 1.0));\n  }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..fc5fc6500 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,162 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.util.FastMath;\n+\n+public class GammaFunction {\n+\n+  /**\n+   * This implementation is based on the same implementation as used in Apache Math.\n+   * It uses Lanczos approximation to calculate the gamma function.\n+   * Reference: http://mathworld.wolfram.com/LanczosApproximation.html\n+   *\n+   * @param x The input value.\n+   * @return The calculated gamma value.\n+   */\n+  public static double gamma(double x) {\n+\n+    if (Double.isNaN(x) || (x <= 0.0)) {\n+      return Double.NaN;\n+    }\n+\n+    double g = 7;\n+    double[] coefficients = {0.9999999999998099, 676.5203681218851, -1259.1392167224028,\n+        771.32342877765313, -176.61502916214059, 12.507343278686905, -0.13857109526572012,\n+        9.9843695780195716e-6, 1.5056327351493116e-7};\n+\n+    double a = coefficients[0];\n+    double t = x + g + 0.5;\n+    for (int i = 1; i < coefficients.length; i++) {\n+      a += coefficients[i] / (x + i);\n+    }\n+\n+    return Math.sqrt(2 * MathUtils.PI) * FastMath.pow(t, (x + 0.5)) * FastMath.exp(-t) * a;\n+  }\n+\n+  /**\n+   * This implementation calculates the regularized gamma function P(a, x).\n+   * It is calculated as (1 / gamma(a)) * integral (0 to x) t^(a-1) * e^(-t) dt.\n+   * The implementation uses the series expansion of the incomplete gamma function to\n+   * calculate P(a, x) with the series continued till the desired level of accuracy.\n+   * Reference: http://mathworld.wolfram.com/RegularizedGammaFunction.html\n+   *\n+   * @param a Shape parameter.\n+   * @param x The upper limit of the integral.\n+   * @param maxIter Maximum iterations for convergence.\n+   * @param eps Desired level of accuracy.\n+   * @return The calculated regularized gamma function value.\n+   */\n+  public static double regularizedGamma(double a, double x, int maxIter, double eps) {\n+\n+    if (Double.isNaN(a) || Double.isNaN(x) || (a <= 0.0) || (x < 0.0)) {\n+      return Double.NaN;\n+    }\n+\n+    if (x == 0.0) {\n+      return 0.0;\n+    }\n+\n+    if (x < a + 1.0) {\n+      return incompleteSeries(a, x, maxIter, eps);\n+    } else {\n+      Pair<Double, Double> continuedFraction = incompleteFraction(a, x, maxIter, eps);\n+      return 1.0 - (FastMath.exp(-x) * FastMath.pow(x, a) * continuedFraction.getB()) / Gamma\n+          .gamma(a);\n+    }\n+  }\n+\n+  /**\n+   * Calculate the infinite sum part of the incomplete gamma function.\n+   *\n+   * @param a Shape parameter.\n+   * @param x The upper limit of the integral.\n+   * @param maxIter Maximum iterations for convergence.\n+   * @param eps Desired level of accuracy.\n+   * @return The calculated incomplete gamma function value.\n+   */\n+  private static double incompleteSeries(double a, double x, int maxIter, double eps) {\n+\n+    double n = 0.0;\n+    double sum = 1.0 / a;\n+    double an = sum;\n+\n+    while (FastMath.abs(an) > eps * FastMath.abs(sum) && n < maxIter && sum != 0.0) {\n+      n += 1.0;\n+      an = an * (x / (a + n));\n+      sum += an;\n+    }\n+\n+    return FastMath.exp(-x) * FastMath.pow(x, a) * sum / Gamma.gamma(a);\n+  }\n+\n+  /**\n+   * Calculate the continued fraction part of the incomplete gamma function.\n+   *\n+   * @param a Shape parameter.\n+   * @param x The upper limit of the integral.\n+   * @param maxIter Maximum iterations for convergence.\n+   * @param eps Desired level of accuracy.\n+   * @return a pair of {value, last_term} for the incomplete gamma function value and the last term.\n+   * The value is calculated as (1 / gamma(a)) * integral (0 to x) t^(a-1) * e^(-t) dt.\n+   */\n+  private static Pair<Double, Double> incompleteFraction(double a, double x, int maxIter,\n+                                                         double eps) {\n+\n+    double big = Double.MAX_VALUE * 2.0;\n+\n+    double b1 = 1.0;\n+    double b2 = x + 1.0 - a;\n+    double b3 = x;\n+    double d1 = 0.0;\n+    double d2 = 1.0;\n+    double d3 = 1.0;\n+    double h1 = b2;\n+    double h2 = b1;\n+    double h3 = 0.0;\n+    double q1 = b2;\n+    double q2 = b2 * b3 - b1;\n+    double a1 = q1 / q2;\n+    double a2 = b3;\n+    double n = 1.0;\n+\n+    while (n <= maxIter) {\n+      double a_n = (n - a) * a1 + x;\n+      double b_n = b2 + (n - 1.0) * (b1 - b2) / (n + 1.0);\n+      double d_n = a_n * d2 + b_n * d1;\n+      if (FastMath.abs(d_n) > big) {\n+        d1 /= big;\n+        d2 /= big;\n+        d3 /= big;\n+        h1 /= big;\n+        h2 /= big;\n+      }\n+      d1 = d2;\n+      d2 = d3;\n+      d3 = d_n;\n+      h3 = h2;\n+      h2 = h1;\n+      h1 = d_n;\n+      a3 = a2;\n+      a2 = a1;\n+      a1 = d_n != 0.0 ? b_n / d_n : Double.MAX_VALUE;\n+\n+      if (FastMath.abs(a1 * a3 - 1.0) < eps) {\n+        return new Pair<>(\n+            1.0 - (FastMath.exp(-x) * FastMath.pow(x, a) * a1) / Gamma.gamma(a),\n+            FastMath.abs(a1 * a3 - 1.0));\n+      }\n+\n+      n += 1.0;\n+    }\n+\n+    return new Pair<>(\n+        1.0 - (FastMath.exp(-x) * FastMath.pow(x, a) * a1) / Gamma.gamma(a),\n+        FastMath.abs(a1 * a3 - 1.0));\n+  }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}