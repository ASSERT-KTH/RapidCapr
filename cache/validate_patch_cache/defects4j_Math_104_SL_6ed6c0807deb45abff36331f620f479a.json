{
    "patch": "import org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.exception.ConvergenceException;\nimport org.apache.commons.math3.exception.MathIllegalArgumentException;\nimport org.apache.commons.math3.exception.MaxCountExceededException;\nimport org.apache.commons.math3.util.ContinuedFraction;\nimport org.apache.commons.math3.util.DefaultContinuedFractionProvider;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Precision;\nimport org.apache.commons.math3.util.SeriesExpansion;\nimport org.apache.commons.math3.special.Gamma;\n\n/**\n * Implements the <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">\n * Regularized Gamma Function</a>.\n * <p>\n * The implementation of this gamma function follows the\n * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">definition</a>:\n * <pre>\n * \u0393(s, x) = 1 / \u0393(s) * Integral(t=0 to t=x) : t^(s-1) * exp(-t) dt\n * </pre>\n * where \u0393(s) is the <a href=\"http://mathworld.wolfram.com/CompleteGammaFunction.html\">complete gamma\n * function</a>. This implementation uses either a Lanczos series approximation or a power series\n * approximation depending on the precision of the input.\n *\n * @since 1.1\n */\npublic class RegularizedGamma {\n\n    /** The default relative accuracy. */\n    private static final double DEFAULT_EPSILON = 1e-9;\n\n    /** The Lanczos coefficients. */\n    private static final double[] LANCZOS = {\n       0.99999999999999709182,\n       57.156235665862923517,\n      -59.597960355475491248,\n       14.136097974741747174,\n       -0.49191381609762019978,\n        0.33994649984811888699e-4,\n        0.46523628927048575665e-4,\n       -0.98374475304879564677e-4,\n        0.15808870322491248884e-3,\n       -0.21026444172410488319e-3,\n        0.21743961811521264320e-3,\n       -0.16431810653676389022e-3,\n        0.84418223983852743293e-4,\n       -0.26190838401581408670e-4,\n        0.36899182659531622704e-5,\n    };\n\n    /** The continued fraction provider to use. */\n    private static final DefaultContinuedFractionProvider CONTINUED_FRACTION_PROVIDER =\n            new DefaultContinuedFractionProvider();\n\n    /**\n     * Private constructor to prevent instantiation.\n     */\n    private RegularizedGamma() {}\n\n    /**\n     * Returns the regularized gamma function Q(a, x) = 1 / \u0393(a) * Integral(t=0 to t=x) : t^(a-1) * exp(-t)\n     * dt for a &gt; 0 and x &ge; 0.\n     *\n     * @param a the a parameter (must be positive).\n     * @param x the x parameter (must be non-negative).\n     * @return the regularized gamma function Q(a, x).\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     * @throws MathIllegalArgumentException if {@code a < 0} or {@code x < 0}.\n     */\n    public static double gamma(double a, double x)\n        throws MaxCountExceededException, MathIllegalArgumentException {\n\n        if (a <= 0.0) {\n            throw new MathIllegalArgumentException(new LocalizedFormats(\"NOT_POSITIVE_GAMMA_FUNCTIONAL_PARAMETER\"), a);\n        }\n        if (x < 0.0) {\n            throw new MathIllegalArgumentException(new LocalizedFormats(\"UNABLE_TO_COMPUTE_REGULARIZED_GAMMA_A_SMALLER_THAN_0\"), x);\n        }\n\n        if (Precision.equals(x, 0.0, 0) || (x > a && x > 1.0)) {\n            return 1.0;\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            return 0.0;\n        }\n\n        if (a > 1.0e8) {\n            if (x > a) {\n                final double d = x - a;\n                return regularizedGamma1(a, d, DEFAULT_EPSILON, Integer.MAX_VALUE);\n            } else {\n                return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n            }\n        }\n\n        final double epsilon = getEpsilon(a, x);\n        if (x >= a || x >= 1.0) {\n            return regularizedGammaQ(a, x, epsilon, Integer.MAX_VALUE);\n        } else {\n            return regularizedGammaP(a, x, epsilon, Integer.MAX_VALUE);\n        }\n    }\n\n    /**\n     * Computes the regularized gamma function P(a, x) = 1 / \u0393(a) * Integral(t=0 to t=x) : t^(a-1) * exp(-t)\n     * dt for 0 &lt; a &lt; 1 and x &ge; 0.\n     *\n     * @param a the a parameter (must satisfy 0 < a < 1).\n     * @param x the x parameter (must be non-negative).\n     * @param epsilon the accuracy goal.\n     * @param maxIterations maximum number of iterations.\n     * @return the regularized gamma function P(a, x).\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     */\n    private static double regularizedGammaP(double a, double x, double epsilon, int maxIterations)\n            throws MaxCountExceededException {\n\n        double sum = 1 / a;\n        double term = sum;\n        int i = 1;\n        while (Precision.compareTo(term, epsilon, 0) > 0 && i <= maxIterations) {\n            term *= x / (a + i);\n            sum += term;\n            i++;\n        }\n\n        if (i > maxIterations) {\n            throw new MaxCountExceededException(new LocalizedFormats(\"NON_CONVERGENT_CONTINUED_FRACTION\"), maxIterations);\n        }\n\n        return FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * sum;\n    }\n\n    /**\n     * Computes the regularized gamma function Q(a, x) = 1 / \u0393(a) * Integral(t=x to infinity) :\n     * t^(a-1) * exp(-t) dt for a &gt; 0 and x &ge; 0.\n     *\n     * @param a the a parameter (must be positive).\n     * @param x the x parameter (must be non-negative).\n     * @param epsilon the accuracy goal.\n     * @param maxIterations maximum number of iterations.\n     * @return the regularized gamma function Q(a, x).\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     */\n    private static double regularizedGammaQ(double a, double x, double epsilon, int maxIterations)\n            throws MaxCountExceededException {\n\n        double i = CONTINUED_FRACTION_PROVIDER.getNonTrivialFraction(a, x, epsilon, maxIterations).evaluate(x);\n        return FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * i;\n    }\n\n    /**\n     * Returns the regularized gamma function Q(a, \u221e) for a &gt; 0.\n     *\n     * @param a the a parameter (must be positive).\n     * @param epsilon the accuracy goal.\n     * @param maxIterations maximum number of iterations.\n     * @return the regularized gamma function Q(a, \u221e).\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     */\n    public static double regularizedGammaQ(double a, double epsilon, int maxIterations)\n            throws MaxCountExceededException {\n\n        final int n = (int) FastMath.max(0, FastMath.ceil(a) - 1);\n        final double b = a - n;\n        double i;\n        if (b == 0.0) {\n            i = 0.0;\n        } else if (b >= 1) {\n            i = regularizedGammaQ(b, epsilon, maxIterations);\n            for (int j = 1; j < n; j++) {\n                if (i == 0.0) {\n                    return 0.0;\n                }\n                i = MathUtils.factorialDouble(j - 1) * Math.pow(1 / i + b, -1) * FastMath.exp(-b + (j - 1) * FastMath.log(b));\n            }\n        } else {\n            i = 1.0 / (b * Constants.EULER_GAMMA + 1.0);\n            for (int j = 1; j < n; j++) {\n                i = Math.pow(b * j / i + 1, -1);\n            }\n        }\n        return 1.0 / (1.0 + i);\n    }\n\n    /**\n     * Returns the regularized gamma function Q(a, \u221e) for a &gt; 0.\n     *\n     * @param a the a parameter (must be positive).\n     * @return the regularized gamma function Q(a, \u221e).\n     */\n    public static double regularizedGammaQ(double a) {\n        return regularizedGammaQ(a, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Computes the regularized gamma function Q(a + n, x) using its series representation<br/>\n     * Q(a + n, x) = \u0393(a,x) / \u0393(a) - x^a * Sum[k=0 to n-1] (x^k / (a + k)!)\n     * where \u0393(a,x) is the <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">Incomplete Gamma\n     * Function</a>. See <a href=\"http://dlmf.nist.gov/8.11.E19\">DLMF equation 8.11.19.1</a>.<br/>\n     *\n     * @param a the a parameter (must be positive).\n     * @param n the number of terms in the sum.\n     * @param x the x parameter (must be non-negative).\n     * @return the regularized gamma function Q(a + n, x).\n     */\n    private static double seriesSumApsilant(double a, int n, double x) {\n        double term = 1d / a;\n        double sum = term;\n        for (int i = 1; i <= n-1; i++) {\n            term *= x / (a + i);\n            sum += term;\n        }\n        return FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * sum;\n    }\n\n    /**\n     * Computes the regularized gamma function Q(a, x + n) using its series representation<br/>\n     * Q(a, x + n) = 1 - (x+n)^a / \u0393(a) * Sum[k=0 to n-1] ((x+n-a)^k * k! / (x + n + k))\n     * where \u0393(a,x) is the <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">Incomplete Gamma\n     * Function</a>. See <a href=\"http://dlmf.nist.gov/8.11.E19\">DLMF equation 8.11.19.1</a>.<br/>\n     *\n     * @param a the a parameter (must be positive).\n     * @param n the number of terms in the sum.\n     * @param x the x parameter (must be sufficiently large that x+n >= a+1).\n     * @return the regularized gamma function Q(a, x + n).\n     */\n    private static double seriesSumBrinch(double a, int n, double x) {\n        double prefix = FastMath.pow(x + n - a, n) * MathUtils.factorialDouble(n - 1) / x;\n        double term = 1d / (x + n);\n        double sum = term;\n        for (int k = 1; k <= n - 1; k++) {\n            term *= (x + n - a + k - 1) / (x + n + k);\n            sum += term;\n        }\n        sum = prefix * sum;\n        return FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * sum;\n    }\n\n    /**\n     * Returns a suitable epsilon for the calculation of the regularized\n     * gamma function with parameters a and x.\n     * For a > 15, the returned epsilon is max(10e-15, 10e-15 * |x + a| * ULP(a)),\n     * otherwise the epsilon is max(10e-15, 10e-15 * ULP(1)).\n     * Here ULP(y) is the size of the smallest increment of y representable by\n     * the floating-point implementation.\n     * @param a first argument of the gamma function\n     * @param x second argument of the gamma function\n     * @return a value eps such that for gamma(a, x) = P + eps,\n     * neither P nor eps differ significantly from their true values.\n     */\n    private static double getEpsilon(double a, double x) {\n        final double epsilon;\n        if (Precision.compareTo(a, 15, 1) > 0) {\n            epsilon = Precision.EPSILON * FastMath.abs(x + a) * Precision.ulp(a);\n        } else {\n            epsilon = Precision.EPSILON * Precision.ulp(1d);\n        }\n        return epsilon;\n    }\n\n    /**\n     * Refinement procedure applied to a computed base estimate of the\n     * incomplete gamma function. The algorithm is described in Chapter 6\n     * of reference [1]. The argument {@code a} here is identical to\n     * {@code gln} in reference [1].\n     *\n     * @param a the value of {@code alpha} in the integral.\n     * @param x the value of {@code x} in the integral.\n     * @param incompleteGamma the incomplete gamma function.\n     * @param epsilon the accuracy goal.\n     * @return the refined value.\n     * @throws MaxCountExceededException if the maximum number of iterations is exhausted.\n     */\n    private static double temme(double a, double x, double incompleteGamma, double epsilon)\n            throws MaxCountExceededException {\n        double small = 1e-50;\n        double big = 1d / small;\n        double bigInv = 0;\n        double h0 = 1;\n        double hPrev = x;\n        double[] h = new double[2];\n        double d0 = 0;\n        double dPrev = 1;\n        double[] d = new double[2];\n        double hBar = hPrev;\n        double dBar = dPrev;\n        int i = 1;\n        double error;\n        do {\n            boolean exact = i % 2 != 0;\n            double p = (i - 1) / 2d;\n            double q = a - (i - 1) / 2d;\n            double numerator;\n            if (exact) {\n                numerator = p * (q + p) * x;\n            } else {\n                numerator = -(x + p) * (x + q);\n            }\n            double denominator = q * hPrev - p * dPrev;\n            double a_i = numerator / denominator;\n            h[0] = FastMath.max(small, FastMath.min(big, hPrev + a_i * h0));\n            d[0] = FastMath.max(small, FastMath.min(big, dPrev + a_i * d0));\n            if (FastMath.abs(h[0] * bigInv) > 1) {\n                bigInv = 1d / h[0];\n            }\n            double hBarPrev = hBar;\n            hBar = h[0] * bigInv;\n            Double.isNaN(hBar);\n            dBar += a_i * dBar;\n            d0 = dPrev;\n            dPrev = d[0];\n            h0 = hPrev;\n            hPrev = h[0];\n            error = dBar != 0 ? FastMath.abs((hBar - hBarPrev) / (dBar)) : FastMath.abs(hBar - hBarPrev);\n            i++;\n        } while ((error > epsilon) && (i <= 200));\n        if (i > 200) {\n            throw new MaxCountExceededException(new LocalizedFormats(\"NON_CONVERGENT_CONTINUED_FRACTION\"));\n        }\n        return incompleteGamma * hBar;\n    }\n\n    /**\n     * Computes regularized gamma function P(a, x) using the series definition.\n     *\n     * @param a the value of {@code alpha} in the integral.\n     * @param x the value of {@code x} in the integral.\n     * @param epsilon the accuracy goal.\n     * @param maxIterations the maximum number of iterations to perform.\n     * @return the regularized gamma function P(a, x).\n     * @throws MaxCountExceededException if the algorithm fails to converge.\n     */\n    private static double regularizedGamma1(double a, double x, double epsilon, int maxIterations)\n            throws MaxCountExceededException {\n        double p = a;\n        double sum = 1 / a;\n        double term = sum;\n        int i = 1;\n        while (Precision.compareTo(term, epsilon, 0) > 0 && i <= maxIterations) {\n            p++;\n            term *= x / p;",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}