{
    "patch": "        if (count > 0) {\n            // [...]\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                // save the fields up to (but not including) the year field\n                // in case the parser needs to recursively parse the values\n                int year = 0;\n                int fieldIndex = -1;\n                for (int i = 0; i < count; i++) {\n                    DateTimeField field = savedFields[i].iField;\n                    if (field == null || !field.isSupported()) {\n                        continue;\n                    }\n                    if (field.getType() >= DateTimeFieldType.year().getType()) {\n                        break;\n                    }\n                    fieldIndex = i;\n                }\n                if (fieldIndex >= 0) {\n                    DateTimeField[] fields = new DateTimeField[fieldIndex + 1];\n                    for (int i = 0; i <= fieldIndex; i++) {\n                        fields[i] = savedFields[i].iField;\n                    }\n                    Chronology chrono = iChrono.withUTC();\n                    long millis = 0L;\n                    Partial partial = new Partial(fields, new int[fieldIndex + 1]);\n                    try {\n                        millis = chrono.getDateTimeMillis(partial);\n                        LocalDate date = new LocalDate(millis, chrono);\n                        year = date.getYear();\n                    } catch (IllegalArgumentException e) {\n                        // date specified fields that are incompatible with the chronology\n                        // for example - February 30th\n                    }\n                    saveField(DateTimeFieldType.year(), year);\n                } else {\n                    saveField(DateTimeFieldType.year(), iDefaultYear);\n                }\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            // [...]\n        } catch (IllegalFieldValueException e) {\n            // [...]\n        }\n\n        // recompute the year after parsing in case the fields include a day of year or week year\n        Chronology chrono = iChrono.withUTC();\n        LocalDate date = new LocalDate(millis, chrono);\n        int year = date.getYear();\n        millis = chrono.getDateTimeMillis(year, date.getMonthOfYear(), date.getDayOfMonth(),\n                date.getMillisOfDay());\n\n        // [...]\n        \n        return millis;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..95ae415b 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,63 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+        if (count > 0) {\n+            // [...]\n+            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n+                // save the fields up to (but not including) the year field\n+                // in case the parser needs to recursively parse the values\n+                int year = 0;\n+                int fieldIndex = -1;\n+                for (int i = 0; i < count; i++) {\n+                    DateTimeField field = savedFields[i].iField;\n+                    if (field == null || !field.isSupported()) {\n+                        continue;\n+                    }\n+                    if (field.getType() >= DateTimeFieldType.year().getType()) {\n+                        break;\n+                    }\n+                    fieldIndex = i;\n+                }\n+                if (fieldIndex >= 0) {\n+                    DateTimeField[] fields = new DateTimeField[fieldIndex + 1];\n+                    for (int i = 0; i <= fieldIndex; i++) {\n+                        fields[i] = savedFields[i].iField;\n+                    }\n+                    Chronology chrono = iChrono.withUTC();\n+                    long millis = 0L;\n+                    Partial partial = new Partial(fields, new int[fieldIndex + 1]);\n+                    try {\n+                        millis = chrono.getDateTimeMillis(partial);\n+                        LocalDate date = new LocalDate(millis, chrono);\n+                        year = date.getYear();\n+                    } catch (IllegalArgumentException e) {\n+                        // date specified fields that are incompatible with the chronology\n+                        // for example - February 30th\n+                    }\n+                    saveField(DateTimeFieldType.year(), year);\n+                } else {\n+                    saveField(DateTimeFieldType.year(), iDefaultYear);\n+                }\n+            }\n+        }\n+\n+        long millis = iMillis;\n+        try {\n+            // [...]\n+        } catch (IllegalFieldValueException e) {\n+            // [...]\n+        }\n+\n+        // recompute the year after parsing in case the fields include a day of year or week year\n+        Chronology chrono = iChrono.withUTC();\n+        LocalDate date = new LocalDate(millis, chrono);\n+        int year = date.getYear();\n+        millis = chrono.getDateTimeMillis(year, date.getMonthOfYear(), date.getDayOfMonth(),\n+                date.getMillisOfDay());\n+\n+        // [...]\n+        \n+        return millis;\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}