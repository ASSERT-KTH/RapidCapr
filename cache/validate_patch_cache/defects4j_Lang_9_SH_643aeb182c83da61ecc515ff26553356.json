{
    "patch": "    public Date parse(String input) throws ParseException {\n        return parse(input, new ParsePosition(0));\n    }\n  \n    public Date parse(String input, ParsePosition pos) {\n        // initialize Calendar to midnight\n        Calendar cal = Calendar.getInstance(timeZone, locale);\n        cal.clear();\n        cal.set(Calendar.YEAR, thisYear);\n        cal.set(Calendar.MONTH, month);\n        cal.set(Calendar.DATE, day);\n\n        // format matcher\n        Matcher matcher = parsePattern.matcher(input.substring(pos.getIndex()));\n\n        // parse input based on the patterns\n        for (int i = 0; i < strategies.length; ++i) {\n            Strategy strategy = strategies[i];\n            if (!matcher.find()) {\n                pos.setErrorIndex(pos.getIndex());\n                return null;\n            }\n            int index = matcher.start();\n            String value = matcher.group();\n            DateBuilder dateBuilder = strategy.parseInto(this, value, cal);\n            if (dateBuilder == null) {\n                pos.setErrorIndex(index);\n                return null;\n            }\n            cal = dateBuilder.buildCalendar(cal);\n        }\n\n        // discard parsed timezone\n        if (pos.getIndex() < input.length()) {\n            char nextChar = input.charAt(pos.getIndex());\n            if (nextChar == 'Z') { // UTC (no offset)\n                pos.setIndex(pos.getIndex() + 1);\n            } else if (nextChar == '+' || nextChar == '-') { // offset of the form [+-]hh:mm\n                pos.setIndex(pos.getIndex() + 3);\n            }\n        }\n\n        // return parsed date\n        pos.setIndex(pos.getIndex() + matcher.end());\n        return cal.getTime();\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 8df302f9..50a4cbfd 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -141,6 +141,52 @@ public class FastDateParser implements DateParser, Serializable {\n             currentFormatField= nextFormatField;\n             currentStrategy= nextStrategy;\n         }\n+    public Date parse(String input) throws ParseException {\n+        return parse(input, new ParsePosition(0));\n+    }\n+  \n+    public Date parse(String input, ParsePosition pos) {\n+        // initialize Calendar to midnight\n+        Calendar cal = Calendar.getInstance(timeZone, locale);\n+        cal.clear();\n+        cal.set(Calendar.YEAR, thisYear);\n+        cal.set(Calendar.MONTH, month);\n+        cal.set(Calendar.DATE, day);\n+\n+        // format matcher\n+        Matcher matcher = parsePattern.matcher(input.substring(pos.getIndex()));\n+\n+        // parse input based on the patterns\n+        for (int i = 0; i < strategies.length; ++i) {\n+            Strategy strategy = strategies[i];\n+            if (!matcher.find()) {\n+                pos.setErrorIndex(pos.getIndex());\n+                return null;\n+            }\n+            int index = matcher.start();\n+            String value = matcher.group();\n+            DateBuilder dateBuilder = strategy.parseInto(this, value, cal);\n+            if (dateBuilder == null) {\n+                pos.setErrorIndex(index);\n+                return null;\n+            }\n+            cal = dateBuilder.buildCalendar(cal);\n+        }\n+\n+        // discard parsed timezone\n+        if (pos.getIndex() < input.length()) {\n+            char nextChar = input.charAt(pos.getIndex());\n+            if (nextChar == 'Z') { // UTC (no offset)\n+                pos.setIndex(pos.getIndex() + 1);\n+            } else if (nextChar == '+' || nextChar == '-') { // offset of the form [+-]hh:mm\n+                pos.setIndex(pos.getIndex() + 3);\n+            }\n+        }\n+\n+        // return parsed date\n+        pos.setIndex(pos.getIndex() + matcher.end());\n+        return cal.getTime();\n+    }\n         if(currentStrategy.addRegex(this, regex)) {\n             collector.add(currentStrategy);\n         }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}