{
    "patch": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            // split into year, month-day, and time\n            Chronology chrono = iChronology;\n            DateTimeField[] fields = chrono.get(partial).getFields();\n            int[] newValues = values.clone();\n            long instant = 0L;\n            int monthIndex = -1;\n            for (int i = 0; i < fields.length; i++) {\n                DurationField unit = fields[i].getDurationField();\n                if (unit == null || !unit.isSupported() || fields[i].isReadOnly()) {\n                    continue;\n                }\n                int newValue = (i == fieldIndex ? fields[i].add(newValues[i], valueToAdd) : newValues[i]);\n                if (newValue != newValues[i]) {\n                    // so there is a change, see if it cascades\n                    // down to month-day\n                    if (i == DateTimeFieldType.monthOfYear().getFieldIndex()\n                            && (DateTimeFieldType.dayOfMonth().getFieldIndex() < fieldIndex\n                            || DateTimeFieldType.monthOfYear().getFieldIndex() > fieldIndex)) {\n                        monthIndex = i;\n                    } else if (i == DateTimeFieldType.year().getFieldIndex()\n                            && DateTimeFieldType.monthOfYear().getFieldIndex() < fieldIndex) {\n                        // this year has changed, so we need to ensure\n                        // the day of month is still valid\n                        try {\n                            Chronology c = ((LimitChronology) chrono).withYear(newValue);\n                            monthIndex = DateTimeFieldType.monthOfYear().getFieldIndex();\n                            newValue = c.monthOfYear().set(newValue, newValues[monthIndex]);\n                            if (newValue < 1) {\n                                newValue = 1;\n                            } else {\n                                int max = c.dayOfMonth().getMaximumValue(newValue);\n                                int cur = c.dayOfMonth().get(newValue);\n                                newValue = (cur < max ? cur : max);\n                            }\n                        } catch (IllegalArgumentException ex) {\n                            // year is out of range\n                            throw new org.joda.time.IllegalFieldValueException(DateTimeFieldType.year(), String.valueOf(newValue));\n                        }\n                    }\n                    newValues[i] = newValue;\n                }\n            }\n            // components are updated, now rebuild instant\n            return iChronology.get(partial, iChronology.getDateTimeMillis(instant, newValues));\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\nindex afca44e6..8d246b1b 100644\n--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -206,14 +206,52 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n         if (valueToAdd == 0) {\n             return values;\n         }\n-            // month is largest field and being added to, such as month-day\n+        // month is largest field and being added to, such as month-day\n         if (DateTimeUtils.isContiguous(partial)) {\n+            // split into year, month-day, and time\n+            Chronology chrono = iChronology;\n+            DateTimeField[] fields = chrono.get(partial).getFields();\n+            int[] newValues = values.clone();\n             long instant = 0L;\n-            for (int i = 0, isize = partial.size(); i < isize; i++) {\n-                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+            int monthIndex = -1;\n+            for (int i = 0; i < fields.length; i++) {\n+                DurationField unit = fields[i].getDurationField();\n+                if (unit == null || !unit.isSupported() || fields[i].isReadOnly()) {\n+                    continue;\n+                }\n+                int newValue = (i == fieldIndex ? fields[i].add(newValues[i], valueToAdd) : newValues[i]);\n+                if (newValue != newValues[i]) {\n+                    // so there is a change, see if it cascades\n+                    // down to month-day\n+                    if (i == DateTimeFieldType.monthOfYear().getFieldIndex()\n+                            && (DateTimeFieldType.dayOfMonth().getFieldIndex() < fieldIndex\n+                            || DateTimeFieldType.monthOfYear().getFieldIndex() > fieldIndex)) {\n+                        monthIndex = i;\n+                    } else if (i == DateTimeFieldType.year().getFieldIndex()\n+                            && DateTimeFieldType.monthOfYear().getFieldIndex() < fieldIndex) {\n+                        // this year has changed, so we need to ensure\n+                        // the day of month is still valid\n+                        try {\n+                            Chronology c = ((LimitChronology) chrono).withYear(newValue);\n+                            monthIndex = DateTimeFieldType.monthOfYear().getFieldIndex();\n+                            newValue = c.monthOfYear().set(newValue, newValues[monthIndex]);\n+                            if (newValue < 1) {\n+                                newValue = 1;\n+                            } else {\n+                                int max = c.dayOfMonth().getMaximumValue(newValue);\n+                                int cur = c.dayOfMonth().get(newValue);\n+                                newValue = (cur < max ? cur : max);\n+                            }\n+                        } catch (IllegalArgumentException ex) {\n+                            // year is out of range\n+                            throw new org.joda.time.IllegalFieldValueException(DateTimeFieldType.year(), String.valueOf(newValue));\n+                        }\n+                    }\n+                    newValues[i] = newValue;\n+                }\n             }\n-            instant = add(instant, valueToAdd);\n-            return iChronology.get(partial, instant);\n+            // components are updated, now rebuild instant\n+            return iChronology.get(partial, iChronology.getDateTimeMillis(instant, newValues));\n         } else {\n             return super.add(partial, fieldIndex, values, valueToAdd);\n         }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}