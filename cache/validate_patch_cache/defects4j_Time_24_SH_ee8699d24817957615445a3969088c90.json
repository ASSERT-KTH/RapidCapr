{
    "patch": "ArrayList<IllegalFieldValueException> exceptions = new ArrayList<>();\nfor (int i = 0; i < count; i++) {\n    try {\n        millis = savedFields[i].set(millis, resetFields);\n    } catch (IllegalFieldValueException e) {\n        // Save the exception since we may be able to validly parse with less fields\n        exceptions.add(e);\n    }\n}\nif (exceptions.isEmpty()) {\n    iSavedFields = savedFields;\n    iSavedFieldsCount = count;\n    iSavedFieldsShared = false;\n} else if (exceptions.size() == count) {\n    if (text != null) {\n        IllegalFieldValueException e = exceptions.get(0);\n        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n        throw e;\n    }\n    throw exceptions.get(0);\n} else {\n    iSavedFields = new SavedField[count - exceptions.size()];\n    int index = 0;\n    for (int i = 0; i < count; i++) {\n        if (savedFields[i].getValue() != null) {\n            iSavedFields[index] = savedFields[i];\n            index++;\n        }\n    }\n    iSavedFieldsCount = index;\n    iSavedFieldsShared = false;\n    // We can parse, but some fields were invalid. Setting saved fields to the correct size\n    // means the caller can access every valid field through the getters. \n    AssertionError ex = new AssertionError(\"Fields could not be parsed with all specified granularities\");\n    for (IllegalFieldValueException illExc : exceptions) {\n        ex.addSuppressed(illExc);\n    }\n    throw ex;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..12612fe1 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,45 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+ArrayList<IllegalFieldValueException> exceptions = new ArrayList<>();\n+for (int i = 0; i < count; i++) {\n+    try {\n+        millis = savedFields[i].set(millis, resetFields);\n+    } catch (IllegalFieldValueException e) {\n+        // Save the exception since we may be able to validly parse with less fields\n+        exceptions.add(e);\n+    }\n+}\n+if (exceptions.isEmpty()) {\n+    iSavedFields = savedFields;\n+    iSavedFieldsCount = count;\n+    iSavedFieldsShared = false;\n+} else if (exceptions.size() == count) {\n+    if (text != null) {\n+        IllegalFieldValueException e = exceptions.get(0);\n+        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+        throw e;\n+    }\n+    throw exceptions.get(0);\n+} else {\n+    iSavedFields = new SavedField[count - exceptions.size()];\n+    int index = 0;\n+    for (int i = 0; i < count; i++) {\n+        if (savedFields[i].getValue() != null) {\n+            iSavedFields[index] = savedFields[i];\n+            index++;\n+        }\n+    }\n+    iSavedFieldsCount = index;\n+    iSavedFieldsShared = false;\n+    // We can parse, but some fields were invalid. Setting saved fields to the correct size\n+    // means the caller can access every valid field through the getters. \n+    AssertionError ex = new AssertionError(\"Fields could not be parsed with all specified granularities\");\n+    for (IllegalFieldValueException illExc : exceptions) {\n+        ex.addSuppressed(illExc);\n+    }\n+    throw ex;\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}