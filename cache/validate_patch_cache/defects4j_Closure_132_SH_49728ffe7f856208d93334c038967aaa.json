{
    "patch": "              // before: if(a.length); after: if(a.length)>0;\n              if (NodeUtil.isNullOrUndefined(lhs2)) {\n                n.removeChild(cond);\n                Node gt = IR.gt(lhs, IR.number(0)).srcref(n);\n                Node newExpr = NodeUtil.newExpr(gt);\n                parent.replaceChild(n, newExpr);\n                reportCodeChange();\n\n                return newExpr;\n              }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..c0340114 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,16 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              // before: if(a.length); after: if(a.length)>0;\n+              if (NodeUtil.isNullOrUndefined(lhs2)) {\n+                n.removeChild(cond);\n+                Node gt = IR.gt(lhs, IR.number(0)).srcref(n);\n+                Node newExpr = NodeUtil.newExpr(gt);\n+                parent.replaceChild(n, newExpr);\n+                reportCodeChange();\n+\n+                return newExpr;\n+              }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}