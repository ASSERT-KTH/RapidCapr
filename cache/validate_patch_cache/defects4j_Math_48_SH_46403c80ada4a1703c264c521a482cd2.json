{
    "patch": "        int maxEval = getMaxEvaluations();\n        double min = getMin();\n        double max = getMax();\n        double initial = getStartValue();\n        if (initial < min || initial > max) {\n            initial = min + 0.5 * (max - min);\n        }\n\n        BracketedUnivariateSolver<F> bracketedSolver = new BrentSolverBuilder()\n                .withAbsoluteAccuracy(getAbsoluteAccuracy())\n                .withMaximalIterationCount(Integer.MAX_VALUE)\n                .withRelativeAccuracy(getRelativeAccuracy())\n                .build();\n\n        UnivariateSolverHelper<F> helper = new UnivariateSolverHelper<>(f);\n        final double functionValueAccuracy = getFunctionValueAccuracy();\n\n        return bracketedSolver.solve(maxEval, helper, min, initial, max,\n                getAllowedSolution(), functionValueAccuracy);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex 8a667dad3..9ffa4c0ef 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -186,6 +186,25 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Detect early that algorithm is stuck, instead of waiting\n                     // for the maximum number of iterations to be exceeded.\n+        int maxEval = getMaxEvaluations();\n+        double min = getMin();\n+        double max = getMax();\n+        double initial = getStartValue();\n+        if (initial < min || initial > max) {\n+            initial = min + 0.5 * (max - min);\n+        }\n+\n+        BracketedUnivariateSolver<F> bracketedSolver = new BrentSolverBuilder()\n+                .withAbsoluteAccuracy(getAbsoluteAccuracy())\n+                .withMaximalIterationCount(Integer.MAX_VALUE)\n+                .withRelativeAccuracy(getRelativeAccuracy())\n+                .build();\n+\n+        UnivariateSolverHelper<F> helper = new UnivariateSolverHelper<>(f);\n+        final double functionValueAccuracy = getFunctionValueAccuracy();\n+\n+        return bracketedSolver.solve(maxEval, helper, min, initial, max,\n+                getAllowedSolution(), functionValueAccuracy);\n                     break;\n                 default:\n                     // Should never happen.",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}