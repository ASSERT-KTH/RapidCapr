{
    "patch": "public static double regularizedGammaP(double a, double x){\n    double epsilon = 10e-15;\n    double big = 4503599627370496.0;\n    double bigInv = 2.22044604925031308085e-16; \n\n    if(a <= 0.0 || x < 0.0){\n        throw new IllegalArgumentException(\"Invalid parameters for regularized gamma function.\");\n    }\n\n    if(x == 0.0){\n        return 0.0;\n    }\n\n    if(x >= a + 1.0){\n        return 1.0 - regularizedGammaQ(a, x);\n    }\n\n    double w = a;\n    double y = x;\n    double z = 1.0;\n    double c = 0.0;\n    double pkm1 = 1.0;\n    double qkm1 = x;\n    double pkm2 = 1.0;\n    double qkm2 = 0.0;\n    double ans = 0.0;\n    boolean converge = false;\n    double lambda = 1.0;\n\n    while(!converge){\n        c += 1.0;\n        double yc = y - c;\n        double pk = pkm1 * yc + pkm2 * w;\n        double qk = qkm1 * yc + qkm2 * w;\n\n        if(qk != 0){\n            double r = pk/qk;\n            double t = Math.abs((ans - r)/r);\n            ans = r;\n\n            if(t < epsilon){\n                converge = true;\n            } else {\n                pkm2 = pkm1;\n                pkm1 = pk;\n                qkm2 = qkm1;\n                qkm1 = qk;\n                if(Math.abs(pk) > big){\n                    pkm2 *= bigInv;\n                    pkm1 *= bigInv;\n                    qkm2 *= bigInv;\n                    qkm1 *= bigInv;\n                }\n                if(Math.abs(qk) > big){\n                    pkm2 *= bigInv;\n                    pkm1 *= bigInv;\n                    qkm2 *= bigInv;\n                    qkm1 *= bigInv;\n                }\n            }\n        } else {\n            pkm2 = pkm1;\n            pkm1 = pk;\n            qkm2 = qkm1;\n            qkm1 = qk;\n            if(Math.abs(pk) > big){\n                pkm2 *= bigInv;\n                pkm1 *= bigInv;\n                qkm2 *= bigInv;\n                qkm1 *= bigInv;\n            }\n            if(Math.abs(qk) > big){\n                pkm2 *= bigInv;\n                pkm1 *= bigInv;\n                qkm2 *= bigInv;\n                qkm1 *= bigInv;\n            }\n        }\n\n        if(Math.abs(pk) > big){\n            pkm2 *= bigInv;\n            pkm1 *= bigInv;\n            qkm2 *= bigInv;\n            qkm1 *= bigInv;\n        }\n        if(Math.abs(qk) > big){\n            pkm2 *= bigInv;\n            pkm1 *= bigInv;\n            qkm2 *= bigInv;\n            qkm1 *= bigInv;\n        }\n\n        if(Math.max(Math.abs(pk), Math.abs(qk)) > 10e20){\n            pkm2 *= 10e-20;\n            pkm1 *= 10e-20;\n            qkm2 *= 10e-20;\n            qkm1 *= 10e-20;\n        }\n\n        if(c == lambda){\n            double g = pkm1/qkm1;\n            lambda += 1;\n            w += 1;\n            z *= y;\n\n            if(z == 0){\n                return ans;\n            } else {\n                pkm2 = pkm2 * y + g*z;\n                pkm1 = pkm1 * y + g*w*pkm2;\n                qkm2 = qkm2 * y + g*z*qkm1;\n                qkm1 = qkm1 * y + g*w*qkm2;\n\n                pkm2 = pkm2 * bigInv;\n                pkm1 = pkm1 * bigInv;\n                qkm2 = qkm2 * bigInv;\n                qkm1 = qkm1 * bigInv;\n            }\n        }\n\n    }\n\n    return ans;\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..adf1a94d9 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,130 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x){\n+    double epsilon = 10e-15;\n+    double big = 4503599627370496.0;\n+    double bigInv = 2.22044604925031308085e-16; \n+\n+    if(a <= 0.0 || x < 0.0){\n+        throw new IllegalArgumentException(\"Invalid parameters for regularized gamma function.\");\n+    }\n+\n+    if(x == 0.0){\n+        return 0.0;\n+    }\n+\n+    if(x >= a + 1.0){\n+        return 1.0 - regularizedGammaQ(a, x);\n+    }\n+\n+    double w = a;\n+    double y = x;\n+    double z = 1.0;\n+    double c = 0.0;\n+    double pkm1 = 1.0;\n+    double qkm1 = x;\n+    double pkm2 = 1.0;\n+    double qkm2 = 0.0;\n+    double ans = 0.0;\n+    boolean converge = false;\n+    double lambda = 1.0;\n+\n+    while(!converge){\n+        c += 1.0;\n+        double yc = y - c;\n+        double pk = pkm1 * yc + pkm2 * w;\n+        double qk = qkm1 * yc + qkm2 * w;\n+\n+        if(qk != 0){\n+            double r = pk/qk;\n+            double t = Math.abs((ans - r)/r);\n+            ans = r;\n+\n+            if(t < epsilon){\n+                converge = true;\n+            } else {\n+                pkm2 = pkm1;\n+                pkm1 = pk;\n+                qkm2 = qkm1;\n+                qkm1 = qk;\n+                if(Math.abs(pk) > big){\n+                    pkm2 *= bigInv;\n+                    pkm1 *= bigInv;\n+                    qkm2 *= bigInv;\n+                    qkm1 *= bigInv;\n+                }\n+                if(Math.abs(qk) > big){\n+                    pkm2 *= bigInv;\n+                    pkm1 *= bigInv;\n+                    qkm2 *= bigInv;\n+                    qkm1 *= bigInv;\n+                }\n+            }\n+        } else {\n+            pkm2 = pkm1;\n+            pkm1 = pk;\n+            qkm2 = qkm1;\n+            qkm1 = qk;\n+            if(Math.abs(pk) > big){\n+                pkm2 *= bigInv;\n+                pkm1 *= bigInv;\n+                qkm2 *= bigInv;\n+                qkm1 *= bigInv;\n+            }\n+            if(Math.abs(qk) > big){\n+                pkm2 *= bigInv;\n+                pkm1 *= bigInv;\n+                qkm2 *= bigInv;\n+                qkm1 *= bigInv;\n+            }\n+        }\n+\n+        if(Math.abs(pk) > big){\n+            pkm2 *= bigInv;\n+            pkm1 *= bigInv;\n+            qkm2 *= bigInv;\n+            qkm1 *= bigInv;\n+        }\n+        if(Math.abs(qk) > big){\n+            pkm2 *= bigInv;\n+            pkm1 *= bigInv;\n+            qkm2 *= bigInv;\n+            qkm1 *= bigInv;\n+        }\n+\n+        if(Math.max(Math.abs(pk), Math.abs(qk)) > 10e20){\n+            pkm2 *= 10e-20;\n+            pkm1 *= 10e-20;\n+            qkm2 *= 10e-20;\n+            qkm1 *= 10e-20;\n+        }\n+\n+        if(c == lambda){\n+            double g = pkm1/qkm1;\n+            lambda += 1;\n+            w += 1;\n+            z *= y;\n+\n+            if(z == 0){\n+                return ans;\n+            } else {\n+                pkm2 = pkm2 * y + g*z;\n+                pkm1 = pkm1 * y + g*w*pkm2;\n+                qkm2 = qkm2 * y + g*z*qkm1;\n+                qkm1 = qkm1 * y + g*w*qkm2;\n+\n+                pkm2 = pkm2 * bigInv;\n+                pkm1 = pkm1 * bigInv;\n+                qkm2 = qkm2 * bigInv;\n+                qkm1 = qkm1 * bigInv;\n+            }\n+        }\n+\n+    }\n+\n+    return ans;\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}