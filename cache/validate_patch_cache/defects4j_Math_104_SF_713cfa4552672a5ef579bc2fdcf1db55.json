{
    "patch": "public static double regularizedGamma(double a, double x) {\n    if (a <= 0.0 || x < 0.0) {\n        throw new IllegalArgumentException(\"Invalid arguments for gamma function.\");\n    }\n    if (x == 0.0) {\n        return 0.0;\n    }\n    if (x >= 1 + a) {\n        // Asymptotic expansion for x >= a + 1.\n        return 1.0 - regularizedGammaComplement(a, x);\n    }\n\n    // Series expansion for small a and x.\n    double g = 0.0;\n    double ap = a;\n    double del = 1.0 / a;\n    double sum = del;\n    while (Math.abs(del) > Math.abs(sum) * DEFAULT_EPSILON && ap < MAX_ITERATIONS) {\n        ++ap;\n        del *= x / ap;\n        sum += del;\n    }\n    g = sum * Math.exp(-x + a * Math.log(x) - logGamma(a));\n    return g;\n}\n\npublic static double regularizedGammaComplement(double a, double x) {\n    if (a <= 0.0 || x < 0.0) {\n        throw new IllegalArgumentException(\"Invalid arguments for gamma function.\");\n    }\n    if (x == 0.0) {\n        return 1.0;\n    }\n    if (x < a + 1.0) {\n        // Use the series representation of the complement.\n        return 1.0 - regularizedGamma(a, x);\n    }\n\n    // Continued fraction representation of the complement.\n    double[] d = new double[MAX_ITERATIONS + 2];\n    double[] c = new double[MAX_ITERATIONS + 2];\n\n    d[1] = 1.0 + x - a;\n    c[1] = 1.0 / d[1];\n    double delta = c[1];\n    int i = 1;\n    while (i <= MAX_ITERATIONS && Math.abs(delta) > Math.abs(c[i]) * DEFAULT_EPSILON) {\n        ++i;\n        double a1 = 2 * i - 1 + x - a;\n        double a2 = i * (a - i);\n        d[i] = a1 * d[i - 1] - a2 * d[i - 2];\n        c[i] = a1 * c[i - 1] - a2 * c[i - 2];\n        if (Math.abs(d[i]) < Double.MIN_VALUE) {\n            d[i] = Double.MIN_VALUE;\n        }\n        delta = c[i] / d[i];\n    }\n    double g = 1.0 - Math.exp(-x + a * Math.log(x) - logGamma(a)) * delta;\n    return g;\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..385075282 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,66 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGamma(double a, double x) {\n+    if (a <= 0.0 || x < 0.0) {\n+        throw new IllegalArgumentException(\"Invalid arguments for gamma function.\");\n+    }\n+    if (x == 0.0) {\n+        return 0.0;\n+    }\n+    if (x >= 1 + a) {\n+        // Asymptotic expansion for x >= a + 1.\n+        return 1.0 - regularizedGammaComplement(a, x);\n+    }\n+\n+    // Series expansion for small a and x.\n+    double g = 0.0;\n+    double ap = a;\n+    double del = 1.0 / a;\n+    double sum = del;\n+    while (Math.abs(del) > Math.abs(sum) * DEFAULT_EPSILON && ap < MAX_ITERATIONS) {\n+        ++ap;\n+        del *= x / ap;\n+        sum += del;\n+    }\n+    g = sum * Math.exp(-x + a * Math.log(x) - logGamma(a));\n+    return g;\n+}\n+\n+public static double regularizedGammaComplement(double a, double x) {\n+    if (a <= 0.0 || x < 0.0) {\n+        throw new IllegalArgumentException(\"Invalid arguments for gamma function.\");\n+    }\n+    if (x == 0.0) {\n+        return 1.0;\n+    }\n+    if (x < a + 1.0) {\n+        // Use the series representation of the complement.\n+        return 1.0 - regularizedGamma(a, x);\n+    }\n+\n+    // Continued fraction representation of the complement.\n+    double[] d = new double[MAX_ITERATIONS + 2];\n+    double[] c = new double[MAX_ITERATIONS + 2];\n+\n+    d[1] = 1.0 + x - a;\n+    c[1] = 1.0 / d[1];\n+    double delta = c[1];\n+    int i = 1;\n+    while (i <= MAX_ITERATIONS && Math.abs(delta) > Math.abs(c[i]) * DEFAULT_EPSILON) {\n+        ++i;\n+        double a1 = 2 * i - 1 + x - a;\n+        double a2 = i * (a - i);\n+        d[i] = a1 * d[i - 1] - a2 * d[i - 2];\n+        c[i] = a1 * c[i - 1] - a2 * c[i - 2];\n+        if (Math.abs(d[i]) < Double.MIN_VALUE) {\n+            d[i] = Double.MIN_VALUE;\n+        }\n+        delta = c[i] / d[i];\n+    }\n+    double g = 1.0 - Math.exp(-x + a * Math.log(x) - logGamma(a)) * delta;\n+    return g;\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}