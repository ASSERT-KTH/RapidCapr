{
    "patch": "      // Don't traverse functions that are getting lent to a prototype.\n      if (isLeftSideOfAssignmentToPrototype(parent)) {\n        return false;\n      }\n    }\n\n    if (isRightSideOfDirectPrototypeMutation(parent)) {\n      // Don't traverse the right side of a direct assignment to a prototype property,\n      // as those are commonly used to add methods to prototype which should not\n      // be processed.\n      return false;\n    }\n\n    return true;\n  }\n\n  private static boolean isLeftSideOfAssignmentToPrototype(Node parent) {\n    if (parent == null || parent.getType() != Token.ASSIGN) {\n      return false;\n    }\n    Node lhs = parent.getFirstChild();\n    if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n      return true;\n    }\n    Node llhs = lhs.getFirstChild();\n    if (llhs != null && llhs.getType() == Token.GETPROP &&\n        llhs.getLastChild().getString().equals(\"prototype\") &&\n        NodeUtil.isObjectLitKey(lhs)) {\n      // It is a left side of assignment to prototype property, e.g.\n      // var a = {prop: 0};\n      return true;\n    }\n    return false;\n  }\n\n  private static boolean isRightSideOfDirectPrototypeMutation(Node parent) {\n    return parent != null && NodeUtil.isPrototypeMutation(parent);\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..b5e87502 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,44 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      // Don't traverse functions that are getting lent to a prototype.\n+      if (isLeftSideOfAssignmentToPrototype(parent)) {\n+        return false;\n+      }\n+    }\n+\n+    if (isRightSideOfDirectPrototypeMutation(parent)) {\n+      // Don't traverse the right side of a direct assignment to a prototype property,\n+      // as those are commonly used to add methods to prototype which should not\n+      // be processed.\n+      return false;\n+    }\n+\n+    return true;\n+  }\n+\n+  private static boolean isLeftSideOfAssignmentToPrototype(Node parent) {\n+    if (parent == null || parent.getType() != Token.ASSIGN) {\n+      return false;\n+    }\n+    Node lhs = parent.getFirstChild();\n+    if (lhs.getType() == Token.GETPROP && lhs.getLastChild().getString().equals(\"prototype\")) {\n+      return true;\n+    }\n+    Node llhs = lhs.getFirstChild();\n+    if (llhs != null && llhs.getType() == Token.GETPROP &&\n+        llhs.getLastChild().getString().equals(\"prototype\") &&\n+        NodeUtil.isObjectLitKey(lhs)) {\n+      // It is a left side of assignment to prototype property, e.g.\n+      // var a = {prop: 0};\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isRightSideOfDirectPrototypeMutation(Node parent) {\n+    return parent != null && NodeUtil.isPrototypeMutation(parent);\n+  }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}