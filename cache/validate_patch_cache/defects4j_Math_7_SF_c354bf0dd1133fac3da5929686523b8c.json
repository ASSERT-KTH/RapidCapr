{
    "patch": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.List;\n\nimport org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\nimport org.apache.commons.math3.ode.AbstractParameterizable;\nimport org.apache.commons.math3.ode.EquationsMapper;\nimport org.apache.commons.math3.ode.event.Action;\nimport org.apache.commons.math3.ode.event.ActionMultiplexer;\nimport org.apache.commons.math3.ode.event.EventState;\nimport org.apache.commons.math3.ode.event.EventHandler;\nimport org.apache.commons.math3.ode.event.EventStateComparator;\nimport org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;\nimport org.apache.commons.math3.ode.sampling.StepHandler;\n\nimport org.orekit.errors.OrekitException;\nimport org.orekit.propagation.SpacecraftState;\nimport org.orekit.propagation.numerical.NumericalPropagator;\nimport org.orekit.utils.ParameterDriver;\n\npublic class NumericalPropagatorWithEventDetection {\n\n    private static class StepNormalizer implements StepHandler {\n\n        /** Last sign. */\n        private double lastSign;\n\n        /** Last time. */\n        private double lastTime;\n\n        /** Slope of g at the beginning of the step. */\n        private double slopeStart;\n\n        /** Slope of g at the end of the step. */\n        private double slopeEnd;\n\n        /** Target time. */\n        private double tEnd;\n\n        /** Integrator. */\n        private final DormandPrince853Integrator integrator;\n\n        /** Integrator stopper. */\n        private final IntegratorStopper stopper;\n\n        /** Underlying step handler. */\n        private final StepHandler handler;\n\n        /** Mapper between raw and processed states. */\n        private final EquationsMapper mapper;\n\n        /** Simple constructor.\n         * @param tEnd target time for the propagation\n         * @param handler handler for the normalized steps\n         * @param reference reference time (the step size of the integrator may not match\n         * the step size of the users' application).\n         * @param maxCheck maximum time interval between events occurrences\n         * @param dP driver parameters for Jacobian matrices manipulations\n         */\n        public StepNormalizer(final double tEnd, final StepHandler handler, final double reference,\n                              final double maxCheck, final Collection<ParameterDriver> dP) {\n            this.lastSign   = Double.NaN;\n            this.lastTime   = Double.NaN;\n            this.tEnd       = tEnd;\n            this.integrator = new DormandPrince853Integrator(reference, reference + 1.0, 1.0e-12, 1.0e12);\n            this.stopper    = new IntegratorStopper(maxCheck, 1.0e-6);\n            this.handler    = handler;\n            this.mapper     = new IdentityMapper(handler.getStateDimension(), dP);\n        }\n\n        /** {@inheritDoc} */\n        public void init(final SpacecraftState s0, final double t) {\n            integrator.integrate(s0, t);\n            lastSign   = integrator.isForward() ? -1.0 : 1.0;\n            lastTime   = integrator.getCurrentTime();\n            slopeStart = computeG(integrator.getInterpolatedState()).getPartialDerivative(1);\n        }\n\n        /** {@inheritDoc} */\n        public void handleStep(final SpacecraftState currentState, final boolean isLast)\n            throws OrekitException {\n            // EquationsMapper holds onto the raw unprocessed 6 x n state array\n            final double[] y = mapper.mapState(currentState);\n            final DerivativeStructure[] derivatives = computeG(y);\n            slopeEnd = derivatives[1].getReal();\n            if (slopeStart * slopeEnd < 0) {\n                // there is a sign change: an event is expected during the step\n                Action action = stopper.eventOccurred(lastSign, lastTime, currentState);\n                while (action == Action.STOP) {\n                    // rejected step, step size need to be shortened\n                    integrator.setEndTime(lastTime + 0.5 * integrator.getCurrentStepSize());\n                    integrator.integrate(currentState, tEnd);\n                    this.lastSign = Double.NaN;\n                    action = stopper.eventOccurred(lastSign, lastTime, currentState);\n                }\n                if (action == Action.RESET_STATE) {\n                    currentState.resetEventsStates();\n                }\n                // handle event\n                handler.handleStep(currentState, false);\n                // integrator may have called several ones at its end\n                // take the last event time as the next starting time guess\n                if (integrator.getCurrentTime() < tEnd) {\n                    lastTime = integrator.getCurrentTime();\n                    integrator.setInterpolatedTime(lastTime);\n                } else {\n                    lastTime = tEnd;\n                }\n                slopeStart = derivatives[1].getReal();\n            }\n            if (! isLast) {\n                integrator.integrate(currentState, tEnd);\n                if (integrator.isLastStep()) {\n                    // integrator did overshoot, we back up to the target time\n                    integrator.setInterpolatedTime(tEnd);\n                }\n                this.lastSign = integrator.isForward() ? -1.0 : 1.0;\n                lastTime = integrator.getCurrentTime();\n                slopeStart = slopeEnd;\n            }\n        }\n\n        /** {@inheritDoc} */\n        public boolean requiresDenseOutput() {\n            return handler.requiresDenseOutput();\n        }\n\n        /** Compute g function value and derivative.\n         * @param state state\n         * @return array containing g function value at index 0 and its derivative at index 1\n         * @throws OrekitException if function cannot be computed\n         */\n        private DerivativeStructure[] computeG(final double[] state)\n            throws OrekitException {\n            final DerivativeStructure[] yDS = new DerivativeStructure[state.length];\n            for (int i = 0; i < yDS.length; ++i) {\n                yDS[i] = new DerivativeStructure(1, 1, state[i]);\n            }\n            final DerivativeStructure gDS = g.evaluate(0.0, yDS);\n            return new DerivativeStructure[] {\n                gDS,\n                gDS.getPartialDerivative(1)\n            };\n        }\n    }\n\n    private static class IntegratorStopper extends AbstractParameterizable {\n\n        /** Maximum time between events. */\n        private final double maxCheck;\n\n        /** Maximum time to wait before declaring end of propagation. */\n        private final double maxIter;\n\n        /** Last event time. */\n        private double lastEventTime;\n\n        /** Count of consecutive iterations without event. */\n        private int count;\n\n        /** Simple constructor.\n         * @param maxCheck maximum time interval between events occurrences\n         * @param maxIter maximum iterations without events occurrences\n         */\n        public IntegratorStopper(final double maxCheck, final double maxIter) {\n            this.maxCheck        = maxCheck;\n            this.maxIter         = maxIter;\n            this.lastEventTime   = Double.NaN;\n            this.count           = 0;\n        }\n\n        /** {@inheritDoc} */\n        public Action eventOccurred(final SpacecraftState s, final boolean increasing)\n            throws OrekitException {\n            final double t = s.getDate().durationFrom(s0.getDate());\n            if (Double.isNaN(lastEventTime)) {\n                lastEventTime = t;\n            } else if (t - lastEventTime < maxCheck) {\n                ++count;\n                if (count >= maxIter) {\n                    return Action.STOP;\n                }\n            } else {\n                lastEventTime = t;\n                count         = 0;\n            }\n            // delegate the real action to the underlying handler\n            final int n                   = eventsStates.size();\n            final EventState[] statesArray = eventsStates.toArray(new EventState[n]);\n            for (int i = 0; i < n; ++i) {\n                statesArray[i].eventOccurred(s, increasing);\n            }\n            return Action.RESET_STATE;\n        }\n\n        /** {@inheritDoc} */\n        public SpacecraftState reset(final SpacecraftState s) throws OrekitException {\n            lastEventTime = Double.NaN;\n            count         = 0;\n            return s;\n        }\n\n    }\n\n    private static class IdentityMapper implements EquationsMapper {\n\n        /** Dimension of the state. */\n        private final int dimension;\n\n        /** Driver parameters for Jacobian matrices manipulations. */\n        private final Collection<ParameterDriver> drivers;\n\n        /**\n         * Initializes a new instance\n         * @param dimension dimension of the state\n         * @param drivers parameters drivers for Jacobians manipulation\n         */\n        public IdentityMapper(final int dimension, final Collection<ParameterDriver> drivers) {\n            this.dimension = dimension;\n            this.drivers   = new ArrayList<ParameterDriver>(drivers);\n        }\n\n        /** {@inheritDoc} */\n        public double[] mapState(final SpacecraftState state) {\n            final double[] mappedState = new double[dimension];\n            state.getOrbit().getType().mapOrbitToArray(state.getOrbit(), PositionAngle.TRUE,\n                                                        mappedState, null);\n            int index = orbitType.getAttitudeProvider().getParameters().length;\n            for (final ParameterDriver driver : drivers) {\n                driver.setValue(driver.getReferenceValue());\n                driver.setSelected(true);\n                mappedState[index++] = driver.getValue();\n            }\n            return mappedState;\n        }\n\n        /** {@inheritDoc} */\n        public void mapStateDerivative(final SpacecraftState state, final double[] y, final double[] yDot) {\n            final double[] originalY = new double[dimension];\n            final double[] yTmp      = new double[y.length];\n            System.arraycopy(y, 0, yTmp, 0, y.length);\n            for (final ParameterDriver driver : drivers) {\n                driver.setSelected(true);\n            }\n            orbitType.mapArrayToOrbit(yTmp, PositionAngle.TRUE, originalY, null);\n            final double[][] jacobian = orbitType.mapOrbitToArrayDerivative(originalY, PositionAngle.TRUE);\n            for (final ParameterDriver driver : drivers) {\n                driver.setSelected(false);\n                final double[] driverDerivatives = driver.getSelectedDerivatives(jacobian);\n                for (int i = 0; i < driverDerivatives.length; ++i) {\n                    yDot[i] += driverDerivatives[i];\n                }\n            }\n            System.arraycopy(yTmp, orbitType.getStateDimension(), yDot, orbitType.getStateDimension(), drivers.size());\n        }\n\n    }\n\n    private final NumericalPropagator realPropagator;\n    private final List<EventDetector> eventsDetectors;\n    private final List<EventState> eventsStates;\n\n    public NumericalPropagatorWithEventDetection(NumericalPropagator realPropagator, List<EventDetector> eventsDetectors) {\n        this.realPropagator = realPropagator;\n        this.eventsDetectors = eventsDetectors;\n\n        eventsStates = new ArrayList<EventState>(eventsDetectors.size());\n        for (EventDetector detector : eventsDetectors) {\n            eventsStates.add(detector.getEventState());\n        }\n    }\n\n    public SpacecraftState propagate(SpacecraftState initialState, final AbsoluteDate finalDate) throws OrekitException {\n\n        initialState = realPropagator.getInitialState()\n                                     .addAdditionalState(\"g\", 0.0, 1.0e-12);\n        for (final EventDetector detector : eventsDetectors) {\n            realPropagator.addEventDetector(detector);\n        }\n        realPropagator.setInitialState(initialState);\n        realPropagator.setOrbitType(null);\n        final double tMin = initialState.getDate().durationFrom(initialState.shiftedBy(60.0));\n        doEvents(realPropagator.getInitialState(), eventsDetectors);\n\n        SpacecraftState finalState = initialState;\n        if ((finalDate.durationFrom(initialState.getDate()) > 0.) && realPropagator.getInitialState() != null) {\n            finalState = realPropagator.propagate(finalDate).addAdditionalState(\"g\", 0.0, 1.0e-12);\n        }\n\n        return finalState;\n    }\n\n    /**\n     * Get the propagator.\n     *\n     * @return the propagator.\n     */\n    public NumericalPropagator getPropagator() {\n        return realPropagator;\n    }\n\n    /**\n     * Do the events.\n     *\n     * @param <T> the type of events detectors\n     * @param s0 the initial state\n     * @param detectors the detectors\n     * @throws OrekitException if an Orekit exception occurs\n     */\n    public <T extends EventDetector> void doEvents(final SpacecraftState s0,\n                                                  final Collection<T> detectors) throws OrekitException {\n        final EventHandler<T> handler = new EventHandler<T>(detectors);\n        handler.init(s0, s0.getDate().durationFrom(s0.shiftedBy(60.0)));\n        final double tEnd = handler.getEventTime();\n        StepNormalizer stepNormalizer = new StepNormalizer(tEnd, new FixedStepHandler() {\n            public void init(SpacecraftState s0, double t) throws OrekitException {\n                handler.setInterpolated(s0);\n            }\n\n            public void handleStep(SpacecraftState currentState, boolean isLast) throws OrekitException {\n                if (handler.evaluateStep(currentState)) {\n                    handler.eventOccurred(currentState, isLast);\n                }\n            }\n        }, s0.getFrame(), 0.1, realPropagator.getDrivers());\n        final double maxCheckInterval = handler.getMaxCheckInterval();\n        if (maxCheckInterval < tEnd - s0.getDate().durationFrom(s0)) {\n            // the last switch time would be outside of the tolerance interval,\n            // we will shorten the last step a little bit to make it fit\n            final double epsilon = 1.0e-10 * (tEnd - s0.getDate().durationFrom(s0));\n            StepNormalizer truncatedStepNormalizer ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..91886ec1f 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,337 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.List;\n+\n+import org.apache.commons.math3.analysis.differentiation.DerivativeStructure;\n+import org.apache.commons.math3.ode.AbstractParameterizable;\n+import org.apache.commons.math3.ode.EquationsMapper;\n+import org.apache.commons.math3.ode.event.Action;\n+import org.apache.commons.math3.ode.event.ActionMultiplexer;\n+import org.apache.commons.math3.ode.event.EventState;\n+import org.apache.commons.math3.ode.event.EventHandler;\n+import org.apache.commons.math3.ode.event.EventStateComparator;\n+import org.apache.commons.math3.ode.nonstiff.DormandPrince853Integrator;\n+import org.apache.commons.math3.ode.sampling.StepHandler;\n+\n+import org.orekit.errors.OrekitException;\n+import org.orekit.propagation.SpacecraftState;\n+import org.orekit.propagation.numerical.NumericalPropagator;\n+import org.orekit.utils.ParameterDriver;\n+\n+public class NumericalPropagatorWithEventDetection {\n+\n+    private static class StepNormalizer implements StepHandler {\n+\n+        /** Last sign. */\n+        private double lastSign;\n+\n+        /** Last time. */\n+        private double lastTime;\n+\n+        /** Slope of g at the beginning of the step. */\n+        private double slopeStart;\n+\n+        /** Slope of g at the end of the step. */\n+        private double slopeEnd;\n+\n+        /** Target time. */\n+        private double tEnd;\n+\n+        /** Integrator. */\n+        private final DormandPrince853Integrator integrator;\n+\n+        /** Integrator stopper. */\n+        private final IntegratorStopper stopper;\n+\n+        /** Underlying step handler. */\n+        private final StepHandler handler;\n+\n+        /** Mapper between raw and processed states. */\n+        private final EquationsMapper mapper;\n+\n+        /** Simple constructor.\n+         * @param tEnd target time for the propagation\n+         * @param handler handler for the normalized steps\n+         * @param reference reference time (the step size of the integrator may not match\n+         * the step size of the users' application).\n+         * @param maxCheck maximum time interval between events occurrences\n+         * @param dP driver parameters for Jacobian matrices manipulations\n+         */\n+        public StepNormalizer(final double tEnd, final StepHandler handler, final double reference,\n+                              final double maxCheck, final Collection<ParameterDriver> dP) {\n+            this.lastSign   = Double.NaN;\n+            this.lastTime   = Double.NaN;\n+            this.tEnd       = tEnd;\n+            this.integrator = new DormandPrince853Integrator(reference, reference + 1.0, 1.0e-12, 1.0e12);\n+            this.stopper    = new IntegratorStopper(maxCheck, 1.0e-6);\n+            this.handler    = handler;\n+            this.mapper     = new IdentityMapper(handler.getStateDimension(), dP);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void init(final SpacecraftState s0, final double t) {\n+            integrator.integrate(s0, t);\n+            lastSign   = integrator.isForward() ? -1.0 : 1.0;\n+            lastTime   = integrator.getCurrentTime();\n+            slopeStart = computeG(integrator.getInterpolatedState()).getPartialDerivative(1);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void handleStep(final SpacecraftState currentState, final boolean isLast)\n+            throws OrekitException {\n+            // EquationsMapper holds onto the raw unprocessed 6 x n state array\n+            final double[] y = mapper.mapState(currentState);\n+            final DerivativeStructure[] derivatives = computeG(y);\n+            slopeEnd = derivatives[1].getReal();\n+            if (slopeStart * slopeEnd < 0) {\n+                // there is a sign change: an event is expected during the step\n+                Action action = stopper.eventOccurred(lastSign, lastTime, currentState);\n+                while (action == Action.STOP) {\n+                    // rejected step, step size need to be shortened\n+                    integrator.setEndTime(lastTime + 0.5 * integrator.getCurrentStepSize());\n+                    integrator.integrate(currentState, tEnd);\n+                    this.lastSign = Double.NaN;\n+                    action = stopper.eventOccurred(lastSign, lastTime, currentState);\n+                }\n+                if (action == Action.RESET_STATE) {\n+                    currentState.resetEventsStates();\n+                }\n+                // handle event\n+                handler.handleStep(currentState, false);\n+                // integrator may have called several ones at its end\n+                // take the last event time as the next starting time guess\n+                if (integrator.getCurrentTime() < tEnd) {\n+                    lastTime = integrator.getCurrentTime();\n+                    integrator.setInterpolatedTime(lastTime);\n+                } else {\n+                    lastTime = tEnd;\n                 }\n+                slopeStart = derivatives[1].getReal();\n+            }\n+            if (! isLast) {\n+                integrator.integrate(currentState, tEnd);\n+                if (integrator.isLastStep()) {\n+                    // integrator did overshoot, we back up to the target time\n+                    integrator.setInterpolatedTime(tEnd);\n+                }\n+                this.lastSign = integrator.isForward() ? -1.0 : 1.0;\n+                lastTime = integrator.getCurrentTime();\n+                slopeStart = slopeEnd;\n+            }\n+        }\n \n-            });\n+        /** {@inheritDoc} */\n+        public boolean requiresDenseOutput() {\n+            return handler.requiresDenseOutput();\n+        }\n \n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n+        /** Compute g function value and derivative.\n+         * @param state state\n+         * @return array containing g function value at index 0 and its derivative at index 1\n+         * @throws OrekitException if function cannot be computed\n+         */\n+        private DerivativeStructure[] computeG(final double[] state)\n+            throws OrekitException {\n+            final DerivativeStructure[] yDS = new DerivativeStructure[state.length];\n+            for (int i = 0; i < yDS.length; ++i) {\n+                yDS[i] = new DerivativeStructure(1, 1, state[i]);\n+            }\n+            final DerivativeStructure gDS = g.evaluate(0.0, yDS);\n+            return new DerivativeStructure[] {\n+                gDS,\n+                gDS.getPartialDerivative(1)\n+            };\n+        }\n+    }\n+\n+    private static class IntegratorStopper extends AbstractParameterizable {\n+\n+        /** Maximum time between events. */\n+        private final double maxCheck;\n+\n+        /** Maximum time to wait before declaring end of propagation. */\n+        private final double maxIter;\n+\n+        /** Last event time. */\n+        private double lastEventTime;\n+\n+        /** Count of consecutive iterations without event. */\n+        private int count;\n+\n+        /** Simple constructor.\n+         * @param maxCheck maximum time interval between events occurrences\n+         * @param maxIter maximum iterations without events occurrences\n+         */\n+        public IntegratorStopper(final double maxCheck, final double maxIter) {\n+            this.maxCheck        = maxCheck;\n+            this.maxIter         = maxIter;\n+            this.lastEventTime   = Double.NaN;\n+            this.count           = 0;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public Action eventOccurred(final SpacecraftState s, final boolean increasing)\n+            throws OrekitException {\n+            final double t = s.getDate().durationFrom(s0.getDate());\n+            if (Double.isNaN(lastEventTime)) {\n+                lastEventTime = t;\n+            } else if (t - lastEventTime < maxCheck) {\n+                ++count;\n+                if (count >= maxIter) {\n+                    return Action.STOP;\n+                }\n+            } else {\n+                lastEventTime = t;\n+                count         = 0;\n+            }\n+            // delegate the real action to the underlying handler\n+            final int n                   = eventsStates.size();\n+            final EventState[] statesArray = eventsStates.toArray(new EventState[n]);\n+            for (int i = 0; i < n; ++i) {\n+                statesArray[i].eventOccurred(s, increasing);\n+            }\n+            return Action.RESET_STATE;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public SpacecraftState reset(final SpacecraftState s) throws OrekitException {\n+            lastEventTime = Double.NaN;\n+            count         = 0;\n+            return s;\n+        }\n+\n+    }\n+\n+    private static class IdentityMapper implements EquationsMapper {\n+\n+        /** Dimension of the state. */\n+        private final int dimension;\n+\n+        /** Driver parameters for Jacobian matrices manipulations. */\n+        private final Collection<ParameterDriver> drivers;\n+\n+        /**\n+         * Initializes a new instance\n+         * @param dimension dimension of the state\n+         * @param drivers parameters drivers for Jacobians manipulation\n+         */\n+        public IdentityMapper(final int dimension, final Collection<ParameterDriver> drivers) {\n+            this.dimension = dimension;\n+            this.drivers   = new ArrayList<ParameterDriver>(drivers);\n+        }\n+\n+        /** {@inheritDoc} */\n+        public double[] mapState(final SpacecraftState state) {\n+            final double[] mappedState = new double[dimension];\n+            state.getOrbit().getType().mapOrbitToArray(state.getOrbit(), PositionAngle.TRUE,\n+                                                        mappedState, null);\n+            int index = orbitType.getAttitudeProvider().getParameters().length;\n+            for (final ParameterDriver driver : drivers) {\n+                driver.setValue(driver.getReferenceValue());\n+                driver.setSelected(true);\n+                mappedState[index++] = driver.getValue();\n+            }\n+            return mappedState;\n+        }\n+\n+        /** {@inheritDoc} */\n+        public void mapStateDerivative(final SpacecraftState state, final double[] y, final double[] yDot) {\n+            final double[] originalY = new double[dimension];\n+            final double[] yTmp      = new double[y.length];\n+            System.arraycopy(y, 0, yTmp, 0, y.length);\n+            for (final ParameterDriver driver : drivers) {\n+                driver.setSelected(true);\n+            }\n+            orbitType.mapArrayToOrbit(yTmp, PositionAngle.TRUE, originalY, null);\n+            final double[][] jacobian = orbitType.mapOrbitToArrayDerivative(originalY, PositionAngle.TRUE);\n+            for (final ParameterDriver driver : drivers) {\n+                driver.setSelected(false);\n+                final double[] driverDerivatives = driver.getSelectedDerivatives(jacobian);\n+                for (int i = 0; i < driverDerivatives.length; ++i) {\n+                    yDot[i] += driverDerivatives[i];\n                 }\n             }\n+            System.arraycopy(yTmp, orbitType.getStateDimension(), yDot, orbitType.getStateDimension(), drivers.size());\n+        }\n+\n+    }\n \n-            while (!occuringEvents.isEmpty()) {\n+    private final NumericalPropagator realPropagator;\n+    private final List<EventDetector> eventsDetectors;\n+    private final List<EventState> eventsStates;\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+    public NumericalPropagatorWithEventDetection(NumericalPropagator realPropagator, List<EventDetector> eventsDetectors) {\n+        this.realPropagator = realPropagator;\n+        this.eventsDetectors = eventsDetectors;\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+        eventsStates = new ArrayList<EventState>(eventsDetectors.size());\n+        for (EventDetector detector : eventsDetectors) {\n+            eventsStates.add(detector.getEventState());\n+        }\n+    }\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+    public SpacecraftState propagate(SpacecraftState initialState, final AbsoluteDate finalDate) throws OrekitException {\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+        initialState = realPropagator.getInitialState()\n+                                     .addAdditionalState(\"g\", 0.0, 1.0e-12);\n+        for (final EventDetector detector : eventsDetectors) {\n+            realPropagator.addEventDetector(detector);\n+        }\n+        realPropagator.setInitialState(initialState);\n+        realPropagator.setOrbitType(null);\n+        final double tMin = initialState.getDate().durationFrom(initialState.shiftedBy(60.0));\n+        doEvents(realPropagator.getInitialState(), eventsDetectors);\n+\n+        SpacecraftState finalState = initialState;\n+        if ((finalDate.durationFrom(initialState.getDate()) > 0.) && realPropagator.getInitialState() != null) {\n+            finalState = realPropagator.propagate(finalDate).addAdditionalState(\"g\", 0.0, 1.0e-12);\n+        }\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+        return finalState;\n+    }\n+\n+    /**\n+     * Get the propagator.\n+     *\n+     * @return the propagator.\n+     */\n+    public NumericalPropagator getPropagator() {\n+        return realPropagator;\n+    }\n+\n+    /**\n+     * Do the events.\n+     *\n+     * @param <T> the type of events detectors\n+     * @param s0 the initial state\n+     * @param detectors the detectors\n+     * @throws OrekitException if an Orekit exception occurs\n+     */\n+    public <T extends EventDetector> void doEvents(final SpacecraftState s0,\n+                                                  final Collection<T> detectors) throws OrekitException {\n+        final EventHandler<T> handler = new EventHandler<T>(detectors);\n+        handler.init(s0, s0.getDate().durationFrom(s0.shiftedBy(60.0)));\n+        final double tEnd = handler.getEventTime();\n+        StepNormalizer stepNormalizer = new StepNormalizer(tEnd, new FixedStepHandler() {\n+            public void init(SpacecraftState s0, double t) throws OrekitException {\n+                handler.setInterpolated(s0);\n+            }\n+\n+            public void handleStep(SpacecraftState currentState, boolean isLast) throws OrekitException {\n+                if (handler.evaluateStep(currentState)) {\n+                    handler.eventOccurred(currentState, isLast);\n                 }\n+            }\n+        }, s0.getFrame(), 0.1, realPropagator.getDrivers());\n+        final double maxCheckInterval = handler.getMaxCheckInterval();\n+        if (maxCheckInterval < tEnd - s0.getDate().durationFrom(s0)) {\n+            // the last switch time would be outside of the tolerance interval,\n+            // we will shorten the last step a little bit to make it fit\n+            final double epsilon = 1.0e-10 * (tEnd - s0.getDate().durationFrom(s0));\n+            StepNormalizer truncatedStepNormalizer \n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}