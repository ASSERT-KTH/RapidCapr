{
    "patch": "            int loops = 0;\n            for (;;) {\n                long next = 0;\n                try {\n                    for (; loops < count; loops++) {\n                        next = savedFields[loops].set(next, resetFields);\n                    }\n                } catch (IllegalFieldValueException e) {\n                    if (text != null) {\n                        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                    }\n                    throw e;\n                }\n                if (next < iMillis) {\n                    // this only happens when there is a numeric underflow\n                    if (loops != count && savedFields[loops].type > MONTH_OF_YEAR) {\n                        // continue, but first undo the latest addition\n                        loops++;\n                        next = iMillis;\n                    } else {\n                        IllegalArgumentException ex = new IllegalArgumentException\n                                (\"Parsed time is too small: \" + next);\n                        if (text != null) {\n                            ex.initCause(null);\n                            ex = new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": \" \n                                    + ex.getMessage(), ex);\n                        }\n                        throw ex;\n                    }\n                } else if (next > iMillis + DAYS.toMillis(365)) {\n                    // this only happens when there is a numeric overflow\n                    for (; loops > 0; loops--) {\n                        next = savedFields[loops - 1].addWrapField(next, 1);\n                    }\n                    throw new IllegalArgumentException\n                            (\"Parsed time is too large: \" + next);\n                } else {\n                    return next;\n                }\n            }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..c9255ab6 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,46 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+            int loops = 0;\n+            for (;;) {\n+                long next = 0;\n+                try {\n+                    for (; loops < count; loops++) {\n+                        next = savedFields[loops].set(next, resetFields);\n+                    }\n+                } catch (IllegalFieldValueException e) {\n+                    if (text != null) {\n+                        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                    }\n+                    throw e;\n+                }\n+                if (next < iMillis) {\n+                    // this only happens when there is a numeric underflow\n+                    if (loops != count && savedFields[loops].type > MONTH_OF_YEAR) {\n+                        // continue, but first undo the latest addition\n+                        loops++;\n+                        next = iMillis;\n+                    } else {\n+                        IllegalArgumentException ex = new IllegalArgumentException\n+                                (\"Parsed time is too small: \" + next);\n+                        if (text != null) {\n+                            ex.initCause(null);\n+                            ex = new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": \" \n+                                    + ex.getMessage(), ex);\n+                        }\n+                        throw ex;\n+                    }\n+                } else if (next > iMillis + DAYS.toMillis(365)) {\n+                    // this only happens when there is a numeric overflow\n+                    for (; loops > 0; loops--) {\n+                        next = savedFields[loops - 1].addWrapField(next, 1);\n+                    }\n+                    throw new IllegalArgumentException\n+                            (\"Parsed time is too large: \" + next);\n+                } else {\n+                    return next;\n+                }\n+            }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}