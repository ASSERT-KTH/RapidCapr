{
    "patch": "        if (sign >= 0) {\n            // check if either value is close to a zero\n            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n                setResult(min, yMin, 0);\n                return min;\n            } else if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n                setResult(max, yMax, 0);\n                return max;\n            }else{\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                    (\"Function values at endpoints do not have different signs.\" +\n                     \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                     \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        } else {\n            double ret;\n            double x = min;\n            double y = yMin;\n            double fy = (yMax - yMin) / (max - min);  // secant\n      \n            // keep finding better approximations\n            boolean isBrent = false;\n            boolean bisect = true;\n            for (int i = 1; i <= getMaximumIterations(); ++i) {\n                // compute candidate new x-value, guaranteeing to keep it inside bracket\n                double mx = 0.5 * (min + max);\n                double adjustment = (Math.abs(y) < Math.abs(yMax)) ?\n                    getAbsoluteAccuracy() / fy :\n                    0.5 * (max - min);\n                double nextX;\n                if (Math.abs(mx - max) > adjustment) {\n                    // we have not crossed the maximum of the function\n                    nextX = mx - y / fy;\n                } else {\n                    // we have crossed the maximum of the function\n                    nextX = max - getRelativeAccuracy() * (max - min);\n                    isBrent = true;\n                }\n                if (nextX <= min || nextX >= max || \n                    (isBrent && (Math.abs(nextX - mx) >= 0.5 * Math.abs(mx - x)))) {\n                    // A new approximation is outside the bracket.\n                    // Use bisection instead.\n                    nextX = 0.5 * (min + max);\n                    bisect = true;\n                } else if (!isBrent &&\n                           (Math.abs(nextX - x) <= getAbsoluteAccuracy() || \n                            Math.abs(y) <= getFunctionValueAccuracy())) {\n                    // The absolute tolerance is used when we have not yet found a root\n                    // in order to get to the required tolerance level faster and because\n                    // in many cases the numerical noise is dominated by the absolute\n                    // tolerance.\n                    bisect = true;\n                } else if (!isBrent &&\n                           (Math.abs(y) <= getFunctionValueAccuracy() ||\n                            (Math.abs(y) <= getPreviousResult().getFunctionValue() &&\n                             Math.abs(nextX - x) > 0.5 * Math.abs(x - getPreviousResult().getPoint())))) {\n                    // In this case, we use bisection for one iteration (or until the absolute\n                    // tolerance is reached). However, we keep track of the evolution of the function\n                    // values computed at previous iterations in order will be able to return the\n                    // result if it is accurate enough or to restart from the previous point using\n                    // an improved bracketing if it is not. This corresponds to strategy \"A\" in\n                    // the classical Brent's method paper.\n                    bisect = true;\n                } else {\n                    // We prefer to use the secant method as its convergence rate in the vicinity\n                    // of the solution is much faster than the one of the pure Newton's method, that\n                    // requires the knowledge of the function derivative. However, we may also use\n                    // the Newton-Raphson method, if we happen to guess very well the solution, or if\n                    // we have very tight brackets that can compensate for the slow convergence rate\n                    // in this case.\n                    bisect = false;\n                }\n                // compute the value of the function and the corresponding new approximation to the root\n                double nextY;\n                if (bisect) {\n                    nextY = f.value(nextX);\n                    if (Math.abs(nextY) < getFunctionValueAccuracy()) {\n                        // The root has been found exactly!\n                        setResult(nextX, nextY, i);\n                        return getResult().getPoint();\n                    }\n                    // improve bracketing\n                    sign = y * nextY;\n                    if (sign < 0) {\n                        max = nextX;\n                        yMax = nextY;\n                    } else if (sign > 0) {\n                        min = nextX;\n                        yMin = nextY;\n                    } else {\n                        // This shouldn't happen any more once the code has matured.\n                        // However, it will be safe to consider this case as convergence.\n                        setResult(nextX, nextY, i);\n                        return getResult().getPoint();\n                    }\n                    if ((isBrent || nextX - x >= 0) && Math.abs(y) <= Math.abs(nextY)) {\n                        // A new approximation is stagnating. Use bisection.\n                        fy = (yMax - yMin) / (max - min);\n                        nextX = 0.5 * (min + max);\n                        nextY = f.value(nextX);\n                    }\n                } else {\n                    // evaluate the derivative\n                    double xDot = f.derivative().value(x);\n                    double denom = xDot + fy;\n                    if (FastMath.abs(denom) < 1e-08)\n                        // Newton-Raphson step irregular. Use Secant method instead.\n                        denom = fy;\n                    double deltaX = y / denom;\n                    nextX = x - deltaX;\n                    // check new approximation\n                    if (nextX <= min || nextX >= max) {\n                        // A new approximation is outside the bracket.\n                        // Use bisection instead.\n                        nextX = 0.5 * (min + max);\n                        bisect = true;\n                    } else if (!isBrent &&\n                               (Math.abs(deltaX) <= getAbsoluteAccuracy() ||\n                                Math.abs(y) <= getFunctionValueAccuracy())) {\n                        // The absolute tolerance is used when we have not yet found a root\n                        // in order to get to the required tolerance level faster and because\n                        // in many cases the numerical noise is dominated by the absolute\n                        // tolerance.\n                        bisect = true;\n                    } else if (!isBrent &&\n                               (Math.abs(y) <= getFunctionValueAccuracy() ||\n                                (Math.abs(y) <= getPreviousResult().getFunctionValue() &&\n                                 Math.abs(nextX - x) > 0.5 * Math.abs(x - getPreviousResult().getPoint())))) {\n                        // In this case, we use bisection for one iteration (or until the absolute\n                        // tolerance is reached). However, we keep track of the evolution of the function\n                        // values computed at previous iterations in order will be able to return the\n                        // result if it is accurate enough or to restart from the previous point using\n                        // an improved bracketing if it is not. This corresponds to strategy \"A\" in\n                        // the classical Brent's method paper.\n                        bisect = true;\n                    } else {\n                        // update bracketing\n                        xDot = f.derivative().value(nextX);\n                        fy = (yMax - nextY) / (max - nextX);\n                        fy = fy * xDot + nextY;\n                        // check convergence\n                        if (FastMath.abs(nextY) <= getFunctionValueAccuracy()) {\n                            setResult(nextX, nextY, i);\n                            return getResult().getPoint();\n                        } else {\n                            ++i;\n                            x = nextX;\n                            y = nextY;\n                            setResult(x, y, i);\n                        }\n                    }\n                    if (bisect) {\n                        // improve bracketing\n                        nextY = f.value(nextX);\n                        if (Math.abs(nextY) < getFunctionValueAccuracy()) {\n                            // The root has been found exactly!\n                            setResult(nextX, nextY, i);\n                            return getResult().getPoint();\n                        }\n                        sign = y * nextY;\n                        if (sign < 0) {\n                            max = nextX;\n                            yMax = nextY;\n                        } else if (sign > 0) {\n                            min = nextX;\n                            yMin = nextY;\n                        } else {\n                            // This shouldn't happen any more once the code has matured.\n                            // However, it will be safe to consider this case as convergence.\n                            setResult(nextX, nextY, i);\n                            return getResult().getPoint();\n                        }\n                    }\n                }\n                // save the last result\n                if (i == 1) {\n                    getPreviousResult().set(getResult());\n                } else {\n                    if (Math.abs(getResult().getPoint() - getPreviousResult().getPoint()) <=\n                        Math.max(getRelativeAccuracy() * Math.abs(getResult().getPoint()),\n                                 getAbsoluteAccuracy())) {\n                        if (getAccuracy().checkResult(getPreviousResult().getFunctionValue(),\n                                                       getResult().getFunctionValue())) {\n                            return getResult().getPoint();\n                        } else {\n                            bisect = true;\n                        }\n                    }\n                    getPreviousResult().set(getResult());\n                }\n            }\n            throw new MaxIterationsExceededException(getMaxIterations());",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..4e8de2137 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,34 +122,199 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n-        \n-        clearResult();\n-        verifyInterval(min, max);\n-        \n-        double ret = Double.NaN;\n-        \n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n-        \n-        // Verify bracketing\n-        double sign = yMin * yMax;\n         if (sign >= 0) {\n             // check if either value is close to a zero\n+            if (Math.abs(yMin) <= getFunctionValueAccuracy()) {\n+                setResult(min, yMin, 0);\n+                return min;\n+            } else if (Math.abs(yMax) <= getFunctionValueAccuracy()) {\n+                setResult(max, yMax, 0);\n+                return max;\n+            }else{\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+                    (\"Function values at endpoints do not have different signs.\" +\n+                     \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n+                     \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+            }\n         } else {\n-            // solve using only the first endpoint as initial guess\n-            ret = solve(min, yMin, max, yMax, min, yMin);\n-            // either min or max is a root\n-        }\n-\n-        return ret;\n-    }\n+            double ret;\n+            double x = min;\n+            double y = yMin;\n+            double fy = (yMax - yMin) / (max - min);  // secant\n+      \n+            // keep finding better approximations\n+            boolean isBrent = false;\n+            boolean bisect = true;\n+            for (int i = 1; i <= getMaximumIterations(); ++i) {\n+                // compute candidate new x-value, guaranteeing to keep it inside bracket\n+                double mx = 0.5 * (min + max);\n+                double adjustment = (Math.abs(y) < Math.abs(yMax)) ?\n+                    getAbsoluteAccuracy() / fy :\n+                    0.5 * (max - min);\n+                double nextX;\n+                if (Math.abs(mx - max) > adjustment) {\n+                    // we have not crossed the maximum of the function\n+                    nextX = mx - y / fy;\n+                } else {\n+                    // we have crossed the maximum of the function\n+                    nextX = max - getRelativeAccuracy() * (max - min);\n+                    isBrent = true;\n+                }\n+                if (nextX <= min || nextX >= max || \n+                    (isBrent && (Math.abs(nextX - mx) >= 0.5 * Math.abs(mx - x)))) {\n+                    // A new approximation is outside the bracket.\n+                    // Use bisection instead.\n+                    nextX = 0.5 * (min + max);\n+                    bisect = true;\n+                } else if (!isBrent &&\n+                           (Math.abs(nextX - x) <= getAbsoluteAccuracy() || \n+                            Math.abs(y) <= getFunctionValueAccuracy())) {\n+                    // The absolute tolerance is used when we have not yet found a root\n+                    // in order to get to the required tolerance level faster and because\n+                    // in many cases the numerical noise is dominated by the absolute\n+                    // tolerance.\n+                    bisect = true;\n+                } else if (!isBrent &&\n+                           (Math.abs(y) <= getFunctionValueAccuracy() ||\n+                            (Math.abs(y) <= getPreviousResult().getFunctionValue() &&\n+                             Math.abs(nextX - x) > 0.5 * Math.abs(x - getPreviousResult().getPoint())))) {\n+                    // In this case, we use bisection for one iteration (or until the absolute\n+                    // tolerance is reached). However, we keep track of the evolution of the function\n+                    // values computed at previous iterations in order will be able to return the\n+                    // result if it is accurate enough or to restart from the previous point using\n+                    // an improved bracketing if it is not. This corresponds to strategy \"A\" in\n+                    // the classical Brent's method paper.\n+                    bisect = true;\n+                } else {\n+                    // We prefer to use the secant method as its convergence rate in the vicinity\n+                    // of the solution is much faster than the one of the pure Newton's method, that\n+                    // requires the knowledge of the function derivative. However, we may also use\n+                    // the Newton-Raphson method, if we happen to guess very well the solution, or if\n+                    // we have very tight brackets that can compensate for the slow convergence rate\n+                    // in this case.\n+                    bisect = false;\n+                }\n+                // compute the value of the function and the corresponding new approximation to the root\n+                double nextY;\n+                if (bisect) {\n+                    nextY = f.value(nextX);\n+                    if (Math.abs(nextY) < getFunctionValueAccuracy()) {\n+                        // The root has been found exactly!\n+                        setResult(nextX, nextY, i);\n+                        return getResult().getPoint();\n+                    }\n+                    // improve bracketing\n+                    sign = y * nextY;\n+                    if (sign < 0) {\n+                        max = nextX;\n+                        yMax = nextY;\n+                    } else if (sign > 0) {\n+                        min = nextX;\n+                        yMin = nextY;\n+                    } else {\n+                        // This shouldn't happen any more once the code has matured.\n+                        // However, it will be safe to consider this case as convergence.\n+                        setResult(nextX, nextY, i);\n+                        return getResult().getPoint();\n+                    }\n+                    if ((isBrent || nextX - x >= 0) && Math.abs(y) <= Math.abs(nextY)) {\n+                        // A new approximation is stagnating. Use bisection.\n+                        fy = (yMax - yMin) / (max - min);\n+                        nextX = 0.5 * (min + max);\n+                        nextY = f.value(nextX);\n+                    }\n+                } else {\n+                    // evaluate the derivative\n+                    double xDot = f.derivative().value(x);\n+                    double denom = xDot + fy;\n+                    if (FastMath.abs(denom) < 1e-08)\n+                        // Newton-Raphson step irregular. Use Secant method instead.\n+                        denom = fy;\n+                    double deltaX = y / denom;\n+                    nextX = x - deltaX;\n+                    // check new approximation\n+                    if (nextX <= min || nextX >= max) {\n+                        // A new approximation is outside the bracket.\n+                        // Use bisection instead.\n+                        nextX = 0.5 * (min + max);\n+                        bisect = true;\n+                    } else if (!isBrent &&\n+                               (Math.abs(deltaX) <= getAbsoluteAccuracy() ||\n+                                Math.abs(y) <= getFunctionValueAccuracy())) {\n+                        // The absolute tolerance is used when we have not yet found a root\n+                        // in order to get to the required tolerance level faster and because\n+                        // in many cases the numerical noise is dominated by the absolute\n+                        // tolerance.\n+                        bisect = true;\n+                    } else if (!isBrent &&\n+                               (Math.abs(y) <= getFunctionValueAccuracy() ||\n+                                (Math.abs(y) <= getPreviousResult().getFunctionValue() &&\n+                                 Math.abs(nextX - x) > 0.5 * Math.abs(x - getPreviousResult().getPoint())))) {\n+                        // In this case, we use bisection for one iteration (or until the absolute\n+                        // tolerance is reached). However, we keep track of the evolution of the function\n+                        // values computed at previous iterations in order will be able to return the\n+                        // result if it is accurate enough or to restart from the previous point using\n+                        // an improved bracketing if it is not. This corresponds to strategy \"A\" in\n+                        // the classical Brent's method paper.\n+                        bisect = true;\n+                    } else {\n+                        // update bracketing\n+                        xDot = f.derivative().value(nextX);\n+                        fy = (yMax - nextY) / (max - nextX);\n+                        fy = fy * xDot + nextY;\n+                        // check convergence\n+                        if (FastMath.abs(nextY) <= getFunctionValueAccuracy()) {\n+                            setResult(nextX, nextY, i);\n+                            return getResult().getPoint();\n+                        } else {\n+                            ++i;\n+                            x = nextX;\n+                            y = nextY;\n+                            setResult(x, y, i);\n+                        }\n+                    }\n+                    if (bisect) {\n+                        // improve bracketing\n+                        nextY = f.value(nextX);\n+                        if (Math.abs(nextY) < getFunctionValueAccuracy()) {\n+                            // The root has been found exactly!\n+                            setResult(nextX, nextY, i);\n+                            return getResult().getPoint();\n+                        }\n+                        sign = y * nextY;\n+                        if (sign < 0) {\n+                            max = nextX;\n+                            yMax = nextY;\n+                        } else if (sign > 0) {\n+                            min = nextX;\n+                            yMin = nextY;\n+                        } else {\n+                            // This shouldn't happen any more once the code has matured.\n+                            // However, it will be safe to consider this case as convergence.\n+                            setResult(nextX, nextY, i);\n+                            return getResult().getPoint();\n+                        }\n+                    }\n+                }\n+                // save the last result\n+                if (i == 1) {\n+                    getPreviousResult().set(getResult());\n+                } else {\n+                    if (Math.abs(getResult().getPoint() - getPreviousResult().getPoint()) <=\n+                        Math.max(getRelativeAccuracy() * Math.abs(getResult().getPoint()),\n+                                 getAbsoluteAccuracy())) {\n+                        if (getAccuracy().checkResult(getPreviousResult().getFunctionValue(),\n+                                                       getResult().getFunctionValue())) {\n+                            return getResult().getPoint();\n+                        } else {\n+                            bisect = true;\n+                        }\n+                    }\n+                    getPreviousResult().set(getResult());\n+                }\n+            }\n+            throw new MaxIterationsExceededException(getMaxIterations());\n         \n     /**\n      * Find a zero starting search according to the three provided points.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}