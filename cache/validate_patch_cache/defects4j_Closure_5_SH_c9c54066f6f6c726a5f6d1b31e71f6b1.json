{
    "patch": "static class MinimizeExitPointsCallback\n        extends AbstractPostOrderCallback {\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n        switch (n.getToken()) {\n            case VAR: {\n                Node currentNode = n.getFirstChild().getNext();\n                while (currentNode != null) {\n                    Node next = currentNode.getNext();\n                    String varName = currentNode.getString();\n                    if (NodeUtil.isNameDeclaration(currentNode.getParent())) {\n                        Node initialValue = currentNode.getFirstChild();\n                        if (initialValue != null && initialValue.isFunction()) {\n                            ReplaceReturnWithAssignment replacer = new ReplaceReturnWithAssignment(\n                                    t.getCompiler(), t.getScope(), n.getJSDocInfo());\n                            Node body = initialValue.getLastChild();\n                            boolean modifiedBody = false;\n                            for (Node child : body.children()) {\n                                if (child.isReturn()) {\n                                    Node returnedValue = child.getFirstChild();\n                                    if (returnedValue == null) {\n                                        returnedValue = IR.nullNode();\n                                    }\n                                    child.replaceWith(replacer.createAssignment(\n                                            varName, returnedValue.detach()));\n                                    modifiedBody = true;\n                                }\n                            }\n                            if (modifiedBody) {\n                                body.addChildToBack(replacer.createReturn(varName));\n                                if (NodeUtil.isStatement(initialValue.getParent())) {\n                                    initialValue.detach();\n                                    n.getParent().addChildAfter(initialValue, n);\n                                }\n                                t.getCompiler().reportChangeToEnclosingScope(initialValue.getParent());\n                            }\n                        }\n                    }\n                    currentNode = next;\n                }\n            }\n            break;\n\n            case RETURN: {\n                if (!MINIMIZE_EXIT_POINTS) {\n                    break;\n                }\n                Node result = n.getFirstChild();\n                if (result != null && result.isName() && !NodeUtil.isLoopStructure(parent)) {\n                    int definitionCount = 0;\n                    int assignmentCount = 0;\n                    Var variable = t.getScope().getVar(result.getString());\n                    if (variable != null) {\n                        definitionCount = variable.getInitialDefinitions().size();\n                        for (Node use : variable.getUsages()) {\n                            if (!use.isName()) {\n                                ++assignmentCount;\n                                break;\n                            }\n                            if (!isAssignedName(t, use)) {\n                                ++assignmentCount;\n                                break;\n                            }\n                        }\n                    }\n\n                    if (definitionCount == 1 && assignmentCount == 0) {\n                        Node newName = new Node(Token.NAME, result.getString() + \"_\");\n                        newName.useSourceInfoIfMissingFrom(result);\n                        n.replaceChild(result, newName);\n                        t.getCompiler().reportChangeToEnclosingScope(newName);\n                    }\n                }\n            }\n            break;\n        }\n    }\n\n    private static final boolean MINIMIZE_EXIT_POINTS =\n            System.getProperty(\"minimize_exit_points\") != null;\n\n    private static boolean isAssignedName(NodeTraversal t, Node name) {\n        Node parent = name.getParent();\n        if (parent.isVar() &&\n                parent.getFirstChild() == name &&\n                NodeUtil.isNameDeclaration(parent)) {\n            return false;\n        }\n\n        if (parent.isFunction()) {\n            return false;\n        }\n\n        if (parent.isAssign() &&\n                parent.getFirstChild() == name &&\n                NodeUtil.isNameDeclaration(parent.getParent())) {\n            return false;\n        }\n\n        if (NodeUtil.isAssignmentOp(parent) &&\n                parent.getFirstChild() == name) {\n            return false;\n        }\n\n        if (parent.isForIn() || parent.isForOf()) {\n            return parent.getFirstChild() == name;\n        }\n\n        if (parent.isInc() || parent.isDec()) {\n            return parent.getFirstChild() == name;\n        }\n\n        return true;\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..cb81453b 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,122 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+static class MinimizeExitPointsCallback\n+        extends AbstractPostOrderCallback {\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+        switch (n.getToken()) {\n+            case VAR: {\n+                Node currentNode = n.getFirstChild().getNext();\n+                while (currentNode != null) {\n+                    Node next = currentNode.getNext();\n+                    String varName = currentNode.getString();\n+                    if (NodeUtil.isNameDeclaration(currentNode.getParent())) {\n+                        Node initialValue = currentNode.getFirstChild();\n+                        if (initialValue != null && initialValue.isFunction()) {\n+                            ReplaceReturnWithAssignment replacer = new ReplaceReturnWithAssignment(\n+                                    t.getCompiler(), t.getScope(), n.getJSDocInfo());\n+                            Node body = initialValue.getLastChild();\n+                            boolean modifiedBody = false;\n+                            for (Node child : body.children()) {\n+                                if (child.isReturn()) {\n+                                    Node returnedValue = child.getFirstChild();\n+                                    if (returnedValue == null) {\n+                                        returnedValue = IR.nullNode();\n+                                    }\n+                                    child.replaceWith(replacer.createAssignment(\n+                                            varName, returnedValue.detach()));\n+                                    modifiedBody = true;\n+                                }\n+                            }\n+                            if (modifiedBody) {\n+                                body.addChildToBack(replacer.createReturn(varName));\n+                                if (NodeUtil.isStatement(initialValue.getParent())) {\n+                                    initialValue.detach();\n+                                    n.getParent().addChildAfter(initialValue, n);\n+                                }\n+                                t.getCompiler().reportChangeToEnclosingScope(initialValue.getParent());\n+                            }\n+                        }\n+                    }\n+                    currentNode = next;\n+                }\n+            }\n+            break;\n+\n+            case RETURN: {\n+                if (!MINIMIZE_EXIT_POINTS) {\n+                    break;\n+                }\n+                Node result = n.getFirstChild();\n+                if (result != null && result.isName() && !NodeUtil.isLoopStructure(parent)) {\n+                    int definitionCount = 0;\n+                    int assignmentCount = 0;\n+                    Var variable = t.getScope().getVar(result.getString());\n+                    if (variable != null) {\n+                        definitionCount = variable.getInitialDefinitions().size();\n+                        for (Node use : variable.getUsages()) {\n+                            if (!use.isName()) {\n+                                ++assignmentCount;\n+                                break;\n+                            }\n+                            if (!isAssignedName(t, use)) {\n+                                ++assignmentCount;\n+                                break;\n+                            }\n+                        }\n+                    }\n+\n+                    if (definitionCount == 1 && assignmentCount == 0) {\n+                        Node newName = new Node(Token.NAME, result.getString() + \"_\");\n+                        newName.useSourceInfoIfMissingFrom(result);\n+                        n.replaceChild(result, newName);\n+                        t.getCompiler().reportChangeToEnclosingScope(newName);\n+                    }\n+                }\n+            }\n+            break;\n+        }\n+    }\n+\n+    private static final boolean MINIMIZE_EXIT_POINTS =\n+            System.getProperty(\"minimize_exit_points\") != null;\n+\n+    private static boolean isAssignedName(NodeTraversal t, Node name) {\n+        Node parent = name.getParent();\n+        if (parent.isVar() &&\n+                parent.getFirstChild() == name &&\n+                NodeUtil.isNameDeclaration(parent)) {\n+            return false;\n+        }\n+\n+        if (parent.isFunction()) {\n+            return false;\n+        }\n+\n+        if (parent.isAssign() &&\n+                parent.getFirstChild() == name &&\n+                NodeUtil.isNameDeclaration(parent.getParent())) {\n+            return false;\n+        }\n+\n+        if (NodeUtil.isAssignmentOp(parent) &&\n+                parent.getFirstChild() == name) {\n+            return false;\n+        }\n+\n+        if (parent.isForIn() || parent.isForOf()) {\n+            return parent.getFirstChild() == name;\n+        }\n+\n+        if (parent.isInc() || parent.isDec()) {\n+            return parent.getFirstChild() == name;\n+        }\n+\n+        return true;\n+    }\n+}\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}