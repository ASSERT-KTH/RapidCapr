{
    "patch": "Node symbolicReturnNode = new Node(Token.IF);\nsymbolicReturnNode.useSourceInfoIfMissingFromForTree(fromNode);\nsymbolicReturnNode.addChildToBack(new Node(Token.TRUE));\nNode successor = new Node(Token.BLOCK);\nsuccessor.useSourceInfoIfMissingFromForTree(fromNode);\nsuccessor.addChildToBack(symbolicReturnNode);\ncfa.createEdge(fromNode, Branch.UNCOND, successor);\nreturn symbolicReturnNode;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..b06cbfd4 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,14 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+Node symbolicReturnNode = new Node(Token.IF);\n+symbolicReturnNode.useSourceInfoIfMissingFromForTree(fromNode);\n+symbolicReturnNode.addChildToBack(new Node(Token.TRUE));\n+Node successor = new Node(Token.BLOCK);\n+successor.useSourceInfoIfMissingFromForTree(fromNode);\n+successor.addChildToBack(symbolicReturnNode);\n+cfa.createEdge(fromNode, Branch.UNCOND, successor);\n+return symbolicReturnNode;\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "java.lang.NullPointerException",
    "test_result": "FAIL"
}