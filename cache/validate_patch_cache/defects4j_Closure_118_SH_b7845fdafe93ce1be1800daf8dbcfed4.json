{
    "patch": "        JSDocInfo info = NodeUtil.getBestJSDocInfo(child);\n        if (info != null && info.containsType()) {\n          T type = typeRegistry.getType(info.getType());\n          if (type instanceof FunctionType) {\n            // Add a function property to this object literal.\n            FunctionType fnType = (FunctionType) type;\n            if (fnType.isConstructor()) {\n              JSError error = JSError.make(\n                  t.getSourceName(), child, Warnings.CTOR_IN_DIFFERENT_SCOPE);\n              compiler.report(error);\n            } else if (fnType.isInterface()) {\n              JSError error = JSError.make(t.getSourceName(), child, Warnings.INTERFACE_METHOD);\n              compiler.report(error);\n            } else {\n              String typeName = type.toString();\n              Node functionNode = NodeUtil.getEnclosingFunction(n);\n              String functionName = \"\";\n              if (functionNode != null) {\n                functionName = NodeUtil.getNearestFunctionName(functionNode);\n              }\n              FunctionType subType = fnType;\n              for (String part : name.split(\"\\\\.\")) {\n                subType = subType.getPropertyType(part);\n              }\n              Property prop = getProperty(name);\n              if (!prop.scheduleRenaming(child,\n                  processProperty(t, prop, subType, typeName))) {\n                if (propertiesToErrorFor.containsKey(name)) {\n                  compiler.report(JSError.make(\n                      t.getSourceName(), child, propertiesToErrorFor.get(name),\n                      Warnings.INVALIDATION, name,\n                      (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n                }\n              }\n            }\n          }\n        } else {\n          // No JSDoc for this property, but maybe its value has a type.\n          T type = typeSystem.getType(getScope(), n, name);\n          Property prop = getProperty(name);\n          if (!prop.scheduleRenaming(child,\n                processProperty(t, prop, type, null))) {\n            if (propertiesToErrorFor.containsKey(name)) {\n              compiler.report(JSError.make(\n                  t.getSourceName(), child, propertiesToErrorFor.get(name),\n                  Warnings.INVALIDATION, name,\n                  (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n            }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DisambiguateProperties.java b/src/com/google/javascript/jscomp/DisambiguateProperties.java\nindex b34921ed..b7e6bb68 100644\n--- a/src/com/google/javascript/jscomp/DisambiguateProperties.java\n+++ b/src/com/google/javascript/jscomp/DisambiguateProperties.java\n@@ -492,6 +492,54 @@ class DisambiguateProperties<T> implements CompilerPass {\n           child != null;\n           child = child.getNext()) {\n         // Maybe STRING, GET, SET\n+        JSDocInfo info = NodeUtil.getBestJSDocInfo(child);\n+        if (info != null && info.containsType()) {\n+          T type = typeRegistry.getType(info.getType());\n+          if (type instanceof FunctionType) {\n+            // Add a function property to this object literal.\n+            FunctionType fnType = (FunctionType) type;\n+            if (fnType.isConstructor()) {\n+              JSError error = JSError.make(\n+                  t.getSourceName(), child, Warnings.CTOR_IN_DIFFERENT_SCOPE);\n+              compiler.report(error);\n+            } else if (fnType.isInterface()) {\n+              JSError error = JSError.make(t.getSourceName(), child, Warnings.INTERFACE_METHOD);\n+              compiler.report(error);\n+            } else {\n+              String typeName = type.toString();\n+              Node functionNode = NodeUtil.getEnclosingFunction(n);\n+              String functionName = \"\";\n+              if (functionNode != null) {\n+                functionName = NodeUtil.getNearestFunctionName(functionNode);\n+              }\n+              FunctionType subType = fnType;\n+              for (String part : name.split(\"\\\\.\")) {\n+                subType = subType.getPropertyType(part);\n+              }\n+              Property prop = getProperty(name);\n+              if (!prop.scheduleRenaming(child,\n+                  processProperty(t, prop, subType, typeName))) {\n+                if (propertiesToErrorFor.containsKey(name)) {\n+                  compiler.report(JSError.make(\n+                      t.getSourceName(), child, propertiesToErrorFor.get(name),\n+                      Warnings.INVALIDATION, name,\n+                      (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n+                }\n+              }\n+            }\n+          }\n+        } else {\n+          // No JSDoc for this property, but maybe its value has a type.\n+          T type = typeSystem.getType(getScope(), n, name);\n+          Property prop = getProperty(name);\n+          if (!prop.scheduleRenaming(child,\n+                processProperty(t, prop, type, null))) {\n+            if (propertiesToErrorFor.containsKey(name)) {\n+              compiler.report(JSError.make(\n+                  t.getSourceName(), child, propertiesToErrorFor.get(name),\n+                  Warnings.INVALIDATION, name,\n+                  (type == null ? \"null\" : type.toString()), n.toString(), \"\"));\n+            }\n \n         // We should never see a mix of numbers and strings.\n         String name = child.getString();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}