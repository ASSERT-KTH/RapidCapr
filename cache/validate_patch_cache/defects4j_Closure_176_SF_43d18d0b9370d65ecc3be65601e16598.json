{
    "patch": "public void ensurePropertyDefined(Node getprop, JSType rightType) {\n  String propName = getprop.getLastChild().getString();\n  Node obj = getprop.getFirstChild();\n  ObjectType objectType = ObjectType.cast(\n      getJSType(obj).restrictByNotNullOrUndefined());\n  boolean propCreationInConstructor = obj.isThis() &&\n      getJSType(syntacticScope.getRootNode()).isConstructor();\n\n  if (objectType == null) {\n    registry.registerPropertyOnGlobal(propName, rightType);\n  } else {\n    if (objectType.isStructFunction()) {\n      warnings.add(JSError.make(getprop, ILLEGAL_PROPERTY_CREATION_ON_FUNCTION_TYPE));\n      // Early return to avoid creating the property below.\n      return;\n    }\n\n    if (objectType.isFunctionPrototypeType()) {\n      ObjectType ownerFunctionType = objectType.getOwnerFunction();\n\n      // We are in global scope and we are creating a prototype property\n      // for a function defined right here.\n      boolean isPropertyInConstructor = syntacticScope.isGlobal()\n          && ownerFunctionType.isConstructor()\n          && ownerFunctionType.getSource().getInputId().equals(getprop.getInputId());\n\n      if (!isPropertyInConstructor && !isConstructorPrototype(getprop)) {\n        warnings.add(\n            JSError.make(getprop, ILLEGAL_PROPERTY_CREATION_ON_POSSIBLE_CTOR, propName));\n        // Early return to avoid creating the property below.\n        return;\n      }\n    }\n\n    if (nodeTypeHasKnownProperty(objectType, propName)) {\n      if (!objectType.isNamespace() && isPrototypeProperty(getprop)) {\n        if (!isConstructorProperty(getprop)) {\n          warnings.add(JSError.make(\n              getprop,\n              INHERITANCE_CYCLE,\n              getQualifiedFunctionName(objectType)));\n        }\n      }\n      ObjectType nativeObjectType = getNativeObjectType(obj);\n      if (nativeObjectType != null) {\n        FunctionType fnType = nativeObjectType.getConstructor();\n        if (fnType != null && fnType.isInterface() && !fnType.hasPropertyDeclared(propName)) {\n          FunctionTypeBuilder builder = new FunctionTypeBuilder(registry);\n          builder.copyFrom(fnType);\n          builder.addProperty(propName, rightType, null);\n          rightType = builder.buildAndResolve();\n        }\n      }\n    } else {\n      registry.registerPropertyOnObjectType(objectType, propName, rightType, getprop);\n    }\n    ObjectType objLitType = getJSType(obj).getObjLiteralWithProperty(propName);\n    if (objLitType != null && rightType.isSubtypeOf(unknownType)) {\n      addPropertyToAllSubtypes(objLitType, propName, unknownType, getprop);\n    } else if (getJSType(obj).getFunctionType() != null) {\n      registry.addNominalType(getJSType(obj).getFunctionType());\n    }\n  }\n  getprop.setJSType(rightType);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..652dd5a8 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,109 +521,71 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n-\n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n-\n+public void ensurePropertyDefined(Node getprop, JSType rightType) {\n+  String propName = getprop.getLastChild().getString();\n+  Node obj = getprop.getFirstChild();\n+  ObjectType objectType = ObjectType.cast(\n+      getJSType(obj).restrictByNotNullOrUndefined());\n+  boolean propCreationInConstructor = obj.isThis() &&\n+      getJSType(syntacticScope.getRootNode()).isConstructor();\n+\n+  if (objectType == null) {\n+    registry.registerPropertyOnGlobal(propName, rightType);\n+  } else {\n+    if (objectType.isStructFunction()) {\n+      warnings.add(JSError.make(getprop, ILLEGAL_PROPERTY_CREATION_ON_FUNCTION_TYPE));\n+      // Early return to avoid creating the property below.\n+      return;\n+    }\n \n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n+    if (objectType.isFunctionPrototypeType()) {\n+      ObjectType ownerFunctionType = objectType.getOwnerFunction();\n \n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n-        }\n-        break;\n-      case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n-        }\n+      // We are in global scope and we are creating a prototype property\n+      // for a function defined right here.\n+      boolean isPropertyInConstructor = syntacticScope.isGlobal()\n+          && ownerFunctionType.isConstructor()\n+          && ownerFunctionType.getSource().getInputId().equals(getprop.getInputId());\n \n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n-        break;\n+      if (!isPropertyInConstructor && !isConstructorPrototype(getprop)) {\n+        warnings.add(\n+            JSError.make(getprop, ILLEGAL_PROPERTY_CREATION_ON_POSSIBLE_CTOR, propName));\n+        // Early return to avoid creating the property below.\n+        return;\n+      }\n     }\n-  }\n \n-  /**\n-   * Defines a property if the property has not been defined yet.\n-   */\n-  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n-    String propName = getprop.getLastChild().getString();\n-    Node obj = getprop.getFirstChild();\n-    JSType nodeType = getJSType(obj);\n-    ObjectType objectType = ObjectType.cast(\n-        nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n-        getJSType(syntacticScope.getRootNode()).isConstructor();\n-\n-    if (objectType == null) {\n-      registry.registerPropertyOnType(propName, nodeType);\n-    } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n-        boolean staticPropCreation = false;\n-        Node maybeAssignStm = getprop.getParent().getParent();\n-        if (syntacticScope.isGlobal() &&\n-            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n-          String propCreationFilename = maybeAssignStm.getSourceFileName();\n-          Node ctor = objectType.getOwnerFunction().getSource();\n-          if (ctor != null &&\n-              ctor.getSourceFileName().equals(propCreationFilename)) {\n-            staticPropCreation = true;\n-          }\n+    if (nodeTypeHasKnownProperty(objectType, propName)) {\n+      if (!objectType.isNamespace() && isPrototypeProperty(getprop)) {\n+        if (!isConstructorProperty(getprop)) {\n+          warnings.add(JSError.make(\n+              getprop,\n+              INHERITANCE_CYCLE,\n+              getQualifiedFunctionName(objectType)));\n         }\n-        if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n+      }\n+      ObjectType nativeObjectType = getNativeObjectType(obj);\n+      if (nativeObjectType != null) {\n+        FunctionType fnType = nativeObjectType.getConstructor();\n+        if (fnType != null && fnType.isInterface() && !fnType.hasPropertyDeclared(propName)) {\n+          FunctionTypeBuilder builder = new FunctionTypeBuilder(registry);\n+          builder.copyFrom(fnType);\n+          builder.addProperty(propName, rightType, null);\n+          rightType = builder.buildAndResolve();\n         }\n       }\n+    } else {\n+      registry.registerPropertyOnObjectType(objectType, propName, rightType, getprop);\n+    }\n+    ObjectType objLitType = getJSType(obj).getObjLiteralWithProperty(propName);\n+    if (objLitType != null && rightType.isSubtypeOf(unknownType)) {\n+      addPropertyToAllSubtypes(objLitType, propName, unknownType, getprop);\n+    } else if (getJSType(obj).getFunctionType() != null) {\n+      registry.addNominalType(getJSType(obj).getFunctionType());\n+    }\n+  }\n+  getprop.setJSType(rightType);\n+}\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: modifier public not allowed here",
    "test_result": "ERROR"
}