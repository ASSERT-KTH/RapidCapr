{
    "patch": "    public static Number createNumber(String val) throws NumberFormatException {\n        if (val == null) {\n            return null;\n        }\n\n        if (val.length() == 0) {\n            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n        }\n\n        // Strings starting with -- are legal if the -- is followed by a digit\n        // or a decimal point.\n        if (val.startsWith(\"--\")) {\n            return null;\n        }\n\n        // Handle 0x and 0b radix prefixes separately\n        final String[] possiblePrefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"0b\", \"0B\", \"-0b\", \"-0B\"};\n        int prefixLength = 0;\n        for (String possiblePrefix : possiblePrefixes) {\n            if (val.startsWith(possiblePrefix)) {\n                prefixLength = possiblePrefix.length();\n                break;\n            }\n        }\n        String workingString = (prefixLength > 0) ? val.substring(prefixLength) : val;\n\n        // Handle +/- signs separately\n        char firstChar = workingString.charAt(0);\n        if (workingString.length() > 1 && (firstChar == '+' || firstChar == '-')) {\n            if (firstChar == '-' && workingString.charAt(1) == '-') {\n                // special case handling for \"--\" leading text, which is ignored but\n                // cannot be mistakenly identified as octal (see Bugzilla#20716 for\n                // the original problem description). The test here should work\n                // whether or not '-' is classified as an octal digit by the regex\n                // parser in validateDigits()\n                prefixLength += 2;\n            } else {\n                prefixLength++;\n                firstChar = workingString.charAt(1);\n            }\n            workingString = workingString.substring(1);\n        }\n\n        // Performing validation.\n        // Subsequent code works only with well-formed input\n        if (validFloatPattern.matcher(workingString).matches())\n            return createFloatOrDouble(workingString);\n\n        if (validIntPattern.matcher(workingString).matches())\n            return createIntegerOrLong(workingString, prefixLength);\n\n        throw new NumberFormatException(val + \" is not a valid number.\");\n    }\n\n    private static final Pattern validIntPattern = Pattern.compile(\"[+-]?[\\\\d]+\");\n\n    private static final Pattern zeroLeadIntPattern = Pattern.compile(\"[-+]?0[\\\\d]+\");\n\n    private static final Pattern validFloatPattern =\n            Pattern.compile(\"[+-]?(((((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+)))(\" +\n                    \"[eE][+-]?[\\\\d]+)?)|([\\\\d]+[eE][+-]?[\\\\d]+))\");\n\n    /**\n     * <p>Currently used to only check min/max for byte/short etc.</p>\n     *\n     * @param val       The value validation is being performed on.\n     * @param minValue  The inclusive minimum value allowed.\n     * @param maxValue  The inclusive maximum value allowed.\n     * @throws NumberFormatException if the value is not within the specified range.\n     */\n    private static void checkMinMax(String val, long minValue, long maxValue) {\n        try {\n            long value = Long.parseLong(val);\n            if ((value < minValue) || (value > maxValue)) {\n                throw new NumberFormatException(\n                        \"Value [\" + val + \"] out of range from [\" + minValue + \"] to [\" + maxValue + \"]\");\n            }\n        } catch(NumberFormatException nfe) {\n            // catch and rethrow with a little extra context\n            throw new NumberFormatException(\"Value [\" + val + \"] is not in range from [\" + minValue + \"] to [\" + maxValue + \"]\");\n        }\n    }\n\n    /**\n     * <p>Creates a <code>Double</code> or <code>Float</code> instance\n     * representing the specified floating-point value.</p>\n     *\n     * <p>This implementation uses {@link Double#valueOf(String)}.\n     * If a <code>NumberFormatException</code> is caught, it tries with\n     * {@link Float#valueOf(String)}.</p>\n     *\n     * @param val floating-point string representation of a numeric value.\n     * @return a <code>Double</code> if a valid argument is passed\n     * or a <code>Float</code> if a valid argument (but out of\n     * <code>Double</code> range) is passed.\n     * @throws NumberFormatException if the value is not a valid number\n     */\n    private static Number createFloatOrDouble(String val) {\n        try {\n            return Double.valueOf(val);\n        } catch (NumberFormatException nfe) {\n            // let's try with a float\n            try {\n                return Float.valueOf(val);\n            } catch (NumberFormatException nestedNfe) {\n                // cannot convert val to either float or double\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        }\n    }\n    /**\n     * <p>Creates a <code>Number</code>.</p>\n     *\n     * <p>This implementation handles the following input classes:</p>\n     * <ul>\n     * <li>BigDecimal</li>\n     * <li>BigInteger</li>\n     * <li>Double</li>\n     * <li>Float</li>\n     * <li>Long (from hex or octal strings)</li>\n     * <li>Integer</li>\n     * </ul>\n     *\n     * @param val The value validation is being performed on.\n     * @param decimalPointIndex Index of the decimal point in val. -1 if there isn't one.\n     * @param octal       Whether or not the number is octal.\n     * @param hex         Whether or not the number is hex.\n     * @return The appropriate <code>Number</code> instance.\n     */\n    private static Number createNumber(final String val, final int decimalPointIndex,\n            final boolean octal, final boolean hex) throws NumberFormatException {\n        // if there is decimal point and no octal/hex prefix we check\n        // which is the most appropriate type to use\n        if (decimalPointIndex > -1 && !hex && !octal) {\n            // if is less than max int length\n            if (val.length() <= 10 + decimalPointIndex\n                    && (decimalPointIndex <= 9 || decimalPointIndex == 10 && (val.charAt(0) == '1' || val.charAt(0) == '2'))) {\n                return createInteger(val);\n            }\n            // if less than max long length\n            if (val.length() <= 19 + decimalPointIndex\n                    && (decimalPointIndex <= 18 || decimalPointIndex == 19 && val.startsWith(\"1\"))) {\n                return createLong(val);\n            }\n            return createBigDecimal(val);\n        }\n\n        final char lastChar = val.charAt(val.length() - 1);\n\n        // Treat empty String as zero.\n        if (val.length() == 0) {\n            return Integer.valueOf(0);\n        }\n\n        // Use number valueOf methods for each relevant type\n        if (hex) {\n            if (val.length() > 16) {\n                return createBigInteger(val);\n            }\n            if (val.length() > 8 || val.length()==8 && lastChar >= '8') {\n                return createLong(val);\n            }\n            return createInteger(val);\n        }\n\n        if (octal) {\n            if (val.length() > 11) {\n                return createBigInteger(val);\n            }\n            if (val.length() > 6 || val.length()==6 && lastChar >= '8') {\n                return createInteger(val);\n            }\n            return createLong(val);\n        }\n\n        // If number is negative, strip minus sign and recurse.\n        if (val.charAt(0) == '-') {\n            if (val.length() == 1) {\n                throw new NumberFormatException(\"\\\"-\\\" is not a valid number.\");\n            }\n            return createNumber(val.substring(1), decimalPointIndex, octal, hex).negate();\n        }\n\n        // Check for and remove leading zeros.\n        int leadingZeroCount = 0;\n        while (leadingZeroCount < val.length() && val.charAt(leadingZeroCount) == '0') {\n            leadingZeroCount++;\n        }\n\n        if (leadingZeroCount == val.length()) {\n            // Leading zeros only constitute a legitimate number for values\n            // of radix 1 (i.e., 0).\n            return Integer.valueOf(0);\n        }\n\n        // Attempt to parse as an int, since it's the most common case.\n        if (decimalPointIndex == -1 && val.length() - leadingZeroCount <= 9) { //int\n            final int i = Integer.parseInt(val);\n            if (i >= 0 || leadingZeroCount <= 1 && val.charAt(0) == '-') {\n                return Integer.valueOf(i);\n            }\n            // a negative number with too many leading zeros\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n        if (decimalPointIndex == -1 && val.length() - leadingZeroCount <= 18) { //long\n            final long l = Long.parseLong(val);\n            if (l >= 0 || leadingZeroCount <= 1 && val.charAt(0) == '-') {\n                return Long.valueOf(l);\n            }\n            // a negative number with too many leading zeros\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n\n        // If we're almost out of range for a positive value parse as a BigInteger.\n        if (val.length() - leadingZeroCount > 18 && val.charAt(0) != '-') {\n            return createBigInteger(val);\n        }\n\n        // Overflowed into double or BigDecimal if there is a .\n        // Fractional part makes number a BigDecimal regardless of size.\n        if (decimalPointIndex > -1 || val.charAt(val.length() - 1) == 'd'\n                || val.charAt(val.length() - 1) == 'D'\n                || val.charAt(val.length() - 1) == 'f'\n                || val.charAt(val.length() - 1) == 'F') {\n            return createBigDecimal(val);\n        }\n\n        // Parse as a long by default.\n        return createLong(val);\n    }\n    /**\n     * <p>Returns a new <code>BigDecimal</code> instance consisting of the\n     * number represented by the specified <code>String</code>.  The\n     * scale of the returned <code>BigDecimal</code> is the smallest value\n     * such that (10<sup>scale</sup> &times; val) is an integer.</p>\n     *\n     * <p>This implementation is identical to NumberUtils.createBigDecimal(String).</p>\n     *\n     * @param val The value to convert to a <code>BigDecimal</code>.\n     * @return The big decimal representation of <code>val</code>.\n     * @throws NumberFormatException if <code>val</code> is not a valid number.\n     * @see #createBigDecimal(String)\n     * @since 3.2 Changed signature from createBigDecimal(String) to propagate exceptions\n     */\n    public static BigDecimal createBigDecimal(final String val) throws NumberFormatException {\n\n        try {\n            // regular decimal representation\n            return new BigDecimal(val);\n        } catch (NumberFormatException originalException) {\n            if (val == null) {\n                throw originalException;\n            }\n            String noExponents = val.toUpperCase(Locale.ROOT);\n\n            boolean hasSign = false;\n            char maybePlusChar = noExponents.charAt(0);\n            if (maybePlusChar == '+') {\n                hasSign = true;\n                noExponents = noExponent",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex 18a05efe..cc3bec61 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -142,6 +142,266 @@ public final class NumberUtils {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n+    public static Number createNumber(String val) throws NumberFormatException {\n+        if (val == null) {\n+            return null;\n+        }\n+\n+        if (val.length() == 0) {\n+            throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+        }\n+\n+        // Strings starting with -- are legal if the -- is followed by a digit\n+        // or a decimal point.\n+        if (val.startsWith(\"--\")) {\n+            return null;\n+        }\n+\n+        // Handle 0x and 0b radix prefixes separately\n+        final String[] possiblePrefixes = {\"0x\", \"0X\", \"-0x\", \"-0X\", \"0b\", \"0B\", \"-0b\", \"-0B\"};\n+        int prefixLength = 0;\n+        for (String possiblePrefix : possiblePrefixes) {\n+            if (val.startsWith(possiblePrefix)) {\n+                prefixLength = possiblePrefix.length();\n+                break;\n+            }\n+        }\n+        String workingString = (prefixLength > 0) ? val.substring(prefixLength) : val;\n+\n+        // Handle +/- signs separately\n+        char firstChar = workingString.charAt(0);\n+        if (workingString.length() > 1 && (firstChar == '+' || firstChar == '-')) {\n+            if (firstChar == '-' && workingString.charAt(1) == '-') {\n+                // special case handling for \"--\" leading text, which is ignored but\n+                // cannot be mistakenly identified as octal (see Bugzilla#20716 for\n+                // the original problem description). The test here should work\n+                // whether or not '-' is classified as an octal digit by the regex\n+                // parser in validateDigits()\n+                prefixLength += 2;\n+            } else {\n+                prefixLength++;\n+                firstChar = workingString.charAt(1);\n+            }\n+            workingString = workingString.substring(1);\n+        }\n+\n+        // Performing validation.\n+        // Subsequent code works only with well-formed input\n+        if (validFloatPattern.matcher(workingString).matches())\n+            return createFloatOrDouble(workingString);\n+\n+        if (validIntPattern.matcher(workingString).matches())\n+            return createIntegerOrLong(workingString, prefixLength);\n+\n+        throw new NumberFormatException(val + \" is not a valid number.\");\n+    }\n+\n+    private static final Pattern validIntPattern = Pattern.compile(\"[+-]?[\\\\d]+\");\n+\n+    private static final Pattern zeroLeadIntPattern = Pattern.compile(\"[-+]?0[\\\\d]+\");\n+\n+    private static final Pattern validFloatPattern =\n+            Pattern.compile(\"[+-]?(((((\\\\d+\\\\.?\\\\d*)|(\\\\.\\\\d+)))(\" +\n+                    \"[eE][+-]?[\\\\d]+)?)|([\\\\d]+[eE][+-]?[\\\\d]+))\");\n+\n+    /**\n+     * <p>Currently used to only check min/max for byte/short etc.</p>\n+     *\n+     * @param val       The value validation is being performed on.\n+     * @param minValue  The inclusive minimum value allowed.\n+     * @param maxValue  The inclusive maximum value allowed.\n+     * @throws NumberFormatException if the value is not within the specified range.\n+     */\n+    private static void checkMinMax(String val, long minValue, long maxValue) {\n+        try {\n+            long value = Long.parseLong(val);\n+            if ((value < minValue) || (value > maxValue)) {\n+                throw new NumberFormatException(\n+                        \"Value [\" + val + \"] out of range from [\" + minValue + \"] to [\" + maxValue + \"]\");\n+            }\n+        } catch(NumberFormatException nfe) {\n+            // catch and rethrow with a little extra context\n+            throw new NumberFormatException(\"Value [\" + val + \"] is not in range from [\" + minValue + \"] to [\" + maxValue + \"]\");\n+        }\n+    }\n+\n+    /**\n+     * <p>Creates a <code>Double</code> or <code>Float</code> instance\n+     * representing the specified floating-point value.</p>\n+     *\n+     * <p>This implementation uses {@link Double#valueOf(String)}.\n+     * If a <code>NumberFormatException</code> is caught, it tries with\n+     * {@link Float#valueOf(String)}.</p>\n+     *\n+     * @param val floating-point string representation of a numeric value.\n+     * @return a <code>Double</code> if a valid argument is passed\n+     * or a <code>Float</code> if a valid argument (but out of\n+     * <code>Double</code> range) is passed.\n+     * @throws NumberFormatException if the value is not a valid number\n+     */\n+    private static Number createFloatOrDouble(String val) {\n+        try {\n+            return Double.valueOf(val);\n+        } catch (NumberFormatException nfe) {\n+            // let's try with a float\n+            try {\n+                return Float.valueOf(val);\n+            } catch (NumberFormatException nestedNfe) {\n+                // cannot convert val to either float or double\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+            }\n+        }\n+    }\n+    /**\n+     * <p>Creates a <code>Number</code>.</p>\n+     *\n+     * <p>This implementation handles the following input classes:</p>\n+     * <ul>\n+     * <li>BigDecimal</li>\n+     * <li>BigInteger</li>\n+     * <li>Double</li>\n+     * <li>Float</li>\n+     * <li>Long (from hex or octal strings)</li>\n+     * <li>Integer</li>\n+     * </ul>\n+     *\n+     * @param val The value validation is being performed on.\n+     * @param decimalPointIndex Index of the decimal point in val. -1 if there isn't one.\n+     * @param octal       Whether or not the number is octal.\n+     * @param hex         Whether or not the number is hex.\n+     * @return The appropriate <code>Number</code> instance.\n+     */\n+    private static Number createNumber(final String val, final int decimalPointIndex,\n+            final boolean octal, final boolean hex) throws NumberFormatException {\n+        // if there is decimal point and no octal/hex prefix we check\n+        // which is the most appropriate type to use\n+        if (decimalPointIndex > -1 && !hex && !octal) {\n+            // if is less than max int length\n+            if (val.length() <= 10 + decimalPointIndex\n+                    && (decimalPointIndex <= 9 || decimalPointIndex == 10 && (val.charAt(0) == '1' || val.charAt(0) == '2'))) {\n+                return createInteger(val);\n+            }\n+            // if less than max long length\n+            if (val.length() <= 19 + decimalPointIndex\n+                    && (decimalPointIndex <= 18 || decimalPointIndex == 19 && val.startsWith(\"1\"))) {\n+                return createLong(val);\n+            }\n+            return createBigDecimal(val);\n+        }\n+\n+        final char lastChar = val.charAt(val.length() - 1);\n+\n+        // Treat empty String as zero.\n+        if (val.length() == 0) {\n+            return Integer.valueOf(0);\n+        }\n+\n+        // Use number valueOf methods for each relevant type\n+        if (hex) {\n+            if (val.length() > 16) {\n+                return createBigInteger(val);\n+            }\n+            if (val.length() > 8 || val.length()==8 && lastChar >= '8') {\n+                return createLong(val);\n+            }\n+            return createInteger(val);\n+        }\n+\n+        if (octal) {\n+            if (val.length() > 11) {\n+                return createBigInteger(val);\n+            }\n+            if (val.length() > 6 || val.length()==6 && lastChar >= '8') {\n+                return createInteger(val);\n+            }\n+            return createLong(val);\n+        }\n+\n+        // If number is negative, strip minus sign and recurse.\n+        if (val.charAt(0) == '-') {\n+            if (val.length() == 1) {\n+                throw new NumberFormatException(\"\\\"-\\\" is not a valid number.\");\n+            }\n+            return createNumber(val.substring(1), decimalPointIndex, octal, hex).negate();\n+        }\n+\n+        // Check for and remove leading zeros.\n+        int leadingZeroCount = 0;\n+        while (leadingZeroCount < val.length() && val.charAt(leadingZeroCount) == '0') {\n+            leadingZeroCount++;\n+        }\n+\n+        if (leadingZeroCount == val.length()) {\n+            // Leading zeros only constitute a legitimate number for values\n+            // of radix 1 (i.e., 0).\n+            return Integer.valueOf(0);\n+        }\n+\n+        // Attempt to parse as an int, since it's the most common case.\n+        if (decimalPointIndex == -1 && val.length() - leadingZeroCount <= 9) { //int\n+            final int i = Integer.parseInt(val);\n+            if (i >= 0 || leadingZeroCount <= 1 && val.charAt(0) == '-') {\n+                return Integer.valueOf(i);\n+            }\n+            // a negative number with too many leading zeros\n+            throw new NumberFormatException(val + \" is not a valid number.\");\n+        }\n+        if (decimalPointIndex == -1 && val.length() - leadingZeroCount <= 18) { //long\n+            final long l = Long.parseLong(val);\n+            if (l >= 0 || leadingZeroCount <= 1 && val.charAt(0) == '-') {\n+                return Long.valueOf(l);\n+            }\n+            // a negative number with too many leading zeros\n+            throw new NumberFormatException(val + \" is not a valid number.\");\n+        }\n+\n+        // If we're almost out of range for a positive value parse as a BigInteger.\n+        if (val.length() - leadingZeroCount > 18 && val.charAt(0) != '-') {\n+            return createBigInteger(val);\n+        }\n+\n+        // Overflowed into double or BigDecimal if there is a .\n+        // Fractional part makes number a BigDecimal regardless of size.\n+        if (decimalPointIndex > -1 || val.charAt(val.length() - 1) == 'd'\n+                || val.charAt(val.length() - 1) == 'D'\n+                || val.charAt(val.length() - 1) == 'f'\n+                || val.charAt(val.length() - 1) == 'F') {\n+            return createBigDecimal(val);\n+        }\n+\n+        // Parse as a long by default.\n+        return createLong(val);\n+    }\n+    /**\n+     * <p>Returns a new <code>BigDecimal</code> instance consisting of the\n+     * number represented by the specified <code>String</code>.  The\n+     * scale of the returned <code>BigDecimal</code> is the smallest value\n+     * such that (10<sup>scale</sup> &times; val) is an integer.</p>\n+     *\n+     * <p>This implementation is identical to NumberUtils.createBigDecimal(String).</p>\n+     *\n+     * @param val The value to convert to a <code>BigDecimal</code>.\n+     * @return The big decimal representation of <code>val</code>.\n+     * @throws NumberFormatException if <code>val</code> is not a valid number.\n+     * @see #createBigDecimal(String)\n+     * @since 3.2 Changed signature from createBigDecimal(String) to propagate exceptions\n+     */\n+    public static BigDecimal createBigDecimal(final String val) throws NumberFormatException {\n+\n+        try {\n+            // regular decimal representation\n+            return new BigDecimal(val);\n+        } catch (NumberFormatException originalException) {\n+            if (val == null) {\n+                throw originalException;\n+            }\n+            String noExponents = val.toUpperCase(Locale.ROOT);\n+\n+            boolean hasSign = false;\n+            char maybePlusChar = noExponents.charAt(0);\n+            if (maybePlusChar == '+') {\n+                hasSign = true;\n+                noExponents = noExponent\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}