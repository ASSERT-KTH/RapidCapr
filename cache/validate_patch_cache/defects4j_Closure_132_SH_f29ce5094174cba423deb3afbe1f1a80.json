{
    "patch": "              Node lhs = thenOp.getFirstChild();\n              if (areNodesEqualForInlining(lhs, elseOp.getFirstChild())) {\n                Node thenExpr = thenOp.removeFirstChild();\n                Node elseExpr = elseOp.getLastChild().detachFromParent();\n                cond.detachFromParent();\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n                                    .srcref(n);\n                Node assignNode = new Node(\n                    thenOp.getType(), lhs.detachFromParent(), hookNode)\n                                        .srcref(thenOp);\n                Node exprNode = NodeUtil.newExpr(assignNode);\n                parent.replaceChild(n, exprNode);\n                reportCodeChange();\n                return exprNode;\n              }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..61358121 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,21 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              Node lhs = thenOp.getFirstChild();\n+              if (areNodesEqualForInlining(lhs, elseOp.getFirstChild())) {\n+                Node thenExpr = thenOp.removeFirstChild();\n+                Node elseExpr = elseOp.getLastChild().detachFromParent();\n+                cond.detachFromParent();\n+                Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n+                                    .srcref(n);\n+                Node assignNode = new Node(\n+                    thenOp.getType(), lhs.detachFromParent(), hookNode)\n+                                        .srcref(thenOp);\n+                Node exprNode = NodeUtil.newExpr(assignNode);\n+                parent.replaceChild(n, exprNode);\n+                reportCodeChange();\n+                return exprNode;\n+              }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}