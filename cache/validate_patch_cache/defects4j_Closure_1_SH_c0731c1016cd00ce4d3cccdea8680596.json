{
    "patch": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    // Collect all arguments that are referenced at least once.\n    HashSet<String> referencedParamNames = new HashSet<>();\n    NodeTraversal.traverse(compiler, function, (NodeTraversal t, Node n, Node parent) -> {\n      if (NodeUtil.isParamList(n)) {\n        // In case the parameter list is a default value, visit the rhs of each PARAMETER_DEF.\n        Node firstChild = n.getFirstChild();\n        while (firstChild != null && firstChild.isDefaultValue()) {\n          ReferenceCollectingCallback referenceCollectingCallback =\n              new ReferenceCollectingCallback(\n                  referencedParamNames, true /* collectToplevelReferencesOnly */);\n          NodeTraversal.traverse(compiler, firstChild.getLastChild(), referenceCollectingCallback);\n          firstChild = firstChild.getFirstChild();\n          // remove the placeholder node created by Compiler#initCompiler for default parameters.\n          // First child is parameter name then comes the default value.\n          if (firstChild != null) {\n            firstChild.detachFromParent();\n            firstChild.detachChildren();\n          }\n        }\n      } else if (n.isName() && parent.isParamList()) {\n        referencedParamNames.add(n.getString());\n      }\n    });\n\n    if (referencedParamNames.isEmpty()) {\n      // remove the entire parameter list\n      Node firstChild = argList.getFirstChild();\n      argList.removeChildren();\n      // restore the first child, which is assigned its default value if necessary.\n      argList.addChildToFront(firstChild);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    IdentityHashMap<Node, Integer> references = new IdentityHashMap<>();\n    ArrayList<Node> keep = new ArrayList<>();\n    // Collect all unreferenced arguments in reverse order, so we can remove\n    // them without affecting the indices of remaining arguments.\n    for (Node arg = argList.getLastChild(); arg != null; arg = arg.getPrevious()) {\n      if (!arg.isName()) {\n        throw new IllegalStateException(\"Expected only NAMEs in parameter list\");\n      }\n      if (referencedParamNames.contains(arg.getString())) {\n        keep.add(arg);\n        references.put(arg, keep.size() - 1);\n      }\n    }\n\n    // Remove all unreferenced arguments in reverse order.\n    int nextReference = keep.size();\n    for (int i = argList.getChildCount() - 1; i >= 0; i--) {\n      Node arg = argList.getChildAt(i);\n      if (arg.isName() && !references.containsKey(arg)) {\n        argList.removeChildAt(i);\n        nextReference--;\n        // Replace a call like f(x, void 0) with f(x) (where x is the only referenced param).\n        // This applies only if we're compiling with `--aggressive_renaming`.\n        // It is actually more correct to remove these extra arguments before inlining, but it's\n        // less convenient for the final output.\n        if (compiler.getOptions().isAggressiveRenamingEnabled()) {\n          for (Node call : callSiteOptimizer.candidates) {\n            Node argPos = findArgumentNodeForParameterName(arg, call);\n            if (argPos != null) {\n              if (nextReference == 1 && keep.get(0).getString().equals(\"this\")) {\n                // If there's only one just-for-length param left, skip that one too.\n                compiler.reportCodeChange();\n                argPos.detachFromParent();\n              } else {\n                Node undefined = new Node(Token.VOID, new Node(Token.EMPTY));\n                undefined.srcrefTree(arg);\n                argPos.replaceWith(undefined);\n                compiler.reportCodeChange();\n              }\n            }\n          }\n        }\n      } else if (arg.isDefaultValue()) {\n        for (Node lhs : NodeUtil.findLhsNodesForDefaultValue(arg)) {\n          String name = lhs.getString();\n          Var var = fnScope.getVar(name);\n          if (var == null || !referencedParamNames.contains(name)) {\n            Node rhs = arg.getLastChild().detachFromParent();\n            Node decl = IR.var(lhs.cloneNode()).copyInformationFrom(lhs);\n            decl.getFirstChild().addChildToBack(rhs);\n            argList.getParent().addChildBefore(decl, argList);\n          } else {\n            keep.add(lhs);\n            references.put(lhs, keep.size() - 1);\n          }\n        }\n      }\n    }\n    argList.removeChildren();\n    for (Node n : Lists.reverse(keep)) {\n      argList.addChildToFront(n.detachFromParent());\n    }\n    compiler.reportCodeChange();\n  }\n\n  private Node findArgumentNodeForParameterName(Node param, Node call) {\n    Node argList = call.getSecondChild();\n    int i = 0;\n    for (Node c = argList.getFirstChild(); c != null; c = c.getNext()) {\n      if (param.matchesQualifiedName(c.getString())) {\n        return c;\n      } else if (c.getJSType() != null && c.getJSType().isNominalConstructor()) {\n        // Expand constructors. A call like `f(Ctor)` should also match `function(x) { return new Ctor(x) }`\n        // after removing the argument 'x'. It is actually a fairly common pattern in our libraries.\n        Node ctorDef = getEnclosingCtor(c.getJSType());\n        if (ctorDef != null) {\n          ConstructorTypeRegistry registry = compiler.getTypeRegistry().getConstructorTypeRegistry();\n          FunctionType ctor = (FunctionType) registry.getNamedType(ctorDef).getReference();\n          if (ctor.getParametersCount() == 1) {\n            Node newCtor = IR.newNode(IR.name(ctorDef.getFirstChild().getString()));\n            Node arg = new Node(Token.NAME, \"$arg$\" + i++);\n            newCtor.addChildToBack(arg);\n            Node parent = call.getParent();\n            Node exprResult = new Node(Token.EXPR_RESULT, newCtor);\n            // Currently, the --polymer_pass expects function call arguments to have quotes,\n            // so we need to accommodate that convention.\n            if (parent.isStringLit()) {\n              exprResult.putBooleanProp(Node.FREE_CALL, true);\n            }\n            parent.replaceChild(call, exprResult);\n            argList = newCtor.getLastChild();\n            i = updateCallSites(fnScope, new Node[]{arg}, ctor, false /* onlyOriginalCalls */);\n            if (i != 1) {\n              throw new IllegalStateException(\n                  \"Unexpected number of call sites replaced: \" + i + \", at \" + call);\n            }\n            return arg;\n          }\n        }\n      }\n    }\n    return null;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..f1a6c390 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,163 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n+    // Notice that removing unreferenced function args breaks\n+    // Function.prototype.length. In advanced mode, we don't really care\n+    // about this: we consider \"length\" the equivalent of reflecting on\n+    // the function's lexical source.\n+    //\n+    // Rather than create a new option for this, we assume that if the user\n+    // is removing globals, then it's OK to remove unused function args.\n+    //\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+\n+    Node function = fnScope.getRootNode();\n+\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    // Collect all arguments that are referenced at least once.\n+    HashSet<String> referencedParamNames = new HashSet<>();\n+    NodeTraversal.traverse(compiler, function, (NodeTraversal t, Node n, Node parent) -> {\n+      if (NodeUtil.isParamList(n)) {\n+        // In case the parameter list is a default value, visit the rhs of each PARAMETER_DEF.\n+        Node firstChild = n.getFirstChild();\n+        while (firstChild != null && firstChild.isDefaultValue()) {\n+          ReferenceCollectingCallback referenceCollectingCallback =\n+              new ReferenceCollectingCallback(\n+                  referencedParamNames, true /* collectToplevelReferencesOnly */);\n+          NodeTraversal.traverse(compiler, firstChild.getLastChild(), referenceCollectingCallback);\n+          firstChild = firstChild.getFirstChild();\n+          // remove the placeholder node created by Compiler#initCompiler for default parameters.\n+          // First child is parameter name then comes the default value.\n+          if (firstChild != null) {\n+            firstChild.detachFromParent();\n+            firstChild.detachChildren();\n+          }\n+        }\n+      } else if (n.isName() && parent.isParamList()) {\n+        referencedParamNames.add(n.getString());\n+      }\n+    });\n+\n+    if (referencedParamNames.isEmpty()) {\n+      // remove the entire parameter list\n+      Node firstChild = argList.getFirstChild();\n+      argList.removeChildren();\n+      // restore the first child, which is assigned its default value if necessary.\n+      argList.addChildToFront(firstChild);\n+      compiler.reportCodeChange();\n+      return;\n+    }\n+\n+    IdentityHashMap<Node, Integer> references = new IdentityHashMap<>();\n+    ArrayList<Node> keep = new ArrayList<>();\n+    // Collect all unreferenced arguments in reverse order, so we can remove\n+    // them without affecting the indices of remaining arguments.\n+    for (Node arg = argList.getLastChild(); arg != null; arg = arg.getPrevious()) {\n+      if (!arg.isName()) {\n+        throw new IllegalStateException(\"Expected only NAMEs in parameter list\");\n+      }\n+      if (referencedParamNames.contains(arg.getString())) {\n+        keep.add(arg);\n+        references.put(arg, keep.size() - 1);\n+      }\n+    }\n+\n+    // Remove all unreferenced arguments in reverse order.\n+    int nextReference = keep.size();\n+    for (int i = argList.getChildCount() - 1; i >= 0; i--) {\n+      Node arg = argList.getChildAt(i);\n+      if (arg.isName() && !references.containsKey(arg)) {\n+        argList.removeChildAt(i);\n+        nextReference--;\n+        // Replace a call like f(x, void 0) with f(x) (where x is the only referenced param).\n+        // This applies only if we're compiling with `--aggressive_renaming`.\n+        // It is actually more correct to remove these extra arguments before inlining, but it's\n+        // less convenient for the final output.\n+        if (compiler.getOptions().isAggressiveRenamingEnabled()) {\n+          for (Node call : callSiteOptimizer.candidates) {\n+            Node argPos = findArgumentNodeForParameterName(arg, call);\n+            if (argPos != null) {\n+              if (nextReference == 1 && keep.get(0).getString().equals(\"this\")) {\n+                // If there's only one just-for-length param left, skip that one too.\n+                compiler.reportCodeChange();\n+                argPos.detachFromParent();\n+              } else {\n+                Node undefined = new Node(Token.VOID, new Node(Token.EMPTY));\n+                undefined.srcrefTree(arg);\n+                argPos.replaceWith(undefined);\n+                compiler.reportCodeChange();\n+              }\n+            }\n+          }\n+        }\n+      } else if (arg.isDefaultValue()) {\n+        for (Node lhs : NodeUtil.findLhsNodesForDefaultValue(arg)) {\n+          String name = lhs.getString();\n+          Var var = fnScope.getVar(name);\n+          if (var == null || !referencedParamNames.contains(name)) {\n+            Node rhs = arg.getLastChild().detachFromParent();\n+            Node decl = IR.var(lhs.cloneNode()).copyInformationFrom(lhs);\n+            decl.getFirstChild().addChildToBack(rhs);\n+            argList.getParent().addChildBefore(decl, argList);\n+          } else {\n+            keep.add(lhs);\n+            references.put(lhs, keep.size() - 1);\n+          }\n+        }\n+      }\n+    }\n+    argList.removeChildren();\n+    for (Node n : Lists.reverse(keep)) {\n+      argList.addChildToFront(n.detachFromParent());\n+    }\n+    compiler.reportCodeChange();\n+  }\n+\n+  private Node findArgumentNodeForParameterName(Node param, Node call) {\n+    Node argList = call.getSecondChild();\n+    int i = 0;\n+    for (Node c = argList.getFirstChild(); c != null; c = c.getNext()) {\n+      if (param.matchesQualifiedName(c.getString())) {\n+        return c;\n+      } else if (c.getJSType() != null && c.getJSType().isNominalConstructor()) {\n+        // Expand constructors. A call like `f(Ctor)` should also match `function(x) { return new Ctor(x) }`\n+        // after removing the argument 'x'. It is actually a fairly common pattern in our libraries.\n+        Node ctorDef = getEnclosingCtor(c.getJSType());\n+        if (ctorDef != null) {\n+          ConstructorTypeRegistry registry = compiler.getTypeRegistry().getConstructorTypeRegistry();\n+          FunctionType ctor = (FunctionType) registry.getNamedType(ctorDef).getReference();\n+          if (ctor.getParametersCount() == 1) {\n+            Node newCtor = IR.newNode(IR.name(ctorDef.getFirstChild().getString()));\n+            Node arg = new Node(Token.NAME, \"$arg$\" + i++);\n+            newCtor.addChildToBack(arg);\n+            Node parent = call.getParent();\n+            Node exprResult = new Node(Token.EXPR_RESULT, newCtor);\n+            // Currently, the --polymer_pass expects function call arguments to have quotes,\n+            // so we need to accommodate that convention.\n+            if (parent.isStringLit()) {\n+              exprResult.putBooleanProp(Node.FREE_CALL, true);\n+            }\n+            parent.replaceChild(call, exprResult);\n+            argList = newCtor.getLastChild();\n+            i = updateCallSites(fnScope, new Node[]{arg}, ctor, false /* onlyOriginalCalls */);\n+            if (i != 1) {\n+              throw new IllegalStateException(\n+                  \"Unexpected number of call sites replaced: \" + i + \", at \" + call);\n+            }\n+            return arg;\n+          }\n+        }\n+      }\n+    }\n+    return null;\n+  }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}