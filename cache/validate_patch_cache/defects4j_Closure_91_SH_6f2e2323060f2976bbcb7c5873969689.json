{
    "patch": "      if (parent != null && parent.getType() == Token.ASSIGN) {\n          Node lhs = parent.getFirstChild();\n\n          if (lhs == null || !NodeUtil.isGet(lhs)) {\n              return true;\n          }\n\n          Node grandParent = parent.getParent();\n\n          if (grandParent == null || grandParent.getType() != Token.EXPR_RESULT) {\n              return true;\n          }\n\n          Node greatGrandParent = grandParent.getParent();\n\n          if (greatGrandParent == null || greatGrandParent.getType() != Token.BLOCK ||\n                  !NodeUtil.isControlStructure(greatGrandParent.getParent())) {\n              return true;\n          }\n\n          Node rhs = lhs.getNext();\n\n          if (rhs == null || rhs.getNext() != n) {\n              return true;\n          }\n\n          Node rightMost = NodeUtil.getRValueOfLValue(lhs);\n\n          if (rightMost == null || !NodeUtil.isObjectLitKey(rightMost) ||\n                  !rightMost.getString().equals(\"prototype\")) {\n              return true;\n          }\n\n          // Do not traverse functions that are getting lent to a prototype via chaining.\n          Node target = lhs.getFirstChild();\n\n          while (target != null && NodeUtil.isGet(target)) {\n              target = target.getFirstChild();\n          }\n\n          return target == null ||\n                  !(target.matchesQualifiedName(\"Object\") &&\n                          rhs.matchesQualifiedName(\"assignProperties\"));\n      }\n\n      return true;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..9d3114f0 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,52 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      if (parent != null && parent.getType() == Token.ASSIGN) {\n+          Node lhs = parent.getFirstChild();\n+\n+          if (lhs == null || !NodeUtil.isGet(lhs)) {\n+              return true;\n+          }\n+\n+          Node grandParent = parent.getParent();\n+\n+          if (grandParent == null || grandParent.getType() != Token.EXPR_RESULT) {\n+              return true;\n+          }\n+\n+          Node greatGrandParent = grandParent.getParent();\n+\n+          if (greatGrandParent == null || greatGrandParent.getType() != Token.BLOCK ||\n+                  !NodeUtil.isControlStructure(greatGrandParent.getParent())) {\n+              return true;\n+          }\n+\n+          Node rhs = lhs.getNext();\n+\n+          if (rhs == null || rhs.getNext() != n) {\n+              return true;\n+          }\n+\n+          Node rightMost = NodeUtil.getRValueOfLValue(lhs);\n+\n+          if (rightMost == null || !NodeUtil.isObjectLitKey(rightMost) ||\n+                  !rightMost.getString().equals(\"prototype\")) {\n+              return true;\n+          }\n+\n+          // Do not traverse functions that are getting lent to a prototype via chaining.\n+          Node target = lhs.getFirstChild();\n+\n+          while (target != null && NodeUtil.isGet(target)) {\n+              target = target.getFirstChild();\n+          }\n+\n+          return target == null ||\n+                  !(target.matchesQualifiedName(\"Object\") &&\n+                          rhs.matchesQualifiedName(\"assignProperties\"));\n+      }\n+\n+      return true;\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}