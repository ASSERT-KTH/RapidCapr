{
    "patch": "//---------------------------------------------------------------------------------\n// Public methods\n//---------------------------------------------------------------------------------\n\n/**\n * Gets the source region corresponding to the given source name and line number.\n *\n * @return The source region, or null if the source file is not found or the\n * line number is less than 1.\n */\npublic SourceRegion getSourceRegion(String sourceName, int lineNumber) {\n  if (lineNumber < 1) {\n    return null;\n  }\n  for (CompilerInput input : inputsById.values()) {\n    if (input.getName().equals(sourceName)) {\n      return input.getSourceFile().getRegion(lineNumber);\n    }\n  }\n  return null;\n}\n\n//---------------------------------------------------------------------------------\n// Package-private methods\n//---------------------------------------------------------------------------------\n\n/**\n * Computes the parse tree for all inputs. Reports errors and warnings to the error\n * manager.\n *\n * @param symbols the symbol table used to\n * ensure unique names within a scope.\n * @param gatherExternProperties Whether variable declarations in externs files should\n * produce properties rather than variables.\n * @param idGenerator State for generating unique IDs.\n * Alternatively, a cached ID generator can be passed as this argument to speed up tests.\n */\nvoid parseInputs(\n    Scope symbols, boolean gatherExternProperties, IdGenerator idGenerator) {\n  Preconditions.checkNotNull(symbols);\n  Preconditions.checkNotNull(idGenerator);\n\n  for (CompilerInput input : inputsById.values()) {\n    if (input.isExtern() == gatherExternProperties) { // process only externs or non externs\n      CompilerProgressIndicator progress =\n          new CompilerProgressIndicator(\n              input.getName(), input.getSourceFile().getOriginalPath(), options);\n      try {\n        JSError[] parseWarnings = input.getParseWarnings();\n        for (JSError warning : parseWarnings) {\n          progress.reportWarning(warning);\n        }\n\n        if (input.isOnDisk()) {\n          input.getSourceFile().setKind(SourceKind.STRONG);\n        }\n\n        AbstractCompiler compiler = createInternalCompiler();\n        CompilerPass parseInput =\n            new JsAstParser(compiler, input).withProgress(progress::progress);\n\n        codingConvention.resetCache();\n        runInCompilerThread(compiler, () -> {\n          parseInput.process(externsRoot, inputRoot);\n          // Only compile this input, not the whole AST, in pedantic mode.\n          check(input.getJsAst());\n        });\n      } catch (Throwable t) {\n        reportInternalError(input.getName(), null, t);\n      } finally {\n        progress.stop();\n      }\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..90cdff48 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,112 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n+  public Region getSourceRegion(String sourceName, int lineNumber) {\n+    if (lineNumber < 1) {\n+      return null;\n+    }\n+    SourceFile input = getSourceFileByName(sourceName);\n+    if (input != null) {\n+      return input.getRegion(lineNumber);\n+    }\n+    return null;\n+  }\n \n-    checkFirstModule(modules);\n+  //------------------------------------------------------------------------\n+  // Package-private helpers\n+  //------------------------------------------------------------------------\n \n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n+  @Override\n+  Node getNodeForCodeInsertion(JSModule module) {\n+    if (module == null) {\n+      if (inputs.length == 0) {\n+        throw new IllegalStateException(\"No inputs\");\n+      }\n+\n+      return inputs[0].getAstRoot(this);\n     }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n \n-    initInputsByNameMap();\n-  }\n+    List<CompilerInput> inputs = module.getInputs();\n+    if (inputs.size() > 0) {\n+      return inputs.get(0).getAstRoot(this);\n+    }\n+//---------------------------------------------------------------------------------\n+// Public methods\n+//---------------------------------------------------------------------------------\n \n-  /**\n-   * Do any initialization that is dependent on the compiler options.\n-   */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+/**\n+ * Gets the source region corresponding to the given source name and line number.\n+ *\n+ * @return The source region, or null if the source file is not found or the\n+ * line number is less than 1.\n+ */\n+public SourceRegion getSourceRegion(String sourceName, int lineNumber) {\n+  if (lineNumber < 1) {\n+    return null;\n+  }\n+  for (CompilerInput input : inputsById.values()) {\n+    if (input.getName().equals(sourceName)) {\n+      return input.getSourceFile().getRegion(lineNumber);\n     }\n   }\n+  return null;\n+}\n+\n+//---------------------------------------------------------------------------------\n+// Package-private methods\n+//---------------------------------------------------------------------------------\n+\n+/**\n+ * Computes the parse tree for all inputs. Reports errors and warnings to the error\n+ * manager.\n+ *\n+ * @param symbols the symbol table used to\n+ * ensure unique names within a scope.\n+ * @param gatherExternProperties Whether variable declarations in externs files should\n+ * produce properties rather than variables.\n+ * @param idGenerator State for generating unique IDs.\n+ * Alternatively, a cached ID generator can be passed as this argument to speed up tests.\n+ */\n+void parseInputs(\n+    Scope symbols, boolean gatherExternProperties, IdGenerator idGenerator) {\n+  Preconditions.checkNotNull(symbols);\n+  Preconditions.checkNotNull(idGenerator);\n+\n+  for (CompilerInput input : inputsById.values()) {\n+    if (input.isExtern() == gatherExternProperties) { // process only externs or non externs\n+      CompilerProgressIndicator progress =\n+          new CompilerProgressIndicator(\n+              input.getName(), input.getSourceFile().getOriginalPath(), options);\n+      try {\n+        JSError[] parseWarnings = input.getParseWarnings();\n+        for (JSError warning : parseWarnings) {\n+          progress.reportWarning(warning);\n+        }\n+\n+        if (input.isOnDisk()) {\n+          input.getSourceFile().setKind(SourceKind.STRONG);\n+        }\n \n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n+        AbstractCompiler compiler = createInternalCompiler();\n+        CompilerPass parseInput =\n+            new JsAstParser(compiler, input).withProgress(progress::progress);\n+\n+        codingConvention.resetCache();\n+        runInCompilerThread(compiler, () -> {\n+          parseInput.process(externsRoot, inputRoot);\n+          // Only compile this input, not the whole AST, in pedantic mode.\n+          check(input.getJsAst());\n+        });\n+      } catch (Throwable t) {\n+        reportInternalError(input.getName(), null, t);\n+      } finally {\n+        progress.stop();\n+      }\n+    }\n+  }\n+}\n+    throw new IllegalStateException(\"Root module has no inputs\");\n+  }\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}