{
    "patch": "public class IRFactory extends AstNodeFactory {\n\n  private final List<String> ALLOWED_DIRECTIVES =\n      Arrays.asList(\"use strict\", \"use asm\", \"use strict asm\");\n\n  private final SourceInfo sourceName;\n  private final ErrorReporter errorReporter;\n  private final UniqueIdGenerator uniqueIdGenerator;\n\n  private int tempVarCount = 0;\n\n  public IRFactory(SourceInfo sourceName, ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.errorReporter = errorReporter;\n    this.uniqueIdGenerator = new UniqueIdGenerator();\n  }\n\n  private String createTempName() {\n    return \"tmp$\" + uniqueIdGenerator.getNextUniqueId();\n  }\n\n  private class TransformDispatcher implements TypeSafeDispatcher {\n    @Override\n    public Node process(ArrayComprehension node) {\n      throw new UnsupportedOperationException(\"Array comprehensions are not supported\");\n    }\n\n    @Override\n    public Node process(ArrayComprehensionLoop node) {\n      throw new UnsupportedOperationException(\"Array comprehensions are not supported\");\n    }\n\n    @Override\n    public Node process(ArrayLiteral node) {\n      Node arrayNode = newNode(Token.ARRAYLIT);\n      for (AstNode element : node.getElements()) {\n        if (element == null) {\n          arrayNode.addChildToBack(newNode(Token.EMPTY));\n        } else {\n          arrayNode.addChildToBack(transform(element));\n        }\n      }\n      return arrayNode;\n    }\n\n    @Override\n    public Node process(Assignment node) {\n      return newNode(\n          node.getLineno(),\n          transform(node.getLeft()),\n          transform(node.getRight()));\n    }\n\n    @Override\n    public Node process(AstRoot node) {\n      return processGeneric(node);\n    }\n\n    @Override\n    public Node process(Block node) {\n      return processGeneric(node);\n    }\n\n    @Override\n    public Node process(BreakStatement node) {\n      Node breakNode = newNode(Token.BREAK);\n      String label = node.getBreakLabel();\n      if (label != null) {\n        breakNode.putProp(Node.LABEL_NAME_PROP, label);\n      }\n      return breakNode;\n    }\n\n    @Override\n    public Node process(CaseClause node) {\n      Node caseNode = newNode(Token.CASE);\n      caseNode.addChildToBack(transform(node.getExpression()));\n      Node statementsList = IR.block();\n      for (AstNode statement : node.getStatements()) {\n        statementsList.addChildToBack(transform(statement));\n      }\n      caseNode.addChildToBack(statementsList);\n      return caseNode;\n    }\n\n    @Override\n    public Node process(CatchClause node) {\n      Node catchNode = newNode(Token.CATCH);\n      catchNode.putProp(Node.EXCEPTION_TYPE_PROP, node.getExceptionType());\n      if (node.getVarName() != null) {\n        catchNode.addChildToBack(transform(node.getVarName()));\n      }\n      catchNode.addChildToBack(transform(node.getBody()));\n      return catchNode;\n    }\n\n    @Override\n    public Node process(ConstantWrapper node) {\n      return newNode(Token.NUMBER, Double.toString(node.getDouble()));\n    }\n\n    @Override\n    public Node process(ContinueStatement node) {\n      Node continueNode = newNode(Token.CONTINUE);\n      String label = node.getLabel();\n      if (label != null) {\n        continueNode.putProp(Node.LABEL_NAME_PROP, label);\n      }\n      return continueNode;\n    }\n\n    @Override\n    public Node process(Directive node) {\n      return IR.empty().putProp(Node.DIRECTIVE_PROP, node.getValue());\n    }\n\n    @Override\n    public Node process(DoLoop node) {\n      Node doNode = newNode(Token.DO, transform(node.getBody()));\n      doNode.addChildToBack(transform(node.getCondition()));\n      return doNode;\n    }\n\n    @Override\n    public Node process(EmptyExpression node) {\n      return newNode(Token.EMPTY);\n    }\n\n    @Override\n    public Node process(ExpressionStatement node) {\n      Node exprNode = transform(node.getExpression());\n      int tokenType = transformTokenType(node.getType());\n      if (exprNode.getType() == Token.FUNCTION && tokenType == Token.FUNCTION) {\n        return exprNode;\n      }\n      return newNode(tokenType, exprNode);\n    }\n\n    @Override\n    public Node process(ForInLoop node) {\n      AstNode left = node.getIterator();\n      Node right = transform(node.getIteratedObject());\n      Node body = transform(node.getBody());\n      if (left instanceof DestructuringForm) {\n        DestructuringForm destructuringForm = (DestructuringForm) left;\n        Node expressions = newNode(Token.EXPRESSION_LIST);\n        Node tmpVar = IR.name(createTempName());\n        tmpVar.putProp(Node.IS_NAMESPACE, true);\n        Node tmpVarDecl =\n            newNode(\n                Token.VAR,\n                newNode(\n                    Token.LET, IR.name(destructuringForm.getTarget().getString()), tmpVar.cloneNode()),\n                right.cloneNode());\n        Node leftSide = IR.assign(destructuringForm.getTarget().cloneNode(), tmpVar.cloneNode());\n        expressions.addChildToBack(leftSide);\n        expressions.addChildToBack(tmpVarDecl);\n        Node whileNode = IR.whileNode(IR.trueNode(), newNode(Token.BLOCK, body.cloneNode()));\n        expressions.addChildToBack(whileNode);\n        return expressions;\n      }\n      Node header =\n          newNode(Token.FOR, transform(left), right.cloneNode(), newNode(Token.EMPTY));\n      Node[] kids = {header, body.cloneNode()};\n      return newNode(Token.BLOCK, kids);\n    }\n\n    @Override\n    public Node process(ForLoop node) {\n      Node header = newNode(Token.FOR);\n      header.addChildToBack(transform(node.getInitializer()));\n      header.addChildToBack(transform(node.getCondition()));\n      header.addChildToBack(transform(node.getIncrement()));\n      Node[] kids = {header, transform(node.getBody()).cloneNode()};\n      return newNode(Token.BLOCK, kids);\n    }\n\n    @Override\n    public Node process(FunctionCall node) {\n      Node functionNode = transform(node.getTarget());\n      ArgumentList argList = node.getArguments();\n      Node argNode = node.isNew() ? newNode(Token.NEW) : newNode(Token.CALL);\n      argNode.addChildToBack(functionNode);\n      for (AstNode arg : argList) {\n        argNode.addChildToBack(transform(arg));\n      }\n      return argNode;\n    }\n\n    @Override\n    public Node process(FunctionNode node) {\n      Node fNode = newNode(Token.FUNCTION);\n      if (node.getFunctionName() != null) {\n        Node name = IR.name(node.getName());\n        name.putProp(Node.IS_NAMESPACE, true);\n        fNode.addChildToBack(name);\n      }\n      Node argNode = newNode(Token.PARAM_LIST);\n      fNode.addChildToBack(argNode);\n      AstNode params = node.getParams();\n      for (int i = 0; i < params.getLength(); i++) {\n        ArgSlot param = (ArgSlot) params.get(i);\n        Node paramNode = newNode(Token.NAME, param.getName());\n        argNode.addChildToBack(paramNode);\n      }\n      fNode.addChildToBack(transform(node.getBody()));\n      return fNode;\n    }\n\n    @Override\n    public Node process(GeneratorExpression node) {\n      throw new UnsupportedOperationException(\"Generator expressions are not supported\");\n    }\n\n    @Override\n    public Node process(GetPropExpression node) {\n      return newNode(Token.GETPROP, transform(node.getTarget()), IR.string(node.getProperty()));\n    }\n\n    @Override\n    public Node process(IfStatement node) {\n      Node ifNode = newNode(Token.IF);\n      ifNode.addChildToBack(transform(node.getCondition()));\n      ifNode.addChildToBack(transform(node.getThenPart()));\n      if (node.getElsePart() != null) {\n        ifNode.addChildToBack(transform(node.getElsePart()));\n      }\n      return ifNode;\n    }\n\n    @Override\n    public Node process(InfixExpression node) {\n      int type = transformTokenType(node.getType());\n      if (type == Token.ASSIGN) {\n        Node left = transform(node.getLeft());\n        if (left.getType() == Token.GETPROPLHS || left.getType() == Token.GETELEMLHS) {\n          Node[] kids = {\n            newNode(Token.SETELEM, transform(((InfixExpression) left).getLeft()), transform(((InfixExpression) left).getRight()), transform(node.getRight()))\n          };\n          return newNode(Token.BLOCK, kids);\n        }\n      }\n      if (type == Token.COMMA) {\n        Node leftSide = transform(node.getLeft());\n        Node rightSide = transform(node.getRight());\n        if (leftSide.getType() == Token.BLOCK) {\n          leftSide.addChildToBack(rightSide);\n          return leftSide;\n        } else {\n          Node[] kids = {leftSide, rightSide};\n          return newNode(Token.COMMA, kids);\n        }\n      }\n      return newNode(\n          transformTokenType(node.getType()),\n          transform(node.getLeft()),\n          transform(node.getRight()));\n    }\n\n    @Override\n    public Node process(JSModule node) {\n      throw new UnsupportedOperationException(\"ES6 modules are not supported\");\n    }\n\n    @Override\n    public Node process(LabeledStatement node) {\n      Node labelNode =\n          newNode(Token.LABEL, IR.name(node.getLabelName()), transform(node.getStatement()));\n      return labelNode;\n    }\n\n    @Override\n    public Node process(LetNode node) {\n      throw new UnsupportedOperationException(\"let/const declarations are not supported\");\n    }\n\n    @Override\n    public Node process(Literal node) {\n      return newNode(transformTokenType(node.getType()), node.getValue());\n    }\n\n    @Override\n    public Node process(Name node) {\n      return newNode(Token.NAME, node.getIdentifier());\n    }\n\n    @Override\n    public Node process(NewExpression node) {\n      Node callNode = newNode(Token.NEW);\n      callNode.addChildToBack(transform(node.getTarget()));\n      ArgumentList argList = node.getArguments();\n      if (argList != null) {\n        for (AstNode arg : argList) {\n          callNode.addChildToBack(transform(arg));\n        }\n      }\n      return callNode;\n    }\n\n    @Override\n    public Node process(NumberLiteral node) {\n      return newNode(Token.NUMBER, node.getNumber());\n    }\n\n    @Override\n    public Node process(ObjectLiteral node) {\n      Node objectNode = newNode(Token.OBJECTLIT);\n      List<ObjectProperty> elements = node.getElements();\n      for (ObjectProperty element : elements) {\n        Node keyNode;\n        if (element.getLeft() instanceof StringLiteral) {\n          String key = ((StringLiteral) element.getLeft()).getValue();\n          keyNode = IR.string(key);\n        } else if (element.getLeft() instanceof Name) {\n          String key = ((Name) element.getLeft()).getIdentifier();\n          keyNode = IR.string(key);\n        } else {\n          keyNode = transform(element.getLeft());\n        }\n        Node valueNode = transform(element.getRight());\n        objectNode.addChildToBack(newNode(Token.PROPERTY, keyNode, valueNode));\n      }\n      return objectNode;\n    }\n\n    @Override\n    public Node process(ObjectProperty node) {\n      throw new IllegalStateException(\"Should be part of processing an ObjectLiteral\");\n    }\n\n    @Override\n    public Node process(ParenthesizedExpression node) {\n      return transform(node.getExpression());\n    }\n\n    @Override\n    public Node process(RegExpLiteral node) {\n      return newNode(Token.REGEXP, node.getValue(), node.getFlags());\n    }\n\n    @Override\n    public Node process(ReturnStatement node) {\n      return newNode(transformTokenType(node.getType()), transform(node.getReturnValue()));\n    }\n\n    @Override\n    public Node process(Scope node) {\n      throw new IllegalStateException(\"Not supported\");\n    }\n\n    @Override\n    public Node process(ScriptNode node) {\n      return processGeneric(node);\n    }\n\n    @Override\n    public Node process(StringLiteral node) {\n      return newNode(Token.STRING, node.getValue());\n    }\n\n    @Override\n    public Node process(SwitchCase node) {\n      Node caseBlock =\n          newNode(\n              Token.BLOCK,\n              transformArray(node.getStatements()).toArray(new Node[node.getStatements().size()]));\n      if (node.getExpression() == null) {\n        return caseBlock;\n      } else {\n        Node matchNode = newNode(Token.EQ, transform(node.getExpression()), createUndefinedNode());\n        Node caseNode = newNode(Token.CASE, matchNode);\n        caseNode.addChildToBack(caseBlock);\n        return caseNode;\n      }\n    }\n\n    @Override\n    public Node process(SwitchStatement node) {\n      Node switchNode = newNode(Token.SWITCH, transform(node.getExpression()));\n      List<SwitchCase> cases = node.getCases();\n      for (SwitchCase aCase : cases) {\n        switchNode.addChildToBack(transform(aCase));\n      }\n      return switchNode;\n    }\n\n    @Override\n    public Node process(ThrowStatement node) {\n      return newNode(transformTokenType(node.getType()), transform(node.getExpression()));\n    }\n\n    @Override\n    public Node process(TryStatement node) {\n      Node tryNode = newNode(Token.TRY, transformBlock(node.getTryBlock()));\n      if (node.getCatchBlock() != null) {\n        Node catchNode = newNode(Token.CATCH, transform(node.getCatchParameter()));\n        catchNode.addChildToBack(transformBlock(node.getCatchBlock()));\n        tryNode.addChildToBack(catchNode);\n      }\n      if (node.getFinallyBlock() != null) {\n        tryNode.addChildToBack(transformBlock(node.getFinallyBlock()));\n      }\n      return tryNode;\n    }\n\n    @Override\n    public Node process(UnaryExpression node) {\n      int type = transformTokenType(node.getType());\n      if (type == Token.TYPEOF || type == Token.VOID || type == Token.NOT) {\n        return newNode(transformTokenType(node.getType()), transform(node.getOperand()));\n      }\n      if (type == Token.DELPROP && node.getOperand() instanceof Name) {\n        return newNode(Token.UNARYDEL, IR.string(((Name) node.getOperand()).getIdentifier()));\n      }\n      return newNode(transformTokenType(node.getType()), transform(node.getOperand()));\n    }\n\n    @Override\n    public Node process(VariableDeclaration node) {\n      String typeString;\n      switch (node.getType()) {\n        case Token.VAR:\n          typeString = \"var\";",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..eeaf73e0 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,430 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory extends AstNodeFactory {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private final List<String> ALLOWED_DIRECTIVES =\n+      Arrays.asList(\"use strict\", \"use asm\", \"use strict asm\");\n+\n+  private final SourceInfo sourceName;\n+  private final ErrorReporter errorReporter;\n+  private final UniqueIdGenerator uniqueIdGenerator;\n+\n+  private int tempVarCount = 0;\n+\n+  public IRFactory(SourceInfo sourceName, ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.errorReporter = errorReporter;\n+    this.uniqueIdGenerator = new UniqueIdGenerator();\n+  }\n+\n+  private String createTempName() {\n+    return \"tmp$\" + uniqueIdGenerator.getNextUniqueId();\n+  }\n+\n+  private class TransformDispatcher implements TypeSafeDispatcher {\n+    @Override\n+    public Node process(ArrayComprehension node) {\n+      throw new UnsupportedOperationException(\"Array comprehensions are not supported\");\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node process(ArrayComprehensionLoop node) {\n+      throw new UnsupportedOperationException(\"Array comprehensions are not supported\");\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public Node process(ArrayLiteral node) {\n+      Node arrayNode = newNode(Token.ARRAYLIT);\n+      for (AstNode element : node.getElements()) {\n+        if (element == null) {\n+          arrayNode.addChildToBack(newNode(Token.EMPTY));\n+        } else {\n+          arrayNode.addChildToBack(transform(element));\n+        }\n       }\n-      return node;\n+      return arrayNode;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    public Node process(Assignment node) {\n+      return newNode(\n+          node.getLineno(),\n+          transform(node.getLeft()),\n+          transform(node.getRight()));\n+    }\n+\n+    @Override\n+    public Node process(AstRoot node) {\n+      return processGeneric(node);\n+    }\n+\n+    @Override\n+    public Node process(Block node) {\n+      return processGeneric(node);\n+    }\n+\n+    @Override\n+    public Node process(BreakStatement node) {\n+      Node breakNode = newNode(Token.BREAK);\n+      String label = node.getBreakLabel();\n+      if (label != null) {\n+        breakNode.putProp(Node.LABEL_NAME_PROP, label);\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+      return breakNode;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public Node process(CaseClause node) {\n+      Node caseNode = newNode(Token.CASE);\n+      caseNode.addChildToBack(transform(node.getExpression()));\n+      Node statementsList = IR.block();\n+      for (AstNode statement : node.getStatements()) {\n+        statementsList.addChildToBack(transform(statement));\n+      }\n+      caseNode.addChildToBack(statementsList);\n+      return caseNode;\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public Node process(CatchClause node) {\n+      Node catchNode = newNode(Token.CATCH);\n+      catchNode.putProp(Node.EXCEPTION_TYPE_PROP, node.getExceptionType());\n+      if (node.getVarName() != null) {\n+        catchNode.addChildToBack(transform(node.getVarName()));\n       }\n-      return node;\n+      catchNode.addChildToBack(transform(node.getBody()));\n+      return catchNode;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node process(ConstantWrapper node) {\n+      return newNode(Token.NUMBER, Double.toString(node.getDouble()));\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node process(ContinueStatement node) {\n+      Node continueNode = newNode(Token.CONTINUE);\n+      String label = node.getLabel();\n+      if (label != null) {\n+        continueNode.putProp(Node.LABEL_NAME_PROP, label);\n+      }\n+      return continueNode;\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node process(Directive node) {\n+      return IR.empty().putProp(Node.DIRECTIVE_PROP, node.getValue());\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node process(DoLoop node) {\n+      Node doNode = newNode(Token.DO, transform(node.getBody()));\n+      doNode.addChildToBack(transform(node.getCondition()));\n+      return doNode;\n+    }\n+\n+    @Override\n+    public Node process(EmptyExpression node) {\n+      return newNode(Token.EMPTY);\n+    }\n+\n+    @Override\n+    public Node process(ExpressionStatement node) {\n+      Node exprNode = transform(node.getExpression());\n+      int tokenType = transformTokenType(node.getType());\n+      if (exprNode.getType() == Token.FUNCTION && tokenType == Token.FUNCTION) {\n+        return exprNode;\n+      }\n+      return newNode(tokenType, exprNode);\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node process(ForInLoop node) {\n+      AstNode left = node.getIterator();\n+      Node right = transform(node.getIteratedObject());\n+      Node body = transform(node.getBody());\n+      if (left instanceof DestructuringForm) {\n+        DestructuringForm destructuringForm = (DestructuringForm) left;\n+        Node expressions = newNode(Token.EXPRESSION_LIST);\n+        Node tmpVar = IR.name(createTempName());\n+        tmpVar.putProp(Node.IS_NAMESPACE, true);\n+        Node tmpVarDecl =\n+            newNode(\n+                Token.VAR,\n+                newNode(\n+                    Token.LET, IR.name(destructuringForm.getTarget().getString()), tmpVar.cloneNode()),\n+                right.cloneNode());\n+        Node leftSide = IR.assign(destructuringForm.getTarget().cloneNode(), tmpVar.cloneNode());\n+        expressions.addChildToBack(leftSide);\n+        expressions.addChildToBack(tmpVarDecl);\n+        Node whileNode = IR.whileNode(IR.trueNode(), newNode(Token.BLOCK, body.cloneNode()));\n+        expressions.addChildToBack(whileNode);\n+        return expressions;\n+      }\n+      Node header =\n+          newNode(Token.FOR, transform(left), right.cloneNode(), newNode(Token.EMPTY));\n+      Node[] kids = {header, body.cloneNode()};\n+      return newNode(Token.BLOCK, kids);\n+    }\n+\n+    @Override\n+    public Node process(ForLoop node) {\n+      Node header = newNode(Token.FOR);\n+      header.addChildToBack(transform(node.getInitializer()));\n+      header.addChildToBack(transform(node.getCondition()));\n+      header.addChildToBack(transform(node.getIncrement()));\n+      Node[] kids = {header, transform(node.getBody()).cloneNode()};\n+      return newNode(Token.BLOCK, kids);\n+    }\n+\n+    @Override\n+    public Node process(FunctionCall node) {\n+      Node functionNode = transform(node.getTarget());\n+      ArgumentList argList = node.getArguments();\n+      Node argNode = node.isNew() ? newNode(Token.NEW) : newNode(Token.CALL);\n+      argNode.addChildToBack(functionNode);\n+      for (AstNode arg : argList) {\n+        argNode.addChildToBack(transform(arg));\n+      }\n+      return argNode;\n+    }\n+\n+    @Override\n+    public Node process(FunctionNode node) {\n+      Node fNode = newNode(Token.FUNCTION);\n+      if (node.getFunctionName() != null) {\n+        Node name = IR.name(node.getName());\n+        name.putProp(Node.IS_NAMESPACE, true);\n+        fNode.addChildToBack(name);\n+      }\n+      Node argNode = newNode(Token.PARAM_LIST);\n+      fNode.addChildToBack(argNode);\n+      AstNode params = node.getParams();\n+      for (int i = 0; i < params.getLength(); i++) {\n+        ArgSlot param = (ArgSlot) params.get(i);\n+        Node paramNode = newNode(Token.NAME, param.getName());\n+        argNode.addChildToBack(paramNode);\n+      }\n+      fNode.addChildToBack(transform(node.getBody()));\n+      return fNode;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n+    @Override\n+    public Node process(GeneratorExpression node) {\n+      throw new UnsupportedOperationException(\"Generator expressions are not supported\");\n+    }\n+\n+    @Override\n+    public Node process(GetPropExpression node) {\n+      return newNode(Token.GETPROP, transform(node.getTarget()), IR.string(node.getProperty()));\n+    }\n+\n+    @Override\n+    public Node process(IfStatement node) {\n+      Node ifNode = newNode(Token.IF);\n+      ifNode.addChildToBack(transform(node.getCondition()));\n+      ifNode.addChildToBack(transform(node.getThenPart()));\n+      if (node.getElsePart() != null) {\n+        ifNode.addChildToBack(transform(node.getElsePart()));\n+      }\n+      return ifNode;\n+    }\n+\n+    @Override\n+    public Node process(InfixExpression node) {\n+      int type = transformTokenType(node.getType());\n+      if (type == Token.ASSIGN) {\n+        Node left = transform(node.getLeft());\n+        if (left.getType() == Token.GETPROPLHS || left.getType() == Token.GETELEMLHS) {\n+          Node[] kids = {\n+            newNode(Token.SETELEM, transform(((InfixExpression) left).getLeft()), transform(((InfixExpression) left).getRight()), transform(node.getRight()))\n+          };\n+          return newNode(Token.BLOCK, kids);\n+        }\n+      }\n+      if (type == Token.COMMA) {\n+        Node leftSide = transform(node.getLeft());\n+        Node rightSide = transform(node.getRight());\n+        if (leftSide.getType() == Token.BLOCK) {\n+          leftSide.addChildToBack(rightSide);\n+          return leftSide;\n+        } else {\n+          Node[] kids = {leftSide, rightSide};\n+          return newNode(Token.COMMA, kids);\n+        }\n+      }\n       return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+          transformTokenType(node.getType()),\n+          transform(node.getLeft()),\n+          transform(node.getRight()));\n     }\n \n+    @Override\n+    public Node process(JSModule node) {\n+      throw new UnsupportedOperationException(\"ES6 modules are not supported\");\n+    }\n+\n+    @Override\n+    public Node process(LabeledStatement node) {\n+      Node labelNode =\n+          newNode(Token.LABEL, IR.name(node.getLabelName()), transform(node.getStatement()));\n+      return labelNode;\n+    }\n+\n+    @Override\n+    public Node process(LetNode node) {\n+      throw new UnsupportedOperationException(\"let/const declarations are not supported\");\n+    }\n+\n+    @Override\n+    public Node process(Literal node) {\n+      return newNode(transformTokenType(node.getType()), node.getValue());\n+    }\n+\n+    @Override\n+    public Node process(Name node) {\n+      return newNode(Token.NAME, node.getIdentifier());\n+    }\n+\n+    @Override\n+    public Node process(NewExpression node) {\n+      Node callNode = newNode(Token.NEW);\n+      callNode.addChildToBack(transform(node.getTarget()));\n+      ArgumentList argList = node.getArguments();\n+      if (argList != null) {\n+        for (AstNode arg : argList) {\n+          callNode.addChildToBack(transform(arg));\n+        }\n+      }\n+      return callNode;\n+    }\n+\n+    @Override\n+    public Node process(NumberLiteral node) {\n+      return newNode(Token.NUMBER, node.getNumber());\n+    }\n+\n+    @Override\n+    public Node process(ObjectLiteral node) {\n+      Node objectNode = newNode(Token.OBJECTLIT);\n+      List<ObjectProperty> elements = node.getElements();\n+      for (ObjectProperty element : elements) {\n+        Node keyNode;\n+        if (element.getLeft() instanceof StringLiteral) {\n+          String key = ((StringLiteral) element.getLeft()).getValue();\n+          keyNode = IR.string(key);\n+        } else if (element.getLeft() instanceof Name) {\n+          String key = ((Name) element.getLeft()).getIdentifier();\n+          keyNode = IR.string(key);\n+        } else {\n+          keyNode = transform(element.getLeft());\n+        }\n+        Node valueNode = transform(element.getRight());\n+        objectNode.addChildToBack(newNode(Token.PROPERTY, keyNode, valueNode));\n+      }\n+      return objectNode;\n+    }\n+\n+    @Override\n+    public Node process(ObjectProperty node) {\n+      throw new IllegalStateException(\"Should be part of processing an ObjectLiteral\");\n+    }\n+\n+    @Override\n+    public Node process(ParenthesizedExpression node) {\n+      return transform(node.getExpression());\n+    }\n+\n+    @Override\n+    public Node process(RegExpLiteral node) {\n+      return newNode(Token.REGEXP, node.getValue(), node.getFlags());\n+    }\n+\n+    @Override\n+    public Node process(ReturnStatement node) {\n+      return newNode(transformTokenType(node.getType()), transform(node.getReturnValue()));\n+    }\n+\n+    @Override\n+    public Node process(Scope node) {\n+      throw new IllegalStateException(\"Not supported\");\n+    }\n+\n+    @Override\n+    public Node process(ScriptNode node) {\n+      return processGeneric(node);\n+    }\n+\n+    @Override\n+    public Node process(StringLiteral node) {\n+      return newNode(Token.STRING, node.getValue());\n+    }\n+\n+    @Override\n+    public Node process(SwitchCase node) {\n+      Node caseBlock =\n+          newNode(\n+              Token.BLOCK,\n+              transformArray(node.getStatements()).toArray(new Node[node.getStatements().size()]));\n+      if (node.getExpression() == null) {\n+        return caseBlock;\n+      } else {\n+        Node matchNode = newNode(Token.EQ, transform(node.getExpression()), createUndefinedNode());\n+        Node caseNode = newNode(Token.CASE, matchNode);\n+        caseNode.addChildToBack(caseBlock);\n+        return caseNode;\n+      }\n+    }\n+\n+    @Override\n+    public Node process(SwitchStatement node) {\n+      Node switchNode = newNode(Token.SWITCH, transform(node.getExpression()));\n+      List<SwitchCase> cases = node.getCases();\n+      for (SwitchCase aCase : cases) {\n+        switchNode.addChildToBack(transform(aCase));\n+      }\n+      return switchNode;\n+    }\n+\n+    @Override\n+    public Node process(ThrowStatement node) {\n+      return newNode(transformTokenType(node.getType()), transform(node.getExpression()));\n+    }\n+\n+    @Override\n+    public Node process(TryStatement node) {\n+      Node tryNode = newNode(Token.TRY, transformBlock(node.getTryBlock()));\n+      if (node.getCatchBlock() != null) {\n+        Node catchNode = newNode(Token.CATCH, transform(node.getCatchParameter()));\n+        catchNode.addChildToBack(transformBlock(node.getCatchBlock()));\n+        tryNode.addChildToBack(catchNode);\n+      }\n+      if (node.getFinallyBlock() != null) {\n+        tryNode.addChildToBack(transformBlock(node.getFinallyBlock()));\n+      }\n+      return tryNode;\n+    }\n+\n+    @Override\n+    public Node process(UnaryExpression node) {\n+      int type = transformTokenType(node.getType());\n+      if (type == Token.TYPEOF || type == Token.VOID || type == Token.NOT) {\n+        return newNode(transformTokenType(node.getType()), transform(node.getOperand()));\n+      }\n+      if (type == Token.DELPROP && node.getOperand() instanceof Name) {\n+        return newNode(Token.UNARYDEL, IR.string(((Name) node.getOperand()).getIdentifier()));\n+      }\n+      return newNode(transformTokenType(node.getType()), transform(node.getOperand()));\n+    }\n+\n+    @Override\n+    public Node process(VariableDeclaration node) {\n+      String typeString;\n+      switch (node.getType()) {\n+        case Token.VAR:\n+          typeString = \"var\";\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}