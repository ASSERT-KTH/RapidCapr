{
    "patch": "public static String unescape(String str) {\n   StringBuilder result = new StringBuilder();\n   int backslashIndex = -1;\n   int searchOffset = 0;\n   char[] sequence = null;\n\n   while (true) {\n      // look for the next backslash\n      backslashIndex = str.indexOf('\\\\', searchOffset);\n      if (backslashIndex < 0) {\n         // no more backslashes found\n         result.append(str.substring(searchOffset));\n         return result.toString();\n      } else {\n         if (backslashIndex > searchOffset) {\n            // append characters up to the next backslash\n            result.append(str.substring(searchOffset, backslashIndex));\n         }\n         // look ahead to determine the type of escape sequence\n         switch (str.charAt(backslashIndex + 1)) {\n            case 't':\n               result.append('\\t');\n               break;\n            case 'r':\n               result.append('\\r');\n               break;\n            case 'n':\n               result.append('\\n');\n               break;\n            case 'f':\n               result.append('\\f');\n               break;\n            case 'b':\n               result.append('\\b');\n               break;\n            case '\\\"':\n               result.append('\\\"');\n               break;\n            case '\\'':\n               result.append('\\'');\n               break;\n            case '\\\\':\n               result.append('\\\\');\n               break;\n            case '0':\n            case '1':\n            case '2':\n            case '3':\n               // octal code\n               sequence = new char[3];\n               for (int i = 0; i < 3 && backslashIndex + 1 + i < str.length(); i++) {\n                  char nextChar = str.charAt(backslashIndex + 1 + i);\n                  if (nextChar >= '0' && nextChar <= '7') {\n                     sequence[i] = nextChar;\n                  } else {\n                     break;\n                  }\n               }\n               result.append((char) Integer.parseInt(new String(sequence).trim(), 8));\n               break;\n            case 'u':\n               // unicode code\n               sequence = new char[4];\n               for (int i = 0; i < 4 && backslashIndex + 1 + i < str.length(); i++) {\n                  char nextChar = str.charAt(backslashIndex + 1 + i);\n                  if ((nextChar >= '0' && nextChar <= '9') ||\n                        (nextChar >= 'a' && nextChar <= 'f') ||\n                        (nextChar >= 'A' && nextChar <= 'F')) {\n                     sequence[i] = nextChar;\n                  } else {\n                     break;\n                  }\n               }\n               result.append((char) Integer.parseInt(new String(sequence).trim(), 16));\n               break;\n            default:\n               result.append('\\\\');\n               result.append(str.charAt(backslashIndex + 1));\n         }\n         searchOffset = backslashIndex + 2;\n      }\n   }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\nindex 8caca580..4aa18f05 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n@@ -27,7 +27,89 @@ package org.apache.commons.lang3.text.translate;\n  */\n public class EntityArrays {\n \n-    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\n+public static String unescape(String str) {\n+   StringBuilder result = new StringBuilder();\n+   int backslashIndex = -1;\n+   int searchOffset = 0;\n+   char[] sequence = null;\n+\n+   while (true) {\n+      // look for the next backslash\n+      backslashIndex = str.indexOf('\\\\', searchOffset);\n+      if (backslashIndex < 0) {\n+         // no more backslashes found\n+         result.append(str.substring(searchOffset));\n+         return result.toString();\n+      } else {\n+         if (backslashIndex > searchOffset) {\n+            // append characters up to the next backslash\n+            result.append(str.substring(searchOffset, backslashIndex));\n+         }\n+         // look ahead to determine the type of escape sequence\n+         switch (str.charAt(backslashIndex + 1)) {\n+            case 't':\n+               result.append('\\t');\n+               break;\n+            case 'r':\n+               result.append('\\r');\n+               break;\n+            case 'n':\n+               result.append('\\n');\n+               break;\n+            case 'f':\n+               result.append('\\f');\n+               break;\n+            case 'b':\n+               result.append('\\b');\n+               break;\n+            case '\\\"':\n+               result.append('\\\"');\n+               break;\n+            case '\\'':\n+               result.append('\\'');\n+               break;\n+            case '\\\\':\n+               result.append('\\\\');\n+               break;\n+            case '0':\n+            case '1':\n+            case '2':\n+            case '3':\n+               // octal code\n+               sequence = new char[3];\n+               for (int i = 0; i < 3 && backslashIndex + 1 + i < str.length(); i++) {\n+                  char nextChar = str.charAt(backslashIndex + 1 + i);\n+                  if (nextChar >= '0' && nextChar <= '7') {\n+                     sequence[i] = nextChar;\n+                  } else {\n+                     break;\n+                  }\n+               }\n+               result.append((char) Integer.parseInt(new String(sequence).trim(), 8));\n+               break;\n+            case 'u':\n+               // unicode code\n+               sequence = new char[4];\n+               for (int i = 0; i < 4 && backslashIndex + 1 + i < str.length(); i++) {\n+                  char nextChar = str.charAt(backslashIndex + 1 + i);\n+                  if ((nextChar >= '0' && nextChar <= '9') ||\n+                        (nextChar >= 'a' && nextChar <= 'f') ||\n+                        (nextChar >= 'A' && nextChar <= 'F')) {\n+                     sequence[i] = nextChar;\n+                  } else {\n+                     break;\n+                  }\n+               }\n+               result.append((char) Integer.parseInt(new String(sequence).trim(), 16));\n+               break;\n+            default:\n+               result.append('\\\\');\n+               result.append(str.charAt(backslashIndex + 1));\n+         }\n+         searchOffset = backslashIndex + 2;\n+      }\n+   }\n+}\n     private static final String[][] ISO8859_1_ESCAPE = {\n         {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n         {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark",
    "result_reason": "error: operand expected (error token is \"=\")",
    "test_result": "ERROR"
}