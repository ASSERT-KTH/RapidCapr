{
    "patch": "// Remove unreferenced function arguments.\nprivate void removeUnreferencedFunctionArgs(Scope fnScope) {\n    Node functionNode = fnScope.getRootNode();\n\n    Preconditions.checkState(functionNode.isFunction(), functionNode);\n\n    if (NodeUtil.isGetOrSetKey(functionNode.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n\n    // Get the argument list node of the function.\n    Node argsNode = functionNode.getSecondChild();\n    boolean isVarArgs = functionNode.isVarArgs();\n\n    // If no argument nodes, nothing to remove.\n    if (argsNode == null || !argsNode.hasChildren()) return;\n\n    // Collect unreferenced arg nodes, if empty arg list then return.\n    Set<Node> unreferencedVars = collectUnreferencedVars(argsNode.getLastChild(), fnScope);\n    if (unreferencedVars.isEmpty()) return;\n\n    // Remove the unreferenced arg nodes from the tree.\n    for (Node child : argsNode.children()) {\n        if (unreferencedVars.contains(child)) {\n            argsNode.removeChild(child);\n            compiler.reportCodeChange();\n        }\n    }\n\n    // If a varargs function and the last argument is not being removed, cannot optimize.\n    if (isVarArgs && !unreferencedVars.contains(argsNode.getLastChild())) return;\n\n    // Replace parameter references with undefined constants, for modified callers.\n    if (modifyCallSites && callSiteOptimizer.canModifyCallers(functionNode)) {\n        callSiteOptimizer.optimize(fnScope, unreferencedVars);\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..c62bf8a5 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,44 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+// Remove unreferenced function arguments.\n+private void removeUnreferencedFunctionArgs(Scope fnScope) {\n+    Node functionNode = fnScope.getRootNode();\n+\n+    Preconditions.checkState(functionNode.isFunction(), functionNode);\n+\n+    if (NodeUtil.isGetOrSetKey(functionNode.getParent())) {\n+        // The parameters object literal setters can not be removed.\n+        return;\n+    }\n+\n+    // Get the argument list node of the function.\n+    Node argsNode = functionNode.getSecondChild();\n+    boolean isVarArgs = functionNode.isVarArgs();\n+\n+    // If no argument nodes, nothing to remove.\n+    if (argsNode == null || !argsNode.hasChildren()) return;\n+\n+    // Collect unreferenced arg nodes, if empty arg list then return.\n+    Set<Node> unreferencedVars = collectUnreferencedVars(argsNode.getLastChild(), fnScope);\n+    if (unreferencedVars.isEmpty()) return;\n+\n+    // Remove the unreferenced arg nodes from the tree.\n+    for (Node child : argsNode.children()) {\n+        if (unreferencedVars.contains(child)) {\n+            argsNode.removeChild(child);\n+            compiler.reportCodeChange();\n+        }\n+    }\n+\n+    // If a varargs function and the last argument is not being removed, cannot optimize.\n+    if (isVarArgs && !unreferencedVars.contains(argsNode.getLastChild())) return;\n+\n+    // Replace parameter references with undefined constants, for modified callers.\n+    if (modifyCallSites && callSiteOptimizer.canModifyCallers(functionNode)) {\n+        callSiteOptimizer.optimize(fnScope, unreferencedVars);\n+    }\n+}\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}