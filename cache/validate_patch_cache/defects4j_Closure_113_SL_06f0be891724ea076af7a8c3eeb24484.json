{
    "patch": "private class RemoveRequireCallback implements ParentTraversalCallback<Scope> {\n  private final Compiler compiler;\n  private final Node requireNode;\n  private final Node requireParent;\n\n  public RemoveRequireCallback(Compiler compiler, Node requireNode, Node requireParent) {\n    this.compiler = compiler;\n    this.requireNode = requireNode;\n    this.requireParent = requireParent;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Scope scope) {\n    Node parent = n.getParent();\n    if (parent == requireNode || parent == requireParent) {\n      return;\n    }\n    if (NodeUtil.isExprAssign(parent) &&\n        n == parent.getFirstChild().getNext() &&\n        requireNode.getFirstChild().getString().equals(\n            parent.getFirstChild().getQualifiedName())) {\n      // We may not remove goog.require('some.Name').\n      return;\n    }\n    parent.detachChild(n);\n    compiler.reportCodeChange();\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex 70bf1b00..e84b16a6 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -326,7 +326,34 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+private class RemoveRequireCallback implements ParentTraversalCallback<Scope> {\n+  private final Compiler compiler;\n+  private final Node requireNode;\n+  private final Node requireParent;\n+\n+  public RemoveRequireCallback(Compiler compiler, Node requireNode, Node requireParent) {\n+    this.compiler = compiler;\n+    this.requireNode = requireNode;\n+    this.requireParent = requireParent;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Scope scope) {\n+    Node parent = n.getParent();\n+    if (parent == requireNode || parent == requireParent) {\n+      return;\n+    }\n+    if (NodeUtil.isExprAssign(parent) &&\n+        n == parent.getFirstChild().getNext() &&\n+        requireNode.getFirstChild().getString().equals(\n+            parent.getFirstChild().getQualifiedName())) {\n+      // We may not remove goog.require('some.Name').\n+      return;\n+    }\n+    parent.detachChild(n);\n+    compiler.reportCodeChange();\n+  }\n+}\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}