{
    "patch": "import java.lang.reflect.Method;\nimport net.sf.cglib.proxy.Callback;\nimport net.sf.cglib.proxy.Enhancer;\nimport net.sf.cglib.proxy.Factory;\nimport net.sf.cglib.proxy.MethodInterceptor;\nimport net.sf.cglib.proxy.MethodProxy;\n\npublic class MockHandler<T> implements MethodInterceptor {\n    private T mockObject;\n\n    public MockHandler() {\n    }\n\n    public MockHandler(MockHandlerInterface<T> innerHandler) {\n    }\n\n    public T createMock(Class<T> clazz) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(clazz);\n        enhancer.setCallbackType(MethodInterceptor.class);\n        Object mock = enhancer.create();\n        this.mockObject = (T) mock;\n        return (T) mock;\n    }\n\n    public void resetMock(T mock) {\n        Factory factory = (Factory) mock;\n        Callback[] callbacks = factory.getCallbacks();\n        for (int i = 0; i < callbacks.length; i++) {\n            if (callbacks[i] instanceof MockHandlerInterface) {\n                callbacks[i] = new MockHandler<T>((MockHandlerInterface<T>) callbacks[i]);\n                break;\n            }\n        }\n        factory.setCallbacks(callbacks);\n    }\n\n    public Object intercept(Object obj, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n        InvocationReportImpl targetInfo = new InvocationReportImpl(obj, method, objects);\n        Object result = null;\n\n        try {\n            result = methodProxy.invokeSuper(mockObject, objects);\n            return result;\n        } catch (Throwable e) {\n            targetInfo.setThrowable(e);\n            throw e;\n        } finally {\n            // Report invocation only if we have an IInvokedMethodListener available\n            if (null\n                    != org.mockito.Mockito.framework()\n                            .getListeners()\n                            .getInvokedMethodListeners()) {\n                org.mockito.Mockito.framework().getListeners().getInvokedMethodListeners().reportInvocation(targetInfo);\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..b9d2e418a 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,65 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import java.lang.reflect.Method;\n+import net.sf.cglib.proxy.Callback;\n+import net.sf.cglib.proxy.Enhancer;\n+import net.sf.cglib.proxy.Factory;\n+import net.sf.cglib.proxy.MethodInterceptor;\n+import net.sf.cglib.proxy.MethodProxy;\n+\n+public class MockHandler<T> implements MethodInterceptor {\n+    private T mockObject;\n+\n+    public MockHandler() {\n+    }\n+\n+    public MockHandler(MockHandlerInterface<T> innerHandler) {\n+    }\n+\n+    public T createMock(Class<T> clazz) {\n+        Enhancer enhancer = new Enhancer();\n+        enhancer.setSuperclass(clazz);\n+        enhancer.setCallbackType(MethodInterceptor.class);\n+        Object mock = enhancer.create();\n+        this.mockObject = (T) mock;\n+        return (T) mock;\n+    }\n+\n+    public void resetMock(T mock) {\n+        Factory factory = (Factory) mock;\n+        Callback[] callbacks = factory.getCallbacks();\n+        for (int i = 0; i < callbacks.length; i++) {\n+            if (callbacks[i] instanceof MockHandlerInterface) {\n+                callbacks[i] = new MockHandler<T>((MockHandlerInterface<T>) callbacks[i]);\n+                break;\n+            }\n+        }\n+        factory.setCallbacks(callbacks);\n+    }\n+\n+    public Object intercept(Object obj, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n+        InvocationReportImpl targetInfo = new InvocationReportImpl(obj, method, objects);\n+        Object result = null;\n+\n+        try {\n+            result = methodProxy.invokeSuper(mockObject, objects);\n+            return result;\n+        } catch (Throwable e) {\n+            targetInfo.setThrowable(e);\n+            throw e;\n+        } finally {\n+            // Report invocation only if we have an IInvokedMethodListener available\n+            if (null\n+                    != org.mockito.Mockito.framework()\n+                            .getListeners()\n+                            .getInvokedMethodListeners()) {\n+                org.mockito.Mockito.framework().getListeners().getInvokedMethodListeners().reportInvocation(targetInfo);\n+            }\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}