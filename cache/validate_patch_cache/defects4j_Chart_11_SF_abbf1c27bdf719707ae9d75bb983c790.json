{
    "patch": "public static boolean equal(GeneralPath p1, GeneralPath p2) {\n    if (p1 == null) {\n        return p2 == null;\n    }\n    if (p2 == null) {\n        return false;\n    }\n    if (p1.getWindingRule() != p2.getWindingRule()) {\n        return false;\n    }\n    PathIterator iterator1 = p1.getPathIterator(null);\n    PathIterator iterator2 = p2.getPathIterator(null);\n    double[] coords1 = new double[6];\n    double[] coords2 = new double[6];\n    while (!iterator1.isDone() && !iterator2.isDone()) {\n        int seg1 = iterator1.currentSegment(coords1);\n        int seg2 = iterator2.currentSegment(coords2);\n        if (seg1 != seg2) {\n            return false;\n        }\n        if (seg1 == PathIterator.SEG_CLOSE) {\n            // Ignore close operations as they do not have coordinates\n            iterator1.next();\n            iterator2.next();\n            continue;\n        }\n        if (!Arrays.equals(coords1, coords2)) {\n            return false;\n        }\n        iterator1.next();\n        iterator2.next();\n    }\n    return iterator1.isDone() && iterator2.isDone();\n}",
    "patch_diff": "diff --git a/source/org/jfree/chart/util/ShapeUtilities.java b/source/org/jfree/chart/util/ShapeUtilities.java\nindex 31aa6c6..7aed9c3 100644\n--- a/source/org/jfree/chart/util/ShapeUtilities.java\n+++ b/source/org/jfree/chart/util/ShapeUtilities.java\n@@ -261,39 +261,40 @@ public class ShapeUtilities {\n      *\n      * @return A boolean.\n      */\n-    public static boolean equal(GeneralPath p1, GeneralPath p2) {\n-        if (p1 == null) {\n-            return (p2 == null);\n-        }\n-        if (p2 == null) {\n-            return false;\n-        }\n-        if (p1.getWindingRule() != p2.getWindingRule()) {\n+public static boolean equal(GeneralPath p1, GeneralPath p2) {\n+    if (p1 == null) {\n+        return p2 == null;\n+    }\n+    if (p2 == null) {\n+        return false;\n+    }\n+    if (p1.getWindingRule() != p2.getWindingRule()) {\n+        return false;\n+    }\n+    PathIterator iterator1 = p1.getPathIterator(null);\n+    PathIterator iterator2 = p2.getPathIterator(null);\n+    double[] coords1 = new double[6];\n+    double[] coords2 = new double[6];\n+    while (!iterator1.isDone() && !iterator2.isDone()) {\n+        int seg1 = iterator1.currentSegment(coords1);\n+        int seg2 = iterator2.currentSegment(coords2);\n+        if (seg1 != seg2) {\n             return false;\n         }\n-        PathIterator iterator1 = p1.getPathIterator(null);\n-        PathIterator iterator2 = p1.getPathIterator(null);\n-        double[] d1 = new double[6];\n-        double[] d2 = new double[6];\n-        boolean done = iterator1.isDone() && iterator2.isDone();\n-        while (!done) {\n-            if (iterator1.isDone() != iterator2.isDone()) {\n-                return false;\n-            }\n-            int seg1 = iterator1.currentSegment(d1);\n-            int seg2 = iterator2.currentSegment(d2);\n-            if (seg1 != seg2) {\n-                return false;\n-            }\n-            if (!Arrays.equals(d1, d2)) {\n-                return false;\n-            }\n+        if (seg1 == PathIterator.SEG_CLOSE) {\n+            // Ignore close operations as they do not have coordinates\n             iterator1.next();\n             iterator2.next();\n-            done = iterator1.isDone() && iterator2.isDone();\n+            continue;\n         }\n-        return true;\n+        if (!Arrays.equals(coords1, coords2)) {\n+            return false;\n+        }\n+        iterator1.next();\n+        iterator2.next();\n     }\n+    return iterator1.isDone() && iterator2.isDone();\n+}\n \n     /**\n      * Creates and returns a translated shape.",
    "result_reason": "all tests passed",
    "test_result": "PASS"
}