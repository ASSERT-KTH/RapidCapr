{
    "patch": "final int delta = offsetLocal - offsetAdjusted;\nfinal int minOffset;\nfinal int maxOffset;\nif (delta >= 0) {\n    // moving backward in time, find previous transition\n    long prevTransition = previousTransition(instantLocal - offsetAdjusted);\n    final long adjPrevTransition = previousTransition(instantAdjusted);\n    final int offsetPrev = getOffset(prevTransition);\n    if (offsetPrev >= offsetLocal) {\n        // choose previous transition with local offset\n        return offsetLocal;\n    } else if (offsetPrev < offsetAdjusted) {\n        // choose previous transition with adjusted offset\n        return offsetPrev;\n    }\n\n    // adjust prevTransition for possible DST gap\n    long prevTransitionAdj = prevTransition;\n    int adjOffsetPrev = offsetPrev;\n    while (adjOffsetPrev < offsetAdjusted) {\n        prevTransitionAdj = previousTransition(prevTransitionAdj - 1);\n        adjOffsetPrev = getOffset(prevTransitionAdj);\n    }\n\n    // adjust for possible overlap in the previous DST rule\n    long overlapStart = prevTransitionAdj;\n    while (overlapStart > prevTransition) {\n        int adjustedTmp = getOffset(overlapStart - 1);\n        if (adjustedTmp <= offsetAdjusted) {\n            break;\n        }\n        overlapStart = previousTransition(overlapStart - DateTimeConstants.MILLIS_PER_HOUR);\n    }\n    long overlapEnd = prevTransition;\n    while (overlapEnd < prevTransitionAdj) {\n        int adjustedTmp = getOffset(overlapEnd);\n        if (adjustedTmp <= offsetPrev) {\n            break;\n        }\n        overlapEnd = nextTransition(overlapEnd);\n    }\n    // get min and max offsets for overlap period\n    minOffset = getOffset(overlapStart - 1);\n    maxOffset = getOffset(overlapEnd);\n\n} else {\n    // moving forward in time, find next transition\n    long nextTransition = nextTransition(instantLocal - offsetAdjusted);\n    final long adjNextTransition = nextTransition(instantAdjusted);\n    final int offsetNext = getOffset(nextTransition);\n\n    if (offsetNext > offsetAdjusted) {\n        // choose next transition with adjusted offset\n        return offsetAdjusted;\n    } else if (offsetNext >= offsetLocal) {\n        // choose next transition with local offset\n        return offsetLocal;\n    }\n\n    // adjust nextTransition for possible DST gap\n    long nextTransitionAdj = nextTransition;\n    int adjOffsetNext = offsetNext;\n    while (adjOffsetNext <= offsetAdjusted) {\n        nextTransitionAdj = nextTransition(nextTransitionAdj + 1);\n        adjOffsetNext = getOffset(nextTransitionAdj);\n    }\n\n    // adjust for possible overlap in the next DST rule\n    long overlapStart = nextTransition;\n    while (overlapStart < nextTransitionAdj) {\n        int adjustedTmp = getOffset(overlapStart);\n        if (adjustedTmp >= offsetLocal) {\n            break;\n        }\n        overlapStart = nextTransition(overlapStart);\n    }\n    long overlapEnd = nextTransitionAdj;\n    while (overlapEnd > overlapStart) {\n        int adjustedTmp = getOffset(overlapEnd - 1);\n        if (adjustedTmp >= offsetAdjusted) {\n            break;\n        }\n        overlapEnd = previousTransition(overlapEnd - DateTimeConstants.MILLIS_PER_HOUR);\n    }\n    // get min and max offsets for overlap period\n    minOffset = getOffset(overlapStart);\n    maxOffset = getOffset(overlapEnd - 1);\n}\n\nif (minOffset == maxOffset) {\n    // only one valid offset in overlap period, return it\n    return minOffset;\n}\n\n// find the offset that matches the actual instant\nfinal long overlapMiddle = (overlapEnd + overlapStart) / 2;\nint overlapMiddleOffset = getOffset(overlapMiddle);\nif (delta >= 0) {\n    if (overlapMiddleOffset < offsetAdjusted) {\n        overlapMiddleOffset = offsetAdjusted;\n    }\n} else {\n    if (overlapMiddleOffset > offsetAdjusted) {\n        overlapMiddleOffset = offsetAdjusted;\n    }\n}\n\nif (instantAdjusted >= overlapMiddle) {\n    return maxOffset;\n} else {\n    return minOffset;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..1c8b9810 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,118 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+final int delta = offsetLocal - offsetAdjusted;\n+final int minOffset;\n+final int maxOffset;\n+if (delta >= 0) {\n+    // moving backward in time, find previous transition\n+    long prevTransition = previousTransition(instantLocal - offsetAdjusted);\n+    final long adjPrevTransition = previousTransition(instantAdjusted);\n+    final int offsetPrev = getOffset(prevTransition);\n+    if (offsetPrev >= offsetLocal) {\n+        // choose previous transition with local offset\n+        return offsetLocal;\n+    } else if (offsetPrev < offsetAdjusted) {\n+        // choose previous transition with adjusted offset\n+        return offsetPrev;\n+    }\n+\n+    // adjust prevTransition for possible DST gap\n+    long prevTransitionAdj = prevTransition;\n+    int adjOffsetPrev = offsetPrev;\n+    while (adjOffsetPrev < offsetAdjusted) {\n+        prevTransitionAdj = previousTransition(prevTransitionAdj - 1);\n+        adjOffsetPrev = getOffset(prevTransitionAdj);\n+    }\n+\n+    // adjust for possible overlap in the previous DST rule\n+    long overlapStart = prevTransitionAdj;\n+    while (overlapStart > prevTransition) {\n+        int adjustedTmp = getOffset(overlapStart - 1);\n+        if (adjustedTmp <= offsetAdjusted) {\n+            break;\n+        }\n+        overlapStart = previousTransition(overlapStart - DateTimeConstants.MILLIS_PER_HOUR);\n+    }\n+    long overlapEnd = prevTransition;\n+    while (overlapEnd < prevTransitionAdj) {\n+        int adjustedTmp = getOffset(overlapEnd);\n+        if (adjustedTmp <= offsetPrev) {\n+            break;\n+        }\n+        overlapEnd = nextTransition(overlapEnd);\n+    }\n+    // get min and max offsets for overlap period\n+    minOffset = getOffset(overlapStart - 1);\n+    maxOffset = getOffset(overlapEnd);\n+\n+} else {\n+    // moving forward in time, find next transition\n+    long nextTransition = nextTransition(instantLocal - offsetAdjusted);\n+    final long adjNextTransition = nextTransition(instantAdjusted);\n+    final int offsetNext = getOffset(nextTransition);\n+\n+    if (offsetNext > offsetAdjusted) {\n+        // choose next transition with adjusted offset\n+        return offsetAdjusted;\n+    } else if (offsetNext >= offsetLocal) {\n+        // choose next transition with local offset\n+        return offsetLocal;\n+    }\n+\n+    // adjust nextTransition for possible DST gap\n+    long nextTransitionAdj = nextTransition;\n+    int adjOffsetNext = offsetNext;\n+    while (adjOffsetNext <= offsetAdjusted) {\n+        nextTransitionAdj = nextTransition(nextTransitionAdj + 1);\n+        adjOffsetNext = getOffset(nextTransitionAdj);\n+    }\n+\n+    // adjust for possible overlap in the next DST rule\n+    long overlapStart = nextTransition;\n+    while (overlapStart < nextTransitionAdj) {\n+        int adjustedTmp = getOffset(overlapStart);\n+        if (adjustedTmp >= offsetLocal) {\n+            break;\n+        }\n+        overlapStart = nextTransition(overlapStart);\n+    }\n+    long overlapEnd = nextTransitionAdj;\n+    while (overlapEnd > overlapStart) {\n+        int adjustedTmp = getOffset(overlapEnd - 1);\n+        if (adjustedTmp >= offsetAdjusted) {\n+            break;\n+        }\n+        overlapEnd = previousTransition(overlapEnd - DateTimeConstants.MILLIS_PER_HOUR);\n+    }\n+    // get min and max offsets for overlap period\n+    minOffset = getOffset(overlapStart);\n+    maxOffset = getOffset(overlapEnd - 1);\n+}\n+\n+if (minOffset == maxOffset) {\n+    // only one valid offset in overlap period, return it\n+    return minOffset;\n+}\n+\n+// find the offset that matches the actual instant\n+final long overlapMiddle = (overlapEnd + overlapStart) / 2;\n+int overlapMiddleOffset = getOffset(overlapMiddle);\n+if (delta >= 0) {\n+    if (overlapMiddleOffset < offsetAdjusted) {\n+        overlapMiddleOffset = offsetAdjusted;\n+    }\n+} else {\n+    if (overlapMiddleOffset > offsetAdjusted) {\n+        overlapMiddleOffset = offsetAdjusted;\n+    }\n+}\n+\n+if (instantAdjusted >= overlapMiddle) {\n+    return maxOffset;\n+} else {\n+    return minOffset;\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}