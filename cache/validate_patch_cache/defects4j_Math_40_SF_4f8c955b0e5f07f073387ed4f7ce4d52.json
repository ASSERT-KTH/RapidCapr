{
    "patch": "import org.apache.commons.math.analysis.UnivariateFunction;\nimport org.apache.commons.math.exception.MathInternalError;\nimport org.apache.commons.math.exception.NoBracketingException;\nimport org.apache.commons.math.exception.TooManyEvaluationsException;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.Precision;\n\npublic class BrentSolverFixed extends AbstractUnivariateSolver {\n\n    /**\n     * The default absolute accuracy.\n     */\n    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n\n    /**\n     * The default relative accuracy.\n     */\n    private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n\n    /**\n     * The default function value accuracy.\n     */\n    private static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n\n    /**\n     * The maximum order of polynomial functions allowed.\n     */\n    private static final int MAXIMAL_ORDER = 5;\n\n    /**\n     * The upper limit for the number of iterations.\n     */\n    private static final int ITERATION_LIMIT = 100;\n\n    /**\n     * The array of coefficients for the reversed polynomial.\n     */\n    private final double[] coefficients;\n\n    /**\n     * The maximum number of iterations allowed.\n     */\n    private final int maxIterations;\n\n    /**\n     * Construct a solver with default accuracy settings.\n     */\n    public BrentSolverFixed() {\n        this(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_FUNCTION_VALUE_ACCURACY, ITERATION_LIMIT);\n    }\n\n    /**\n     * Construct a solver.\n     *\n     * @param relativeAccuracy maximum relative error\n     * @param absoluteAccuracy maximum absolute error\n     * @param functionValueAccuracy maximum function value error\n     * @param maxIterations maximum number of iterations\n     */\n    public BrentSolverFixed(final double relativeAccuracy,\n                            final double absoluteAccuracy,\n                            final double functionValueAccuracy,\n                            final int maxIterations) {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        MathUtils.checkPositive(maxIterations, \"maximal number of iterations\");\n        this.coefficients = new double[MAXIMAL_ORDER + 1];\n        this.maxIterations = maxIterations;\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * @throws TooManyEvaluationsException {@inheritDoc}\n     * @throws NoBracketingException {@inheritDoc}\n     */\n    @Override\n    protected double doSolve() {\n        // Get initial start, end, and midpoint values\n        double a = getMin();\n        double b = getMax();\n        double m = 0.5 * (a + b);\n\n        double f_a = computeObjectiveValue(a);\n        double f_b = computeObjectiveValue(b);\n        double f_m = computeObjectiveValue(m);\n        double s, d = b - a;\n\n        // Verify bracketing of the root\n        verifyBracketing(a, b);\n\n        // Check for root input as initial guess\n        if (Precision.equals(f_m, 0d, getFunctionValueAccuracy())) {\n            return m;\n        }\n\n        double f_old = f_m;\n        double e = b >= m ? a - b : b - a;\n        int iter = 0;\n        // Outer loop starts here\n        while (++iter <= maxIterations) {\n            // Check for convergence at midpoint\n            if (Precision.equals(m, 0d, getRelativeAccuracy())) {\n                return m;\n            }\n\n            // Perform golden/ratio section step\n            double old_a = a;\n            double old_f_a = f_a;\n            double old_b = b;\n            double old_f_b = f_b;\n            double old_m = m;\n            double old_f_m = f_m;\n\n            if (FastMath.abs(f_m) < FastMath.abs(f_b)) {\n                if (Precision.equals(a, m, getRelativeAccuracy())) {\n                    s = Precision.SAFE_MIN * FastMath.max(1d, FastMath.abs(b));\n                } else {\n                    s = m - (f_m / ((f_b - f_m) / (b - m) + (f_m - f_a) / (m - a)));\n                }\n            } else {\n                if (Precision.equals(b, m, getRelativeAccuracy())) {\n                    s = Precision.SAFE_MIN * FastMath.max(1d, FastMath.abs(b));\n                } else {\n                    s = m - (f_m / ((f_b - f_m) / (b - m) + (f_m - f_a) / (m - a)));\n                }\n            }\n\n            // Adjust for floating-point rounding errors\n            if (Precision.equals(s, a, getFunctionValueAccuracy()) || Precision.equals(s, b, getFunctionValueAccuracy())) {\n                s = 0.5 * (a + b);\n            }\n            // Re-compute the function values\n            f_a = computeObjectiveValue(a = m = b >= m ? a : b);\n            f_b = old_f_m;\n            f_m = computeObjectiveValue(m = s);\n\n            // Convergence test and possible exit\n            double delta = FastMath.max(FastMath.max(getAbsoluteAccuracy(), getRelativeAccuracy() * FastMath.abs(m)),\n                                         getFunctionValueAccuracy());\n            if (FastMath.abs(m - old_m) <= delta &&\n                ((f_m > 0 && f_old > 0) || (f_m <= 0 && f_old <= 0))) {\n                return m;\n            }\n            f_old = f_m;\n\n            // Maintain the bracket [a, m, b]\n            if (f_m * f_b < 0) {\n                a = old_m;\n                f_a = old_f_m;\n            } else {\n                b = old_m;\n                f_b = old_f_m;\n            }\n\n            if (FastMath.abs(f_a) < FastMath.abs(f_b)) {\n                double tmp = a;\n                a = b;\n                b = tmp;\n                tmp = f_a;\n                f_a = f_b;\n                f_b = tmp;\n            }\n\n            // Prepare to use inverse quadratic interpolation or extrapolation\n            boolean boundOK = FastMath.abs(e) > getRelativeAccuracy() * FastMath.max(FastMath.abs(b), 1.0);\n            double q = coefficients[0] = 0.0;\n            double r = coefficients[1] = f_a / f_b;\n            double p = coefficients[2] = (f_m / f_b) * r;\n            double next_step = 0.0;\n\n            // Inverse quadratic interpolation\n            for (int i = 2; i <= MAXIMAL_ORDER; i++) {\n                double denominator = (f_a - f_b) * (f_m - f_b) * (f_a - f_m);\n                double a_i = (f_m - f_b) * coefficients[i - 2] + p - r * coefficients[i - 1];\n                a_i /= denominator;\n\n                coefficients[i] = a_i;\n\n                // Update coefficients for next iteration\n                for (int j = i - 1; j >= 1; j--) {\n                    coefficients[j] = coefficients[j - 1] - a_i * coefficients[j];\n                }\n                coefficients[0] = -a_i * coefficients[0] + p;\n\n                // Use extrapolation for large intervals\n                if (FastMath.abs(coefficients[i]) > getRelativeAccuracy() * FastMath.max(FastMath.abs(b), 1.0) && boundOK) {\n                    next_step = -r * (coefficients[i] / coefficients[i - 1]);\n                    break;\n                }\n            }\n\n            // Use inverse quadratic extrapolation if interval is large\n            if (FastMath.abs(next_step) <= getAbsoluteAccuracy() ||\n                FastMath.abs(next_step) <= getRelativeAccuracy() * FastMath.abs(m)) {\n                next_step = delta_sign(m - old_m, delta_internal);\n                delta_internal = 0.5 * delta;\n                delta_sign = (delta_sign > 0) ? 1.0 : -1.0;\n            }\n\n            // Update variables for next iteration\n            e = m - old_m;\n            old_f_m = f_m;\n            if (FastMath.abs(next_step) >= delta_internal) {\n                m += next_step;\n            } else {\n                m += delta_sign(m - old_m, delta_internal);\n            }\n        }\n\n        // Maximum number of iterations exceeded\n        throw new TooManyEvaluationsException(maxIterations);\n    }\n\n    /**\n     * Compute the third order correction factor.\n     *",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..84feca19f 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,210 +140,224 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.MathInternalError;\n+import org.apache.commons.math.exception.NoBracketingException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n-            return x[1];\n-        }\n+public class BrentSolverFixed extends AbstractUnivariateSolver {\n \n-        // evaluate first  endpoint\n-        y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n-            return x[0];\n-        }\n+    /**\n+     * The default absolute accuracy.\n+     */\n+    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n-        int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n+    /**\n+     * The default relative accuracy.\n+     */\n+    private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n \n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n+    /**\n+     * The default function value accuracy.\n+     */\n+    private static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n \n-        } else {\n+    /**\n+     * The maximum order of polynomial functions allowed.\n+     */\n+    private static final int MAXIMAL_ORDER = 5;\n \n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n-            }\n+    /**\n+     * The upper limit for the number of iterations.\n+     */\n+    private static final int ITERATION_LIMIT = 100;\n \n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n-            } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n-            }\n+    /**\n+     * The array of coefficients for the reversed polynomial.\n+     */\n+    private final double[] coefficients;\n+\n+    /**\n+     * The maximum number of iterations allowed.\n+     */\n+    private final int maxIterations;\n+\n+    /**\n+     * Construct a solver with default accuracy settings.\n+     */\n+    public BrentSolverFixed() {\n+        this(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_FUNCTION_VALUE_ACCURACY, ITERATION_LIMIT);\n+    }\n \n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy maximum relative error\n+     * @param absoluteAccuracy maximum absolute error\n+     * @param functionValueAccuracy maximum function value error\n+     * @param maxIterations maximum number of iterations\n+     */\n+    public BrentSolverFixed(final double relativeAccuracy,\n+                            final double absoluteAccuracy,\n+                            final double functionValueAccuracy,\n+                            final int maxIterations) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+        MathUtils.checkPositive(maxIterations, \"maximal number of iterations\");\n+        this.coefficients = new double[MAXIMAL_ORDER + 1];\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * @throws TooManyEvaluationsException {@inheritDoc}\n+     * @throws NoBracketingException {@inheritDoc}\n+     */\n+    @Override\n+    protected double doSolve() {\n+        // Get initial start, end, and midpoint values\n+        double a = getMin();\n+        double b = getMax();\n+        double m = 0.5 * (a + b);\n+\n+        double f_a = computeObjectiveValue(a);\n+        double f_b = computeObjectiveValue(b);\n+        double f_m = computeObjectiveValue(m);\n+        double s, d = b - a;\n+\n+        // Verify bracketing of the root\n+        verifyBracketing(a, b);\n+\n+        // Check for root input as initial guess\n+        if (Precision.equals(f_m, 0d, getFunctionValueAccuracy())) {\n+            return m;\n         }\n \n-        // prepare a work array for inverse polynomial interpolation\n-        final double[] tmpX = new double[x.length];\n-\n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n-        while (true) {\n-\n-            // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n-                switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n-                }\n+        double f_old = f_m;\n+        double e = b >= m ? a - b : b - a;\n+        int iter = 0;\n+        // Outer loop starts here\n+        while (++iter <= maxIterations) {\n+            // Check for convergence at midpoint\n+            if (Precision.equals(m, 0d, getRelativeAccuracy())) {\n+                return m;\n             }\n \n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+            // Perform golden/ratio section step\n+            double old_a = a;\n+            double old_f_a = f_a;\n+            double old_b = b;\n+            double old_f_b = f_b;\n+            double old_m = m;\n+            double old_f_m = f_m;\n+\n+            if (FastMath.abs(f_m) < FastMath.abs(f_b)) {\n+                if (Precision.equals(a, m, getRelativeAccuracy())) {\n+                    s = Precision.SAFE_MIN * FastMath.max(1d, FastMath.abs(b));\n+                } else {\n+                    s = m - (f_m / ((f_b - f_m) / (b - m) + (f_m - f_a) / (m - a)));\n+                }\n             } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n-            }\n-\n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n-                    }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n+                if (Precision.equals(b, m, getRelativeAccuracy())) {\n+                    s = Precision.SAFE_MIN * FastMath.max(1d, FastMath.abs(b));\n+                } else {\n+                    s = m - (f_m / ((f_b - f_m) / (b - m) + (f_m - f_a) / (m - a)));\n                 }\n+            }\n \n-            } while (Double.isNaN(nextX) && (end - start > 1));\n+            // Adjust for floating-point rounding errors\n+            if (Precision.equals(s, a, getFunctionValueAccuracy()) || Precision.equals(s, b, getFunctionValueAccuracy())) {\n+                s = 0.5 * (a + b);\n+            }\n+            // Re-compute the function values\n+            f_a = computeObjectiveValue(a = m = b >= m ? a : b);\n+            f_b = old_f_m;\n+            f_m = computeObjectiveValue(m = s);\n+\n+            // Convergence test and possible exit\n+            double delta = FastMath.max(FastMath.max(getAbsoluteAccuracy(), getRelativeAccuracy() * FastMath.abs(m)),\n+                                         getFunctionValueAccuracy());\n+            if (FastMath.abs(m - old_m) <= delta &&\n+                ((f_m > 0 && f_old > 0) || (f_m <= 0 && f_old <= 0))) {\n+                return m;\n+            }\n+            f_old = f_m;\n \n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n+            // Maintain the bracket [a, m, b]\n+            if (f_m * f_b < 0) {\n+                a = old_m;\n+                f_a = old_f_m;\n+            } else {\n+                b = old_m;\n+                f_b = old_f_m;\n             }\n \n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n+            if (FastMath.abs(f_a) < FastMath.abs(f_b)) {\n+                double tmp = a;\n+                a = b;\n+                b = tmp;\n+                tmp = f_a;\n+                f_a = f_b;\n+                f_b = tmp;\n             }\n \n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n+            // Prepare to use inverse quadratic interpolation or extrapolation\n+            boolean boundOK = FastMath.abs(e) > getRelativeAccuracy() * FastMath.max(FastMath.abs(b), 1.0);\n+            double q = coefficients[0] = 0.0;\n+            double r = coefficients[1] = f_a / f_b;\n+            double p = coefficients[2] = (f_m / f_b) * r;\n+            double next_step = 0.0;\n \n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n+            // Inverse quadratic interpolation\n+            for (int i = 2; i <= MAXIMAL_ORDER; i++) {\n+                double denominator = (f_a - f_b) * (f_m - f_b) * (f_a - f_m);\n+                double a_i = (f_m - f_b) * coefficients[i - 2] + p - r * coefficients[i - 1];\n+                a_i /= denominator;\n \n-            } else  if (nbPoints == x.length) {\n+                coefficients[i] = a_i;\n \n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n+                // Update coefficients for next iteration\n+                for (int j = i - 1; j >= 1; j--) {\n+                    coefficients[j] = coefficients[j - 1] - a_i * coefficients[j];\n+                }\n+                coefficients[0] = -a_i * coefficients[0] + p;\n \n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n+                // Use extrapolation for large intervals\n+                if (FastMath.abs(coefficients[i]) > getRelativeAccuracy() * FastMath.max(FastMath.abs(b), 1.0) && boundOK) {\n+                    next_step = -r * (coefficients[i] / coefficients[i - 1]);\n+                    break;\n                 }\n+            }\n \n+            // Use inverse quadratic extrapolation if interval is large\n+            if (FastMath.abs(next_step) <= getAbsoluteAccuracy() ||\n+                FastMath.abs(next_step) <= getRelativeAccuracy() * FastMath.abs(m)) {\n+                next_step = delta_sign(m - old_m, delta_internal);\n+                delta_internal = 0.5 * delta;\n+                delta_sign = (delta_sign > 0) ? 1.0 : -1.0;\n             }\n \n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n+            // Update variables for next iteration\n+            e = m - old_m;\n+            old_f_m = f_m;\n+            if (FastMath.abs(next_step) >= delta_internal) {\n+                m += next_step;\n             } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n+                m += delta_sign(m - old_m, delta_internal);\n             }\n-\n         }\n \n+        // Maximum number of iterations exceeded\n+        throw new TooManyEvaluationsException(maxIterations);\n     }\n \n+    /**\n+     * Compute the third order correction factor.\n+     *\n+\n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>\n      * The x value is guessed by evaluating polynomial Q(y) at y = targetY, where Q",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}