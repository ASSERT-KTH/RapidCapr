{
    "patch": "  private void tryMinimizeExits(Node n, int exitType, String labelName) {\n\n    // Just an 'exit'.\n    if (matchingExitNode(n, exitType, labelName)) {\n      NodeUtil.removeChild(n.getParent(), n);\n      compiler.reportCodeChange();\n      return;\n    }\n\n    // Just an 'if'.\n    if (n.isIf()) {\n      Node ifBlock = n.getFirstChild().getNext();\n      tryMinimizeExits(ifBlock, exitType, labelName);\n      Node elseBlock = ifBlock.getNext();\n      if (elseBlock != null) {\n        tryMinimizeExits(elseBlock, exitType, labelName);\n      }\n      return;\n    }\n\n    // Just a 'try/catch/finally'.\n    if (n.isTry()) {\n      Node tryBlock = n.getFirstChild();\n      tryMinimizeExits(tryBlock, exitType, labelName);\n      Node allCatchNodes = NodeUtil.getCatchBlock(n);\n      if (NodeUtil.hasCatchHandler(allCatchNodes)) {\n        Preconditions.checkState(allCatchNodes.hasOneChild());\n        Node catchNode = allCatchNodes.getFirstChild();\n        Node catchCodeBlock = catchNode.getLastChild();\n        tryMinimizeExits(catchCodeBlock, exitType, labelName);\n      }\n      /*\n       * Call tryMinimizeExits on finally block. We would like to minimize any breaks that can be\n       * minimized while not breaking the finally block itself. Its completion type should not be\n       * changed if possible.\n       */\n      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        tryMinimizeExits(finallyBlock,exitType, labelName);\n      }\n    }\n\n    // Just a 'label'.\n    if (n.isLabel()) {\n      Node labelBlock = n.getLastChild();\n      tryMinimizeExits(labelBlock, exitType, labelName);\n    }\n\n    // TODO(johnlenz): The last case of SWITCH statement?\n\n    // The rest assumes a block with at least one child, bail on anything else.\n    if (!n.isBlock() || n.getLastChild() == null) {\n      return;\n    }\n\n    // This is used to detect nested ifs, in which case we need to preserve any IGNORE_EXIT labels.\n    // Without the IGNORE_EXIT label, if the inner break was minimized to not break, it would cause\n    // the outer if to break instead.\n    // We can never remove these labels, because if we do the break will not be matched with the\n    // correct label anymore.\n    boolean hasIgnoreExit = NodeUtil.getDirectChildrenTyped(n, LABEL).stream()\n        .anyMatch(l -> l.getString().equals(labelName) && l.isBreak() && l.firstChild().isIgnoreResult());\n\n    // Multiple if-exits can be converted in a single pass.\n    // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n    // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n    // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n    for (Node c : n.children()) {\n\n      // If there is a labeled break we should not optimize past it.\n      // If there is an IGNORE_EXIT before a labeled break do not optimize past it.\n      if ((hasLabeledBreak(c, labelName) || hasIgnoreExit) && c != n.getLastChild()) {\n        break;\n      }\n\n      // An 'if' block to process below.\n      if (c.isIf()) {\n        Node ifTree = c;\n        Node trueBlock, falseBlock;\n\n        // First, the true condition block.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        tryMinimizeIfBlockExits(trueBlock, falseBlock,\n            ifTree, exitType, labelName);\n\n        // Now the else block.\n        // The if blocks may have changed, get them again.\n        trueBlock = ifTree.getFirstChild().getNext();\n        falseBlock = trueBlock.getNext();\n        if (falseBlock != null) {\n          tryMinimizeIfBlockExits(falseBlock, trueBlock,\n              ifTree, exitType, labelName);\n        }\n      }\n\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n\n    // Now try to minimize the exits of the last child, if it is removed\n    // look at what has become the last child.\n    for (Node c = n.getLastChild(); c != null; c = n.getLastChild()) {\n      tryMinimizeExits(c, exitType, labelName);\n      // If the node is still the last child, we are done.\n      if (c == n.getLastChild()) {\n        break;\n      }\n    }\n  }\n  \n  /** Returns true if any child of n is a break node with the given label. */\n  private static boolean hasLabeledBreak(Node n, String labelName) {\n    return NodeUtil.getDirectChildrenTyped(n, BREAK).stream()\n        .anyMatch(b -> b.getString().equals(labelName));\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..98bd9e45 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -103,7 +103,7 @@ class MinimizeExitPoints\n    *   null otherwise.\n    * @nullable labelName non-null only for breaks within labels.\n    */\n-  void tryMinimizeExits(Node n, int exitType, String labelName) {\n+  private void tryMinimizeExits(Node n, int exitType, String labelName) {\n \n     // Just an 'exit'.\n     if (matchingExitNode(n, exitType, labelName)) {\n@@ -134,13 +134,14 @@ class MinimizeExitPoints\n         Node catchCodeBlock = catchNode.getLastChild();\n         tryMinimizeExits(catchCodeBlock, exitType, labelName);\n       }\n-      /* Don't try to minimize the exits of finally blocks, as this\n-       * can cause problems if it changes the completion type of the finally\n-       * block. See ECMA 262 Sections 8.9 & 12.14\n+      /*\n+       * Call tryMinimizeExits on finally block. We would like to minimize any breaks that can be\n+       * minimized while not breaking the finally block itself. Its completion type should not be\n+       * changed if possible.\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n+        tryMinimizeExits(finallyBlock,exitType, labelName);\n       }\n     }\n \n@@ -157,12 +158,26 @@ class MinimizeExitPoints\n       return;\n     }\n \n+    // This is used to detect nested ifs, in which case we need to preserve any IGNORE_EXIT labels.\n+    // Without the IGNORE_EXIT label, if the inner break was minimized to not break, it would cause\n+    // the outer if to break instead.\n+    // We can never remove these labels, because if we do the break will not be matched with the\n+    // correct label anymore.\n+    boolean hasIgnoreExit = NodeUtil.getDirectChildrenTyped(n, LABEL).stream()\n+        .anyMatch(l -> l.getString().equals(labelName) && l.isBreak() && l.firstChild().isIgnoreResult());\n+\n     // Multiple if-exits can be converted in a single pass.\n     // Convert \"if (blah) break;  if (blah2) break; other_stmt;\" to\n     // become \"if (blah); else { if (blah2); else { other_stmt; } }\"\n     // which will get converted to \"if (!blah && !blah2) { other_stmt; }\".\n     for (Node c : n.children()) {\n \n+      // If there is a labeled break we should not optimize past it.\n+      // If there is an IGNORE_EXIT before a labeled break do not optimize past it.\n+      if ((hasLabeledBreak(c, labelName) || hasIgnoreExit) && c != n.getLastChild()) {\n+        break;\n+      }\n+\n       // An 'if' block to process below.\n       if (c.isIf()) {\n         Node ifTree = c;\n@@ -199,6 +214,12 @@ class MinimizeExitPoints\n       }\n     }\n   }\n+  \n+  /** Returns true if any child of n is a break node with the given label. */\n+  private static boolean hasLabeledBreak(Node n, String labelName) {\n+    return NodeUtil.getDirectChildrenTyped(n, BREAK).stream()\n+        .anyMatch(b -> b.getString().equals(labelName));\n+  }\n \n   /**\n    * Look for exits (returns, breaks, or continues, depending on the context) at",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}