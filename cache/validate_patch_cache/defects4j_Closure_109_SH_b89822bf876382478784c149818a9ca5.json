{
    "patch": "    if (token.getType() == JsDocToken.Type.LC) {\n      // context is a function type\n      token = nextToken();\n      Node params = null;\n      Node returnType = null;\n      while (token != null && token.getType() != JsDocToken.Type.RC) {\n        if (token.getType() == JsDocToken.Type.COLON) {\n          Node type = parseContextTypeExpression(nextToken());\n          if (type == null) {\n            reportWarning(token, \"Bad type annotation. type not recognized due to syntax error\");\n          } else {\n            if (params == null) {\n              params = type;\n            } else if (returnType == null) {\n              returnType = type;\n            } else {\n              reportWarning(token, \"Bad function type annotation. Unexpected token after return type.\");\n            }\n          }\n        } else if (params == null) {\n          params = parseContextTypeExpression(token);\n        } else if (returnType == null) {\n          returnType = parseContextTypeExpression(token);\n        } else {\n          reportWarning(token, \"Bad function type annotation. Unexpected token after return type.\");\n        }\n        token = nextToken();\n      }\n      if (params == null) {\n        reportWarning(token, \"Bad function type annotation. Missing parameter type(s).\");\n      }\n      return JSDocInfo.buildFunctionType(params, returnType);\n\n    } else {\n      return parseTypeName(token);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex e30c3509..c8f971b1 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1905,7 +1905,42 @@ public final class JsDocInfoParser {\n    * For expressions on the right hand side of a this: or new:\n    */\n   private Node parseContextTypeExpression(JsDocToken token) {\n-          return parseTypeName(token);\n+    if (token.getType() == JsDocToken.Type.LC) {\n+      // context is a function type\n+      token = nextToken();\n+      Node params = null;\n+      Node returnType = null;\n+      while (token != null && token.getType() != JsDocToken.Type.RC) {\n+        if (token.getType() == JsDocToken.Type.COLON) {\n+          Node type = parseContextTypeExpression(nextToken());\n+          if (type == null) {\n+            reportWarning(token, \"Bad type annotation. type not recognized due to syntax error\");\n+          } else {\n+            if (params == null) {\n+              params = type;\n+            } else if (returnType == null) {\n+              returnType = type;\n+            } else {\n+              reportWarning(token, \"Bad function type annotation. Unexpected token after return type.\");\n+            }\n+          }\n+        } else if (params == null) {\n+          params = parseContextTypeExpression(token);\n+        } else if (returnType == null) {\n+          returnType = parseContextTypeExpression(token);\n+        } else {\n+          reportWarning(token, \"Bad function type annotation. Unexpected token after return type.\");\n+        }\n+        token = nextToken();\n+      }\n+      if (params == null) {\n+        reportWarning(token, \"Bad function type annotation. Missing parameter type(s).\");\n+      }\n+      return JSDocInfo.buildFunctionType(params, returnType);\n+\n+    } else {\n+      return parseTypeName(token);\n+    }\n   }\n \n   /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}