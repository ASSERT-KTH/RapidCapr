{
    "patch": "        double yMid, xup, yUp, xLo, yLo = 0, xTmp, yTmp;\n        yUp = yMax;\n        xLo = min;\n        xup = max;\n        double dTmp = initial;\n        double minDiff = Double.MAX_VALUE;\n        final int maxIterations = maximalIterationCount;\n        final boolean isStrictlyMonotonic = Verifier.verifySequence(f, min, initial, max);\n        double temp = 0;\n        int intervalsUsed = 1;\n        while (true) {\n          final double oldMin = xLo;\n          final double oldMax = xup;\n          final double oldTmp = dTmp;\n          yMid = f.value(dTmp);\n          if (Math.abs(yMid) <= functionValueAccuracy) {\n            setResult(dTmp, intervalsUsed);\n            return result;\n          }\n          if ((yMid > 0 && yLo > 0) || (yMid < 0 && yLo < 0)) {\n            // Move up bounds\n            yLo = yMid;\n            xLo = dTmp;\n          } else if ((yMid < 0 && yUp < 0) || (yMid > 0 && yUp > 0)) {\n            // Move down bounds\n            yUp = yMid;\n            xup = dTmp;\n          } else {\n            // minimum point found\n            xLo = xup = dTmp;\n            yLo = yUp = yMid;\n          }\n          // Tighten bounds\n          if (yMid < 0) {\n            double aux = xLo;\n            xLo = xup;\n            xup = aux;\n            aux = yLo;\n            yLo = yUp;\n            yUp = aux;\n          }\n          if (xup == xLo || (Math.abs(yLo) < eps && Math.abs(yUp) < eps)) {\n            setResult(dTmp, intervalsUsed);\n            return result;\n          }\n          xTmp = (secant(xLo, yLo, xup, yUp) + bisection(xLo, xup)) / 2;\n          if (Math.abs(xTmp - dTmp) <= functionValueAccuracy) {\n            temp = 0;\n          } else {\n            temp = Math.abs(dTmp - xTmp) / Math.max(Math.abs(xTmp), 1.0);\n          }\n          if (temp < minDiff) {\n            minDiff = temp;\n          }\n          if (--maxIterations == 0) {\n            if (isStrictlyMonotonic) {\n              setResult(dTmp, intervalsUsed);\n              return result;\n            }\n            throw new MaxIterationsExceededException(maxIterations);\n          }\n          if (Math.abs(yMid) <= functionValueAccuracy) {\n            setResult(dTmp, intervalsUsed);\n            return result;\n          }\n          if (yMid * yLo <= 0.0) {\n            xup = dTmp;\n            yUp = yMid;\n          } else {\n            xLo = dTmp;\n            yLo = yMid;\n          }\n          // If the result is converging, reduce the maximal number of iteration gradually\n          final int iter = maximalIterationCount - maxIterations;\n          if (iter > 2 && isStrictlyMonotonic && minDiff < .01) {\n            maximalIterationCount = iter + Math.max(15, iter / 5);\n          }\n          dTmp = xTmp;\n          intervalsUsed++;\n        }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..da387e9b1 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,86 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double yMid, xup, yUp, xLo, yLo = 0, xTmp, yTmp;\n+        yUp = yMax;\n+        xLo = min;\n+        xup = max;\n+        double dTmp = initial;\n+        double minDiff = Double.MAX_VALUE;\n+        final int maxIterations = maximalIterationCount;\n+        final boolean isStrictlyMonotonic = Verifier.verifySequence(f, min, initial, max);\n+        double temp = 0;\n+        int intervalsUsed = 1;\n+        while (true) {\n+          final double oldMin = xLo;\n+          final double oldMax = xup;\n+          final double oldTmp = dTmp;\n+          yMid = f.value(dTmp);\n+          if (Math.abs(yMid) <= functionValueAccuracy) {\n+            setResult(dTmp, intervalsUsed);\n+            return result;\n+          }\n+          if ((yMid > 0 && yLo > 0) || (yMid < 0 && yLo < 0)) {\n+            // Move up bounds\n+            yLo = yMid;\n+            xLo = dTmp;\n+          } else if ((yMid < 0 && yUp < 0) || (yMid > 0 && yUp > 0)) {\n+            // Move down bounds\n+            yUp = yMid;\n+            xup = dTmp;\n+          } else {\n+            // minimum point found\n+            xLo = xup = dTmp;\n+            yLo = yUp = yMid;\n+          }\n+          // Tighten bounds\n+          if (yMid < 0) {\n+            double aux = xLo;\n+            xLo = xup;\n+            xup = aux;\n+            aux = yLo;\n+            yLo = yUp;\n+            yUp = aux;\n+          }\n+          if (xup == xLo || (Math.abs(yLo) < eps && Math.abs(yUp) < eps)) {\n+            setResult(dTmp, intervalsUsed);\n+            return result;\n+          }\n+          xTmp = (secant(xLo, yLo, xup, yUp) + bisection(xLo, xup)) / 2;\n+          if (Math.abs(xTmp - dTmp) <= functionValueAccuracy) {\n+            temp = 0;\n+          } else {\n+            temp = Math.abs(dTmp - xTmp) / Math.max(Math.abs(xTmp), 1.0);\n+          }\n+          if (temp < minDiff) {\n+            minDiff = temp;\n+          }\n+          if (--maxIterations == 0) {\n+            if (isStrictlyMonotonic) {\n+              setResult(dTmp, intervalsUsed);\n+              return result;\n+            }\n+            throw new MaxIterationsExceededException(maxIterations);\n+          }\n+          if (Math.abs(yMid) <= functionValueAccuracy) {\n+            setResult(dTmp, intervalsUsed);\n+            return result;\n+          }\n+          if (yMid * yLo <= 0.0) {\n+            xup = dTmp;\n+            yUp = yMid;\n+          } else {\n+            xLo = dTmp;\n+            yLo = yMid;\n+          }\n+          // If the result is converging, reduce the maximal number of iteration gradually\n+          final int iter = maximalIterationCount - maxIterations;\n+          if (iter > 2 && isStrictlyMonotonic && minDiff < .01) {\n+            maximalIterationCount = iter + Math.max(15, iter / 5);\n+          }\n+          dTmp = xTmp;\n+          intervalsUsed++;\n+        }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}