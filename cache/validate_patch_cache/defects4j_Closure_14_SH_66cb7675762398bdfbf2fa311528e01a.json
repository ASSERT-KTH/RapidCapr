{
    "patch": "        Node nextSibling = node.getNext();\n        // Skip function declarations because control doesn't get passed into it.\n        while (nextSibling != null && nextSibling.isFunction()) {\n          nextSibling = nextSibling.getNext();\n        }\n\n        // If there are no more siblings, control is transferred up the AST.\n>>> [ INFILL ] <<<\n        if (nextSibling == null) {\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n\n        // If the next immediate sibling is a function, and it is already\n        // in the CFG, then skip over it.\n        if (cfa != null && nextSibling.isFunction()) {\n          NodeReachable hasForwardEdgeTo = cfa.getHasForwardEdgeTo(nextSibling);\n\n          if (hasForwardEdgeTo == NodeReachable.REACHABLE_BY_FALL_THROUGH) {\n            return computeFallThrough(nextSibling);\n          } else if (hasForwardEdgeTo == NodeReachable.REACHABLE_BY_BRANCH) {\n            List<DiGraphEdge<Node, Branch>> outEdges = getCfg().getOutEdges(nextSibling);\n            if (outEdges.size() == 1) {\n              DiGraphEdge<Node, Branch> nextEdge = outEdges.get(0);\n              return nextEdge.getDestination();\n            } else {\n              Preconditions.checkState(false, \"Function linked to more than one CFG edge.\");\n            }\n          }\n\n          // If the function is new, it will eventually get added to the CFG\n          // and we'll take the branch when recomputing the follow node then.\n          return computeFollowNode(fromNode, parent, cfa);\n        }\n\n        return computeFallThrough(nextSibling);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..a9f9d2c4 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,41 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+        Node nextSibling = node.getNext();\n+        // Skip function declarations because control doesn't get passed into it.\n+        while (nextSibling != null && nextSibling.isFunction()) {\n+          nextSibling = nextSibling.getNext();\n+        }\n+\n+        // If there are no more siblings, control is transferred up the AST.\n+>>> [ INFILL ] <<<\n+        if (nextSibling == null) {\n+          return computeFollowNode(fromNode, parent, cfa);\n+        }\n+\n+        // If the next immediate sibling is a function, and it is already\n+        // in the CFG, then skip over it.\n+        if (cfa != null && nextSibling.isFunction()) {\n+          NodeReachable hasForwardEdgeTo = cfa.getHasForwardEdgeTo(nextSibling);\n+\n+          if (hasForwardEdgeTo == NodeReachable.REACHABLE_BY_FALL_THROUGH) {\n+            return computeFallThrough(nextSibling);\n+          } else if (hasForwardEdgeTo == NodeReachable.REACHABLE_BY_BRANCH) {\n+            List<DiGraphEdge<Node, Branch>> outEdges = getCfg().getOutEdges(nextSibling);\n+            if (outEdges.size() == 1) {\n+              DiGraphEdge<Node, Branch> nextEdge = outEdges.get(0);\n+              return nextEdge.getDestination();\n+            } else {\n+              Preconditions.checkState(false, \"Function linked to more than one CFG edge.\");\n+            }\n+          }\n+\n+          // If the function is new, it will eventually get added to the CFG\n+          // and we'll take the branch when recomputing the follow node then.\n+          return computeFollowNode(fromNode, parent, cfa);\n+        }\n+\n+        return computeFallThrough(nextSibling);\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}