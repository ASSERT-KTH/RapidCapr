{
    "patch": "import com.google.common.base.Preconditions;\nimport com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.ControlFlowGraph;\nimport com.google.javascript.jscomp.DataFlowAnalysis;\nimport com.google.javascript.jscomp.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.DiGraph.DiGraphNode;\nimport com.google.javascript.jscomp.JSType;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.ObjectType;\nimport com.google.javascript.jscomp.Result;\nimport com.google.javascript.jscomp.Scope;\nimport com.google.javascript.jscomp.TypeMismatch;\nimport com.google.javascript.jscomp.TypeReferenceCollector;\nimport com.google.javascript.jscomp.TypedScope;\nimport com.google.javascript.rhino.Node;\n\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Automated program repair tool.\n */\npublic class ProgramRepairTool {\n\n  private static final JSType unknownType = JSType.UNKNOWN;\n\n  private AbstractCompiler compiler;\n  private TypedScope syntacticScope;\n  private ControlFlowGraph<Node> cfg;\n  private Set<Node> cfgNodes = new HashSet<>();\n\n  /**\n   * Create the tool.\n   * \n   * @param compiler the compiler to use for the analysis\n   */\n  public ProgramRepairTool(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  /**\n   * Repair a JavaScrip AST.\n   *\n   * @param ast the AST to repair\n   * @return the repaired AST, or null if no repairs could be made\n   */\n  public Node repair(Node ast) {\n    syntacticScope = compiler.getTopScope();\n    cfg = new ControlFlowGraph<>(ast);\n    DataFlowAnalysis<Node, Branch> reachingDefsAnalysis = new ReachingDefs(cfg);\n    reachingDefsAnalysis.analyze();\n\n    DataFlowAnalysis<Node, JSType> typeAnalysis =\n        new TemplateTypeInference(syntacticScope, compiler.getTypeRegistry(), unknownType);\n    typeAnalysis.analyze();\n\n    TypeReferenceCollector collector = new TypeReferenceCollector(compiler);\n\n    for (Node rootNode : NodeUtil.getFunctionBody(ast).children()) {\n      // Instantiate the CFG and traverse it, repairing nodes as necessary\n      DiGraphNode<Node, Branch> root = cfg.createNode(rootNode);\n      cfgNodes.add(rootNode);\n      visit(cfg, root, reachingDefsAnalysis, typeAnalysis, collector);\n    }\n\n    Result result = compiler.check(ast);\n    if (result.success) {\n      return ast;\n    }\n    return null;\n  }\n\n  private void visit(\n      ControlFlowGraph<Node> cfg,\n      DiGraphNode<Node, Branch> node,\n      DataFlowAnalysis<Node, Branch> reachingDefs,\n      DataFlowAnalysis<Node, JSType> typeAnalysis,\n      TypeReferenceCollector collector) {\n    Node cfgNode = node.getValue();\n    Set<Node> visitableChildren = getVisitableChildren(cfgNode);\n\n    visitNode(cfgNode, typeAnalysis, collector);\n\n    // Traverse the tree in pre-order, visiting each child and repairing it\n    for (DiGraphEdge<Node, Branch> edge : cfg.getOutEdges(node)) {\n      Node child = edge.getDestination().getValue();\n      if (visitableChildren.contains(child)) {\n        reachingDefs.crossFunctionDefine(node, edge); // Update reaching defs analysis\n        visit(edge.getDestination(), reachingDefs, typeAnalysis, collector);\n      }\n    }\n  }\n\n  private Set<Node> getVisitableChildren(Node node) {\n    Set<Node> visitableChildren = new HashSet<>();\n    for (Node child : node.children()) {\n      if (child.isFunction()) {\n        // Optimization: do not traverse inside function bodies\n        break;\n      }\n      switch (child.getToken()) {\n        case Token.BLOCK:\n        case Token.SCRIPT:\n          // Only traverse inside blocks and at the top level of a script\n          visitableChildren.add(child);\n          break;\n        default:\n          // Do not visit other node types\n          break;\n      }\n    }\n    return visitableChildren;\n  }\n\n  private void visitNode(\n      Node node,\n      DataFlowAnalysis<Node, JSType> typeAnalysis,\n      TypeReferenceCollector collector) {\n    switch (node.getToken()) {\n      case Token.NAME:\n        TypeMismatch mismatch = typeAnalysis.getMismatch(node);\n        if (mismatch != null) {\n          JSType leftType =\n              mismatch.getLeftType() != null ? mismatch.getLeftType() : unknownType;\n          JSType rightType =\n              mismatch.getRightType() != null ? mismatch.getRightType() : unknownType;\n          maybeInferTemplateTypeName(mismatch.getTemplateType(), node, rightType);\n          fixTypeMismatch(node, leftType, rightType, typeAnalysis.getScope());\n        }\n        break;\n      case Token.VAR:\n      case Token.LET:\n      case Token.CONST:\n        collector.processVariableDeclaration(node);\n        break;\n      case Token.ASSIGN:\n      case Token.NAME:\n      case Token.GETPROP:\n      case Token.FUNCTION:\n        TypeMismatch mismatch2 = typeAnalysis.getMismatch(node);\n        if (mismatch2 != null) {\n          JSType leftType =\n              mismatch2.getLeftType() != null ? mismatch2.getLeftType() : unknownType;\n          JSType rightType =\n              mismatch2.getRightType() != null ? mismatch2.getRightType() : unknownType;\n          maybeInferTemplateTypeName(mismatch2.getTemplateType(), node, rightType);\n          fixTypeMismatch(node, leftType, rightType, typeAnalysis.getScope());\n        }\n        break;\n      default:\n        break;\n    }\n  }\n\n  private void fixTypeMismatch(\n      Node node, JSType leftType, JSType rightType, TypedScope scope) {\n    JSType fixedType = leftType.getLeastSupertype(rightType);\n    if (fixedType == null) {\n      fixedType = rightType.getLeastSupertype(leftType);\n    }\n    if (fixedType != null) {\n      NodeUtil.setNodeTypeI(node, fixedType);\n    }\n    Preconditions.checkNotNull(fixedType);\n    switch (node.getToken()) {\n      case Token.ASSIGN:\n        maybeUnwrapQualifiedName(\n            scope, node.getFirstChild(), leftType, rightType, fixedType, node.getLastChild());\n        break;\n      case Token.NAME:\n        Node parent = node.getParent();\n        if (parent.isParamList()) {\n          parent.addChildAfter(\n              Node.newString(Token.DEFAULT_VALUE, \"\"),\n              node.getNext(), node.getSyntheticFlag());\n        } else if (NodeUtil.isEnhancedFor(parent)) {\n          parent.addChildBefore(\n              Node.newString(Token.NAME, \"\"),\n              parent.getLastChild().getPrevious(), parent.getSyntheticFlag());\n        }\n        maybeUnwrapQualifiedName(scope, node, leftType, rightType, fixedType, null);\n        break;\n      case Token.FUNCTION:\n        node.setJSType(fixedType);\n        break;\n      default:\n        break;\n    }\n  }\n\n  private void maybeUnwrapQualifiedName(\n      TypedScope scope,\n      Node node,\n      JSType leftType,\n      JSType rightType,\n      JSType fixedType,\n      Node rhsNode) {\n    Node parent = node.getParent();\n    if (!parent.isGetProp() || !node.isQualifiedName()\n        || !syntaxInScope(scope, node.getFirstChild())) {\n      return;\n    }\n    JSType parentType = getJSType(parent.getFirstChild());\n    if (!parentType.isObjectType() || parentType.isUnknownType()\n        || !syntaxInScope(scope, parent.getFirstChild())) {\n      return;\n    }\n    ObjectType objectType = ObjectType.cast(parentType);\n    String propName = node.getLastChild().getString();\n    JSType currentPropType =\n        objectType.inferPropertyType(propName, rhsNode != null ? rhsNode : node.getParent());\n    if (currentPropType == null || currentPropType.isUnknownType()) {\n      currentPropType = rhsNode != null ? rightType : unknownType;\n    }\n    if (currentPropType.isFunctionType() || fixedType.isFunctionType()) {\n      // Avoid unwrapping types that involve functions\n      return;\n    }\n    ObjectType newObjectType = objectType.withoutProperty(propName);\n    newObjectType = newObjectType.withProperty(propName, fixedType);\n    JSType newType = maybeChangeType(currentPropType, fixedType, newObjectType);\n    if (node.getNext() == null) {\n      // Last part of a qualified name, replace entire getprop\n      Node replacementNode = NodeUtil.newQName(compiler, node.getQualifiedName(), newType);\n      replacementNode.setJSType(newType);\n      parent.replaceWith(replacementNode);\n    } else {\n      node.replaceWith(NodeUtil.newQName(compiler, node.getQualifiedName(), newType));\n    }\n  }\n\n  private JSType maybeChangeType(JSType before, JSType after, ObjectType newObjType) {\n    Preconditions.checkNotNull(before);\n    Preconditions.checkNotNull(after);\n    if (before.isUnknownType() && after.isUnknownType()) {\n      return after;\n    }\n    if (before.isUnknownType()) {\n      return newObjType;\n    }\n    if (after.isUnknownType()) {\n      return before;\n    }\n    if (!newObjType.isStruct() && !before.isSubtype(after)) {\n      return before;\n    }\n    return newObjType;\n  }\n\n  private boolean syntaxInScope(TypedScope scope, Node node) {\n    return scope.getRootNode().getStaticSourceFile().equals(node.getStaticSourceFile());\n  }\n\n  private JSType getJSType(Node node) {\n    JSType type = node.getJSType();\n    if (type == null) {\n      type = unknownType;\n    }\n    return type;\n  }\n\n  private void maybeInferTemplateTypeName(\n      TemplateType templateType, Node typeNode, JSType typeValue) {\n    // Do not store disjunctions in the name type map so that we only infer\n    // types when they can be guaranteedly resolved to a single type.\n    if (typeValue.isNoType() || typeValue.isDisjunctive()) {\n      return;\n    }\n    Node nameNode = templateType.getNameNode();\n    String name = nameNode.getQualifiedName();\n    if (templateTypeRegistry.getTemplateTypeByName(name) != null || !nameNode.isGetProp()) {\n      return;\n    }\n    ObjectType objType = ObjectType.cast(typeValue.restrictByNotNullOrUndefined());\n    if (ob",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..860b8eb8 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,109 +521,282 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n+import com.google.common.base.Preconditions;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.ControlFlowGraph;\n+import com.google.javascript.jscomp.DataFlowAnalysis;\n+import com.google.javascript.jscomp.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.DiGraph.DiGraphNode;\n+import com.google.javascript.jscomp.JSType;\n+import com.google.javascript.jscomp.NodeUtil;\n+import com.google.javascript.jscomp.ObjectType;\n+import com.google.javascript.jscomp.Result;\n+import com.google.javascript.jscomp.Scope;\n+import com.google.javascript.jscomp.TypeMismatch;\n+import com.google.javascript.jscomp.TypeReferenceCollector;\n+import com.google.javascript.jscomp.TypedScope;\n+import com.google.javascript.rhino.Node;\n \n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n \n+/**\n+ * Automated program repair tool.\n+ */\n+public class ProgramRepairTool {\n \n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n+  private static final JSType unknownType = JSType.UNKNOWN;\n+\n+  private AbstractCompiler compiler;\n+  private TypedScope syntacticScope;\n+  private ControlFlowGraph<Node> cfg;\n+  private Set<Node> cfgNodes = new HashSet<>();\n+\n+  /**\n+   * Create the tool.\n+   * \n+   * @param compiler the compiler to use for the analysis\n+   */\n+  public ProgramRepairTool(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  /**\n+   * Repair a JavaScrip AST.\n+   *\n+   * @param ast the AST to repair\n+   * @return the repaired AST, or null if no repairs could be made\n+   */\n+  public Node repair(Node ast) {\n+    syntacticScope = compiler.getTopScope();\n+    cfg = new ControlFlowGraph<>(ast);\n+    DataFlowAnalysis<Node, Branch> reachingDefsAnalysis = new ReachingDefs(cfg);\n+    reachingDefsAnalysis.analyze();\n+\n+    DataFlowAnalysis<Node, JSType> typeAnalysis =\n+        new TemplateTypeInference(syntacticScope, compiler.getTypeRegistry(), unknownType);\n+    typeAnalysis.analyze();\n+\n+    TypeReferenceCollector collector = new TypeReferenceCollector(compiler);\n+\n+    for (Node rootNode : NodeUtil.getFunctionBody(ast).children()) {\n+      // Instantiate the CFG and traverse it, repairing nodes as necessary\n+      DiGraphNode<Node, Branch> root = cfg.createNode(rootNode);\n+      cfgNodes.add(rootNode);\n+      visit(cfg, root, reachingDefsAnalysis, typeAnalysis, collector);\n+    }\n \n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n+    Result result = compiler.check(ast);\n+    if (result.success) {\n+      return ast;\n+    }\n+    return null;\n+  }\n+\n+  private void visit(\n+      ControlFlowGraph<Node> cfg,\n+      DiGraphNode<Node, Branch> node,\n+      DataFlowAnalysis<Node, Branch> reachingDefs,\n+      DataFlowAnalysis<Node, JSType> typeAnalysis,\n+      TypeReferenceCollector collector) {\n+    Node cfgNode = node.getValue();\n+    Set<Node> visitableChildren = getVisitableChildren(cfgNode);\n+\n+    visitNode(cfgNode, typeAnalysis, collector);\n+\n+    // Traverse the tree in pre-order, visiting each child and repairing it\n+    for (DiGraphEdge<Node, Branch> edge : cfg.getOutEdges(node)) {\n+      Node child = edge.getDestination().getValue();\n+      if (visitableChildren.contains(child)) {\n+        reachingDefs.crossFunctionDefine(node, edge); // Update reaching defs analysis\n+        visit(edge.getDestination(), reachingDefs, typeAnalysis, collector);\n+      }\n+    }\n+  }\n+\n+  private Set<Node> getVisitableChildren(Node node) {\n+    Set<Node> visitableChildren = new HashSet<>();\n+    for (Node child : node.children()) {\n+      if (child.isFunction()) {\n+        // Optimization: do not traverse inside function bodies\n+        break;\n+      }\n+      switch (child.getToken()) {\n+        case Token.BLOCK:\n+        case Token.SCRIPT:\n+          // Only traverse inside blocks and at the top level of a script\n+          visitableChildren.add(child);\n+          break;\n+        default:\n+          // Do not visit other node types\n+          break;\n+      }\n+    }\n+    return visitableChildren;\n+  }\n+\n+  private void visitNode(\n+      Node node,\n+      DataFlowAnalysis<Node, JSType> typeAnalysis,\n+      TypeReferenceCollector collector) {\n+    switch (node.getToken()) {\n+      case Token.NAME:\n+        TypeMismatch mismatch = typeAnalysis.getMismatch(node);\n+        if (mismatch != null) {\n+          JSType leftType =\n+              mismatch.getLeftType() != null ? mismatch.getLeftType() : unknownType;\n+          JSType rightType =\n+              mismatch.getRightType() != null ? mismatch.getRightType() : unknownType;\n+          maybeInferTemplateTypeName(mismatch.getTemplateType(), node, rightType);\n+          fixTypeMismatch(node, leftType, rightType, typeAnalysis.getScope());\n         }\n         break;\n+      case Token.VAR:\n+      case Token.LET:\n+      case Token.CONST:\n+        collector.processVariableDeclaration(node);\n+        break;\n+      case Token.ASSIGN:\n+      case Token.NAME:\n       case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n+      case Token.FUNCTION:\n+        TypeMismatch mismatch2 = typeAnalysis.getMismatch(node);\n+        if (mismatch2 != null) {\n+          JSType leftType =\n+              mismatch2.getLeftType() != null ? mismatch2.getLeftType() : unknownType;\n+          JSType rightType =\n+              mismatch2.getRightType() != null ? mismatch2.getRightType() : unknownType;\n+          maybeInferTemplateTypeName(mismatch2.getTemplateType(), node, rightType);\n+          fixTypeMismatch(node, leftType, rightType, typeAnalysis.getScope());\n         }\n+        break;\n+      default:\n+        break;\n+    }\n+  }\n \n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n+  private void fixTypeMismatch(\n+      Node node, JSType leftType, JSType rightType, TypedScope scope) {\n+    JSType fixedType = leftType.getLeastSupertype(rightType);\n+    if (fixedType == null) {\n+      fixedType = rightType.getLeastSupertype(leftType);\n+    }\n+    if (fixedType != null) {\n+      NodeUtil.setNodeTypeI(node, fixedType);\n+    }\n+    Preconditions.checkNotNull(fixedType);\n+    switch (node.getToken()) {\n+      case Token.ASSIGN:\n+        maybeUnwrapQualifiedName(\n+            scope, node.getFirstChild(), leftType, rightType, fixedType, node.getLastChild());\n+        break;\n+      case Token.NAME:\n+        Node parent = node.getParent();\n+        if (parent.isParamList()) {\n+          parent.addChildAfter(\n+              Node.newString(Token.DEFAULT_VALUE, \"\"),\n+              node.getNext(), node.getSyntheticFlag());\n+        } else if (NodeUtil.isEnhancedFor(parent)) {\n+          parent.addChildBefore(\n+              Node.newString(Token.NAME, \"\"),\n+              parent.getLastChild().getPrevious(), parent.getSyntheticFlag());\n+        }\n+        maybeUnwrapQualifiedName(scope, node, leftType, rightType, fixedType, null);\n+        break;\n+      case Token.FUNCTION:\n+        node.setJSType(fixedType);\n+        break;\n+      default:\n         break;\n     }\n   }\n \n-  /**\n-   * Defines a property if the property has not been defined yet.\n-   */\n-  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n-    String propName = getprop.getLastChild().getString();\n-    Node obj = getprop.getFirstChild();\n-    JSType nodeType = getJSType(obj);\n-    ObjectType objectType = ObjectType.cast(\n-        nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n-        getJSType(syntacticScope.getRootNode()).isConstructor();\n-\n-    if (objectType == null) {\n-      registry.registerPropertyOnType(propName, nodeType);\n+  private void maybeUnwrapQualifiedName(\n+      TypedScope scope,\n+      Node node,\n+      JSType leftType,\n+      JSType rightType,\n+      JSType fixedType,\n+      Node rhsNode) {\n+    Node parent = node.getParent();\n+    if (!parent.isGetProp() || !node.isQualifiedName()\n+        || !syntaxInScope(scope, node.getFirstChild())) {\n+      return;\n+    }\n+    JSType parentType = getJSType(parent.getFirstChild());\n+    if (!parentType.isObjectType() || parentType.isUnknownType()\n+        || !syntaxInScope(scope, parent.getFirstChild())) {\n+      return;\n+    }\n+    ObjectType objectType = ObjectType.cast(parentType);\n+    String propName = node.getLastChild().getString();\n+    JSType currentPropType =\n+        objectType.inferPropertyType(propName, rhsNode != null ? rhsNode : node.getParent());\n+    if (currentPropType == null || currentPropType.isUnknownType()) {\n+      currentPropType = rhsNode != null ? rightType : unknownType;\n+    }\n+    if (currentPropType.isFunctionType() || fixedType.isFunctionType()) {\n+      // Avoid unwrapping types that involve functions\n+      return;\n+    }\n+    ObjectType newObjectType = objectType.withoutProperty(propName);\n+    newObjectType = newObjectType.withProperty(propName, fixedType);\n+    JSType newType = maybeChangeType(currentPropType, fixedType, newObjectType);\n+    if (node.getNext() == null) {\n+      // Last part of a qualified name, replace entire getprop\n+      Node replacementNode = NodeUtil.newQName(compiler, node.getQualifiedName(), newType);\n+      replacementNode.setJSType(newType);\n+      parent.replaceWith(replacementNode);\n     } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n-        boolean staticPropCreation = false;\n-        Node maybeAssignStm = getprop.getParent().getParent();\n-        if (syntacticScope.isGlobal() &&\n-            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n-          String propCreationFilename = maybeAssignStm.getSourceFileName();\n-          Node ctor = objectType.getOwnerFunction().getSource();\n-          if (ctor != null &&\n-              ctor.getSourceFileName().equals(propCreationFilename)) {\n-            staticPropCreation = true;\n-          }\n-        }\n-        if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n-        }\n-      }\n+      node.replaceWith(NodeUtil.newQName(compiler, node.getQualifiedName(), newType));\n+    }\n+  }\n+\n+  private JSType maybeChangeType(JSType before, JSType after, ObjectType newObjType) {\n+    Preconditions.checkNotNull(before);\n+    Preconditions.checkNotNull(after);\n+    if (before.isUnknownType() && after.isUnknownType()) {\n+      return after;\n+    }\n+    if (before.isUnknownType()) {\n+      return newObjType;\n+    }\n+    if (after.isUnknownType()) {\n+      return before;\n+    }\n+    if (!newObjType.isStruct() && !before.isSubtype(after)) {\n+      return before;\n+    }\n+    return newObjType;\n+  }\n+\n+  private boolean syntaxInScope(TypedScope scope, Node node) {\n+    return scope.getRootNode().getStaticSourceFile().equals(node.getStaticSourceFile());\n+  }\n+\n+  private JSType getJSType(Node node) {\n+    JSType type = node.getJSType();\n+    if (type == null) {\n+      type = unknownType;\n+    }\n+    return type;\n+  }\n+\n+  private void maybeInferTemplateTypeName(\n+      TemplateType templateType, Node typeNode, JSType typeValue) {\n+    // Do not store disjunctions in the name type map so that we only infer\n+    // types when they can be guaranteedly resolved to a single type.\n+    if (typeValue.isNoType() || typeValue.isDisjunctive()) {\n+      return;\n+    }\n+    Node nameNode = templateType.getNameNode();\n+    String name = nameNode.getQualifiedName();\n+    if (templateTypeRegistry.getTemplateTypeByName(name) != null || !nameNode.isGetProp()) {\n+      return;\n+    }\n+    ObjectType objType = ObjectType.cast(typeValue.restrictByNotNullOrUndefined());\n+    if (ob\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}