{
    "patch": "public Dfp multiply(final int x) {\n    if(isNaN()) {\n        return newInstance(getField(), NAN);\n    }\n    if(x == 0) {\n        return newInstance(getField(), getZero());\n    }\n    Dfp result = newInstance(this);\n    boolean nonnegative = x > 0;\n    int[] work = new int[NE];\n    if(nonnegative) {\n        for(int i = 0; i < NE; i++) {\n            work[i] = mant[i];\n        }\n    } else {\n        for(int i = 0; i < NE; i++) {\n            work[i] = -mant[i];\n        }\n    }\n    for(int i = 0; i < NE - 1; i++) {\n        for(int j = 0; j < NE - 1 - i; j++) {\n            int[] prod = mult(work[j], x, radixDigits);\n            int[] newsum = addMult(result.mant, prod, work[j + 1], radixDigits);\n            if(!needToSplit(newsum)) {\n                result.mant = newsum;\n            } else {\n                shift(newsum, 1);\n                result.exp++;\n                if(nonnegative) {\n                    result.mant = subtract(newsum, getOne(), radixDigits);\n                } else {\n                    result.mant = add(newsum, getOne(), radixDigits);\n                }\n            }\n        }\n    }\n    if(!nonnegative) {\n        result.negate();\n    }\n    if(result.classifyFinite() == INFINITE && classifyFinite() != ZERO) {\n        getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n    }\n    return dotrap(DfpField.TRAP_MULTIPLY, \"multiply\", result);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..c5e7a73f0 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1599,9 +1599,50 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param x multiplicand\n      * @return product of this and x\n      */\n-    public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n+public Dfp multiply(final int x) {\n+    if(isNaN()) {\n+        return newInstance(getField(), NAN);\n+    }\n+    if(x == 0) {\n+        return newInstance(getField(), getZero());\n+    }\n+    Dfp result = newInstance(this);\n+    boolean nonnegative = x > 0;\n+    int[] work = new int[NE];\n+    if(nonnegative) {\n+        for(int i = 0; i < NE; i++) {\n+            work[i] = mant[i];\n+        }\n+    } else {\n+        for(int i = 0; i < NE; i++) {\n+            work[i] = -mant[i];\n+        }\n+    }\n+    for(int i = 0; i < NE - 1; i++) {\n+        for(int j = 0; j < NE - 1 - i; j++) {\n+            int[] prod = mult(work[j], x, radixDigits);\n+            int[] newsum = addMult(result.mant, prod, work[j + 1], radixDigits);\n+            if(!needToSplit(newsum)) {\n+                result.mant = newsum;\n+            } else {\n+                shift(newsum, 1);\n+                result.exp++;\n+                if(nonnegative) {\n+                    result.mant = subtract(newsum, getOne(), radixDigits);\n+                } else {\n+                    result.mant = add(newsum, getOne(), radixDigits);\n+                }\n+            }\n+        }\n+    }\n+    if(!nonnegative) {\n+        result.negate();\n     }\n+    if(result.classifyFinite() == INFINITE && classifyFinite() != ZERO) {\n+        getField().setIEEEFlagsBits(DfpField.FLAG_INVALID);\n+    }\n+    return dotrap(DfpField.TRAP_MULTIPLY, \"multiply\", result);\n+}\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n      * There are speed advantages in this special case.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}