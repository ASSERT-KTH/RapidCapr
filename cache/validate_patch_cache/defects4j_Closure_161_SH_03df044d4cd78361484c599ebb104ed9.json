{
    "patch": "    if (left.getType() == Token.ARRAYLIT) {\n      // Only fold array access if literal array.\n      Node[] elements = left.getChildren().toArray(new Node[0]);\n      if (intIndex < elements.length) {\n        Node element = elements[intIndex];\n        if (element.getType() == Token.EMPTY) {\n          element = NodeUtil.newUndefinedNode(element);\n        } else {\n          left.removeChild(element);\n        }\n\n        // Replace the entire GETELEM with the value.\n        n.getParent().replaceChild(n, element);\n        reportCodeChange();\n\n        // Statements have no value.\n        if (parent.getType() != Token.EXPR_RESULT) {\n          return element;\n        } else {\n          return null;\n        }\n      }\n    }\n    return n;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 0b2636f4..b010d4eb 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1280,6 +1280,30 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     // If GETPROP/GETELEM is used as assignment target the array literal is\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n+    if (left.getType() == Token.ARRAYLIT) {\n+      // Only fold array access if literal array.\n+      Node[] elements = left.getChildren().toArray(new Node[0]);\n+      if (intIndex < elements.length) {\n+        Node element = elements[intIndex];\n+        if (element.getType() == Token.EMPTY) {\n+          element = NodeUtil.newUndefinedNode(element);\n+        } else {\n+          left.removeChild(element);\n+        }\n+\n+        // Replace the entire GETELEM with the value.\n+        n.getParent().replaceChild(n, element);\n+        reportCodeChange();\n+\n+        // Statements have no value.\n+        if (parent.getType() != Token.EXPR_RESULT) {\n+          return element;\n+        } else {\n+          return null;\n+        }\n+      }\n+    }\n+    return n;\n \n     if (right.getType() != Token.NUMBER) {\n       // Sometimes people like to use complex expressions to index into",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}