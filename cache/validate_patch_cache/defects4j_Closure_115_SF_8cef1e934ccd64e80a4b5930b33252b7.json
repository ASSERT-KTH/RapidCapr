{
    "patch": "  private CanInlineResult canInlineReferenceDirectly(\n      Node callNode, Node fnNode) {\n    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n      return CanInlineResult.NO;\n    }\n\n    Node block = fnNode.getLastChild();\n\n    boolean hasSideEffects = false;\n    // Look for the last return statement and see if it has any side effects\n    if (block.hasChildren()) {\n      Node lastStmt = block.getLastChild().getLastChild();\n      if (lastStmt.isReturn()) {\n        hasSideEffects = NodeUtil.mayHaveSideEffects(lastStmt.getFirstChild(), compiler);\n      }\n    }\n\n    Node fnParams = NodeUtil.getFunctionParameters(fnNode);\n    Node cArgParam = callNode.getFirstFirstChild();\n    boolean hasExtraArgs = false;\n\n    while (cArgParam != null) {\n      if (hasExtraArgs) {\n        return CanInlineResult.NO;\n      }\n      if (fnParams == null) {\n        hasExtraArgs = true;\n      }\n      if (fnParams != null && fnParams.isDefaultValue()) {\n        // If fnParams have default values then assign call arguments to corresponding variable\n        Node nameNode = fnParams.getFirstChild();\n        if (!cArgParam.isSpread()) {\n          // Type checking will have verified that there's at least one @define.\n          Preconditions.checkState(nameNode.isName());\n          if (!nameNode.hasChildren()) {\n            nameNode.addChildToBack(IR.defaultValue(nameNode.getType()).srcref(nameNode));\n          }\n          nameNode.getFirstChild().replaceWith(cArgParam);\n          nameNode.removeChild(nameNode.getLastChild());\n          nameNode.putProp(Node.ORIGINAL_NAME_PROP, nameNode.getString());\n          nameNode.setString(\"\");\n        }\n        fnParams = fnParams.getNext();\n        cArgParam = cArgParam.getNext();\n        continue;\n      }\n      Node formalParameterNode = fnParams;\n      if (formalParameterNode.isRest()) {\n        hasExtraArgs = true;\n      }\n\n      if (cArgParam.isSpread()) {\n        // We have to handle a spread argument. In this case, we match it with\n        // a rest parameter if there are any remaining, or a normal parameter.\n        String variableName = null;\n        Node restParam = formalParameterNode;\n        while (restParam != null) {\n          if (restParam.isRest()) {\n            variableName = restParam.getNext().getString();\n            break; // Matched with a rest parameter.\n          }\n          variableName = restParam.getString();\n          restParam = restParam.getNext();\n        }\n        if (variableName == null) {\n          // We added a special check to prevent this error from happening in the type checker,\n          // but some libraries don't use the recommended form for dealing with rest parameters.\n          return CanInlineResult.NO;\n        }\n        Node nameNode = IR.name(variableName);\n        Node assignNode = IR.assign(nameNode, cArgParam.removeFirstChild());\n        assignNode.srcrefTreeIfMissing(callNode);\n        cArgParam.addChildToFront(assignNode);\n        break;\n      }\n      if (fnParams.isDefaultValue()) {\n        // If we have extra arguments and formal parameter is a default parameter, then we can skip processing it\n        if (!hasExtraArgs) {\n          formalParameterNode = fnParams.getFirstChild();\n        }\n      }\n\n      Node cArg = cArgParam;\n      if (cArg == null) {\n        if (formalParameterNode.isOptionalArg()) {\n          break;\n        }\n        return CanInlineResult.NO;\n      }\n      if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n        return CanInlineResult.NO;\n      }\n      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n        return CanInlineResult.NO;\n      }\n      cArgParam = cArgParam.getNext();\n      fnParams = fnParams.getNext();\n    }\n\n    return hasExtraArgs ? CanInlineResult.NO : CanInlineResult.YES;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex 73d6a4b3..428dca22 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -695,66 +695,97 @@ class FunctionInjector {\n     Node block = fnNode.getLastChild();\n \n     boolean hasSideEffects = false;\n+    // Look for the last return statement and see if it has any side effects\n     if (block.hasChildren()) {\n-      Preconditions.checkState(block.hasOneChild());\n-      Node stmt = block.getFirstChild();\n-      if (stmt.isReturn()) {\n-        hasSideEffects = NodeUtil.mayHaveSideEffects(stmt.getFirstChild(), compiler);\n+      Node lastStmt = block.getLastChild().getLastChild();\n+      if (lastStmt.isReturn()) {\n+        hasSideEffects = NodeUtil.mayHaveSideEffects(lastStmt.getFirstChild(), compiler);\n       }\n     }\n-    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n-    Node cArg = callNode.getFirstChild().getNext();\n \n-    // Functions called via 'call' and 'apply' have a this-object as\n-    // the first parameter, but this is not part of the called function's\n-    // parameter list.\n-    if (!callNode.getFirstChild().isName()) {\n-      if (NodeUtil.isFunctionObjectCall(callNode)) {\n-        // TODO(johnlenz): Support replace this with a value.\n-        if (cArg == null || !cArg.isThis()) {\n-          return CanInlineResult.NO;\n+    Node fnParams = NodeUtil.getFunctionParameters(fnNode);\n+    Node cArgParam = callNode.getFirstFirstChild();\n+    boolean hasExtraArgs = false;\n+\n+    while (cArgParam != null) {\n+      if (hasExtraArgs) {\n+        return CanInlineResult.NO;\n+      }\n+      if (fnParams == null) {\n+        hasExtraArgs = true;\n+      }\n+      if (fnParams != null && fnParams.isDefaultValue()) {\n+        // If fnParams have default values then assign call arguments to corresponding variable\n+        Node nameNode = fnParams.getFirstChild();\n+        if (!cArgParam.isSpread()) {\n+          // Type checking will have verified that there's at least one @define.\n+          Preconditions.checkState(nameNode.isName());\n+          if (!nameNode.hasChildren()) {\n+            nameNode.addChildToBack(IR.defaultValue(nameNode.getType()).srcref(nameNode));\n+          }\n+          nameNode.getFirstChild().replaceWith(cArgParam);\n+          nameNode.removeChild(nameNode.getLastChild());\n+          nameNode.putProp(Node.ORIGINAL_NAME_PROP, nameNode.getString());\n+          nameNode.setString(\"\");\n         }\n-        cArg = cArg.getNext();\n-      } else {\n-        // \".apply\" call should be filtered before this.\n-        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n+        fnParams = fnParams.getNext();\n+        cArgParam = cArgParam.getNext();\n+        continue;\n+      }\n+      Node formalParameterNode = fnParams;\n+      if (formalParameterNode.isRest()) {\n+        hasExtraArgs = true;\n       }\n-    }\n \n-    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n-    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n-    while (cArg != null || fnParam != null) {\n-      // For each named parameter check if a mutable argument use more than one.\n-      if (fnParam != null) {\n-        if (cArg != null) {\n-          if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n-            return CanInlineResult.NO;\n-          }\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n-            return CanInlineResult.NO;\n+      if (cArgParam.isSpread()) {\n+        // We have to handle a spread argument. In this case, we match it with\n+        // a rest parameter if there are any remaining, or a normal parameter.\n+        String variableName = null;\n+        Node restParam = formalParameterNode;\n+        while (restParam != null) {\n+          if (restParam.isRest()) {\n+            variableName = restParam.getNext().getString();\n+            break; // Matched with a rest parameter.\n           }\n+          variableName = restParam.getString();\n+          restParam = restParam.getNext();\n+        }\n+        if (variableName == null) {\n+          // We added a special check to prevent this error from happening in the type checker,\n+          // but some libraries don't use the recommended form for dealing with rest parameters.\n+          return CanInlineResult.NO;\n+        }\n+        Node nameNode = IR.name(variableName);\n+        Node assignNode = IR.assign(nameNode, cArgParam.removeFirstChild());\n+        assignNode.srcrefTreeIfMissing(callNode);\n+        cArgParam.addChildToFront(assignNode);\n+        break;\n+      }\n+      if (fnParams.isDefaultValue()) {\n+        // If we have extra arguments and formal parameter is a default parameter, then we can skip processing it\n+        if (!hasExtraArgs) {\n+          formalParameterNode = fnParams.getFirstChild();\n         }\n-\n-        // Move to the next name.\n-        fnParam = fnParam.getNext();\n       }\n \n-      // For every call argument check for side-effects, even if there\n-      // isn't a named parameter to match.\n-      if (cArg != null) {\n-        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n-          return CanInlineResult.NO;\n+      Node cArg = cArgParam;\n+      if (cArg == null) {\n+        if (formalParameterNode.isOptionalArg()) {\n+          break;\n         }\n-        cArg = cArg.getNext();\n+        return CanInlineResult.NO;\n+      }\n+      if (hasSideEffects && NodeUtil.canBeSideEffected(cArg)) {\n+        return CanInlineResult.NO;\n+      }\n+      if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n+        return CanInlineResult.NO;\n       }\n+      cArgParam = cArgParam.getNext();\n+      fnParams = fnParams.getNext();\n     }\n \n-    return CanInlineResult.YES;\n+    return hasExtraArgs ? CanInlineResult.NO : CanInlineResult.YES;\n   }\n \n   /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}