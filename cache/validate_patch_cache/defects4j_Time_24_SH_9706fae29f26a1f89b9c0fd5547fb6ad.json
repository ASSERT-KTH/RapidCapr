{
    "patch": "            long year = savedFields[i].iField.set(millis, savedFields[i].iValue);\n            if (year != millis) {\n                // if asking to parse \"Feb 29th\" and leap year not allowed, jump to March 1st\n                if (savedFields[i].iField.getType() == DateTimeFieldType.monthOfYear() &&\n                        DateTimeUtils.isLeapYear(year) == false &&\n                        savedFields[i + 1].iField.getType() == DateTimeFieldType.dayOfMonth() &&\n                        savedFields[i + 1].iValue.intValue() == 29) {\n                    millis = savedFields[i].iField.set(year, savedFields[i].iValue + 1);\n                    continue;\n                }\n                // if asking to parse \"W50\" or \"Q2\" with January as start of year, ensure leap\n                if (savedFields[i].iField.getType() == DateTimeFieldType.weekyear() ||\n                        savedFields[i].iField.getType() == DateTimeFieldType.weekOfWeekyear() ||\n                        savedFields[i].iField.getType() == DateTimeFieldType.weekyearOfCentury() ||\n                        savedFields[i].iField.getType() == DateTimeFieldType.weekOfWeekyear() ||\n                        savedFields[i].iField.getType() == DateTimeFieldType.quarterOfYear()) {\n                    DateTimeField field = savedFields[i].iField;\n                    if (field.getRangeDurationField().getType() == DurationFieldType.weeks() ||\n                            field.getDurationField().getType() == DurationFieldType.weeks()) {\n                        int yearWeeks = getWeeksInYear(year);\n                        int parsedWeeks = savedFields[i].iValue.intValue();\n                        if (yearWeeks <= 52 && parsedWeeks >= 52 && (parsedWeeks > 52 || getWeeksInYear(year + 1) > 52) ||\n                                yearWeeks <= 53 && parsedWeeks == 53 && getWeeksInYear(year + 1) > 52) {\n                            // Handle transition of day-of-week due to year boundary.\n                            if (savedFields[i + 1].iField.getType() != DateTimeFieldType.dayOfWeek()) {\n                                throw new IllegalFieldValueException(field.getType(), savedFields[i].iValue, null, null);\n                            }\n                            int hourOfDay = savedFields[i + 2].iField.set(savedFields[i + 1].iField.set(year, 1), 1);\n                            assert millis == savedFields[i + 2].iField.roundFloor(hourOfDay);\n                            break;\n                        }\n                    }\n                }\n                // simple test for most fields\n                for (int j = 0; j < i; j++) {\n                    if (savedFields[j].iField.getType() == savedFields[i].iField.getType() &&\n                            savedFields[j].iValue.intValue() != savedFields[i].iValue.intValue()) {\n                        throw new IllegalFieldValueException(savedFields[i].iField.getType(), savedFields[i].iValue, null, null);\n                    }\n                }\n                millis = year;  // safe after verification\n                continue;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..a7af374e 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,48 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+            long year = savedFields[i].iField.set(millis, savedFields[i].iValue);\n+            if (year != millis) {\n+                // if asking to parse \"Feb 29th\" and leap year not allowed, jump to March 1st\n+                if (savedFields[i].iField.getType() == DateTimeFieldType.monthOfYear() &&\n+                        DateTimeUtils.isLeapYear(year) == false &&\n+                        savedFields[i + 1].iField.getType() == DateTimeFieldType.dayOfMonth() &&\n+                        savedFields[i + 1].iValue.intValue() == 29) {\n+                    millis = savedFields[i].iField.set(year, savedFields[i].iValue + 1);\n+                    continue;\n+                }\n+                // if asking to parse \"W50\" or \"Q2\" with January as start of year, ensure leap\n+                if (savedFields[i].iField.getType() == DateTimeFieldType.weekyear() ||\n+                        savedFields[i].iField.getType() == DateTimeFieldType.weekOfWeekyear() ||\n+                        savedFields[i].iField.getType() == DateTimeFieldType.weekyearOfCentury() ||\n+                        savedFields[i].iField.getType() == DateTimeFieldType.weekOfWeekyear() ||\n+                        savedFields[i].iField.getType() == DateTimeFieldType.quarterOfYear()) {\n+                    DateTimeField field = savedFields[i].iField;\n+                    if (field.getRangeDurationField().getType() == DurationFieldType.weeks() ||\n+                            field.getDurationField().getType() == DurationFieldType.weeks()) {\n+                        int yearWeeks = getWeeksInYear(year);\n+                        int parsedWeeks = savedFields[i].iValue.intValue();\n+                        if (yearWeeks <= 52 && parsedWeeks >= 52 && (parsedWeeks > 52 || getWeeksInYear(year + 1) > 52) ||\n+                                yearWeeks <= 53 && parsedWeeks == 53 && getWeeksInYear(year + 1) > 52) {\n+                            // Handle transition of day-of-week due to year boundary.\n+                            if (savedFields[i + 1].iField.getType() != DateTimeFieldType.dayOfWeek()) {\n+                                throw new IllegalFieldValueException(field.getType(), savedFields[i].iValue, null, null);\n+                            }\n+                            int hourOfDay = savedFields[i + 2].iField.set(savedFields[i + 1].iField.set(year, 1), 1);\n+                            assert millis == savedFields[i + 2].iField.roundFloor(hourOfDay);\n+                            break;\n+                        }\n+                    }\n+                }\n+                // simple test for most fields\n+                for (int j = 0; j < i; j++) {\n+                    if (savedFields[j].iField.getType() == savedFields[i].iField.getType() &&\n+                            savedFields[j].iValue.intValue() != savedFields[i].iValue.intValue()) {\n+                        throw new IllegalFieldValueException(savedFields[i].iField.getType(), savedFields[i].iValue, null, null);\n+                    }\n+                }\n+                millis = year;  // safe after verification\n+                continue;\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: 'catch' without 'try'",
    "test_result": "ERROR"
}