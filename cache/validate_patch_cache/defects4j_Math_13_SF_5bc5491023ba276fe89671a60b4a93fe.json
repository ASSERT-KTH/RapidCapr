{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final int n = m.getRowDimension();\n    final int maxElements = Integer.MAX_VALUE / Double.BYTES;\n    if ((long)n * n > maxElements) {\n        return matrixIterativeSquareRoot(m);\n    }\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    return dec.getSquareRoot();\n}\n\nprivate RealMatrix matrixIterativeSquareRoot(final RealMatrix m) {\n    final int n = m.getRowDimension();\n    final double epsilon = 1e-8;\n    RealMatrix x = MatrixUtils.createRealIdentityMatrix(n);\n    RealMatrix dx;\n    do {\n        RealMatrix mx = m.multiply(x);\n        RealMatrix mxsqrt = sqrt(mx);\n        dx = x.multiply(2).multiply(mxsqrt.subtract(x)).multiply(mxsqrt);\n        x = x.add(dx);\n    } while (dx.getNorm() > epsilon * x.getNorm());\n    return x;\n}\n\nprivate RealMatrix sqrt (final RealMatrix m) {\n    final int n = m.getRowDimension();\n    final double[][] sqrt = new double[n][n];\n    for (int i = 0; i < n; i++) {\n        double x = m.getEntry(i, i);\n        sqrt[i][i] = Math.sqrt(x);\n        for (int j = i+1; j < n; j++) {\n            double y = m.getEntry(i, j) / (sqrt[i][i] + 1e-12);\n            sqrt[i][j] = y;\n            sqrt[j][i] = y;\n        }\n    }\n    return MatrixUtils.createRealMatrix(sqrt);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..2a0d3f871 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,42 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final int n = m.getRowDimension();\n+    final int maxElements = Integer.MAX_VALUE / Double.BYTES;\n+    if ((long)n * n > maxElements) {\n+        return matrixIterativeSquareRoot(m);\n     }\n+    final EigenDecomposition dec = new EigenDecomposition(m);\n+    return dec.getSquareRoot();\n+}\n+\n+private RealMatrix matrixIterativeSquareRoot(final RealMatrix m) {\n+    final int n = m.getRowDimension();\n+    final double epsilon = 1e-8;\n+    RealMatrix x = MatrixUtils.createRealIdentityMatrix(n);\n+    RealMatrix dx;\n+    do {\n+        RealMatrix mx = m.multiply(x);\n+        RealMatrix mxsqrt = sqrt(mx);\n+        dx = x.multiply(2).multiply(mxsqrt.subtract(x)).multiply(mxsqrt);\n+        x = x.add(dx);\n+    } while (dx.getNorm() > epsilon * x.getNorm());\n+    return x;\n+}\n+\n+private RealMatrix sqrt (final RealMatrix m) {\n+    final int n = m.getRowDimension();\n+    final double[][] sqrt = new double[n][n];\n+    for (int i = 0; i < n; i++) {\n+        double x = m.getEntry(i, i);\n+        sqrt[i][i] = Math.sqrt(x);\n+        for (int j = i+1; j < n; j++) {\n+            double y = m.getEntry(i, j) / (sqrt[i][i] + 1e-12);\n+            sqrt[i][j] = y;\n+            sqrt[j][i] = y;\n+        }\n+    }\n+    return MatrixUtils.createRealMatrix(sqrt);\n+}\n }",
    "result_reason": "error: method multiply in interface RealMatrix cannot be applied to given types;",
    "test_result": "ERROR"
}