{
    "patch": "import org.apache.commons.math3.util.MathUtils;\n\npublic class RegularizedGammaFunction {\n    private static double eps = Math.pow(10, -14);\n    private static double eps2 = Math.pow(10, -15);\n\n    /**\n     * Calculate the Gamma function of x.\n     *\n     * @param x number to calculate Gamma of\n     * @return Gamma function of x\n     */\n    public static double gamma(double x) {\n        return Math.exp(logGamma(x));\n    }\n\n    /**\n     * Calculate the ln of the Gamma function of x.\n     *\n     * @param x number to calculate ln of the Gamma of\n     * @return ln of the Gamma function of x\n     */\n    public static double logGamma(double x) {\n        if (x <= 0) {\n            throw new IllegalArgumentException(\"x should be greater than zero\");\n        }\n\n        double a = 0;\n        double b = 0;\n        double c = 0;\n        double d = 0;\n        double p = 0;\n        double q = 0;\n\n        double sqrtTwoPi = 2.5066282746310005d;\n\n        b = x;\n        c = b;\n        while (c < 1.0d) {\n            b++;\n            c = b + c;\n        }\n        double[] pCoeff = {0.0006791962044236d, 0.0005392845391922d, 0.01062446351982d,\n                0.04214067327128d, 0.07434243585629d, 0.0498673470d};\n        double[] qCoeff = {-0.0000000397646749610498646426d, 0.0000023784717394977308399656d, -0.0007430888334442310101998727d,\n                0.0659488073575003706237439599d, -0.0649669595683137805469370761d, 0.0079365079350035023696547333d};\n        double z = (c - 0.5d);\n        double pSum = pCoeff[5];\n        double qSum = qCoeff[5];\n        for (int i = 4; i >= 0; --i) {\n            pSum *= z;\n            pSum += pCoeff[i];\n            qSum *= z;\n            qSum += qCoeff[i];\n        }\n\n        double norm = Math.pow(c - 0.5d, c - 0.5d + 0.5d * MathUtils.TWO_PI) / Math.exp(c - 0.5d);\n        double logNorm = 0.5d * Math.log(MathUtils.TWO_PI) + (c - 0.5d) * Math.log(c - 0.5d);\n        double logGamma = logNorm + Math.log(norm * pSum / qSum) - Math.log(sqrtTwoPi * b);\n        return logGamma;\n    }\n\n    /**\n     * Calculate the regularized Gamma function (P(a, x)).\n     *\n     * @param a shape parameter of the gamma distribution (must be > 0)\n     * @param x integration end point (must be >= 0)\n     * @return P(a, x)\n     */\n    public static double regularizedGamma(double a, double x)\n    {\n        if (a <= 0 || x < 0) {\n            throw new IllegalArgumentException(\"Invalid arguments: <\" + a + \", \" + x + \">\");\n        }\n        double prev, P = 1 / a, sum = P, delta;\n\n        for (int n = 1; n < 200; n++) {\n            prev = P;\n            P *= x / (a + n);\n            sum += P;\n            delta = P / sum;\n            if (Math.abs(delta) < eps || Math.abs(delta) < sum * eps2) {\n                return sum * Math.exp(-x + a * Math.log(x) - logGamma(a));\n            }\n        }\n        throw new RuntimeException(\"Series did not converge after 200 iterations.\");\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..76834ef1d 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,94 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.util.MathUtils;\n+\n+public class RegularizedGammaFunction {\n+    private static double eps = Math.pow(10, -14);\n+    private static double eps2 = Math.pow(10, -15);\n+\n+    /**\n+     * Calculate the Gamma function of x.\n+     *\n+     * @param x number to calculate Gamma of\n+     * @return Gamma function of x\n+     */\n+    public static double gamma(double x) {\n+        return Math.exp(logGamma(x));\n+    }\n+\n+    /**\n+     * Calculate the ln of the Gamma function of x.\n+     *\n+     * @param x number to calculate ln of the Gamma of\n+     * @return ln of the Gamma function of x\n+     */\n+    public static double logGamma(double x) {\n+        if (x <= 0) {\n+            throw new IllegalArgumentException(\"x should be greater than zero\");\n+        }\n+\n+        double a = 0;\n+        double b = 0;\n+        double c = 0;\n+        double d = 0;\n+        double p = 0;\n+        double q = 0;\n+\n+        double sqrtTwoPi = 2.5066282746310005d;\n+\n+        b = x;\n+        c = b;\n+        while (c < 1.0d) {\n+            b++;\n+            c = b + c;\n+        }\n+        double[] pCoeff = {0.0006791962044236d, 0.0005392845391922d, 0.01062446351982d,\n+                0.04214067327128d, 0.07434243585629d, 0.0498673470d};\n+        double[] qCoeff = {-0.0000000397646749610498646426d, 0.0000023784717394977308399656d, -0.0007430888334442310101998727d,\n+                0.0659488073575003706237439599d, -0.0649669595683137805469370761d, 0.0079365079350035023696547333d};\n+        double z = (c - 0.5d);\n+        double pSum = pCoeff[5];\n+        double qSum = qCoeff[5];\n+        for (int i = 4; i >= 0; --i) {\n+            pSum *= z;\n+            pSum += pCoeff[i];\n+            qSum *= z;\n+            qSum += qCoeff[i];\n+        }\n+\n+        double norm = Math.pow(c - 0.5d, c - 0.5d + 0.5d * MathUtils.TWO_PI) / Math.exp(c - 0.5d);\n+        double logNorm = 0.5d * Math.log(MathUtils.TWO_PI) + (c - 0.5d) * Math.log(c - 0.5d);\n+        double logGamma = logNorm + Math.log(norm * pSum / qSum) - Math.log(sqrtTwoPi * b);\n+        return logGamma;\n+    }\n+\n+    /**\n+     * Calculate the regularized Gamma function (P(a, x)).\n+     *\n+     * @param a shape parameter of the gamma distribution (must be > 0)\n+     * @param x integration end point (must be >= 0)\n+     * @return P(a, x)\n+     */\n+    public static double regularizedGamma(double a, double x)\n+    {\n+        if (a <= 0 || x < 0) {\n+            throw new IllegalArgumentException(\"Invalid arguments: <\" + a + \", \" + x + \">\");\n+        }\n+        double prev, P = 1 / a, sum = P, delta;\n+\n+        for (int n = 1; n < 200; n++) {\n+            prev = P;\n+            P *= x / (a + n);\n+            sum += P;\n+            delta = P / sum;\n+            if (Math.abs(delta) < eps || Math.abs(delta) < sum * eps2) {\n+                return sum * Math.exp(-x + a * Math.log(x) - logGamma(a));\n+            }\n+        }\n+        throw new RuntimeException(\"Series did not converge after 200 iterations.\");\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}