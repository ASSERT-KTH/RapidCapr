{
    "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    Set<Field> candidateFields = new HashSet<>();\n    \n    // gather all fields first\n    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n        // apply filter on each field to check if a mock candidate is present\n        Object mockCandidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n        if (mockCandidate != null && field.getType().isAssignableFrom(mockCandidate.getClass())) {\n            candidateFields.add(field);\n        }\n    }\n\n    if (candidateFields.isEmpty()) {\n        return; // no field can have a mock injected\n    }\n\n    // choose the best matching field\n    Field bestMatchingField = Collections.min(candidateFields, new Comparator<Field>() {\n        @Override\n        public int compare(Field field1, Field field2) {\n            Class<?> fieldType1 = field1.getType();\n            Class<?> fieldType2 = field2.getType();\n\n            if (fieldType1.equals(fieldType2)) {\n                return 0;\n            }\n\n            if (fieldType1.isAssignableFrom(fieldType2)) {\n                return -1;\n            }\n\n            if (fieldType2.isAssignableFrom(fieldType1)) {\n                return 1;\n            }\n\n            return 0;\n        }\n    });\n\n    // inject the mock\n    Object mockCandidate = mockCandidateFilter.filterCandidate(mocks, bestMatchingField, fieldInstance);\n    bestMatchingField.setAccessible(true);\n    try {\n        bestMatchingField.set(fieldInstance, mockCandidate);\n    } catch (IllegalAccessException e) {\n        throw new RuntimeException(e);\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\nindex 213ebf351..a359b986f 100644\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n@@ -88,11 +88,55 @@ public class DefaultInjectionEngine {\n         }\n     }\n \n-    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n-        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n-        }\n-    }\n+\n+private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n+    Set<Field> candidateFields = new HashSet<>();\n+    \n+    // gather all fields first\n+    for (Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+        // apply filter on each field to check if a mock candidate is present\n+        Object mockCandidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n+        if (mockCandidate != null && field.getType().isAssignableFrom(mockCandidate.getClass())) {\n+            candidateFields.add(field);\n+        }\n+    }\n+\n+    if (candidateFields.isEmpty()) {\n+        return; // no field can have a mock injected\n+    }\n+\n+    // choose the best matching field\n+    Field bestMatchingField = Collections.min(candidateFields, new Comparator<Field>() {\n+        @Override\n+        public int compare(Field field1, Field field2) {\n+            Class<?> fieldType1 = field1.getType();\n+            Class<?> fieldType2 = field2.getType();\n+\n+            if (fieldType1.equals(fieldType2)) {\n+                return 0;\n+            }\n+\n+            if (fieldType1.isAssignableFrom(fieldType2)) {\n+                return -1;\n+            }\n+\n+            if (fieldType2.isAssignableFrom(fieldType1)) {\n+                return 1;\n+            }\n+\n+            return 0;\n+        }\n+    });\n+\n+    // inject the mock\n+    Object mockCandidate = mockCandidateFilter.filterCandidate(mocks, bestMatchingField, fieldInstance);\n+    bestMatchingField.setAccessible(true);\n+    try {\n+        bestMatchingField.set(fieldInstance, mockCandidate);\n+    } catch (IllegalAccessException e) {\n+        throw new RuntimeException(e);\n+    }\n+}\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}