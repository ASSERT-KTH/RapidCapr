{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    int n = m.getRowDimension();\n    double[][] rm = m.getData();\n    double[][] sm = new double[n][n];\n    double[][] tm = new double[n][n];\n\n    // Initialize the result matrix with the identity matrix\n    for (int i = 0; i < n; i++) {\n        sm[i][i] = 1.0;\n    }\n\n    // Iterate until convergence\n    double norm = Double.POSITIVE_INFINITY;\n    while (norm > 1e-10) {\n        // Compute the matrix T\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                double t = rm[i][j] / Math.sqrt(rm[i][i] * rm[j][j]);\n                tm[i][j] = (Double.isNaN(t)) ? 0.0 : t;\n            }\n        }\n\n        // Update the result matrix\n        double[][] smTemp = sm;\n        sm = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    sm[i][j] += tm[i][k] * smTemp[k][j];\n                }\n            }\n        }\n\n        // Compute the norm of the difference between m and sm^2\n        double[][] p = new double[n][n];\n        double[][] sm2 = new double[n][n];\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                for (int k = 0; k < n; k++) {\n                    sm2[i][j] += sm[i][k] * sm[k][j];\n                }\n                p[i][j] = rm[i][j] - sm2[i][j];\n            }\n        }\n        norm = norm(p);\n        rm = p;\n    }\n\n    return new Array2DRowRealMatrix(sm);\n}\n\nprivate static double norm(double[][] m) {\n    double norm = 0.0;\n    for (int i = 0; i < m.length; i++) {\n        for (int j = 0; j < m[0].length; j++) {\n            norm += m[i][j] * m[i][j];\n        }\n    }\n    return Math.sqrt(norm);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..9e9c2e59a 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,64 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    int n = m.getRowDimension();\n+    double[][] rm = m.getData();\n+    double[][] sm = new double[n][n];\n+    double[][] tm = new double[n][n];\n+\n+    // Initialize the result matrix with the identity matrix\n+    for (int i = 0; i < n; i++) {\n+        sm[i][i] = 1.0;\n     }\n+\n+    // Iterate until convergence\n+    double norm = Double.POSITIVE_INFINITY;\n+    while (norm > 1e-10) {\n+        // Compute the matrix T\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                double t = rm[i][j] / Math.sqrt(rm[i][i] * rm[j][j]);\n+                tm[i][j] = (Double.isNaN(t)) ? 0.0 : t;\n+            }\n+        }\n+\n+        // Update the result matrix\n+        double[][] smTemp = sm;\n+        sm = new double[n][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                for (int k = 0; k < n; k++) {\n+                    sm[i][j] += tm[i][k] * smTemp[k][j];\n+                }\n+            }\n+        }\n+\n+        // Compute the norm of the difference between m and sm^2\n+        double[][] p = new double[n][n];\n+        double[][] sm2 = new double[n][n];\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                for (int k = 0; k < n; k++) {\n+                    sm2[i][j] += sm[i][k] * sm[k][j];\n+                }\n+                p[i][j] = rm[i][j] - sm2[i][j];\n+            }\n+        }\n+        norm = norm(p);\n+        rm = p;\n+    }\n+\n+    return new Array2DRowRealMatrix(sm);\n+}\n+\n+private static double norm(double[][] m) {\n+    double norm = 0.0;\n+    for (int i = 0; i < m.length; i++) {\n+        for (int j = 0; j < m[0].length; j++) {\n+            norm += m[i][j] * m[i][j];\n+        }\n+    }\n+    return Math.sqrt(norm);\n+}\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}