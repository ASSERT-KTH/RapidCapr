{
    "patch": "      attachLiteralTypes(n);\n      int type = n.getType();\n      if (type == Token.FUNCTION || type == Token.METHOD || type == Token.GETTER_DEF || \n          type == Token.SETTER_DEF || type == Token.GENERATOR || type == Token.STRING_KEY) {\n        Node function = NodeUtil.getEnclosingFunction(n);\n        if (function == null && type == Token.STRING_KEY) {\n          function = NodeUtil.getEnclosingFunction(n.getParent());\n        }\n        if (function == null) {\n          if (type == Token.METHOD || type == Token.STRING_KEY) {\n            defineMethod(n);\n          }\n          break;\n        }\n        switch (function.getType()) {\n          case Token.SCRIPT:\n            // A top level function.\n            if (type == Token.FUNCTION && !NodeUtil.isFunctionExpression(n)) {\n              defineTopScopeVar(n);\n            }\n            break;\n          case Token.FUNCTION:\n            if (n.getParent().isDefaultValue() ||\n                // Named function expression without explicit assignment to a variable.\n                (NodeUtil.isFunctionExpression(n) &&\n                 !NodeUtil.isFunctionDeclaration(n) &&\n                 NodeUtil.getEnclosingAssignment(n) == null)) {\n              defineDeclaredFunction(n, parent);\n            } else if (!NodeUtil.isFunctionDeclaration(n)) {\n              defineScopeVar(n, parent);\n            }\n            break;\n          case Token.PARAM_LIST:  // function argument names\n            defineScopeVar(n, parent);\n            break;\n          case Token.BLOCK:  // function local variables\n          case Token.LP:     // function expressions\n            Node grandparent = function.getParent();\n            if (grandparent != null) {\n              if (grandparent.getType() == Token.CATCH) {\n                defineCatchVar(n, parent);\n              } else if (grandparent.getType() == Token.FOR ||\n                         grandparent.getType() == Token.FOR_OF) {\n                defineLoopVar(n, parent);\n              } else {\n                defineScopeVar(n, parent);\n              }\n            } else {\n              defineScopeVar(n, parent);\n            }\n            break;\n          case Token.CATCH:\n            defineCatchVar(n, parent);\n            break;\n          case Token.FOR:\n          case Token.FOR_IN:\n          case Token.FOR_OF:\n            defineLoopVar(n, parent);\n            break;\n          case Token.CLASS:\n            if (type != Token.METHOD && type != Token.STRING_KEY) {\n              defineClassMember(n, parent);\n            }\n            break;\n        }\n      } else if (type == Token.LP && parent == scope.getRootNode()) {\n        handleFunctionInputs(parent);\n      } else if (type == Token.VAR) {\n        defineVar(n, parent);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..f4903d39 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1449,20 +1449,74 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n \n       attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n+      int type = n.getType();\n+      if (type == Token.FUNCTION || type == Token.METHOD || type == Token.GETTER_DEF || \n+          type == Token.SETTER_DEF || type == Token.GENERATOR || type == Token.STRING_KEY) {\n+        Node function = NodeUtil.getEnclosingFunction(n);\n+        if (function == null && type == Token.STRING_KEY) {\n+          function = NodeUtil.getEnclosingFunction(n.getParent());\n+        }\n+        if (function == null) {\n+          if (type == Token.METHOD || type == Token.STRING_KEY) {\n+            defineMethod(n);\n           }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n           break;\n-      }\n+        }\n+        switch (function.getType()) {\n+          case Token.SCRIPT:\n+            // A top level function.\n+            if (type == Token.FUNCTION && !NodeUtil.isFunctionExpression(n)) {\n+              defineTopScopeVar(n);\n+            }\n+            break;\n+          case Token.FUNCTION:\n+            if (n.getParent().isDefaultValue() ||\n+                // Named function expression without explicit assignment to a variable.\n+                (NodeUtil.isFunctionExpression(n) &&\n+                 !NodeUtil.isFunctionDeclaration(n) &&\n+                 NodeUtil.getEnclosingAssignment(n) == null)) {\n+              defineDeclaredFunction(n, parent);\n+            } else if (!NodeUtil.isFunctionDeclaration(n)) {\n+              defineScopeVar(n, parent);\n+            }\n+            break;\n+          case Token.PARAM_LIST:  // function argument names\n+            defineScopeVar(n, parent);\n+            break;\n+          case Token.BLOCK:  // function local variables\n+          case Token.LP:     // function expressions\n+            Node grandparent = function.getParent();\n+            if (grandparent != null) {\n+              if (grandparent.getType() == Token.CATCH) {\n+                defineCatchVar(n, parent);\n+              } else if (grandparent.getType() == Token.FOR ||\n+                         grandparent.getType() == Token.FOR_OF) {\n+                defineLoopVar(n, parent);\n+              } else {\n+                defineScopeVar(n, parent);\n+              }\n+            } else {\n+              defineScopeVar(n, parent);\n+            }\n+            break;\n+          case Token.CATCH:\n+            defineCatchVar(n, parent);\n+            break;\n+          case Token.FOR:\n+          case Token.FOR_IN:\n+          case Token.FOR_OF:\n+            defineLoopVar(n, parent);\n+            break;\n+          case Token.CLASS:\n+            if (type != Token.METHOD && type != Token.STRING_KEY) {\n+              defineClassMember(n, parent);\n+            }\n+            break;\n+        }\n+      } else if (type == Token.LP && parent == scope.getRootNode()) {\n+        handleFunctionInputs(parent);\n+      } else if (type == Token.VAR) {\n+        defineVar(n, parent);\n     }\n \n     /** Handle bleeding functions and function parameters. */",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}