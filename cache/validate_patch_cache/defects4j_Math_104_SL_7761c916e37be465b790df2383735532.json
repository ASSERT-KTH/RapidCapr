{
    "patch": "import org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Precision;\nimport org.apache.commons.math3.util.MathUtils;\n\npublic class Gamma {\n\n    /** Maximum allowed numerical error. */\n    private static final double DEFAULT_EPSILON = 10e-15;\n    /** Lanczos coefficients */\n    private static final double[] LANCZOS = {\n        0.99999999999999709182,\n        57.156235665862923517,\n        -59.597960355475491248,\n        14.136097974741747174,\n        -0.49191381609762019978,\n        0.000033994649984811888699,\n        0.000046523628927048575523,\n        -0.000098374475304879564677,\n        0.00015808870322491248884,\n        -0.00021026444172410488319,\n        0.00021743961811521264320,\n        -0.00016431810653676389022,\n        0.000084418223983852743357,\n        -0.000026190838401581408045,\n        0.0000036899182659531622704\n    };\n\n    /** Avoid repeated computation of PI. */\n    private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(MathUtils.TWO_PI);\n\n    /** Constants for the computation of the incomplete Gamma functions\n     *  and the inverse of the regularized Gamma function.\n     *  For details see: Cephes Math Library, file gamma.c */\n    private static final double[] INV_GAMMA1 = {\n        0.0,\n        -0.5772156649015329,\n        0.42278433509846713,\n        -0.23069756185458267,\n        0.034885298639737445,\n        -0.0026265216155871203,\n        0.00010762161047755216,\n        -1.638380933434076E-6\n    };\n\n    /** Constants for the computation of the incomplete Gamma functions\n     *  and the inverse of the regularized Gamma function.\n     *  For details see: Cephes Math Library, file gamma.c */\n    private static final double[] INV_GAMMA2 = {\n        1.0,\n        0.15443132980334649,\n        -0.6727857673587579,\n        -0.18156840658076257,\n        0.019194026481287777,\n        -0.0011043734911148742,\n        0.000029194830987225026,\n        2.4817435006629755E-7,\n        -0.000000000043362231975,\n        0.0000000000005768764692,\n        4.4002635030425065E-12\n    };\n\n    /** Private constructor. */\n    private Gamma() {}\n\n    /** Compute the regularized gamma function Q(a, x) = Gamma(a, x) / Gamma(a).\n     *\n     * @param a Parameter a (must be positive)\n     * @param x Parameter x (must be non-negative)\n     * @param epsilon Maximum absolute error tolerated.\n     * @param maxIterations Maximum number of \"iterations\" to perform.\n     *  If the continued fraction or Lanczos approximation does not converge\n     *  within this number of iterations, an error is thrown.\n     * @return Q(a, x)\n     * @throws org.apache.commons.math3.exception.MaxIterationsExceededException\n     * if the continued fraction does not converge.\n     * @throws org.apache.commons.math3.exception.NumberIsTooSmallException\n     * if a <= 0 or x < 0.\n     * @throws org.apache.commons.math3.exception.TooLargeArgumentException\n     * if a is so large that the computed value would overflow.\n     */\n    public static double regularizedGammaP(double a,\n                                           double x,\n                                           double epsilon,\n                                           int maxIterations) {\n        if (a <= 0) {\n            throw new org.apache.commons.math3.exception.NumberIsTooSmallException(a, 0, true);\n        }\n        if (x < 0.0) {\n            throw new org.apache.commons.math3.exception.NumberIsTooSmallException(x, 0, false);\n        }\n        if (x == 0.0) {\n            return 0.0;\n        }\n        if (a > 1e10) {\n            return Gamma.regularizedGammaP(a - 1, x, epsilon, maxIterations);\n        }\n\n        final double ret;\n\n        // Lanczos computation\n        final double gln = lanczos(a);\n        if (x >= a + 1) {\n            ret = Gamma.regularizedGammaQ(a, x, gln, epsilon, maxIterations);\n        } else {\n            // continued fraction computation\n            final double frac = continuedFractionA(a, x, epsilon, maxIterations);\n            ret = FastMath.exp(-x + (a * FastMath.log(x)) - gln) * frac / a;\n        }\n\n        return ret;\n    }\n\n    /** Compute the regularized gamma function Q(a, x) = Gamma(a, x) / Gamma(a).\n     *\n     * For x >= a+1 this uses the series representation:\n     *\n     *   q(a,x) = Gamma(a,x)/Gamma(a) = 1 - p(a,x)\n     *   where\n     *   p(a,x) = sum_{n=0}^inf (a)_n x^n / (Gamma(a+n) n!)\n     *\n     * Otherwise it uses the continued fraction representation:\n     *\n     *   q(a,x) = Gamma(a,x)/Gamma(a) = (x/a)^a exp(-x) / (a W(x/a))\n     *   where\n     *   W(z) = exp(-z) sum_{n=0}^inf (n+z)^n / (n! (n+z)!)    (Lambert's W function).\n     *\n     * @param a Parameter a.\n     * @param x Parameter x.\n     * @param gln log(Gamma(a)).\n     * @param epsilon Maximum absolute error tolerated.\n     * @param maxIterations Maximum number of \"iterations\" to perform.\n     *  If the continued fraction does not converge within this\n     *  number of iterations, an error is thrown.\n     * @return Q(a, x)\n     * @throws org.apache.commons.math3.exception.MaxIterationsExceededException\n     * if the continued fraction does not converge.\n     */\n    public static double regularizedGammaQ(double a,\n                                           double x,\n                                           double gln,\n                                           double epsilon,\n                                           int maxIterations) {\n        if (a <= 0) {\n            throw new org.apache.commons.math3.exception.NumberIsTooSmallException(a, 0, true);\n        }\n        if (x < 0.0) {\n            throw new org.apache.commons.math3.exception.NumberIsTooSmallException(x, 0, false);\n        }\n        if (x == 0) {\n            return 1d;\n        }\n        if (a > 1e10) {\n            return 1d - Gamma.regularizedGammaP(a - 1, x, epsilon, maxIterations);\n        }\n\n        double a1 = 1.0 / a;\n        double u = (1.0 - a) * (FastMath.log(x) - FastMath.log(a)) + FastMath.log(a1);\n        double v = 1.0;\n        double q = a1;\n        double lngam = gln; // log Gamma(a + 1) = log a!\n        for (int i = 0; i < maxIterations; i++) {\n            double a2 = a1 + (double) i;\n            double b2 = x + (double) i - a;\n            double a3 = a2 * (i + 1) * a1;\n            double a4 = b2 * a2 * a1;\n            q = q * a3 / (a4 + q);\n            v = v + q;\n            double a5 = i + 1 - a;\n            if (Precision.equals(q, a1, epsilon)) {\n                return FastMath.exp(-x + (a * FastMath.log(x)) - lngam) * v;\n            }\n            a1 = q;\n        }\n\n        throw new org.apache.commons.math3.exception.MaxIterationsExceededException(maxIterations);\n    }\n\n    /** Compute the gamma function.\n     *\n     * @param x Argument.\n     * @return Gamma(x).\n     */\n    public static double gamma(double x) {\n        return Math.exp(logGamma(x));\n    }\n\n    /** Compute the natural logarithm of the gamma function.\n     *\n     * @param x Argument.\n     * @return log(Gamma(x)).\n     * approximately 5E-16\n     */\n    public static double logGamma(final double x) {\n        if (x <= 0.0) {\n            throw new IllegalArgumentException(\"Positive argument expected, but got \" + x);\n        }\n\n        final double ret;\n\n        if (Double.isInfinite(x)) {\n            ret = Double.POSITIVE_INFINITY;\n        } else if (Double.isNaN(x)) {\n            ret = Double.NaN;\n        } else if (x < 0.5) {\n            return logGamma1(x);\n        } else if (x <= 2.5) {\n            return logGamma2(x) - x + 0.5 * FastMath.log(x);\n        } else if (x <= 8.0) {\n            final int n = (int) FastMath.floor(x - 1.5);\n            double prod = 1.0;\n            for (int i = 1; i <= n; i++) {\n                prod *= x - i;\n            }\n            return logGamma2(x) - FastMath.log(prod);\n        } else {\n            final double sum = lanczos(x);\n            final double tmp = x + LANCZOS.length - 0.5;\n            ret = ((x - 0.5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum);\n        }\n\n        return ret;\n    }\n\n    /**\n     * Compute log[Gamma(x)] for x in the interval (0, 0.5).\n     *\n     * @param x Argument.\n     * @return log(Gamma(x)).\n     * @throws IllegalArgumentException if {@code x <= 0} or {@code x >= 0.5}.\n     */\n    private static double logGamma1(final double x) {\n        if (x >= 0.5) {\n            throw new IllegalArgumentException(\"Argument must be < 0.5 but got \" + x);\n        }\n\n        double y = -FastMath.log(x);\n        double gamma = logGamma2(x);\n        double delta = 1.0 / x;\n        double delta_n = delta;\n        double sum = 0.0;\n        for (int i = 0; i < 10; ++i) {\n            sum += delta_n * INV_GAMMA1[i];\n            delta_n *= delta;\n        }\n\n        return y * (x - 0.5) + gamma + sum;\n    }\n\n    /**\n     * Compute log[Gamma(x)] for x in the interval (1.0, 2.5).\n     *\n     * @param x Argument.\n     * @return log(Gamma(x)).\n     * @throws IllegalArgumentException if {@code x <= 1.0} or {@code x >= 2.5}.\n     */\n    private static double logGamma2(final double x) {\n        if (x >= 2.5) {\n            throw new IllegalArgumentException(\"Argument must be < 2.5 but got \" + x);\n        }\n\n        double y = x - 1.0;\n        double gamma = 0.5723649429247000870717135; // log gamma(2)\n        double delta = y - 0.5;\n        double sum = 0.0;\n        double delta_n = delta;\n        for (int i = 0; i < 7; ++i) {\n            sum += delta_n / INV_GAMMA2[i];\n            delta_n *= delta;\n        }\n\n        return gamma + sum / y;\n    }\n\n    /** Compute the natural logarithm of the gamma function scaled by {@code x}.\n     *\n     * @param x Argument.\n     * @return log(x * Gamma(x)).\n     * @since 2.2\n     */\n    public static double logGamma1p(final double x) {\n        if (x < -0.5) {\n            throw new IllegalArgumentException(\"Invalid input argument: \" + x);\n        }\n        return logGamma(x + 1.0);\n    }\n\n    /**\n     * Lanczos approximation.\n     * Code translated into Java from C implementation available at\n     * http://my.fit.edu/~gabdo/gammacoeff.txt\n     *\n     * @param x Argument.\n     * @return Lanczos approximation of \u0393(x).\n     */\n    private static double lanczos(final double x) {\n\n        if (x < 0.5) {\n            return MathUtils.PI / (FastMath.sin(MathUtils.PI * x) * lanczos(1.0 - x));\n        }\n\n        final double sum = 0.99999999999980993227684700473478;\n        for (int i = 0; i < LANCZOS.length; ++i) {\n            sum += LANCZOS[i] / (x + (double) i);\n        }\n\n        return FastMath.sqrt(MathUtils.TWO_PI) / x * FastMath.pow(x + MathUtils.EULER_CONSTANT - 0.5, x - 0.5) *\n               FastMath.exp(-x) * sum;\n    }\n\n    /**\n     * Continued fraction of the IncompleteBeta kind.\n     *\n     * @param a Parameter.\n     * @param b Parameter.\n     * @param x Argument.\n     * @param epsilon Maximum error allowed.\n     * @param maxIterations Maximum number of iterations allowed.\n     * @return the continued fraction approximating the IncompleteBeta function.\n     * @throws MaxIterationsExceededException if the algorithm fails to converge.\n     */\n    public static double continuedFractionB(final double a,\n                                             final double b,\n                                             final double x,\n                                             final double epsilon,\n                                             final int maxIterations) {\n        final double small = 1e-50;\n        final double big = 1e50;\n\n        double pkm2 = 1.;\n        double qkm2 = x;\n        double pkm1 = x + 1;\n        double qkm1 = a - b * x;\n        double r = pkm1 / qkm1;\n        double ans = small;\n        int n = 1;\n        do {\n            final double factor = n * (b - n) * x / ((a + 2 * n - 1) * (a + 2 * n));\n            final double d = 1.0 + factor * r;\n            ans = d == 0.0 ? big : 1.0 / d;\n            final double ca = pkm1 * ans + pkm2;\n            final double qa = qkm1 * ans + qkm2;\n            final double pk = ca / qa;\n            if (Double.isInfinite(pk)) {\n                pk = big;\n            }\n            final double delta = r * pk;\n            r = 1.0 / (1.0 + delta);\n            pkm2 = pkm1;\n            pkm1 = pk;\n            qkm2 = qkm1;\n            qkm1 = qa;\n            if (FastMath.abs(delta - 1.0) < epsilon) {\n                return ans;\n            }\n        } while (n < maxIterations);\n        throw new org.apache.commons.math3.exception.MaxIterationsExceededException(maxIterations);\n    }\n\n    /**\n     * Continued fraction of the IncompleteGamma kind.\n     *\n     * @param a Parameter.\n     * @param x Argument.\n     * @param epsilon Maximum error allowed.\n     * @param maxIterations Maximum number of iterations allowed.\n     * @return the continued fraction approximating the IncompleteGamma function.\n     * @throws MaxIterationsExceededException if the algorithm fails to converge.\n     */\n    public static double continuedFractionA(final double a,\n                                             final double x,\n                                             final double epsilon,\n                                             final int maxIterations) {\n        final double small = 1e-50;\n        final double big = 1e50;\n\n        double h2 = 1;\n        double d2 = x;\n        double c2 = d2;\n        double h1 = 1;\n        double d1 = 0;\n        int i = 1;\n        do {\n            final double a1 = i * (a - i);\n            final double h = 1 + d1 * h2 / a1;\n            final double d = 1 + d1 / a1 * c2;\n            final double c = 1 + d1 / a1 * d2;\n            h1 = h * h1;\n            d1 = d / h;\n            c2 = c / h;\n            final double delta = c2 * h1;\n            if (Double.isInfinite(delta)) {\n                final double result = delta < 0 ? -big : big;\n                return result;\n            }\n            if (Double.isNaN(delta) || FastMath.abs(delta - 1) < epsilon) {\n                return delta;\n            }\n            h2 = h;\n            d2 = d;\n            ++i;\n        } while (i <= maxIterations);\n        throw new org.apache.commons.math3.exception.MaxIterationsExceededException(maxIterations);\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}