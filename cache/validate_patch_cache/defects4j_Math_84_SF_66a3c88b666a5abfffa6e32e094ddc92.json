{
    "patch": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws TooManyEvaluationsException, OptimizationException {\n\n    final int n = simplex.length;\n    final int n1 = n - 1;\n\n    // iterate until convergence or maximal number of iterations\n    while (getIterations() < maximalIterationCount) {\n\n        // find the worst, nextWorst and best vertices\n        int iWorst = 0;\n        int iNextWorst = 0;\n        int iBest = 0;\n        for (int i = 0; i < n; ++i) {\n            if (simplex[i].getValue() < simplex[iBest].getValue()) {\n                iBest = i;\n            }\n            if (simplex[i].getValue() > simplex[iWorst].getValue()) {\n                iWorst = i;\n            }\n        }\n        for (int i = 0; i < n; ++i) {\n            if (i == iWorst) {\n                continue;\n            }\n            if (simplex[i].getValue() > simplex[iNextWorst].getValue()) {\n                iNextWorst = i;\n            }\n        }\n\n        // compute the centroid of all vertices except the worst\n        final double[] xBar = new double[n1];\n        Arrays.fill(xBar, 0.0);\n        for (int i = 0; i < n; ++i) {\n            if (i == iWorst) {\n                continue;\n            }\n            final double[] verticesI = simplex[i].getPoint();\n            for (int j = 0; j < n1; ++j) {\n                xBar[j] += verticesI[j];\n            }\n        }\n        final double cc = 1.0 / n1;\n        for (int j = 0; j < n1; ++j) {\n            xBar[j] *= cc;\n        }\n\n        // compute the reflection vertex\n        final double[] xR = new double[n1];\n        final double[] xWorst = simplex[iWorst].getPoint();\n        for (int j = 0; j < n1; ++j) {\n            xR[j] = xBar[j] + k * (xBar[j] - xWorst[j]);\n        }\n        final RealPointValuePair reflected = new RealPointValuePair(xR,\n                computeObjectiveValue(xR));\n\n        // compare the new vertex to the best vertex\n        if (comparator.compare(reflected, simplex[iBest]) < 0) {\n            // the new vertex is better than the best, try to extend it\n            final double[] xE = new double[n1];\n            for (int j = 0; j < n1; ++j) {\n                xE[j] = xBar[j] + r * (xR[j] - xBar[j]);\n            }\n            final RealPointValuePair extended = new RealPointValuePair(xE,\n                    computeObjectiveValue(xE));\n            if (comparator.compare(extended, reflected) < 0) {\n                // the new vertex was successfully extended\n                simplex[iWorst] = extended;\n                continue;\n            } else {\n                // the reflection was successful\n                simplex[iWorst] = reflected;\n                continue;\n            }\n        }\n\n        if (comparator.compare(reflected, simplex[iNextWorst]) < 0) {\n            // the new vertex is better than the next worst vertex, accept it\n            simplex[iWorst] = reflected;\n            continue;\n        }\n\n        // the new vertex is worse than the next worst vertex, try to contract the simplex\n        final double[] xC = new double[n1];\n        final double[] xWorstOld = simplex[iWorst].getPoint();\n        for (int j = 0; j < n1; ++j) {\n            xC[j] = xBar[j] + c * (xWorstOld[j] - xBar[j]);\n        }\n        final RealPointValuePair contracted = new RealPointValuePair(xC,\n                computeObjectiveValue(xC));\n        if (comparator.compare(contracted, simplex[iWorst]) < 0) {\n            // the contracted vertex is better than the old worst vertex\n            simplex[iWorst] = contracted;\n            continue;\n        }\n\n        // none of the above cases apply, contract the whole simplex towards the best vertex\n        for (int i = 0; i < n; ++i) {\n            if (i == iBest) {\n                continue;\n            }\n            final double[] verticesI = simplex[i].getPoint();\n            for (int j = 0; j < n1; ++j) {\n                verticesI[j] = simplex[iBest].getPoint()[j] + sh * (verticesI[j] - simplex[iBest].getPoint()[j]);\n            }\n            simplex[i] = new RealPointValuePair(verticesI,\n                    computeObjectiveValue(verticesI));\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..5be0e4957 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,45 +58,116 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-\n-        while (true) {\n-\n-            incrementIterationsCounter();\n+protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+        throws TooManyEvaluationsException, OptimizationException {\n+\n+    final int n = simplex.length;\n+    final int n1 = n - 1;\n+\n+    // iterate until convergence or maximal number of iterations\n+    while (getIterations() < maximalIterationCount) {\n+\n+        // find the worst, nextWorst and best vertices\n+        int iWorst = 0;\n+        int iNextWorst = 0;\n+        int iBest = 0;\n+        for (int i = 0; i < n; ++i) {\n+            if (simplex[i].getValue() < simplex[iBest].getValue()) {\n+                iBest = i;\n+            }\n+            if (simplex[i].getValue() > simplex[iWorst].getValue()) {\n+                iWorst = i;\n+            }\n+        }\n+        for (int i = 0; i < n; ++i) {\n+            if (i == iWorst) {\n+                continue;\n+            }\n+            if (simplex[i].getValue() > simplex[iNextWorst].getValue()) {\n+                iNextWorst = i;\n+            }\n+        }\n \n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n+        // compute the centroid of all vertices except the worst\n+        final double[] xBar = new double[n1];\n+        Arrays.fill(xBar, 0.0);\n+        for (int i = 0; i < n; ++i) {\n+            if (i == iWorst) {\n+                continue;\n+            }\n+            final double[] verticesI = simplex[i].getPoint();\n+            for (int j = 0; j < n1; ++j) {\n+                xBar[j] += verticesI[j];\n+            }\n+        }\n+        final double cc = 1.0 / n1;\n+        for (int j = 0; j < n1; ++j) {\n+            xBar[j] *= cc;\n+        }\n \n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n+        // compute the reflection vertex\n+        final double[] xR = new double[n1];\n+        final double[] xWorst = simplex[iWorst].getPoint();\n+        for (int j = 0; j < n1; ++j) {\n+            xR[j] = xBar[j] + k * (xBar[j] - xWorst[j]);\n+        }\n+        final RealPointValuePair reflected = new RealPointValuePair(xR,\n+                computeObjectiveValue(xR));\n+\n+        // compare the new vertex to the best vertex\n+        if (comparator.compare(reflected, simplex[iBest]) < 0) {\n+            // the new vertex is better than the best, try to extend it\n+            final double[] xE = new double[n1];\n+            for (int j = 0; j < n1; ++j) {\n+                xE[j] = xBar[j] + r * (xR[j] - xBar[j]);\n+            }\n+            final RealPointValuePair extended = new RealPointValuePair(xE,\n+                    computeObjectiveValue(xE));\n+            if (comparator.compare(extended, reflected) < 0) {\n+                // the new vertex was successfully extended\n+                simplex[iWorst] = extended;\n+                continue;\n+            } else {\n+                // the reflection was successful\n+                simplex[iWorst] = reflected;\n+                continue;\n+            }\n+        }\n \n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n+        if (comparator.compare(reflected, simplex[iNextWorst]) < 0) {\n+            // the new vertex is better than the next worst vertex, accept it\n+            simplex[iWorst] = reflected;\n+            continue;\n+        }\n \n-                return;\n+        // the new vertex is worse than the next worst vertex, try to contract the simplex\n+        final double[] xC = new double[n1];\n+        final double[] xWorstOld = simplex[iWorst].getPoint();\n+        for (int j = 0; j < n1; ++j) {\n+            xC[j] = xBar[j] + c * (xWorstOld[j] - xBar[j]);\n+        }\n+        final RealPointValuePair contracted = new RealPointValuePair(xC,\n+                computeObjectiveValue(xC));\n+        if (comparator.compare(contracted, simplex[iWorst]) < 0) {\n+            // the contracted vertex is better than the old worst vertex\n+            simplex[iWorst] = contracted;\n+            continue;\n+        }\n \n+        // none of the above cases apply, contract the whole simplex towards the best vertex\n+        for (int i = 0; i < n; ++i) {\n+            if (i == iBest) {\n+                continue;\n             }\n-\n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n+            final double[] verticesI = simplex[i].getPoint();\n+            for (int j = 0; j < n1; ++j) {\n+                verticesI[j] = simplex[iBest].getPoint()[j] + sh * (verticesI[j] - simplex[iBest].getPoint()[j]);\n             }\n-\n+            simplex[i] = new RealPointValuePair(verticesI,\n+                    computeObjectiveValue(verticesI));\n         }\n-\n     }\n+}\n \n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}