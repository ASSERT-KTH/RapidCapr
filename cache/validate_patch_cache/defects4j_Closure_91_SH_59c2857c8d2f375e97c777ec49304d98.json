{
    "patch": "      int pType = parent.getType();\n\n      if (pType == Token.IDENT) {\n        Node grandParent = parent.getParent();\n        if (grandParent.getType() == Token.CALL && grandParent.getFirstChild() == parent) {\n          // function call context, don't skip array index and object property functions\n          return true;\n        } else {\n          return false;\n        }\n      }\n\n      if (pType == Token.GETELEM && parent.getFirstChild() == n) {\n        // accessing an array element\n        return true;\n      }\n\n      if (pType == Token.OBJECTLIT) {\n        // object property function\n        return true;\n      }\n\n      if (pType == Token.STRING_KEY && parent.getFirstChild() == n) {\n        Node ancestor = parent.getParent();\n        if (ancestor.getType() == Token.OBJECTLIT) {\n          // object property function\n          return true;\n        }\n      }\n\n      if (pType == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        Node rhs = lhs.getNext();\n        if (n == lhs) {\n          if (lhs.getType() == Token.GETELEM) {\n            // array element assignment\n            return true;\n          } else if (NodeUtil.isObjectLiteralKey(lhs)) {\n            // object property assignment\n            return true;\n          } else if (NodeUtil.isNameDeclaration(parent.getParent())) {\n            // declaration\n            return true;\n          } else {\n            return false;\n          }\n        } else {\n          if (rhs != null) {\n            int rhsType = rhs.getType();\n            if (rhsType == Token.FUNCTION ||\n                rhsType == Token.REGEXP ||\n                rhsType == Token.OBJECTLIT ||\n                rhsType == Token.ARRAYLIT) {\n              // function, regex, object literal, and array literal assignments\n              return true;\n            } else if (NodeUtil.isCall(rhs) && rhs.getFirstChild() == n) {\n              // result discarded\n              return true;\n            } else {\n              return false;\n            }\n          } else {\n            return false;\n          }\n        }\n      }\n\n      return (pType == Token.SCRIPT || pType == Token.BLOCK || pType == Token.CATCH);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..3d2bf33e 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,75 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      int pType = parent.getType();\n+\n+      if (pType == Token.IDENT) {\n+        Node grandParent = parent.getParent();\n+        if (grandParent.getType() == Token.CALL && grandParent.getFirstChild() == parent) {\n+          // function call context, don't skip array index and object property functions\n+          return true;\n+        } else {\n+          return false;\n+        }\n+      }\n+\n+      if (pType == Token.GETELEM && parent.getFirstChild() == n) {\n+        // accessing an array element\n+        return true;\n+      }\n+\n+      if (pType == Token.OBJECTLIT) {\n+        // object property function\n+        return true;\n+      }\n+\n+      if (pType == Token.STRING_KEY && parent.getFirstChild() == n) {\n+        Node ancestor = parent.getParent();\n+        if (ancestor.getType() == Token.OBJECTLIT) {\n+          // object property function\n+          return true;\n+        }\n+      }\n+\n+      if (pType == Token.ASSIGN) {\n+        Node lhs = parent.getFirstChild();\n+        Node rhs = lhs.getNext();\n+        if (n == lhs) {\n+          if (lhs.getType() == Token.GETELEM) {\n+            // array element assignment\n+            return true;\n+          } else if (NodeUtil.isObjectLiteralKey(lhs)) {\n+            // object property assignment\n+            return true;\n+          } else if (NodeUtil.isNameDeclaration(parent.getParent())) {\n+            // declaration\n+            return true;\n+          } else {\n+            return false;\n+          }\n+        } else {\n+          if (rhs != null) {\n+            int rhsType = rhs.getType();\n+            if (rhsType == Token.FUNCTION ||\n+                rhsType == Token.REGEXP ||\n+                rhsType == Token.OBJECTLIT ||\n+                rhsType == Token.ARRAYLIT) {\n+              // function, regex, object literal, and array literal assignments\n+              return true;\n+            } else if (NodeUtil.isCall(rhs) && rhs.getFirstChild() == n) {\n+              // result discarded\n+              return true;\n+            } else {\n+              return false;\n+            }\n+          } else {\n+            return false;\n+          }\n+        }\n+      }\n+\n+      return (pType == Token.SCRIPT || pType == Token.BLOCK || pType == Token.CATCH);\n+    }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}