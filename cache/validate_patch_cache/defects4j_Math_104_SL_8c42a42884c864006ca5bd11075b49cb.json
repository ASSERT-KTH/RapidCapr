{
    "patch": "import org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.ArithmeticUtils;\nimport org.apache.commons.math3.exception.NotPositiveException;\nimport org.apache.commons.math3.exception.OutOfRangeException;\n\npublic class Gamma {\n\n    private static final double DEFAULT_EPSILON = 1e-14;\n\n    /**\n     * Default constructor.  Prohibits instantiation.\n     */\n    private Gamma() {}\n\n    /**\n     * <p>\n     * Returns the regularized gamma function P(a, x).\n     * </p>\n     * <p>\n     * The series is truncated when the absolute term-to-term\n     * ratio is less than {@value #DEFAULT_EPSILON}.\n     * </p>\n     * @param a the parameter of the gamma distribution\n     * @param x the integration end point\n     * @return the regularized gamma function P(a, x)\n     * @throws OutOfRangeException if {@code a < 0} or {@code x <= 0}\n     * @throws NotPositiveException if {@code a == 0}.\n     */\n    public static double regularizedGammaP(double a,\n                                           double x)\n        throws OutOfRangeException,\n        NotPositiveException  {\n        return regularizedGammaP(a, x, DEFAULT_EPSILON,\n                                 Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Returns the regularized gamma function P(a, x).</p>\n     * <p>The series is truncated at {@code maxIterations} terms.</p>\n     *\n     * @param a the parameter of the gamma distribution\n     * @param x the integration end point\n     * @param epsilon absolute accuracy of the result\n     * @param maxIterations maximum number of terms in the series\n     * @return the regularized gamma function P(a, x)\n     * @throws OutOfRangeException if {@code a < 0} or {@code x <= 0}\n     * @throws NotPositiveException if {@code a == 0}.\n     */\n    public static double regularizedGammaP(double a,\n                                           double x,\n                                           double epsilon,\n                                           int maxIterations)\n        throws OutOfRangeException,\n        NotPositiveException  {\n\n        if (a <= 0) {\n            throw new OutOfRangeException(a, 0, Double.POSITIVE_INFINITY);\n        }\n        if (x <= 0) {\n            throw new OutOfRangeException(x, 0, Double.POSITIVE_INFINITY);\n        }\n        if (FastMath.abs(FastMath.floor(a)) == a) {\n            return Gamma.regularizedGammaP((int) a, x, epsilon, maxIterations);\n        }\n        if (x < a + 1) {\n            return 1 - GammaSeries.regularizedGammaQ(a, x, epsilon, maxIterations);\n        }\n        return GammaContinuedFraction.\n            regularizedGammaP(a, x, epsilon, maxIterations);\n    }\n\n    /**\n     * Returns the value of 1 / \u0393(z) for z > 0.\n     * For {@code 0 < z <= 6} the implementation is based on the double precision\n     * implementation in the {@link Gamma} class. For {@code 6 < z <= 36} the\n     * implementation switches to the BigGamma class. For {@code z > 36} an\n     * overflow exception is thrown.\n     *\n     * @param z the parameter (z > 0).\n     * @return the value of 1 / \u0393(z).\n     * @throws OutOfRangeException if {@code z <= 0}.\n     */\n    public static double invGamma1pm1(double z)\n        throws OutOfRangeException {\n\n        if (z <= 0) {\n            throw new OutOfRangeException(z, 0, Double.POSITIVE_INFINITY);\n        }\n        if (z > 1e6) {\n            // Prevent overflow later on\n            z = 1e6;\n        }\n        if (z > 36) {\n            // Overflow\n            final double t = Gamma.lanczosGamma(z);\n            if (Double.isInfinite(t)) {\n                throw new ArithmeticException(\"Overflow\");\n            }\n            return 1 / (t * (z - 1));\n        }\n        return InvGamma1pm1.invGamma1pm1(z);\n    }\n\n    /**\n     * <p>Returns the regularized gamma function Q(a, x) = 1 - (P(a, x)).</p>\n     * <p>The series is truncated when the absolute term-to-term\n     * ratio is less than {@value #DEFAULT_EPSILON}.</p>\n     *\n     * @param a the parameter of the gamma distribution\n     * @param x the integration end point\n     * @return the regularized gamma function Q(a, x)\n     * @throws OutOfRangeException if {@code a < 0} or {@code x <= 0}\n     * @throws NotPositiveException if {@code a == 0}.\n     */\n    public static double regularizedGammaQ(final double a, final double x)\n        throws OutOfRangeException, NotPositiveException  {\n        if (a <= 0) {\n            throw new OutOfRangeException(a, 0, Double.POSITIVE_INFINITY);\n        }\n        if (x <= 0) {\n            throw new OutOfRangeException(x, 0, Double.POSITIVE_INFINITY);\n        }\n        if (FastMath.abs(FastMath.floor(a)) == a) {\n            return Gamma.regularizedGammaQ((int) a, x, DEFAULT_EPSILON,\n                                           Integer.MAX_VALUE);\n        }\n        if (x < a + 1.0) {\n            return GammaSeries.regularizedGammaP(a, x, DEFAULT_EPSILON,\n                                                 Integer.MAX_VALUE);\n        }\n        return GammaContinuedFraction.regularizedGammaQ(a, x, DEFAULT_EPSILON,\n                                                        Integer.MAX_VALUE);\n    }\n\n    /**\n     * <p>Returns the regularized gamma function Q(a, x) = 1 - (P(a, x)).</p>\n     * <p>The series is truncated at {@code maxIterations} terms.</p>\n     *\n     * @param a the parameter of the gamma distribution\n     * @param x the integration end point\n     * @param epsilon absolute accuracy of the result\n     * @param maxIterations maximum number of terms in the series\n     * @return the regularized gamma function Q(a, x)\n     * @throws OutOfRangeException if {@code a < 0} or {@code x <= 0}\n     * @throws NotPositiveException if {@code a == 0}.\n     */\n    public static double regularizedGammaQ(final double a, final double x,\n                                           final double epsilon,\n                                           final int maxIterations)\n        throws OutOfRangeException, NotPositiveException  {\n        if (a <= 0) {\n            throw new OutOfRangeException(a, 0, Double.POSITIVE_INFINITY);\n        }\n        if (x <= 0) {\n            throw new OutOfRangeException(x, 0, Double.POSITIVE_INFINITY);\n        }\n        if (FastMath.abs(FastMath.floor(a)) == a) {\n            return Gamma.regularizedGammaQ((int) a, x, epsilon, maxIterations);\n        }\n        if (x < a + 1.0) {\n            return GammaSeries.regularizedGammaP(a, x, epsilon, maxIterations);\n        }\n        return GammaContinuedFraction.regularizedGammaQ(a, x, epsilon,\n                                                        maxIterations);\n    }\n\n    /**\n     * Returns the value of \u0393(n) for integer n.\n     * @param n the parameter.\n     * @return \u0393(n)\n     * @throws NotPositiveException if {@code n <= 0}.\n     * @throws MathArithmeticException if the result is too large to be\n     * represented by a {@code double}.\n     */\n    public static double factorial(final int n)\n        throws NotPositiveException, MathArithmeticException {\n        if (n < 0) {\n            throw new NotPositiveException(n);\n        }\n        if (n > 170) {\n            throw new MathArithmeticException();\n        }\n        return FastMath.floor(FastMath.exp(Gamma.logGamma(n) + 0.5 * FastMath.log(MathUtils.TWO_PI) + n * FastMath.log(n / MathUtils.E)));\n    }\n\n    /**\n     * Returns the natural logarithm of the gamma function \u0393(n).\n     * <p>\n     * For {@code n <= 15}, the implementation computes the log-gamma using the\n     * {@link #logGamma(double) logGamma} method and then returns {@code\n     * exp(logGamma(n))}. For {@code n > 15}, the implementation uses the\n     * Lanczos approximation (see \"Numerical Recipes in C\", 2nd edition,\n     * page 214, Cambridge University Press).\n     *\n     * @param n the parameter.\n     * @return log(\u0393(n))\n     * @throws NotPositiveException if {@code n <= 0}.\n     */\n    public static double logGamma(final double n) throws NotPositiveException {\n        if (n <= 0) {\n            throw new NotPositiveException(n);\n        }\n\n        if (n < 0.5) {\n            return logGamma1p(n) - FastMath.log(n);\n        }\n\n        if (n <= 2.5) {\n            return logGamma1p((n - 0.5) - 0.5);\n        }\n\n        if (n <= 8.0) {\n            final int nInt = (int) FastMath.floor(n);\n            double prod = 1;\n            for (int i = 1; i <= nInt; i++) {\n                prod *= n - i;\n            }\n            return logGamma1p(nInt) + FastMath.log(prod);\n        }\n\n        final double sum = lanczos(n);\n        final double tmp = n + LANCZOS_G + .5;\n        return ((n + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / n);\n    }\n\n    /** Lanczos coefficients */\n    private static final double[] LANCZOS =\n        {\n            0.99999999999980993,\n            676.5203681218851,\n            -1259.1392167224028,\n            771.32342877765313,\n            -176.61502916214059,\n            12.507343278686905,\n            -0.13857109526572012,\n            9.9843695780195716e-6,\n            1.5056327351493116e-7\n        };\n    /** The constant value of {@code sqrt(2 * PI)}. */\n    private static final double SQRT_TWO_PI = FastMath.sqrt(2 * MathUtils.PI);\n    /** The constant value of {@code log(sqrt(2 * PI))}. */\n    private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(2 * MathUtils.PI);\n    /** Lanczos G constant. */\n    private static final double LANCZOS_G = 607/128.0;\n    /** Lanczos G minus 0.5 constant. */\n    private static final double LANCZOS_G_MINUS_HALF = LANCZOS_G - 0.5;\n\n    /**\n     * Computes the <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">\n     * Lanczos approximation</a> of the gamma function.\n     *\n     * @param x the argument.\n     * @return \u0393(x) by Lanczos approximation.\n     */\n    public static double lanczos(final double x) {\n        double sum = LANCZOS[0];\n        for (int i = 1; i < LANCZOS.length; i++) {\n            sum += LANCZOS[i] / (x + i);\n        }\n        final double tmp = x + LANCZOS_G_MINUS_HALF + .5;\n        return SQRT_TWO_PI / x * FastMath.pow(tmp, x + .5) * FastMath.exp(-tmp) * sum;\n    }\n\n    /**\n     * The natural logarithm of the gamma function for 1/2 \u2264 <i>z</i> \u2264 1 by the\n     * formula <pre>logGamma(z) = log(2 sqrt(2\u03c0)) + (z - 0.5)log(1-z) +\n     *   log(A),</pre> where A is the\n     * <a href=\"http://mathworld.wolfram.com/Gauss-KummerSeries.html\">Gauss-Kummer</a>\n     * series.\n     *\n     * @param z the argument (order of the gamma function).\n     * @return the value of {@code log(Gamma(z))}.\n     */\n    private static double logGamma1p(final double z) {\n\n        if (z < 0.5) {\n            return FastMath.log(Math.PI / (FastMath.sin(Math.PI * z) * Gamma.gamma1p(-z)));\n        }\n\n        if (z <= 2.5) {\n            return FastMath.log(Gamma.gamma1p(z - 1));\n        }\n\n        final double x = (z - 0.5) - 1;\n        final double[] y = new double[LanczosApproximation.LANCZOS_SIZE];\n        LanczosApproximation.evaluate(y, x);\n        double sum = y[LanczosApproximation.LANCZOS_SIZE - 1];\n        for (int i = LanczosApproximation.LANCZOS_SIZE - 2; i >= 0; i--) {\n            sum = sum * x + y[i];\n        }\n        return (x + 0.5) * FastMath.log((z - 1.0) / MathUtils.E) + FastMath.log(sum / z);\n    }\n\n    /**\n     * Returns the value of \u0393(z) for positive z.\n     *\n     * @param z the parameter.\n     * @return \u0393(z)\n     */\n    public static double gamma(final double z) {\n\n        if (Double.isNaN(z) || (z <= 0.0)) {\n            return Double.NaN;\n        }\n\n        if (z < 0.5) {\n            return Math.PI / (FastMath.sin(Math.PI * z) * gamma(1.0 - z));\n        }\n\n        if (z > 100.0) {\n            // Avoid overflow in Math.pow\n            final double g = lanczos(z);\n            if (g == Double.POSITIVE_INFINITY) {\n                throw new ArithmeticException(\"Overflow\");\n            }\n            return g;\n        }\n\n        return FastMath.exp(logGamma(z));\n    }\n\n    /**\n     * Returns the value of \u0393(z + 1).\n     *\n     * @param z the parameter.\n     * @return \u0393(z + 1)\n     */\n    public static double gamma1p(final double z) {\n\n        if (Double.isNaN(z) || (z <= -1.0)) {\n            return Double.NaN;\n        }\n\n        if (z < 1.0e-6) {\n            return 1.0 / (z * (1.0 + GAMMA * z));\n        }\n\n        if ((z == 1.0) || (z == 2.0)) {\n            return 1.0;\n        }\n\n        if (z == 0.5) {\n            return SQRT_PI;\n        }\n\n        if (z > 2.0) {\n\n            /*\n             * Apply Spencer's (1964) formula:\n             * \u0393(1 + z) = (z/e)^z sqrt(2\u03c0(1 + 1/z)) *\n             * [1 + 1/12z + 1/288z^2 - 139/51840z^3 - 571/2488320z^4 +\n             * O(z^-5)].\n             */\n\n            final double c = SpencerGamma.C[0] / (1.0 + z);\n            double s = c;\n            for (int i = 1; i < SpencerGamma.C.length; i++) {\n                c *= (SpencerGamma.C[i] / (i + z));\n                s += c;\n            }\n            final double tmp = z + SpencerGamma.G + .5;\n            return SQRT_TWO_PI * FastMath.pow(tmp, z + 0.5) * FastMath.exp(-tmp) * s / z;\n        }\n\n        /*\n         * Apply the reflection formula (due to Gauss)\n         * Here, 1- because we're actually calculating gamma(1-z)\n         * so we'll subtract 1 from the series term exponent below\n         */\n        return (1.0 / (z * lanczos(1.0 - z))) * MathUtils.PI / FastMath.sin(MathUtils.PI * z);\n    }\n\n}    ",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}