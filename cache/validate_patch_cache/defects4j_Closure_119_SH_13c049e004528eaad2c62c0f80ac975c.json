{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.JSModule;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.Scope;\nimport com.google.javascript.jscomp.CodeGenerator;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.parsing.parser.trees.BinaryTree;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.StaticScope;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.NamedType;\nimport com.google.javascript.rhino.jstype.ObjectType;\nimport com.google.javascript.rhino.jstype.Property;\nimport com.google.javascript.rhino.jstype.TemplateType;\nimport com.google.javascript.rhino.jstype.TemplateTypeRegistry;\nimport com.google.javascript.rhino.jstype.TypedefType;\nimport com.google.javascript.rhino.jstype.UnionType;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport java.util.HashMap;\nimport java.util.List;\nimport java.util.Map;\n\npublic class CollectPropertyDefs extends AbstractCompiler {\n  private static final String PROPERTY_DEFS = \"propertyDefs\";\n\n  private Map<String, PropertyDef> propertyDefsById;\n  private StaticScope<JSType> currentScope;\n  private Scope currentScopeWrapper;\n  private JSTypeRegistry registry;\n  private JSType stringType;\n  private TemplateTypeRegistry templateRegistry;\n\n  /**\n   * The results of this pass: a map from NAME node value ids to a list of types\n   * that property accessors with that name have been called with.\n   */\n  public static Map<String, PropertyDef> getPropertyDefs(AbstractCompiler compiler, Node externs, Node root) {\n    CollectPropertyDefs pass = new CollectPropertyDefs(compiler);\n    pass.process(externs, root);\n    return pass.propertyDefsById;\n  }\n\n  private CollectPropertyDefs(AbstractCompiler compiler) {\n    this.registry = compiler.getTypeRegistry();\n    this.templateRegistry = registry.getTemplateTypeRegistry();\n    this.stringType = registry.getNativeType(JSTypeNative.STRING_TYPE);\n  }\n\n  @Override\n  public void beforePass(NodeTraversal t) {\n    propertyDefsById = new HashMap<>();\n    CollectPropertyDefsCallback cb = new CollectPropertyDefsCallback();\n    NodeTraversal.traverse(this, t.getScopeRoot(), cb);\n  }\n\n  /**\n   * A traversal callback that finds \"proto.foo.call(obj)\" and \"this.foo=\"\n   * expressions and records their types in a map.\n   */\n  private class CollectPropertyDefsCallback extends NodeTraversal.AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.getType() != Token.CALL && n.getType() != Token.ASSIGN) {\n        return;\n      }\n\n      Node callee = n.getFirstChild();\n      if (callee == null || !callee.isGetProp()) {\n        return;\n      }\n\n      Node objNode = callee.getFirstChild();\n      if (!\"call\".equals(callee.getLastChild().getString()) ||\n          objNode == null || !\"prototype\".equals(objNode.getLastChild().getString())) {\n        return;\n      }\n\n      Node propNameNode = callee.getLastChild().getPrevious();\n      String propName = propNameNode == null ? \"undefined\" : propNameNode.getString();\n\n      Node calleeChild = n.getFirstChild();\n      if (n.getType() == Token.CALL && calleeChild != null && calleeChild.isFunction()) {\n        // Collect usage of properties as instance initializers\n        Node fn = calleeChild;\n        Node obj = fn.getFirstChild();\n        // Ignore anonymous constructor functions.\n        if (obj.getLastChild() == null) {\n          return;\n        }\n        propName = obj.getLastChild().getString();\n      }\n\n      if (n.getType() == Token.ASSIGN && !callee.getNext().isNull()) {\n        // Collect usage of properties like X.y = f;\n        propNameNode = callee.getNext();\n        propName = propNameNode == null ? \"undefined\" : propNameNode.getString();\n      }\n\n      String propId = NodeUtil.getRootOfQualifiedName(callee).getQualifiedName();\n\n      // Strip outer quotes, if they exist\n      if (propName.startsWith(\"\\\"\") && propName.endsWith(\"\\\"\") &&\n          propName.length() > 1) {\n        propName = propName.substring(1, propName.length() - 1);\n      }\n      Map<String, PropertyDef> propertyDefsById = CollectPropertyDefs.this.propertyDefsById;\n      PropertyDef propertyDef = propertyDefsById.get(propId);\n      if (propertyDef == null) {\n        propertyDef = new PropertyDef();\n        propertyDefsById.put(propId, propertyDef);\n      }\n      propertyDef.addDef(CollectPropertyDefs.this.registry.getType(propName, currentScope));\n    }\n\n    // ...\n  }\n\n  private class PropertyDef {\n    private UnionType unionType;\n\n    public void addDef(JSType type) {\n      if (unionType == null) {\n        unionType = createUnion(type);\n      } else {\n        unionType = unionType.getLeastSupertype(createUnion(type));\n      }\n    }\n\n    public ObjectType getObjectType() {\n      if (unionType == null ||\n          (unionType.getAlternates().size() != 1)) {\n        return null;\n      }\n\n      if (!(unionType.getAlternates().get(0) instanceof ObjectType)) {\n        return null;\n      }\n\n      return (ObjectType) unionType.getAlternates().get(0);\n    }\n\n    public static final int MAX_DEPTH = 10;\n\n    public String getTemplateTypeName() {\n      for (JSType alt : unionType.getAlternates()) {\n        if (!(alt instanceof NamedType)) {\n          return null;\n        }\n\n        NamedType namedType = (NamedType) alt;\n        ObjectType objType = namedType.getReference().getObjectType();\n\n        if (objType != null && objType.isTemplatizedType()) {\n          TemplateType templateType = objType.getTemplateType();\n          if (templateType == null) {\n            continue;\n          }\n          TypedefType typedefType = objType.findTypedef(templateType.getReferenceName());\n          if (typedefType == null) {\n            continue;\n          }\n          if (typedefType.getDepth() > MAX_DEPTH) {\n            continue;\n          }\n          for (ObjectType proto : typedefType.getAppliedTo()) {\n            if (proto.getKeyType() == stringType) {\n              return proto.getReferenceName();\n            }\n          }\n        }\n      }\n      return null;\n    }\n\n    public ObjectType getNamespaceObjectType() {\n      if (unionType == null) {\n        return null;\n      }\n\n      ObjectType result = null;\n      boolean unsure = false;\n      for (JSType alt : unionType.getAlternates()) {\n        if (!(alt instanceof ObjectType)) {\n          continue;\n        }\n        ObjectType objType = (ObjectType) alt;\n        if (result == null) {\n          result = objType;\n        } else if (!result.equals(objType)) {\n          unsure = true;\n        }\n      }\n      return unsure ? null : result;\n    }\n\n    private UnionType createUnion(JSType type) {\n      return new UnionType(ImmutableList.of(type), registry);\n    }\n  }\n\n  private class CollectPropertyDefsScopeCallback implements ScopeCreator {\n    @Override\n    public Scope createScope(Node n, StaticScope<JSType> s) {\n      currentScope = s;\n      currentScopeWrapper = Scope.wrap(currentScope);\n      return currentScopeWrapper;\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 639318df..8efcfa2e 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -363,6 +363,218 @@ class GlobalNamespace\n                 isSet = true;\n                 type = Name.Type.FUNCTION;\n                 break;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.JSModule;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.Scope;\n+import com.google.javascript.jscomp.CodeGenerator;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.jscomp.parsing.parser.trees.BinaryTree;\n+import com.google.javascript.rhino.InputId;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.StaticScope;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.NamedType;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.Property;\n+import com.google.javascript.rhino.jstype.TemplateType;\n+import com.google.javascript.rhino.jstype.TemplateTypeRegistry;\n+import com.google.javascript.rhino.jstype.TypedefType;\n+import com.google.javascript.rhino.jstype.UnionType;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import java.util.HashMap;\n+import java.util.List;\n+import java.util.Map;\n+\n+public class CollectPropertyDefs extends AbstractCompiler {\n+  private static final String PROPERTY_DEFS = \"propertyDefs\";\n+\n+  private Map<String, PropertyDef> propertyDefsById;\n+  private StaticScope<JSType> currentScope;\n+  private Scope currentScopeWrapper;\n+  private JSTypeRegistry registry;\n+  private JSType stringType;\n+  private TemplateTypeRegistry templateRegistry;\n+\n+  /**\n+   * The results of this pass: a map from NAME node value ids to a list of types\n+   * that property accessors with that name have been called with.\n+   */\n+  public static Map<String, PropertyDef> getPropertyDefs(AbstractCompiler compiler, Node externs, Node root) {\n+    CollectPropertyDefs pass = new CollectPropertyDefs(compiler);\n+    pass.process(externs, root);\n+    return pass.propertyDefsById;\n+  }\n+\n+  private CollectPropertyDefs(AbstractCompiler compiler) {\n+    this.registry = compiler.getTypeRegistry();\n+    this.templateRegistry = registry.getTemplateTypeRegistry();\n+    this.stringType = registry.getNativeType(JSTypeNative.STRING_TYPE);\n+  }\n+\n+  @Override\n+  public void beforePass(NodeTraversal t) {\n+    propertyDefsById = new HashMap<>();\n+    CollectPropertyDefsCallback cb = new CollectPropertyDefsCallback();\n+    NodeTraversal.traverse(this, t.getScopeRoot(), cb);\n+  }\n+\n+  /**\n+   * A traversal callback that finds \"proto.foo.call(obj)\" and \"this.foo=\"\n+   * expressions and records their types in a map.\n+   */\n+  private class CollectPropertyDefsCallback extends NodeTraversal.AbstractPostOrderCallback {\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.getType() != Token.CALL && n.getType() != Token.ASSIGN) {\n+        return;\n+      }\n+\n+      Node callee = n.getFirstChild();\n+      if (callee == null || !callee.isGetProp()) {\n+        return;\n+      }\n+\n+      Node objNode = callee.getFirstChild();\n+      if (!\"call\".equals(callee.getLastChild().getString()) ||\n+          objNode == null || !\"prototype\".equals(objNode.getLastChild().getString())) {\n+        return;\n+      }\n+\n+      Node propNameNode = callee.getLastChild().getPrevious();\n+      String propName = propNameNode == null ? \"undefined\" : propNameNode.getString();\n+\n+      Node calleeChild = n.getFirstChild();\n+      if (n.getType() == Token.CALL && calleeChild != null && calleeChild.isFunction()) {\n+        // Collect usage of properties as instance initializers\n+        Node fn = calleeChild;\n+        Node obj = fn.getFirstChild();\n+        // Ignore anonymous constructor functions.\n+        if (obj.getLastChild() == null) {\n+          return;\n+        }\n+        propName = obj.getLastChild().getString();\n+      }\n+\n+      if (n.getType() == Token.ASSIGN && !callee.getNext().isNull()) {\n+        // Collect usage of properties like X.y = f;\n+        propNameNode = callee.getNext();\n+        propName = propNameNode == null ? \"undefined\" : propNameNode.getString();\n+      }\n+\n+      String propId = NodeUtil.getRootOfQualifiedName(callee).getQualifiedName();\n+\n+      // Strip outer quotes, if they exist\n+      if (propName.startsWith(\"\\\"\") && propName.endsWith(\"\\\"\") &&\n+          propName.length() > 1) {\n+        propName = propName.substring(1, propName.length() - 1);\n+      }\n+      Map<String, PropertyDef> propertyDefsById = CollectPropertyDefs.this.propertyDefsById;\n+      PropertyDef propertyDef = propertyDefsById.get(propId);\n+      if (propertyDef == null) {\n+        propertyDef = new PropertyDef();\n+        propertyDefsById.put(propId, propertyDef);\n+      }\n+      propertyDef.addDef(CollectPropertyDefs.this.registry.getType(propName, currentScope));\n+    }\n+\n+    // ...\n+  }\n+\n+  private class PropertyDef {\n+    private UnionType unionType;\n+\n+    public void addDef(JSType type) {\n+      if (unionType == null) {\n+        unionType = createUnion(type);\n+      } else {\n+        unionType = unionType.getLeastSupertype(createUnion(type));\n+      }\n+    }\n+\n+    public ObjectType getObjectType() {\n+      if (unionType == null ||\n+          (unionType.getAlternates().size() != 1)) {\n+        return null;\n+      }\n+\n+      if (!(unionType.getAlternates().get(0) instanceof ObjectType)) {\n+        return null;\n+      }\n+\n+      return (ObjectType) unionType.getAlternates().get(0);\n+    }\n+\n+    public static final int MAX_DEPTH = 10;\n+\n+    public String getTemplateTypeName() {\n+      for (JSType alt : unionType.getAlternates()) {\n+        if (!(alt instanceof NamedType)) {\n+          return null;\n+        }\n+\n+        NamedType namedType = (NamedType) alt;\n+        ObjectType objType = namedType.getReference().getObjectType();\n+\n+        if (objType != null && objType.isTemplatizedType()) {\n+          TemplateType templateType = objType.getTemplateType();\n+          if (templateType == null) {\n+            continue;\n+          }\n+          TypedefType typedefType = objType.findTypedef(templateType.getReferenceName());\n+          if (typedefType == null) {\n+            continue;\n+          }\n+          if (typedefType.getDepth() > MAX_DEPTH) {\n+            continue;\n+          }\n+          for (ObjectType proto : typedefType.getAppliedTo()) {\n+            if (proto.getKeyType() == stringType) {\n+              return proto.getReferenceName();\n+            }\n+          }\n+        }\n+      }\n+      return null;\n+    }\n+\n+    public ObjectType getNamespaceObjectType() {\n+      if (unionType == null) {\n+        return null;\n+      }\n+\n+      ObjectType result = null;\n+      boolean unsure = false;\n+      for (JSType alt : unionType.getAlternates()) {\n+        if (!(alt instanceof ObjectType)) {\n+          continue;\n+        }\n+        ObjectType objType = (ObjectType) alt;\n+        if (result == null) {\n+          result = objType;\n+        } else if (!result.equals(objType)) {\n+          unsure = true;\n+        }\n+      }\n+      return unsure ? null : result;\n+    }\n+\n+    private UnionType createUnion(JSType type) {\n+      return new UnionType(ImmutableList.of(type), registry);\n+    }\n+  }\n+\n+  private class CollectPropertyDefsScopeCallback implements ScopeCreator {\n+    @Override\n+    public Scope createScope(Node n, StaticScope<JSType> s) {\n+      currentScope = s;\n+      currentScopeWrapper = Scope.wrap(currentScope);\n+      return currentScopeWrapper;\n+    }\n+  }\n+}\n               case Token.INC:\n               case Token.DEC:\n                 isSet = true;",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}