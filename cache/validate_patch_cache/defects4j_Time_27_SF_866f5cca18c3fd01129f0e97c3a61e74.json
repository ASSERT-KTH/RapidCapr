{
    "patch": "public static Period parsePeriod(String periodStr) {\n    if (periodStr == null) {\n        throw new IllegalArgumentException(\"Invalid period format: empty string\");\n    }\n    periodStr = periodStr.toUpperCase(Locale.ENGLISH);\n    if (periodStr.startsWith(\"P\")) {\n        return parseDuration(periodStr.substring(1), 0);\n    }\n    if (periodStr.startsWith(\"-P\")) {\n        return parseDuration(periodStr.substring(2), 1);\n    }\n    throw new IllegalArgumentException(\"Invalid period format: \" + periodStr);\n}\n\nprivate static Period parseDuration(String durationStr, int negate) {\n    if (durationStr == null || durationStr.length() == 0) {\n        return Period.ZERO;\n    }\n    int size = durationStr.length();\n    char[] chars = new char[size];\n    durationStr.getChars(0, size, chars, 0);\n    boolean negative = false;\n    int[] values = new int[8]; // <-- Array size set to 8 here\n    int typesIndex = 0;\n    int type = 0;\n    int i = (chars[0] == '-' || chars[0] == '+') ? 1 : 0;\n    for (; i < size; i++) {\n        char c = chars[i];\n        if (c == '.') {\n            if (type >= (negate == 0 ? SECONDS_INDEX : 6)) {\n                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n            }\n            int[] parsed = parseFraction(durationStr, i);\n            i = parsed[0];\n            // Result is added even if its a zero, as a zero value is still a value\n            values[type++] = negate(parsed[1], negate);\n            continue;\n        }\n        if (c < '0' || c > '9') {\n            // stop parse number, and determine value\n            if (type == 7 && (c == 'Z' || c == '+' || c == '-')) {\n                i = parseTotalMillis(durationStr, i, negative, values);\n                break;\n            }\n            int end;\n            if (c == ',') {\n                end = findEnd(durationStr, i);\n                i++;\n            } else {\n                end = i + 1;\n            }\n            String str = durationStr.substring(i, end);\n            if (str.equals(\"H\")) {\n                verifyValues(++typesIndex, type);\n                values[type++] = negate(Integer.parseInt(checkSingular(str)), negate);\n            } else\n                if (str.equals(\"M\")) {\n                if (type >= SECONDS_INDEX) {\n                    throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n                }\n                verifyValues(++typesIndex, type);\n                values[type++] = negate(Integer.parseInt(checkSingular(str)), negate);\n            } else {\n                if (str.equals(\"S\")) {\n                    if (type >= SECONDS_INDEX) {\n                        throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n                    }\n                    verifyValues(++typesIndex, type);\n                    values[type++] = negate(Integer.parseInt(checkSingular(str)), negate);\n                } else {\n                    if (str.equals(\"D\")) {\n                        verifyValues(1, type);\n                        values[0] = negate(Integer.parseInt(checkSingular(str)), negate);\n                    } else {\n                        if (str.equals(\"W\")) {\n                            verifyValues(2, type);\n                            values[1] = negate(Integer.parseInt(checkSingular(str)), negate);\n                        } else {\n                            if (str.charAt(0) == 'P') {\n                                str = str.substring(1);\n                                if (str.length() == 0) {\n                                    throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n                                }\n                                // time-only format used with add(Duration)\n                                if (str.indexOf('T') >= 0) {\n                                    throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n                                }\n                                int[] parsed = parseDuration(str, negate);\n                                for (int k = 0; k < parsed.length; k++) {\n                                    values[k] = verifyUnit(values[k], parsed[k]);\n                                }\n                            } else {\n                                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n                            }\n                        }\n                    }\n                }\n            }\n            i = end;\n        } else {\n            if (type >= (negate == 0 ? SECONDS_INDEX : 6)) {\n                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n            }\n            int start = i++;\n            while (i < size && chars[i] >= '0' && chars[i] <= '9') {\n                i++;\n            }\n            int value = Integer.parseInt(durationStr.substring(start, i));\n            if (type == 0 && i < size && chars[i] == 'W') {\n                verifyValues(1, type);\n                values[type++] = negate(Weeks.weeks(value).getWeeks(), negate);\n                i++;\n            } else {\n                verifyValues(++typesIndex, type);\n                values[type++] = negate(value, negate);\n            }\n        }\n    }\n    if (typesIndex == 0 && type == 1 && values[0] == 0) {\n        return Period.ZERO;\n    }\n    if (type < SECONDS_INDEX) {\n        int seconds = 0;\n        for (i = 0; i < type; i++) {\n            seconds = FieldUtils.safeAdd(seconds, values[i] * SECONDS_PER[i]);\n        }\n        return createPeriod(negate != 0, values[0], values[1], values[2], values[3], values[4], values[5], seconds, 0);\n    } else {\n        long milliseconds = 0;\n        int seconds = 0;\n        for (i = 0; i < SECONDS_INDEX; i++) {\n            seconds = FieldUtils.safeAdd(seconds, values[i] * SECONDS_PER[i]);\n        }\n        for (; i < type; i++) {\n            milliseconds = FieldUtils.safeAdd(milliseconds, values[i] * MILLIS_PER[i - SECONDS_INDEX]);\n        }\n        return createPeriod(negate != 0, values[0], values[1], values[2], values[3], values[4], values[5], seconds, milliseconds);\n    }\n}\n\nprivate static void verifyValues(int set, int type) {\n    if (set != type) {\n        throw new IllegalArgumentException(\"Invalid duration format: format requires \" + set + \" values but supplied \" + type);\n    }\n}\n\nprivate static int verifyUnit(int value1, int value2) {\n    if (value1 != 0 && value2 != 0) {\n        throw new IllegalArgumentException(\"Multiple time zone indicators in duration are not allowed\");\n    }\n    return value1 + value2;\n}\n\nprivate static int parseTotalMillis(String durationStr, int start, boolean negative, int[] values) {\n    int i = durationStr.indexOf('Z', start);\n    if (i < 0) {\n        i = durationStr.indexOf('+', start);\n        if (i < 0) {\n            i = durationStr.indexOf('-', start);\n            if (i < 0) {\n                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n            }\n        }\n    }\n    int hours = parseInt(durationStr, start + 1, i);\n    i++;\n    int minutes = parseInt(durationStr, i, i + 2);\n    i += 3;\n    int seconds = parseInt(durationStr, i, i + 2);\n    i += 3;\n    int millis = parseInt(durationStr, i, durationStr.indexOf('S', i));\n    values[6] = negate(((((hours * 60L) + minutes) * 60L) + seconds) * 1000L + millis, negative); // <-- Index 6 in array is used to store milliseconds\n    return durationStr.indexOf('S', i) + 1;\n}\n\nprivate static int parseInt(String str, int fromIndex, int toIndex) {\n    if (fromIndex < 0 || toIndex < 0 || fromIndex >= str.length() || toIndex > str.length()) {\n        throw new NumberFormatException(\"Invalid duration format: \" + str);\n    }\n    int i = Integer.parseInt(str.substring(fromIndex, toIndex));\n    if (toIndex - fromIndex == 3 && str.charAt(fromIndex) == '-') {\n        i = -i;\n    }\n    return i;\n}\n\nprivate static int[] parseFraction(String str, int pos) {\n    int start = pos + 1;\n    while (start < str.length()) {\n        char c = str.charAt(start);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        start++;\n    }\n    int millis;\n    int pow = 0;\n    if (start <= pos + 1) {\n        throw new IllegalArgumentException(\"Invalid duration format: \" + str);\n    }\n    int value = Integer.parseInt(str.substring(pos + 1, start));\n    while (start < str.length() && pow < 3) {\n        char c = str.charAt(start);\n        if (c < '0' || c > '9') {\n            break;\n        }\n        pow++;\n        start++;\n        value *= 10;\n        value += c - '0';\n    }\n    while (start < str.length() && str.charAt(start) >= '0' && str.charAt(start) <= '9') {\n        start++;\n    }\n    if (start == pos + 1) {\n        // single dot\n        throw new IllegalArgumentException(\"Invalid duration format: \" + str);\n    }\n    switch (start - (pos + 1)) {\n        case 1: // 'T'\n            millis = value * 100;\n            break;\n        case 2: // '.S'\n            millis = value * 10;\n            break;\n        case 3: // '.SSS'\n            millis = value;\n            break;\n        default:\n            throw new IllegalArgumentException(\"Invalid duration format: \" + str);\n    }\n    return new int[]{start - 1, millis};\n}\n\nprivate static int negate(int value, int negate) {\n    return negate == 0 ? value : -value;\n}\n\nprivate static Period createPeriod(boolean negative, int years, int months, int weeks, int days, int hours, int minutes, int seconds, long millis) {\n    if (negative) {\n        years = FieldUtils.safeNegate(years);\n        months = FieldUtils.safeNegate(months);\n        weeks = FieldUtils.safeNegate(weeks);\n        days = FieldUtils.safeNegate(days);\n        hours = FieldUtils.safeNegate(hours);\n        minutes = FieldUtils.safeNegate(minutes);\n        seconds = FieldUtils.safeNegate(seconds);\n        millis = FieldUtils.safeNegate(millis);\n    }\n    return new Period(\n            years, months, weeks, days, hours, minutes, seconds, millis\n    );\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\nindex 15332284..580202a3 100644\n--- a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n@@ -791,26 +791,259 @@ public class PeriodFormatterBuilder {\n     }\n \n     //-----------------------------------------------------------------------\n-    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n-        if (notPrinter && notParser) {\n-            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n-        }\n-        int size = elementPairs.size();\n-        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n-            Separator sep = (Separator) elementPairs.get(0);\n-                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n-                sep = sep.finish(f.getPrinter(), f.getParser());\n-                return new PeriodFormatter(sep, sep);\n-        }\n-        Object[] comp = createComposite(elementPairs);\n-        if (notPrinter) {\n-            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n-        } else if (notParser) {\n-            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n+public static Period parsePeriod(String periodStr) {\n+    if (periodStr == null) {\n+        throw new IllegalArgumentException(\"Invalid period format: empty string\");\n+    }\n+    periodStr = periodStr.toUpperCase(Locale.ENGLISH);\n+    if (periodStr.startsWith(\"P\")) {\n+        return parseDuration(periodStr.substring(1), 0);\n+    }\n+    if (periodStr.startsWith(\"-P\")) {\n+        return parseDuration(periodStr.substring(2), 1);\n+    }\n+    throw new IllegalArgumentException(\"Invalid period format: \" + periodStr);\n+}\n+\n+private static Period parseDuration(String durationStr, int negate) {\n+    if (durationStr == null || durationStr.length() == 0) {\n+        return Period.ZERO;\n+    }\n+    int size = durationStr.length();\n+    char[] chars = new char[size];\n+    durationStr.getChars(0, size, chars, 0);\n+    boolean negative = false;\n+    int[] values = new int[8]; // <-- Array size set to 8 here\n+    int typesIndex = 0;\n+    int type = 0;\n+    int i = (chars[0] == '-' || chars[0] == '+') ? 1 : 0;\n+    for (; i < size; i++) {\n+        char c = chars[i];\n+        if (c == '.') {\n+            if (type >= (negate == 0 ? SECONDS_INDEX : 6)) {\n+                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+            }\n+            int[] parsed = parseFraction(durationStr, i);\n+            i = parsed[0];\n+            // Result is added even if its a zero, as a zero value is still a value\n+            values[type++] = negate(parsed[1], negate);\n+            continue;\n+        }\n+        if (c < '0' || c > '9') {\n+            // stop parse number, and determine value\n+            if (type == 7 && (c == 'Z' || c == '+' || c == '-')) {\n+                i = parseTotalMillis(durationStr, i, negative, values);\n+                break;\n+            }\n+            int end;\n+            if (c == ',') {\n+                end = findEnd(durationStr, i);\n+                i++;\n+            } else {\n+                end = i + 1;\n+            }\n+            String str = durationStr.substring(i, end);\n+            if (str.equals(\"H\")) {\n+                verifyValues(++typesIndex, type);\n+                values[type++] = negate(Integer.parseInt(checkSingular(str)), negate);\n+            } else\n+                if (str.equals(\"M\")) {\n+                if (type >= SECONDS_INDEX) {\n+                    throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+                }\n+                verifyValues(++typesIndex, type);\n+                values[type++] = negate(Integer.parseInt(checkSingular(str)), negate);\n+            } else {\n+                if (str.equals(\"S\")) {\n+                    if (type >= SECONDS_INDEX) {\n+                        throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+                    }\n+                    verifyValues(++typesIndex, type);\n+                    values[type++] = negate(Integer.parseInt(checkSingular(str)), negate);\n+                } else {\n+                    if (str.equals(\"D\")) {\n+                        verifyValues(1, type);\n+                        values[0] = negate(Integer.parseInt(checkSingular(str)), negate);\n+                    } else {\n+                        if (str.equals(\"W\")) {\n+                            verifyValues(2, type);\n+                            values[1] = negate(Integer.parseInt(checkSingular(str)), negate);\n+                        } else {\n+                            if (str.charAt(0) == 'P') {\n+                                str = str.substring(1);\n+                                if (str.length() == 0) {\n+                                    throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+                                }\n+                                // time-only format used with add(Duration)\n+                                if (str.indexOf('T') >= 0) {\n+                                    throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+                                }\n+                                int[] parsed = parseDuration(str, negate);\n+                                for (int k = 0; k < parsed.length; k++) {\n+                                    values[k] = verifyUnit(values[k], parsed[k]);\n+                                }\n+                            } else {\n+                                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+                            }\n+                        }\n+                    }\n+                }\n+            }\n+            i = end;\n         } else {\n-            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n+            if (type >= (negate == 0 ? SECONDS_INDEX : 6)) {\n+                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+            }\n+            int start = i++;\n+            while (i < size && chars[i] >= '0' && chars[i] <= '9') {\n+                i++;\n+            }\n+            int value = Integer.parseInt(durationStr.substring(start, i));\n+            if (type == 0 && i < size && chars[i] == 'W') {\n+                verifyValues(1, type);\n+                values[type++] = negate(Weeks.weeks(value).getWeeks(), negate);\n+                i++;\n+            } else {\n+                verifyValues(++typesIndex, type);\n+                values[type++] = negate(value, negate);\n+            }\n+        }\n+    }\n+    if (typesIndex == 0 && type == 1 && values[0] == 0) {\n+        return Period.ZERO;\n+    }\n+    if (type < SECONDS_INDEX) {\n+        int seconds = 0;\n+        for (i = 0; i < type; i++) {\n+            seconds = FieldUtils.safeAdd(seconds, values[i] * SECONDS_PER[i]);\n+        }\n+        return createPeriod(negate != 0, values[0], values[1], values[2], values[3], values[4], values[5], seconds, 0);\n+    } else {\n+        long milliseconds = 0;\n+        int seconds = 0;\n+        for (i = 0; i < SECONDS_INDEX; i++) {\n+            seconds = FieldUtils.safeAdd(seconds, values[i] * SECONDS_PER[i]);\n+        }\n+        for (; i < type; i++) {\n+            milliseconds = FieldUtils.safeAdd(milliseconds, values[i] * MILLIS_PER[i - SECONDS_INDEX]);\n+        }\n+        return createPeriod(negate != 0, values[0], values[1], values[2], values[3], values[4], values[5], seconds, milliseconds);\n+    }\n+}\n+\n+private static void verifyValues(int set, int type) {\n+    if (set != type) {\n+        throw new IllegalArgumentException(\"Invalid duration format: format requires \" + set + \" values but supplied \" + type);\n+    }\n+}\n+\n+private static int verifyUnit(int value1, int value2) {\n+    if (value1 != 0 && value2 != 0) {\n+        throw new IllegalArgumentException(\"Multiple time zone indicators in duration are not allowed\");\n+    }\n+    return value1 + value2;\n+}\n+\n+private static int parseTotalMillis(String durationStr, int start, boolean negative, int[] values) {\n+    int i = durationStr.indexOf('Z', start);\n+    if (i < 0) {\n+        i = durationStr.indexOf('+', start);\n+        if (i < 0) {\n+            i = durationStr.indexOf('-', start);\n+            if (i < 0) {\n+                throw new IllegalArgumentException(\"Invalid duration format: \" + durationStr);\n+            }\n         }\n     }\n+    int hours = parseInt(durationStr, start + 1, i);\n+    i++;\n+    int minutes = parseInt(durationStr, i, i + 2);\n+    i += 3;\n+    int seconds = parseInt(durationStr, i, i + 2);\n+    i += 3;\n+    int millis = parseInt(durationStr, i, durationStr.indexOf('S', i));\n+    values[6] = negate(((((hours * 60L) + minutes) * 60L) + seconds) * 1000L + millis, negative); // <-- Index 6 in array is used to store milliseconds\n+    return durationStr.indexOf('S', i) + 1;\n+}\n+\n+private static int parseInt(String str, int fromIndex, int toIndex) {\n+    if (fromIndex < 0 || toIndex < 0 || fromIndex >= str.length() || toIndex > str.length()) {\n+        throw new NumberFormatException(\"Invalid duration format: \" + str);\n+    }\n+    int i = Integer.parseInt(str.substring(fromIndex, toIndex));\n+    if (toIndex - fromIndex == 3 && str.charAt(fromIndex) == '-') {\n+        i = -i;\n+    }\n+    return i;\n+}\n+\n+private static int[] parseFraction(String str, int pos) {\n+    int start = pos + 1;\n+    while (start < str.length()) {\n+        char c = str.charAt(start);\n+        if (c < '0' || c > '9') {\n+            break;\n+        }\n+        start++;\n+    }\n+    int millis;\n+    int pow = 0;\n+    if (start <= pos + 1) {\n+        throw new IllegalArgumentException(\"Invalid duration format: \" + str);\n+    }\n+    int value = Integer.parseInt(str.substring(pos + 1, start));\n+    while (start < str.length() && pow < 3) {\n+        char c = str.charAt(start);\n+        if (c < '0' || c > '9') {\n+            break;\n+        }\n+        pow++;\n+        start++;\n+        value *= 10;\n+        value += c - '0';\n+    }\n+    while (start < str.length() && str.charAt(start) >= '0' && str.charAt(start) <= '9') {\n+        start++;\n+    }\n+    if (start == pos + 1) {\n+        // single dot\n+        throw new IllegalArgumentException(\"Invalid duration format: \" + str);\n+    }\n+    switch (start - (pos + 1)) {\n+        case 1: // 'T'\n+            millis = value * 100;\n+            break;\n+        case 2: // '.S'\n+            millis = value * 10;\n+            break;\n+        case 3: // '.SSS'\n+            millis = value;\n+            break;\n+        default:\n+            throw new IllegalArgumentException(\"Invalid duration format: \" + str);\n+    }\n+    return new int[]{start - 1, millis};\n+}\n+\n+private static int negate(int value, int negate) {\n+    return negate == 0 ? value : -value;\n+}\n+\n+private static Period createPeriod(boolean negative, int years, int months, int weeks, int days, int hours, int minutes, int seconds, long millis) {\n+    if (negative) {\n+        years = FieldUtils.safeNegate(years);\n+        months = FieldUtils.safeNegate(months);\n+        weeks = FieldUtils.safeNegate(weeks);\n+        days = FieldUtils.safeNegate(days);\n+        hours = FieldUtils.safeNegate(hours);\n+        minutes = FieldUtils.safeNegate(minutes);\n+        seconds = FieldUtils.safeNegate(seconds);\n+        millis = FieldUtils.safeNegate(millis);\n+    }\n+    return new Period(\n+            years, months, weeks, days, hours, minutes, seconds, millis\n+    );\n+}\n \n     private static Object[] createComposite(List<Object> elementPairs) {\n         switch (elementPairs.size()) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}