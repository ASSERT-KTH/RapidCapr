{
    "patch": "try {\n    for (int i = 0; i < count; i++) {\n        millis = savedFields[i].set(millis, resetFields);\n    }\n} catch (IllegalFieldValueException e) {\n    // use a locally created copy of the fields to ensure that\n    // we do not corrupt the original array as constraint checks are made\n    SavedField[] tmpSavedFields = new SavedField[savedFields.length];\n    System.arraycopy(savedFields, 0, tmpSavedFields, 0, savedFields.length);\n    \n    for (int i = 0; i < count; i++) {\n        try {\n            millis = tmpSavedFields[i].set(millis, resetFields);\n        } catch (Throwable t) {\n            // ignore\n            tmpSavedFields[i] = null;\n        }\n    }\n    \n    long lastTime = millis;\n    if (resetFields) {\n        lastTime = iChrono.millisOfDay().set(lastTime, 0);\n    }\n    for (int i = count - 1; i >= 0; i--) {\n        if (tmpSavedFields[i] == null) {\n            // element was invalid, so remove it\n            int newSize = count - 1;\n            SavedField[] newSavedFields = new SavedField[newSize];\n            System.arraycopy(savedFields, 0, newSavedFields, 0, i);\n            if (i < newSize) {\n                System.arraycopy(savedFields, i + 1, newSavedFields, i, newSize - i);\n            }\n            count--;\n            savedFields = newSavedFields;\n        } else {\n            // element was valid, so update it with final value\n            tmpSavedFields[i].save();\n            millis = tmpSavedFields[i].set(lastTime, false);\n        }\n    }\n\n    // re-sort the saved fields array\n    if (count > 0) {\n        sort(savedFields, count);\n    }\n\n    if (count > 0) {\n        DurationField months = DurationFieldType.months().getField(iChrono);\n        DurationField days = DurationFieldType.days().getField(iChrono);\n        DurationField first = savedFields[0].iField.getDurationField();\n        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n            saveField(DateTimeFieldType.year(), iDefaultYear);\n            return computeMillis(resetFields, text);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..79f377df 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,62 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+try {\n+    for (int i = 0; i < count; i++) {\n+        millis = savedFields[i].set(millis, resetFields);\n+    }\n+} catch (IllegalFieldValueException e) {\n+    // use a locally created copy of the fields to ensure that\n+    // we do not corrupt the original array as constraint checks are made\n+    SavedField[] tmpSavedFields = new SavedField[savedFields.length];\n+    System.arraycopy(savedFields, 0, tmpSavedFields, 0, savedFields.length);\n+    \n+    for (int i = 0; i < count; i++) {\n+        try {\n+            millis = tmpSavedFields[i].set(millis, resetFields);\n+        } catch (Throwable t) {\n+            // ignore\n+            tmpSavedFields[i] = null;\n+        }\n+    }\n+    \n+    long lastTime = millis;\n+    if (resetFields) {\n+        lastTime = iChrono.millisOfDay().set(lastTime, 0);\n+    }\n+    for (int i = count - 1; i >= 0; i--) {\n+        if (tmpSavedFields[i] == null) {\n+            // element was invalid, so remove it\n+            int newSize = count - 1;\n+            SavedField[] newSavedFields = new SavedField[newSize];\n+            System.arraycopy(savedFields, 0, newSavedFields, 0, i);\n+            if (i < newSize) {\n+                System.arraycopy(savedFields, i + 1, newSavedFields, i, newSize - i);\n+            }\n+            count--;\n+            savedFields = newSavedFields;\n+        } else {\n+            // element was valid, so update it with final value\n+            tmpSavedFields[i].save();\n+            millis = tmpSavedFields[i].set(lastTime, false);\n+        }\n+    }\n+\n+    // re-sort the saved fields array\n+    if (count > 0) {\n+        sort(savedFields, count);\n+    }\n+\n+    if (count > 0) {\n+        DurationField months = DurationFieldType.months().getField(iChrono);\n+        DurationField days = DurationFieldType.days().getField(iChrono);\n+        DurationField first = savedFields[0].iField.getDurationField();\n+        if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n+            saveField(DateTimeFieldType.year(), iDefaultYear);\n+            return computeMillis(resetFields, text);\n+        }\n+    }\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}