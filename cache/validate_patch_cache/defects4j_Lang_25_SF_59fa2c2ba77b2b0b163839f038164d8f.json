{
    "patch": "public static String unescape(String input) {\n    char[] in = input.toCharArray();\n    int off = 0;\n    int len = in.length;\n    char[] convtBuf = new char[len];\n    int p = 0;\n    while (true) {\n        // Search for '&'\n        int next = findNextCharacter(in, '&', off);\n        if (next < 0) {\n            if (p < len)\n                System.arraycopy(in, off, convtBuf, p, len - off);\n            return new String(convtBuf, 0, p);\n        }\n\n        // Copy characters between off..(next-1) from the input to the output buffer\n        if (next > off) {\n            int count = next - off;\n            if (p + count > convtBuf.length)\n                convtBuf = Arrays.copyOf(convtBuf, Math.max(convtBuf.length << 1, p + count));\n            System.arraycopy(in, off, convtBuf, p, count);\n            p += count;\n        }\n\n        // Decode the escaped character\n        off = decodeEscapeCharacter(in, next, len, convtBuf, p);\n        p++;\n\n        // Skip over the decoded escape sequence in the input\n        off++;\n    }\n}\n\n// Searches for the next occurrence of the specified character in\n// the given input buffer.\nprivate static int findNextCharacter(char[] in, char ch, int off) {\n    int len = in.length;\n    for (int i = off; i < len; i++) {\n        if (in[i] == ch) {\n            return i;\n        }\n    }\n    return -1;\n}\n\n// Decodes an escape sequence (starting with & and ending with ;)\n// and writes the corresponding character to the output buffer.\nprivate static int decodeEscapeCharacter(char[] in, int off, int len, char[] out, int outOff) {\n    // Check whether this is a numeric escape sequence\n    if (in[off + 1] == '#') {\n        off += 2;\n        int value;\n        if (in[off] == 'x') {\n            // Hexadecimal value\n            value = Integer.parseInt(new String(in, off + 1, 2), 16);\n            off += 3;\n        } else {\n            // Decimal value\n            int next = findNextCharacter(in, ';', off);\n            value = Integer.parseInt(new String(in, off, next - off));\n            off = next;\n        }\n        out[outOff] = (char) value;\n        return off;\n    }\n\n    // It's not a numeric escape sequence - it must be a named entity\n    int next = findNextCharacter(in, ';', off);\n    String name = new String(in, off + 1, next - off - 1);\n    if (name.equals(\"lt\")) {\n        out[outOff] = '<';\n    } else if (name.equals(\"gt\")) {\n        out[outOff] = '>';\n    } else if (name.equals(\"amp\")) {\n        out[outOff] = '&';\n    } else if (name.equals(\"quot\")) {\n        out[outOff] = '\"';\n    } else if (name.equals(\"apos\")) {\n        out[outOff] = '\\'';\n    } else {\n        return off;\n    }\n    return next;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\nindex 8caca580..e06d0c11 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n@@ -27,7 +27,90 @@ package org.apache.commons.lang3.text.translate;\n  */\n public class EntityArrays {\n \n-    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\n+public static String unescape(String input) {\n+    char[] in = input.toCharArray();\n+    int off = 0;\n+    int len = in.length;\n+    char[] convtBuf = new char[len];\n+    int p = 0;\n+    while (true) {\n+        // Search for '&'\n+        int next = findNextCharacter(in, '&', off);\n+        if (next < 0) {\n+            if (p < len)\n+                System.arraycopy(in, off, convtBuf, p, len - off);\n+            return new String(convtBuf, 0, p);\n+        }\n+\n+        // Copy characters between off..(next-1) from the input to the output buffer\n+        if (next > off) {\n+            int count = next - off;\n+            if (p + count > convtBuf.length)\n+                convtBuf = Arrays.copyOf(convtBuf, Math.max(convtBuf.length << 1, p + count));\n+            System.arraycopy(in, off, convtBuf, p, count);\n+            p += count;\n+        }\n+\n+        // Decode the escaped character\n+        off = decodeEscapeCharacter(in, next, len, convtBuf, p);\n+        p++;\n+\n+        // Skip over the decoded escape sequence in the input\n+        off++;\n+    }\n+}\n+\n+// Searches for the next occurrence of the specified character in\n+// the given input buffer.\n+private static int findNextCharacter(char[] in, char ch, int off) {\n+    int len = in.length;\n+    for (int i = off; i < len; i++) {\n+        if (in[i] == ch) {\n+            return i;\n+        }\n+    }\n+    return -1;\n+}\n+\n+// Decodes an escape sequence (starting with & and ending with ;)\n+// and writes the corresponding character to the output buffer.\n+private static int decodeEscapeCharacter(char[] in, int off, int len, char[] out, int outOff) {\n+    // Check whether this is a numeric escape sequence\n+    if (in[off + 1] == '#') {\n+        off += 2;\n+        int value;\n+        if (in[off] == 'x') {\n+            // Hexadecimal value\n+            value = Integer.parseInt(new String(in, off + 1, 2), 16);\n+            off += 3;\n+        } else {\n+            // Decimal value\n+            int next = findNextCharacter(in, ';', off);\n+            value = Integer.parseInt(new String(in, off, next - off));\n+            off = next;\n+        }\n+        out[outOff] = (char) value;\n+        return off;\n+    }\n+\n+    // It's not a numeric escape sequence - it must be a named entity\n+    int next = findNextCharacter(in, ';', off);\n+    String name = new String(in, off + 1, next - off - 1);\n+    if (name.equals(\"lt\")) {\n+        out[outOff] = '<';\n+    } else if (name.equals(\"gt\")) {\n+        out[outOff] = '>';\n+    } else if (name.equals(\"amp\")) {\n+        out[outOff] = '&';\n+    } else if (name.equals(\"quot\")) {\n+        out[outOff] = '\"';\n+    } else if (name.equals(\"apos\")) {\n+        out[outOff] = '\\'';\n+    } else {\n+        return off;\n+    }\n+    return next;\n+}\n     private static final String[][] ISO8859_1_ESCAPE = {\n         {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n         {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark",
    "result_reason": "error: operand expected (error token is \"=\")",
    "test_result": "ERROR"
}