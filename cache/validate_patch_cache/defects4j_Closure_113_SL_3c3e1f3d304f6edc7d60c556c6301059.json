{
    "patch": "    private static final String WARNING_LEVEL_VALUE_OFF = \"off\";\n  \n    private void maybeAddExtraRequire(JSModuleGraph.Builder builder, Node n) {\n      if (n.isCall() && n.getFirstChild().matchesQualifiedName(\"goog.addDependency\")) {\n        Node secondChild = n.getSecondChild();\n  \n        if (secondChild != null && secondChild.isString()) {\n          JSModule module = closureToModuleId.get(secondChild.getString());\n          if (module == null) {\n            if (reportDependencies) {\n              final Node thirdChild = n.getChildAtIndex(2);\n              if (thirdChild.isString()) {\n                String path = thirdChild.getString();\n                // If the path is a relative path, resolve it.\n                if (!PathUtil.isAbsolute(path)) {\n                  path = PathUtil.resolve(currentFile, path);\n                }\n                builder.addUnresolvedDependency(PathUtil.removeLastPathElement(path));\n                // Set the warning level to \"off\" to avoid \"missing requires\" warnings. \n                // We will add extra requires below.\n                n.putBooleanProp(Node.IS_NAMESPACE, false);\n                Node fourthChild = n.getChildAtIndex(3);\n                if (fourthChild.isObjectLit()) {\n                  fourthChild.addChildToBack(Node.newString(Token.STRING, \"warning_level\"));\n                  fourthChild.addChildToBack(Node.newString(Token.STRING, WARNING_LEVEL_VALUE_OFF));\n                } else {\n                  Node objectLit = new Node(Token.OBJECTLIT);\n                  objectLit.addChildToBack(Node.newString(Token.STRING, \"warning_level\"));\n                  objectLit.addChildToBack(Node.newString(Token.STRING, WARNING_LEVEL_VALUE_OFF));\n                  n.addChildToBack(objectLit);\n                }\n              }\n            }\n          } else {\n            if (builder.hasModule(module)) {\n              compiler.report(JSError.make(n, DUPLICATE_MODULE, secondChild.getString()));\n            } else {\n              builder.addDependency(module, Pair.of(n, n.getBooleanProp(Node.NEEDS_ISOLATION)));\n            }\n          }\n        }\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\nindex 70bf1b00..396ba64e 100644\n--- a/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n+++ b/src/com/google/javascript/jscomp/ProcessClosurePrimitives.java\n@@ -326,7 +326,49 @@ class ProcessClosurePrimitives extends AbstractPostOrderCallback\n       // the checks for broken requires turned off. In these cases, we\n       // allow broken requires to be preserved by the first run to\n       // let them be caught in the subsequent run.\n-      if (provided != null) {\n+    private static final String WARNING_LEVEL_VALUE_OFF = \"off\";\n+  \n+    private void maybeAddExtraRequire(JSModuleGraph.Builder builder, Node n) {\n+      if (n.isCall() && n.getFirstChild().matchesQualifiedName(\"goog.addDependency\")) {\n+        Node secondChild = n.getSecondChild();\n+  \n+        if (secondChild != null && secondChild.isString()) {\n+          JSModule module = closureToModuleId.get(secondChild.getString());\n+          if (module == null) {\n+            if (reportDependencies) {\n+              final Node thirdChild = n.getChildAtIndex(2);\n+              if (thirdChild.isString()) {\n+                String path = thirdChild.getString();\n+                // If the path is a relative path, resolve it.\n+                if (!PathUtil.isAbsolute(path)) {\n+                  path = PathUtil.resolve(currentFile, path);\n+                }\n+                builder.addUnresolvedDependency(PathUtil.removeLastPathElement(path));\n+                // Set the warning level to \"off\" to avoid \"missing requires\" warnings. \n+                // We will add extra requires below.\n+                n.putBooleanProp(Node.IS_NAMESPACE, false);\n+                Node fourthChild = n.getChildAtIndex(3);\n+                if (fourthChild.isObjectLit()) {\n+                  fourthChild.addChildToBack(Node.newString(Token.STRING, \"warning_level\"));\n+                  fourthChild.addChildToBack(Node.newString(Token.STRING, WARNING_LEVEL_VALUE_OFF));\n+                } else {\n+                  Node objectLit = new Node(Token.OBJECTLIT);\n+                  objectLit.addChildToBack(Node.newString(Token.STRING, \"warning_level\"));\n+                  objectLit.addChildToBack(Node.newString(Token.STRING, WARNING_LEVEL_VALUE_OFF));\n+                  n.addChildToBack(objectLit);\n+                }\n+              }\n+            }\n+          } else {\n+            if (builder.hasModule(module)) {\n+              compiler.report(JSError.make(n, DUPLICATE_MODULE, secondChild.getString()));\n+            } else {\n+              builder.addDependency(module, Pair.of(n, n.getBooleanProp(Node.NEEDS_ISOLATION)));\n+            }\n+          }\n+        }\n+      }\n+    }\n         parent.detachFromParent();\n         compiler.reportCodeChange();\n       }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}