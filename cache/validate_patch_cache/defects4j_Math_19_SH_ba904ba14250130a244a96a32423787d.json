{
    "patch": "                double sum = 0;\n                for (int i = 0; i < init.length; i++) {\n                    sum += FastMath.abs(init[i]);\n                    if (boundaries != null) {\n                        final double[] b = boundaries[i];\n                        final double boundDiff = b[1] - b[0];\n                        if (Double.isInfinite(boundDiff)) {\n                            if (init[i] * b[0] < 0 ||\n                                Double.isInfinite(init[i])) {\n                                throw new MathIllegalArgumentException(LocalizedCoreFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, init[i], b[0], b[1]);\n                            }\n                            continue;\n                        }\n                        // Returns true if the values are equal or within range of each other.\n                        boolean equal = Precision.equals(init[i],b[0], FastMath.max(relativeThreshold * FastMath.abs(b[0]), absoluteThreshold))\n                                    || Precision.equals(init[i],b[1], FastMath.max(relativeThreshold * FastMath.abs(b[1]), absoluteThreshold));\n                        if ((init[i] < b[0] && !equal) ||\n                            (init[i] > b[1] && !equal)) {\n                            throw new MathIllegalArgumentException(LocalizedCoreFormats.OUT_OF_RANGE_SIMPLE, init[i], b[0], b[1]);\n                        }\n                        // Ensure the number does not become too small after normalization.\n                        final double normalizedAbs = FastMath.abs((init[i] - b[0]) / boundDiff);\n                        if (Double.isInfinite(normalizedAbs) ||\n                            normalizedAbs > FastMath.sqrt(Precision.EPSILON)) {\n                            throw new MathIllegalArgumentException(LocalizedOptimFormats.NORMALIZE_BOUND_DIFF, boundDiff);\n                        }\n                    } else if (Double.isInfinite(init[i])) {\n                        throw new MathIllegalArgumentException(LocalizedCoreFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, init[i], Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n                    }\n                }\n                if (sum > FastMath.sqrt(Precision.SAFE_MIN)) {\n                    throw new MathIllegalArgumentException(LocalizedCoreFormats.TOO_LARGE_RELATIVE_DEVIATION, sum);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 51d1c6428..6bc7632f7 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -537,6 +537,38 @@ public class CMAESOptimizer\n                 boundaries[1] = uB;\n \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                double sum = 0;\n+                for (int i = 0; i < init.length; i++) {\n+                    sum += FastMath.abs(init[i]);\n+                    if (boundaries != null) {\n+                        final double[] b = boundaries[i];\n+                        final double boundDiff = b[1] - b[0];\n+                        if (Double.isInfinite(boundDiff)) {\n+                            if (init[i] * b[0] < 0 ||\n+                                Double.isInfinite(init[i])) {\n+                                throw new MathIllegalArgumentException(LocalizedCoreFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, init[i], b[0], b[1]);\n+                            }\n+                            continue;\n+                        }\n+                        // Returns true if the values are equal or within range of each other.\n+                        boolean equal = Precision.equals(init[i],b[0], FastMath.max(relativeThreshold * FastMath.abs(b[0]), absoluteThreshold))\n+                                    || Precision.equals(init[i],b[1], FastMath.max(relativeThreshold * FastMath.abs(b[1]), absoluteThreshold));\n+                        if ((init[i] < b[0] && !equal) ||\n+                            (init[i] > b[1] && !equal)) {\n+                            throw new MathIllegalArgumentException(LocalizedCoreFormats.OUT_OF_RANGE_SIMPLE, init[i], b[0], b[1]);\n+                        }\n+                        // Ensure the number does not become too small after normalization.\n+                        final double normalizedAbs = FastMath.abs((init[i] - b[0]) / boundDiff);\n+                        if (Double.isInfinite(normalizedAbs) ||\n+                            normalizedAbs > FastMath.sqrt(Precision.EPSILON)) {\n+                            throw new MathIllegalArgumentException(LocalizedOptimFormats.NORMALIZE_BOUND_DIFF, boundDiff);\n+                        }\n+                    } else if (Double.isInfinite(init[i])) {\n+                        throw new MathIllegalArgumentException(LocalizedCoreFormats.NUMBER_TOO_LARGE_BOUND_EXCLUDED, init[i], Double.NEGATIVE_INFINITY, Double.POSITIVE_INFINITY);\n+                    }\n+                }\n+                if (sum > FastMath.sqrt(Precision.SAFE_MIN)) {\n+                    throw new MathIllegalArgumentException(LocalizedCoreFormats.TOO_LARGE_RELATIVE_DEVIATION, sum);\n             }\n         } else {\n             // Convert API to internal handling of boundaries.",
    "result_reason": "error: 'else' without 'if'",
    "test_result": "ERROR"
}