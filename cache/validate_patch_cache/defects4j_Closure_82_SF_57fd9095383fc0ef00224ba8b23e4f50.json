{
    "patch": "@Test\npublic void testIssue301() {\n    CompilationUnit cu = StaticJavaParser.parse(\n            \"public class X<Y> { \" +\n            \"  Y y; \" +\n            \"  public void f() { \" +\n            \"    for (Z z : (Iterable<Z>) null) { \" +\n            \"    } \" +\n            \"    for (Z z : (List<? extends Z>) null) { \" +\n            \"    } \" +\n            \"    for (Z z : (List<Z> & Serializable) null) { \" +\n            \"    } \" +\n            \"  } \" +\n            \"  public boolean isEmptyType() { \" +\n            \"    return true; \" +\n            \"  } \" +\n            \"}\"\n    );\n\n    List<MethodCallExpr> calls = cu.findAll(MethodCallExpr.class);\n\n    // Modify this line to check if the isEmptyType() method is called AND whether it returns true\n    assertTrue(calls.stream().anyMatch(m -> m.getNameAsString().equals(\"isEmptyType\") && m.<Boolean>asMethodCallExpr().resolve().getReturnType().isPrimitiveType() && m.<Boolean>asMethodCallExpr().resolve().getReturnType().asPrimitiveType().getType() == PrimitiveType.Primitive.BOOLEAN));\n\n    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(new CombinedTypeSolver());\n    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n\n    cu.accept(new ModifierVisitor<Void>() {\n\n        @Override\n        public Visitable visit(MethodCallExpr n, Void arg) {\n            if (n.getNameAsString().equals(\"asList\")) {\n                ResolvedMethodDeclaration resolved = n.resolve();\n                assertTrue(resolved.getQualifiedSignature().contains(\"<T> List<T> asList(T...)\"));\n            } else if (n.getNameAsString().equals(\"isEmptyType\")) {\n                ResolvedMethodDeclaration resolved = n.resolve();\n                assertTrue(resolved.getQualifiedSignature().equals(\"boolean isEmptyType()\"));\n            }\n            return super.visit(n, arg);\n        }\n    }, null);\n\n    ParseResult<CompilationUnit> result = new JavaParser().parse(\n            \"class X {\" +\n            \"  public void f() {\" +\n            \"    for (Z z : (Iterable<Z>) null) { \" +\n            \"    } \" +\n            \"    for (Z z : (List<? extends Z>) null) { \" +\n            \"    } \" +\n            \"    for (Z z : (List<Z> & Serializable) null) { \" +\n            \"    } \" +\n            \"  } \" +\n            \"}\"\n    );\n    result.getResult().ifPresent(r -> {\n        r.getMethodsByName(\"f\").forEach(m -> {\n            // Modify this line to check if the isEmptyType() method is called AND whether it returns true\n            assertTrue(m.getBody().get().findAll(MethodCallExpr.class)\n                    .stream().anyMatch(ex -> ex.getNameAsString().equals(\"isEmptyType\")\n                            && ex.<Boolean>asMethodCallExpr().resolve().getReturnType().isPrimitiveType()\n                            && ex.<Boolean>asMethodCallExpr().resolve().getReturnType().asPrimitiveType().getType() == PrimitiveType.Primitive.BOOLEAN));\n        });\n    });\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex 32a0b250..a6bc2d00 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -159,9 +159,70 @@ public abstract class JSType implements Serializable {\n     return false;\n   }\n \n-  public final boolean isEmptyType() {\n-    return isNoType() || isNoObjectType() || isNoResolvedType();\n-  }\n+@Test\n+public void testIssue301() {\n+    CompilationUnit cu = StaticJavaParser.parse(\n+            \"public class X<Y> { \" +\n+            \"  Y y; \" +\n+            \"  public void f() { \" +\n+            \"    for (Z z : (Iterable<Z>) null) { \" +\n+            \"    } \" +\n+            \"    for (Z z : (List<? extends Z>) null) { \" +\n+            \"    } \" +\n+            \"    for (Z z : (List<Z> & Serializable) null) { \" +\n+            \"    } \" +\n+            \"  } \" +\n+            \"  public boolean isEmptyType() { \" +\n+            \"    return true; \" +\n+            \"  } \" +\n+            \"}\"\n+    );\n+\n+    List<MethodCallExpr> calls = cu.findAll(MethodCallExpr.class);\n+\n+    // Modify this line to check if the isEmptyType() method is called AND whether it returns true\n+    assertTrue(calls.stream().anyMatch(m -> m.getNameAsString().equals(\"isEmptyType\") && m.<Boolean>asMethodCallExpr().resolve().getReturnType().isPrimitiveType() && m.<Boolean>asMethodCallExpr().resolve().getReturnType().asPrimitiveType().getType() == PrimitiveType.Primitive.BOOLEAN));\n+\n+    JavaSymbolSolver symbolSolver = new JavaSymbolSolver(new CombinedTypeSolver());\n+    StaticJavaParser.getConfiguration().setSymbolResolver(symbolSolver);\n+\n+    cu.accept(new ModifierVisitor<Void>() {\n+\n+        @Override\n+        public Visitable visit(MethodCallExpr n, Void arg) {\n+            if (n.getNameAsString().equals(\"asList\")) {\n+                ResolvedMethodDeclaration resolved = n.resolve();\n+                assertTrue(resolved.getQualifiedSignature().contains(\"<T> List<T> asList(T...)\"));\n+            } else if (n.getNameAsString().equals(\"isEmptyType\")) {\n+                ResolvedMethodDeclaration resolved = n.resolve();\n+                assertTrue(resolved.getQualifiedSignature().equals(\"boolean isEmptyType()\"));\n+            }\n+            return super.visit(n, arg);\n+        }\n+    }, null);\n+\n+    ParseResult<CompilationUnit> result = new JavaParser().parse(\n+            \"class X {\" +\n+            \"  public void f() {\" +\n+            \"    for (Z z : (Iterable<Z>) null) { \" +\n+            \"    } \" +\n+            \"    for (Z z : (List<? extends Z>) null) { \" +\n+            \"    } \" +\n+            \"    for (Z z : (List<Z> & Serializable) null) { \" +\n+            \"    } \" +\n+            \"  } \" +\n+            \"}\"\n+    );\n+    result.getResult().ifPresent(r -> {\n+        r.getMethodsByName(\"f\").forEach(m -> {\n+            // Modify this line to check if the isEmptyType() method is called AND whether it returns true\n+            assertTrue(m.getBody().get().findAll(MethodCallExpr.class)\n+                    .stream().anyMatch(ex -> ex.getNameAsString().equals(\"isEmptyType\")\n+                            && ex.<Boolean>asMethodCallExpr().resolve().getReturnType().isPrimitiveType()\n+                            && ex.<Boolean>asMethodCallExpr().resolve().getReturnType().asPrimitiveType().getType() == PrimitiveType.Primitive.BOOLEAN));\n+        });\n+    });\n+}\n \n   public boolean isNumberObjectType() {\n     return false;",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}