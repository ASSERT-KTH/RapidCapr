{
    "patch": "import org.apache.commons.math3.analysis.MultivariateFunction;\nimport org.apache.commons.math3.analysis.SimpleBounds;\nimport org.apache.commons.math3.optim.InitialGuess;\nimport org.apache.commons.math3.optim.MaxEval;\nimport org.apache.commons.math3.optim.PointValuePair;\nimport org.apache.commons.math3.optim.SimpleBounds;\nimport org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\nimport org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.LifecycleListener;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.RetryBehavior;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.TerminationException;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerUtils;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexSolver;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexTableau;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SingleObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.PointValuePairComparator;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.Simplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexTableau;\nimport org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\nimport org.apache.commons.math3.optim.univariate.UnivariateOptimizer;\nimport org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\nimport org.apache.commons.math3.optim.univariate.search.BracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.ExpandableBracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.GoldenSectionBracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.SearchInterval;\nimport org.apache.commons.math3.optim.univariate.search.UnivariateSearch;\nimport org.apache.commons.math3.optim.univariate.search.UnivariateSearch.Direction;\nimport org.apache.commons.math3.util.FastMath;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class NelderMead implements MultivariateOptimizer {\n\n    private static final int DEFAULT_MAX_ITERATIONS = 200;\n    private static final double DEFAULT_ABSOLUTE_TOLERANCE = 1e-6;\n    private static final double DEFAULT_RELATIVE_TOLERANCE = 1e-6;\n    private static final double DEFAULT_SIMPLE_MAX = 1.0;\n    private static final double DEFAULT_SIMPLE_MIN = 0.5;\n\n    private final double rho;\n    private final double khi;\n    private final double gamma;\n    private final double sigma;\n    private final LifecycleListener lifecycleListener;\n\n    private int iterations;\n    private int maxIterations;\n    private double absoluteThreshold;\n    private double relativeThreshold;\n\n    public NelderMead() {\n        this(1.0, 2.0, 0.5, 0.5, DEFAULT_MAX_ITERATIONS, DEFAULT_ABSOLUTE_TOLERANCE, DEFAULT_RELATIVE_TOLERANCE);\n    }\n\n    public NelderMead(final double rho, final double khi, final double gamma, final double sigma,\n                      final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n        this.rho = rho;\n        this.khi = khi;\n        this.gamma = gamma;\n        this.sigma = sigma;\n        this.lifecycleListener = null;\n        setMaxIterations(maxIterations);\n        setAbsoluteThreshold(absoluteThreshold);\n        setRelativeThreshold(relativeThreshold);\n    }\n\n    /**\n     * Gets the reflection coefficient.\n     *\n     * @return the reflection coefficient.\n     */\n    public double getRho() {\n        return rho;\n    }\n\n    /**\n     * Gets the expansion coefficient.\n     *\n     * @return the expansion coefficient.\n     */\n    public double getKhi() {\n        return khi;\n    }\n\n    /**\n     * Gets the contraction coefficient.\n     *\n     * @return the contraction coefficient.\n     */\n    public double getGamma() {\n        return gamma;\n    }\n\n    /**\n     * Gets the shrinkage coefficient.\n     *\n     * @return the shrinkage coefficient.\n     */\n    public double getSigma() {\n        return sigma;\n    }\n\n    /**\n     * Sets the maximum number of iterations (maximum number of times the simplex is\n     * reflected, expanded, contracted and shrunk). The default value is 200.\n     *\n     * @param maxIterations Maximum number of iterations.\n     */\n    public void setMaxIterations(final int maxIterations) {\n        if (maxIterations <= 0) {\n            throw new IllegalArgumentException(\"maxIterations must be positive\");\n        }\n        this.maxIterations = maxIterations;\n    }\n\n    /**\n     * Sets the absolute tolerance used to stop the algorithm if the simplex\n     * \"size\" (represented by the max of the consecutive pairwise distances)\n     * is below this tolerance. The default value is 1e-6.\n     *\n     * @param absoluteThreshold Absolute convergence threshold.\n     */\n    public void setAbsoluteThreshold(final double absoluteThreshold) {\n        if (absoluteThreshold <= 0) {\n            throw new IllegalArgumentException(\"absoluteThreshold must be positive\");\n        }\n        this.absoluteThreshold = absoluteThreshold;\n    }\n\n    /**\n     * Sets the relative tolerance used to stop the algorithm if the simplex\n     * \"size\" (represented by the max of the consecutive pairwise distances)\n     * is below this tolerance. The default value is 1e-6.\n     *\n     * @param relativeThreshold Relative convergence threshold.\n     */\n    public void setRelativeThreshold(final double relativeThreshold) {\n        if (relativeThreshold <= 0) {\n            throw new IllegalArgumentException(\"relativeThreshold must be positive\");\n        }\n        this.relativeThreshold = relativeThreshold;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public PointValuePair optimize(final MaxEval maxEval, final MultivariateFunction f,\n                                    final GoalType goalType, final SimpleBounds bounds, final InitialGuess startPoint) {\n\n        // Instantiate the simplex\n        final int dim = startPoint.getInitialGuess().length;\n        final Simplex simplex = new NelderMeadSimplex(dim, DEFAULT_SIMPLE_MAX, DEFAULT_SIMPLE_MIN);\n\n        // Instantiate the ObjectiveFunction\n        final SingleObjectiveFunction objectiveFunction = new SingleObjectiveFunction(f);\n\n        // Instantiate the SimplexOptimizer\n        final SimplexOptimizer optimizer = new SimplexOptimizer(getAbsoluteThreshold(),\n                getRelativeThreshold());\n\n        // Register the lifecycle listener, if set\n        if (lifecycleListener != null) {\n            optimizer.registerLifecycleListener(lifecycleListener);\n        }\n\n        // Set the retry strategy to EXPAND_RETAIN if the algorithm lives\n        // prematurely.\n        optimizer.setRetryBehavior(RetryBehavior.EXPAND_RETAIN);\n\n        // Set the maximal number of iterations\n        optimizer.setMaxIterations(getMaxIterations());\n\n        // Optimize\n        PointValuePair optimum;\n        try {\n            optimum = optimizer.optimize(objectiveFunction, goalType, bounds, startPoint, simplex);\n        } catch (SimplexOptimizer.TooManyIterationsException e) {\n            throw new OptimizationException(e);\n        }\n\n        return optimum;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getMaxEvaluations() {\n        return Integer.MAX_VALUE;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getEvaluations() {\n        return 0;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public int getIterations() {\n        return iterations;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getAbsoluteThreshold() {\n        return absoluteThreshold;\n    }\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    public double getRelativeThreshold() {\n        return relativeThreshold;\n    }\n\n    /**\n     * Returns a new instance of the {@link NelderMead} optimizer with the same configuration.\n     *\n     * @return a new instance of the optimizer.\n     */\n    public NelderMead newInstance() {\n        return new NelderMead(rho, khi, gamma, sigma, maxIterations, absoluteThreshold, relativeThreshold);\n    }\n\n    /**\n     * Returns a new instance of the {@link NelderMead} optimizer with different configuration.\n     *\n     * @param maxIterations Maximum number of iterations.\n     * @param absoluteThreshold Absolute convergence threshold.\n     * @param relativeThreshold Relative convergence threshold.\n     * @return a new instance of the optimizer.\n     */\n    public NelderMead newInstance(final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n        return new NelderMead(rho, khi, gamma, sigma, maxIterations, absoluteThreshold, relativeThreshold);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..0ecb0ed05 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,46 +58,265 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+import org.apache.commons.math3.analysis.MultivariateFunction;\n+import org.apache.commons.math3.analysis.SimpleBounds;\n+import org.apache.commons.math3.optim.InitialGuess;\n+import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.PointValuePair;\n+import org.apache.commons.math3.optim.SimpleBounds;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n+import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.LifecycleListener;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.RetryBehavior;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.TerminationException;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerUtils;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexSolver;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexTableau;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SingleObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.PointValuePairComparator;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.Simplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexTableau;\n+import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\n+import org.apache.commons.math3.optim.univariate.UnivariateOptimizer;\n+import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\n+import org.apache.commons.math3.optim.univariate.search.BracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.ExpandableBracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.GoldenSectionBracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.SearchInterval;\n+import org.apache.commons.math3.optim.univariate.search.UnivariateSearch;\n+import org.apache.commons.math3.optim.univariate.search.UnivariateSearch.Direction;\n+import org.apache.commons.math3.util.FastMath;\n \n-        while (true) {\n+import java.util.Arrays;\n+import java.util.Comparator;\n \n-            incrementIterationsCounter();\n+public class NelderMead implements MultivariateOptimizer {\n \n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n+    private static final int DEFAULT_MAX_ITERATIONS = 200;\n+    private static final double DEFAULT_ABSOLUTE_TOLERANCE = 1e-6;\n+    private static final double DEFAULT_RELATIVE_TOLERANCE = 1e-6;\n+    private static final double DEFAULT_SIMPLE_MAX = 1.0;\n+    private static final double DEFAULT_SIMPLE_MIN = 0.5;\n \n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n+    private final double rho;\n+    private final double khi;\n+    private final double gamma;\n+    private final double sigma;\n+    private final LifecycleListener lifecycleListener;\n \n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n+    private int iterations;\n+    private int maxIterations;\n+    private double absoluteThreshold;\n+    private double relativeThreshold;\n \n-                return;\n+    public NelderMead() {\n+        this(1.0, 2.0, 0.5, 0.5, DEFAULT_MAX_ITERATIONS, DEFAULT_ABSOLUTE_TOLERANCE, DEFAULT_RELATIVE_TOLERANCE);\n+    }\n \n-            }\n+    public NelderMead(final double rho, final double khi, final double gamma, final double sigma,\n+                      final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n+        this.rho = rho;\n+        this.khi = khi;\n+        this.gamma = gamma;\n+        this.sigma = sigma;\n+        this.lifecycleListener = null;\n+        setMaxIterations(maxIterations);\n+        setAbsoluteThreshold(absoluteThreshold);\n+        setRelativeThreshold(relativeThreshold);\n+    }\n+\n+    /**\n+     * Gets the reflection coefficient.\n+     *\n+     * @return the reflection coefficient.\n+     */\n+    public double getRho() {\n+        return rho;\n+    }\n \n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n+    /**\n+     * Gets the expansion coefficient.\n+     *\n+     * @return the expansion coefficient.\n+     */\n+    public double getKhi() {\n+        return khi;\n+    }\n \n-            // check convergence\n-                return;\n-            }\n+    /**\n+     * Gets the contraction coefficient.\n+     *\n+     * @return the contraction coefficient.\n+     */\n+    public double getGamma() {\n+        return gamma;\n+    }\n+\n+    /**\n+     * Gets the shrinkage coefficient.\n+     *\n+     * @return the shrinkage coefficient.\n+     */\n+    public double getSigma() {\n+        return sigma;\n+    }\n \n+    /**\n+     * Sets the maximum number of iterations (maximum number of times the simplex is\n+     * reflected, expanded, contracted and shrunk). The default value is 200.\n+     *\n+     * @param maxIterations Maximum number of iterations.\n+     */\n+    public void setMaxIterations(final int maxIterations) {\n+        if (maxIterations <= 0) {\n+            throw new IllegalArgumentException(\"maxIterations must be positive\");\n         }\n+        this.maxIterations = maxIterations;\n+    }\n \n+    /**\n+     * Sets the absolute tolerance used to stop the algorithm if the simplex\n+     * \"size\" (represented by the max of the consecutive pairwise distances)\n+     * is below this tolerance. The default value is 1e-6.\n+     *\n+     * @param absoluteThreshold Absolute convergence threshold.\n+     */\n+    public void setAbsoluteThreshold(final double absoluteThreshold) {\n+        if (absoluteThreshold <= 0) {\n+            throw new IllegalArgumentException(\"absoluteThreshold must be positive\");\n+        }\n+        this.absoluteThreshold = absoluteThreshold;\n     }\n \n+    /**\n+     * Sets the relative tolerance used to stop the algorithm if the simplex\n+     * \"size\" (represented by the max of the consecutive pairwise distances)\n+     * is below this tolerance. The default value is 1e-6.\n+     *\n+     * @param relativeThreshold Relative convergence threshold.\n+     */\n+    public void setRelativeThreshold(final double relativeThreshold) {\n+        if (relativeThreshold <= 0) {\n+            throw new IllegalArgumentException(\"relativeThreshold must be positive\");\n+        }\n+        this.relativeThreshold = relativeThreshold;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public PointValuePair optimize(final MaxEval maxEval, final MultivariateFunction f,\n+                                    final GoalType goalType, final SimpleBounds bounds, final InitialGuess startPoint) {\n+\n+        // Instantiate the simplex\n+        final int dim = startPoint.getInitialGuess().length;\n+        final Simplex simplex = new NelderMeadSimplex(dim, DEFAULT_SIMPLE_MAX, DEFAULT_SIMPLE_MIN);\n+\n+        // Instantiate the ObjectiveFunction\n+        final SingleObjectiveFunction objectiveFunction = new SingleObjectiveFunction(f);\n+\n+        // Instantiate the SimplexOptimizer\n+        final SimplexOptimizer optimizer = new SimplexOptimizer(getAbsoluteThreshold(),\n+                getRelativeThreshold());\n+\n+        // Register the lifecycle listener, if set\n+        if (lifecycleListener != null) {\n+            optimizer.registerLifecycleListener(lifecycleListener);\n+        }\n+\n+        // Set the retry strategy to EXPAND_RETAIN if the algorithm lives\n+        // prematurely.\n+        optimizer.setRetryBehavior(RetryBehavior.EXPAND_RETAIN);\n+\n+        // Set the maximal number of iterations\n+        optimizer.setMaxIterations(getMaxIterations());\n+\n+        // Optimize\n+        PointValuePair optimum;\n+        try {\n+            optimum = optimizer.optimize(objectiveFunction, goalType, bounds, startPoint, simplex);\n+        } catch (SimplexOptimizer.TooManyIterationsException e) {\n+            throw new OptimizationException(e);\n+        }\n+\n+        return optimum;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int getMaxEvaluations() {\n+        return Integer.MAX_VALUE;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int getEvaluations() {\n+        return 0;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public int getIterations() {\n+        return iterations;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getAbsoluteThreshold() {\n+        return absoluteThreshold;\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    public double getRelativeThreshold() {\n+        return relativeThreshold;\n+    }\n+\n+    /**\n+     * Returns a new instance of the {@link NelderMead} optimizer with the same configuration.\n+     *\n+     * @return a new instance of the optimizer.\n+     */\n+    public NelderMead newInstance() {\n+        return new NelderMead(rho, khi, gamma, sigma, maxIterations, absoluteThreshold, relativeThreshold);\n+    }\n+\n+    /**\n+     * Returns a new instance of the {@link NelderMead} optimizer with different configuration.\n+     *\n+     * @param maxIterations Maximum number of iterations.\n+     * @param absoluteThreshold Absolute convergence threshold.\n+     * @param relativeThreshold Relative convergence threshold.\n+     * @return a new instance of the optimizer.\n+     */\n+    public NelderMead newInstance(final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n+        return new NelderMead(rho, khi, gamma, sigma, maxIterations, absoluteThreshold, relativeThreshold);\n+    }\n+}\n+\n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)\n      * @param coeff linear coefficient",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}