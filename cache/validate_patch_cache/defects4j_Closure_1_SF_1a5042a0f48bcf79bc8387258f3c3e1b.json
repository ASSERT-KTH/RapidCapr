{
    "patch": "I apologize for the confusion. Here is the complete and correct class that should fix the issue:\n\n```\nimport com.google.common.base.Preconditions;\nimport com.google.common.collect.ImmutableMap;\nimport com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.AbstractPeepholeOptimization;\nimport com.google.javascript.jscomp.CodeChangeHandler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.ControlFlowAnalysis;\nimport com.google.javascript.jscomp.ControlFlowGraph;\nimport com.google.javascript.jscomp.DiagnosticType;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.Scope;\nimport com.google.javascript.jscomp.Scope.Var;\nimport com.google.javascript.jscomp.TypedScope;\nimport com.google.javascript.jscomp.VarCheck;\nimport com.google.javascript.jscomp.graph.Annotation;\nimport com.google.javascript.jscomp.graph.LinkedDirectedGraph;\nimport com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDiGraphNode;\nimport com.google.javascript.jscomp.parsing.parser.util.format.SimpleFormat;\nimport com.google.javascript.rhino.Node;\n\nimport java.util.ArrayDeque;\nimport java.util.BitSet;\nimport java.util.Deque;\nimport java.util.LinkedHashSet;\nimport java.util.Map;\nimport java.util.logging.Logger;\n\n/**\n * PeepholeOptimization that removes unused variables,\n * variables that are only assigned once, and in some cases,\n * variables that are only referenced once.\n */\nclass RemoveUnusedVars extends AbstractPeepholeOptimization implements CodeChangeHandler {\n\n  private static final Logger logger =\n      Logger.getLogger(RemoveUnusedVars.class.getName());\n\n  // Transient data used by this peephole optimizer.\n  private Deque<Scope> scopeStack;\n  private LinkedHashSet<Var> referencedVars;\n  private VariableMap variableMap;\n\n  private final boolean removeUnusedLocalVars;\n  private final boolean removeUnusedVars;\n  private final boolean removeUnusedPrototypeProperties;\n  private final boolean removeUnusedThisProperties;\n  private final boolean preserveFunctionExpressionNames;\n  private final boolean optimizeCalls;\n\n  // For testing\n  private final boolean removeGlobals;\n\n  /**\n   * @param removeUnusedLocalVars Whether to remove unused function parameters and variables.\n   * @param removeUnusedVars Whether to remove unused vars outside of a LOCALIZED_ASSIGNMENT block.\n   * @param removeUnusedPrototypeProperties Whether to remove prototype properties.\n   * @param removeUnusedThisProperties Whether to remove this properties.\n   * @param preserveFunctionExpressionNames Whether to preserve function expression names.\n   * @param optimizeCalls Whether to remove functions that only called once.\n   * @param removeGlobals Whether to remove all global variables.\n   */\n  RemoveUnusedVars(\n      boolean removeUnusedLocalVars,\n      boolean removeUnusedVars,\n      boolean removeUnusedPrototypeProperties,\n      boolean removeUnusedThisProperties,\n      boolean preserveFunctionExpressionNames,\n      boolean optimizeCalls,\n      boolean removeGlobals) {\n    this.removeUnusedLocalVars = removeUnusedLocalVars;\n    this.removeUnusedVars = removeUnusedVars;\n    this.removeUnusedPrototypeProperties = removeUnusedPrototypeProperties;\n    this.removeUnusedThisProperties = removeUnusedThisProperties;\n    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n    this.optimizeCalls = optimizeCalls;\n    this.removeGlobals = removeGlobals;\n  }\n\n  private boolean isInLocalAssignmentBlock(Node n) {\n    return n.getParent() != null\n        && n.getParent().getParent() != null\n        && NodeUtil.isNonArrowFunctionBlock(n.getParent())\n        && BlockTraversal.isNormalizedLocalBlock(n.getParent().getParent());\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getToken()) {\n      case SCRIPT:\n        if (!isFirstPass()) {\n          Node script = n;\n          Scope topScope = t.getScope();\n          scopeStack.push(topScope);\n\n          if (removeUnusedLocalVars) {\n            pullOutFunctionDeclarations(topScope, parent, script);\n            removeUnreferencedLocalVarsInFunctionDeclarations();\n          }\n          if (removeUnusedVars) {\n            pullOutAssignments(topScope, parent, script);\n            removeUnreferencedVarsAndFunctions();\n          }\n          if (removeUnusedPrototypeProperties) {\n            removeUnreferencedPrototypeProperties();\n          }\n          if (removeUnusedThisProperties) {\n            removeUnreferencedThisProperties();\n          }\n          if (optimizeCalls) {\n            optimizeCalls(topScope, variableMap.map);\n          }\n          if (removeGlobals) {\n            removeUnreferencedGlobalVars(topScope);\n          }\n\n          // Remove the cached state for this scope.\n          scopeStack.pop();\n          referencedVars = null;\n          variableMap = null;\n        }\n        break;\n\n      case FUNCTION:\n        // Before recursing into a function, process assignments up to this point.\n        if (optimizeCalls) {\n          optimizeCalls(t.getScope(), variableMap.map);\n        }\n        if (removeUnusedVars && scopeStack.size() > 0 && scopeStack.peek() == t.getScope()) {\n          pullOutAssignments(t.getScope(), parent, n);\n          removeUnreferencedVarsAndFunctions();\n        }\n\n        // Visit the function.\n        if (t.getTypedScope() != null) {\n          scopeStack.push(t.getScope());\n          referencedVars = new LinkedHashSet<>();\n          variableMap = new VariableMap();\n          variableMap.useInstanceProperties = true;\n\n          innerLoop: for (Map.Entry<String, Var> entry : t.getTypedScope().getAllSymbols().entrySet()) {\n            Var v = entry.getValue();\n\n            // Constructors are always used, because they are saved\n            // as a reference to the class.\n            if (v.isConstructor()) {\n              continue innerLoop;\n            }\n\n            // Goog.scope variables will always exist on the top-level window object.\n            if (v.isGoogScope()) {\n              continue innerLoop;\n            }\n\n            // Ignore parameters with unique names.\n            if (isFunctionWithUniqueParamName(t.getScope().getParent(), v)) {\n              continue innerLoop;\n            }\n\n            if (variableMap.map.get(v) == null) {\n              variableMap.map.put(v.getName(), v);\n            }\n            // variables that are still unused can be removed\n          }\n        }\n        break;\n    }\n  }\n\n  private static boolean isFunctionWithUniqueParamName(Scope parent, Var var) {\n    if (parent == null) {\n      return false;\n    }\n    if (var.getParentNode().getParent().isCatch()) {\n      return false;\n    }\n    // ES6 classes may have a constructor with duplicate arguments.\n    // However, variables are **always** used in such class constructors.\n    if (NodeUtil.isEs6ConstructorMemberFunctionDef(var.getParentNode().getParent())) {\n      return false;\n    }\n    return parent.hasSameNameAsParam(var);\n  }\n\n  private static boolean isFunctionWithRestArgs(Node function) {\n    Node lastParam = function.getLastChild();\n\n    // Check whether the last parameter is a rest parameter.\n    if (lastParam.isRest()) {\n      return true;\n    }\n    return false;\n  }\n\n  private static boolean isReferenced(Var var, LinkedHashSet<Var> referencedVars) {\n    return var.isArguments()\n        || var.isCatch()\n        || referencedVars.contains(var);\n  }\n\n  private static boolean isVarInLoop(Scope scope, Node n) {\n    Var var = scope.getVar(n.getString());\n    for (Scope s = var.getScope().getParent(); s != null; s = s.getParent()) {\n      ControlFlowGraph<?> cfg = s.getControlFlowAnalysis().getCfg();\n      LinkedDirectedGraph<ControlFlowGraph.Branch> g = cfg.getGraph();\n      LinkedDiGraphNode<? extends ControlFlowGraph.Branch> node = cfg.getEntry();\n      for (int i = 0; i < g.getNumberOfNodes(); ++i) {\n        if (isVarInLoop(n, node, new BitSet(g.getNumberOfNodes()))) {\n          return true;\n        }\n        node = node.getFirstChild();\n      }\n    }\n    return false;\n  }\n\n  private static boolean isVarInLoop(\n      Node n, LinkedDiGraphNode<? extends ControlFlowGraph.Branch> node, BitSet visited) {\n    if (visited.get(node.getId())) {\n      return false;\n    }\n    visited.set(node.getId());\n    ControlFlowGraph.Branch label = node.getValue();\n    switch (label.getType()) {\n      case ROOT:\n      case BLOCK:\n        return false;\n      case IF:\n      case SWITCH:\n        for (int i = 0; i < node.getOutEdges().size(); ++i) {\n          LinkedDiGraphNode<? extends ControlFlowGraph.Branch> child = node.getOutEdges().get(i);\n          if (isVarInLoop(n, child, visited)) {\n            return true;\n          }\n        }\n        break;\n      case DO:\n      case WHILE:\n      case FOR:\n        Node root = label.getRoot();\n        Node inner = root.getLastChild();\n        if (inner.isLabel()) {\n          inner = inner.getLastChild();\n        }\n        Node varNode = inner.getFirstChild();\n        if (varNode.isVar() && n.getString().equals(varNode.getFirstChild().getString())) {\n          return true;\n        }\n        break;\n      default:\n        logger.fine(\"Unknown label type: \" + label.getType());\n        break;\n    }\n    return false;\n  }\n\n  private void pullOutAssignments(Scope topScope, Node parent, Node script) {\n    // If a pass only optimizes function level code, then\n    // assignments to variables outside of functions are unsafe to pull out.\n    if (compiler.getLifeCycleStage().isNormalized()) {\n      // Don't crawl inside functions yet, it might be unsafe.\n      return;\n    }\n\n    if (parent == null) {\n      parent = script;\n    }\n\n    if (NodeUtil.mayHaveSideEffects(parent)) {\n      return;\n    }\n\n    scopeStack.push(topScope);\n\n    controlFlowAnalysis = new ControlFlowAnalysis(compiler, false, true);\n    controlFlowAnalysis.process(null, script);\n    VariableReferenceGraph referenceGraph =\n        VariableReferenceGraphBuilder.build(topScope, variableMap, controlFlowAnalysis.getCfg());\n\n    TreeAnalyzer treeAnalyzer = new TreeAnalyzer(topScope, referenceGraph);\n\n    for (BranchedFlowState branch : treeAnalyzer.getAllBranches()) {\n      Node block = branch.getNormalizedNode();\n\n      // We can only extract statements from a basic block.\n      // Extracting expressions could cause problems, because expressions\n      // are often order-dependent. For example, a function call often needs\n      // to be done before a variable is set up.\n      if (!NodeUtil.isStatementsBlock(block)) {\n        continue;\n      }\n\n      for (Node n = block.getFirstChild(), next; n != null; n = next) {\n        next = n.getNext();\n\n        if (!n.isExprResult()) {\n          continue;\n        }\n\n        Node expr = n.getFirstChild();\n\n        // Prevent removal of CALL expressions in stubs.\n        if (NodeUtil.isCallOrNew(expr)) {\n          continue;\n        }\n\n        if (expr.isAssign() && !isInLocalAssignmentBlock(expr.getFirstChild())) {\n          Node value = expr.getLastChild();\n          Node lhs = expr.getFirstChild();\n          if (lhs.getFirstChild().isThis()) {\n            continue;\n          }\n          Var var = controlFlowAnalysis.getSlotDefiningValue(lhs);\n          if ((lhs.getFirstChild().isObjectPattern() || lhs.getFirstChild().isArrayPattern())\n              && value.hasChildren()) {\n            // When there are properties spread out on right side, it's not safe\n            // to pull left side into the global scope, because order might be\n            // important in them.\n            continue;\n          }\n          if (var == null || var.isModuleExport() || !variableMap.map.containsKey(var.getName())) {\n            continue;\n          }\n          if (var.getParentScope().isBlockScope()) {\n            // Local variable properties are tricky and don't need the\n            // transitive optimization.\n            continue;\n          }\n          referencedVars = referenceGraph.getTransitiveClosure(var);\n          // MOVE HERE...\n          boolean safeToRemove =\n              canRemoveVar(\n                  var,\n                  var.isArguments()\n                      || preserveFunctionExpressionNames\n                      || !var.getParentNode().getParent().isArrowFunction());\n          if (safeToRemove && !isReferenced(var, referencedVars)) {\n            if (!modifyCallSites) {\n              NodeUtil.removeChild(parent, n);\n              compiler.reportCodeChange();\n            } else {\n              // Gather all CALL and NEW expressions that reference this var.\n              LinkedHashSet<Node> nodes = referenceGraph.getNodesReferencing(var);\n              ArrayDeque<Node> usages = new ArrayDeque<>(nodes);\n              while (!usages.isEmpty()) {\n                ControlFlowGraph.Branch branchOfUsage =\n                    NodeUtil.getEnclosingBranch(usages.removeLast());\n                if (branchOfUsage != null) {\n                  // SPECIAL CASE: disallow removal of functions used as properties in object literals in other\n                  // fields of the same object literal, as that could change evaluation order.\n                  //   e.g. {a: foo(), b: bar()} ==> {b: bar()} foo()\n                  if (expr.getParent().isGetProp()) {\n                    Node grandParent = expr.getParent().getParent();\n                    if (grandParent.isObjectLit()) {\n                      for (Node objProp = grandParent.getFirstChild(); objProp != null; objProp = objProp.getNext()) {\n                        if (objProp != expr.getParent()\n                            && objProp.getFirstChild().isString()\n                            && !objProp.getFirstChild().getString().equals(\"constructor\")) {\n                          Node val = objProp.getLastChild();\n                          if (val != null && val.isFunction()) {\n                            // We should not remove this element, because\n                            // its presence may cause mutation of the object\n                            // before the function call.\n                            safeToRemove = false;\n                            break;\n                          }\n                        }\n                      }\n                    }\n                  }\n                  if (safeToRemove) {\n                    ControlFlowGraph graph = controlFlowAnalysis.getCfg();\n                    Node branchNode = branchOfUsage.getRoot();\n                    LinkedDiGraphNode<Integer> node =\n                        graph.getNode(nodeCounter.get(branchNode) + expr.getLineno());\n                    if (graph.getDirectedPredicates().getSideEffectFreePredicate().apply(node)) {\n                      NodeUtil.removeChild(parent, branchNode);\n                      NodeUtil.markFunctionsDeleted(branchNode, compiler);\n                      NodeUtil.markNewScopesDeleted(branchNode, compiler);\n                      compiler.reportCodeChange();\n                    } else {\n                      // We can't delete this branch yet. Remove usages and we will\n                      // try again in the next pass.  Or, a non-global variable needs to be propagated.\n                      // We can't propagate variables during the analysis phase.\n                      // Put all local variables on a propagate queue to be handled\n                      // after analysis\n                      propagateQueue.add(var.getName());\n                    }\n                  }\n                }\n              }\n            }\n          }\n        }\n      }\n    }\n  }\n\n  private void removeUnreferencedLocalVarsInFunctionDeclarations() {\n    for (Scope scope : scopeStack) {\n      Node root = scope.getRootNode();\n      if (root == null || !root.isFunction()) {\n        continue;\n      }\n\n      Preconditions.checkState(root.isFunction());\n      Node fnNode = root;\n      Node paramList = fnNode.getFirstChild().getNext",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..95e064b4 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -366,45 +366,417 @@ class RemoveUnusedVars\n    *\n    * @param fnScope The scope inside the function\n    */\n-  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n-\n-    Node function = fnScope.getRootNode();\n-\n-    Preconditions.checkState(function.isFunction());\n-    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n-      // The parameters object literal setters can not be removed.\n+I apologize for the confusion. Here is the complete and correct class that should fix the issue:\n+\n+```\n+import com.google.common.base.Preconditions;\n+import com.google.common.collect.ImmutableMap;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.AbstractPeepholeOptimization;\n+import com.google.javascript.jscomp.CodeChangeHandler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.ControlFlowAnalysis;\n+import com.google.javascript.jscomp.ControlFlowGraph;\n+import com.google.javascript.jscomp.DiagnosticType;\n+import com.google.javascript.jscomp.NodeUtil;\n+import com.google.javascript.jscomp.Scope;\n+import com.google.javascript.jscomp.Scope.Var;\n+import com.google.javascript.jscomp.TypedScope;\n+import com.google.javascript.jscomp.VarCheck;\n+import com.google.javascript.jscomp.graph.Annotation;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph;\n+import com.google.javascript.jscomp.graph.LinkedDirectedGraph.LinkedDiGraphNode;\n+import com.google.javascript.jscomp.parsing.parser.util.format.SimpleFormat;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.ArrayDeque;\n+import java.util.BitSet;\n+import java.util.Deque;\n+import java.util.LinkedHashSet;\n+import java.util.Map;\n+import java.util.logging.Logger;\n+\n+/**\n+ * PeepholeOptimization that removes unused variables,\n+ * variables that are only assigned once, and in some cases,\n+ * variables that are only referenced once.\n+ */\n+class RemoveUnusedVars extends AbstractPeepholeOptimization implements CodeChangeHandler {\n+\n+  private static final Logger logger =\n+      Logger.getLogger(RemoveUnusedVars.class.getName());\n+\n+  // Transient data used by this peephole optimizer.\n+  private Deque<Scope> scopeStack;\n+  private LinkedHashSet<Var> referencedVars;\n+  private VariableMap variableMap;\n+\n+  private final boolean removeUnusedLocalVars;\n+  private final boolean removeUnusedVars;\n+  private final boolean removeUnusedPrototypeProperties;\n+  private final boolean removeUnusedThisProperties;\n+  private final boolean preserveFunctionExpressionNames;\n+  private final boolean optimizeCalls;\n+\n+  // For testing\n+  private final boolean removeGlobals;\n+\n+  /**\n+   * @param removeUnusedLocalVars Whether to remove unused function parameters and variables.\n+   * @param removeUnusedVars Whether to remove unused vars outside of a LOCALIZED_ASSIGNMENT block.\n+   * @param removeUnusedPrototypeProperties Whether to remove prototype properties.\n+   * @param removeUnusedThisProperties Whether to remove this properties.\n+   * @param preserveFunctionExpressionNames Whether to preserve function expression names.\n+   * @param optimizeCalls Whether to remove functions that only called once.\n+   * @param removeGlobals Whether to remove all global variables.\n+   */\n+  RemoveUnusedVars(\n+      boolean removeUnusedLocalVars,\n+      boolean removeUnusedVars,\n+      boolean removeUnusedPrototypeProperties,\n+      boolean removeUnusedThisProperties,\n+      boolean preserveFunctionExpressionNames,\n+      boolean optimizeCalls,\n+      boolean removeGlobals) {\n+    this.removeUnusedLocalVars = removeUnusedLocalVars;\n+    this.removeUnusedVars = removeUnusedVars;\n+    this.removeUnusedPrototypeProperties = removeUnusedPrototypeProperties;\n+    this.removeUnusedThisProperties = removeUnusedThisProperties;\n+    this.preserveFunctionExpressionNames = preserveFunctionExpressionNames;\n+    this.optimizeCalls = optimizeCalls;\n+    this.removeGlobals = removeGlobals;\n+  }\n+\n+  private boolean isInLocalAssignmentBlock(Node n) {\n+    return n.getParent() != null\n+        && n.getParent().getParent() != null\n+        && NodeUtil.isNonArrowFunctionBlock(n.getParent())\n+        && BlockTraversal.isNormalizedLocalBlock(n.getParent().getParent());\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    switch (n.getToken()) {\n+      case SCRIPT:\n+        if (!isFirstPass()) {\n+          Node script = n;\n+          Scope topScope = t.getScope();\n+          scopeStack.push(topScope);\n+\n+          if (removeUnusedLocalVars) {\n+            pullOutFunctionDeclarations(topScope, parent, script);\n+            removeUnreferencedLocalVarsInFunctionDeclarations();\n+          }\n+          if (removeUnusedVars) {\n+            pullOutAssignments(topScope, parent, script);\n+            removeUnreferencedVarsAndFunctions();\n+          }\n+          if (removeUnusedPrototypeProperties) {\n+            removeUnreferencedPrototypeProperties();\n+          }\n+          if (removeUnusedThisProperties) {\n+            removeUnreferencedThisProperties();\n+          }\n+          if (optimizeCalls) {\n+            optimizeCalls(topScope, variableMap.map);\n+          }\n+          if (removeGlobals) {\n+            removeUnreferencedGlobalVars(topScope);\n+          }\n+\n+          // Remove the cached state for this scope.\n+          scopeStack.pop();\n+          referencedVars = null;\n+          variableMap = null;\n+        }\n+        break;\n+\n+      case FUNCTION:\n+        // Before recursing into a function, process assignments up to this point.\n+        if (optimizeCalls) {\n+          optimizeCalls(t.getScope(), variableMap.map);\n+        }\n+        if (removeUnusedVars && scopeStack.size() > 0 && scopeStack.peek() == t.getScope()) {\n+          pullOutAssignments(t.getScope(), parent, n);\n+          removeUnreferencedVarsAndFunctions();\n+        }\n+\n+        // Visit the function.\n+        if (t.getTypedScope() != null) {\n+          scopeStack.push(t.getScope());\n+          referencedVars = new LinkedHashSet<>();\n+          variableMap = new VariableMap();\n+          variableMap.useInstanceProperties = true;\n+\n+          innerLoop: for (Map.Entry<String, Var> entry : t.getTypedScope().getAllSymbols().entrySet()) {\n+            Var v = entry.getValue();\n+\n+            // Constructors are always used, because they are saved\n+            // as a reference to the class.\n+            if (v.isConstructor()) {\n+              continue innerLoop;\n+            }\n+\n+            // Goog.scope variables will always exist on the top-level window object.\n+            if (v.isGoogScope()) {\n+              continue innerLoop;\n+            }\n+\n+            // Ignore parameters with unique names.\n+            if (isFunctionWithUniqueParamName(t.getScope().getParent(), v)) {\n+              continue innerLoop;\n+            }\n+\n+            if (variableMap.map.get(v) == null) {\n+              variableMap.map.put(v.getName(), v);\n+            }\n+            // variables that are still unused can be removed\n+          }\n+        }\n+        break;\n+    }\n+  }\n+\n+  private static boolean isFunctionWithUniqueParamName(Scope parent, Var var) {\n+    if (parent == null) {\n+      return false;\n+    }\n+    if (var.getParentNode().getParent().isCatch()) {\n+      return false;\n+    }\n+    // ES6 classes may have a constructor with duplicate arguments.\n+    // However, variables are **always** used in such class constructors.\n+    if (NodeUtil.isEs6ConstructorMemberFunctionDef(var.getParentNode().getParent())) {\n+      return false;\n+    }\n+    return parent.hasSameNameAsParam(var);\n+  }\n+\n+  private static boolean isFunctionWithRestArgs(Node function) {\n+    Node lastParam = function.getLastChild();\n+\n+    // Check whether the last parameter is a rest parameter.\n+    if (lastParam.isRest()) {\n+      return true;\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isReferenced(Var var, LinkedHashSet<Var> referencedVars) {\n+    return var.isArguments()\n+        || var.isCatch()\n+        || referencedVars.contains(var);\n+  }\n+\n+  private static boolean isVarInLoop(Scope scope, Node n) {\n+    Var var = scope.getVar(n.getString());\n+    for (Scope s = var.getScope().getParent(); s != null; s = s.getParent()) {\n+      ControlFlowGraph<?> cfg = s.getControlFlowAnalysis().getCfg();\n+      LinkedDirectedGraph<ControlFlowGraph.Branch> g = cfg.getGraph();\n+      LinkedDiGraphNode<? extends ControlFlowGraph.Branch> node = cfg.getEntry();\n+      for (int i = 0; i < g.getNumberOfNodes(); ++i) {\n+        if (isVarInLoop(n, node, new BitSet(g.getNumberOfNodes()))) {\n+          return true;\n+        }\n+        node = node.getFirstChild();\n+      }\n+    }\n+    return false;\n+  }\n+\n+  private static boolean isVarInLoop(\n+      Node n, LinkedDiGraphNode<? extends ControlFlowGraph.Branch> node, BitSet visited) {\n+    if (visited.get(node.getId())) {\n+      return false;\n+    }\n+    visited.set(node.getId());\n+    ControlFlowGraph.Branch label = node.getValue();\n+    switch (label.getType()) {\n+      case ROOT:\n+      case BLOCK:\n+        return false;\n+      case IF:\n+      case SWITCH:\n+        for (int i = 0; i < node.getOutEdges().size(); ++i) {\n+          LinkedDiGraphNode<? extends ControlFlowGraph.Branch> child = node.getOutEdges().get(i);\n+          if (isVarInLoop(n, child, visited)) {\n+            return true;\n+          }\n+        }\n+        break;\n+      case DO:\n+      case WHILE:\n+      case FOR:\n+        Node root = label.getRoot();\n+        Node inner = root.getLastChild();\n+        if (inner.isLabel()) {\n+          inner = inner.getLastChild();\n+        }\n+        Node varNode = inner.getFirstChild();\n+        if (varNode.isVar() && n.getString().equals(varNode.getFirstChild().getString())) {\n+          return true;\n+        }\n+        break;\n+      default:\n+        logger.fine(\"Unknown label type: \" + label.getType());\n+        break;\n+    }\n+    return false;\n+  }\n+\n+  private void pullOutAssignments(Scope topScope, Node parent, Node script) {\n+    // If a pass only optimizes function level code, then\n+    // assignments to variables outside of functions are unsafe to pull out.\n+    if (compiler.getLifeCycleStage().isNormalized()) {\n+      // Don't crawl inside functions yet, it might be unsafe.\n       return;\n     }\n \n-    Node argList = getFunctionArgList(function);\n-    boolean modifyCallers = modifyCallSites\n-        && callSiteOptimizer.canModifyCallers(function);\n-    if (!modifyCallers) {\n-      // Strip unreferenced args off the end of the function declaration.\n-      Node lastArg;\n-      while ((lastArg = argList.getLastChild()) != null) {\n-        Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n-          argList.removeChild(lastArg);\n-          compiler.reportCodeChange();\n-        } else {\n-          break;\n+    if (parent == null) {\n+      parent = script;\n+    }\n+\n+    if (NodeUtil.mayHaveSideEffects(parent)) {\n+      return;\n+    }\n+\n+    scopeStack.push(topScope);\n+\n+    controlFlowAnalysis = new ControlFlowAnalysis(compiler, false, true);\n+    controlFlowAnalysis.process(null, script);\n+    VariableReferenceGraph referenceGraph =\n+        VariableReferenceGraphBuilder.build(topScope, variableMap, controlFlowAnalysis.getCfg());\n+\n+    TreeAnalyzer treeAnalyzer = new TreeAnalyzer(topScope, referenceGraph);\n+\n+    for (BranchedFlowState branch : treeAnalyzer.getAllBranches()) {\n+      Node block = branch.getNormalizedNode();\n+\n+      // We can only extract statements from a basic block.\n+      // Extracting expressions could cause problems, because expressions\n+      // are often order-dependent. For example, a function call often needs\n+      // to be done before a variable is set up.\n+      if (!NodeUtil.isStatementsBlock(block)) {\n+        continue;\n+      }\n+\n+      for (Node n = block.getFirstChild(), next; n != null; n = next) {\n+        next = n.getNext();\n+\n+        if (!n.isExprResult()) {\n+          continue;\n+        }\n+\n+        Node expr = n.getFirstChild();\n+\n+        // Prevent removal of CALL expressions in stubs.\n+        if (NodeUtil.isCallOrNew(expr)) {\n+          continue;\n+        }\n+\n+        if (expr.isAssign() && !isInLocalAssignmentBlock(expr.getFirstChild())) {\n+          Node value = expr.getLastChild();\n+          Node lhs = expr.getFirstChild();\n+          if (lhs.getFirstChild().isThis()) {\n+            continue;\n+          }\n+          Var var = controlFlowAnalysis.getSlotDefiningValue(lhs);\n+          if ((lhs.getFirstChild().isObjectPattern() || lhs.getFirstChild().isArrayPattern())\n+              && value.hasChildren()) {\n+            // When there are properties spread out on right side, it's not safe\n+            // to pull left side into the global scope, because order might be\n+            // important in them.\n+            continue;\n+          }\n+          if (var == null || var.isModuleExport() || !variableMap.map.containsKey(var.getName())) {\n+            continue;\n+          }\n+          if (var.getParentScope().isBlockScope()) {\n+            // Local variable properties are tricky and don't need the\n+            // transitive optimization.\n+            continue;\n+          }\n+          referencedVars = referenceGraph.getTransitiveClosure(var);\n+          // MOVE HERE...\n+          boolean safeToRemove =\n+              canRemoveVar(\n+                  var,\n+                  var.isArguments()\n+                      || preserveFunctionExpressionNames\n+                      || !var.getParentNode().getParent().isArrowFunction());\n+          if (safeToRemove && !isReferenced(var, referencedVars)) {\n+            if (!modifyCallSites) {\n+              NodeUtil.removeChild(parent, n);\n+              compiler.reportCodeChange();\n+            } else {\n+              // Gather all CALL and NEW expressions that reference this var.\n+              LinkedHashSet<Node> nodes = referenceGraph.getNodesReferencing(var);\n+              ArrayDeque<Node> usages = new ArrayDeque<>(nodes);\n+              while (!usages.isEmpty()) {\n+                ControlFlowGraph.Branch branchOfUsage =\n+                    NodeUtil.getEnclosingBranch(usages.removeLast());\n+                if (branchOfUsage != null) {\n+                  // SPECIAL CASE: disallow removal of functions used as properties in object literals in other\n+                  // fields of the same object literal, as that could change evaluation order.\n+                  //   e.g. {a: foo(), b: bar()} ==> {b: bar()} foo()\n+                  if (expr.getParent().isGetProp()) {\n+                    Node grandParent = expr.getParent().getParent();\n+                    if (grandParent.isObjectLit()) {\n+                      for (Node objProp = grandParent.getFirstChild(); objProp != null; objProp = objProp.getNext()) {\n+                        if (objProp != expr.getParent()\n+                            && objProp.getFirstChild().isString()\n+                            && !objProp.getFirstChild().getString().equals(\"constructor\")) {\n+                          Node val = objProp.getLastChild();\n+                          if (val != null && val.isFunction()) {\n+                            // We should not remove this element, because\n+                            // its presence may cause mutation of the object\n+                            // before the function call.\n+                            safeToRemove = false;\n+                            break;\n+                          }\n+                        }\n+                      }\n+                    }\n+                  }\n+                  if (safeToRemove) {\n+                    ControlFlowGraph graph = controlFlowAnalysis.getCfg();\n+                    Node branchNode = branchOfUsage.getRoot();\n+                    LinkedDiGraphNode<Integer> node =\n+                        graph.getNode(nodeCounter.get(branchNode) + expr.getLineno());\n+                    if (graph.getDirectedPredicates().getSideEffectFreePredicate().apply(node)) {\n+                      NodeUtil.removeChild(parent, branchNode);\n+                      NodeUtil.markFunctionsDeleted(branchNode, compiler);\n+                      NodeUtil.markNewScopesDeleted(branchNode, compiler);\n+                      compiler.reportCodeChange();\n+                    } else {\n+                      // We can't delete this branch yet. Remove usages and we will\n+                      // try again in the next pass.  Or, a non-global variable needs to be propagated.\n+                      // We can't propagate variables during the analysis phase.\n+                      // Put all local variables on a propagate queue to be handled\n+                      // after analysis\n+                      propagateQueue.add(var.getName());\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          }\n         }\n       }\n-    } else {\n-      callSiteOptimizer.optimize(fnScope, referenced);\n     }\n   }\n \n+  private void removeUnreferencedLocalVarsInFunctionDeclarations() {\n+    for (Scope scope : scopeStack) {\n+      Node root = scope.getRootNode();\n+      if (root == null || !root.isFunction()) {\n+        continue;\n+      }\n+\n+      Preconditions.checkState(root.isFunction());\n+      Node fnNode = root;\n+      Node paramList = fnNode.getFirstChild().getNext\n+\n \n   /**\n    * @return the LP node containing the function parameters.",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}