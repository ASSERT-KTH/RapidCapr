{
    "patch": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n            if (candidate != null) {\n                field.setAccessible(true);\n                try {\n                    if (field.getType().isPrimitive()) { // field is a primitive type\n                        if (candidate instanceof Number) {\n                            candidate = unwrapNumber((Number) candidate, field.getType());\n                        } else if (candidate instanceof Character) {\n                            candidate = unwrapCharacter((Character) candidate, field.getType());\n                        }\n                    }\n                    if (field.getType().isAssignableFrom(candidate.getClass())) {\n                        field.set(fieldInstance, field.getType().cast(candidate));\n                    } else {\n                        throw new IllegalArgumentException(\"Candidate type \" + candidate.getClass() +\n                                \" not compatible with field type \" + field.getType());\n                    }\n                } catch (IllegalAccessException e) {\n                    e.printStackTrace();\n                }\n            }\n        }\n    }\n    \n    private Object unwrapNumber(Number number, Class<?> targetType) {\n        Class<?> boxedType = getBoxedType(targetType);\n        if (boxedType == Integer.class) {\n            return number.intValue();\n        } else if (boxedType == Long.class) {\n            return number.longValue();\n        } else if (boxedType == Short.class) {\n            return number.shortValue();\n        } else if (boxedType == Byte.class) {\n            return number.byteValue();\n        } else if (boxedType == Double.class) {\n            return number.doubleValue();\n        } else if (boxedType == Float.class) {\n            return number.floatValue();\n        } else {\n            throw new IllegalArgumentException(\"Unsupported primitive type: \" + targetType);\n        }\n    }\n\n    private Object unwrapCharacter(Character character, Class<?> targetType) {\n        if (targetType == char.class) {\n            return character.charValue();\n        } else if (targetType == Character.class) {\n            return character;\n        } else {\n            throw new IllegalArgumentException(\"Unsupported primitive type: \" + targetType);\n        }\n    }\n\n    private Class<?> getBoxedType(Class<?> primitiveType) {\n        if (primitiveType == int.class) {\n            return Integer.class;\n        } else if (primitiveType == long.class) {\n            return Long.class;\n        } else if (primitiveType == short.class) {\n            return Short.class;\n        } else if (primitiveType == byte.class) {\n            return Byte.class;\n        } else if (primitiveType == double.class) {\n            return Double.class;\n        } else if (primitiveType == float.class) {\n            return Float.class;\n        } else if (primitiveType == char.class) {\n            return Character.class;\n        } else if (primitiveType == boolean.class) {\n            return Boolean.class;\n        } else {\n            throw new IllegalArgumentException(\"Not a primitive type: \" + primitiveType);\n        }\n    }",
    "patch_diff": "diff --git a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\nindex 213ebf351..d88a4bfa4 100644\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n@@ -88,9 +88,85 @@ public class DefaultInjectionEngine {\n         }\n     }\n \n+\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n+        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+            Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n+            if (candidate != null) {\n+                field.setAccessible(true);\n+                try {\n+                    if (field.getType().isPrimitive()) { // field is a primitive type\n+                        if (candidate instanceof Number) {\n+                            candidate = unwrapNumber((Number) candidate, field.getType());\n+                        } else if (candidate instanceof Character) {\n+                            candidate = unwrapCharacter((Character) candidate, field.getType());\n+                        }\n+                    }\n+                    if (field.getType().isAssignableFrom(candidate.getClass())) {\n+                        field.set(fieldInstance, field.getType().cast(candidate));\n+                    } else {\n+                        throw new IllegalArgumentException(\"Candidate type \" + candidate.getClass() +\n+                                \" not compatible with field type \" + field.getType());\n+                    }\n+                } catch (IllegalAccessException e) {\n+                    e.printStackTrace();\n+                }\n+            }\n+        }\n+    }\n+    \n+    private Object unwrapNumber(Number number, Class<?> targetType) {\n+        Class<?> boxedType = getBoxedType(targetType);\n+        if (boxedType == Integer.class) {\n+            return number.intValue();\n+        } else if (boxedType == Long.class) {\n+            return number.longValue();\n+        } else if (boxedType == Short.class) {\n+            return number.shortValue();\n+        } else if (boxedType == Byte.class) {\n+            return number.byteValue();\n+        } else if (boxedType == Double.class) {\n+            return number.doubleValue();\n+        } else if (boxedType == Float.class) {\n+            return number.floatValue();\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported primitive type: \" + targetType);\n+        }\n+    }\n+\n+    private Object unwrapCharacter(Character character, Class<?> targetType) {\n+        if (targetType == char.class) {\n+            return character.charValue();\n+        } else if (targetType == Character.class) {\n+            return character;\n+        } else {\n+            throw new IllegalArgumentException(\"Unsupported primitive type: \" + targetType);\n+        }\n+    }\n+\n+    private Class<?> getBoxedType(Class<?> primitiveType) {\n+        if (primitiveType == int.class) {\n+            return Integer.class;\n+        } else if (primitiveType == long.class) {\n+            return Long.class;\n+        } else if (primitiveType == short.class) {\n+            return Short.class;\n+        } else if (primitiveType == byte.class) {\n+            return Byte.class;\n+        } else if (primitiveType == double.class) {\n+            return Double.class;\n+        } else if (primitiveType == float.class) {\n+            return Float.class;\n+        } else if (primitiveType == char.class) {\n+            return Character.class;\n+        } else if (primitiveType == boolean.class) {\n+            return Boolean.class;\n+        } else {\n+            throw new IllegalArgumentException(\"Not a primitive type: \" + primitiveType);\n+        }\n+    }\n         }\n     }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}