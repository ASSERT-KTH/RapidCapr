{
    "patch": "    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    List<Node> unusedParams = new ArrayList<>();\n\n    if (!modifyCallers) {\n      // Collect any unused arguments\n      for (Node child : argList.children()) {\n        Var var = fnScope.getVar(child.getString());\n        if (!referenced.contains(var)) {\n          unusedParams.add(child);\n        } else {\n          // If a used argument already exists, any previous argument is marked as used.\n          referenced.addAll(var.getNameNode().getAncestors());\n        }\n      }\n\n      if (!unusedParams.isEmpty()) {\n        // create a call to 'Array.isArray', 'Array.prototype.concat', and 'slice'\n        Node arrayIsArray = IR.getprop(IR.name(\"Array\"), IR.string(\"isArray\"));\n        Node callArrayIsArray = IR.call(arrayIsArray, IR.name(\"Array\"));\n        Node arrayPrototype = IR.getprop(IR.name(\"Array\"), IR.string(\"prototype\"));\n        Node arrayPrototypeConcat = IR.getprop(arrayPrototype, IR.string(\"concat\"));\n        Node callArrayPrototypeConcat = IR.call(arrayPrototypeConcat, IR.name(\"Array\"));\n        Node slice = IR.getprop(IR.name(\"Array\"), IR.string(\"prototype\"));\n        Node sliceGet = IR.getprop(slice, IR.string(\"slice\"));\n        Node sliceFn = IR.name(\"slice\");\n        Node callSlice = IR.call(sliceGet, CallArgs.builder().add(IR.name(\"arguments\")).build());\n        Node sliceParams = IR.paramList(IR.string(\"start\"));\n\n        // Add the callargs to the slice\n        // Search references to 'arguments' and update accordingly - use arrays to prevent inconsistent traversal\n        List<Node> argumentsRefs = new ArrayList<>();\n        List<Node> arrayIndexes = new ArrayList<>();\n        Node arrayIndex = argList.getFirstChild();\n        for (int i = 0; i < argList.getChildCount(); i++) {\n          if (arrayIndex != null) {\n            arrayIndexes.add(arrayIndex);\n            arrayIndex = arrayIndex.getNext();\n          }\n\n          if (argList.getChildAtIndex(i).isName() && \"arguments\".equals(argList.getChildAtIndex(i).getString())) {\n            argumentsRefs.add(argList.getChildAtIndex(i));\n          }\n        }\n\n        for (Node unusedParam : unusedParams) {\n          Node index = IR.number(arrayIndexes.indexOf(unusedParam));\n          sliceParams.addChildToBack(index);\n        }\n\n        Node callParam = IR.call(sliceFn, sliceParams);\n        callSlice.replaceWith(callParam);\n\n        // Create the new argument list\n        Node argListReplacement = IR.paramList();\n        for (Node child : argList.children()) {\n          if (!unusedParams.contains(child)) {\n            argListReplacement.addChildToBack(child.cloneTree());\n          }\n        }\n\n        // Replace the old argument list with the new one\n        argList.replaceWith(argListReplacement);\n\n        // Add log entry here:\n        Node log = IR.call(\n            IR.getprop(IR.name(\"console\"), IR.string(\"log\")),\n            IR.string(\"Removed unused function arguments\"),\n            IR.nameNode(\"arguments\"));\n\n        Node functionNode = fnScope.getRootNode();\n        functionNode.getLastChild().addChildAfter(log, null);\n        NodeUtil.markFunctionsDeleted(unusedParams);\n        compiler.reportCodeChange();\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..e0828a39 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,93 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+    Preconditions.checkState(function.isFunction());\n+\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers = modifyCallSites\n+        && callSiteOptimizer.canModifyCallers(function);\n+    List<Node> unusedParams = new ArrayList<>();\n+\n+    if (!modifyCallers) {\n+      // Collect any unused arguments\n+      for (Node child : argList.children()) {\n+        Var var = fnScope.getVar(child.getString());\n+        if (!referenced.contains(var)) {\n+          unusedParams.add(child);\n+        } else {\n+          // If a used argument already exists, any previous argument is marked as used.\n+          referenced.addAll(var.getNameNode().getAncestors());\n+        }\n+      }\n+\n+      if (!unusedParams.isEmpty()) {\n+        // create a call to 'Array.isArray', 'Array.prototype.concat', and 'slice'\n+        Node arrayIsArray = IR.getprop(IR.name(\"Array\"), IR.string(\"isArray\"));\n+        Node callArrayIsArray = IR.call(arrayIsArray, IR.name(\"Array\"));\n+        Node arrayPrototype = IR.getprop(IR.name(\"Array\"), IR.string(\"prototype\"));\n+        Node arrayPrototypeConcat = IR.getprop(arrayPrototype, IR.string(\"concat\"));\n+        Node callArrayPrototypeConcat = IR.call(arrayPrototypeConcat, IR.name(\"Array\"));\n+        Node slice = IR.getprop(IR.name(\"Array\"), IR.string(\"prototype\"));\n+        Node sliceGet = IR.getprop(slice, IR.string(\"slice\"));\n+        Node sliceFn = IR.name(\"slice\");\n+        Node callSlice = IR.call(sliceGet, CallArgs.builder().add(IR.name(\"arguments\")).build());\n+        Node sliceParams = IR.paramList(IR.string(\"start\"));\n+\n+        // Add the callargs to the slice\n+        // Search references to 'arguments' and update accordingly - use arrays to prevent inconsistent traversal\n+        List<Node> argumentsRefs = new ArrayList<>();\n+        List<Node> arrayIndexes = new ArrayList<>();\n+        Node arrayIndex = argList.getFirstChild();\n+        for (int i = 0; i < argList.getChildCount(); i++) {\n+          if (arrayIndex != null) {\n+            arrayIndexes.add(arrayIndex);\n+            arrayIndex = arrayIndex.getNext();\n+          }\n+\n+          if (argList.getChildAtIndex(i).isName() && \"arguments\".equals(argList.getChildAtIndex(i).getString())) {\n+            argumentsRefs.add(argList.getChildAtIndex(i));\n+          }\n+        }\n+\n+        for (Node unusedParam : unusedParams) {\n+          Node index = IR.number(arrayIndexes.indexOf(unusedParam));\n+          sliceParams.addChildToBack(index);\n+        }\n+\n+        Node callParam = IR.call(sliceFn, sliceParams);\n+        callSlice.replaceWith(callParam);\n+\n+        // Create the new argument list\n+        Node argListReplacement = IR.paramList();\n+        for (Node child : argList.children()) {\n+          if (!unusedParams.contains(child)) {\n+            argListReplacement.addChildToBack(child.cloneTree());\n+          }\n+        }\n+\n+        // Replace the old argument list with the new one\n+        argList.replaceWith(argListReplacement);\n+\n+        // Add log entry here:\n+        Node log = IR.call(\n+            IR.getprop(IR.name(\"console\"), IR.string(\"log\")),\n+            IR.string(\"Removed unused function arguments\"),\n+            IR.nameNode(\"arguments\"));\n+\n+        Node functionNode = fnScope.getRootNode();\n+        functionNode.getLastChild().addChildAfter(log, null);\n+        NodeUtil.markFunctionsDeleted(unusedParams);\n+        compiler.reportCodeChange();\n+      }\n+    } else {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}