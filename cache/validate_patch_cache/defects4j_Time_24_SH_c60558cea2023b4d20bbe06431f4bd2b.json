{
    "patch": "int firstErrorIndex = -1;\nfor (int i = 0; i < count; i++) {\n    SavedField save = savedFields[i];\n    long next;\n    try {\n        next = save.set(millis, resetFields);\n    } catch (IllegalFieldValueException e) {\n        if (firstErrorIndex == -1) {\n            firstErrorIndex = i;\n        }\n        continue;\n    }\n    if (next != millis) {\n        if (resetFields) {\n            for (int j = 0; j <= i; j++) {\n                savedFields[j].save();\n            }\n        }\n        millis = next;\n        firstErrorIndex = -1;\n    }\n}\nif (firstErrorIndex >= 0) {\n    SavedField save = savedFields[firstErrorIndex];\n    DateTimeField field = save.getField();\n    FieldType type = field.getType();\n    Collection<String> variants = type.getVariants();\n    String message = String.format(\"Invalid value for \\\"%s\\\": \\\"%s\\\"\", type.getName(), variants != null ? String.format(\"[%s]\", String.join(\"|\", variants)) : save.getValue());\n    if (text != null) {\n        message = String.format(\"Cannot parse \\\"%s\\\": %s\", text, message);\n    }\n    throw new IllegalFieldValueException(field, message);\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..e6701bb1 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,39 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+int firstErrorIndex = -1;\n+for (int i = 0; i < count; i++) {\n+    SavedField save = savedFields[i];\n+    long next;\n+    try {\n+        next = save.set(millis, resetFields);\n+    } catch (IllegalFieldValueException e) {\n+        if (firstErrorIndex == -1) {\n+            firstErrorIndex = i;\n+        }\n+        continue;\n+    }\n+    if (next != millis) {\n+        if (resetFields) {\n+            for (int j = 0; j <= i; j++) {\n+                savedFields[j].save();\n+            }\n+        }\n+        millis = next;\n+        firstErrorIndex = -1;\n+    }\n+}\n+if (firstErrorIndex >= 0) {\n+    SavedField save = savedFields[firstErrorIndex];\n+    DateTimeField field = save.getField();\n+    FieldType type = field.getType();\n+    Collection<String> variants = type.getVariants();\n+    String message = String.format(\"Invalid value for \\\"%s\\\": \\\"%s\\\"\", type.getName(), variants != null ? String.format(\"[%s]\", String.join(\"|\", variants)) : save.getValue());\n+    if (text != null) {\n+        message = String.format(\"Cannot parse \\\"%s\\\": %s\", text, message);\n+    }\n+    throw new IllegalFieldValueException(field, message);\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}