{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final int maxRetries = 3;\n    final double memoryFactor = 1.5;\n    final long maxMemory = Runtime.getRuntime().maxMemory();\n    final long minMemory = (long) (m.getRowDimension() * m.getColumnDimension() * Double.BYTES * memoryFactor);\n\n    for (int i = 0; i <= maxRetries; i++) {\n        try {\n            final EigenDecomposition dec = new EigenDecomposition(m, minMemory);\n            return dec.getSquareRoot();\n        } catch (OutOfMemoryError e) {\n            System.gc();\n            final long newMemory = Math.min((long) (maxMemory * Math.pow(memoryFactor, i)), Integer.MAX_VALUE - 1);\n            if (newMemory <= minMemory) {\n                break;\n            }\n            try {\n                final EigenDecomposition dec = new EigenDecomposition(m, newMemory);\n                return dec.getSquareRoot();\n            } catch (OutOfMemoryError e2) {\n                System.gc();\n            }\n        }\n    }\n\n    // If all attempts failed, use iterative square root method\n    return matrixIterativeSquareRoot(m);\n}\n\nprivate static RealMatrix matrixIterativeSquareRoot(RealMatrix m) {\n    final int maxIterations = 100;\n    final double tolerance = 1e-9;\n\n    final int n = m.getRowDimension();\n    RealMatrix X = MatrixUtils.createRealIdentityMatrix(n);\n    RealMatrix Xk;\n    for (int i = 0; i < maxIterations; i++) {\n        Xk = 0.5 * (X.add(m.multiply(X.inverse())));\n        if (Xk.subtract(X).getNorm() < tolerance) {\n            return Xk;\n        }\n        X = Xk;\n    }\n    // Return the last approximation after maxIterations\n    return Xk;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..403c05f04 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,50 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final int maxRetries = 3;\n+    final double memoryFactor = 1.5;\n+    final long maxMemory = Runtime.getRuntime().maxMemory();\n+    final long minMemory = (long) (m.getRowDimension() * m.getColumnDimension() * Double.BYTES * memoryFactor);\n+\n+    for (int i = 0; i <= maxRetries; i++) {\n+        try {\n+            final EigenDecomposition dec = new EigenDecomposition(m, minMemory);\n             return dec.getSquareRoot();\n+        } catch (OutOfMemoryError e) {\n+            System.gc();\n+            final long newMemory = Math.min((long) (maxMemory * Math.pow(memoryFactor, i)), Integer.MAX_VALUE - 1);\n+            if (newMemory <= minMemory) {\n+                break;\n+            }\n+            try {\n+                final EigenDecomposition dec = new EigenDecomposition(m, newMemory);\n+                return dec.getSquareRoot();\n+            } catch (OutOfMemoryError e2) {\n+                System.gc();\n+            }\n+        }\n     }\n+\n+    // If all attempts failed, use iterative square root method\n+    return matrixIterativeSquareRoot(m);\n+}\n+\n+private static RealMatrix matrixIterativeSquareRoot(RealMatrix m) {\n+    final int maxIterations = 100;\n+    final double tolerance = 1e-9;\n+\n+    final int n = m.getRowDimension();\n+    RealMatrix X = MatrixUtils.createRealIdentityMatrix(n);\n+    RealMatrix Xk;\n+    for (int i = 0; i < maxIterations; i++) {\n+        Xk = 0.5 * (X.add(m.multiply(X.inverse())));\n+        if (Xk.subtract(X).getNorm() < tolerance) {\n+            return Xk;\n+        }\n+        X = Xk;\n+    }\n+    // Return the last approximation after maxIterations\n+    return Xk;\n+}\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}