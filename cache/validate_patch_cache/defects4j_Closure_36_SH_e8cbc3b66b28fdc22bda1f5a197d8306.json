{
    "patch": "if (value.isFunction()) {\n  Node callNode = reference.getParent();\n  if (callNode.isCall()) {\n    CodingConvention convention = compiler.getCodingConvention();\n    // Bug 2388531: Don't inline subclass definitions into class defining\n    // calls as this confused class removing logic.\n    SubclassRelationship relationship =\n        convention.getClassesDefinedByCall(callNode);\n    if (relationship != null) {\n      return false;\n    }\n    \n    // issue 668: Don't inline singleton getter methods\n    // calls as this confused class removing logic.\n    if (value.isQualifiedName()) {\n      Var declarationVar = t.getScope().getVar(declaration.getNode());\n      JSType declarationType =\n          declarationVar != null ? declarationVar.getType() : null;\n\n      // The declared type needs to be nullable. This is because, in practice,\n      // not all singletons are instantiated. As such we need to support passing\n      // null value to the getter function.\n      if (declarationType != null && !declarationType.isNullable()) {\n        return false;\n      }\n\n      Node objNode = value.getFirstChild();\n      String objName = objNode.getQualifiedName();\n      Node fnNameNode = objNode.getNext();\n      String fnName = fnNameNode.getString();\n      if (objName != null && fnName != null) {\n        JSType jsType = t.getTypeRegistry().getNativeObjectType(OBJECT_TYPE_STRING);\n        ObjectType objectType = ObjectType.cast(jsType);\n\n        if (objectType != null\n            && objectType.getOwnPropertyNames().contains(objName)) {\n          // getOwnPropertyNames() contains only own properties. If objectName\n          // is not present, it might be present in a prototype and we cannot\n          // inline it.\n          ObjectProperty prop = objectType.getOwnProperty(objName);\n          if (prop == null\n              || !prop.isMethod()\n              || !prop.getType().isFunctionType()) {\n            return false;\n          }\n\n          FunctionType getterFnType = prop.getType().toMaybeFunctionType();\n          if (getterFnType == null) {\n            // In case the type is null, bail out.\n            // Inlined function can be null at the time of inlining.\n            return false;\n          }\n\n          JSType returnType = getterFnType.getReturnType();\n          if (returnType == null || !returnType.isEquivalentTo(declarationType)) {\n            return false;\n          }\n\n          // additional checks that can be done:\n          // 1) getter should not take any parameter, i.e.,\n          //    getter(a) --> false\n          // 2) singleton should only be instantiated once\n          //    var x = function() { return {}; }();\n          //    x.getInstance() --> OK\n          //    function y() { return {}; };\n          //    y.getInstance() --> false\n          \n          // Get the \"instance\" method of the singleton object if it exists.\n          Node singletonObjNode = reference.cloneNode();\n          singletonObjNode.replaceWith(objNode.cloneTree());\n          Node instanceCallNode =\n              IR.call(IR.getprop(singletonObjNode, \"getInstance\"));\n          if (callNode.hasMoreThanOneChild()\n              || !callNode.getFirstChild().matchesQualifiedName(fnName)\n              || !callNode.getFirstChild().isGetProp()\n              || !callNode.getParent().isExprResult()) {\n            return false;\n          }\n          Node prev = callNode.getPrevious();\n          Node next = callNode.getNext();\n          if (prev != null &&\n              !NodeUtil.mayHaveSideEffectsAfterExecution(prev, compiler) &&\n              !instanceCallNode.isEquivalentTo(prev.getLastChild())) {\n            return false;\n          }\n          if (next != null &&\n              !NodeUtil.mayHaveSideEffectsBeforeExecution(next, compiler) &&\n              !instanceCallNode.isEquivalentTo(next.getFirstChild())) {\n            return false;\n          }\n\n          value = instanceCallNode;\n        }\n      }\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..01ceaf72 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,103 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+if (value.isFunction()) {\n+  Node callNode = reference.getParent();\n+  if (callNode.isCall()) {\n+    CodingConvention convention = compiler.getCodingConvention();\n+    // Bug 2388531: Don't inline subclass definitions into class defining\n+    // calls as this confused class removing logic.\n+    SubclassRelationship relationship =\n+        convention.getClassesDefinedByCall(callNode);\n+    if (relationship != null) {\n+      return false;\n+    }\n+    \n+    // issue 668: Don't inline singleton getter methods\n+    // calls as this confused class removing logic.\n+    if (value.isQualifiedName()) {\n+      Var declarationVar = t.getScope().getVar(declaration.getNode());\n+      JSType declarationType =\n+          declarationVar != null ? declarationVar.getType() : null;\n+\n+      // The declared type needs to be nullable. This is because, in practice,\n+      // not all singletons are instantiated. As such we need to support passing\n+      // null value to the getter function.\n+      if (declarationType != null && !declarationType.isNullable()) {\n+        return false;\n+      }\n+\n+      Node objNode = value.getFirstChild();\n+      String objName = objNode.getQualifiedName();\n+      Node fnNameNode = objNode.getNext();\n+      String fnName = fnNameNode.getString();\n+      if (objName != null && fnName != null) {\n+        JSType jsType = t.getTypeRegistry().getNativeObjectType(OBJECT_TYPE_STRING);\n+        ObjectType objectType = ObjectType.cast(jsType);\n+\n+        if (objectType != null\n+            && objectType.getOwnPropertyNames().contains(objName)) {\n+          // getOwnPropertyNames() contains only own properties. If objectName\n+          // is not present, it might be present in a prototype and we cannot\n+          // inline it.\n+          ObjectProperty prop = objectType.getOwnProperty(objName);\n+          if (prop == null\n+              || !prop.isMethod()\n+              || !prop.getType().isFunctionType()) {\n+            return false;\n+          }\n+\n+          FunctionType getterFnType = prop.getType().toMaybeFunctionType();\n+          if (getterFnType == null) {\n+            // In case the type is null, bail out.\n+            // Inlined function can be null at the time of inlining.\n+            return false;\n+          }\n+\n+          JSType returnType = getterFnType.getReturnType();\n+          if (returnType == null || !returnType.isEquivalentTo(declarationType)) {\n+            return false;\n+          }\n+\n+          // additional checks that can be done:\n+          // 1) getter should not take any parameter, i.e.,\n+          //    getter(a) --> false\n+          // 2) singleton should only be instantiated once\n+          //    var x = function() { return {}; }();\n+          //    x.getInstance() --> OK\n+          //    function y() { return {}; };\n+          //    y.getInstance() --> false\n+          \n+          // Get the \"instance\" method of the singleton object if it exists.\n+          Node singletonObjNode = reference.cloneNode();\n+          singletonObjNode.replaceWith(objNode.cloneTree());\n+          Node instanceCallNode =\n+              IR.call(IR.getprop(singletonObjNode, \"getInstance\"));\n+          if (callNode.hasMoreThanOneChild()\n+              || !callNode.getFirstChild().matchesQualifiedName(fnName)\n+              || !callNode.getFirstChild().isGetProp()\n+              || !callNode.getParent().isExprResult()) {\n+            return false;\n+          }\n+          Node prev = callNode.getPrevious();\n+          Node next = callNode.getNext();\n+          if (prev != null &&\n+              !NodeUtil.mayHaveSideEffectsAfterExecution(prev, compiler) &&\n+              !instanceCallNode.isEquivalentTo(prev.getLastChild())) {\n+            return false;\n+          }\n+          if (next != null &&\n+              !NodeUtil.mayHaveSideEffectsBeforeExecution(next, compiler) &&\n+              !instanceCallNode.isEquivalentTo(next.getFirstChild())) {\n+            return false;\n+          }\n+\n+          value = instanceCallNode;\n+        }\n+      }\n+    }\n+  }\n+}\n         }\n       }\n ",
    "result_reason": "error: variable callNode is already defined in method canInline(Reference,Reference,Reference)",
    "test_result": "ERROR"
}