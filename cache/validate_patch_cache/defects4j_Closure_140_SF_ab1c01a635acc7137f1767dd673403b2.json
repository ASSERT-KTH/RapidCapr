{
    "patch": "@Override\nNode getNodeForCodeInsertion(JSModule module) {\n  if (module == null) {\n    List<CompilerInput> sourceInputs = new ArrayList<>();\n    List<CompilerInput> nonSourceInputs = new ArrayList<>();\n\n    for (CompilerInput input : inputs) {\n      if (!input.isExtern()) {\n        if (input.getSourceFile() != null) {\n          sourceInputs.add(input);\n        } else {\n          nonSourceInputs.add(input);\n        }\n      }\n    }\n\n    for (CompilerInput input : sourceInputs) {\n      Node ast = input.getAstRoot(this);\n      if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n        return ast;\n      }\n    }\n\n    if (!sourceInputs.isEmpty()) {\n      return sourceInputs.get(sourceInputs.size() - 1).getAstRoot(this).getLastChild();\n    }\n\n    for (CompilerInput input : nonSourceInputs) {\n      Node ast = input.getAstRoot(this);\n      if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n        return ast;\n      }\n    }\n\n    if (!nonSourceInputs.isEmpty()) {\n      return nonSourceInputs.get(nonSourceInputs.size() - 1).getAstRoot(this).getLastChild();\n    }\n\n    throw new IllegalStateException(\"empty root module with no valid inputs\");\n  }\n\n  List<CompilerInput> inputs = module.getInputs();\n\n  for (CompilerInput input : inputs) {\n    if (!input.isExtern()) {\n      Node ast = input.getAstRoot(this);\n      if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n        return ast;\n      }\n    }\n  }\n\n  JSModuleGraph moduleGraph = getModuleGraph();\n  for (JSModule m : moduleGraph.getExpandedModules(module)) {\n    inputs = m.getInputs();\n    for (CompilerInput input : inputs) {\n      if (!input.isExtern()) {\n        Node ast = input.getAstRoot(this);\n        if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n          return ast;\n        }\n      }\n    }\n  }\n\n  throw new IllegalStateException(\"Module has no valid inputs: \" + module.getName());\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..752f2455 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,73 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n+@Override\n+Node getNodeForCodeInsertion(JSModule module) {\n+  if (module == null) {\n+    List<CompilerInput> sourceInputs = new ArrayList<>();\n+    List<CompilerInput> nonSourceInputs = new ArrayList<>();\n \n-    checkFirstModule(modules);\n+    for (CompilerInput input : inputs) {\n+      if (!input.isExtern()) {\n+        if (input.getSourceFile() != null) {\n+          sourceInputs.add(input);\n+        } else {\n+          nonSourceInputs.add(input);\n+        }\n+      }\n+    }\n \n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n+    for (CompilerInput input : sourceInputs) {\n+      Node ast = input.getAstRoot(this);\n+      if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n+        return ast;\n+      }\n     }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n \n-    initInputsByNameMap();\n+    if (!sourceInputs.isEmpty()) {\n+      return sourceInputs.get(sourceInputs.size() - 1).getAstRoot(this).getLastChild();\n+    }\n+\n+    for (CompilerInput input : nonSourceInputs) {\n+      Node ast = input.getAstRoot(this);\n+      if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n+        return ast;\n+      }\n+    }\n+\n+    if (!nonSourceInputs.isEmpty()) {\n+      return nonSourceInputs.get(nonSourceInputs.size() - 1).getAstRoot(this).getLastChild();\n+    }\n+\n+    throw new IllegalStateException(\"empty root module with no valid inputs\");\n   }\n \n-  /**\n-   * Do any initialization that is dependent on the compiler options.\n-   */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+  List<CompilerInput> inputs = module.getInputs();\n+\n+  for (CompilerInput input : inputs) {\n+    if (!input.isExtern()) {\n+      Node ast = input.getAstRoot(this);\n+      if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n+        return ast;\n+      }\n     }\n   }\n \n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n+  JSModuleGraph moduleGraph = getModuleGraph();\n+  for (JSModule m : moduleGraph.getExpandedModules(module)) {\n+    inputs = m.getInputs();\n+    for (CompilerInput input : inputs) {\n+      if (!input.isExtern()) {\n+        Node ast = input.getAstRoot(this);\n+        if (ast.getLastChild() == null || ast.getLastChild().getType() == Token.EOF) {\n+          return ast;\n+        }\n+      }\n+    }\n+  }\n+\n+  throw new IllegalStateException(\"Module has no valid inputs: \" + module.getName());\n+}\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}