{
    "patch": "if (n.isCall() || n.isNew()) {\n  Node fnName = n.getFirstChild();\n  if (fnName.isQualifiedName()) {\n    String name = fnName.getQualifiedName();\n    // Don't traverse known functions that can't have a @this annotation.\n    if (name.equals(\"goog.bind\") ||\n        name.equals(\"goog.partial\") ||\n        name.equals(\"Function.bind\") ||\n        name.equals(\"Function.prototype.bind\") ||\n        name.equals(\"HtmlUnitUtil.setUp\") ||\n        name.equals(\"HtmlUnitUtil.tearDown\") ||\n        name.equals(\"angular.mock.module\") ||\n        name.equals(\"angular.mock.inject\") ||\n        name.equals(\"describe\") ||\n        name.equals(\"it\") ||\n        name.equals(\"window.setInterval\") ||\n        name.equals(\"window.setTimeout\") ||\n        name.equals(\"jasmine.createSpy\") ||\n        name.equals(\"jasmine.createSpyObj\")) {\n      return false;\n    }\n  }\n}\n\nif (n.getJSDocInfo() != null &&\n    (n.getJSDocInfo().hasThisType() ||\n     n.getJSDocInfo().isOverride() ||\n     n.getJSDocInfo().isConstructor() ||\n     n.getJSDocInfo().isInterface())) {\n  return false;\n}\n\nif (NodeUtil.isFunctionExpression(n)) {\n  // Check if the function expression is the right child of an assignment\n  // expressions. e.g. let x = function() { ... };\n  boolean isAssignment = parent != null && parent.isAssign();\n  if (isAssignment) {\n    Node lhs = parent.getFirstChild();\n    // Don't allow declarations of the form let o = { f() { this.y = 3; } };\n    boolean isObjectLit = NodeUtil.isObjectLit(parent.getParent());\n    if (NodeUtil.isGet(lhs) && !isObjectLit) {\n      // We only care about prototyped methods.\n      Node target = lhs.getFirstChild();\n      if (target.getLastChild().getString().equals(\"prototype\")) {\n        String propName = n.getFirstChild().getString();\n        boolean isPrototypeMethod =\n            target.getFirstChild() != null &&\n            !target.getFirstChild().isThis() &&\n            (propName.equals(\"toString\") || propName.equals(\"valueOf\") ||\n             propName.startsWith(\"get\") || propName.startsWith(\"set\"));\n        if (isPrototypeMethod) {\n          return false;\n        }\n      }\n    }\n  }\n  // Don't traverse functions getting lent to a prototype.\n  if (parent != null && NodeUtil.isGet(parent)) {\n    Node target = parent.getFirstChild();\n    if (target.getLastChild().getString().equals(\"prototype\")) {\n      return false;\n    }\n  }\n}\n\n// Don't traverse function declarations in block scope.\nif (n.isFunction() && NodeUtil.isBlockScopedName(n.getString())) {\n  return false;\n}\n\n// Don't traverse functions in object literals or arrays.\nif (NodeUtil.isObjectLit(parent) || NodeUtil.isArrayLit(parent)) {\n  return false;\n}\n\nreturn true;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..db2e26e7 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,82 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+if (n.isCall() || n.isNew()) {\n+  Node fnName = n.getFirstChild();\n+  if (fnName.isQualifiedName()) {\n+    String name = fnName.getQualifiedName();\n+    // Don't traverse known functions that can't have a @this annotation.\n+    if (name.equals(\"goog.bind\") ||\n+        name.equals(\"goog.partial\") ||\n+        name.equals(\"Function.bind\") ||\n+        name.equals(\"Function.prototype.bind\") ||\n+        name.equals(\"HtmlUnitUtil.setUp\") ||\n+        name.equals(\"HtmlUnitUtil.tearDown\") ||\n+        name.equals(\"angular.mock.module\") ||\n+        name.equals(\"angular.mock.inject\") ||\n+        name.equals(\"describe\") ||\n+        name.equals(\"it\") ||\n+        name.equals(\"window.setInterval\") ||\n+        name.equals(\"window.setTimeout\") ||\n+        name.equals(\"jasmine.createSpy\") ||\n+        name.equals(\"jasmine.createSpyObj\")) {\n+      return false;\n+    }\n+  }\n+}\n+\n+if (n.getJSDocInfo() != null &&\n+    (n.getJSDocInfo().hasThisType() ||\n+     n.getJSDocInfo().isOverride() ||\n+     n.getJSDocInfo().isConstructor() ||\n+     n.getJSDocInfo().isInterface())) {\n+  return false;\n+}\n+\n+if (NodeUtil.isFunctionExpression(n)) {\n+  // Check if the function expression is the right child of an assignment\n+  // expressions. e.g. let x = function() { ... };\n+  boolean isAssignment = parent != null && parent.isAssign();\n+  if (isAssignment) {\n+    Node lhs = parent.getFirstChild();\n+    // Don't allow declarations of the form let o = { f() { this.y = 3; } };\n+    boolean isObjectLit = NodeUtil.isObjectLit(parent.getParent());\n+    if (NodeUtil.isGet(lhs) && !isObjectLit) {\n+      // We only care about prototyped methods.\n+      Node target = lhs.getFirstChild();\n+      if (target.getLastChild().getString().equals(\"prototype\")) {\n+        String propName = n.getFirstChild().getString();\n+        boolean isPrototypeMethod =\n+            target.getFirstChild() != null &&\n+            !target.getFirstChild().isThis() &&\n+            (propName.equals(\"toString\") || propName.equals(\"valueOf\") ||\n+             propName.startsWith(\"get\") || propName.startsWith(\"set\"));\n+        if (isPrototypeMethod) {\n+          return false;\n+        }\n+      }\n+    }\n+  }\n+  // Don't traverse functions getting lent to a prototype.\n+  if (parent != null && NodeUtil.isGet(parent)) {\n+    Node target = parent.getFirstChild();\n+    if (target.getLastChild().getString().equals(\"prototype\")) {\n+      return false;\n+    }\n+  }\n+}\n+\n+// Don't traverse function declarations in block scope.\n+if (n.isFunction() && NodeUtil.isBlockScopedName(n.getString())) {\n+  return false;\n+}\n+\n+// Don't traverse functions in object literals or arrays.\n+if (NodeUtil.isObjectLit(parent) || NodeUtil.isArrayLit(parent)) {\n+  return false;\n+}\n+\n+return true;\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}