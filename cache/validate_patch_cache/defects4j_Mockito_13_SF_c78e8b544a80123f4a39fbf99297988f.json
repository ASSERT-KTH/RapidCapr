{
    "patch": "public Object handle(Invocation invocation) throws Throwable {\n    if (invocationContainerImpl.hasAnswersForStubbing()) {\n        // stubbing voids with stubVoid() or doAnswer() style\n        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n                        .getArgumentMatcherStorage(), invocation);\n        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n        return null;\n    }\n\n    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n\n    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n                    invocation);\n\n    mockingProgress.validateState();\n\n    //if verificationMode is not null then someone is doing verify()        \n    if (verificationMode != null) {\n        VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n        // check if verification is intended for the current mock object\n        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n            verificationMode.verify(data);\n            return null;\n        } else {\n            // if verification is not intended for the current mock object, push verification mode back to mockingProgress\n            mockingProgress.verificationStarted(verificationMode);\n        }\n    }\n\n    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n\n    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n\n    if (stubbedInvocation != null) {\n        stubbedInvocation.captureArgumentsFrom(invocation);\n        return stubbedInvocation.answer(invocation);\n    } else {\n        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n\n        // redo setting invocation for potential stubbing in case of partial\n        // mocks / spies.\n        // Without it, the real method inside 'when' might have delegated\n        // to other self method and overwrite the intended stubbed method\n        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n        return ret;\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/MockHandler.java b/src/org/mockito/internal/MockHandler.java\nindex 6f2e4bcfd..93518da97 100644\n--- a/src/org/mockito/internal/MockHandler.java\n+++ b/src/org/mockito/internal/MockHandler.java\n@@ -55,55 +55,57 @@ public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInte\n         this(oldMockHandler.getMockSettings());\n     }\n \n-    public Object handle(Invocation invocation) throws Throwable {\n-        if (invocationContainerImpl.hasAnswersForStubbing()) {\n-            // stubbing voids with stubVoid() or doAnswer() style\n-            InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n-                            .getArgumentMatcherStorage(), invocation);\n-            invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n-            return null;\n-        }\n-        VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n-\n-        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n-                        invocation);\n-\n-        mockingProgress.validateState();\n-\n-        //if verificationMode is not null then someone is doing verify()        \n-        if (verificationMode != null) {\n-            //We need to check if verification was started on the correct mock \n-            // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {                \n-                VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);            \n-                verificationMode.verify(data);\n-                return null;\n-                // this means there is an invocation on a different mock. Re-adding verification mode \n-                // - see VerifyingWithAnExtraCallToADifferentMockTest (bug 138)\n-            }\n-        }\n-        \n-        invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n-        OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n-        mockingProgress.reportOngoingStubbing(ongoingStubbing);\n-\n-        StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n-\n-        if (stubbedInvocation != null) {\n-            stubbedInvocation.captureArgumentsFrom(invocation);\n-            return stubbedInvocation.answer(invocation);\n-        } else {\n-            Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n-\n-            // redo setting invocation for potential stubbing in case of partial\n-            // mocks / spies.\n-            // Without it, the real method inside 'when' might have delegated\n-            // to other self method and overwrite the intended stubbed method\n-            // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n-            invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n-            return ret;\n-        }\n-    }\n+\n+public Object handle(Invocation invocation) throws Throwable {\n+    if (invocationContainerImpl.hasAnswersForStubbing()) {\n+        // stubbing voids with stubVoid() or doAnswer() style\n+        InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress\n+                        .getArgumentMatcherStorage(), invocation);\n+        invocationContainerImpl.setMethodForStubbing(invocationMatcher);\n+        return null;\n+    }\n+\n+    VerificationMode verificationMode = mockingProgress.pullVerificationMode();\n+\n+    InvocationMatcher invocationMatcher = matchersBinder.bindMatchers(mockingProgress.getArgumentMatcherStorage(),\n+                    invocation);\n+\n+    mockingProgress.validateState();\n+\n+    //if verificationMode is not null then someone is doing verify()        \n+    if (verificationMode != null) {\n+        VerificationDataImpl data = new VerificationDataImpl(invocationContainerImpl, invocationMatcher);\n+        // check if verification is intended for the current mock object\n+        if (verificationMode instanceof MockAwareVerificationMode && ((MockAwareVerificationMode) verificationMode).getMock() == invocation.getMock()) {\n+            verificationMode.verify(data);\n+            return null;\n+        } else {\n+            // if verification is not intended for the current mock object, push verification mode back to mockingProgress\n+            mockingProgress.verificationStarted(verificationMode);\n+        }\n+    }\n+\n+    invocationContainerImpl.setInvocationForPotentialStubbing(invocationMatcher);\n+    OngoingStubbingImpl<T> ongoingStubbing = new OngoingStubbingImpl<T>(invocationContainerImpl);\n+    mockingProgress.reportOngoingStubbing(ongoingStubbing);\n+\n+    StubbedInvocationMatcher stubbedInvocation = invocationContainerImpl.findAnswerFor(invocation);\n+\n+    if (stubbedInvocation != null) {\n+        stubbedInvocation.captureArgumentsFrom(invocation);\n+        return stubbedInvocation.answer(invocation);\n+    } else {\n+        Object ret = mockSettings.getDefaultAnswer().answer(invocation);\n+\n+        // redo setting invocation for potential stubbing in case of partial\n+        // mocks / spies.\n+        // Without it, the real method inside 'when' might have delegated\n+        // to other self method and overwrite the intended stubbed method\n+        // with a different one. The reset is required to avoid runtime exception that validates return type with stubbed method signature.\n+        invocationContainerImpl.resetInvocationForPotentialStubbing(invocationMatcher);\n+        return ret;\n+    }\n+}\n \n     public VoidMethodStubbable<T> voidMethodStubbable(T mock) {\n         return new VoidMethodStubbableImpl<T>(mock, invocationContainerImpl);\n@@ -121,4 +123,4 @@ public class MockHandler<T> implements MockitoInvocationHandler, MockHandlerInte\n     public InvocationContainer getInvocationContainer() {\n         return invocationContainerImpl;\n     }\n-}\n\\ No newline at end of file\n+}",
    "result_reason": "all tests passed",
    "test_result": "PASS"
}