{
    "patch": "public void doEvents(final double t) throws MaxCountExceededException {\n    final boolean forward = interpolator.isForward();\n    final double tEnd = interpolator.getInterpolatedTime();\n    final double previousT = interpolator.getPreviousTime();\n    final List<EventState> events = stateMapper.getEventsStates();\n    final int nev = events.size();\n\n    // clear the events states and reset the events handlers\n    stateMapper.clearEventsStates();\n    for (final EventHandler eh : eventsHandlers) {\n        eh.resetState();\n    }\n\n    // search for ongoing and future events (i.e. events that occurs between\n    // previous and target time steps) and add their first occurrence to the\n    // event states list\n    final TreeSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n        public int compare(EventState es0, EventState es1) {\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n    });\n    for (final EventState state : events) {\n        if (forward ^ (state.getEventTime() < tEnd)) {\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(state);\n            }\n            state.reinitializeBegin(eventHandler);\n        }\n    }\n    stateMapper.setEventsStates(occuringEvents);\n\n    while (!occuringEvents.isEmpty()) {\n\n        // handle the chronologically first event\n        final Iterator<EventState> iterator = occuringEvents.iterator();\n        final EventState currentEvent = iterator.next();\n        iterator.remove();\n\n        // restrict the interpolator to the first part of the step, up to the event\n        final double eventT = currentEvent.getEventTime();\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n\n        // get state at event time\n        interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState().clone();\n\n        // advance all event states to current time\n        final List<EventState> occurringEventsList = new ArrayList<EventState>(occuringEvents);\n        for (final EventState evt : occurringEventsList) {\n            final double tEvent = evt.getEventTime();\n            // we need to recompute the event only if it occurs before the current\n            // event and if it occurs in the future regarding the integrator (it\n            // can have been processed by a previous call to this method and the\n            // integrator will not recognize previous event occurrences)\n            if (orderingSign * (tEvent - eventT) < 0 &&\n                forward ^ (tEvent >= tEnd)) {\n                if (evt.evaluateStep(interpolator)) {\n                    // add future occurrence to the list of ongoing events\n                    occuringEvents.add(evt);\n                }\n                evt.reinitializeBegin(eventHandler);\n            }\n            evt.stepAccepted(tEvent, eventY);\n        }\n\n        // advance all event states to current time\n        currentEvent.stepAccepted(eventT, eventY);\n\n        // handle the first part of the step, up to the event\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, false);\n        }\n\n        // handle the event\n        currentEvent.handleStep(eventT, eventY, false);\n\n        // handle the remaining part of the step, after the event\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, false);\n        }\n\n        // check if a stop event occurs\n        if (currentEvent.stop()) {\n            // the event asked to stop integration\n            stateMapper.setEventsStates(occuringEvents);\n            throw new StopException();\n        }\n\n        // prepare handling of the remaining part of the step, after the event\n        for (final EventHandler handler : eventsHandlers) {\n            handler.reinitializeEnd();\n        }\n\n        if (occuringEvents.isEmpty()) {\n            // the event we have just processed trigger some new ones, we need to\n            // recompute the ongoing events list before continuing\n            for (final EventState state : events) {\n                if (forward ^ (state.getEventTime() < tEnd)) {\n                    if (state.evaluateStep(interpolator)) {\n                        // the event occurs during the current step\n                        occuringEvents.add(state);\n                    }\n                    state.reinitializeBegin(eventHandler);\n                }\n            }\n            stateMapper.setEventsStates(occuringEvents);\n        }\n    }\n\n    // handle the remaining part of the step\n    if (previousT < tEnd) {\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(tEnd);\n        interpolator.setInterpolatedTime(t);\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, true);\n        }\n    }\n\n    // prepare handling of the next step\n    for (final EventHandler handler : eventsHandlers) {\n        handler.reinitializeBegin();\n    }\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..41f51ccb5 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,133 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n-\n-            });\n+public void doEvents(final double t) throws MaxCountExceededException {\n+    final boolean forward = interpolator.isForward();\n+    final double tEnd = interpolator.getInterpolatedTime();\n+    final double previousT = interpolator.getPreviousTime();\n+    final List<EventState> events = stateMapper.getEventsStates();\n+    final int nev = events.size();\n+\n+    // clear the events states and reset the events handlers\n+    stateMapper.clearEventsStates();\n+    for (final EventHandler eh : eventsHandlers) {\n+        eh.resetState();\n+    }\n \n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n+    // search for ongoing and future events (i.e. events that occurs between\n+    // previous and target time steps) and add their first occurrence to the\n+    // event states list\n+    final TreeSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n+        public int compare(EventState es0, EventState es1) {\n+            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n+        }\n+    });\n+    for (final EventState state : events) {\n+        if (forward ^ (state.getEventTime() < tEnd)) {\n+            if (state.evaluateStep(interpolator)) {\n+                // the event occurs during the current step\n+                occuringEvents.add(state);\n+            }\n+            state.reinitializeBegin(eventHandler);\n+        }\n+    }\n+    stateMapper.setEventsStates(occuringEvents);\n+\n+    while (!occuringEvents.isEmpty()) {\n+\n+        // handle the chronologically first event\n+        final Iterator<EventState> iterator = occuringEvents.iterator();\n+        final EventState currentEvent = iterator.next();\n+        iterator.remove();\n+\n+        // restrict the interpolator to the first part of the step, up to the event\n+        final double eventT = currentEvent.getEventTime();\n+        interpolator.setSoftPreviousTime(previousT);\n+        interpolator.setSoftCurrentTime(eventT);\n+\n+        // get state at event time\n+        interpolator.setInterpolatedTime(eventT);\n+        final double[] eventY = interpolator.getInterpolatedState().clone();\n+\n+        // advance all event states to current time\n+        final List<EventState> occurringEventsList = new ArrayList<EventState>(occuringEvents);\n+        for (final EventState evt : occurringEventsList) {\n+            final double tEvent = evt.getEventTime();\n+            // we need to recompute the event only if it occurs before the current\n+            // event and if it occurs in the future regarding the integrator (it\n+            // can have been processed by a previous call to this method and the\n+            // integrator will not recognize previous event occurrences)\n+            if (orderingSign * (tEvent - eventT) < 0 &&\n+                forward ^ (tEvent >= tEnd)) {\n+                if (evt.evaluateStep(interpolator)) {\n+                    // add future occurrence to the list of ongoing events\n+                    occuringEvents.add(evt);\n                 }\n+                evt.reinitializeBegin(eventHandler);\n             }\n+            evt.stepAccepted(tEvent, eventY);\n+        }\n \n-            while (!occuringEvents.isEmpty()) {\n+        // advance all event states to current time\n+        currentEvent.stepAccepted(eventT, eventY);\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+        // handle the first part of the step, up to the event\n+        for (final StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, false);\n+        }\n+\n+        // handle the event\n+        currentEvent.handleStep(eventT, eventY, false);\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+        // handle the remaining part of the step, after the event\n+        for (final StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, false);\n+        }\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+        // check if a stop event occurs\n+        if (currentEvent.stop()) {\n+            // the event asked to stop integration\n+            stateMapper.setEventsStates(occuringEvents);\n+            throw new StopException();\n+        }\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+        // prepare handling of the remaining part of the step, after the event\n+        for (final EventHandler handler : eventsHandlers) {\n+            handler.reinitializeEnd();\n+        }\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+        if (occuringEvents.isEmpty()) {\n+            // the event we have just processed trigger some new ones, we need to\n+            // recompute the ongoing events list before continuing\n+            for (final EventState state : events) {\n+                if (forward ^ (state.getEventTime() < tEnd)) {\n+                    if (state.evaluateStep(interpolator)) {\n+                        // the event occurs during the current step\n+                        occuringEvents.add(state);\n+                    }\n+                    state.reinitializeBegin(eventHandler);\n                 }\n+            }\n+            stateMapper.setEventsStates(occuringEvents);\n+        }\n+    }\n+\n+    // handle the remaining part of the step\n+    if (previousT < tEnd) {\n+        interpolator.setSoftPreviousTime(previousT);\n+        interpolator.setSoftCurrentTime(tEnd);\n+        interpolator.setInterpolatedTime(t);\n+        for (final StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, true);\n+        }\n+    }\n+\n+    // prepare handling of the next step\n+    for (final EventHandler handler : eventsHandlers) {\n+        handler.reinitializeBegin();\n+    }\n+\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}