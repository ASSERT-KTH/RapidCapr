{
    "patch": "Node value = callTarget.getNext();\nif (value != null) {\n  boolean isImmutable = NodeUtil.isImmutableValue(value);\n  boolean isStringConstructor = functionName.equals(\"String\") &&\n      value.getNext() == null &&\n      (isImmutable || NodeUtil.mayHaveSideEffects(value));\n  // Fold String(a) to '' + (a) on immutable literals or calls with a single immutable argument,\n  // which allows further optimizations in the compiler.\n  //\n  // We can't do this in the general case, because String(a) has\n  // slightly different semantics than '' + (a), and the string constructor\n  // returns '' for null/undefined, while '' + a returns 'null'/'undefined'.\n  if (isStringConstructor) {\n    Node argNode = value;\n    if (isImmutable) {\n      argNode.detachFromParent();\n    } else {\n      // Create a copy to avoid side effects if the argument has side effects.\n      argNode = value.cloneTree();\n    }\n    Node addition = IR.add(\n        IR.string(\"\").srcref(callTarget),\n        argNode).srcref(callTarget);\n    n.getParent().replaceChild(n, addition);\n    reportCodeChange();\n    return addition;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex bfa17074..609a744f 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -217,7 +217,34 @@ class PeepholeSubstituteAlternateSyntax\n       // slightly different semantics than '' + (a). See\n       // http://code.google.com/p/closure-compiler/issues/detail?id=759\n       Node value = callTarget.getNext();\n-      if (value != null) {\n+Node value = callTarget.getNext();\n+if (value != null) {\n+  boolean isImmutable = NodeUtil.isImmutableValue(value);\n+  boolean isStringConstructor = functionName.equals(\"String\") &&\n+      value.getNext() == null &&\n+      (isImmutable || NodeUtil.mayHaveSideEffects(value));\n+  // Fold String(a) to '' + (a) on immutable literals or calls with a single immutable argument,\n+  // which allows further optimizations in the compiler.\n+  //\n+  // We can't do this in the general case, because String(a) has\n+  // slightly different semantics than '' + (a), and the string constructor\n+  // returns '' for null/undefined, while '' + a returns 'null'/'undefined'.\n+  if (isStringConstructor) {\n+    Node argNode = value;\n+    if (isImmutable) {\n+      argNode.detachFromParent();\n+    } else {\n+      // Create a copy to avoid side effects if the argument has side effects.\n+      argNode = value.cloneTree();\n+    }\n+    Node addition = IR.add(\n+        IR.string(\"\").srcref(callTarget),\n+        argNode).srcref(callTarget);\n+    n.getParent().replaceChild(n, addition);\n+    reportCodeChange();\n+    return addition;\n+  }\n+}\n         Node addition = IR.add(\n             IR.string(\"\").srcref(callTarget),\n             value.detachFromParent());",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}