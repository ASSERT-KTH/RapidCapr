{
    "patch": "import org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Precision;\nimport org.apache.commons.math3.util.FastMath;\n\npublic class Gamma {\n\n    /**\n     * Default accuracy for algorithm.\n     */\n    private static final double DEFAULT_EPSILON = 1e-9;\n\n    /**\n     * The value below which {@code gamma} is computed by the Lanczos approximation.\n     */\n    private static final double LANCZOS_LOWER_LIMIT = 0.000000000000001;\n\n    /**\n     * The Lanczos coefficients.\n     */\n    static final double[] LANCZOS = {\n        0.9999999999998099,   676.5203681218851,   -1259.1392167224028,\n        771.32342877765313,  -176.61502916214059,  12.507343278686905,\n        -0.13857109526572012, 9.9843695780195716e-6, 1.5056327351493116e-7\n    };\n\n    /**\n     * Private constructor, utility class, no instances allowed.\n     */\n    private Gamma() {}\n\n    /**\n     * Computes the natural logarithm of the gamma function at {@code x}.\n     *\n     * @param x Argument.\n     * @return the value of {@code log(Gamma(x))}, {@code NaN} if {@code x <= 0.0}.\n     */\n    public static double logGamma(double x) {\n        double ret;\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else if (x < 0.5) {\n            return logGamma1p(x) - Math.log(x);\n        } else if (x <= 2.5) {\n            return logGamma1p((x - 0.5) - 0.5);\n        } else if (x <= 8.0) {\n            int n = (int) Math.floor(x - 1.5);\n            double prod = 1.0;\n            for (int i = 1; i <= n; i++) {\n                prod *= x - i;\n            }\n            return logGamma1p(x - (n + 1)) + Math.log(prod);\n        } else {\n            double sum = lanczos(x);\n            double tmp = x + LANCZOS_G + .5;\n            ret = ((x + .5) * Math.log(tmp)) - tmp +\n                  HALF_LOG_2_PI + Math.log(sum / x);\n        }\n        return ret;\n    }\n\n    /**\n     * Computes the natural logarithm of the gamma function at {@code x}.\n     * This method uses a Lanczos approximation to compute the gamma function.\n     *\n     * @param x Argument.\n     * @return the value of {@code log(Gamma(x))}, {@code NaN} if {@code x <= 0.0}.\n     */\n    public static double logGammaLanczos(double x) {\n        double ret;\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            ret = Double.NaN;\n        } else {\n            double sum = lanczos(x);\n            double tmp = x + LANCZOS_G + .5;\n            ret = ((x + .5) * Math.log(tmp)) - tmp +\n                  HALF_LOG_2_PI + Math.log(sum / x);\n        }\n        return ret;\n    }\n\n    /**\n     * Computes the digamma function of {@code x}.\n     * @param x Argument.\n     * @return the value of {@code digamma(x)}, {@code NaN} if {@code x <= 0.0}.\n     * @see <a href=\"http://en.wikipedia.org/wiki/Digamma_function\">Digamma Function</a>\n     */\n    public static double digamma(double x) {\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            return Double.NaN;\n        }\n\n        /*\n         * This implementation is based on the NSWC Library of Mathematics\n         * (http://math.nist.gov/nr/nswc/index.html) method psi(xx).\n         * They use a prefix of \"d\" for variables directly associated with\n         * the digamma function, and \"p\" for variables associated with the\n         * polygamma function: dp[i] is the i-th derivative of the\n         * polygamma function.\n         *\n         * Abramowitz and Stegun (p. 259, 6.3.11) write the polygamma\n         * derivative of order n as psi^ (n-1) (z).\n         *   dp[0] is therefore just psi(), i.e., the digamma function.\n         *   dp[1] is the trigamma function.\n         *   dp[2] is the tetragamma function.\n         *   etc.\n         * \n         * The basic idea for calculating this is to use the identity\n         * digamma(x) = digamma(x+1) - 1/x.\n         * This reduces the problem to calculating the digamma for arguments\n         * greater than 1.\n         *\n         * If x is less than the digammaSmallLimit value of 1e-5 or less,\n         * we use the approximation to digamma directly:\n         *\n         * digamma(x) = -Euler - 1/x + O(x)\n         *\n         * where Euler is the Euler-Mascheroni constant.\n         *\n         * For larger values, we apply the following recurrence relation to\n         * arrive at the value at the desired argument:\n         *\n         * digamma(x) = digamma(x - n) - 1/(x - n)\n         * \n         * where n=floor(x).\n         * Repeat this recursively to obtain x >= n + 1.\n         * Accurate values for arguments close to n can be calculated\n         * using the following formula, where z=x-n:\n         *\n         * digamma(x) = digamma(n) + 1/(2*z) - 1/(12*z^2) + 1/(120*z^4) - ...\n         *\n         * We stop the recursion and use this formula when z <= digammaDelta.\n         * \n         * Note that for large x, there are faster methods to compute digamma.\n         * However, this recursive method avoids double precision problems.\n         * \n         */\n\n        if (x >= 1e-5) {\n            double ret = 0.0;\n            while (x < digammaBigArgument) {\n                ret -= 1.0 / x;\n                x++;\n            }\n\n            double r = 1.0 / x;\n            double t = r * r;\n            ret += Math.log(x) - (0.5 * r) + t *\n                 ((((((((0.0833333333333333333333 * t - 0.00833333333333333333333) * t\n                 + 0.00396825396825396825397) * t - 0.00416666666666666666667) * t\n                 + 0.00757575757575757575758) * t - 0.0210927960927960927961) * t\n                 + 0.0833333333333333333333) * r);\n            return ret;\n        }\n        return -EULER - 1.0/x;\n    }\n\n    /**\n     * Computes the trigamma function of {@code x}.\n     * @param x Argument.\n     * @return the value of {@code trigamma(x)}, {@code NaN} if {@code x <= 0.0}.\n     * @see <a href=\"http://en.wikipedia.org/wiki/Trigamma_function\">Trigamma Function</a>\n     */\n    public static double trigamma(double x) {\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            return Double.NaN;\n        }\n        if (x < 1e-5) {\n            return 1.0 / (x * x) + HALF_EULER - EulerMascheroniConstants.DEFAULT;\n        }\n        /*\n         * This recurrence is from Bernardo, J.M. (1976).\n         * Algorithm AS 103: Psi ( Digamma ) Function.\n         * Applied Statistics 25 (3), 315-317.\n         * It is supposed to give full machine precision.\n         *\n         * If accuracy becomes an issue, another source of imprecision comes from\n         * the digamma function.\n         */\n        double ret = 0.0;\n        while (x < trigammaBigArgument) {\n            ret += 1.0 / (x * x);\n            x++;\n        }\n\n        /*\n         * Applying the asymptotic expansion directly gives better accuracy\n         * than recursively applying the defining relation.\n         */\n        double r = 1.0 / x;\n        ret += 0.5 * r;\n        double t = r * r;\n        ret -= t *\n            ((((((((0.0833333333333333333333 * t + 0.00833333333333333333333) * t\n            - 0.00396825396825396825397) * t + 0.00416666666666666666667) * t\n            - 0.00757575757575757575758) * t + 0.0210927960927960927961) * t\n            - 0.0833333333333333333333) * r);\n        return ret;\n    }\n\n    /**\n     * Computes the polygamma function of order {@code n} of {@code x}.\n     * @param n Order of polygamma function.\n     * @param x Argument.\n     * @return the value of {@code psi^(n)(x)}, {@code NaN} if {@code x <= 0.0} or if {@code n < 0.0}.\n     * @see <a href=\"http://en.wikipedia.org/wiki/Polygamma_function\">Polygamma Function</a>\n     */\n    public static double polygamma(int n, double x) {\n        if (Double.isNaN(x) || (x <= 0.0) || (n < 0)) {\n            return Double.NaN;\n        }\n        if (n == 0) {\n            return digamma(x);\n        } else {\n            return polySum(n, x);\n        }\n    }\n\n    /**\n     * @return A fast Lanczos approximation to the gamma function.\n     * @param z Argument.\n     * @exception ArithmeticException if the algorithm fails to converge.\n     * @see <a href=\"http://mathworld.wolfram.com/LanczosApproximation.html\">Lanczos Approximation</a>\n     */\n    private static double lanczos(double z) {\n        double sum = 0.0;\n        for (int i = LANCZOS.length - 1; i > 0; --i) {\n            sum += LANCZOS[i] / (z + i);\n        }\n        return sum + LANCZOS[0] + 0.5 * Math.log(2 * Math.PI / z);\n    }\n\n    /** Series constant. */\n    private static final double HALF_LOG_2_PI = 0.5 * FastMath.log(2.0 * FastMath.PI);\n\n    /** Lanczos gamma constants. */\n    static final double LANCZOS_G = 607.0 / 128.0;\n\n    /** Argument requiring a polynomial evaluation. */\n    static final double lanczosP = 0.5;\n\n    /** Maximum value that factorial can have before\n     * {@code Double.POSITIVE_INFINITY} is returned.\n     */\n    private static final int FACTORIAL_DOUBLE_LIMIT = 170;\n\n    /** Double values for the first factorials. */\n    private static final double[] FACT = new double[FACTORIAL_DOUBLE_LIMIT + 1];\n    static {\n        FACT[0] = 1.0;\n        for (int i = 1; i <= FACTORIAL_DOUBLE_LIMIT; i++) {\n            FACT[i] = FACT[i - 1] * i;\n        }\n    }\n\n    /**\n     * Computes the value of log(Gamma(x + 1)), accurate for large x.\n     * This implementation is based on the implementation in the\n     * Boost Math Library.\n     *\n     * @param x Argument.\n     * @return the value of {@code log(Gamma(x + 1))}.\n     */\n    public static double logGamma1p(double x) {\n        if (x < -0.5) {\n            throw new NumberFormatException(\"Argument \" + x +\n                \" is outside the valid range [-0.5,inf)\");\n        }\n        /*\n         * From the recurrence relation\n         *\n         * Gamma(x+1) = x*Gamma(x)\n         *\n         * we have\n         *\n         * log(Gamma(x+1)) = log(x) + log(Gamma(x))\n         *\n         * We use this formula directly in the cases where x >= 0.5.\n         * For x < 0.5, we rearrange the formula\n         *\n         * Gamma(x) = Gamma(x+1)/x\n         *\n         * to give\n         *\n         * log(Gamma(x)) = logGamma(x+1) - log(x)\n         *\n         * We then use the following formula for logGamma(x+1):\n         *\n         * logGamma(x+1) = (x + 0.5)*log(x + 1) - (x + 1) +\n         *                  0.5*log(2*pi) + 1/(12(x+1)) - 1/(360(x+1)^3) + ...\n         *\n         * (where the terms after 0.5*log(2*pi) are the terms of the\n         * B-series representation of logGamma).\n         *\n         * This formula is only valid for x >= -0.5. However, for x < -0.5, we\n         * are given x >= -1.5, and use the following formula to increase x\n         *\n         * Gamma(x + 1) = -x*Gamma(-x)\n         *\n         * to a suitable value greater than -0.5.\n         */\n        double ret;\n        double t;\n        if (x >= 0.5) {\n            return logGamma(x) - Math.log(x);\n        } else if (x >= -0.5) {\n            return logGammaB(x + 1) - Math.log(x + 1.0);\n        } else {\n            /*\n             * Original calculation:\n             *    double g = 4.7421875;\n             *    final double[] gab = {\n             *        -1.1368683772161603e-13,\n             *        2.7284841053187847e-12,\n             *        -3.8229041297263417e-10,\n             *        6.0486158027177679e-9,\n             *        -6.9388871886718732e-8,\n             *        -5.8481924273253642e-8,\n             *        1.6380154795229705e-6,\n             *        -2.4635611516369578e-6,\n             *        1.9940036796704124e-6,\n             *        -1.0624266888885457e-6,\n             *        3.8374242076189195e-7,\n             *        -9.2389822600406695e-8,\n             *        1.4087483124242948e-8,\n             *        -1.3320275820295053e-9,\n             *        6.6923582655716693e-11\n             *    };\n             *    t = x + 1.0;\n             *    ret = 0.5 * Math.log(2 * Math.PI) + (x + 0.5) * Math.log(t) - t;\n             *    for (int i = 0; i < gab.length; ++i) {\n             *        g += gab[i] / (x - i);\n             *    }\n             *    final double gl0 = 0.0833333333294263;\n             *    final double gl1 = 0.0027777777777015593;\n             *    final double gl2 = 0.0007936507935003509;\n             *    final double gl3 = 0.0005952380952382598;\n             *    final double gl4 = 0.0008417508417508321;\n             *    final double gl5 = 0.0019175269175266896;\n             *    final double gl6 = 0.0064102564102562643;\n             *    final double gl7 = 0.041666666666666574;\n             *    final double gl8 = 0.16666666666666666;\n             *    final double gl9 = 0.66666666666666663;\n             *    double z = x;\n             *    ret += g / x +\n             *         gl0 + z * (gl1 + z * (gl2 + z * (gl3 + z * (gl4 + z *\n             *         (gl5 + z * (gl6 + z * (gl7 + z * gl8))))))) / t;\n             *    return ret;\n             */\n            /*\n             * Improved calculation:\n             * We have a - 1.5 < -1.0.\n             * Thus, writing a = -1.5 - z,\n             * we perform the change of variable x = 1.5 - a = z + 1.5.  Note that\n             * x > 0.5.\n             */\n            t = 1.5 + x;\n            ret = logGamma(t) - Math.log(t);\n            final double coef3 = -1.0 / 360.0;\n            fina",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}