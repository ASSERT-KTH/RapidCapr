{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.CustomPassExecutionTime;\nimport com.google.javascript.jscomp.DiagnosticGroup;\nimport com.google.javascript.jscomp.DiagnosticType;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.jscomp.VariableMap;\nimport com.google.javascript.jscomp.parsing.Config;\n\nimport java.util.Iterator;\n\nclass Example {\n  private static final DiagnosticType WRONG_ARGUMENT_COUNT =\n        DiagnosticType.warning(\"JSC_WRONG_ARGUMENT_COUNT\",\n                                \"Function {0} called with {1} argument(s). \" +\n                                \"Function requires at least {2}{3}.\");\n\n  private final AbstractCompiler compiler;\n  private final Validator validator;\n  private final Config config;\n  private final VariableMap variableMap;\n\n  Example(AbstractCompiler compiler, CompilerOptions options,\n          VariableMap variableMap) {\n    this.compiler = compiler;\n    this.validator = new Validator(compiler, new TypeRegistry(options), options);\n    this.config = options.getParserConfig();\n    this.variableMap = variableMap;\n  }\n\n  void visitFunction(NodeTraversal t, Node function) {\n    if (compiler.getLifeCycleStage().isNormalized()) {\n      // Don't check \"normalized\" passes that run as part of the compilation\n      // pipeline, because those cannot generate invalid code; checking for\n      // errors in those cases would just add unnecessary overhead.\n      return;\n    }\n\n    FunctionType functionType = validator.getFunctionType(function);\n\n    // Handle function calls with no arguments.\n    if (functionType.getRequiredArity() == 0) {\n      return;\n    }\n\n    Node caller = t.getClosestHoistScope().getRootNode();\n    NodeTraversal callTrav = new NodeTraversal(compiler, new Callback() {\n      @Override\n      public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n        return n.isCall() ||\n            (n.isNew() && n.getLastChild().isQualifiedName()) ||\n            n.isTaggedTemplateLit() || n.isTemplateLit();\n      }\n\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isCall()) {\n          visitParameterList(t, n, functionType);\n        } else if (n.isNew() && n.getLastChild().isQualifiedName()) {\n          visitParameterList(t, n.getLastChild(), functionType);\n        } else {\n          visitChildren(t, n);\n        }\n      }\n    });\n    callTrav.traverse(caller);\n  }\n\n  private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n\n    while (arguments.hasNext() && parameters.hasNext()) {\n        parameter = parameters.next();\n        argument = arguments.next();\n        ordinal++;\n        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    if (functionType.hasRestFormals()) {\n        // This is a function that has varargs.\n        if (parameters.hasNext()) {\n            throw new RuntimeException(\"Invalid declaration of function type\");\n        }\n\n        while (arguments.hasNext()) {\n            argument = arguments.next();\n            ordinal++;\n            Node restType = functionType.getRestFormalsType();\n            validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(restType), call, ordinal);\n        }\n    } else {\n        // Check that the number of arguments matches the function signature.\n        int numArgs = call.getChildCount() - 1;\n        int minArgs = functionType.getMinArguments();\n        int maxArgs = functionType.getMaxArguments();\n        if (minArgs > numArgs || maxArgs < numArgs) {\n            report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false),\n                String.valueOf(numArgs), String.valueOf(minArgs),\n                maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n        }\n    }\n  }\n\n  private JSType getJSType(Node n) {\n    JSTypeExpression typeExpr = validator.getTypeOfExpression(n);\n    if (typeExpr == null) {\n      return null;\n    }\n    return typeExpr.evaluate(null, validator.getTypeRegistry());\n  }\n\n  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType,\n                      Object... arguments) {\n    t.report(n, diagnosticType, arguments);\n  }\n}\n\nclass Validator {\n  private final TypeCheck typeCheck;\n\n  Validator(AbstractCompiler compiler, TypeRegistry registry, CompilerOptions options) {\n    typeCheck = new TypeCheck(compiler, registry, options, null);\n  }\n\n  public void expectArgumentMatchesParameter(NodeTraversal t, Node arg, JSType argType,\n                                             JSType paramType, Node call, int ordinal) {\n    if (argType == null) {\n      return;\n    }\n\n    // Special case for objects with call signatures, like function instances;\n    // we compare the callee types instead of the instance type in that case.\n    FunctionType expectedFnType = null;\n    if (paramType.isConstructor() && argType.isInstanceType()) {\n      expectedFnType = paramType.getConstructorFunction();\n    } else if (paramType.isFunctionType()) {\n      expectedFnType = paramType.toMaybeFunctionType();\n    }\n\n    if (expectedFnType != null) {\n      JSType actualFnType = getJSType(arg).autobox().restrictByNotNullOrUndefined();\n      if (actualFnType.isFunctionType() || actualFnType.isConstructor()) {\n        if (!expectedFnType.isEquivalentTo(actualFnType)) {\n          report(t, call, MISTYPED_ASSIGN_RHS, ordinal, expectedFnType.toString(),\n              actualFnType.toString());\n          return;\n        }\n      } else {\n        // fall through to normal comparison below\n      }\n    }\n\n    if (paramType.isTemplatizedType() && argType.isConcreteType()) {\n      // We want to compare the resolvedTemplated type to the actual type.\n      JSTypeParameterMap typeMap = getTypeMap(paramType.toMaybeTemplatizedType().getReferenceName(), argType.toMaybeObjectType());\n      JSType resolvedType = paramType.toMaybeTemplatizedType().instantiateGenerics(typeMap);\n      // We may find the resolved type by using JSType#getResolvedType, but this version of Closure\n      // only supports JSType#getResolvedType on the UNIVERSE instance and we are not running through\n      // that code path.\n      if (!(argType.isSubtype(resolvedType) || resolvedType.isSubtype(argType))\n          && paramType.toMaybeTemplatizedType().getReferenceName() != null) {\n        report(t, arg.getParent(), INVALID_ARGUMENT_TYPE_TEMPLATE,\n            argType.toString(), expectedTemplatizedType(paramType.toMaybeTemplatizedType().getReferenceName(), resolvedType));\n        return;\n      }\n    }\n\n    if (!(argType.isSubtype(paramType) || paramType.isSubtype(argType))) {\n      report(t, arg.getParent(), MISTYPED_ASSIGN_RHS, ordinal, paramType.toString(),\n          argType.toString());\n    }\n  }\n\n  private static JSTypeParameterMap getTypeMap(String name, ObjectType objType) {\n    JSTypeParameterMap.Builder builder =\n        JSTypeParameterMap.builder(name);\n    if (objType != null) {\n      for (String pname : objType.getPropertyNames()) {\n        builder.addBinding(pname,\n            objType.getPropertyType(pname));\n      }\n    }\n    return builder.build();\n  }\n\n  private JSType getJSType(Node n) {\n    JSTypeExpression expr = getTypeOfExpression(n);\n    return expr == null ? null : expr.evaluate(null, getTypeRegistry());\n  }\n\n  private JSTypeExpression getTypeOfExpression(Node n) {\n    return typeCheck.getTypeIgnoringImplicitCast(n);\n  }\n\n  private TypeRegistry getTypeRegistry() {\n    return typeCheck.getRegistry();\n  }\n\n  public String getReadableJSTypeName(Node n, boolean expandObjectTypes) {\n    JSTypeExpression typeExpr = getTypeOfExpression(n);\n    if (typeExpr != null) {\n      JSType type = typeExpr.evaluate(null, getTypeRegistry());\n      return type == null ? \"?\" : type.toAnnotationString(expandObjectTypes);\n    }\n    return \"?\";\n  }\n\n  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType,\n                      Object... arguments) {\n    String msg = diagnosticType.format(arguments);\n    t.getCompiler().report(JSError.make(n, diagnosticType, msg));\n  }\n\n  FunctionType getFunctionType(Node function) {\n    return getTypeOfExpression(function).evaluate(null, getTypeRegistry()).toMaybeFunctionType();\n  }\n\n  private static final DiagnosticType INVALID_ARGUMENT_TYPE_TEMPLATE =\n      DiagnosticType.warning(\"JSC_INVALID_ARGUMENT_TYPE_TEMPLATE\",\n          \"Invalid type for argument {0}. Expected: {1}.\");\n\n  private static final DiagnosticType MISTYPED_ASSIGN_RHS =\n      DiagnosticType.warning(\"JSC_MISTYPED_ASSIGN_RHS\",\n          \"mismatch of the {0} argument to function {1}. \" +\n              \"Expected: {2}, actual: {3}\");\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 8077e0d8..348f5080 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1396,8 +1396,80 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n   /**\n    * Visits the parameters of a CALL or a NEW node.\n    */\n-  private void visitParameterList(NodeTraversal t, Node call,\n-      FunctionType functionType) {\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.AbstractCompiler.LifeCycleStage;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.CustomPassExecutionTime;\n+import com.google.javascript.jscomp.DiagnosticGroup;\n+import com.google.javascript.jscomp.DiagnosticType;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.jscomp.VariableMap;\n+import com.google.javascript.jscomp.parsing.Config;\n+\n+import java.util.Iterator;\n+\n+class Example {\n+  private static final DiagnosticType WRONG_ARGUMENT_COUNT =\n+        DiagnosticType.warning(\"JSC_WRONG_ARGUMENT_COUNT\",\n+                                \"Function {0} called with {1} argument(s). \" +\n+                                \"Function requires at least {2}{3}.\");\n+\n+  private final AbstractCompiler compiler;\n+  private final Validator validator;\n+  private final Config config;\n+  private final VariableMap variableMap;\n+\n+  Example(AbstractCompiler compiler, CompilerOptions options,\n+          VariableMap variableMap) {\n+    this.compiler = compiler;\n+    this.validator = new Validator(compiler, new TypeRegistry(options), options);\n+    this.config = options.getParserConfig();\n+    this.variableMap = variableMap;\n+  }\n+\n+  void visitFunction(NodeTraversal t, Node function) {\n+    if (compiler.getLifeCycleStage().isNormalized()) {\n+      // Don't check \"normalized\" passes that run as part of the compilation\n+      // pipeline, because those cannot generate invalid code; checking for\n+      // errors in those cases would just add unnecessary overhead.\n+      return;\n+    }\n+\n+    FunctionType functionType = validator.getFunctionType(function);\n+\n+    // Handle function calls with no arguments.\n+    if (functionType.getRequiredArity() == 0) {\n+      return;\n+    }\n+\n+    Node caller = t.getClosestHoistScope().getRootNode();\n+    NodeTraversal callTrav = new NodeTraversal(compiler, new Callback() {\n+      @Override\n+      public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n+        return n.isCall() ||\n+            (n.isNew() && n.getLastChild().isQualifiedName()) ||\n+            n.isTaggedTemplateLit() || n.isTemplateLit();\n+      }\n+\n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (n.isCall()) {\n+          visitParameterList(t, n, functionType);\n+        } else if (n.isNew() && n.getLastChild().isQualifiedName()) {\n+          visitParameterList(t, n.getLastChild(), functionType);\n+        } else {\n+          visitChildren(t, n);\n+        }\n+      }\n+    });\n+    callTrav.traverse(caller);\n+  }\n+\n+  private void visitParameterList(NodeTraversal t, Node call, FunctionType functionType) {\n     Iterator<Node> arguments = call.children().iterator();\n     arguments.next(); // skip the function name\n \n@@ -1405,30 +1477,163 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n-    while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n-      // If there are no parameters left in the list, then the while loop\n-      // above implies that this must be a var_args function.\n+\n+    while (arguments.hasNext() && parameters.hasNext()) {\n         parameter = parameters.next();\n-      argument = arguments.next();\n-      ordinal++;\n+        argument = arguments.next();\n+        ordinal++;\n+        validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\n+    }\n+\n+    if (functionType.hasRestFormals()) {\n+        // This is a function that has varargs.\n+        if (parameters.hasNext()) {\n+            throw new RuntimeException(\"Invalid declaration of function type\");\n+        }\n+\n+        while (arguments.hasNext()) {\n+            argument = arguments.next();\n+            ordinal++;\n+            Node restType = functionType.getRestFormalsType();\n+            validator.expectArgumentMatchesParameter(t, argument, getJSType(argument), getJSType(restType), call, ordinal);\n+        }\n+    } else {\n+        // Check that the number of arguments matches the function signature.\n+        int numArgs = call.getChildCount() - 1;\n+        int minArgs = functionType.getMinArguments();\n+        int maxArgs = functionType.getMaxArguments();\n+        if (minArgs > numArgs || maxArgs < numArgs) {\n+            report(t, call, WRONG_ARGUMENT_COUNT, validator.getReadableJSTypeName(call.getFirstChild(), false),\n+                String.valueOf(numArgs), String.valueOf(minArgs),\n+                maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+        }\n+    }\n+  }\n+\n+  private JSType getJSType(Node n) {\n+    JSTypeExpression typeExpr = validator.getTypeOfExpression(n);\n+    if (typeExpr == null) {\n+      return null;\n+    }\n+    return typeExpr.evaluate(null, validator.getTypeRegistry());\n+  }\n+\n+  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType,\n+                      Object... arguments) {\n+    t.report(n, diagnosticType, arguments);\n+  }\n+}\n+\n+class Validator {\n+  private final TypeCheck typeCheck;\n+\n+  Validator(AbstractCompiler compiler, TypeRegistry registry, CompilerOptions options) {\n+    typeCheck = new TypeCheck(compiler, registry, options, null);\n+  }\n+\n+  public void expectArgumentMatchesParameter(NodeTraversal t, Node arg, JSType argType,\n+                                             JSType paramType, Node call, int ordinal) {\n+    if (argType == null) {\n+      return;\n+    }\n+\n+    // Special case for objects with call signatures, like function instances;\n+    // we compare the callee types instead of the instance type in that case.\n+    FunctionType expectedFnType = null;\n+    if (paramType.isConstructor() && argType.isInstanceType()) {\n+      expectedFnType = paramType.getConstructorFunction();\n+    } else if (paramType.isFunctionType()) {\n+      expectedFnType = paramType.toMaybeFunctionType();\n+    }\n+\n+    if (expectedFnType != null) {\n+      JSType actualFnType = getJSType(arg).autobox().restrictByNotNullOrUndefined();\n+      if (actualFnType.isFunctionType() || actualFnType.isConstructor()) {\n+        if (!expectedFnType.isEquivalentTo(actualFnType)) {\n+          report(t, call, MISTYPED_ASSIGN_RHS, ordinal, expectedFnType.toString(),\n+              actualFnType.toString());\n+          return;\n+        }\n+      } else {\n+        // fall through to normal comparison below\n+      }\n+    }\n+\n+    if (paramType.isTemplatizedType() && argType.isConcreteType()) {\n+      // We want to compare the resolvedTemplated type to the actual type.\n+      JSTypeParameterMap typeMap = getTypeMap(paramType.toMaybeTemplatizedType().getReferenceName(), argType.toMaybeObjectType());\n+      JSType resolvedType = paramType.toMaybeTemplatizedType().instantiateGenerics(typeMap);\n+      // We may find the resolved type by using JSType#getResolvedType, but this version of Closure\n+      // only supports JSType#getResolvedType on the UNIVERSE instance and we are not running through\n+      // that code path.\n+      if (!(argType.isSubtype(resolvedType) || resolvedType.isSubtype(argType))\n+          && paramType.toMaybeTemplatizedType().getReferenceName() != null) {\n+        report(t, arg.getParent(), INVALID_ARGUMENT_TYPE_TEMPLATE,\n+            argType.toString(), expectedTemplatizedType(paramType.toMaybeTemplatizedType().getReferenceName(), resolvedType));\n+        return;\n+      }\n+    }\n \n-      validator.expectArgumentMatchesParameter(t, argument,\n-          getJSType(argument), getJSType(parameter), call, ordinal);\n+    if (!(argType.isSubtype(paramType) || paramType.isSubtype(argType))) {\n+      report(t, arg.getParent(), MISTYPED_ASSIGN_RHS, ordinal, paramType.toString(),\n+          argType.toString());\n     }\n+  }\n+\n+  private static JSTypeParameterMap getTypeMap(String name, ObjectType objType) {\n+    JSTypeParameterMap.Builder builder =\n+        JSTypeParameterMap.builder(name);\n+    if (objType != null) {\n+      for (String pname : objType.getPropertyNames()) {\n+        builder.addBinding(pname,\n+            objType.getPropertyType(pname));\n+      }\n+    }\n+    return builder.build();\n+  }\n+\n+  private JSType getJSType(Node n) {\n+    JSTypeExpression expr = getTypeOfExpression(n);\n+    return expr == null ? null : expr.evaluate(null, getTypeRegistry());\n+  }\n+\n+  private JSTypeExpression getTypeOfExpression(Node n) {\n+    return typeCheck.getTypeIgnoringImplicitCast(n);\n+  }\n \n-    int numArgs = call.getChildCount() - 1;\n-    int minArgs = functionType.getMinArguments();\n-    int maxArgs = functionType.getMaxArguments();\n-    if (minArgs > numArgs || maxArgs < numArgs) {\n-      report(t, call, WRONG_ARGUMENT_COUNT,\n-              validator.getReadableJSTypeName(call.getFirstChild(), false),\n-              String.valueOf(numArgs), String.valueOf(minArgs),\n-              maxArgs != Integer.MAX_VALUE ?\n-              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+  private TypeRegistry getTypeRegistry() {\n+    return typeCheck.getRegistry();\n+  }\n+\n+  public String getReadableJSTypeName(Node n, boolean expandObjectTypes) {\n+    JSTypeExpression typeExpr = getTypeOfExpression(n);\n+    if (typeExpr != null) {\n+      JSType type = typeExpr.evaluate(null, getTypeRegistry());\n+      return type == null ? \"?\" : type.toAnnotationString(expandObjectTypes);\n     }\n+    return \"?\";\n+  }\n+\n+  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType,\n+                      Object... arguments) {\n+    String msg = diagnosticType.format(arguments);\n+    t.getCompiler().report(JSError.make(n, diagnosticType, msg));\n   }\n \n+  FunctionType getFunctionType(Node function) {\n+    return getTypeOfExpression(function).evaluate(null, getTypeRegistry()).toMaybeFunctionType();\n+  }\n+\n+  private static final DiagnosticType INVALID_ARGUMENT_TYPE_TEMPLATE =\n+      DiagnosticType.warning(\"JSC_INVALID_ARGUMENT_TYPE_TEMPLATE\",\n+          \"Invalid type for argument {0}. Expected: {1}.\");\n+\n+  private static final DiagnosticType MISTYPED_ASSIGN_RHS =\n+      DiagnosticType.warning(\"JSC_MISTYPED_ASSIGN_RHS\",\n+          \"mismatch of the {0} argument to function {1}. \" +\n+              \"Expected: {2}, actual: {3}\");\n+}\n+\n   /**\n    * Visits a RETURN node.\n    *",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}