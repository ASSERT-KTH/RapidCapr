{
    "patch": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    // If the condition is a literal, let other optimizations remove useless code\n    if (NodeUtil.isLiteralValue(cond, true)) {\n        return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (!elseBranch.isNull()) {\n        tryRemoveRepeatedStatements(n);\n\n        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n            n.replaceChild(cond, cond.removeFirstChild());\n            n.removeChild(thenBranch);\n            n.addChildToBack(thenBranch);\n            return n;\n        }\n\n        // Transform if (x) return a; else return b; into return x ? a : b;\n        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n            Node thenExpr = getBlockReturnExpression(thenBranch);\n            Node elseExpr = getBlockReturnExpression(elseBranch);\n            n.removeChild(cond);\n            thenExpr.detachFromParent();\n            elseExpr.detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node returnNode = IR.returnNode(hookNode);\n            parent.replaceChild(n, returnNode);\n            return returnNode;\n        }\n\n        boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n        boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n        // if (x) foo(); else bar() -> x ? foo() : bar()\n        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n            Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n            Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n            if (thenOp.getType() == elseOp.getType()) {\n                if (NodeUtil.isAssignmentOp(thenOp)) {\n                    Node lhs = thenOp.getFirstChild();\n                    if (areNodesEqualForInlining(lhs, elseOp.getFirstChild())\n                            && !mayEffectMutableState(lhs)) {\n                        n.removeChild(cond);\n                        Node assignName = thenOp.removeFirstChild();\n                        Node thenExpr = thenOp.removeFirstChild();\n                        Node elseExpr = elseOp.getLastChild();\n                        elseOp.removeChild(elseExpr);\n                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                        Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                        Node expr = NodeUtil.newExpr(assign);\n                        parent.replaceChild(n, expr);\n                        return expr;\n                    }\n                }\n                n.removeChild(cond);\n                thenOp.detachFromParent();\n                elseOp.detachFromParent();\n                Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n                parent.replaceChild(n, expr);\n                return expr;\n            }\n        }\n\n        thenBranchIsExpressionBlock = isExpressionResultBlock(thenBranch);\n        elseBranchIsExpressionBlock = isExpressionResultBlock(elseBranch);\n\n        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n            Node thenExpr = getBlockExpression(thenBranch).getFirstChild();\n            Node elseExpr = getBlockExpression(elseBranch).getFirstChild();\n            if (thenExpr.isName() && elseExpr.isName() && thenExpr.getString().equals(elseExpr.getString())) {\n                Node newAssign = IR.assign(thenExpr.cloneNode(), IR.hook(cond, thenExpr.cloneNode(), elseExpr.cloneNode())\n                        .srcref(n)).srcref(n);\n                newAssign.putBooleanProp(Node.DIRECT_THIS, thenExpr.getBooleanProp(Node.DIRECT_THIS));\n                n.removeChild(cond);\n                Node expr = NodeUtil.newExpr(newAssign);\n                parent.replaceChild(n, expr);\n                return expr;\n            }\n        }\n\n        n.detachChildren();\n        Node booleanExpr = new Node(Token.HOOK, cond, thenBranch, elseBranch).srcref(n);\n        if (n.hasXChildren(2)) {\n            // if we have \"return expr ? a : b;\", just return the hook itself\n            if (NodeUtil.isImmutableValue(n.getFirstChild())) {\n                parent.replaceChild(n, booleanExpr);\n                return booleanExpr;\n            }\n            // expressions like a = foo() ? bar() : baz();\n            Node opNode = n.getLastChild();\n            boolean isExprResult = opNode.isExprResult();\n            if (!isExprResult) {\n                // ensure opNode is an expression\n                opNode = IR.exprResult(opNode).srcref(opNode);\n                n.replaceChild(n.getLastChild(), opNode);\n            }\n            opNode.replaceChild(0, booleanExpr);\n            if (!isExprResult) {\n                // remove the expression-result parent we added above\n                Node exprNode = opNode.getFirstChild();\n                n.replaceChild(opNode, exprNode);\n                exprNode.setBooleanProp(Node.FREE_CALL, true);\n            }\n            return booleanExpr;\n        }\n\n        // Ensure that code like \"(foo() ? true : false) ? bar() : baz();\" has parens.\n        if (n.getParent().isCall()) {\n            Node expr = new Node(Token.TRUE);\n            Node hook = new Node(Token.HOOK, cond.cloneNode(), thenBranch.cloneNode(), elseBranch.cloneNode());\n            hook.srcref(n);\n            Node newNode = new Node(Token.HOOK, expr, hook, IR.falseNode());\n            parent.replaceChild(n, newNode);\n            return newNode;\n        }\n\n        Node expr = NodeUtil.newExpr(booleanExpr);\n        parent.replaceChild(n, expr);\n        return expr;\n    }\n\n    // If we have an expression as the then clause, then use the conditional operator.\n    if (isFoldableExpressBlock(thenBranch) && !late) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!isPropertyAssignmentInExpression(expr)) {\n            if (cond.isNot()) {\n                // if (!x) foo(); -> x || foo();\n                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n                Node newExpr = NodeUtil.newExpr(or);\n                parent.replaceChild(n, newExpr);\n                return newExpr;\n            }\n\n            // if (x) foo(); -> x && foo();\n            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n            Node newExpr = NodeUtil.newExpr(and);\n            parent.replaceChild(n, newExpr);\n            return newExpr;\n        }\n    }\n\n    return n;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..df05a814 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -633,239 +633,154 @@ class PeepholeSubstituteAlternateSyntax\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n-  private Node tryMinimizeIf(Node n) {\n-\n+private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n-\n     Node cond = n.getFirstChild();\n \n-    /* If the condition is a literal, we'll let other\n-     * optimizations try to remove useless code.\n-     */\n+    // If the condition is a literal, let other optimizations remove useless code\n     if (NodeUtil.isLiteralValue(cond, true)) {\n-      return n;\n+        return n;\n     }\n \n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n-    if (elseBranch == null) {\n-      if (isFoldableExpressBlock(thenBranch)) {\n-        Node expr = getBlockExpression(thenBranch);\n-        if (!late && isPropertyAssignmentInExpression(expr)) {\n-          // Keep opportunities for CollapseProperties such as\n-          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-          // until CollapseProperties has been run.\n-          return n;\n-        }\n+    if (!elseBranch.isNull()) {\n+        tryRemoveRepeatedStatements(n);\n \n-        if (cond.isNot()) {\n-          // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n+        if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n+            n.replaceChild(cond, cond.removeFirstChild());\n+            n.removeChild(thenBranch);\n+            n.addChildToBack(thenBranch);\n             return n;\n-          }\n-\n-          Node or = IR.or(\n-              cond.removeFirstChild(),\n-              expr.removeFirstChild()).srcref(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          reportCodeChange();\n-\n-          return newExpr;\n         }\n \n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses is worth the change even if\n-          // there is no immediate code size win. However, two extra pair of\n-          // {}, we would have to think twice. (unless we know for sure the\n-          // we can further optimize its parent.\n-          return n;\n+        // Transform if (x) return a; else return b; into return x ? a : b;\n+        if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+            Node thenExpr = getBlockReturnExpression(thenBranch);\n+            Node elseExpr = getBlockReturnExpression(elseBranch);\n+            n.removeChild(cond);\n+            thenExpr.detachFromParent();\n+            elseExpr.detachFromParent();\n+            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+            Node returnNode = IR.returnNode(hookNode);\n+            parent.replaceChild(n, returnNode);\n+            return returnNode;\n         }\n \n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n-        reportCodeChange();\n-\n-        return newExpr;\n-      } else {\n+        boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n+        boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n+\n+        // if (x) foo(); else bar() -> x ? foo() : bar()\n+        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+            Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+            Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+            if (thenOp.getType() == elseOp.getType()) {\n+                if (NodeUtil.isAssignmentOp(thenOp)) {\n+                    Node lhs = thenOp.getFirstChild();\n+                    if (areNodesEqualForInlining(lhs, elseOp.getFirstChild())\n+                            && !mayEffectMutableState(lhs)) {\n+                        n.removeChild(cond);\n+                        Node assignName = thenOp.removeFirstChild();\n+                        Node thenExpr = thenOp.removeFirstChild();\n+                        Node elseExpr = elseOp.getLastChild();\n+                        elseOp.removeChild(elseExpr);\n+                        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                        Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n+                        Node expr = NodeUtil.newExpr(assign);\n+                        parent.replaceChild(n, expr);\n+                        return expr;\n+                    }\n+                }\n+                n.removeChild(cond);\n+                thenOp.detachFromParent();\n+                elseOp.detachFromParent();\n+                Node expr = IR.exprResult(IR.hook(cond, thenOp, elseOp).srcref(n));\n+                parent.replaceChild(n, expr);\n+                return expr;\n+            }\n+        }\n \n-        // Try to combine two IF-ELSE\n-        if (NodeUtil.isStatementBlock(thenBranch) &&\n-            thenBranch.hasOneChild()) {\n-          Node innerIf = thenBranch.getFirstChild();\n-\n-          if (innerIf.isIf()) {\n-            Node innerCond = innerIf.getFirstChild();\n-            Node innerThenBranch = innerCond.getNext();\n-            Node innerElseBranch = innerThenBranch.getNext();\n-\n-            if (innerElseBranch == null &&\n-                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n-              n.detachChildren();\n-              n.addChildToBack(\n-                  IR.and(\n-                      cond,\n-                      innerCond.detachFromParent())\n-                      .srcref(cond));\n-              n.addChildrenToBack(innerThenBranch.detachFromParent());\n-              reportCodeChange();\n-              // Not worth trying to fold the current IF-ELSE into && because\n-              // the inner IF-ELSE wasn't able to be folded into && anyways.\n-              return n;\n+        thenBranchIsExpressionBlock = isExpressionResultBlock(thenBranch);\n+        elseBranchIsExpressionBlock = isExpressionResultBlock(elseBranch);\n+\n+        if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+            Node thenExpr = getBlockExpression(thenBranch).getFirstChild();\n+            Node elseExpr = getBlockExpression(elseBranch).getFirstChild();\n+            if (thenExpr.isName() && elseExpr.isName() && thenExpr.getString().equals(elseExpr.getString())) {\n+                Node newAssign = IR.assign(thenExpr.cloneNode(), IR.hook(cond, thenExpr.cloneNode(), elseExpr.cloneNode())\n+                        .srcref(n)).srcref(n);\n+                newAssign.putBooleanProp(Node.DIRECT_THIS, thenExpr.getBooleanProp(Node.DIRECT_THIS));\n+                n.removeChild(cond);\n+                Node expr = NodeUtil.newExpr(newAssign);\n+                parent.replaceChild(n, expr);\n+                return expr;\n             }\n-          }\n         }\n-      }\n \n-      return n;\n-    }\n+        n.detachChildren();\n+        Node booleanExpr = new Node(Token.HOOK, cond, thenBranch, elseBranch).srcref(n);\n+        if (n.hasXChildren(2)) {\n+            // if we have \"return expr ? a : b;\", just return the hook itself\n+            if (NodeUtil.isImmutableValue(n.getFirstChild())) {\n+                parent.replaceChild(n, booleanExpr);\n+                return booleanExpr;\n+            }\n+            // expressions like a = foo() ? bar() : baz();\n+            Node opNode = n.getLastChild();\n+            boolean isExprResult = opNode.isExprResult();\n+            if (!isExprResult) {\n+                // ensure opNode is an expression\n+                opNode = IR.exprResult(opNode).srcref(opNode);\n+                n.replaceChild(n.getLastChild(), opNode);\n+            }\n+            opNode.replaceChild(0, booleanExpr);\n+            if (!isExprResult) {\n+                // remove the expression-result parent we added above\n+                Node exprNode = opNode.getFirstChild();\n+                n.replaceChild(opNode, exprNode);\n+                exprNode.setBooleanProp(Node.FREE_CALL, true);\n+            }\n+            return booleanExpr;\n+        }\n \n-    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n-     * peephole optimization. This should probably get moved to another pass.\n-     */\n-    tryRemoveRepeatedStatements(n);\n-\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      reportCodeChange();\n-      return n;\n-    }\n+        // Ensure that code like \"(foo() ? true : false) ? bar() : baz();\" has parens.\n+        if (n.getParent().isCall()) {\n+            Node expr = new Node(Token.TRUE);\n+            Node hook = new Node(Token.HOOK, cond.cloneNode(), thenBranch.cloneNode(), elseBranch.cloneNode());\n+            hook.srcref(n);\n+            Node newNode = new Node(Token.HOOK, expr, hook, IR.falseNode());\n+            parent.replaceChild(n, newNode);\n+            return newNode;\n+        }\n \n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-      Node thenExpr = getBlockReturnExpression(thenBranch);\n-      Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n-                                .srcref(n));\n-      parent.replaceChild(n, returnNode);\n-      reportCodeChange();\n-      return returnNode;\n+        Node expr = NodeUtil.newExpr(booleanExpr);\n+        parent.replaceChild(n, expr);\n+        return expr;\n     }\n \n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-      if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n-        if (NodeUtil.isAssignmentOp(thenOp)) {\n-          Node lhs = thenOp.getFirstChild();\n-          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n-            reportCodeChange();\n+    // If we have an expression as the then clause, then use the conditional operator.\n+    if (isFoldableExpressBlock(thenBranch) && !late) {\n+        Node expr = getBlockExpression(thenBranch);\n+        if (!isPropertyAssignmentInExpression(expr)) {\n+            if (cond.isNot()) {\n+                // if (!x) foo(); -> x || foo();\n+                Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n+                Node newExpr = NodeUtil.newExpr(or);\n+                parent.replaceChild(n, newExpr);\n+                return newExpr;\n+            }\n \n-            return expr;\n-          }\n+            // if (x) foo(); -> x && foo();\n+            Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n+            Node newExpr = NodeUtil.newExpr(and);\n+            parent.replaceChild(n, newExpr);\n+            return newExpr;\n         }\n-      }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n-      reportCodeChange();\n-      return expr;\n-    }\n-\n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n-        return var;\n-      }\n-\n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n-\n-        return var;\n-      }\n     }\n \n     return n;\n-  }\n+}\n \n   /**\n    * Try to remove duplicate statements from IF blocks. For example:",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}