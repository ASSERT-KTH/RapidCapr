{
    "patch": "    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n            Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n            if (candidate != null) {\n                field.setAccessible(true);\n                // Find the field with the most compatible type\n                Class<?> candidateClass = candidate.getClass();\n                Field bestField = null;\n                int bestDistance = Integer.MAX_VALUE;\n                for (Field f : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n                    Class<?> fieldType = f.getType();\n                    if (fieldType.isAssignableFrom(candidateClass)) {\n                        int distance = getFieldDistance(fieldType, candidateClass);\n                        if (distance < bestDistance) {\n                            bestDistance = distance;\n                            bestField = f;\n                        }\n                    }\n                }\n                if (bestField != null) {\n                    try {\n                        bestField.setAccessible(true);\n                        bestField.set(fieldInstance, candidate);\n                    } catch (IllegalAccessException e) {\n                        e.printStackTrace();\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Computes the \"distance\" between two classes. This is used to find the most compatible field type.\n     * For example, the distance between Integer and Number is 1, and the distance between Object and String is 2.\n     * If a class is a subclass of another class, the distance is increased by 1.\n     * @param superClass The super class to which the distance is to be calculated\n     * @param subClass The subclass for which the distance is to be calculated\n     * @return The distance between the classes\n     */\n    private int getFieldDistance(Class<?> superClass, Class<?> subClass) {\n        int distance = 0;\n        while (subClass != null && !superClass.isAssignableFrom(subClass)) {\n            subClass = subClass.getSuperclass();\n            distance++;\n        }\n        return distance;\n    }\n\n    /**\n     * Returns a list of all non-static, non-final instance fields declared in the given class and its superclasses.\n     * The fields are returned in the order in which they are declared.\n     * @param clazz The class for which to get the fields\n     * @return The list of fields\n     */\n    private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n        List<Field> fields = new ArrayList<>();\n        while (clazz != null) {\n            for (Field field : clazz.getDeclaredFields()) {\n                if (!Modifier.isStatic(field.getModifiers()) && !Modifier.isFinal(field.getModifiers())) {\n                    field.setAccessible(true);\n                    fields.add(field);\n                }\n            }\n            clazz = clazz.getSuperclass();\n        }\n        return fields;\n    }",
    "patch_diff": "diff --git a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\nindex 213ebf351..e7fc586b5 100644\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n@@ -88,9 +88,76 @@ public class DefaultInjectionEngine {\n         }\n     }\n \n+\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n+        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+            Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n+            if (candidate != null) {\n+                field.setAccessible(true);\n+                // Find the field with the most compatible type\n+                Class<?> candidateClass = candidate.getClass();\n+                Field bestField = null;\n+                int bestDistance = Integer.MAX_VALUE;\n+                for (Field f : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n+                    Class<?> fieldType = f.getType();\n+                    if (fieldType.isAssignableFrom(candidateClass)) {\n+                        int distance = getFieldDistance(fieldType, candidateClass);\n+                        if (distance < bestDistance) {\n+                            bestDistance = distance;\n+                            bestField = f;\n+                        }\n+                    }\n+                }\n+                if (bestField != null) {\n+                    try {\n+                        bestField.setAccessible(true);\n+                        bestField.set(fieldInstance, candidate);\n+                    } catch (IllegalAccessException e) {\n+                        e.printStackTrace();\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    /**\n+     * Computes the \"distance\" between two classes. This is used to find the most compatible field type.\n+     * For example, the distance between Integer and Number is 1, and the distance between Object and String is 2.\n+     * If a class is a subclass of another class, the distance is increased by 1.\n+     * @param superClass The super class to which the distance is to be calculated\n+     * @param subClass The subclass for which the distance is to be calculated\n+     * @return The distance between the classes\n+     */\n+    private int getFieldDistance(Class<?> superClass, Class<?> subClass) {\n+        int distance = 0;\n+        while (subClass != null && !superClass.isAssignableFrom(subClass)) {\n+            subClass = subClass.getSuperclass();\n+            distance++;\n+        }\n+        return distance;\n+    }\n+\n+    /**\n+     * Returns a list of all non-static, non-final instance fields declared in the given class and its superclasses.\n+     * The fields are returned in the order in which they are declared.\n+     * @param clazz The class for which to get the fields\n+     * @return The list of fields\n+     */\n+    private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n+        List<Field> fields = new ArrayList<>();\n+        while (clazz != null) {\n+            for (Field field : clazz.getDeclaredFields()) {\n+                if (!Modifier.isStatic(field.getModifiers()) && !Modifier.isFinal(field.getModifiers())) {\n+                    field.setAccessible(true);\n+                    fields.add(field);\n+                }\n+            }\n+            clazz = clazz.getSuperclass();\n+        }\n+        return fields;\n+    }\n         }\n     }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}