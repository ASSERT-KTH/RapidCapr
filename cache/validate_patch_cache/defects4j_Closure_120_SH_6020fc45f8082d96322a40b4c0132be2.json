{
    "patch": "        if (ref == null) {\n            return false;\n        }\n\n        boolean isAssignedOnce = true;\n        Set<BasicBlock> visited = new HashSet<>();\n        BasicBlock block = ref.getBasicBlock();\n        Deque<BasicBlock> stack = new ArrayDeque<>();\n        stack.push(block);\n\n        while (!stack.isEmpty()) {\n            BasicBlock currentBlock = stack.pop();\n            if (!visited.contains(currentBlock)) {\n                visited.add(currentBlock);\n                for (BasicBlock successor : currentBlock.getSuccessors()) {\n                    if (successor.getPredecessors().size() == 1) {\n                        List<Node> nodes = successor.getNodes();\n                        for (Node node : nodes) {\n                            if (node.isAssign()) {\n                                List<Node> lhsNodes = node.getFirstChild().flatten();\n                                for (Node lhsNode : lhsNodes) {\n                                    if (ref.matchesName(lhsNode.getString()) && !ref.getNode()\n                                            .isEqualNode(lhsNode)) {\n                                        isAssignedOnce = false;\n                                        break;\n                                    }\n                                }\n                                if (!isAssignedOnce) {\n                                    break;\n                                }\n                            }\n                        }\n                        if (isAssignedOnce) {\n                            stack.push(successor);\n                        } else {\n                            break;\n                        }\n                    } else {\n                        isAssignedOnce = false;\n                        break;\n                    }\n                }\n            }\n        }\n\n        return isAssignedOnce;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..32a994cd 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,52 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+        if (ref == null) {\n+            return false;\n+        }\n+\n+        boolean isAssignedOnce = true;\n+        Set<BasicBlock> visited = new HashSet<>();\n+        BasicBlock block = ref.getBasicBlock();\n+        Deque<BasicBlock> stack = new ArrayDeque<>();\n+        stack.push(block);\n+\n+        while (!stack.isEmpty()) {\n+            BasicBlock currentBlock = stack.pop();\n+            if (!visited.contains(currentBlock)) {\n+                visited.add(currentBlock);\n+                for (BasicBlock successor : currentBlock.getSuccessors()) {\n+                    if (successor.getPredecessors().size() == 1) {\n+                        List<Node> nodes = successor.getNodes();\n+                        for (Node node : nodes) {\n+                            if (node.isAssign()) {\n+                                List<Node> lhsNodes = node.getFirstChild().flatten();\n+                                for (Node lhsNode : lhsNodes) {\n+                                    if (ref.matchesName(lhsNode.getString()) && !ref.getNode()\n+                                            .isEqualNode(lhsNode)) {\n+                                        isAssignedOnce = false;\n+                                        break;\n+                                    }\n+                                }\n+                                if (!isAssignedOnce) {\n+                                    break;\n+                                }\n+                            }\n+                        }\n+                        if (isAssignedOnce) {\n+                            stack.push(successor);\n+                        } else {\n+                            break;\n+                        }\n+                    } else {\n+                        isAssignedOnce = false;\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+\n+        return isAssignedOnce;\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}