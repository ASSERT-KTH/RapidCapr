{
    "patch": "        final int maxIter = getMaximalIterationCount();\n        double x0 = min;\n        double x1 = initial;\n        double x2 = max;\n        double y0 = f.value(x0);\n        double y1 = f.value(x1);\n        double y2 = f.value(x2);\n\n        double z = Double.NaN;\n        double w = Double.NaN;\n        double previousBest = Double.POSITIVE_INFINITY;\n        double best = getAbsoluteAccuracy();\n\n        for (int i = 0; i < maxIter; ++i) {\n            final double denominator = (y2 - y1) * (y0 - y1) * (y2 - y0);\n            final double numerator = x1 * (y0 - y2) * (y1 - y2)\n                    + x2 * (y2 - y1) * (y0 - y1)\n                    + x0 * (y1 - y0) * (y2 - y1);\n            final double xp = numerator / denominator;\n\n            if (i > 0) {\n                if (Math.abs(xp - previousBest) < getRelativeAccuracy() * Math.max(Math.abs(previousBest), Math.abs(xp))) {\n                    // The root location is accurate enough or converged.\n                    setResult(previousBest, i);\n                    return getResult();\n                }\n\n                // Save the last two estimates and use the faster one to\n                // extrapolate.\n                final double delta1 = Math.abs(xp - previousBest);\n                final double delta2 = Math.abs(previousBest - w);\n                if (delta1 > 0.5 * delta2) {\n                    z = xp - 0.5 * (xp - w);\n                } else {\n                    z = previousBest + 0.5 * (xp - previousBest);\n                }\n            }\n\n            w  = previousBest; // Save the last root estimate.\n            previousBest = xp;\n\n            if (!isBracketing(x0, xp, x2)) {\n                throw new IllegalArgumentException();\n            }\n\n            double y = f.value(xp);\n            if (Math.abs(y) <= functionValueAccuracy) {\n                // The function value is small enough and converged.\n                setResult(xp, i);\n                return getResult();\n            }\n\n            // Update the data for new interval.\n            if (y * y2 < 0) {\n                x0 = x1;\n                y0 = y1;\n                x1 = x2;\n                y1 = y2;\n                x2 = xp;\n                y2 = y;\n            } else if (y * y0 < 0) {\n                x2 = x1;\n                y2 = y1;\n                x1 = x0;\n                y1 = y0;\n                x0 = xp;\n                y0 = y;\n            } else {\n                // update bounds\n                if (y > 0) {\n                    x2 = xp;\n                    y2 = y;\n                } else {\n                    x0 = xp;\n                    y0 = y;\n                }\n            }\n        }\n        throw new MaxIterationsExceededException(maxIter);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..0ce91f504 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,85 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        final int maxIter = getMaximalIterationCount();\n+        double x0 = min;\n+        double x1 = initial;\n+        double x2 = max;\n+        double y0 = f.value(x0);\n+        double y1 = f.value(x1);\n+        double y2 = f.value(x2);\n+\n+        double z = Double.NaN;\n+        double w = Double.NaN;\n+        double previousBest = Double.POSITIVE_INFINITY;\n+        double best = getAbsoluteAccuracy();\n+\n+        for (int i = 0; i < maxIter; ++i) {\n+            final double denominator = (y2 - y1) * (y0 - y1) * (y2 - y0);\n+            final double numerator = x1 * (y0 - y2) * (y1 - y2)\n+                    + x2 * (y2 - y1) * (y0 - y1)\n+                    + x0 * (y1 - y0) * (y2 - y1);\n+            final double xp = numerator / denominator;\n+\n+            if (i > 0) {\n+                if (Math.abs(xp - previousBest) < getRelativeAccuracy() * Math.max(Math.abs(previousBest), Math.abs(xp))) {\n+                    // The root location is accurate enough or converged.\n+                    setResult(previousBest, i);\n+                    return getResult();\n+                }\n+\n+                // Save the last two estimates and use the faster one to\n+                // extrapolate.\n+                final double delta1 = Math.abs(xp - previousBest);\n+                final double delta2 = Math.abs(previousBest - w);\n+                if (delta1 > 0.5 * delta2) {\n+                    z = xp - 0.5 * (xp - w);\n+                } else {\n+                    z = previousBest + 0.5 * (xp - previousBest);\n+                }\n+            }\n+\n+            w  = previousBest; // Save the last root estimate.\n+            previousBest = xp;\n+\n+            if (!isBracketing(x0, xp, x2)) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            double y = f.value(xp);\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                // The function value is small enough and converged.\n+                setResult(xp, i);\n+                return getResult();\n+            }\n+\n+            // Update the data for new interval.\n+            if (y * y2 < 0) {\n+                x0 = x1;\n+                y0 = y1;\n+                x1 = x2;\n+                y1 = y2;\n+                x2 = xp;\n+                y2 = y;\n+            } else if (y * y0 < 0) {\n+                x2 = x1;\n+                y2 = y1;\n+                x1 = x0;\n+                y1 = y0;\n+                x0 = xp;\n+                y0 = y;\n+            } else {\n+                // update bounds\n+                if (y > 0) {\n+                    x2 = xp;\n+                    y2 = y;\n+                } else {\n+                    x0 = xp;\n+                    y0 = y;\n+                }\n+            }\n+        }\n+        throw new MaxIterationsExceededException(maxIter);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: method isBracketing in class UnivariateRealSolverImpl cannot be applied to given types;",
    "test_result": "ERROR"
}