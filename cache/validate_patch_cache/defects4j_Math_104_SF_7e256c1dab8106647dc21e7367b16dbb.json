{
    "patch": "public static double regularizedGammaP(double a, double x) {\n    final double EPSILON = 10e-15;\n    if (Double.isNaN(a) || Double.isNaN(x)) {\n        return Double.NaN;\n    } \n    if (x < 0 || a <= 0) {\n        return Double.NaN;\n    }\n    if (x == 0) {\n        return 0;\n    }\n    double gammaValue = Gamma.gamma(a);\n    double seriesValue = regularizedGammaPSeries(a, x, EPSILON / gammaValue);\n    return Math.exp(-x + a * Math.log(x) - Math.log(gammaValue)) * seriesValue;\n}\n\npublic static double regularizedGammaQ(double a, double x) {\n    final double EPSILON = 10e-15;\n    if (Double.isNaN(a) || Double.isNaN(x)) {\n        return Double.NaN;\n    } \n    if (x < 0 || a <= 0) {\n        return Double.NaN;\n    }\n    if (x == 0) {\n        return 1;\n    }\n    double gammaValue = Gamma.gamma(a);\n    double seriesValue = regularizedGammaQSeries(a, x, EPSILON / gammaValue);\n    return Math.exp(-x + a * Math.log(x) - Math.log(gammaValue)) * seriesValue;\n}\n\nprivate static double regularizedGammaPSeries(double a, double x, double epsilon) {\n    double n = 1;\n    double ap = a;\n    double sum = 1 / a;\n    double del = sum;\n    while (Math.abs(del) > Math.abs(sum) * epsilon && ap < Double.MAX_VALUE * n) {\n        ap += 1;\n        del *= x / ap;\n        sum += del;\n        n += 1;\n    }\n    return sum * Math.exp(-x + a * Math.log(x) - Math.log(Gamma.gamma(a)));\n}\n\nprivate static double regularizedGammaQSeries(double a, double x, double epsilon) {\n    final double FPMIN = Double.MIN_VALUE / EPSILON;\n    double gs = FPMIN;\n    double ans = 0;\n    double sum = 1 / FPMIN;\n    double delta = sum;\n    while (Math.abs(delta) > Math.abs(sum) * epsilon) {\n        ++gs;\n        delta *= -x / gs;\n        sum += delta;\n        if (sum < 0) {\n            sum *= gs / (gs + a);\n            ans += sum;\n            sum = 1 / FPMIN;\n            gs = 0;\n        }\n    }\n    ans += sum;\n    return ans * Math.exp(-x + a * Math.log(x) - Math.log(Gamma.gamma(a)));\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bbb72fc1b 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,72 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x) {\n+    final double EPSILON = 10e-15;\n+    if (Double.isNaN(a) || Double.isNaN(x)) {\n+        return Double.NaN;\n+    } \n+    if (x < 0 || a <= 0) {\n+        return Double.NaN;\n+    }\n+    if (x == 0) {\n+        return 0;\n+    }\n+    double gammaValue = Gamma.gamma(a);\n+    double seriesValue = regularizedGammaPSeries(a, x, EPSILON / gammaValue);\n+    return Math.exp(-x + a * Math.log(x) - Math.log(gammaValue)) * seriesValue;\n+}\n+\n+public static double regularizedGammaQ(double a, double x) {\n+    final double EPSILON = 10e-15;\n+    if (Double.isNaN(a) || Double.isNaN(x)) {\n+        return Double.NaN;\n+    } \n+    if (x < 0 || a <= 0) {\n+        return Double.NaN;\n+    }\n+    if (x == 0) {\n+        return 1;\n+    }\n+    double gammaValue = Gamma.gamma(a);\n+    double seriesValue = regularizedGammaQSeries(a, x, EPSILON / gammaValue);\n+    return Math.exp(-x + a * Math.log(x) - Math.log(gammaValue)) * seriesValue;\n+}\n+\n+private static double regularizedGammaPSeries(double a, double x, double epsilon) {\n+    double n = 1;\n+    double ap = a;\n+    double sum = 1 / a;\n+    double del = sum;\n+    while (Math.abs(del) > Math.abs(sum) * epsilon && ap < Double.MAX_VALUE * n) {\n+        ap += 1;\n+        del *= x / ap;\n+        sum += del;\n+        n += 1;\n+    }\n+    return sum * Math.exp(-x + a * Math.log(x) - Math.log(Gamma.gamma(a)));\n+}\n+\n+private static double regularizedGammaQSeries(double a, double x, double epsilon) {\n+    final double FPMIN = Double.MIN_VALUE / EPSILON;\n+    double gs = FPMIN;\n+    double ans = 0;\n+    double sum = 1 / FPMIN;\n+    double delta = sum;\n+    while (Math.abs(delta) > Math.abs(sum) * epsilon) {\n+        ++gs;\n+        delta *= -x / gs;\n+        sum += delta;\n+        if (sum < 0) {\n+            sum *= gs / (gs + a);\n+            ans += sum;\n+            sum = 1 / FPMIN;\n+            gs = 0;\n+        }\n+    }\n+    ans += sum;\n+    return ans * Math.exp(-x + a * Math.log(x) - Math.log(Gamma.gamma(a)));\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}