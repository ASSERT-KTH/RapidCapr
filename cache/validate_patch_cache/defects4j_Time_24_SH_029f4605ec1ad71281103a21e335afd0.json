{
    "patch": "        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            boolean hasTime = (count == 0 ? DateTimeParser.ZERO_IS_ADDITIVE : savedFields[0].iField.getType().getRangeDurationField().getType() == DurationFieldType.seconds());\n\n            // Check if error occurred solely because time of day\n            if (hasTime && e.getIllegalFieldValue() == 24 &&\n                e.getFieldName().equals(\"hourOfDay\") && text != null &&\n                (text.indexOf('T') >= 0 || text.indexOf('t') >= 0)) {\n                // Calculate time as 24:00:00.000 or 23:59:59.999\n                long copyMillis = iMillis;\n                for (int i = 0; i < count; i++) {\n                    DateTimeField field = savedFields[i].iField;\n                    DurationField rangeField = field.getDurationField();\n                    if (isSupported(rangeField)) {\n                        int value = savedFields[i].iValue;\n                        // Calculate index and rem within range\n                        int[] values = rangeField.add(copyMillis, value);\n                        copyMillis = values[0];\n                        int added = values[1];\n                        // There are two ways to get midnight: 24:00 or 00:00.\n                        // The value 24 is not legal ISO, so use 00:00.\n                        if (added == 24 && field.getType().equals(DateTimeFieldType.hourOfDay()) &&\n                            isSupported(field.getRangeDurationField())) {\n                            copyMillis -= rangeField.getUnitMillis();\n                        }\n                    }\n                }\n                // Now try parsing the adjusted millis\n                savedFields = savedFields.clone();\n                try {\n                    return computeMillis(resetFields, null) + (copyMillis - iMillis);\n                } catch (IllegalArgumentException ex) {\n                    // Ignore error\n                }\n            }\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\": \");\n            }\n            throw e;\n        }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..229c834b 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,48 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+        } catch (IllegalFieldValueException e) {\n+            if (text != null) {\n+                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+            }\n+            boolean hasTime = (count == 0 ? DateTimeParser.ZERO_IS_ADDITIVE : savedFields[0].iField.getType().getRangeDurationField().getType() == DurationFieldType.seconds());\n+\n+            // Check if error occurred solely because time of day\n+            if (hasTime && e.getIllegalFieldValue() == 24 &&\n+                e.getFieldName().equals(\"hourOfDay\") && text != null &&\n+                (text.indexOf('T') >= 0 || text.indexOf('t') >= 0)) {\n+                // Calculate time as 24:00:00.000 or 23:59:59.999\n+                long copyMillis = iMillis;\n+                for (int i = 0; i < count; i++) {\n+                    DateTimeField field = savedFields[i].iField;\n+                    DurationField rangeField = field.getDurationField();\n+                    if (isSupported(rangeField)) {\n+                        int value = savedFields[i].iValue;\n+                        // Calculate index and rem within range\n+                        int[] values = rangeField.add(copyMillis, value);\n+                        copyMillis = values[0];\n+                        int added = values[1];\n+                        // There are two ways to get midnight: 24:00 or 00:00.\n+                        // The value 24 is not legal ISO, so use 00:00.\n+                        if (added == 24 && field.getType().equals(DateTimeFieldType.hourOfDay()) &&\n+                            isSupported(field.getRangeDurationField())) {\n+                            copyMillis -= rangeField.getUnitMillis();\n+                        }\n+                    }\n+                }\n+                // Now try parsing the adjusted millis\n+                savedFields = savedFields.clone();\n+                try {\n+                    return computeMillis(resetFields, null) + (copyMillis - iMillis);\n+                } catch (IllegalArgumentException ex) {\n+                    // Ignore error\n+                }\n+            }\n+            if (text != null) {\n+                e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\": \");\n+            }\n+            throw e;\n+        }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}