{
    "patch": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    while (true) {\n        incrementIterationsCounter();\n\n        // Sort the simplex\n        Arrays.sort(simplex, comparator);\n\n        // Find best and worst points\n        final RealPointValuePair best = simplex[0];\n        final RealPointValuePair worst = simplex[simplex.length - 1];\n\n        // Check termination\n        double v1 = FastMath.abs(best.getValue());\n        double v2 = FastMath.abs(worst.getValue());\n        final double delta = FastMath.max(\n                FastMath.max(relativeThreshold * (v1 + v2) / 2, absoluteThreshold),\n                MIN_RELATIVE_TOLERANCE * (FastMath.abs(oldOptimum) + FastMath.abs(best.getValue())) / 2);\n        if (iterations > 1 &&\n            FastMath.max(FastMath.abs(v2 - v1), FastMath.max(FastMath.abs(worst.getKey()[0] - best.getKey()[0]),\n            FastMath.max(FastMath.abs(worst.getKey()[1] - best.getKey()[1]), FastMath.abs(worst.getKey()[2] - best.getKey()[2])))) < delta) {\n            return;\n        }\n\n        // Perform a reflection step\n        final double[] xSmallest = simplex[0].getPoint();\n        final double[] xAcctuallyWorst = worst.getPoint();\n        final double[] xBeforeWorst = simplex[simplex.length - 2].getPoint();\n        final double[] xNew = new double[xSmallest.length];\n        for (int i = 0; i < xSmallest.length; i++) {\n            xNew[i] = centroid(xSmallest, i, xBeforeWorst, i, xBeforeWorst, i, xAcctuallyWorst, i);\n        }\n\n        final RealPointValuePair reflected = new RealPointValuePair(xNew, computeObjectiveValue(xNew), false);\n        final int c = comparator.compare(reflected, best);\n        if (c < 0) { // accept reflected point\n            final double[] xExtrapolated = new double[xSmallest.length];\n            for (int i = 0; i < xSmallest.length; i++) {\n                xExtrapolated[i] = centroid(xSmallest, i, xBeforeWorst, i, xBeforeWorst, i, xNew, i);\n            }\n            final RealPointValuePair expanded = new RealPointValuePair(xExtrapolated, computeObjectiveValue(xExtrapolated), false);\n            final int ce = comparator.compare(reflected, expanded);\n            if (ce < 0) {\n                simplex[simplex.length - 1] = expanded;\n            } else {\n                simplex[simplex.length - 1] = reflected;\n            }\n        } else { // reflected point is worse than best\n            final boolean minimumPointReplaced = replaceWorst(compareSingleToAll(simplex[0], comparator));\n            if (!minimumPointReplaced) {\n                // The contraction must go inside the current simplex. We don't\n                // need the intermediate simplex that would be obtained by\n                // creating a new vertex.\n                final double[] xContracted = new double[xSmallest.length];\n                for (int i = 0; i < xSmallest.length; i++) {\n                    xContracted[i] = centroid(xSmallest, i, xAcctuallyWorst, i);\n                }\n                final RealPointValuePair contracted = new RealPointValuePair(xContracted, computeObjectiveValue(xContracted), false);\n                final int cc = comparator.compare(contracted, worst);\n                if (cc < 0) { // accept contracted point\n                    simplex[simplex.length - 1] = contracted;\n                } else {\n                    // perform a shrink\n                    final RealPointValuePair[] pointsToShrink = new RealPointValuePair[simplex.length - 1];\n                    for (int i = 0; i < simplex.length - 1; i++) {\n                        final RealPointValuePair current = simplex[i];\n                        final double[] xShrunk = new double[xSmallest.length];\n                        for (int j = 0; j < xSmallest.length; j++) {\n                            xShrunk[j] = centroid(current.getPoint(), j, worst.getPoint(), j);\n                        }\n                        final RealPointValuePair shrunk = new RealPointValuePair(xShrunk, computeObjectiveValue(xShrunk), false);\n                        pointsToShrink[i] = shrunk;\n                    }\n                    simplex = pointsToShrink;\n                }\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..3cfe23600 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,45 +58,86 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n-        while (true) {\n-\n-            incrementIterationsCounter();\n-\n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n-\n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n-\n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n+    while (true) {\n+        incrementIterationsCounter();\n+\n+        // Sort the simplex\n+        Arrays.sort(simplex, comparator);\n+\n+        // Find best and worst points\n+        final RealPointValuePair best = simplex[0];\n+        final RealPointValuePair worst = simplex[simplex.length - 1];\n+\n+        // Check termination\n+        double v1 = FastMath.abs(best.getValue());\n+        double v2 = FastMath.abs(worst.getValue());\n+        final double delta = FastMath.max(\n+                FastMath.max(relativeThreshold * (v1 + v2) / 2, absoluteThreshold),\n+                MIN_RELATIVE_TOLERANCE * (FastMath.abs(oldOptimum) + FastMath.abs(best.getValue())) / 2);\n+        if (iterations > 1 &&\n+            FastMath.max(FastMath.abs(v2 - v1), FastMath.max(FastMath.abs(worst.getKey()[0] - best.getKey()[0]),\n+            FastMath.max(FastMath.abs(worst.getKey()[1] - best.getKey()[1]), FastMath.abs(worst.getKey()[2] - best.getKey()[2])))) < delta) {\n+            return;\n+        }\n \n-                return;\n+        // Perform a reflection step\n+        final double[] xSmallest = simplex[0].getPoint();\n+        final double[] xAcctuallyWorst = worst.getPoint();\n+        final double[] xBeforeWorst = simplex[simplex.length - 2].getPoint();\n+        final double[] xNew = new double[xSmallest.length];\n+        for (int i = 0; i < xSmallest.length; i++) {\n+            xNew[i] = centroid(xSmallest, i, xBeforeWorst, i, xBeforeWorst, i, xAcctuallyWorst, i);\n+        }\n \n+        final RealPointValuePair reflected = new RealPointValuePair(xNew, computeObjectiveValue(xNew), false);\n+        final int c = comparator.compare(reflected, best);\n+        if (c < 0) { // accept reflected point\n+            final double[] xExtrapolated = new double[xSmallest.length];\n+            for (int i = 0; i < xSmallest.length; i++) {\n+                xExtrapolated[i] = centroid(xSmallest, i, xBeforeWorst, i, xBeforeWorst, i, xNew, i);\n             }\n-\n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n+            final RealPointValuePair expanded = new RealPointValuePair(xExtrapolated, computeObjectiveValue(xExtrapolated), false);\n+            final int ce = comparator.compare(reflected, expanded);\n+            if (ce < 0) {\n+                simplex[simplex.length - 1] = expanded;\n+            } else {\n+                simplex[simplex.length - 1] = reflected;\n+            }\n+        } else { // reflected point is worse than best\n+            final boolean minimumPointReplaced = replaceWorst(compareSingleToAll(simplex[0], comparator));\n+            if (!minimumPointReplaced) {\n+                // The contraction must go inside the current simplex. We don't\n+                // need the intermediate simplex that would be obtained by\n+                // creating a new vertex.\n+                final double[] xContracted = new double[xSmallest.length];\n+                for (int i = 0; i < xSmallest.length; i++) {\n+                    xContracted[i] = centroid(xSmallest, i, xAcctuallyWorst, i);\n+                }\n+                final RealPointValuePair contracted = new RealPointValuePair(xContracted, computeObjectiveValue(xContracted), false);\n+                final int cc = comparator.compare(contracted, worst);\n+                if (cc < 0) { // accept contracted point\n+                    simplex[simplex.length - 1] = contracted;\n+                } else {\n+                    // perform a shrink\n+                    final RealPointValuePair[] pointsToShrink = new RealPointValuePair[simplex.length - 1];\n+                    for (int i = 0; i < simplex.length - 1; i++) {\n+                        final RealPointValuePair current = simplex[i];\n+                        final double[] xShrunk = new double[xSmallest.length];\n+                        for (int j = 0; j < xSmallest.length; j++) {\n+                            xShrunk[j] = centroid(current.getPoint(), j, worst.getPoint(), j);\n+                        }\n+                        final RealPointValuePair shrunk = new RealPointValuePair(xShrunk, computeObjectiveValue(xShrunk), false);\n+                        pointsToShrink[i] = shrunk;\n+                    }\n+                    simplex = pointsToShrink;\n+                }\n             }\n-\n         }\n-\n     }\n+}\n \n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}