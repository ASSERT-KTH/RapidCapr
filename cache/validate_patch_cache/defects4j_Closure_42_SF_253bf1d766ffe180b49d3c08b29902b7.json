{
    "patch": "class TransformDispatcher implements TypeSafeDispatcher<Node> {\n\n  private final AstRoot ast;\n  private final String sourceName;\n  private final ErrorReporter errorReporter;\n\n  TransformDispatcher(AstRoot ast, String sourceName, ErrorReporter errorReporter) {\n    this.ast = ast;\n    this.sourceName = sourceName;\n    this.errorReporter = errorReporter;\n  }\n\n  @Override\n  public Node defaultValue(AstNode node) {\n    throw new UnsupportedOperationException(node.getClass().getName());\n  }\n\n  Node transform(AstNode node) {\n    return node.accept(this);\n  }\n\n  Node transformBlock(Block block) {\n    if (block == null) {\n      return null;\n    }\n    Node node = newNode(Token.BLOCK);\n    for (Node s : transformAll(block)) {\n      node.addChildToBack(s);\n    }\n    return node;\n  }\n\n  List<Node> transformAll(List<? extends AstNode> nodes) {\n    List<Node> result = new ArrayList<>(nodes.size());\n    for (AstNode node : nodes) {\n      result.add(transform(node));\n    }\n    return result;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n            n.getFirstChild().isString() &&\n            ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  @Override\n  Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  @Override\n  Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n              \"Catch clauses are not supported\",\n              sourceName,\n              clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n            Token.HOOK,\n            transform(exprNode.getTestExpression()),\n            transform(exprNode.getTrueExpression()),\n            transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n            Token.DO,\n            transformBlock(loopNode.getBody()),\n            transform(loopNode.getCondition()));\n  }\n\n  @Override\n  Node processElementGet(ElementGet getNode) {\n    return newNode(\n            Token.GETELEM,\n            transform(getNode.getTarget()),\n            transform(getNode.getElement()));\n  }\n\n  @Override\n  Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(Token.EXPR_RESULT);\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  Node processForInLoop(ForInLoop loopNode) {\n    Node varNode = null;\n    AstNode iterVar = loopNode.getIterator();\n    if (iterVar instanceof VariableDeclaration) {\n      varNode = transform(iterVar);\n    } else if (iterVar != null) {\n      varNode = newNode(Token.VAR, transform(iterVar));\n    }\n\n    return newNode(\n            Token.FOR,\n            varNode,\n            transform(loopNode.getIteratedObject()),\n            transformBlock(loopNode.getBody())\n    );\n  }\n\n  @Override\n  Node processFunctionCall(FunctionCall callNode) {\n    Node node = newNode(Token.CALL, transform(callNode.getTarget()));\n    List<AstNode> args = callNode.getArguments();\n    for (AstNode arg : args) {\n      node.addChildToBack(transform(arg));\n    }\n    return node;\n  }\n\n  @Override\n  Node processFunctionNode(FunctionNode functionNode) {\n    Node node = newNode(Token.FUNCTION);\n    if (functionNode.getFunctionName() != null) {\n      node.addChildToBack(transform(functionNode.getFunctionName()));\n    }\n    for (Node param : transformAll(functionNode.getParams())) {\n      node.addChildToBack(param);\n    }\n    node.addChildToBack(transformBlock(functionNode.getBody()));\n    return node;\n  }\n\n  @Override\n  Node processIfStatement(IfStatement statementNode) {\n    Node node = newNode(Token.IF);\n    node.addChildToBack(transform(statementNode.getCondition()));\n    node.addChildToBack(transformBlock(statementNode.getThenPart()));\n    AstNode elsePart = statementNode.getElsePart();\n    if (elsePart != null) {\n      Node elseNode = elsePart instanceof IfStatement\n              ? processIfStatement((IfStatement) elsePart)\n              : transformBlock((Block) elsePart);\n      node.addChildToBack(elseNode);\n    }\n    return node;\n  }\n\n  @Override\n  Node processInfixExpression(InfixExpression exprNode) {\n    String op = getOpString(exprNode.getType());\n    return newNode(\n            Token.newFromType(exprNode.getType()),\n            transform(exprNode.getLeft()),\n            transform(exprNode.getRight()));\n  }\n\n  @Override\n  Node processKeywordLiteral(KeywordLiteral literalNode) {\n    int type = literalNode.getType();\n    if (type == Token.TRUE || type == Token.FALSE) {\n      return newNode(type);\n    }\n    return newNode(type, null, null);\n  }\n\n  @Override\n  Node processName(Name nameNode) {\n    return newNode(Token.NAME, nameNode.getString());\n  }\n\n  @Override\n  Node processNewExpression(NewExpression exprNode) {\n    Node node = newNode(Token.NEW, transform(exprNode.getTarget()));\n    List<AstNode> args = exprNode.getArguments();\n    for (AstNode arg : args) {\n      node.addChildToBack(transform(arg));\n    }\n    return node;\n  }\n\n  @Override\n  Node processNumber(NumberLiteral literalNode) {\n    return newNode(Token.NUMBER, literalNode.getValue());\n  }\n\n  @Override\n  Node processObjectLiteral(ObjectLiteral literalNode) {\n    Node node = newNode(Token.OBJECTLIT);\n    for (ObjectProperty prop : literalNode.getElements()) {\n      int type = Token.STRING;\n      String name = null;\n      AstNode key = prop.getLeft();\n      if (key instanceof Name) {\n        name = key.getString();\n      } else if (key instanceof StringLiteral) {\n        name = ((StringLiteral) key).getValue();\n      } else { // must be a number literal\n        name = Integer.toString((int) ((NumberLiteral) key).getNumber());\n        type = Token.NUMBER;\n      }\n      node.addChildToBack(\n              newNode(type, name, transform(prop.getRight())));\n    }\n    return node;\n  }\n\n  @Override\n  Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n    return newNode(Token.LP, transform(exprNode.getExpression()));\n  }\n\n  @Override\n  Node processPropertyGet(PropertyGet getNode) {\n    Node node = newNode(\n            Token.GETPROP,\n            transform(getNode.getTarget()));\n    node.addChildToBack(newNode(Token.STRING, getNode.getProperty().getIdentifier()));\n    return node;\n  }\n\n  @Override\n  Node processRegExpLiteral(RegExpLiteral literalNode) {\n    Node node = newNode(Token.REGEXP);\n    node.addChildToBack(newNode(Token.STRING, literalNode.getValue()));\n    if (literalNode.getFlags() != null) {\n      node.addChildToBack(newNode(Token.STRING, literalNode.getFlags()));\n    } else {\n      node.addChildToBack(newNode(Token.STRING, \"\"));\n    }\n    return node;\n  }\n\n  @Override\n  Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = newNode(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      node.addChildToBack(transform(statementNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  @Override\n  Node processString(StringLiteral literalNode) {\n    return newNode(Token.STRING, literalNode.getValue());\n  }\n\n  @Override\n  Node processSwitchCase(SwitchCase caseNode) {\n    Node node = newNode(Token.CASE, transform(caseNode.getExpression()));\n    for (Node s : transformAll(caseNode.getStatements())) {\n      node.addChildToBack(s);\n    }\n    return node;\n  }\n\n  @Override\n  Node processSwitchStatement(SwitchStatement statementNode) {\n    Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n    for (SwitchCase caseNode : statementNode.getCases()) {\n      node.addChildToBack(transform(caseNode));\n    }\n    return node;\n  }\n\n  @Override\n  Node processThrowStatement(ThrowStatement statementNode) {\n    return newNode(Token.THROW, transform(statementNode.getExpression()));\n  }\n\n  @Override\n  Node processTryStatement(TryStatement statementNode) {\n    Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n    if (statementNode.getCatchClauses() != null) {\n      for (CatchClause clause : statementNode.getCatchClauses()) {\n        node.addChildToBack(transform(clause));\n      }\n    }\n    Block finallyBlock = statementNode.getFinallyBlock();\n    if (finallyBlock != null) {\n      node.addChildToBack(newNode(Token.FINALLY, transformBlock(finallyBlock)));\n    }\n    return node;\n  }\n\n  @Override\n  Node processUnaryExpression(UnaryExpression exprNode) {\n    int type = Token.newFromType(exprNode.getType());\n    if (exprNode.isPostfix()) {\n      type = Token.newFromType(exprNode.getType()).getTokenTypeForPostfix();\n    }\n    return newNode(type, transform(exprNode.getOperand()));\n  }\n\n  @Override\n  Node processVariableDeclaration(VariableDeclaration decl) {\n    Node node = newNode(Token.VAR);\n    for (VariableInitializer init : decl.getVariables()) {\n      node.addChildToBack(transform(init));\n    }\n    return node;\n  }\n\n  @Override\n  Node processVariableInitializer(VariableInitializer init) {\n    Node node = newNode(Token.NAME, init.getTarget().getString());\n    if (init.getInitializer() != null) {\n      node.addChildToBack(transform(init.getInitializer()));\n    }\n    return node;\n  }\n\n  @Override\n  Node processWhileLoop(WhileLoop loopNode) {\n    return newNode(Token.WHILE,\n            transform(loopNode.getCondition()),\n            transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  Node processWithStatement(WithStatement statementNode) {\n    return newNode(Token.WITH,\n            transform(statementNode.getExpression()),\n            transformBlock(statementNode.getStatement()));\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..8ffb6df9 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,370 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher implements TypeSafeDispatcher<Node> {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private final AstRoot ast;\n+  private final String sourceName;\n+  private final ErrorReporter errorReporter;\n+\n+  TransformDispatcher(AstRoot ast, String sourceName, ErrorReporter errorReporter) {\n+    this.ast = ast;\n+    this.sourceName = sourceName;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  @Override\n+  public Node defaultValue(AstNode node) {\n+    throw new UnsupportedOperationException(node.getClass().getName());\n+  }\n+\n+  Node transform(AstNode node) {\n+    return node.accept(this);\n+  }\n+\n+  Node transformBlock(Block block) {\n+    if (block == null) {\n+      return null;\n+    }\n+    Node node = newNode(Token.BLOCK);\n+    for (Node s : transformAll(block)) {\n+      node.addChildToBack(s);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  List<Node> transformAll(List<? extends AstNode> nodes) {\n+    List<Node> result = new ArrayList<>(nodes.size());\n+    for (AstNode node : nodes) {\n+      result.add(transform(node));\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+            n.getFirstChild().isString() &&\n+            ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  @Override\n+  Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  @Override\n+  Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  @Override\n+  Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+              \"Catch clauses are not supported\",\n+              sourceName,\n+              clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  @Override\n+  Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+            Token.HOOK,\n+            transform(exprNode.getTestExpression()),\n+            transform(exprNode.getTrueExpression()),\n+            transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  @Override\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+            Token.DO,\n+            transformBlock(loopNode.getBody()),\n+            transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+            Token.GETELEM,\n+            transform(getNode.getTarget()),\n+            transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(Token.EXPR_RESULT);\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processForInLoop(ForInLoop loopNode) {\n+    Node varNode = null;\n+    AstNode iterVar = loopNode.getIterator();\n+    if (iterVar instanceof VariableDeclaration) {\n+      varNode = transform(iterVar);\n+    } else if (iterVar != null) {\n+      varNode = newNode(Token.VAR, transform(iterVar));\n+    }\n+\n+    return newNode(\n+            Token.FOR,\n+            varNode,\n+            transform(loopNode.getIteratedObject()),\n+            transformBlock(loopNode.getBody())\n+    );\n+  }\n+\n+  @Override\n+  Node processFunctionCall(FunctionCall callNode) {\n+    Node node = newNode(Token.CALL, transform(callNode.getTarget()));\n+    List<AstNode> args = callNode.getArguments();\n+    for (AstNode arg : args) {\n+      node.addChildToBack(transform(arg));\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processFunctionNode(FunctionNode functionNode) {\n+    Node node = newNode(Token.FUNCTION);\n+    if (functionNode.getFunctionName() != null) {\n+      node.addChildToBack(transform(functionNode.getFunctionName()));\n+    }\n+    for (Node param : transformAll(functionNode.getParams())) {\n+      node.addChildToBack(param);\n+    }\n+    node.addChildToBack(transformBlock(functionNode.getBody()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processIfStatement(IfStatement statementNode) {\n+    Node node = newNode(Token.IF);\n+    node.addChildToBack(transform(statementNode.getCondition()));\n+    node.addChildToBack(transformBlock(statementNode.getThenPart()));\n+    AstNode elsePart = statementNode.getElsePart();\n+    if (elsePart != null) {\n+      Node elseNode = elsePart instanceof IfStatement\n+              ? processIfStatement((IfStatement) elsePart)\n+              : transformBlock((Block) elsePart);\n+      node.addChildToBack(elseNode);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processInfixExpression(InfixExpression exprNode) {\n+    String op = getOpString(exprNode.getType());\n+    return newNode(\n+            Token.newFromType(exprNode.getType()),\n+            transform(exprNode.getLeft()),\n+            transform(exprNode.getRight()));\n+  }\n+\n+  @Override\n+  Node processKeywordLiteral(KeywordLiteral literalNode) {\n+    int type = literalNode.getType();\n+    if (type == Token.TRUE || type == Token.FALSE) {\n+      return newNode(type);\n+    }\n+    return newNode(type, null, null);\n+  }\n+\n+  @Override\n+  Node processName(Name nameNode) {\n+    return newNode(Token.NAME, nameNode.getString());\n+  }\n+\n+  @Override\n+  Node processNewExpression(NewExpression exprNode) {\n+    Node node = newNode(Token.NEW, transform(exprNode.getTarget()));\n+    List<AstNode> args = exprNode.getArguments();\n+    for (AstNode arg : args) {\n+      node.addChildToBack(transform(arg));\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processNumber(NumberLiteral literalNode) {\n+    return newNode(Token.NUMBER, literalNode.getValue());\n+  }\n+\n+  @Override\n+  Node processObjectLiteral(ObjectLiteral literalNode) {\n+    Node node = newNode(Token.OBJECTLIT);\n+    for (ObjectProperty prop : literalNode.getElements()) {\n+      int type = Token.STRING;\n+      String name = null;\n+      AstNode key = prop.getLeft();\n+      if (key instanceof Name) {\n+        name = key.getString();\n+      } else if (key instanceof StringLiteral) {\n+        name = ((StringLiteral) key).getValue();\n+      } else { // must be a number literal\n+        name = Integer.toString((int) ((NumberLiteral) key).getNumber());\n+        type = Token.NUMBER;\n       }\n-      return node;\n+      node.addChildToBack(\n+              newNode(type, name, transform(prop.getRight())));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  @Override\n+  Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n+    return newNode(Token.LP, transform(exprNode.getExpression()));\n+  }\n+\n+  @Override\n+  Node processPropertyGet(PropertyGet getNode) {\n+    Node node = newNode(\n+            Token.GETPROP,\n+            transform(getNode.getTarget()));\n+    node.addChildToBack(newNode(Token.STRING, getNode.getProperty().getIdentifier()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processRegExpLiteral(RegExpLiteral literalNode) {\n+    Node node = newNode(Token.REGEXP);\n+    node.addChildToBack(newNode(Token.STRING, literalNode.getValue()));\n+    if (literalNode.getFlags() != null) {\n+      node.addChildToBack(newNode(Token.STRING, literalNode.getFlags()));\n+    } else {\n+      node.addChildToBack(newNode(Token.STRING, \"\"));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(statementNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  Node processString(StringLiteral literalNode) {\n+    return newNode(Token.STRING, literalNode.getValue());\n+  }\n+\n+  @Override\n+  Node processSwitchCase(SwitchCase caseNode) {\n+    Node node = newNode(Token.CASE, transform(caseNode.getExpression()));\n+    for (Node s : transformAll(caseNode.getStatements())) {\n+      node.addChildToBack(s);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  Node processSwitchStatement(SwitchStatement statementNode) {\n+    Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+    for (SwitchCase caseNode : statementNode.getCases()) {\n+      node.addChildToBack(transform(caseNode));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  Node processThrowStatement(ThrowStatement statementNode) {\n+    return newNode(Token.THROW, transform(statementNode.getExpression()));\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  Node processTryStatement(TryStatement statementNode) {\n+    Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+    if (statementNode.getCatchClauses() != null) {\n+      for (CatchClause clause : statementNode.getCatchClauses()) {\n+        node.addChildToBack(transform(clause));\n+      }\n     }\n+    Block finallyBlock = statementNode.getFinallyBlock();\n+    if (finallyBlock != null) {\n+      node.addChildToBack(newNode(Token.FINALLY, transformBlock(finallyBlock)));\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processUnaryExpression(UnaryExpression exprNode) {\n+    int type = Token.newFromType(exprNode.getType());\n+    if (exprNode.isPostfix()) {\n+      type = Token.newFromType(exprNode.getType()).getTokenTypeForPostfix();\n+    }\n+    return newNode(type, transform(exprNode.getOperand()));\n+  }\n+\n+  @Override\n+  Node processVariableDeclaration(VariableDeclaration decl) {\n+    Node node = newNode(Token.VAR);\n+    for (VariableInitializer init : decl.getVariables()) {\n+      node.addChildToBack(transform(init));\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processVariableInitializer(VariableInitializer init) {\n+    Node node = newNode(Token.NAME, init.getTarget().getString());\n+    if (init.getInitializer() != null) {\n+      node.addChildToBack(transform(init.getInitializer()));\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processWhileLoop(WhileLoop loopNode) {\n+    return newNode(Token.WHILE,\n+            transform(loopNode.getCondition()),\n+            transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  Node processWithStatement(WithStatement statementNode) {\n+    return newNode(Token.WITH,\n+            transform(statementNode.getExpression()),\n+            transformBlock(statementNode.getStatement()));\n+  }\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}