{
    "patch": " private boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n   Node n = ref.getAncestor();\n   String propName = ref.getNode().getString();\n\n   if (NodeUtil.isExpressionNode(n)) {\n     Node parent = n.getParent();\n     if (parent != null) {\n       if (NodeUtil.isAssignmentOp(parent)) {\n         // If we don't clone here, then the RHS of the assignment will be\n         // replaced with it's inline version, which messes up the traversal of\n         // the AST, since nodes may be invalidated as a result.\n         Node rhs = parent.getLastChild().cloneNode();\n         if (NodeUtil.isObjectLitRhs(parent)) {\n           Preconditions.checkState(n == parent.getFirstChild(),\n               \"Expected OBJECTLIT as first child, but found %s\", n);\n           parent = parent.getParent();\n           if (parent.isName()) {\n             // Aliases of object literals with a single reference can be\n             // inlined into the name's declaration.\n             inlineIntoName(parent, rhs, namespace);\n             return true;\n           }\n         } else {\n           // We set the result of this assignment to null to signify that\n           // this statement previously existed, but was removed and replaced\n           // with an expression with no side-effects (the RHS). This is useful\n           // for code removal.\n           parent.getLastChild().detach();\n           parent.setToken(Token.EMPTY);\n           n.setImmutable();\n           NodeUtil.copyNameAnnotations(rhs, parent.getFirstChild());\n           parent.replaceChild(n, rhs);\n           return true;\n         }\n       } else if (parent.isSetterDef()) {\n         // Aliases of the right-hand-side of setter declarations cannot be\n         // inlined into the corresponding parameter declaration.\n       } else if (parent.isInc() || parent.isDec()) {\n         parent = parent.getParent();\n         Preconditions.checkState(NodeUtil.isExpressionNode(parent),\n             \"Expected an expression as parent, but found %s\", parent);\n         ParentSetter ps = new ParentSetter(parent);\n         Node newStatement = IR.exprResult(\n             IR.assign(parent.cloneNode(), n.cloneNode()));\n         ps.insertSiblingAfter(newStatement);\n         n.detachFromParent();\n         return true;\n       }\n     }\n   } else if (n.isStringKey()) {\n     Node grandparent = n.getGrandparent();\n     if (grandparent.isObjectLit()) {\n       inlineIntoObjectLit(grandparent, propName, namespace);\n       return true;\n     }\n   }\n\n   return false;\n }\n\n private void inlineIntoName(Node name, Node rhs, GlobalNamespace namespace) {\n   Preconditions.checkState(name.getParent() instanceof Node,\n       \"Expected child node to have a parent, but it doesn't: %s\",\n       name.toStringTree());\n   Node parent = name.getParent();\n\n   // Find all references to this name, and replace them with RHS.\n   Var var = namespace.getVar(name.getString());\n   for (Reference ref : var.getRefs()) {\n     if (ref.getNode() == name) {\n       ref.getParent().replaceChild(ref.getNode(), rhs);\n     }\n   }\n\n   // Replace the name with the RHS.\n   rhs.setJSType(name.getJSType());\n   NodeUtil.markFunctionsDeleted(rhs, compiler);\n   NodeUtil.copyNodeAnnotations(name, rhs);\n   parent.replaceChild(name, rhs);\n\n   rhs.putBooleanProp(Node.IS_CONSTANT_NAME, name.getBooleanProp(Node.IS_CONSTANT_NAME));\n   rhs.setOriginalName(name.getOriginalName());\n   rhs.setJSDocInfo(name.getJSDocInfo());\n }\n\n private void inlineIntoObjectLit(Node objectLit, String propName, GlobalNamespace namespace) {\n   // Find the value associated with the property name\n   Node propValue = null;\n   for (Node key = objectLit.getFirstChild(); key != null; key = key.getNext()) {\n     if (key.getString().equals(propName)) {\n       propValue = key.getFirstChild();\n       break;\n     }\n   }\n\n   Preconditions.checkNotNull(propValue,\n       \"No property value found for key %s in %s\", propName,\n       objectLit.toStringTree());\n\n   // Find all references to this property value, and replace them with the property name.\n   Var var = namespace.getVar(propValue);\n   for (Reference ref : var.getRefs()) {\n     if (ref.getNode() == propValue) {\n       Node getProp = IR.getprop(objectLit.cloneNode(), IR.string(propName));\n       getProp.setJSType(ref.getNode().getJSType());\n       NodeUtil.markFunctionsDeleted(getProp, compiler);\n       NodeUtil.copyNodeAnnotations(ref.getNode(), getProp);\n       ref.getParent().replaceChild(ref.getNode(), getProp);\n     }\n   }\n\n   // Remove the property.\n   Node key = propValue.getParent();\n   key.detachFromParent();\n   objectLit.removeChild(key);\n   propValue.detachFromParent();\n   key.removeChild(propValue);\n   NodeUtil.markFunctionsDeleted(propValue, compiler);\n }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..be470ca3 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -158,43 +158,125 @@ class CollapseProperties implements CompilerPass {\n    *    inlineable.\n    * @see InlineVariables\n    */\n-  private void inlineAliases(GlobalNamespace namespace) {\n-    // Invariant: All the names in the worklist meet condition (a).\n-    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n-    while (!workList.isEmpty()) {\n-      Name name = workList.pop();\n-\n-      // Don't attempt to inline a getter or setter property as a variable.\n-      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n-        continue;\n-      }\n-\n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n-            }\n-          }\n-        }\n-      }\n-\n-      // Check if {@code name} has any aliases left after the\n-      // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n-           name.type == Name.Type.FUNCTION) &&\n-          name.aliasingGets == 0 && name.props != null) {\n-        // All of {@code name}'s children meet condition (a), so they can be\n-        // added to the worklist.\n-        workList.addAll(name.props);\n-      }\n-    }\n-  }\n+ private boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n+   Node n = ref.getAncestor();\n+   String propName = ref.getNode().getString();\n+\n+   if (NodeUtil.isExpressionNode(n)) {\n+     Node parent = n.getParent();\n+     if (parent != null) {\n+       if (NodeUtil.isAssignmentOp(parent)) {\n+         // If we don't clone here, then the RHS of the assignment will be\n+         // replaced with it's inline version, which messes up the traversal of\n+         // the AST, since nodes may be invalidated as a result.\n+         Node rhs = parent.getLastChild().cloneNode();\n+         if (NodeUtil.isObjectLitRhs(parent)) {\n+           Preconditions.checkState(n == parent.getFirstChild(),\n+               \"Expected OBJECTLIT as first child, but found %s\", n);\n+           parent = parent.getParent();\n+           if (parent.isName()) {\n+             // Aliases of object literals with a single reference can be\n+             // inlined into the name's declaration.\n+             inlineIntoName(parent, rhs, namespace);\n+             return true;\n+           }\n+         } else {\n+           // We set the result of this assignment to null to signify that\n+           // this statement previously existed, but was removed and replaced\n+           // with an expression with no side-effects (the RHS). This is useful\n+           // for code removal.\n+           parent.getLastChild().detach();\n+           parent.setToken(Token.EMPTY);\n+           n.setImmutable();\n+           NodeUtil.copyNameAnnotations(rhs, parent.getFirstChild());\n+           parent.replaceChild(n, rhs);\n+           return true;\n+         }\n+       } else if (parent.isSetterDef()) {\n+         // Aliases of the right-hand-side of setter declarations cannot be\n+         // inlined into the corresponding parameter declaration.\n+       } else if (parent.isInc() || parent.isDec()) {\n+         parent = parent.getParent();\n+         Preconditions.checkState(NodeUtil.isExpressionNode(parent),\n+             \"Expected an expression as parent, but found %s\", parent);\n+         ParentSetter ps = new ParentSetter(parent);\n+         Node newStatement = IR.exprResult(\n+             IR.assign(parent.cloneNode(), n.cloneNode()));\n+         ps.insertSiblingAfter(newStatement);\n+         n.detachFromParent();\n+         return true;\n+       }\n+     }\n+   } else if (n.isStringKey()) {\n+     Node grandparent = n.getGrandparent();\n+     if (grandparent.isObjectLit()) {\n+       inlineIntoObjectLit(grandparent, propName, namespace);\n+       return true;\n+     }\n+   }\n+\n+   return false;\n+ }\n+\n+ private void inlineIntoName(Node name, Node rhs, GlobalNamespace namespace) {\n+   Preconditions.checkState(name.getParent() instanceof Node,\n+       \"Expected child node to have a parent, but it doesn't: %s\",\n+       name.toStringTree());\n+   Node parent = name.getParent();\n+\n+   // Find all references to this name, and replace them with RHS.\n+   Var var = namespace.getVar(name.getString());\n+   for (Reference ref : var.getRefs()) {\n+     if (ref.getNode() == name) {\n+       ref.getParent().replaceChild(ref.getNode(), rhs);\n+     }\n+   }\n+\n+   // Replace the name with the RHS.\n+   rhs.setJSType(name.getJSType());\n+   NodeUtil.markFunctionsDeleted(rhs, compiler);\n+   NodeUtil.copyNodeAnnotations(name, rhs);\n+   parent.replaceChild(name, rhs);\n+\n+   rhs.putBooleanProp(Node.IS_CONSTANT_NAME, name.getBooleanProp(Node.IS_CONSTANT_NAME));\n+   rhs.setOriginalName(name.getOriginalName());\n+   rhs.setJSDocInfo(name.getJSDocInfo());\n+ }\n+\n+ private void inlineIntoObjectLit(Node objectLit, String propName, GlobalNamespace namespace) {\n+   // Find the value associated with the property name\n+   Node propValue = null;\n+   for (Node key = objectLit.getFirstChild(); key != null; key = key.getNext()) {\n+     if (key.getString().equals(propName)) {\n+       propValue = key.getFirstChild();\n+       break;\n+     }\n+   }\n+\n+   Preconditions.checkNotNull(propValue,\n+       \"No property value found for key %s in %s\", propName,\n+       objectLit.toStringTree());\n+\n+   // Find all references to this property value, and replace them with the property name.\n+   Var var = namespace.getVar(propValue);\n+   for (Reference ref : var.getRefs()) {\n+     if (ref.getNode() == propValue) {\n+       Node getProp = IR.getprop(objectLit.cloneNode(), IR.string(propName));\n+       getProp.setJSType(ref.getNode().getJSType());\n+       NodeUtil.markFunctionsDeleted(getProp, compiler);\n+       NodeUtil.copyNodeAnnotations(ref.getNode(), getProp);\n+       ref.getParent().replaceChild(ref.getNode(), getProp);\n+     }\n+   }\n+\n+   // Remove the property.\n+   Node key = propValue.getParent();\n+   key.detachFromParent();\n+   objectLit.removeChild(key);\n+   propValue.detachFromParent();\n+   key.removeChild(propValue);\n+   NodeUtil.markFunctionsDeleted(propValue, compiler);\n+ }\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n     // Ensure that the alias is assigned to a local variable at that",
    "result_reason": "error: method inlineAliasIfPossible(Ref,GlobalNamespace) is already defined in class CollapseProperties",
    "test_result": "ERROR"
}