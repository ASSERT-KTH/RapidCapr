{
    "patch": "import org.mockito.cglib.proxy.*;\n\npublic class ResetMockUtil {\n\n    public static <T> void resetMock(T mock) {\n        MockHandler<T> newMockHandler = null;\n        try {\n            Object currentCallback = ((Factory) mock).getCallback(0);\n            if (currentCallback instanceof MethodInterceptorFilter) {\n                newMockHandler = new MockHandler<T>(((MethodInterceptorFilter) currentCallback).getHandler());\n            } else if (currentCallback instanceof MockHandlerInterface) {\n                newMockHandler = new MockHandler<T>((MockHandlerInterface<T>) currentCallback);\n            } else {\n                newMockHandler = new MockHandler<T>();\n            }\n            MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n            ((Factory) mock).setCallback(0, newFilter);\n        } catch (Throwable t) {\n            throw new RuntimeException(t);\n        }\n    }\n\n    private static class MockHandler<T> implements MockHandlerInterface<T> {\n        private final MockHandlerInterface<T> delegate;\n\n        public MockHandler() {\n            this(Mockito.mock(MockHandlerInterface.class));\n        }\n\n        public MockHandler(MockHandlerInterface<T> delegate) {\n            this.delegate = delegate;\n        }\n\n        public MockHandlerInterface<T> getDelegate() {\n            return delegate;\n        }\n\n        public Object handle(MethodInvocation methodInvocation) throws Throwable {\n            return delegate.handle(methodInvocation);\n        }\n    }\n\n    private static interface MockHandlerInterface<T> extends InvocationHandler {\n        public MockHandlerInterface<T> getDelegate();\n    }\n\n    private static class MethodInterceptorFilter implements MethodInterceptor {\n        private final MockHandlerInterface handler;\n        private final MockSettingsImpl mockSettings;\n\n        public MethodInterceptorFilter(MockHandlerInterface handler, MockSettingsImpl mockSettings) {\n            this.handler = handler;\n            this.mockSettings = mockSettings;\n        }\n\n        public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n            MethodInvocationReport report = new MethodInvocationReport((Factory) object, method, objects, methodProxy);\n            Object toReturn = null;\n            try {\n                toReturn = methodProxy.invokeSuper(object, objects);\n                report.markValid();\n                if (mockSettings.getInvocationListeners() != null) {\n                    for (InvocationListener listener : mockSettings.getInvocationListeners()) {\n                        listener.reportInvocation(report);\n                    }\n                }\n            } catch (Throwable t) {\n                report.markInvalid(t);\n                if (mockSettings.getInvocationListeners() != null) {\n                    for (InvocationListener listener : mockSettings.getInvocationListeners()) {\n                        listener.reportInvocation(report);\n                    }\n                }\n                throw t;\n            }\n            return toReturn;\n        }\n\n        public MockHandlerInterface getHandler() {\n            return handler;\n        }\n    }\n\n    private static class MethodInvocationReport {\n        private final Factory mock;\n        private final Method method;\n        private final Object[] args;\n        private final MethodProxy methodProxy;\n        private final long timestamp = System.currentTimeMillis();\n        private boolean valid = false;\n        private Throwable throwable = null;\n        private Object result = null;\n\n        public MethodInvocationReport(Factory mock, Method method, Object[] args, MethodProxy methodProxy) {\n            this.mock = mock;\n            this.method = method;\n            this.args = args;\n            this.methodProxy = methodProxy;\n        }\n\n        public void markValid() {\n            this.valid = true;\n        }\n\n        public void markInvalid(Throwable t) {\n            this.valid = false;\n            this.throwable = t;\n        }\n\n        @Override\n        public String toString() {\n            StringBuilder sb = new StringBuilder();\n            sb.append(\"Mock \").append(mock).append(\" method \").append(method.getName()).append(\"(\");\n            for (int i = 0; i < args.length; i++) {\n                sb.append(args[i] == null ? \"null\" : args[i].toString());\n                if (i < args.length - 1) {\n                    sb.append(\", \");\n                }\n            }\n            sb.append(\") \");\n            if (valid) {\n                sb.append(\"returned \").append(result == null ? \"null\" : result.toString());\n            } else {\n                sb.append(\"threw \").append(throwable.toString());\n            }\n            sb.append(\"; timestamp=\").append(timestamp);\n            return sb.toString();\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..6bfbfc0f6 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,137 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.cglib.proxy.*;\n+\n+public class ResetMockUtil {\n+\n+    public static <T> void resetMock(T mock) {\n+        MockHandler<T> newMockHandler = null;\n+        try {\n+            Object currentCallback = ((Factory) mock).getCallback(0);\n+            if (currentCallback instanceof MethodInterceptorFilter) {\n+                newMockHandler = new MockHandler<T>(((MethodInterceptorFilter) currentCallback).getHandler());\n+            } else if (currentCallback instanceof MockHandlerInterface) {\n+                newMockHandler = new MockHandler<T>((MockHandlerInterface<T>) currentCallback);\n+            } else {\n+                newMockHandler = new MockHandler<T>();\n+            }\n+            MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+            ((Factory) mock).setCallback(0, newFilter);\n+        } catch (Throwable t) {\n+            throw new RuntimeException(t);\n+        }\n+    }\n+\n+    private static class MockHandler<T> implements MockHandlerInterface<T> {\n+        private final MockHandlerInterface<T> delegate;\n+\n+        public MockHandler() {\n+            this(Mockito.mock(MockHandlerInterface.class));\n+        }\n+\n+        public MockHandler(MockHandlerInterface<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        public MockHandlerInterface<T> getDelegate() {\n+            return delegate;\n+        }\n+\n+        public Object handle(MethodInvocation methodInvocation) throws Throwable {\n+            return delegate.handle(methodInvocation);\n+        }\n+    }\n+\n+    private static interface MockHandlerInterface<T> extends InvocationHandler {\n+        public MockHandlerInterface<T> getDelegate();\n+    }\n+\n+    private static class MethodInterceptorFilter implements MethodInterceptor {\n+        private final MockHandlerInterface handler;\n+        private final MockSettingsImpl mockSettings;\n+\n+        public MethodInterceptorFilter(MockHandlerInterface handler, MockSettingsImpl mockSettings) {\n+            this.handler = handler;\n+            this.mockSettings = mockSettings;\n+        }\n+\n+        public Object intercept(Object object, Method method, Object[] objects, MethodProxy methodProxy) throws Throwable {\n+            MethodInvocationReport report = new MethodInvocationReport((Factory) object, method, objects, methodProxy);\n+            Object toReturn = null;\n+            try {\n+                toReturn = methodProxy.invokeSuper(object, objects);\n+                report.markValid();\n+                if (mockSettings.getInvocationListeners() != null) {\n+                    for (InvocationListener listener : mockSettings.getInvocationListeners()) {\n+                        listener.reportInvocation(report);\n+                    }\n+                }\n+            } catch (Throwable t) {\n+                report.markInvalid(t);\n+                if (mockSettings.getInvocationListeners() != null) {\n+                    for (InvocationListener listener : mockSettings.getInvocationListeners()) {\n+                        listener.reportInvocation(report);\n+                    }\n+                }\n+                throw t;\n+            }\n+            return toReturn;\n+        }\n+\n+        public MockHandlerInterface getHandler() {\n+            return handler;\n+        }\n+    }\n+\n+    private static class MethodInvocationReport {\n+        private final Factory mock;\n+        private final Method method;\n+        private final Object[] args;\n+        private final MethodProxy methodProxy;\n+        private final long timestamp = System.currentTimeMillis();\n+        private boolean valid = false;\n+        private Throwable throwable = null;\n+        private Object result = null;\n+\n+        public MethodInvocationReport(Factory mock, Method method, Object[] args, MethodProxy methodProxy) {\n+            this.mock = mock;\n+            this.method = method;\n+            this.args = args;\n+            this.methodProxy = methodProxy;\n+        }\n+\n+        public void markValid() {\n+            this.valid = true;\n+        }\n+\n+        public void markInvalid(Throwable t) {\n+            this.valid = false;\n+            this.throwable = t;\n+        }\n+\n+        @Override\n+        public String toString() {\n+            StringBuilder sb = new StringBuilder();\n+            sb.append(\"Mock \").append(mock).append(\" method \").append(method.getName()).append(\"(\");\n+            for (int i = 0; i < args.length; i++) {\n+                sb.append(args[i] == null ? \"null\" : args[i].toString());\n+                if (i < args.length - 1) {\n+                    sb.append(\", \");\n+                }\n+            }\n+            sb.append(\") \");\n+            if (valid) {\n+                sb.append(\"returned \").append(result == null ? \"null\" : result.toString());\n+            } else {\n+                sb.append(\"threw \").append(throwable.toString());\n+            }\n+            sb.append(\"; timestamp=\").append(timestamp);\n+            return sb.toString();\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}