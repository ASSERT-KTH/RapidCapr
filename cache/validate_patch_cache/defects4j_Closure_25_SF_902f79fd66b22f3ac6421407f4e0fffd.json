{
    "patch": "    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct == null && constructorType.isFunctionType()) {\n          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n          // return null. But NoObjectType implements the FunctionType\n          // interface, precisely because it can validly construct objects.\n          ct = (FunctionType) constructorType;\n        }\n        if (ct != null && ct.isConstructor()) {\n          type = ct.getInstanceType();\n        }\n      }\n    }\n    n.setJSType(type);\n    if (constructor.getNext() != null) {\n      Node args = constructor.getNext();\n      if (!args.hasChildren()) {\n        // This handles the infrequently-used case of \"new Foo()\".\n        // If the constructor has required parameters, this will catch that case\n        // too.\n        scope = tightenType(Registry.get().getNativeObjectType(OBJECT_TYPE), type, scope, n);\n      } else {\n        // There are arguments, so constrain the constructor return type\n        // accordingly\n        boolean allScalar = true;\n        boolean allFunction = true;\n        int i = 0;\n        for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) {\n          scope = traverse(arg, scope);\n          JSType argType = arg.getJSType();\n          if (argType != null && !argType.isScalar()) {\n            allScalar = false;\n          }\n          if (argType != null && !argType.isFunctionType()) {\n            allFunction = false;\n          }\n          i++;\n        }\n        if (constructorType != null) {\n          if (allScalar) {\n            if (allFunction && i == 2) {\n              // Preserve the existing type for 'this'.\n              type = getNativeType(FUNCTION_TYPE);\n              JSType returnType =\n                  constructorType.toMaybeFunctionType().getReturnType();\n              if (returnType != null) {\n                type = getRegistry().createFunctionType(\n                    returnType.restrictByNotNullOrUndefined(), type, null, n);\n              }\n            } else {\n              type = withTypeFromNode(args.getFirstChild(), constructorType.restrictByNotNullOrUndefined(), JSType.NULL);\n            }\n            // Tighten the inferred type of the construtor.\n            type = tightenType(\n                Registry.get().getNativeObjectType(OBJECT_TYPE),\n                type, scope, n);\n          } else {\n            // Some of the arguments were not scalars, so the constructor type\n            // does not yield an object. Use the declared type of the object.\n            type = withTypeFromNode(args.getFirstChild(), getRegistry().getNativeType(OBJECT_TYPE), JSType.NULL);\n          }\n        }\n      }\n    } else if (constructorType != null && constructorType.isConstructor()) {\n      // There are no arguments, and constructorType is non-null.\n      // This constructor has no arguments, so we set type to the object type.\n      type = constructorType.toMaybeFunctionType().getInstanceType();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 7e218d88..a63f81dc 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1032,9 +1032,6 @@ class TypeInference\n     }\n   }\n \n-  private FlowScope traverseNew(Node n, FlowScope scope) {\n-\n-    Node constructor = n.getFirstChild();\n     scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n@@ -1044,7 +1041,7 @@ class TypeInference\n         type = getNativeType(UNKNOWN_TYPE);\n       } else {\n         FunctionType ct = constructorType.toMaybeFunctionType();\n-        if (ct == null && constructorType instanceof FunctionType) {\n+        if (ct == null && constructorType.isFunctionType()) {\n           // If constructorType is a NoObjectType, then toMaybeFunctionType will\n           // return null. But NoObjectType implements the FunctionType\n           // interface, precisely because it can validly construct objects.\n@@ -1056,11 +1053,59 @@ class TypeInference\n       }\n     }\n     n.setJSType(type);\n-    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n-      scope = traverse(arg, scope);\n-    }\n-    return scope;\n-  }\n+    if (constructor.getNext() != null) {\n+      Node args = constructor.getNext();\n+      if (!args.hasChildren()) {\n+        // This handles the infrequently-used case of \"new Foo()\".\n+        // If the constructor has required parameters, this will catch that case\n+        // too.\n+        scope = tightenType(Registry.get().getNativeObjectType(OBJECT_TYPE), type, scope, n);\n+      } else {\n+        // There are arguments, so constrain the constructor return type\n+        // accordingly\n+        boolean allScalar = true;\n+        boolean allFunction = true;\n+        int i = 0;\n+        for (Node arg = args.getFirstChild(); arg != null; arg = arg.getNext()) {\n+          scope = traverse(arg, scope);\n+          JSType argType = arg.getJSType();\n+          if (argType != null && !argType.isScalar()) {\n+            allScalar = false;\n+          }\n+          if (argType != null && !argType.isFunctionType()) {\n+            allFunction = false;\n+          }\n+          i++;\n+        }\n+        if (constructorType != null) {\n+          if (allScalar) {\n+            if (allFunction && i == 2) {\n+              // Preserve the existing type for 'this'.\n+              type = getNativeType(FUNCTION_TYPE);\n+              JSType returnType =\n+                  constructorType.toMaybeFunctionType().getReturnType();\n+              if (returnType != null) {\n+                type = getRegistry().createFunctionType(\n+                    returnType.restrictByNotNullOrUndefined(), type, null, n);\n+              }\n+            } else {\n+              type = withTypeFromNode(args.getFirstChild(), constructorType.restrictByNotNullOrUndefined(), JSType.NULL);\n+            }\n+            // Tighten the inferred type of the construtor.\n+            type = tightenType(\n+                Registry.get().getNativeObjectType(OBJECT_TYPE),\n+                type, scope, n);\n+          } else {\n+            // Some of the arguments were not scalars, so the constructor type\n+            // does not yield an object. Use the declared type of the object.\n+            type = withTypeFromNode(args.getFirstChild(), getRegistry().getNativeType(OBJECT_TYPE), JSType.NULL);\n+          }\n+        }\n+      }\n+    } else if (constructorType != null && constructorType.isConstructor()) {\n+      // There are no arguments, and constructorType is non-null.\n+      // This constructor has no arguments, so we set type to the object type.\n+      type = constructorType.toMaybeFunctionType().getInstanceType();\n \n   private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {\n     return traverseShortCircuitingBinOp(n, scope, true);",
    "result_reason": "error: <identifier> expected",
    "test_result": "ERROR"
}