{
    "patch": "        final int maxEval = getMaxEvaluations();\n        double a = min;\n        double b = max;\n        double c = initial; // was declared, but not written inside the function solve()\n        double d = 0.0;\n        double fa; // f(a)\n        double fb; // f(b)\n        double fc = yInitial; // f(c)\n        double eps = getAbsoluteAccuracy();\n        double tol = getRelativeAccuracy();\n        double m;\n        double p;\n        double q;\n        double r;\n        double s;\n        double inverseGoldenRatio = 0.5 * (3 - Math.sqrt(5));\n        double newStep;\n        double prevStep = Double.MAX_VALUE;\n\n        verifyInterval(min, max);\n\n        fa = f.value(a);\n        fb = f.value(b);\n\n        // make sure we iterate enough times\n        int iteration = 0;\n        while (iteration++ < maxEval) {\n            if ((fb > 0 && fc > 0) || (fb <= 0 && fc <= 0)) {\n                c = a;\n                fc = fa;\n                d = b - a;\n                e = d;\n            }\n            if (Math.abs(fc) < Math.abs(fb)) {\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            double tmp1 = 2 * eps * Math.abs(b) + 0.5 * tol;\n            double tmp2 = eps * Math.abs(c) + 0.5 * tol;\n            double mTolerance = (tmp1 > tmp2) ? tmp1 : tmp2;\n\n            double tol1 = mTolerance;\n            double xm = 0.5 * (c - b);\n\n            if (Math.abs(xm) <= tol1 || Precision.equals(fb, 0.0, 1)) {\n                setResult(b, iteration - 1);\n                return result;\n            }\n            if (Math.abs(prevStep) >= tol1 && Math.abs(fa) > Math.abs(fb)) {\n                if (a == c) {\n                    // interpolate using quadratic polynominals\n                    double t1 = fb / fa;\n                    double p1 = t1 * (2 * xm - t1 * (c - a));\n                    double q1 = t1 - 1;\n                    fb = fa;\n                    fa = t1;\n                    double step = p1 / q1;\n                    double newA = b;\n                    double newB = (step > 0) ? (b + step) : (b + step * inverseGoldenRatio);\n                    if (Math.abs(newB - c) < Math.abs(step)) {\n                        step = c - b;\n                        newB = b + step * inverseGoldenRatio;\n                    }\n                } else {\n                    // interpolate using cubic polynomials\n                    double q1 = fa / fc;\n                    double q2 = fa / fb;\n                    double q3 = fb / fc;\n                    double r1 = (2 * xm - (b - a) * q1) / (c - a);\n                    double r2 = (q2 - q1) * (b - a) / (c - a);\n                    double r3 = q2 - q1;\n                    double delta;\n                    if ((r2 * r2 - r1 * r3) > 0) {\n                        delta = r2 + Math.sqrt(r2 * r2 - r1 * r3);\n                        double ivec;\n                        if (delta > 0) {\n                            ivec = b - (xm + (r3 / delta));\n                        } else {\n                            ivec = b - (xm - (r3 / r2));\n                        }\n                        double newB = b + ivec;\n                        double newC = c;\n                        double newStep = newB - b;\n                        if ((newStep > 0 && newStep < tol1) || Precision.equals(newStep, 0.0, 1)) {\n                            newStep = tol1;\n                        }\n                        // if step is too small, use b + sign(b - a) * tol1 instead\n                        if ((newStep < tol1 / 2) &&\n                                (newB > b || newB < a)) {\n                            double correction = (b < a) ? tol1 : -tol1;\n                            newB = b + correction;\n                            newStep = tol1;\n                        }\n                        // if step is too large, use b + sign(xm - b) * tol1 instead\n                        if ((newStep > 0.5 * prevStep) &&\n                                (newB < b || newB > c)) {\n                            double correction = (xm < b) ? tol1 : -tol1;\n                            newB = b + correction;\n                            newStep = tol1;\n                        }\n\n                        d = xm;\n                        a = b;\n                        fa = fb;\n                        b = newB;\n                        fb = f.value(b);\n                        c = (Math.abs(fc) > Math.abs(fb)) ? d : xm;\n                        fc = f.value(c);\n                    }\n                }\n            } else {\n                if (xm >= 0) {\n                    e = a - b;\n                } else {\n                    e = c - a;\n                }\n                d = inverseGoldenRatio * e;\n            }\n            if (Math.abs(d) >= tol1) {\n                double newA;\n                if (xm >= 0) {\n                    newA = b;\n                } else {\n                    newA = c;\n                }\n                newStep = d;\n            } else {\n                if (xm >= 0) {\n                    newA = b;\n                } else {\n                    newA = c;\n                }\n                newStep = tol1 * (xm >= 0 ? 1 : -1);\n            }\n            double newB = b + newStep;\n            double nextFb = f.value(newB);\n            if ((nextFb > 0 && fb > 0) ||\n                    (nextFb <= 0 && fb <= 0)) {\n                prevStep = b - c;\n                c = a;\n                fc = fa;\n                d = inverseGoldenRatio * (b - a);\n                e = d;\n            } else {\n                prevStep = c - b;\n                a = b;\n                fa = fb;\n                b = newB;\n                fb = nextFb;\n            }\n        }\n\n        throw new MaxIterationsExceededException(maxEval);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..d5a0b62ed 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,164 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        final int maxEval = getMaxEvaluations();\n+        double a = min;\n+        double b = max;\n+        double c = initial; // was declared, but not written inside the function solve()\n+        double d = 0.0;\n+        double fa; // f(a)\n+        double fb; // f(b)\n+        double fc = yInitial; // f(c)\n+        double eps = getAbsoluteAccuracy();\n+        double tol = getRelativeAccuracy();\n+        double m;\n+        double p;\n+        double q;\n+        double r;\n+        double s;\n+        double inverseGoldenRatio = 0.5 * (3 - Math.sqrt(5));\n+        double newStep;\n+        double prevStep = Double.MAX_VALUE;\n+\n+        verifyInterval(min, max);\n+\n+        fa = f.value(a);\n+        fb = f.value(b);\n+\n+        // make sure we iterate enough times\n+        int iteration = 0;\n+        while (iteration++ < maxEval) {\n+            if ((fb > 0 && fc > 0) || (fb <= 0 && fc <= 0)) {\n+                c = a;\n+                fc = fa;\n+                d = b - a;\n+                e = d;\n+            }\n+            if (Math.abs(fc) < Math.abs(fb)) {\n+                a = b;\n+                b = c;\n+                c = a;\n+                fa = fb;\n+                fb = fc;\n+                fc = fa;\n+            }\n+\n+            double tmp1 = 2 * eps * Math.abs(b) + 0.5 * tol;\n+            double tmp2 = eps * Math.abs(c) + 0.5 * tol;\n+            double mTolerance = (tmp1 > tmp2) ? tmp1 : tmp2;\n+\n+            double tol1 = mTolerance;\n+            double xm = 0.5 * (c - b);\n+\n+            if (Math.abs(xm) <= tol1 || Precision.equals(fb, 0.0, 1)) {\n+                setResult(b, iteration - 1);\n+                return result;\n+            }\n+            if (Math.abs(prevStep) >= tol1 && Math.abs(fa) > Math.abs(fb)) {\n+                if (a == c) {\n+                    // interpolate using quadratic polynominals\n+                    double t1 = fb / fa;\n+                    double p1 = t1 * (2 * xm - t1 * (c - a));\n+                    double q1 = t1 - 1;\n+                    fb = fa;\n+                    fa = t1;\n+                    double step = p1 / q1;\n+                    double newA = b;\n+                    double newB = (step > 0) ? (b + step) : (b + step * inverseGoldenRatio);\n+                    if (Math.abs(newB - c) < Math.abs(step)) {\n+                        step = c - b;\n+                        newB = b + step * inverseGoldenRatio;\n+                    }\n+                } else {\n+                    // interpolate using cubic polynomials\n+                    double q1 = fa / fc;\n+                    double q2 = fa / fb;\n+                    double q3 = fb / fc;\n+                    double r1 = (2 * xm - (b - a) * q1) / (c - a);\n+                    double r2 = (q2 - q1) * (b - a) / (c - a);\n+                    double r3 = q2 - q1;\n+                    double delta;\n+                    if ((r2 * r2 - r1 * r3) > 0) {\n+                        delta = r2 + Math.sqrt(r2 * r2 - r1 * r3);\n+                        double ivec;\n+                        if (delta > 0) {\n+                            ivec = b - (xm + (r3 / delta));\n+                        } else {\n+                            ivec = b - (xm - (r3 / r2));\n+                        }\n+                        double newB = b + ivec;\n+                        double newC = c;\n+                        double newStep = newB - b;\n+                        if ((newStep > 0 && newStep < tol1) || Precision.equals(newStep, 0.0, 1)) {\n+                            newStep = tol1;\n+                        }\n+                        // if step is too small, use b + sign(b - a) * tol1 instead\n+                        if ((newStep < tol1 / 2) &&\n+                                (newB > b || newB < a)) {\n+                            double correction = (b < a) ? tol1 : -tol1;\n+                            newB = b + correction;\n+                            newStep = tol1;\n+                        }\n+                        // if step is too large, use b + sign(xm - b) * tol1 instead\n+                        if ((newStep > 0.5 * prevStep) &&\n+                                (newB < b || newB > c)) {\n+                            double correction = (xm < b) ? tol1 : -tol1;\n+                            newB = b + correction;\n+                            newStep = tol1;\n+                        }\n+\n+                        d = xm;\n+                        a = b;\n+                        fa = fb;\n+                        b = newB;\n+                        fb = f.value(b);\n+                        c = (Math.abs(fc) > Math.abs(fb)) ? d : xm;\n+                        fc = f.value(c);\n+                    }\n+                }\n+            } else {\n+                if (xm >= 0) {\n+                    e = a - b;\n+                } else {\n+                    e = c - a;\n+                }\n+                d = inverseGoldenRatio * e;\n+            }\n+            if (Math.abs(d) >= tol1) {\n+                double newA;\n+                if (xm >= 0) {\n+                    newA = b;\n+                } else {\n+                    newA = c;\n+                }\n+                newStep = d;\n+            } else {\n+                if (xm >= 0) {\n+                    newA = b;\n+                } else {\n+                    newA = c;\n+                }\n+                newStep = tol1 * (xm >= 0 ? 1 : -1);\n+            }\n+            double newB = b + newStep;\n+            double nextFb = f.value(newB);\n+            if ((nextFb > 0 && fb > 0) ||\n+                    (nextFb <= 0 && fb <= 0)) {\n+                prevStep = b - c;\n+                c = a;\n+                fc = fa;\n+                d = inverseGoldenRatio * (b - a);\n+                e = d;\n+            } else {\n+                prevStep = c - b;\n+                a = b;\n+                fa = fb;\n+                b = newB;\n+                fb = nextFb;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maxEval);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}