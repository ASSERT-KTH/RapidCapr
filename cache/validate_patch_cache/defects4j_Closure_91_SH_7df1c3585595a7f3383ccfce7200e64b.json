{
    "patch": "     // Don't traverse functions that are getting lent to a prototype.\n+    if (n.isFunction() && parent != null && parent.isAssign()) {\n+      Node lhs = parent.getFirstChild();\n+      if (lhs.isGetProp()) {\n+        Node target = lhs.getFirstChild();\n+        if (target.matchesQualifiedName(\"prototype\")) {\n+          Node llhs = target.getFirstChild();\n+          boolean isPrototypeAssignment = false;\n+          while (llhs != null) {\n+            if (llhs.isGetProp() && llhs.getLastChild().getString().equals(\"prototype\")) {\n+              isPrototypeAssignment = true;\n+              break;\n+            }\n+            llhs = llhs.getFirstChild();\n+          }\n+          if (isPrototypeAssignment) {\n+            // A function assigned to the prototype, or a subproperty of the prototype,\n+            // should only be traversed if the lhs of the current assign is the same\n+            // as the lhs of the current function.\n+            Node curLhs = n.getParent().getFirstChild();\n+            Node assign = n.getParent().getParent();\n+            while (assign != null) {\n+              // Check if the current lhs is the same as the lhs of the current assign.\n+              if (curLhs.isEquivalentTo(target)) {\n+                return true;\n+              }\n+              assign = assign.getParent(); \n+              if (assign != null) {\n+                curLhs = assign.getFirstChild();\n+                // If we've moved out of the current assign, it means we're looking\n+                // at an enclosing assign, so we need to move up one level in the\n+                // llhs hierarchy.\n+                if (NodeUtil.isGet(curLhs)) {\n+                  curLhs = curLhs.getFirstChild();\n+                }\n+              }\n+            }\n+            return false;\n+          }\n+        }\n+      }\n+    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..fe8b3bf6 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,48 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+     // Don't traverse functions that are getting lent to a prototype.\n++    if (n.isFunction() && parent != null && parent.isAssign()) {\n++      Node lhs = parent.getFirstChild();\n++      if (lhs.isGetProp()) {\n++        Node target = lhs.getFirstChild();\n++        if (target.matchesQualifiedName(\"prototype\")) {\n++          Node llhs = target.getFirstChild();\n++          boolean isPrototypeAssignment = false;\n++          while (llhs != null) {\n++            if (llhs.isGetProp() && llhs.getLastChild().getString().equals(\"prototype\")) {\n++              isPrototypeAssignment = true;\n++              break;\n++            }\n++            llhs = llhs.getFirstChild();\n++          }\n++          if (isPrototypeAssignment) {\n++            // A function assigned to the prototype, or a subproperty of the prototype,\n++            // should only be traversed if the lhs of the current assign is the same\n++            // as the lhs of the current function.\n++            Node curLhs = n.getParent().getFirstChild();\n++            Node assign = n.getParent().getParent();\n++            while (assign != null) {\n++              // Check if the current lhs is the same as the lhs of the current assign.\n++              if (curLhs.isEquivalentTo(target)) {\n++                return true;\n++              }\n++              assign = assign.getParent(); \n++              if (assign != null) {\n++                curLhs = assign.getFirstChild();\n++                // If we've moved out of the current assign, it means we're looking\n++                // at an enclosing assign, so we need to move up one level in the\n++                // llhs hierarchy.\n++                if (NodeUtil.isGet(curLhs)) {\n++                  curLhs = curLhs.getFirstChild();\n++                }\n++              }\n++            }\n++            return false;\n++          }\n++        }\n++      }\n++    }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}