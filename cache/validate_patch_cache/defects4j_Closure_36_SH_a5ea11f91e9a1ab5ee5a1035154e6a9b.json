{
    "patch": "  public CallMatch tryToInlineMethodCall(\n        SideEffectCall callNode,\n        NodeTraversal t,\n        DefinitionUseSite definitionSite,\n        boolean aggressiveInlining) {\n      Node expression = callNode.getExpression();\n      if (expression.isSuper()) {\n        // Skip super call nodes\n        return null;\n      }\n\n      Reference ref = definitionSite.getReference();\n      Node function = ref.getNode();\n\n      // If it's a getter and a simple variable (not an expression), insert the\n      // variable in place of the call\n      // e.g. for \"goog.module.get('base')\", replace with the node for the module\n      // exports object\n      if (function.isGetProp() && isSimpleValue(function.getLastChild())) {\n        // Calculate the node to replace the call with\n        Node replacement = null;\n        Node prop = function.getLastChild();\n        JSType type = prop.getJSType();\n        if (type != null && type.isModuleExportsType()) {\n          return null;\n        }\n\n        // Find a replacement for the getter\n        if (NodeUtil.mayHaveSideEffects(function.getFirstChild())) {\n          if (NodeUtil.isCallTo(function, \"goog.getMsg\") ||\n              NodeUtil.isCallTo(function, \"goog.getTypedMsgWithPlaceholders\")) {\n            Node msgNode = NodeUtil.getInvocationArgsOnly(function).getFirstChild();\n            CheckLevel level =\n                CheckLevel\n                    .valueOf(stringMap.get(\"process_message_placeholders\").toUpperCase());\n            MessageVisitor visitor = new MessageVisitor(level);\n            NodeTraversal.traverse(compiler, msgNode, visitor);\n            Node newNode = visitor.getMessageNode();\n            if (newNode != null) {\n              replacement = newNode;\n            }\n          }\n        } else if (prop.isString()) {\n          String property = prop.getString();\n          if (type != null) {\n            ObjectType objType = ObjectType.cast(type).getImplicitPrototype();\n            if (objType.hasOwnProperty(property)) {\n              replacement = type.toMaybeObjectType().getPropertyReference(prop.getString());\n            }\n          }\n        }\n\n        if (replacement != null) {\n          definitionSite.setDefinition(replacement);\n          NodeUtil.deleteNode(callNode);\n          t.reportCodeChange();\n          return new SimpleStatementMatch(replacement);\n        }\n\n        return null;\n      }\n\n      // Can only inline if the callee is a function and not a variable or field\n      if (!function.isFunction()) {\n        return null;\n      }\n\n      // Make sure there are no local side effects within the call.\n      // Isolate the expression subtree for the call.\n      Node previousLastStatementInBlock = t.getCompiler().getLastStatementInEnclosingBlock(callNode);\n      Node previousLastStatementInFunction = t.getCompiler().getLastFunctionStatement(callNode);\n      Node originalParent = callNode.getParent();\n      boolean canInline = canInlineCall(t, callNode, function, aggressiveInlining);\n\n      if (!hasSideEffectsWithinExpression(callNode, t)) {\n        JSType typeOfThis = ref.getScope().getTypeOfThis();\n        Set<String> thisProperties = canInline ?\n            getThisPropertiesOnFunction(function, t.getScopeCreator()) : null;\n        Node inlineRoot;\n        if (canInline && shouldInline(typeOfThis, thisProperties, function)) {\n          inlineRoot = NodeUtil.tryInlineNode(callNode, function.getParent(), function, t);\n        } else {\n          // Inlining prohibited, convert to a function callback\n          inlineRoot =\n              IR.call(\n                      IR.createGetElem(\n                          IR.getprop(IR.name(\"Function\"), IR.string(\"prototype\")),\n                          IR.string(\"call\")))\n                  .useSourceInfoIfMissingFrom(callNode);\n          inlineRoot.putBooleanProp(Node.FREE_CALL, true);\n          inlineRoot.addChildToBack(expression.cloneTree());\n          inlineRoot.addChildToBack(\n              IR.createThis(\n                  NodeUtil.getRootOfQualifiedName(callNode.getFirstChild()).getQualifiedName()));\n          for (Node arg = expression.getNext(); arg != null; arg = arg.getNext()) {\n            inlineRoot.addChildToBack(arg.cloneTree());\n          }\n          inlineRoot = IR.exprResult(inlineRoot).useSourceInfoIfMissingFrom(callNode);\n          NodeUtil.insertBefore(callNode, inlineRoot);\n          inlineRoot.setOriginalEncoding(callNode.getOriginalEncoding());\n        }\n\n        // Note that the call node may already have been removed\n        return new SimpleStatementMatch(inlineRoot);\n      }\n\n      // The call node has local side-effects and cannot be inlined.\n      if (previousLastStatementInBlock != callNode && originalParent.isBlock()) {\n        // If we managed to inline the previous call in the block\n        // remove the block.\n        Node block = originalParent;\n        if (!t.getCompiler().hasLiveReferences(block)) {\n          NodeUtil.removeChild(previousLastStatementInBlock.getParent(), previousLastStatementInBlock);\n          t.reportCodeChange();\n          return new CodeBlockMatch(block);\n        }\n        // Don't try to inline again if the previous inlining failed\n        return null;\n      }\n\n      if (originalParent.isExprResult()) {\n        Node replacement = IR.var(IR.name(TEMP_NAME), expression)\n            .useSourceInfoIfMissingFrom(callNode)\n            .setOriginalEncoding(callNode.getOriginalEncoding());\n        NodeUtil.insertBefore(callNode.getParent(), replacement);\n        NodeUtil.deleteNode(callNode);\n        t.reportCodeChange();\n        return new SimpleStatementMatch(replacement);\n      } else if (callNode.getParent().isAssign()) {\n        // can't inline, but we can remove the \"unused value\" error\n        callNode.getParent().setJSDocInfo(null);\n        return null;\n      } else {\n        return null;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..3a0b87a2 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,140 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+  public CallMatch tryToInlineMethodCall(\n+        SideEffectCall callNode,\n+        NodeTraversal t,\n+        DefinitionUseSite definitionSite,\n+        boolean aggressiveInlining) {\n+      Node expression = callNode.getExpression();\n+      if (expression.isSuper()) {\n+        // Skip super call nodes\n+        return null;\n+      }\n+\n+      Reference ref = definitionSite.getReference();\n+      Node function = ref.getNode();\n+\n+      // If it's a getter and a simple variable (not an expression), insert the\n+      // variable in place of the call\n+      // e.g. for \"goog.module.get('base')\", replace with the node for the module\n+      // exports object\n+      if (function.isGetProp() && isSimpleValue(function.getLastChild())) {\n+        // Calculate the node to replace the call with\n+        Node replacement = null;\n+        Node prop = function.getLastChild();\n+        JSType type = prop.getJSType();\n+        if (type != null && type.isModuleExportsType()) {\n+          return null;\n+        }\n+\n+        // Find a replacement for the getter\n+        if (NodeUtil.mayHaveSideEffects(function.getFirstChild())) {\n+          if (NodeUtil.isCallTo(function, \"goog.getMsg\") ||\n+              NodeUtil.isCallTo(function, \"goog.getTypedMsgWithPlaceholders\")) {\n+            Node msgNode = NodeUtil.getInvocationArgsOnly(function).getFirstChild();\n+            CheckLevel level =\n+                CheckLevel\n+                    .valueOf(stringMap.get(\"process_message_placeholders\").toUpperCase());\n+            MessageVisitor visitor = new MessageVisitor(level);\n+            NodeTraversal.traverse(compiler, msgNode, visitor);\n+            Node newNode = visitor.getMessageNode();\n+            if (newNode != null) {\n+              replacement = newNode;\n+            }\n+          }\n+        } else if (prop.isString()) {\n+          String property = prop.getString();\n+          if (type != null) {\n+            ObjectType objType = ObjectType.cast(type).getImplicitPrototype();\n+            if (objType.hasOwnProperty(property)) {\n+              replacement = type.toMaybeObjectType().getPropertyReference(prop.getString());\n+            }\n+          }\n+        }\n+\n+        if (replacement != null) {\n+          definitionSite.setDefinition(replacement);\n+          NodeUtil.deleteNode(callNode);\n+          t.reportCodeChange();\n+          return new SimpleStatementMatch(replacement);\n+        }\n+\n+        return null;\n+      }\n+\n+      // Can only inline if the callee is a function and not a variable or field\n+      if (!function.isFunction()) {\n+        return null;\n+      }\n+\n+      // Make sure there are no local side effects within the call.\n+      // Isolate the expression subtree for the call.\n+      Node previousLastStatementInBlock = t.getCompiler().getLastStatementInEnclosingBlock(callNode);\n+      Node previousLastStatementInFunction = t.getCompiler().getLastFunctionStatement(callNode);\n+      Node originalParent = callNode.getParent();\n+      boolean canInline = canInlineCall(t, callNode, function, aggressiveInlining);\n+\n+      if (!hasSideEffectsWithinExpression(callNode, t)) {\n+        JSType typeOfThis = ref.getScope().getTypeOfThis();\n+        Set<String> thisProperties = canInline ?\n+            getThisPropertiesOnFunction(function, t.getScopeCreator()) : null;\n+        Node inlineRoot;\n+        if (canInline && shouldInline(typeOfThis, thisProperties, function)) {\n+          inlineRoot = NodeUtil.tryInlineNode(callNode, function.getParent(), function, t);\n+        } else {\n+          // Inlining prohibited, convert to a function callback\n+          inlineRoot =\n+              IR.call(\n+                      IR.createGetElem(\n+                          IR.getprop(IR.name(\"Function\"), IR.string(\"prototype\")),\n+                          IR.string(\"call\")))\n+                  .useSourceInfoIfMissingFrom(callNode);\n+          inlineRoot.putBooleanProp(Node.FREE_CALL, true);\n+          inlineRoot.addChildToBack(expression.cloneTree());\n+          inlineRoot.addChildToBack(\n+              IR.createThis(\n+                  NodeUtil.getRootOfQualifiedName(callNode.getFirstChild()).getQualifiedName()));\n+          for (Node arg = expression.getNext(); arg != null; arg = arg.getNext()) {\n+            inlineRoot.addChildToBack(arg.cloneTree());\n+          }\n+          inlineRoot = IR.exprResult(inlineRoot).useSourceInfoIfMissingFrom(callNode);\n+          NodeUtil.insertBefore(callNode, inlineRoot);\n+          inlineRoot.setOriginalEncoding(callNode.getOriginalEncoding());\n+        }\n+\n+        // Note that the call node may already have been removed\n+        return new SimpleStatementMatch(inlineRoot);\n+      }\n+\n+      // The call node has local side-effects and cannot be inlined.\n+      if (previousLastStatementInBlock != callNode && originalParent.isBlock()) {\n+        // If we managed to inline the previous call in the block\n+        // remove the block.\n+        Node block = originalParent;\n+        if (!t.getCompiler().hasLiveReferences(block)) {\n+          NodeUtil.removeChild(previousLastStatementInBlock.getParent(), previousLastStatementInBlock);\n+          t.reportCodeChange();\n+          return new CodeBlockMatch(block);\n+        }\n+        // Don't try to inline again if the previous inlining failed\n+        return null;\n+      }\n+\n+      if (originalParent.isExprResult()) {\n+        Node replacement = IR.var(IR.name(TEMP_NAME), expression)\n+            .useSourceInfoIfMissingFrom(callNode)\n+            .setOriginalEncoding(callNode.getOriginalEncoding());\n+        NodeUtil.insertBefore(callNode.getParent(), replacement);\n+        NodeUtil.deleteNode(callNode);\n+        t.reportCodeChange();\n+        return new SimpleStatementMatch(replacement);\n+      } else if (callNode.getParent().isAssign()) {\n+        // can't inline, but we can remove the \"unused value\" error\n+        callNode.getParent().setJSDocInfo(null);\n+        return null;\n+      } else {\n+        return null;\n         }\n       }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}