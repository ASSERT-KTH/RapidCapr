{
    "patch": "package com.google.javascript.jscomp.parsing;\n\nimport com.google.common.collect.ImmutableSet;\nimport org.mozilla.javascript.Node;\nimport org.mozilla.javascript.Token;\nimport org.mozilla.javascript.ast.*;\n\nimport java.util.Set;\n\npublic class IRFactory {\n\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n  private static final Set<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\", \"use asm\");\n\n  public IRFactory(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  private Node processGeneric(Node n) {\n    throw new UnsupportedOperationException(n.shortName());\n  }\n\n  private Node newNode(int type, Node... children) {\n    Node n = new Node(type);\n    for (Node c : children) {\n      n.addChildToBack(c);\n    }\n    return n;\n  }\n\n  private Node transform(AstNode n) {\n    return dispatch((Node) n);\n  }\n\n  private int transformTokenType(int jsType) {\n    switch (jsType) {\n      case Token.TRUE:\n        return Token.TRUE;\n      case Token.FALSE:\n        return Token.FALSE;\n      case Token.NULL:\n        return Token.NULL;\n      case Token.THIS:\n        return Token.THIS;\n      case Token.FUNCTION:\n        return Token.FUNCTION;\n      case Token.NEW:\n        return Token.NEW;\n      case Token.INC:\n        return Token.INC;\n      case Token.DEC:\n        return Token.DEC;\n      case Token.TYPEOF:\n        return Token.TYPEOF;\n      case Token.VOID:\n        return Token.VOID;\n      case Token.NOT:\n        return Token.NOT;\n      case Token.BITNOT:\n        return Token.BITNOT;\n      // ...\n      default:\n        throw new IllegalStateException(\"Unexpected JsToken type: \" + jsType);\n    }\n  }\n\n  private Node transformBlock(Block blockNode) {\n    Node n = newNode(Token.BLOCK);\n    for (Node c = blockNode.getFirstChild(); c != null; c = c.getNext()) {\n      n.addChildToBack(transform(c));\n    }\n    return n;\n  }\n\n  private Node transformVariableInitializer(AstNode varInit) {\n    // All variable initializers should be wrapped in an ASSIGN node without a LEFT child.\n    return newNode(Token.ASSIGN, transform(varInit));\n  }\n\n  private Node transformVariableDeclaration(VariableDeclaration varDecl) {\n    Node n = newNode(Token.VAR);\n    for (VariableInitializer varInit : varDecl.getVariables()) {\n      Node varInitNode = transformVariableInitializer(varInit);\n      if (varInit.getInitializer() == null) {\n        // Ensures that variables that are not initialized explicitly are marked as \"uninitialized\"\n        varInitNode.setIsNewLocal(true);\n      }\n      n.addChildToBack(varInitNode);\n    }\n    return n;\n  }\n\n  private Node dispatch(Node n) {\n    return ((TypeSafeDispatcher) dispatcher).process(n);\n  }\n\n  // Dispatchers.\n  private static final Object dispatcher =\n      new Object() {\n        Node process(AstRoot node) {\n          return newNode(Token.SCRIPT, transformBlock(node));\n        }\n\n        Node process(InfixExpression node) {\n          return newNode(\n              Token.ADD,\n              transform(node.getLeft()),\n              transform(node.getRight()));\n        }\n\n        Node process(VariableInitializer n) {\n          Node varName = transform(n.getTarget());\n          Node varInit = n.getInitializer() != null ? transform(n.getInitializer()) : null;\n          return newNode(Token.NAME, varName, varInit);\n        }\n\n        Node process(Name n) {\n          return newNode(Token.NAME, n.getIdentifier());\n        }\n\n        Node process(BooleanLiteral n) {\n          return newNode(n.isTrue() ? Token.TRUE : Token.FALSE);\n        }\n\n        boolean isDirective(AstNode n) {\n          return n.getType() == Token.EXPR_RESULT &&\n              n.getFirstChild() instanceof StringLiteral &&\n              ALLOWED_DIRECTIVES.contains(\n                  ((StringLiteral) n.getFirstChild()).getValue());\n        }\n\n        Node process(Parser.StatementWithScope node) {\n          Block body = node.getStatement();\n          Node block = newNode(Token.BLOCK, transformBlock(body));\n          for (AstNode directive : body.getDirectives()) {\n            if (!isDirective(directive)) {\n              block.addChildToFront(transform(directive));\n            }\n          }\n          return block;\n        }\n\n        Node process(ArrayLiteral node) {\n          Node array = newNode(Token.ARRAYLIT);\n          for (AstNode element : node.getElements()) {\n            if (element == null) {\n              array.addChildToBack(newNode(Token.EMPTY));\n            } else {\n              array.addChildToBack(transform(element));\n            }\n          }\n          return array;\n        }\n\n        Node process(FunctionCall node) {\n          Node call = newNode(Token.CALL, transform(node.getTarget()));\n          for (AstNode arg : node.getArguments()) {\n            call.addChildToBack(transform(arg));\n          }\n          return call;\n        }\n\n        Node process(ExpressionStatement node) {\n          Node expr = newNode(transformTokenType(node.getType()));\n          expr.addChildToBack(transform(node.getExpression()));\n          return expr;\n        }\n\n        Node process(FunctionNode node) {\n          Node fn = newNode(Token.FUNCTION);\n          // name comes from getFunctionName()\n          fn.addChildToBack(transform(node.getParams()));\n          fn.addChildToBack(transformBlock(node.getBody()));\n          return fn;\n        }\n\n        Node process(ParenthesizedExpression node) {\n          return newNode(Token.PARENTHESIS, transform(node.getExpression()));\n        }\n\n        Node process(NumberLiteral n) {\n          Node number = newNode(Token.NUMBER);\n          number.setString(n.getNumber().toString());\n          return number;\n        }\n\n        Node process(StringLiteral n) {\n          Node string = newNode(Token.STRING);\n          string.setString(n.getValue());\n          return string;\n        }\n\n        Node process(UnaryExpression node) {\n          return newNode(\n              node.isPrefix() ? node.getType() : Token.POSTFIX,\n              transform(node.getOperand()));\n        }\n\n        Node process(ThrowStatement node) {\n          return newNode(Token.THROW, transform(node.getExpression()));\n        }\n\n        Node process(TryStatement node) {\n          Node tryBlock = transformBlock(node.getTryBlock());\n          Node catchBlock = node.getCatchBlock() != null ?\n              transformBlock(node.getCatchBlock()) : null;\n          Node finallyBlock = node.getFinallyBlock() != null ?\n              transformBlock(node.getFinallyBlock()) : null;\n          if (catchBlock == null && finallyBlock == null) {\n            return tryBlock;\n          } else if (finallyBlock == null) {\n            return newNode(Token.TRY, tryBlock, catchBlock);\n          } else if (catchBlock == null) {\n            return newNode(Token.TRY, tryBlock, finallyBlock);\n          } else {\n            return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n          }\n        }\n\n        Node process(WhileLoop node) {\n          return newNode(\n              Token.WHILE,\n              transform(node.getCondition()),\n              transformBlock(node.getBody()));\n        }\n\n        Node process(ForLoop node) {\n          return newNode(\n              Token.FOR,\n              transform(node.getInitializer()),\n              transform(node.getCondition()),\n              transform(node.getIncrement()),\n              transformBlock(node.getBody()));\n        }\n\n        Node process(ForInLoop node) {\n          return newNode(\n              Token.FOR,\n              transformVariableDeclaration(node.getIterator()),\n              transform(node.getIteratedObject()),\n              transformBlock(node.getBody()));\n        }\n\n        Node process(DoLoop node) {\n          return newNode(\n              Token.DO,\n              transformBlock(node.getBody()),\n              transform(node.getCondition()));\n        }\n\n        Node process(IfStatement node) {\n          return newNode(\n              Token.IF,\n              transform(node.getCondition()),\n              transformBlock(node.getThenPart()),\n              node.getElsePart() == null ? null : transformBlock(node.getElsePart()));\n        }\n\n        Node process(SwitchStatement node) {\n          Node sw = newNode(Token.SWITCH, transform(node.getExpression()));\n          for (SwitchCase switchCase : node.getCases()) {\n            Node caseBody = newNode(Token.BLOCK);\n            for (AstNode caseClause : switchCase.getStatements()) {\n              caseBody.addChildToBack(transform(caseClause));\n            }\n            if (switchCase.getExpression() == null) {\n              sw.addChildToBack(newNode(Token.DEFAULT, caseBody));\n            } else {\n              sw.addChildToBack(newNode(Token.CASE, transform(switchCase.getExpression()), caseBody));\n            }\n          }\n          return sw;\n        }\n\n        Node process(BreakStatement node) {\n          Node br = newNode(Token.BREAK);\n          if (node.getBreakLabel() != null) {\n            br.addChildToBack(newNode(Token.LABEL_NAME, node.getBreakLabel()));\n          }\n          return br;\n        }\n\n        Node process(ContinueStatement node) {\n          Node cr = newNode(Token.CONTINUE);\n          if (node.getLabel() != null) {\n            cr.addChildToBack(newNode(Token.LABEL_NAME, node.getLabel()));\n          }\n          return cr;\n        }\n\n        Node process(ReturnStatement node) {\n          Node ret = newNode(Token.RETURN);\n          if (node.getReturnValue() != null) {\n            ret.addChildToBack(transform(node.getReturnValue()));\n          }\n          return ret;\n        }\n\n        Node process(ObjectLiteral node) {\n          Node obj = newNode(Token.OBJECTLIT);\n          for (ObjectProperty prop : node.getElements()) {\n            AstNode key = prop.getLeft();\n            AstNode value = prop.getRight();\n            if (prop.isGetter()) {\n              Node member = newNode(Token.GETTER_DEF, transform(key), transform(value));\n              member.putProp(Node.SPECIAL_PROP_PROP, Boolean.TRUE);\n              obj.addChildToBack(member);\n            } else if (prop.isSetter()) {\n              Node member = newNode(Token.SETTER_DEF, transform(key), transform(value));\n              member.putProp(Node.SPECIAL_PROP_PROP, Boolean.TRUE);\n              obj.addChildToBack(member);\n            } else {\n              Node member = newNode(Token.STRING_KEY, transform(key), transform(value));\n              obj.addChildToBack(member);\n            }\n          }\n          return obj;\n        }\n\n        Node process(RegExpLiteral node) {\n          Node regex = newNode(Token.REGEXP);\n          regex.setRegExp(n.getValue(), node.getFlags());\n          return regex;\n        }\n\n        Node process(XmlString node) {\n          Node xml = newNode(Token.STRING);\n          xml.setString(node.getXml());\n          return xml;\n        }\n\n        Node process(XmlExpression node) {\n          return transform(node.getExpression());\n        }\n\n        Node process(TryCatchFinally node) {\n          Node tryNode = newNode(Token.TRY, transformBlock(node.getTryBlock()));\n          if (node.getCatchBlock() != null) {\n            Node catchNode = newNode(Token.CATCH, new Node(Token.NAME, node.getExceptionName()), transformBlock(\n                node.getCatchBlock()));\n            tryNode.addChildToBack(catchNode);\n          }\n          if (node.getFinallyBlock() != null) {\n            Node finallyNode = newNode(Token.FINALLY, transformBlock(node.getFinallyBlock()));\n            tryNode.addChildToBack(finallyNode);\n          }\n          return tryNode;\n        }\n\n        Node process(DefaultXmlNamespace node) {\n          Node xml = newNode(Token.DEFAULT_NS, transform(node.getNamespace()));\n          xml.setProp(Node.IS_NAMESPACE, true);\n          return xml;\n        }\n\n        Node process(LabeledStatement node) {\n          return newNode(Token.LABEL, new Node(Token.NAME, node.getLabelName()), transform(node.getStatement()));\n        }\n\n        Node process(ConditionalExpression node) {\n          return newNode(Token.HOOK,\n              transform(node.getTestExpression()),\n              transform(node.getTrueExpression()),\n              transform(node.getFalseExpression()));\n        }\n      };\n\n  public interface TypeSafeDispatcher {\n    Node process(AstRoot node);\n    Node process(InfixExpression node);\n    Node process(VariableInitializer node);\n    Node process(Name node);\n    Node process(BooleanLiteral node);\n    Node process(Parser.StatementWithScope node);\n    Node process(ArrayLiteral node);\n    Node process(FunctionCall node);\n    Node process(ExpressionStatement node);\n    Node process(FunctionNode node);\n    Node process(ParenthesizedExpression node);\n    Node process(NumberLiteral node);\n    Node process(StringLiteral node);\n    Node process(UnaryExpression node);\n    Node process(ThrowStatement node);\n    Node process(TryStatement node);\n    Node process(WhileLoop node);\n    Node process(ForLoop node);\n    Node process(ForInLoop node);\n    Node process(DoLoop node);\n    Node process(IfStatement node);\n    Node process(SwitchStatement node);\n    Node process(BreakStatement node);\n    Node process(ContinueStatement node);\n    Node process(ReturnStatement node);\n    Node process(ObjectLiteral node);\n    Node process(RegExpLiteral node);\n    Node process(XmlString node);\n    Node process(XmlExpression node);\n    Node process(TryCatchFinally node);\n    Node process(DefaultXmlNamespace node);\n    Node process(LabeledStatement node);\n    Node process(ConditionalExpression node);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..f6741cf0 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,412 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+package com.google.javascript.jscomp.parsing;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+import com.google.common.collect.ImmutableSet;\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+import org.mozilla.javascript.ast.*;\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+import java.util.Set;\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+public class IRFactory {\n+\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+  private static final Set<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\", \"use asm\");\n+\n+  public IRFactory(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n+\n+  private Node processGeneric(Node n) {\n+    throw new UnsupportedOperationException(n.shortName());\n+  }\n+\n+  private Node newNode(int type, Node... children) {\n+    Node n = new Node(type);\n+    for (Node c : children) {\n+      n.addChildToBack(c);\n     }\n+    return n;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  private Node transform(AstNode n) {\n+    return dispatch((Node) n);\n+  }\n+\n+  private int transformTokenType(int jsType) {\n+    switch (jsType) {\n+      case Token.TRUE:\n+        return Token.TRUE;\n+      case Token.FALSE:\n+        return Token.FALSE;\n+      case Token.NULL:\n+        return Token.NULL;\n+      case Token.THIS:\n+        return Token.THIS;\n+      case Token.FUNCTION:\n+        return Token.FUNCTION;\n+      case Token.NEW:\n+        return Token.NEW;\n+      case Token.INC:\n+        return Token.INC;\n+      case Token.DEC:\n+        return Token.DEC;\n+      case Token.TYPEOF:\n+        return Token.TYPEOF;\n+      case Token.VOID:\n+        return Token.VOID;\n+      case Token.NOT:\n+        return Token.NOT;\n+      case Token.BITNOT:\n+        return Token.BITNOT;\n+      // ...\n+      default:\n+        throw new IllegalStateException(\"Unexpected JsToken type: \" + jsType);\n     }\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  private Node transformBlock(Block blockNode) {\n+    Node n = newNode(Token.BLOCK);\n+    for (Node c = blockNode.getFirstChild(); c != null; c = c.getNext()) {\n+      n.addChildToBack(transform(c));\n     }\n+    return n;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  private Node transformVariableInitializer(AstNode varInit) {\n+    // All variable initializers should be wrapped in an ASSIGN node without a LEFT child.\n+    return newNode(Token.ASSIGN, transform(varInit));\n+  }\n+\n+  private Node transformVariableDeclaration(VariableDeclaration varDecl) {\n+    Node n = newNode(Token.VAR);\n+    for (VariableInitializer varInit : varDecl.getVariables()) {\n+      Node varInitNode = transformVariableInitializer(varInit);\n+      if (varInit.getInitializer() == null) {\n+        // Ensures that variables that are not initialized explicitly are marked as \"uninitialized\"\n+        varInitNode.setIsNewLocal(true);\n       }\n-      return node;\n+      n.addChildToBack(varInitNode);\n     }\n+    return n;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+  private Node dispatch(Node n) {\n+    return ((TypeSafeDispatcher) dispatcher).process(n);\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n+  // Dispatchers.\n+  private static final Object dispatcher =\n+      new Object() {\n+        Node process(AstRoot node) {\n+          return newNode(Token.SCRIPT, transformBlock(node));\n+        }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+        Node process(InfixExpression node) {\n+          return newNode(\n+              Token.ADD,\n+              transform(node.getLeft()),\n+              transform(node.getRight()));\n+        }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n-    }\n+        Node process(VariableInitializer n) {\n+          Node varName = transform(n.getTarget());\n+          Node varInit = n.getInitializer() != null ? transform(n.getInitializer()) : null;\n+          return newNode(Token.NAME, varName, varInit);\n+        }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+        Node process(Name n) {\n+          return newNode(Token.NAME, n.getIdentifier());\n+        }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+        Node process(BooleanLiteral n) {\n+          return newNode(n.isTrue() ? Token.TRUE : Token.FALSE);\n+        }\n+\n+        boolean isDirective(AstNode n) {\n+          return n.getType() == Token.EXPR_RESULT &&\n+              n.getFirstChild() instanceof StringLiteral &&\n+              ALLOWED_DIRECTIVES.contains(\n+                  ((StringLiteral) n.getFirstChild()).getValue());\n+        }\n+\n+        Node process(Parser.StatementWithScope node) {\n+          Block body = node.getStatement();\n+          Node block = newNode(Token.BLOCK, transformBlock(body));\n+          for (AstNode directive : body.getDirectives()) {\n+            if (!isDirective(directive)) {\n+              block.addChildToFront(transform(directive));\n+            }\n+          }\n+          return block;\n+        }\n+\n+        Node process(ArrayLiteral node) {\n+          Node array = newNode(Token.ARRAYLIT);\n+          for (AstNode element : node.getElements()) {\n+            if (element == null) {\n+              array.addChildToBack(newNode(Token.EMPTY));\n+            } else {\n+              array.addChildToBack(transform(element));\n+            }\n+          }\n+          return array;\n+        }\n+\n+        Node process(FunctionCall node) {\n+          Node call = newNode(Token.CALL, transform(node.getTarget()));\n+          for (AstNode arg : node.getArguments()) {\n+            call.addChildToBack(transform(arg));\n+          }\n+          return call;\n+        }\n+\n+        Node process(ExpressionStatement node) {\n+          Node expr = newNode(transformTokenType(node.getType()));\n+          expr.addChildToBack(transform(node.getExpression()));\n+          return expr;\n+        }\n+\n+        Node process(FunctionNode node) {\n+          Node fn = newNode(Token.FUNCTION);\n+          // name comes from getFunctionName()\n+          fn.addChildToBack(transform(node.getParams()));\n+          fn.addChildToBack(transformBlock(node.getBody()));\n+          return fn;\n+        }\n+\n+        Node process(ParenthesizedExpression node) {\n+          return newNode(Token.PARENTHESIS, transform(node.getExpression()));\n+        }\n+\n+        Node process(NumberLiteral n) {\n+          Node number = newNode(Token.NUMBER);\n+          number.setString(n.getNumber().toString());\n+          return number;\n+        }\n+\n+        Node process(StringLiteral n) {\n+          Node string = newNode(Token.STRING);\n+          string.setString(n.getValue());\n+          return string;\n+        }\n+\n+        Node process(UnaryExpression node) {\n+          return newNode(\n+              node.isPrefix() ? node.getType() : Token.POSTFIX,\n+              transform(node.getOperand()));\n+        }\n+\n+        Node process(ThrowStatement node) {\n+          return newNode(Token.THROW, transform(node.getExpression()));\n+        }\n+\n+        Node process(TryStatement node) {\n+          Node tryBlock = transformBlock(node.getTryBlock());\n+          Node catchBlock = node.getCatchBlock() != null ?\n+              transformBlock(node.getCatchBlock()) : null;\n+          Node finallyBlock = node.getFinallyBlock() != null ?\n+              transformBlock(node.getFinallyBlock()) : null;\n+          if (catchBlock == null && finallyBlock == null) {\n+            return tryBlock;\n+          } else if (finallyBlock == null) {\n+            return newNode(Token.TRY, tryBlock, catchBlock);\n+          } else if (catchBlock == null) {\n+            return newNode(Token.TRY, tryBlock, finallyBlock);\n+          } else {\n+            return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+          }\n+        }\n+\n+        Node process(WhileLoop node) {\n+          return newNode(\n+              Token.WHILE,\n+              transform(node.getCondition()),\n+              transformBlock(node.getBody()));\n+        }\n+\n+        Node process(ForLoop node) {\n+          return newNode(\n+              Token.FOR,\n+              transform(node.getInitializer()),\n+              transform(node.getCondition()),\n+              transform(node.getIncrement()),\n+              transformBlock(node.getBody()));\n+        }\n+\n+        Node process(ForInLoop node) {\n+          return newNode(\n+              Token.FOR,\n+              transformVariableDeclaration(node.getIterator()),\n+              transform(node.getIteratedObject()),\n+              transformBlock(node.getBody()));\n+        }\n+\n+        Node process(DoLoop node) {\n+          return newNode(\n+              Token.DO,\n+              transformBlock(node.getBody()),\n+              transform(node.getCondition()));\n+        }\n+\n+        Node process(IfStatement node) {\n+          return newNode(\n+              Token.IF,\n+              transform(node.getCondition()),\n+              transformBlock(node.getThenPart()),\n+              node.getElsePart() == null ? null : transformBlock(node.getElsePart()));\n+        }\n+\n+        Node process(SwitchStatement node) {\n+          Node sw = newNode(Token.SWITCH, transform(node.getExpression()));\n+          for (SwitchCase switchCase : node.getCases()) {\n+            Node caseBody = newNode(Token.BLOCK);\n+            for (AstNode caseClause : switchCase.getStatements()) {\n+              caseBody.addChildToBack(transform(caseClause));\n+            }\n+            if (switchCase.getExpression() == null) {\n+              sw.addChildToBack(newNode(Token.DEFAULT, caseBody));\n+            } else {\n+              sw.addChildToBack(newNode(Token.CASE, transform(switchCase.getExpression()), caseBody));\n+            }\n+          }\n+          return sw;\n+        }\n+\n+        Node process(BreakStatement node) {\n+          Node br = newNode(Token.BREAK);\n+          if (node.getBreakLabel() != null) {\n+            br.addChildToBack(newNode(Token.LABEL_NAME, node.getBreakLabel()));\n+          }\n+          return br;\n+        }\n+\n+        Node process(ContinueStatement node) {\n+          Node cr = newNode(Token.CONTINUE);\n+          if (node.getLabel() != null) {\n+            cr.addChildToBack(newNode(Token.LABEL_NAME, node.getLabel()));\n+          }\n+          return cr;\n+        }\n+\n+        Node process(ReturnStatement node) {\n+          Node ret = newNode(Token.RETURN);\n+          if (node.getReturnValue() != null) {\n+            ret.addChildToBack(transform(node.getReturnValue()));\n+          }\n+          return ret;\n+        }\n+\n+        Node process(ObjectLiteral node) {\n+          Node obj = newNode(Token.OBJECTLIT);\n+          for (ObjectProperty prop : node.getElements()) {\n+            AstNode key = prop.getLeft();\n+            AstNode value = prop.getRight();\n+            if (prop.isGetter()) {\n+              Node member = newNode(Token.GETTER_DEF, transform(key), transform(value));\n+              member.putProp(Node.SPECIAL_PROP_PROP, Boolean.TRUE);\n+              obj.addChildToBack(member);\n+            } else if (prop.isSetter()) {\n+              Node member = newNode(Token.SETTER_DEF, transform(key), transform(value));\n+              member.putProp(Node.SPECIAL_PROP_PROP, Boolean.TRUE);\n+              obj.addChildToBack(member);\n+            } else {\n+              Node member = newNode(Token.STRING_KEY, transform(key), transform(value));\n+              obj.addChildToBack(member);\n+            }\n+          }\n+          return obj;\n+        }\n+\n+        Node process(RegExpLiteral node) {\n+          Node regex = newNode(Token.REGEXP);\n+          regex.setRegExp(n.getValue(), node.getFlags());\n+          return regex;\n+        }\n+\n+        Node process(XmlString node) {\n+          Node xml = newNode(Token.STRING);\n+          xml.setString(node.getXml());\n+          return xml;\n+        }\n+\n+        Node process(XmlExpression node) {\n+          return transform(node.getExpression());\n+        }\n+\n+        Node process(TryCatchFinally node) {\n+          Node tryNode = newNode(Token.TRY, transformBlock(node.getTryBlock()));\n+          if (node.getCatchBlock() != null) {\n+            Node catchNode = newNode(Token.CATCH, new Node(Token.NAME, node.getExceptionName()), transformBlock(\n+                node.getCatchBlock()));\n+            tryNode.addChildToBack(catchNode);\n+          }\n+          if (node.getFinallyBlock() != null) {\n+            Node finallyNode = newNode(Token.FINALLY, transformBlock(node.getFinallyBlock()));\n+            tryNode.addChildToBack(finallyNode);\n+          }\n+          return tryNode;\n+        }\n+\n+        Node process(DefaultXmlNamespace node) {\n+          Node xml = newNode(Token.DEFAULT_NS, transform(node.getNamespace()));\n+          xml.setProp(Node.IS_NAMESPACE, true);\n+          return xml;\n+        }\n+\n+        Node process(LabeledStatement node) {\n+          return newNode(Token.LABEL, new Node(Token.NAME, node.getLabelName()), transform(node.getStatement()));\n+        }\n+\n+        Node process(ConditionalExpression node) {\n+          return newNode(Token.HOOK,\n+              transform(node.getTestExpression()),\n+              transform(node.getTrueExpression()),\n+              transform(node.getFalseExpression()));\n+        }\n+      };\n+\n+  public interface TypeSafeDispatcher {\n+    Node process(AstRoot node);\n+    Node process(InfixExpression node);\n+    Node process(VariableInitializer node);\n+    Node process(Name node);\n+    Node process(BooleanLiteral node);\n+    Node process(Parser.StatementWithScope node);\n+    Node process(ArrayLiteral node);\n+    Node process(FunctionCall node);\n+    Node process(ExpressionStatement node);\n+    Node process(FunctionNode node);\n+    Node process(ParenthesizedExpression node);\n+    Node process(NumberLiteral node);\n+    Node process(StringLiteral node);\n+    Node process(UnaryExpression node);\n+    Node process(ThrowStatement node);\n+    Node process(TryStatement node);\n+    Node process(WhileLoop node);\n+    Node process(ForLoop node);\n+    Node process(ForInLoop node);\n+    Node process(DoLoop node);\n+    Node process(IfStatement node);\n+    Node process(SwitchStatement node);\n+    Node process(BreakStatement node);\n+    Node process(ContinueStatement node);\n+    Node process(ReturnStatement node);\n+    Node process(ObjectLiteral node);\n+    Node process(RegExpLiteral node);\n+    Node process(XmlString node);\n+    Node process(XmlExpression node);\n+    Node process(TryCatchFinally node);\n+    Node process(DefaultXmlNamespace node);\n+    Node process(LabeledStatement node);\n+    Node process(ConditionalExpression node);\n+  }\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}