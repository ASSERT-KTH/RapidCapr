{
    "patch": "private void inferPropertiesFromGenericObject(ObjectType objectType, JSType genericObjType) {\n  ObjectType genericObjectType = ObjectType.cast(genericObjType.restrictByNotNullOrUndefined());\n  if (genericObjectType != null && !genericObjectType.isEmptyType()) {\n    ObjectType objType = objectType.getImplicitPrototype();\n    for (String prop : genericObjectType.getOwnPropertyNames()) {\n      JSType propType = genericObjectType.getPropertyType(prop);\n      if (!objType.isPropertyTypeDeclared(prop)) {\n        JSType existingType = objType.hasProperty(prop) ? objType.getPropertyType(prop) : null;\n\n        if (existingType == null || existingType.isBottom()) {\n          objType.defineInferredProperty(prop, propType, null);\n        } else {\n          JSType typeToInfer = computeGreatestSubtype(existingType, propType);\n          objType.defineInferredProperty(prop, typeToInfer, null);\n        }\n      }\n    }\n  }\n}\n\nprivate JSType computeGreatestSubtype(JSType existingType, JSType propType) {\n  // We add existingType into the set of subtypes so that we can make sure the\n  // resulting JSType is a subtype of existingType, if existingType is not\n  // bottom.\n  Set<JSType> subtypes = existingType.isBottom()\n      ? new LinkedHashSet<JSType>() : existingType.getSubtypesWithoutStructuralTyping();\n\n  if (propType.isUnionType()) {\n    propagateSubtypesOfUnionType(propType.toMaybeUnionType(), subtypes);\n  } else {\n    subtypes.add(propType);\n  }\n\n  if (existingType.isBottom()) {\n    return JSType.join(subtypes);\n  }\n\n  JSType resultType = existingType.getGreatestSubtypeFromUnion(subtypes);\n  if (resultType.isEquivalentTo(existingType)) {\n    return existingType;\n  }\n\n  // If all subtypes are functions and the existing type is a function,\n  // return the existing function type because we don't want\n  // to infer a function type from a record with function properties.\n  if (existingType.isFunctionType() && resultType.isSubtypeOf(\n      getNativeType(JSTypeNative.OBJECT_TYPE))) {\n    return existingType;\n  }\n\n  return resultType;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e10920..64a8c831 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1111,42 +1111,58 @@ class TypeInference\n    * then this code will type-check appropriately.\n    */\n   private void inferPropertyTypesToMatchConstraint(\n-      JSType type, JSType constraint) {\n-    if (type == null || constraint == null) {\n-      return;\n-    }\n-\n-    ObjectType constraintObj =\n-        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n+private void inferPropertiesFromGenericObject(ObjectType objectType, JSType genericObjType) {\n+  ObjectType genericObjectType = ObjectType.cast(genericObjType.restrictByNotNullOrUndefined());\n+  if (genericObjectType != null && !genericObjectType.isEmptyType()) {\n+    ObjectType objType = objectType.getImplicitPrototype();\n+    for (String prop : genericObjectType.getOwnPropertyNames()) {\n+      JSType propType = genericObjectType.getPropertyType(prop);\n+      if (!objType.isPropertyTypeDeclared(prop)) {\n+        JSType existingType = objType.hasProperty(prop) ? objType.getPropertyType(prop) : null;\n+\n+        if (existingType == null || existingType.isBottom()) {\n+          objType.defineInferredProperty(prop, propType, null);\n+        } else {\n+          JSType typeToInfer = computeGreatestSubtype(existingType, propType);\n+          objType.defineInferredProperty(prop, typeToInfer, null);\n         }\n       }\n     }\n   }\n+}\n \n-  /**\n-   * If we access a property of a symbol, then that symbol is not\n-   * null or undefined.\n-   */\n-  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n-    if (n.isQualifiedName()) {\n-      JSType type = getJSType(n);\n-      JSType narrowed = type.restrictByNotNullOrUndefined();\n-      if (type != narrowed) {\n-        scope = narrowScope(scope, n, narrowed);\n-      }\n+private JSType computeGreatestSubtype(JSType existingType, JSType propType) {\n+  // We add existingType into the set of subtypes so that we can make sure the\n+  // resulting JSType is a subtype of existingType, if existingType is not\n+  // bottom.\n+  Set<JSType> subtypes = existingType.isBottom()\n+      ? new LinkedHashSet<JSType>() : existingType.getSubtypesWithoutStructuralTyping();\n+\n+  if (propType.isUnionType()) {\n+    propagateSubtypesOfUnionType(propType.toMaybeUnionType(), subtypes);\n+  } else {\n+    subtypes.add(propType);\n+  }\n+\n+  if (existingType.isBottom()) {\n+    return JSType.join(subtypes);\n+  }\n+\n+  JSType resultType = existingType.getGreatestSubtypeFromUnion(subtypes);\n+  if (resultType.isEquivalentTo(existingType)) {\n+    return existingType;\n+  }\n+\n+  // If all subtypes are functions and the existing type is a function,\n+  // return the existing function type because we don't want\n+  // to infer a function type from a record with function properties.\n+  if (existingType.isFunctionType() && resultType.isSubtypeOf(\n+      getNativeType(JSTypeNative.OBJECT_TYPE))) {\n+    return existingType;\n+  }\n+\n+  return resultType;\n+}\n     }\n     return scope;\n   }",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}