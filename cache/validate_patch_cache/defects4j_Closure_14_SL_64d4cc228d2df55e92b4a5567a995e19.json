{
    "patch": "private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n        return null;\n    } \n\n    Node sibling = node.getNext();\n    while (sibling != null && sibling.isFunction()) {\n        sibling = sibling.getNext();\n    }\n\n    // If sibling exists, return the falling edge from current node to sibling. \n    if (sibling != null) {\n        return computeFallThrough(sibling);\n    }\n\n    switch (parent.getType()) {\n        // For try block, depends if there is a finally block or not.\n        case Token.TRY: {\n            Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n            if (finallyBlock != null && (node == parent.getFirstChild() || node == NodeUtil.getCatchBlock(parent))) {\n                return computeFollowNode(fromNode, finallyBlock, cfa);\n            }\n            return computeFollowNode(fromNode, parent, cfa);\n        }\n        // For while/do loops, return the first child.\n        case Token.WHILE:\n        case Token.DO: \n            return parent;\n        // For branch conditions, return the next token.\n        case Token.CONDITIONAL:\n        case Token.IF:\n        case Token.AND:\n        case Token.OR:\n            return node.getNext();\n        // For case within switch statements, follow the next case or return falling edge of the switch.\n        case Token.CASE: {\n            Node nextCase = parent.getNext();\n            while (nextCase != null && nextCase.getType() == Token.CASE) {\n                nextCase = nextCase.getNext();\n            }\n            if (nextCase != null) {\n                return computeFallThrough(nextCase);\n            }\n            return computeFollowNode(fromNode, parent.getParent(), cfa);\n        }\n        // For default case within switch statements, follow the first child after default case or return falling edge of the switch.\n        case Token.DEFAULT_CASE: { \n            Node defaultNext = parent.getDefaultCase();\n            while (defaultNext != null && !defaultNext.isBlock()) {\n                defaultNext = defaultNext.getNext();\n            }\n            if (defaultNext != null) {\n                return computeFallThrough(defaultNext.getFirstChild());\n            }\n            return computeFollowNode(fromNode, parent.getParent(), cfa);\n        }\n        // For for/in loops, return the first child.\n        case Token.FOR: \n            if (NodeUtil.isForIn(parent)) {\n                return parent;\n            }\n            return parent.getFirstChild().getNext().getNext();\n        // For switch statements and other control structures, follow edge of control flow.\n        case Token.SWITCH:\n            return computeFallThrough(parent);\n        case Token.TRY_FINALLY:\n        case Token.SCRIPT:\n        case Token.BLOCK:\n            return computeFollowNode(fromNode, parent, cfa);\n        default:\n            Preconditions.checkState(false, \"Not reachable\");\n    }\n    return null;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..c2644d85 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,81 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+private static Node computeFollowNode(Node fromNode, Node node, ControlFlowAnalysis cfa) {\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || (cfa != null && node == cfa.root)) {\n+        return null;\n+    } \n+\n+    Node sibling = node.getNext();\n+    while (sibling != null && sibling.isFunction()) {\n+        sibling = sibling.getNext();\n+    }\n+\n+    // If sibling exists, return the falling edge from current node to sibling. \n+    if (sibling != null) {\n+        return computeFallThrough(sibling);\n+    }\n+\n+    switch (parent.getType()) {\n+        // For try block, depends if there is a finally block or not.\n+        case Token.TRY: {\n+            Node finallyBlock = NodeUtil.getFinallyBlock(parent);\n+            if (finallyBlock != null && (node == parent.getFirstChild() || node == NodeUtil.getCatchBlock(parent))) {\n+                return computeFollowNode(fromNode, finallyBlock, cfa);\n+            }\n+            return computeFollowNode(fromNode, parent, cfa);\n+        }\n+        // For while/do loops, return the first child.\n+        case Token.WHILE:\n+        case Token.DO: \n+            return parent;\n+        // For branch conditions, return the next token.\n+        case Token.CONDITIONAL:\n+        case Token.IF:\n+        case Token.AND:\n+        case Token.OR:\n+            return node.getNext();\n+        // For case within switch statements, follow the next case or return falling edge of the switch.\n+        case Token.CASE: {\n+            Node nextCase = parent.getNext();\n+            while (nextCase != null && nextCase.getType() == Token.CASE) {\n+                nextCase = nextCase.getNext();\n+            }\n+            if (nextCase != null) {\n+                return computeFallThrough(nextCase);\n+            }\n+            return computeFollowNode(fromNode, parent.getParent(), cfa);\n+        }\n+        // For default case within switch statements, follow the first child after default case or return falling edge of the switch.\n+        case Token.DEFAULT_CASE: { \n+            Node defaultNext = parent.getDefaultCase();\n+            while (defaultNext != null && !defaultNext.isBlock()) {\n+                defaultNext = defaultNext.getNext();\n+            }\n+            if (defaultNext != null) {\n+                return computeFallThrough(defaultNext.getFirstChild());\n+            }\n+            return computeFollowNode(fromNode, parent.getParent(), cfa);\n+        }\n+        // For for/in loops, return the first child.\n+        case Token.FOR: \n+            if (NodeUtil.isForIn(parent)) {\n+                return parent;\n+            }\n+            return parent.getFirstChild().getNext().getNext();\n+        // For switch statements and other control structures, follow edge of control flow.\n+        case Token.SWITCH:\n+            return computeFallThrough(parent);\n+        case Token.TRY_FINALLY:\n+        case Token.SCRIPT:\n+        case Token.BLOCK:\n+            return computeFollowNode(fromNode, parent, cfa);\n+        default:\n+            Preconditions.checkState(false, \"Not reachable\");\n+    }\n+    return null;\n+}\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}