{
    "patch": "Name functionName = functionNode.getFunctionName();\nboolean isUnnamedFunc = false;\nif (functionName == null) {\n    // If the function has no name, create an empty name node.\n    functionName = new Name();\n    functionName.setIdentifier(\"\");\n    isUnnamedFunc = true;\n}\nNode node = newNode(Token.FUNCTION);\nNode newName = transform(functionName);\nif (isUnnamedFunc) {\n    newName.setLineno(functionNode.getLineno());\n    int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n    newName.setCharno(position2charno(lpColumn));\n}\n\nnode.addChildToBack(newName);\nNode lp = newNode(Token.LP);\nName fnName = functionNode.getFunctionName();\nif (fnName != null) {\n    lp.setLineno(fnName.getLineno());\n} else {\n    lp.setLineno(functionNode.getLineno());\n}\nint lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n\nlp.setCharno(position2charno(lparenCharno));\nfor (AstNode param : functionNode.getParams()) {\n    lp.addChildToBack(transform(param));\n}\nnode.addChildToBack(lp);\n\nNode bodyNode = transform(functionNode.getBody());\nparseDirectives(bodyNode);\n\nif (NodeUtil.isBlockScopedFunctionDeclaration(functionNode)) {\n    node.setLineno(bodyNode.getLineno());\n    node.setCharno(bodyNode.getCharno());\n} else {\n    node.setLineno(position2lineno(lparenCharno));\n    node.setCharno(position2charno(lparenCharno));\n}\nnode.addChildToBack(bodyNode);\nreturn node;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..a4966459 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,6 +514,50 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+Name functionName = functionNode.getFunctionName();\n+boolean isUnnamedFunc = false;\n+if (functionName == null) {\n+    // If the function has no name, create an empty name node.\n+    functionName = new Name();\n+    functionName.setIdentifier(\"\");\n+    isUnnamedFunc = true;\n+}\n+Node node = newNode(Token.FUNCTION);\n+Node newName = transform(functionName);\n+if (isUnnamedFunc) {\n+    newName.setLineno(functionNode.getLineno());\n+    int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n+    newName.setCharno(position2charno(lpColumn));\n+}\n+\n+node.addChildToBack(newName);\n+Node lp = newNode(Token.LP);\n+Name fnName = functionNode.getFunctionName();\n+if (fnName != null) {\n+    lp.setLineno(fnName.getLineno());\n+} else {\n+    lp.setLineno(functionNode.getLineno());\n+}\n+int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+\n+lp.setCharno(position2charno(lparenCharno));\n+for (AstNode param : functionNode.getParams()) {\n+    lp.addChildToBack(transform(param));\n+}\n+node.addChildToBack(lp);\n+\n+Node bodyNode = transform(functionNode.getBody());\n+parseDirectives(bodyNode);\n+\n+if (NodeUtil.isBlockScopedFunctionDeclaration(functionNode)) {\n+    node.setLineno(bodyNode.getLineno());\n+    node.setCharno(bodyNode.getCharno());\n+} else {\n+    node.setLineno(position2lineno(lparenCharno));\n+    node.setCharno(position2charno(lparenCharno));\n+}\n+node.addChildToBack(bodyNode);\n+return node;\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}