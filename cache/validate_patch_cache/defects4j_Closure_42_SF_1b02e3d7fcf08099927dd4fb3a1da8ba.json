{
    "patch": "class TransformDispatcher implements TypeSafeDispatcher {\n    private final String sourceName;\n    private final ErrorReporter errorReporter;\n    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n        ImmutableSet.of(\"use strict\");\n\n    TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n        this.sourceName = sourceName;\n        this.errorReporter = errorReporter;\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) return false;\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n                n.getFirstChild().isString() &&\n                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    @Override\n    public Node processBlock(Block blockNode) {\n        return processGeneric(blockNode);\n    }\n\n    @Override\n    public Node processBreakStatement(BreakStatement statementNode) {\n        Node node = new Node(Token.BREAK);\n        if (statementNode.getBreakLabel() != null) {\n            Node labelName = transform(statementNode.getBreakLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    public Node processCatchClause(CatchClause clauseNode) {\n        AstNode catchVar = clauseNode.getVarName();\n        Node node = newNode(Token.CATCH, transform(catchVar));\n        if (clauseNode.getCatchCondition() != null) {\n            errorReporter.error(\n                    \"Catch clauses are not supported\",\n                    sourceName,\n                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n        }\n        node.addChildToBack(transformBlock(clauseNode.getBody()));\n        return node;\n    }\n\n    @Override\n    public Node processConditionalExpression(ConditionalExpression exprNode) {\n        return new Node(\n                Token.HOOK,\n                transform(exprNode.getTestExpression()),\n                transform(exprNode.getTrueExpression()),\n                transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    public Node processContinueStatement(ContinueStatement statementNode) {\n        Node node = new Node(Token.CONTINUE);\n        if (statementNode.getLabel() != null) {\n            Node labelName = transform(statementNode.getLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    public Node processDoLoop(DoLoop loopNode) {\n        return new Node(\n                Token.DO,\n                transformBlock(loopNode.getBody()),\n                transform(loopNode.getCondition()));\n    }\n\n    @Override\n    public Node processElementGet(ElementGet getNode) {\n        return new Node(\n                Token.GETELEM,\n                transform(getNode.getTarget()),\n                transform(getNode.getElement()));\n    }\n\n    @Override\n    public Node processEmptyExpression(EmptyExpression exprNode) {\n        return new Node(Token.EMPTY);\n    }\n\n    @Override\n    public Node processExpressionStatement(ExpressionStatement statementNode) {\n        Node node = new Node(transformTokenType(statementNode.getType()));\n        node.addChildToBack(transform(statementNode.getExpression()));\n        return node;\n    }\n\n    @Override\n    public Node processForInLoop(ForInLoop loopNode) {\n        AstNode iterator = loopNode.getIterator();\n        Node iteratedObject = transform(loopNode.getIteratedObject());\n        Node body = transformBlock(loopNode.getBody());\n        Node newNode;\n        if (iterator instanceof Name || iterator instanceof KeywordLiteral) {\n            newNode = new Node(Token.FOR);\n            newNode.addChildToBack(transform(iterator));\n            newNode.addChildToBack(iteratedObject);\n            newNode.addChildToBack(body);\n        } else {\n            // Error: Invalid left-hand side in for-in loop\n            errorReporter.error(\n                    \"Invalid left-hand side in for-in loop\",\n                    sourceName,\n                    iterator.getLineno(), \"\", 0);\n            newNode = new Node(Token.EMPTY);\n        }\n        return newNode;\n    }\n\n    @Override\n    public Node processForLoop(ForLoop loopNode) {\n        return new Node(\n                Token.FOR,\n                transform(loopNode.getInitializer()),\n                transform(loopNode.getCondition()),\n                transform(loopNode.getIncrement()),\n                transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    public Node processFunctionCall(FunctionCall callNode) {\n        return new Node(\n                Token.CALL,\n                transform(callNode.getTarget()),\n                transformExprList(callNode.getArguments()));\n    }\n\n    @Override\n    public Node processFunctionNode(FunctionNode functionNode) {\n        Node function = new Node(Token.FUNCTION);\n        Name functionName = functionNode.getFunctionName();\n        if (functionName != null) {\n            function.addChildToBack(transform(functionName));\n        }\n        function.addChildToBack(transform(functionNode.getParams()));\n        function.addChildToBack(transformBlock(functionNode.getBody()));\n        return function;\n    }\n\n    @Override\n    public Node processIfStatement(IfStatement ifNode) {\n        Node ifBlock = new Node(Token.IF);\n\n        Node condition = transform(ifNode.getCondition());\n\n        Node thenPart = transform(ifNode.getThenPart());\n\n        Node elsePart = null;\n        if (ifNode.getElsePart() != null) {\n            elsePart = transform(ifNode.getElsePart());\n        }\n\n        ifBlock.addChildToBack(condition);\n        ifBlock.addChildToBack(thenPart);\n        if (elsePart != null) {\n            ifBlock.addChildToBack(elsePart);\n        }\n\n        return ifBlock;\n    }\n\n    @Override\n    public Node processLabeledStatement(LabeledStatement labeledStatement) {\n        Node labeled = new Node(Token.LABEL);\n        labeled.addChildToBack(transform(labeledStatement.getLabel()));\n        labeled.addChildToBack(transform(labeledStatement.getStatement()));\n        return labeled;\n    }\n\n    @Override\n    public Node processName(Name name) {\n        return new Node(Token.NAME, name.getIdentifier());\n    }\n\n    @Override\n    public Node processNewExpression(NewExpression newExprNode) {\n        Node newNode = new Node(Token.NEW);\n        newNode.addChildToBack(transform(newExprNode.getTarget()));\n        newNode.addChildrenToFront(transformExprList(newExprNode.getArguments()));\n        return newNode;\n    }\n\n    @Override\n    public Node processNumber(NumberLiteral literalNode) {\n        return new Node(Token.NUMBER, literalNode.getValue());\n    }\n\n    @Override\n    public Node processObjectLiteral(ObjectLiteral node) {\n        Node obj = new Node(Token.OBJECTLIT);\n        for (ObjectProperty prop : node.getElements()) {\n            Node key;\n            if (prop.getLeft() instanceof StringLiteral) {\n                String name = ((StringLiteral) prop.getLeft()).getValue();\n                key = Node.newString(name);\n            } else {\n                key = transform((AstNode) prop.getLeft());\n            }\n            Node value = transform((AstNode) prop.getRight());\n            Node pair = new Node(Token.STRING_KEY, key, value);\n            obj.addChildToBack(pair);\n        }\n        return obj;\n    }\n\n    @Override\n    public Node processRegExpLiteral(RegExpLiteral literalNode) {\n        return new Node(Token.REGEXP, literalNode.getValue(),\n                literalNode.getFlags());\n    }\n\n    @Override\n    public Node processReturnStatement(ReturnStatement returnNode) {\n        Node newNode = new Node(Token.RETURN);\n        if (returnNode.getReturnValue() != null) {\n            newNode.addChildToBack(transform(returnNode.getReturnValue()));\n        }\n        return newNode;\n    }\n\n    @Override\n    public Node processScript(Script scriptNode) {\n        Node script = new Node(Token.SCRIPT);\n        script.addChildrenToFront(transformList(scriptNode.getDirectives()));\n        script.addChildrenToFront(transformList(scriptNode.getStatements()));\n        return script;\n    }\n\n    @Override\n    public Node processString(StringLiteral stringNode) {\n        return newNode(Token.STRING, stringNode.getValue());\n    }\n\n    @Override\n    public Node processSwitchCase(SwitchCase switchCase) {\n        if (switchCase.isDefault()) {\n            return transform(switchCase.getStatements());\n        } else {\n            Node newNode = new Node(Token.CASE);\n            newNode.addChildToBack(transform(switchCase.getExpression()));\n            newNode.addChildrenToFront(transform(switchCase.getStatements()));\n            return newNode;\n        }\n    }\n\n    @Override\n    public Node processSwitchStatement(SwitchStatement switchNode) {\n        Node newNode = new Node(Token.SWITCH);\n        newNode.addChildToBack(transform(switchNode.getExpression()));\n        newNode.addChildrenToFront(transformList(switchNode.getCases()));\n        return newNode;\n    }\n\n    @Override\n    public Node processThrowStatement(ThrowStatement statementNode) {\n        Node newNode = new Node(Token.THROW);\n        newNode.addChildToBack(transform(statementNode.getExpression()));\n        return newNode;\n    }\n\n    @Override\n    public Node processTryStatement(TryStatement tryNode) {\n        Node tryBlock = new Node(Token.TRY);\n        tryBlock.addChildToBack(transformBlock(tryNode.getTryBlock()));\n\n        if (tryNode.getCatchClauses() != null) {\n            for (CatchClause catchBlock : tryNode.getCatchClauses()) {\n                Node catchNode = new Node(Token.CATCH);\n                AstNode catchVar = catchBlock.getVarName();\n                if (catchVar != null) {\n                    catchNode.addChildToBack(transform(catchVar));\n                }\n                if (catchBlock.getCatchCondition() != null) {\n                    errorReporter.error(\n                            \"Catch clauses are not supported\",\n                            sourceName,\n                            catchBlock.getCatchCondition().getLineno(), \"\", 0);\n                }\n                catchNode.addChildToBack(transformBlock(catchBlock.getBody()));\n                tryBlock.addChildToBack(catchNode);\n            }\n        }\n\n        if (tryNode.getFinallyBlock() != null) {\n            Node finallyBlock = new Node(Token.FINALLY);\n            finallyBlock.addChildToBack(transformBlock(tryNode.getFinallyBlock()));\n            tryBlock.addChildToBack(finallyBlock);\n        }\n\n        return tryBlock;\n    }\n\n    @Override\n    public Node processUnaryExpression(UnaryExpression unaryNode) {\n        return new Node(\n                Token.valueOf(unaryNode.getTokenType().toString()),\n                transform(unaryNode.getOperand()));\n    }\n\n    @Override\n    public Node processVariableDeclaration(VariableDeclaration varNode) {\n        Node var = new Node(Token.VAR);\n        for (VariableInitializer initializer : varNode.getVariables()) {\n            Node oneVar = new Node(Token.NAME, initializer.getTarget().getIdentifier());\n            if (initializer.getInitializer() != null) {\n                oneVar.addChildToBack(transform(initializer.getInitializer()));\n            }\n            var.addChildToBack(oneVar);\n        }\n        return var;\n    }\n\n    @Override\n    public Node processWhileLoop(WhileLoop loopNode) {\n        return new Node(\n                Token.WHILE,\n                transform(loopNode.getCondition()),\n                transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    public Node processWithStatement(WithStatement withNode) {\n        Node with = new Node(Token.WITH);\n        with.addChildToBack(transform(withNode.getExpression()));\n        with.addChildToBack(transformBlock(withNode.getStatement()));\n        return with;\n    }\n\n    private Node transformList(List<? extends AstNode> nodeList) {\n        Node head = new Node(Token.BLOCK);\n        for (AstNode n : nodeList) {\n            Node current = transform(n);\n            if (current != null) {\n                head.addChildToBack(current);\n            }\n        }\n        return head;\n    }\n\n    private Node transformExprList(List<? extends AstNode> nodeList) {\n        Node head = new Node(Token.EXPR_VOID);\n        for (AstNode n : nodeList) {\n            Node current = transform(n);\n            if (current != null) {\n                head.addChildToBack(current);\n            }\n        }\n        return head.getFirstChild();\n    }\n\n    private Node transform(TokenType type) {\n        Token t = transformTokenType(type);\n        if (t != null) {\n            return new Node(t);\n        } else {\n            return null;\n        }\n    }\n\n    private Token transformTokenType(TokenType type) {\n        switch (type) {\n            case AND:\n                return Token.AND;\n            case ASSIGN:\n                return Token.ASSIGN;\n            case BITAND:\n                return Token.BITAND;\n            case BITNOT:\n                return Token.BITNOT;\n            case BITOR:\n                return Token.BITOR;\n            case BITXOR:\n                return Token.BITXOR;\n            case BREAK:\n                return Token.BREAK;\n            case CASE:\n                return Token.CASE;\n            case CATCH:\n                return Token.CATCH;\n            case COLON:\n                return Token.COLON;\n            case COMMA:\n                return Token.COMMA;\n            case CONDITIONAL:\n                return Token.HOOK;\n            case CONTINUE:\n                return Token.CONTINUE;\n            case DEC:\n                return Token.DEC;\n            case DEFAULT:\n                return Token.DEFAULT;\n            case DELETE:\n                return Token.DELETE;\n            case DO:\n                return Token.DO;\n            case DOT:\n                return Token.DOT;\n            case ELSE:\n                return Token.ELSE;\n            case EMPTY:\n                return Token.EMPTY;\n            case EQ:\n                return Token.EQ;\n            case EXPONENT:\n                return Token.EXPONENT;\n            case FINALLY:\n                return Token.FINALLY;\n            case FOR:\n                return Token.FOR;\n            case FUNCTION:\n                return Token.FUNCTION;\n            case GE:\n                return Token.GE;\n            case GET:\n                return Token.GET;\n            case GT:\n                return Token.GT;\n            case HOOK:\n                return Token.HOOK;\n            case IF:\n                return Token.IF;\n            case IN:\n                return Token.IN;\n            case INC:\n                return Token.INC;\n            case INSTANCEOF:\n                return Token.INSTANCEOF;\n            case LABEL:\n                return Token.LABEL;\n            case LE:\n                return Token.LE;\n            case LET:\n                return Token.LET;\n            case LSH:\n                return Token.LSH;\n            case LT:\n                return Token.LT;\n            case MOD:\n                return Token.MOD;\n            case NAME:\n                return Token.NAME;\n            case NE:\n                return Token.NE;\n            case NEW:\n                return Token.NEW;\n            case NOT:\n                return Token.NOT;\n            case NULL:\n                return Token.NULL;\n            case NUMBER:\n                return Token.NUMBER;\n            case OR:\n                return Token.OR;\n            case POS:\n                return Token.POS;\n            case RBRACKET:\n                return Token.RBRACKET;\n            case RETURN:\n                return Token.RETURN;\n            case RSH:\n                return Token.RSH;\n            case SEMI:\n                return Token.SEMI;\n            case SET:\n                return Token.SET;\n            case SHEQ:\n                return Token.SHEQ;\n            case SHNE:\n                return Token.SHNE;\n            case STRICT_EQ:\n                return Token.STRICT_EQ;\n            case STRICT_NE:\n                return Token.STRICT_NE;\n            case STRING:",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..6b430920 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,494 @@ class IRFactory {\n       }\n     }\n \n+class TransformDispatcher implements TypeSafeDispatcher {\n+    private final String sourceName;\n+    private final ErrorReporter errorReporter;\n+    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+        ImmutableSet.of(\"use strict\");\n+\n+    TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n+        this.sourceName = sourceName;\n+        this.errorReporter = errorReporter;\n+    }\n+\n     private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+        if (n == null) return false;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+                n.getFirstChild().isString() &&\n+                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node processBlock(Block blockNode) {\n+        return processGeneric(blockNode);\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node processBreakStatement(BreakStatement statementNode) {\n+        Node node = new Node(Token.BREAK);\n+        if (statementNode.getBreakLabel() != null) {\n+            Node labelName = transform(statementNode.getBreakLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    public Node processCatchClause(CatchClause clauseNode) {\n+        AstNode catchVar = clauseNode.getVarName();\n+        Node node = newNode(Token.CATCH, transform(catchVar));\n+        if (clauseNode.getCatchCondition() != null) {\n+            errorReporter.error(\n+                    \"Catch clauses are not supported\",\n+                    sourceName,\n+                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+        }\n+        node.addChildToBack(transformBlock(clauseNode.getBody()));\n+        return node;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public Node processConditionalExpression(ConditionalExpression exprNode) {\n+        return new Node(\n+                Token.HOOK,\n+                transform(exprNode.getTestExpression()),\n+                transform(exprNode.getTrueExpression()),\n+                transform(exprNode.getFalseExpression()));\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node processContinueStatement(ContinueStatement statementNode) {\n+        Node node = new Node(Token.CONTINUE);\n+        if (statementNode.getLabel() != null) {\n+            Node labelName = transform(statementNode.getLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node processDoLoop(DoLoop loopNode) {\n+        return new Node(\n+                Token.DO,\n+                transformBlock(loopNode.getBody()),\n+                transform(loopNode.getCondition()));\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node processElementGet(ElementGet getNode) {\n+        return new Node(\n+                Token.GETELEM,\n+                transform(getNode.getTarget()),\n+                transform(getNode.getElement()));\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node processEmptyExpression(EmptyExpression exprNode) {\n+        return new Node(Token.EMPTY);\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node processExpressionStatement(ExpressionStatement statementNode) {\n+        Node node = new Node(transformTokenType(statementNode.getType()));\n+        node.addChildToBack(transform(statementNode.getExpression()));\n+        return node;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node processForInLoop(ForInLoop loopNode) {\n+        AstNode iterator = loopNode.getIterator();\n+        Node iteratedObject = transform(loopNode.getIteratedObject());\n+        Node body = transformBlock(loopNode.getBody());\n+        Node newNode;\n+        if (iterator instanceof Name || iterator instanceof KeywordLiteral) {\n+            newNode = new Node(Token.FOR);\n+            newNode.addChildToBack(transform(iterator));\n+            newNode.addChildToBack(iteratedObject);\n+            newNode.addChildToBack(body);\n+        } else {\n+            // Error: Invalid left-hand side in for-in loop\n+            errorReporter.error(\n+                    \"Invalid left-hand side in for-in loop\",\n+                    sourceName,\n+                    iterator.getLineno(), \"\", 0);\n+            newNode = new Node(Token.EMPTY);\n+        }\n+        return newNode;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    @Override\n+    public Node processForLoop(ForLoop loopNode) {\n+        return new Node(\n+                Token.FOR,\n+                transform(loopNode.getInitializer()),\n+                transform(loopNode.getCondition()),\n+                transform(loopNode.getIncrement()),\n+                transformBlock(loopNode.getBody()));\n+    }\n+\n+    @Override\n+    public Node processFunctionCall(FunctionCall callNode) {\n+        return new Node(\n+                Token.CALL,\n+                transform(callNode.getTarget()),\n+                transformExprList(callNode.getArguments()));\n+    }\n+\n+    @Override\n+    public Node processFunctionNode(FunctionNode functionNode) {\n+        Node function = new Node(Token.FUNCTION);\n+        Name functionName = functionNode.getFunctionName();\n+        if (functionName != null) {\n+            function.addChildToBack(transform(functionName));\n+        }\n+        function.addChildToBack(transform(functionNode.getParams()));\n+        function.addChildToBack(transformBlock(functionNode.getBody()));\n+        return function;\n+    }\n+\n+    @Override\n+    public Node processIfStatement(IfStatement ifNode) {\n+        Node ifBlock = new Node(Token.IF);\n+\n+        Node condition = transform(ifNode.getCondition());\n+\n+        Node thenPart = transform(ifNode.getThenPart());\n+\n+        Node elsePart = null;\n+        if (ifNode.getElsePart() != null) {\n+            elsePart = transform(ifNode.getElsePart());\n+        }\n+\n+        ifBlock.addChildToBack(condition);\n+        ifBlock.addChildToBack(thenPart);\n+        if (elsePart != null) {\n+            ifBlock.addChildToBack(elsePart);\n+        }\n+\n+        return ifBlock;\n+    }\n+\n+    @Override\n+    public Node processLabeledStatement(LabeledStatement labeledStatement) {\n+        Node labeled = new Node(Token.LABEL);\n+        labeled.addChildToBack(transform(labeledStatement.getLabel()));\n+        labeled.addChildToBack(transform(labeledStatement.getStatement()));\n+        return labeled;\n+    }\n+\n+    @Override\n+    public Node processName(Name name) {\n+        return new Node(Token.NAME, name.getIdentifier());\n+    }\n+\n+    @Override\n+    public Node processNewExpression(NewExpression newExprNode) {\n+        Node newNode = new Node(Token.NEW);\n+        newNode.addChildToBack(transform(newExprNode.getTarget()));\n+        newNode.addChildrenToFront(transformExprList(newExprNode.getArguments()));\n+        return newNode;\n+    }\n+\n+    @Override\n+    public Node processNumber(NumberLiteral literalNode) {\n+        return new Node(Token.NUMBER, literalNode.getValue());\n+    }\n+\n+    @Override\n+    public Node processObjectLiteral(ObjectLiteral node) {\n+        Node obj = new Node(Token.OBJECTLIT);\n+        for (ObjectProperty prop : node.getElements()) {\n+            Node key;\n+            if (prop.getLeft() instanceof StringLiteral) {\n+                String name = ((StringLiteral) prop.getLeft()).getValue();\n+                key = Node.newString(name);\n+            } else {\n+                key = transform((AstNode) prop.getLeft());\n+            }\n+            Node value = transform((AstNode) prop.getRight());\n+            Node pair = new Node(Token.STRING_KEY, key, value);\n+            obj.addChildToBack(pair);\n+        }\n+        return obj;\n+    }\n+\n+    @Override\n+    public Node processRegExpLiteral(RegExpLiteral literalNode) {\n+        return new Node(Token.REGEXP, literalNode.getValue(),\n+                literalNode.getFlags());\n+    }\n+\n+    @Override\n+    public Node processReturnStatement(ReturnStatement returnNode) {\n+        Node newNode = new Node(Token.RETURN);\n+        if (returnNode.getReturnValue() != null) {\n+            newNode.addChildToBack(transform(returnNode.getReturnValue()));\n+        }\n+        return newNode;\n+    }\n+\n+    @Override\n+    public Node processScript(Script scriptNode) {\n+        Node script = new Node(Token.SCRIPT);\n+        script.addChildrenToFront(transformList(scriptNode.getDirectives()));\n+        script.addChildrenToFront(transformList(scriptNode.getStatements()));\n+        return script;\n+    }\n+\n+    @Override\n+    public Node processString(StringLiteral stringNode) {\n+        return newNode(Token.STRING, stringNode.getValue());\n+    }\n+\n+    @Override\n+    public Node processSwitchCase(SwitchCase switchCase) {\n+        if (switchCase.isDefault()) {\n+            return transform(switchCase.getStatements());\n+        } else {\n+            Node newNode = new Node(Token.CASE);\n+            newNode.addChildToBack(transform(switchCase.getExpression()));\n+            newNode.addChildrenToFront(transform(switchCase.getStatements()));\n+            return newNode;\n+        }\n+    }\n+\n+    @Override\n+    public Node processSwitchStatement(SwitchStatement switchNode) {\n+        Node newNode = new Node(Token.SWITCH);\n+        newNode.addChildToBack(transform(switchNode.getExpression()));\n+        newNode.addChildrenToFront(transformList(switchNode.getCases()));\n+        return newNode;\n+    }\n+\n+    @Override\n+    public Node processThrowStatement(ThrowStatement statementNode) {\n+        Node newNode = new Node(Token.THROW);\n+        newNode.addChildToBack(transform(statementNode.getExpression()));\n+        return newNode;\n     }\n \n+    @Override\n+    public Node processTryStatement(TryStatement tryNode) {\n+        Node tryBlock = new Node(Token.TRY);\n+        tryBlock.addChildToBack(transformBlock(tryNode.getTryBlock()));\n+\n+        if (tryNode.getCatchClauses() != null) {\n+            for (CatchClause catchBlock : tryNode.getCatchClauses()) {\n+                Node catchNode = new Node(Token.CATCH);\n+                AstNode catchVar = catchBlock.getVarName();\n+                if (catchVar != null) {\n+                    catchNode.addChildToBack(transform(catchVar));\n+                }\n+                if (catchBlock.getCatchCondition() != null) {\n+                    errorReporter.error(\n+                            \"Catch clauses are not supported\",\n+                            sourceName,\n+                            catchBlock.getCatchCondition().getLineno(), \"\", 0);\n+                }\n+                catchNode.addChildToBack(transformBlock(catchBlock.getBody()));\n+                tryBlock.addChildToBack(catchNode);\n+            }\n+        }\n+\n+        if (tryNode.getFinallyBlock() != null) {\n+            Node finallyBlock = new Node(Token.FINALLY);\n+            finallyBlock.addChildToBack(transformBlock(tryNode.getFinallyBlock()));\n+            tryBlock.addChildToBack(finallyBlock);\n+        }\n+\n+        return tryBlock;\n+    }\n+\n+    @Override\n+    public Node processUnaryExpression(UnaryExpression unaryNode) {\n+        return new Node(\n+                Token.valueOf(unaryNode.getTokenType().toString()),\n+                transform(unaryNode.getOperand()));\n+    }\n+\n+    @Override\n+    public Node processVariableDeclaration(VariableDeclaration varNode) {\n+        Node var = new Node(Token.VAR);\n+        for (VariableInitializer initializer : varNode.getVariables()) {\n+            Node oneVar = new Node(Token.NAME, initializer.getTarget().getIdentifier());\n+            if (initializer.getInitializer() != null) {\n+                oneVar.addChildToBack(transform(initializer.getInitializer()));\n+            }\n+            var.addChildToBack(oneVar);\n+        }\n+        return var;\n+    }\n+\n+    @Override\n+    public Node processWhileLoop(WhileLoop loopNode) {\n+        return new Node(\n+                Token.WHILE,\n+                transform(loopNode.getCondition()),\n+                transformBlock(loopNode.getBody()));\n+    }\n+\n+    @Override\n+    public Node processWithStatement(WithStatement withNode) {\n+        Node with = new Node(Token.WITH);\n+        with.addChildToBack(transform(withNode.getExpression()));\n+        with.addChildToBack(transformBlock(withNode.getStatement()));\n+        return with;\n+    }\n+\n+    private Node transformList(List<? extends AstNode> nodeList) {\n+        Node head = new Node(Token.BLOCK);\n+        for (AstNode n : nodeList) {\n+            Node current = transform(n);\n+            if (current != null) {\n+                head.addChildToBack(current);\n+            }\n+        }\n+        return head;\n+    }\n+\n+    private Node transformExprList(List<? extends AstNode> nodeList) {\n+        Node head = new Node(Token.EXPR_VOID);\n+        for (AstNode n : nodeList) {\n+            Node current = transform(n);\n+            if (current != null) {\n+                head.addChildToBack(current);\n+            }\n+        }\n+        return head.getFirstChild();\n+    }\n+\n+    private Node transform(TokenType type) {\n+        Token t = transformTokenType(type);\n+        if (t != null) {\n+            return new Node(t);\n+        } else {\n+            return null;\n+        }\n+    }\n+\n+    private Token transformTokenType(TokenType type) {\n+        switch (type) {\n+            case AND:\n+                return Token.AND;\n+            case ASSIGN:\n+                return Token.ASSIGN;\n+            case BITAND:\n+                return Token.BITAND;\n+            case BITNOT:\n+                return Token.BITNOT;\n+            case BITOR:\n+                return Token.BITOR;\n+            case BITXOR:\n+                return Token.BITXOR;\n+            case BREAK:\n+                return Token.BREAK;\n+            case CASE:\n+                return Token.CASE;\n+            case CATCH:\n+                return Token.CATCH;\n+            case COLON:\n+                return Token.COLON;\n+            case COMMA:\n+                return Token.COMMA;\n+            case CONDITIONAL:\n+                return Token.HOOK;\n+            case CONTINUE:\n+                return Token.CONTINUE;\n+            case DEC:\n+                return Token.DEC;\n+            case DEFAULT:\n+                return Token.DEFAULT;\n+            case DELETE:\n+                return Token.DELETE;\n+            case DO:\n+                return Token.DO;\n+            case DOT:\n+                return Token.DOT;\n+            case ELSE:\n+                return Token.ELSE;\n+            case EMPTY:\n+                return Token.EMPTY;\n+            case EQ:\n+                return Token.EQ;\n+            case EXPONENT:\n+                return Token.EXPONENT;\n+            case FINALLY:\n+                return Token.FINALLY;\n+            case FOR:\n+                return Token.FOR;\n+            case FUNCTION:\n+                return Token.FUNCTION;\n+            case GE:\n+                return Token.GE;\n+            case GET:\n+                return Token.GET;\n+            case GT:\n+                return Token.GT;\n+            case HOOK:\n+                return Token.HOOK;\n+            case IF:\n+                return Token.IF;\n+            case IN:\n+                return Token.IN;\n+            case INC:\n+                return Token.INC;\n+            case INSTANCEOF:\n+                return Token.INSTANCEOF;\n+            case LABEL:\n+                return Token.LABEL;\n+            case LE:\n+                return Token.LE;\n+            case LET:\n+                return Token.LET;\n+            case LSH:\n+                return Token.LSH;\n+            case LT:\n+                return Token.LT;\n+            case MOD:\n+                return Token.MOD;\n+            case NAME:\n+                return Token.NAME;\n+            case NE:\n+                return Token.NE;\n+            case NEW:\n+                return Token.NEW;\n+            case NOT:\n+                return Token.NOT;\n+            case NULL:\n+                return Token.NULL;\n+            case NUMBER:\n+                return Token.NUMBER;\n+            case OR:\n+                return Token.OR;\n+            case POS:\n+                return Token.POS;\n+            case RBRACKET:\n+                return Token.RBRACKET;\n+            case RETURN:\n+                return Token.RETURN;\n+            case RSH:\n+                return Token.RSH;\n+            case SEMI:\n+                return Token.SEMI;\n+            case SET:\n+                return Token.SET;\n+            case SHEQ:\n+                return Token.SHEQ;\n+            case SHNE:\n+                return Token.SHNE;\n+            case STRICT_EQ:\n+                return Token.STRICT_EQ;\n+            case STRICT_NE:\n+                return Token.STRICT_NE;\n+            case STRING:\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}