{
    "patch": "        Optional<Expression> optionalScope = assignmentTarget.getScope();\n        String lhsName;\n        if (optionalScope.isPresent()) {\n            lhsName = optionalScope.get().toString() + \".\" + assignmentTarget.toString();\n        } else {\n            lhsName = assignmentTarget.toString();\n        }\n\n        boolean isArrayAccessExpr = assignmentTarget instanceof ArrayAccessExpr;\n        Object rhs = rhsNode instanceof ArrayAccessExpr ?\n                new Object() {\n                    int rhsArrayIndex;\n                    String name;\n                    {\n                        ArrayAccessExpr a = (ArrayAccessExpr) rhsNode;\n                        name = a.getName().toString();\n                        a.getIndex().accept(new ExploreIndex());\n                    }\n\n                    class ExploreIndex extends VoidVisitorAdapter<Void> {\n                        @Override\n                        public void visit(IntegerLiteralExpr n, Void arg) {\n                            super.visit(n, arg);\n                            rhsArrayIndex = n.asInt();\n                        }\n                    }\n\n                    @Override\n                    public String toString() {\n                        return name + \"[\" + rhsArrayIndex + \"]\";\n                    }\n                }: rhsNode.toString();\n\n        String infixExpr;\n        if (isArrayAccessExpr) {\n            infixExpr = String.format(\"%s %s %s[%d]\", ((String) rhs), operatorSymbol, lhsName, ((ArrayAccessExpr) assignmentTarget).getIndex());\n        } else {\n            infixExpr = String.format(\"%s %s %s\", ((String) rhs), operatorSymbol, lhsName);\n        }\n\n        AssignExpr.Operator operator;\n        switch (operatorSymbol) {\n            case \"+=\":\n                operator = AssignExpr.Operator.PLUS;\n                break;\n            case \"-=\":\n                operator = AssignExpr.Operator.MINUS;\n                break;\n            case \"*=\":\n                operator = AssignExpr.Operator.MULTIPLY;\n                break;\n            case \"/=\":\n                operator = AssignExpr.Operator.DIVIDE;\n                break;\n            case \"&=\":\n                operator = AssignExpr.Operator.BINARY_AND;\n                break;\n            case \"|=\":\n                operator = AssignExpr.Operator.BINARY_OR;\n                break;\n            case \"^=\":\n                operator = AssignExpr.Operator.XOR;\n                break;\n            default:\n                throw new IllegalArgumentException(\"Unsupported compound operator type: \" + operatorSymbol);\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 54eb5cf8..6267f6c9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -104,7 +104,7 @@ class CodeGenerator {\n     add(n, Context.OTHER);\n   }\n \n-  void add(Node n, Context context) {\n+\n     if (!cc.continueProcessing()) {\n       return;\n     }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}