{
    "patch": "public class IRFactory extends TransformTraversal {\n  // Other methods as before ...\n\n  @Override\n  Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  @Override\n  Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  @Override\n  Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  @Override\n  Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  Node processForInLoop(ForInLoop loopNode) {\n    Node left;\n    // If the left-hand side of the for..in is a destructuring pattern,\n    // declare a temporary variable as the loop variable and destructure\n    // the value each iteration.\n    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n      left = newNode(\n          Token.VAR,\n          createDestructuringLhs(\n              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n    } else {\n      left = transform(loopNode.getIterator());\n    }\n\n    return newNode(\n        Token.FOR,\n        newNode(Token.EMPTY),\n        newNode(Token.EMPTY),\n        newNode(\n            Token.BLOCK,\n            left,\n            newNode(\n                Token.FOR_IN,\n                transform(loopNode.getIteratedObject()),\n                newNode(Token.EMPTY),\n                transformBlock(loopNode.getBody()))));\n  }\n\n  @Override\n  Node processForLoop(ForLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getInitializer()),\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  Node processFunctionCall(FunctionCall callNode) {\n    Node callTarget = transform(callNode.getTarget());\n    Node callArgs = newNode(Token.EMPTY);\n    for (AstNode arg : callNode.getArguments()) {\n      callArgs.addChildToBack(transform(arg));\n    }\n    return newNode(Token.CALL, callTarget, callArgs);\n  }\n\n  @Override\n  Node processFunctionNode(FunctionNode functionNode) {\n    Node parametersNode = newNode(Token.PARAM_LIST);\n    for (int i = 0; i < functionNode.getParams().size(); i++) {\n      AstNode param = functionNode.getParams().get(i);\n      Node nameNode = newNode(Token.NAME, Node.newString(Token.NAME, param.toSource()));\n      parametersNode.addChildToBack(nameNode);\n    }\n    Node returnTypeNode = transform(functionNode.getReturnType());\n    if (returnTypeNode != null) {\n      returnTypeNode.setType(Token.RETURN_TYPE);\n    }\n\n    Node functionBodyNode = transform(functionNode.getBody());\n    Node functionNodeWithJsDoc = addJsDocToFunction(\n        newNode(Token.FUNCTION, Node.newString(Token.NAME, functionNode.getName())),\n        functionNode.getJsDoc(),\n        parametersNode,\n        returnTypeNode,\n        functionBodyNode);\n\n    // If this is a getter or setter method, attach the modifiers as JSDoc.\n    JSDocInfo methodModifiers = functionNode.getJsDoc().getInlineType().getJSDocInfo();\n    if (methodModifiers != null && (methodModifiers.isGetter() || methodModifiers.isSetter())) {\n      functionNodeWithJsDoc.setBooleanProp(Node.COMPUTED_PROP_GETTER, methodModifiers.isGetter());\n      functionNodeWithJsDoc.setBooleanProp(Node.COMPUTED_PROP_SETTER, methodModifiers.isSetter());\n      JsdocUtil.applyToBooleanPropertyName(functionNodeWithJsDoc.getSecondChild());\n    }\n\n    return functionNodeWithJsDoc;\n  }\n\n  @Override\n  Node processIfStatement(IfStatement statementNode) {\n    return newNode(\n        Token.IF,\n        transform(statementNode.getCondition()),\n        transformBlock(statementNode.getThenPart()),\n        statementNode.getElsePart() == null\n            ? null\n            : transformBlock(statementNode.getElsePart()));\n  }\n\n  @Override\n  Node processInfixExpression(InfixExpression exprNode) {\n    return newNode(\n        transformTokenType(exprNode.getType()),\n        transform(exprNode.getLeft()),\n        transform(exprNode.getRight()));\n  }\n\n  @Override\n  Node processLabeledStatement(LabeledStatement statementNode) {\n    Node node = newNode(Token.LABEL, Node.newString(Token.NAME, statementNode.getLabelName()));\n    node.addChildToBack(transform(statementNode.getStatement()));\n    return node;\n  }\n\n  @Override\n  Node processName(Name nameNode) {\n    return Node.newString(Token.NAME, nameNode.getIdentifier());\n  }\n\n  @Override\n  Node processNewExpression(NewExpression exprNode) {\n    Node target = transform(exprNode.getTarget());\n    Node arguments = newNode(Token.EMPTY);\n    for (AstNode arg : exprNode.getArguments()) {\n      arguments.addChildToBack(transform(arg));\n    }\n    return newNode(Token.NEW, target, arguments);\n  }\n\n  @Override\n  Node processNumber(NumberLiteral numberNode) {\n    return Node.newNumber(numberNode.getNumber());\n  }\n\n  @Override\n  Node processObjectLiteral(ObjectLiteral objNode) {\n    Node n = newNode(Token.OBJECTLIT);\n    for (ObjectProperty property : objNode.getElements()) {\n      Node propNode = transform(property);\n      n.addChildToBack(propNode);\n    }\n    return n;\n  }\n\n  Node processObjectProperty(ObjectProperty propNode) {\n    if (propNode.isGetter()) {\n      return newNode(\n          Token.GETTER_DEF,\n          Node.newString(Token.NAME, propNode.getLeft().toSource()),\n          transformFunctionBody(propNode.getRight().getBody()));\n    } else if (propNode.isSetter()) {\n      return newNode(\n          Token.SETTER_DEF,\n          Node.newString(Token.NAME, propNode.getLeft().toSource()),\n          transformFunctionBody(propNode.getRight().getBody()));\n    } else {\n      return newNode(\n          Token.OBJECT_PROP_DEF,\n          transform(propNode.getLeft()),\n          transform(propNode.getRight()));\n    }\n  }\n\n  @Override\n  Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n    return transform(exprNode.getExpression());\n  }\n\n  @Override\n  Node processRegExpLiteral(RegExpLiteral regexNode) {\n    return Node.newString(Token.REGEXP, regexNode.getValue(), regexNode.getFlags());\n  }\n\n  @Override\n  Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = newNode(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      node.addChildToBack(transform(statementNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  @Override\n  Node processString(StringLiteral stringNode) {\n    return Node.newString(stringNode.getType(), stringNode.getValue());\n  }\n\n  @Override\n  Node processSwitchCase(SwitchCase caseNode) {\n    Node block = transform(caseNode.getStatements());\n    if (caseNode.getType() == Token.CASE) {\n      return newNode(Token.CASE, transform(caseNode.getExpression()), block);\n    } else {\n      return newNode(Token.DEFAULT_CASE, block);\n    }\n  }\n\n  @Override\n  Node processSwitchStatement(SwitchStatement statementNode) {\n    Node switchExpr = transform(statementNode.getExpression());\n    Node caseChild = newNode(Token.CASEBLOCK);\n    for (SwitchCase caseNode : statementNode.getCases()) {\n      caseChild.addChildToBack(transform(caseNode));\n    }\n    return newNode(Token.SWITCH, switchExpr, caseChild);\n  }\n\n  @Override\n  Node processThrowStatement(ThrowStatement statementNode) {\n    return newNode(Token.THROW, transform(statementNode.getExpression()));\n  }\n\n  @Override\n  Node processTryStatement(TryStatement statementNode) {\n    Node tryBlock = transformBlock(statementNode.getTryBlock());\n    Node catchBlock = statementNode.getCatchBlock() == null\n        ? null\n        : transform(statementNode.getCatchBlock());\n    Node finallyBlock = statementNode.getFinallyBlock() == null\n        ? null\n        : transform(statementNode.getFinallyBlock());\n    if (catchBlock == null && finallyBlock == null) {\n      return tryBlock;\n    } else if (catchBlock == null) {\n      return newNode(Token.BLOCK, tryBlock, finallyBlock);\n    } else if (finallyBlock == null) {\n      return newNode(Token.TRY, tryBlock, catchBlock);\n    } else {\n      return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n    }\n  }\n\n  @Override\n  Node processUnaryExpression(UnaryExpression exprNode) {\n    return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n  }\n\n  @Override\n  Node processVariableDeclaration(VariableDeclaration declNode) {\n    Node node = newNode(transformTokenType(declNode.getType()));\n    for (VariableInitializer init : declNode.getVariables()) {\n      node.addChildToBack(transform(init));\n    }\n    return node;\n  }\n\n  @Override\n  Node processVariableInitializer(VariableInitializer initNode) {\n    return initNode.getInitializer() == null\n        ? newNode(Token.NAME, Node.newString(Token.NAME, initNode.getTarget().toSource()))\n        : newNode(\n            Token.ASSIGN,\n            newNode(Token.NAME, Node.newString(Token.NAME, initNode.getTarget().toSource())),\n            transform(initNode.getInitializer()));\n  }\n\n  @Override\n  Node processWhileLoop(WhileLoop loopNode) {\n    Node block;\n    if (loopNode.getBody().getType() == Token.BLOCK) {\n      block = transformBlock(loopNode.getBody());\n    } else {\n      block = transform(loopNode.getBody());\n    }\n    return newNode(Token.WHILE, transform(loopNode.getCondition()), block);\n  }\n\n  @Override\n  Node processWithStatement(WithStatement statementNode) {\n    Node node = newNode(Token.WITH, transform(statementNode.getExpression()));\n    node.addChildToBack(transformBlock(statementNode.getStatement()));\n    return node;\n  }\n\n  // The following methods are added to the original implementation.\n  \n  @Override\n  Node processArrayLiteral(ArrayLiteral arrayNode) {\n    Node n = newNode(Token.ARRAYLIT);\n    for (AstNode element : arrayNode.getElements()) {\n      if (element == null) {\n        n.addChildToBack(newNode(Token.EMPTY));\n      } else {\n        n.addChildToBack(transform(element));\n      }\n    }\n    return n;\n  }\n\n  Node processCatchCondition(CatchClause catchClause) {\n    Node bt = transform(catchClause.getBody());\n    Node catchVar = transform(catchClause.getVarName());\n    return newNode(Token.CATCH, catchVar, bt);\n  }\n\n  Node processClass(ClassNode classNode) {\n    Node superClass = transform(classNode.getSuperClass());\n    Node classMembers = newNode(Token.CLASS_MEMBERS);\n    for (ClassProperty classProperty : classNode.getClassElements()) {\n      classMembers.addChildToBack(transform(classProperty));\n    }\n    return addJsDocToNode(\n        newNode(Token.CLASS, Node.newString(Token.NAME, classNode.getClassName()), superClass),\n        classNode.getJsDoc(),\n        classMembers);\n  }\n\n  Node processComputedPropertyDefinition(ComputedPropertyDefinition computedProp) {\n    Node propNode = newNode(Token.COMPUTED_PROP_DEF, transform(computedProp.getLeft()));\n    Node valueNode = transform(computedProp.getRight());\n    if (valueNode.getType() == Token.FUNCTION) {\n      propNode.addChildToBack(valueNode);\n    } else {\n      propNode.addChildToBack(newNode(Token.GETTER_DEF, newNode(Token.EMPTY), valueNode));\n    }\n    return propNode;\n  }\n\n  Node processDestructuringLhs(DestructuringForm formNode, int varType, Node varName) {\n    Node n = newNode(varType, varName);\n    for (AstNode child : formNode.getChildren()) {\n      switch (child.getType()) {\n        case Token.ARRAY_PATTER",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..07e4b7f0 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,407 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory extends TransformTraversal {\n+  // Other methods as before ...\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  @Override\n+  Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  @Override\n+  Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  @Override\n+  Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  @Override\n+  Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  @Override\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processForInLoop(ForInLoop loopNode) {\n+    Node left;\n+    // If the left-hand side of the for..in is a destructuring pattern,\n+    // declare a temporary variable as the loop variable and destructure\n+    // the value each iteration.\n+    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n+        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n+      left = newNode(\n+          Token.VAR,\n+          createDestructuringLhs(\n+              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n+    } else {\n+      left = transform(loopNode.getIterator());\n+    }\n+\n+    return newNode(\n+        Token.FOR,\n+        newNode(Token.EMPTY),\n+        newNode(Token.EMPTY),\n+        newNode(\n+            Token.BLOCK,\n+            left,\n+            newNode(\n+                Token.FOR_IN,\n+                transform(loopNode.getIteratedObject()),\n+                newNode(Token.EMPTY),\n+                transformBlock(loopNode.getBody()))));\n+  }\n+\n+  @Override\n+  Node processForLoop(ForLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getInitializer()),\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  Node processFunctionCall(FunctionCall callNode) {\n+    Node callTarget = transform(callNode.getTarget());\n+    Node callArgs = newNode(Token.EMPTY);\n+    for (AstNode arg : callNode.getArguments()) {\n+      callArgs.addChildToBack(transform(arg));\n     }\n+    return newNode(Token.CALL, callTarget, callArgs);\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  @Override\n+  Node processFunctionNode(FunctionNode functionNode) {\n+    Node parametersNode = newNode(Token.PARAM_LIST);\n+    for (int i = 0; i < functionNode.getParams().size(); i++) {\n+      AstNode param = functionNode.getParams().get(i);\n+      Node nameNode = newNode(Token.NAME, Node.newString(Token.NAME, param.toSource()));\n+      parametersNode.addChildToBack(nameNode);\n+    }\n+    Node returnTypeNode = transform(functionNode.getReturnType());\n+    if (returnTypeNode != null) {\n+      returnTypeNode.setType(Token.RETURN_TYPE);\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    Node functionBodyNode = transform(functionNode.getBody());\n+    Node functionNodeWithJsDoc = addJsDocToFunction(\n+        newNode(Token.FUNCTION, Node.newString(Token.NAME, functionNode.getName())),\n+        functionNode.getJsDoc(),\n+        parametersNode,\n+        returnTypeNode,\n+        functionBodyNode);\n+\n+    // If this is a getter or setter method, attach the modifiers as JSDoc.\n+    JSDocInfo methodModifiers = functionNode.getJsDoc().getInlineType().getJSDocInfo();\n+    if (methodModifiers != null && (methodModifiers.isGetter() || methodModifiers.isSetter())) {\n+      functionNodeWithJsDoc.setBooleanProp(Node.COMPUTED_PROP_GETTER, methodModifiers.isGetter());\n+      functionNodeWithJsDoc.setBooleanProp(Node.COMPUTED_PROP_SETTER, methodModifiers.isSetter());\n+      JsdocUtil.applyToBooleanPropertyName(functionNodeWithJsDoc.getSecondChild());\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    return functionNodeWithJsDoc;\n+  }\n+\n+  @Override\n+  Node processIfStatement(IfStatement statementNode) {\n+    return newNode(\n+        Token.IF,\n+        transform(statementNode.getCondition()),\n+        transformBlock(statementNode.getThenPart()),\n+        statementNode.getElsePart() == null\n+            ? null\n+            : transformBlock(statementNode.getElsePart()));\n+  }\n+\n+  @Override\n+  Node processInfixExpression(InfixExpression exprNode) {\n+    return newNode(\n+        transformTokenType(exprNode.getType()),\n+        transform(exprNode.getLeft()),\n+        transform(exprNode.getRight()));\n+  }\n+\n+  @Override\n+  Node processLabeledStatement(LabeledStatement statementNode) {\n+    Node node = newNode(Token.LABEL, Node.newString(Token.NAME, statementNode.getLabelName()));\n+    node.addChildToBack(transform(statementNode.getStatement()));\n+    return node;\n+  }\n+\n+  @Override\n+  Node processName(Name nameNode) {\n+    return Node.newString(Token.NAME, nameNode.getIdentifier());\n+  }\n+\n+  @Override\n+  Node processNewExpression(NewExpression exprNode) {\n+    Node target = transform(exprNode.getTarget());\n+    Node arguments = newNode(Token.EMPTY);\n+    for (AstNode arg : exprNode.getArguments()) {\n+      arguments.addChildToBack(transform(arg));\n     }\n+    return newNode(Token.NEW, target, arguments);\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n+  @Override\n+  Node processNumber(NumberLiteral numberNode) {\n+    return Node.newNumber(numberNode.getNumber());\n+  }\n+\n+  @Override\n+  Node processObjectLiteral(ObjectLiteral objNode) {\n+    Node n = newNode(Token.OBJECTLIT);\n+    for (ObjectProperty property : objNode.getElements()) {\n+      Node propNode = transform(property);\n+      n.addChildToBack(propNode);\n+    }\n+    return n;\n+  }\n+\n+  Node processObjectProperty(ObjectProperty propNode) {\n+    if (propNode.isGetter()) {\n+      return newNode(\n+          Token.GETTER_DEF,\n+          Node.newString(Token.NAME, propNode.getLeft().toSource()),\n+          transformFunctionBody(propNode.getRight().getBody()));\n+    } else if (propNode.isSetter()) {\n+      return newNode(\n+          Token.SETTER_DEF,\n+          Node.newString(Token.NAME, propNode.getLeft().toSource()),\n+          transformFunctionBody(propNode.getRight().getBody()));\n+    } else {\n       return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+          Token.OBJECT_PROP_DEF,\n+          transform(propNode.getLeft()),\n+          transform(propNode.getRight()));\n     }\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n+    return transform(exprNode.getExpression());\n+  }\n+\n+  @Override\n+  Node processRegExpLiteral(RegExpLiteral regexNode) {\n+    return Node.newString(Token.REGEXP, regexNode.getValue(), regexNode.getFlags());\n+  }\n+\n+  @Override\n+  Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(statementNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  Node processString(StringLiteral stringNode) {\n+    return Node.newString(stringNode.getType(), stringNode.getValue());\n+  }\n+\n+  @Override\n+  Node processSwitchCase(SwitchCase caseNode) {\n+    Node block = transform(caseNode.getStatements());\n+    if (caseNode.getType() == Token.CASE) {\n+      return newNode(Token.CASE, transform(caseNode.getExpression()), block);\n+    } else {\n+      return newNode(Token.DEFAULT_CASE, block);\n     }\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  Node processSwitchStatement(SwitchStatement statementNode) {\n+    Node switchExpr = transform(statementNode.getExpression());\n+    Node caseChild = newNode(Token.CASEBLOCK);\n+    for (SwitchCase caseNode : statementNode.getCases()) {\n+      caseChild.addChildToBack(transform(caseNode));\n+    }\n+    return newNode(Token.SWITCH, switchExpr, caseChild);\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  Node processThrowStatement(ThrowStatement statementNode) {\n+    return newNode(Token.THROW, transform(statementNode.getExpression()));\n+  }\n+\n+  @Override\n+  Node processTryStatement(TryStatement statementNode) {\n+    Node tryBlock = transformBlock(statementNode.getTryBlock());\n+    Node catchBlock = statementNode.getCatchBlock() == null\n+        ? null\n+        : transform(statementNode.getCatchBlock());\n+    Node finallyBlock = statementNode.getFinallyBlock() == null\n+        ? null\n+        : transform(statementNode.getFinallyBlock());\n+    if (catchBlock == null && finallyBlock == null) {\n+      return tryBlock;\n+    } else if (catchBlock == null) {\n+      return newNode(Token.BLOCK, tryBlock, finallyBlock);\n+    } else if (finallyBlock == null) {\n+      return newNode(Token.TRY, tryBlock, catchBlock);\n+    } else {\n+      return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+    }\n+  }\n+\n+  @Override\n+  Node processUnaryExpression(UnaryExpression exprNode) {\n+    return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n+  }\n+\n+  @Override\n+  Node processVariableDeclaration(VariableDeclaration declNode) {\n+    Node node = newNode(transformTokenType(declNode.getType()));\n+    for (VariableInitializer init : declNode.getVariables()) {\n+      node.addChildToBack(transform(init));\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  Node processVariableInitializer(VariableInitializer initNode) {\n+    return initNode.getInitializer() == null\n+        ? newNode(Token.NAME, Node.newString(Token.NAME, initNode.getTarget().toSource()))\n+        : newNode(\n+            Token.ASSIGN,\n+            newNode(Token.NAME, Node.newString(Token.NAME, initNode.getTarget().toSource())),\n+            transform(initNode.getInitializer()));\n+  }\n+\n+  @Override\n+  Node processWhileLoop(WhileLoop loopNode) {\n+    Node block;\n+    if (loopNode.getBody().getType() == Token.BLOCK) {\n+      block = transformBlock(loopNode.getBody());\n+    } else {\n+      block = transform(loopNode.getBody());\n+    }\n+    return newNode(Token.WHILE, transform(loopNode.getCondition()), block);\n+  }\n+\n+  @Override\n+  Node processWithStatement(WithStatement statementNode) {\n+    Node node = newNode(Token.WITH, transform(statementNode.getExpression()));\n+    node.addChildToBack(transformBlock(statementNode.getStatement()));\n+    return node;\n+  }\n+\n+  // The following methods are added to the original implementation.\n+  \n+  @Override\n+  Node processArrayLiteral(ArrayLiteral arrayNode) {\n+    Node n = newNode(Token.ARRAYLIT);\n+    for (AstNode element : arrayNode.getElements()) {\n+      if (element == null) {\n+        n.addChildToBack(newNode(Token.EMPTY));\n+      } else {\n+        n.addChildToBack(transform(element));\n+      }\n+    }\n+    return n;\n+  }\n+\n+  Node processCatchCondition(CatchClause catchClause) {\n+    Node bt = transform(catchClause.getBody());\n+    Node catchVar = transform(catchClause.getVarName());\n+    return newNode(Token.CATCH, catchVar, bt);\n+  }\n+\n+  Node processClass(ClassNode classNode) {\n+    Node superClass = transform(classNode.getSuperClass());\n+    Node classMembers = newNode(Token.CLASS_MEMBERS);\n+    for (ClassProperty classProperty : classNode.getClassElements()) {\n+      classMembers.addChildToBack(transform(classProperty));\n     }\n+    return addJsDocToNode(\n+        newNode(Token.CLASS, Node.newString(Token.NAME, classNode.getClassName()), superClass),\n+        classNode.getJsDoc(),\n+        classMembers);\n+  }\n+\n+  Node processComputedPropertyDefinition(ComputedPropertyDefinition computedProp) {\n+    Node propNode = newNode(Token.COMPUTED_PROP_DEF, transform(computedProp.getLeft()));\n+    Node valueNode = transform(computedProp.getRight());\n+    if (valueNode.getType() == Token.FUNCTION) {\n+      propNode.addChildToBack(valueNode);\n+    } else {\n+      propNode.addChildToBack(newNode(Token.GETTER_DEF, newNode(Token.EMPTY), valueNode));\n+    }\n+    return propNode;\n+  }\n+\n+  Node processDestructuringLhs(DestructuringForm formNode, int varType, Node varName) {\n+    Node n = newNode(varType, varName);\n+    for (AstNode child : formNode.getChildren()) {\n+      switch (child.getType()) {\n+        case Token.ARRAY_PATTER\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: : expected",
    "test_result": "ERROR"
}