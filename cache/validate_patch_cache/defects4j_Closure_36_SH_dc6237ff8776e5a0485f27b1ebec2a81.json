{
    "patch": "if (value.isFunction()) {\n  Node callNode = reference.getParent();\n  if (callNode == null) {\n    return false;\n  }\n\n  boolean isCall =\n      callNode.isCall() && callNode.getFirstChild() == reference.getNode();\n  boolean isResultOfPutField =\n      callNode.isExprResult() && callNode.getFirstChild().isAssign()\n          && callNode.getFirstChild().getFirstChild() == reference.getNode()\n          && callNode.getFirstFirstChild().isGetProp();\n  boolean isResultOfPutGlobal =\n      callNode.isExprResult() && callNode.getFirstChild().isAssign()\n          && callNode.getFirstChild().getFirstChild() == reference.getNode()\n          && callNode.getFirstFirstChild().isName()\n          && callNode.getFirstFirstChild().getString().equals(\"window\");\n\n  if (!isCall && !isResultOfPutField && !isResultOfPutGlobal) {\n    return false;\n  }\n\n  CodingConvention convention = compiler.getCodingConvention();\n  if (isCall || isResultOfPutField) {\n    // Bug 2388531: Don't inline subclass definitions into class defining\n    // calls as this confused class removing logic.\n    SubclassRelationship relationship =\n        convention.getClassesDefinedByCall(callNode);\n    if (relationship != null) {\n      return false;\n    }\n  } else if (isResultOfPutGlobal) {\n    // TODO(b/64318899): Allow this case as well.\n    return false;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..29822638 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,42 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+if (value.isFunction()) {\n+  Node callNode = reference.getParent();\n+  if (callNode == null) {\n+    return false;\n+  }\n+\n+  boolean isCall =\n+      callNode.isCall() && callNode.getFirstChild() == reference.getNode();\n+  boolean isResultOfPutField =\n+      callNode.isExprResult() && callNode.getFirstChild().isAssign()\n+          && callNode.getFirstChild().getFirstChild() == reference.getNode()\n+          && callNode.getFirstFirstChild().isGetProp();\n+  boolean isResultOfPutGlobal =\n+      callNode.isExprResult() && callNode.getFirstChild().isAssign()\n+          && callNode.getFirstChild().getFirstChild() == reference.getNode()\n+          && callNode.getFirstFirstChild().isName()\n+          && callNode.getFirstFirstChild().getString().equals(\"window\");\n+\n+  if (!isCall && !isResultOfPutField && !isResultOfPutGlobal) {\n+    return false;\n+  }\n+\n+  CodingConvention convention = compiler.getCodingConvention();\n+  if (isCall || isResultOfPutField) {\n+    // Bug 2388531: Don't inline subclass definitions into class defining\n+    // calls as this confused class removing logic.\n+    SubclassRelationship relationship =\n+        convention.getClassesDefinedByCall(callNode);\n+    if (relationship != null) {\n+      return false;\n+    }\n+  } else if (isResultOfPutGlobal) {\n+    // TODO(b/64318899): Allow this case as well.\n+    return false;\n+  }\n+}\n         }\n       }\n ",
    "result_reason": "error: variable callNode is already defined in method canInline(Reference,Reference,Reference)",
    "test_result": "ERROR"
}