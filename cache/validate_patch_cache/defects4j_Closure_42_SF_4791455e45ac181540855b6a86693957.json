{
    "patch": "import org.mozilla.javascript.ErrorReporter;\nimport org.mozilla.javascript.ast.*;\n\nfinal class IRFactory extends Parser {\n    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n            ImmutableSet.of(\"use strict\");\n\n    private final ErrorReporter errorReporter;\n    private final String sourceName;\n\n    IRFactory(\n            CompilerEnvirons env,\n            ErrorReporter errorReporter,\n            String sourceName) {\n        super(env, errorReporter);\n        this.errorReporter = errorReporter;\n        this.sourceName = sourceName;\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) return false;\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n                n.getFirstChild().isString() &&\n                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    @Override\n    Node processBlock(Block blockNode) {\n        return processGeneric(blockNode);\n    }\n\n    @Override\n    Node processBreakStatement(BreakStatement statementNode) {\n        Node node = newNode(Token.BREAK);\n        if (statementNode.getBreakLabel() != null) {\n            Node labelName = transform(statementNode.getBreakLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    Node processCatchClause(CatchClause clauseNode) {\n        AstNode catchVar = clauseNode.getVarName();\n        Node node = newNode(Token.CATCH, transform(catchVar));\n        if (clauseNode.getCatchCondition() != null) {\n            errorReporter.error(\n                    \"Catch clauses are not supported\",\n                    sourceName,\n                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n        }\n        node.addChildToBack(transformBlock(clauseNode.getBody()));\n        return node;\n    }\n\n    @Override\n    Node processConditionalExpression(ConditionalExpression exprNode) {\n        return newNode(\n                Token.HOOK,\n                transform(exprNode.getTestExpression()),\n                transform(exprNode.getTrueExpression()),\n                transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    Node processContinueStatement(ContinueStatement statementNode) {\n        Node node = newNode(Token.CONTINUE);\n        if (statementNode.getLabel() != null) {\n            Node labelName = transform(statementNode.getLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    Node processDoLoop(DoLoop loopNode) {\n        return newNode(\n                Token.DO,\n                transformBlock(loopNode.getBody()),\n                transform(loopNode.getCondition()));\n    }\n\n    @Override\n    Node processElementGet(ElementGet getNode) {\n        return newNode(\n                Token.GETELEM,\n                transform(getNode.getTarget()),\n                transform(getNode.getElement()));\n    }\n\n    @Override\n    Node processEmptyExpression(EmptyExpression exprNode) {\n        return newNode(Token.EMPTY);\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n        Node node = newNode(transformTokenType(statementNode.getType()));\n        node.addChildToBack(transform(statementNode.getExpression()));\n        return node;\n    }\n\n    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n        Node left = transform(loopNode.getIterator());\n\n        if (left.getType() == Token.VAR) {\n            // Make sure we catch for(x in []) and for(let x in [])\n            left.getFirstChild().setType(Token.NAME);\n        } else {\n            left.setType(Token.NAME);\n        }\n\n        Node arr = transform(loopNode.getIteratedObject());\n        Node body = transformBlock(loopNode.getBody());\n\n        Node forNode;\n\n        if (loopNode.isForEach()) {\n            forNode = new Node(Token.FOR_OF, left, arr, body);\n        } else {\n            forNode = new Node(Token.FOR_IN, left, arr, body);\n        }\n        return forNode;\n    }\n\n    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n        Node n;\n\n        // condition for CALL or NEW\n        if (callNode.getTarget() instanceof PropertyGet &&\n                \"bind\".equals(\n                        ((PropertyGet) callNode.getTarget()).getProperty().getIdentifier())) {\n            // bind() calls are handled directly in transform calls\n            return transform(callNode.getTarget());\n        } else {\n            // normal function call\n            n = newNode(Token.CALL, transform(callNode.getTarget()));\n            for (AstNode arg : callNode.getArguments()) {\n                n.addChildToBack(transform(arg));\n            }\n            n.setLineno(callNode.getLineno());\n            n.setCharno(callNode.getCharno());\n        }\n\n        return n;\n    }\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n        Node n = newNode(Token.FUNCTION);\n        int functionType = functionNode.getFunctionType();\n        n.addChildToBack(\n                new Node(\n                        Token.NAME,\n                        functionNode.getFunctionName() != null\n                                ? functionNode.getFunctionName().getIdentifier()\n                                : null));\n        if (functionType == FunctionNode.FUNCTION_EXPRESSION) {\n            // Anonymous functions only have children.\n            n.putProp(Node.IS_FUNCTION_EXPRESSION, true);\n        }\n        n.addChildToBack(transform(functionNode.getParams()));\n\n        boolean isArrowFunction = functionNode.isArrowFunction();\n\n        Node body;\n        if (!isArrowFunction) {\n            body = transform(functionNode.getBody());\n        } else {\n            body = transform(functionNode.getArrowExpression());\n        }\n        // an arrow function without a block expression can't have a return statement\n        boolean hasReturn = !isArrowFunction && NodeUtil.hasReturnStatement(body);\n        n.addChildToBack(body);\n        NodeUtil.addFunctionParameters(n, functionNode);\n\n        n.putIntProp(Node.FUNCTION_PROP, functionType);\n        if (hasReturn) {\n            n.putProp(Node.HAS_GOTO, 0);\n        }\n\n        if (!isArrowFunction) {\n            n.setEncodedSourceStart(functionNode.getBody().getEncodedSourceStart());\n            n.setEncodedSourceEnd(functionNode.getBody().getEncodedSourceEnd());\n        }\n        n.setLineno(functionNode.getLineno());\n        n.setCharno(functionNode.getCharno());\n\n        return n;\n    }\n\n    @Override\n    Node processIfStatement(IfStatement statementNode) {\n        Node n = newNode(Token.IF);\n        n.addChildToBack(\n                transform(statementNode.getCondition()));\n        n.addChildToBack(\n                transform(statementNode.getThenPart()));\n        if (statementNode.getElsePart() != null) {\n            n.addChildToBack(transform(statementNode.getElsePart()));\n        }\n        return n;\n    }\n\n    @Override\n    Node processInfixExpression(InfixExpression infixNode) {\n        Node node = newNode(transformTokenType(infixNode.getType()));\n        node.addChildToBack(transform(infixNode.getLeft()));\n        node.addChildToBack(transform(infixNode.getRight()));\n        return node;\n    }\n\n    @Override\n    Node processLabeledStatement(LabeledStatement labelNode) {\n        Node n = transform(labelNode.getStatement());\n        Node label = new Node(Token.LABEL_NAME, labelNode.getLabelName());\n        label.setOriginalName(labelNode.getLabelName());\n        n.addChildToFront(label);\n        return n;\n    }\n\n    @Override\n    Node processLetNode(LetNode letNode) {\n        Node n = newNode(Token.VAR);\n        for (VariableDeclaration decl : letNode.getVariables()) {\n            if (decl.isConst()) {\n                errorReporter.error(\n                        \"Const declarations are not supported. Use let instead.\",\n                        sourceName,\n                        letNode.getLineno(),\n                        \"\", 0);\n            }\n            n.addChildToBack(newNode(Token.NAME, decl.getIdentifier()));\n            if (decl.getInitializer() != null) {\n                n.getLastChild().addChildToBack(transform(decl.getInitializer()));\n            }\n        }\n        return n;\n    }\n\n    @Override\n    Node processName(Name nameNode) {\n        Node n = newNode(Token.NAME, nameNode.getIdentifier());\n        return n;\n    }\n\n    @Override\n    Node processNewExpression(NewExpression newExprNode) {\n        Node n = new Node(Token.NEW);\n        n.addChildToBack(transform(newExprNode.getTarget()));\n        for (AstNode arg : newExprNode.getArguments()) {\n            n.addChildToBack(transform(arg));\n        }\n        return n;\n    }\n\n    @Override\n    Node processNumber(NumberLiteral numberNode) {\n        Node n = newNode(Token.NUMBER);\n        n.setDouble(numberNode.getNumber());\n        return n;\n    }\n\n    @Override\n    Node processObjectLiteral(ObjectLiteral objLit) {\n        Node n = newNode(Token.OBJECTLIT);\n        for (ObjectProperty prop : objLit.getElements()) {\n            Node key = newNode(Token.STRING_KEY);\n            if (prop.isGetter()) {\n                key.setType(Token.GETTER_DEF);\n            } else if (prop.isSetter()) {\n                key.setType(Token.SETTER_DEF);\n            }\n            if (prop.isQuoted()) {\n                key.putProp(Node.QUOTED_PROP, objLit);\n            }\n            AstNode propName = prop.getLeft();\n            if (propName instanceof Name) {\n                key.setString(propName.getString());\n            } else if (propName instanceof StringLiteral) {\n                key.setString(propName.getString());\n                key.setOriginalName(((StringLiteral) propName).getOriginalName());\n            } else if (propName instanceof NumberLiteral) {\n                key.setDouble(((NumberLiteral) propName).getNumber());\n            }\n\n            key.addChildToBack(transform(prop.getRight()));\n            n.addChildToBack(key);\n        }\n        return n;\n    }\n\n    @Override\n    Node processParenthesizedExpression(ParenthesizedExpression parenthesizedExpr) {\n        Node n = newNode(Token.LP);\n        n.addChildToBack(transform(parenthesizedExpr.getExpression()));\n        n.addChildToBack(new Node(Token.RP));\n        return n;\n    }\n\n    @Override\n    Node processPropertyGet(PropertyGet propertyGetNode) {\n        Node targetNode = transform(propertyGetNode.getTarget());\n        Node keyNode =\n                new Node(Token.STRING).setString(propertyGetNode.getProperty().getIdentifier());\n        targetNode.addChildToBack(keyNode);\n        return targetNode;\n    }\n\n    @Override\n    Node processRegExpLiteral(RegExpLiteral regexpNode) {\n        Node node = new Node(Token.REGEXP);\n        node.setString(regexpNode.getValue());\n        node.setRegExpFlags(regexpNode.getFlags());\n        return node;\n    }\n\n    @Override\n    Node processReturnStatement(ReturnStatement statementNode) {\n        Node node = newNode(Token.RETURN);\n        if (statementNode.getReturnValue() != null) {\n            node.addChildToBack(transform(statementNode.getReturnValue()));\n        }\n        return node;\n    }\n\n    @Override\n    Node processString(StringLiteral stringNode) {\n        Node node = newNode(Token.STRING);\n        node.setString(stringNode.getValue());\n        if (stringNode.getQuoteCharacter() == '\\'') {\n            node.putProp(Encoder.ES6_SINGLE_QUOTE_STRING, 1);\n        }\n        return node;\n    }\n\n    @Override\n    Node processSwitchCase(SwitchCase switchCaseNode) {\n        Node n = newNode(Token.CASE);\n        n.addChildToBack(transform(switchCaseNode.getExpression()));\n        for (AstNode stmt : switchCaseNode.getStatements()) {\n            n.addChildToBack(transform(stmt));\n        }\n        return n;\n    }\n\n    @Override\n    Node processSwitchStatement(SwitchStatement statementNode) {\n        Node n = newNode(Token.SWITCH);\n        n.addChildToBack(transform(statementNode.getExpression()));\n        for (SwitchCase caseStmt : statementNode.getCases()) {\n            n.addChildToBack(transform(caseStmt));\n        }\n        return n;\n    }\n\n    @Override\n    Node processThrowStatement(ThrowStatement statementNode) {\n        return newNode(Token.THROW, transform(statementNode.getExpression()));\n    }\n\n    @Override\n    Node processTryStatement(TryStatement statementNode) {\n        Node n = newNode(Token.TRY);\n        n.addChildToBack(transformBlock(statementNode.getTryBlock()));\n\n        if (statementNode.getCatchClauses() != null) {\n            for (CatchClause clause : statementNode.getCatchClauses()) {\n                n.addChildToBack(transform(clause));\n            }\n        }\n\n        if (statementNode.getFinallyBlock() != null) {\n            Node finallyBlock = transformBlock(statementNode.getFinallyBlock());\n            finallyBlock.setType(Token.FINALLY);\n            n.addChildToBack(finallyBlock);\n        }\n\n        return n;\n    }\n\n    @Override\n    Node processUnaryExpression(UnaryExpression unaryNode) {\n        int type;\n        switch (unaryNode.getType()) {\n            case Token.BITNOT:\n                type = Token.BITNOT;\n                break;\n            case Token.NEG:\n                type = Token.NEG;\n                break;\n            case Token.POS:\n                type = Token.POS;\n                break;\n            case Token.NOT:\n                type = Token.NOT;\n                break;\n            case Token.DELPROP:\n                type = Token.DELPROP;\n                break;\n            case Token.VOID:\n                type = Token.VOID;\n                break;\n            case Token.TYPEOF:\n                type = Token.TYPEOF;\n                break;\n            default:\n                throw new RuntimeException(\"Unexpected unary operator\");\n        }\n        Node node = newNode(type, transform(unaryNode.getOperand()));\n        return node;\n    }\n\n    @Override\n    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n        Node node = newNode(Token.VAR);\n        for (VariableInitializer initializer : declarationNode.getVariables()) {\n            Node left = transform(initializer.getTarget());\n            Node right = null;\n            if (initializer.getInitializer() != null) {\n                right = transform(initializer.getInitializer());\n            }\n            Node varNode = new Node(Token.NAME, left);\n            if (right != null) {\n                varNode.addChildToBack(right);\n            } else if (initializer.isConst()) {\n                errorReporter.warning(\n                        \"missing variable initialization for const \" + left.getString(),\n                        sourceName,\n                        initializer.getLineno(),\n                        \"\", 0);\n            }\n            node.addChildToBack(varNode);\n        }\n        return node;\n    }\n\n    @Override\n    Node processWhileLoop(WhileLoop loopNode) {\n        return newNode(\n                Token.WHILE,\n                transform(loopNode.getCondition()),\n                transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    Node processWithStatement(WithStatement statementNode) {\n        // optimization: add a flag to let downstream passes know that this code\n        // cannot be statically accessed unless the \"with\" object is known.\n        errorReporter.error(\n                \"With statements are not supported\",\n                sourceName,\n                statementNode.getLineno(),\n                \"\", 0);\n        Node obj = transform(statementNode.getExpression());\n        Node body = transform(statementNode.getStatement());\n        Node n = new Node(Token.WITH, ob",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..a7be2378 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,472 @@ class IRFactory {\n       }\n     }\n \n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.ast.*;\n+\n+final class IRFactory extends Parser {\n+    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+            ImmutableSet.of(\"use strict\");\n+\n+    private final ErrorReporter errorReporter;\n+    private final String sourceName;\n+\n+    IRFactory(\n+            CompilerEnvirons env,\n+            ErrorReporter errorReporter,\n+            String sourceName) {\n+        super(env, errorReporter);\n+        this.errorReporter = errorReporter;\n+        this.sourceName = sourceName;\n+    }\n+\n     private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+        if (n == null) return false;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+                n.getFirstChild().isString() &&\n+                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n     @Override\n     Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+        return processGeneric(blockNode);\n     }\n \n     @Override\n     Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+        Node node = newNode(Token.BREAK);\n+        if (statementNode.getBreakLabel() != null) {\n+            Node labelName = transform(statementNode.getBreakLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n     Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+        AstNode catchVar = clauseNode.getVarName();\n+        Node node = newNode(Token.CATCH, transform(catchVar));\n+        if (clauseNode.getCatchCondition() != null) {\n+            errorReporter.error(\n+                    \"Catch clauses are not supported\",\n+                    sourceName,\n+                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+        }\n+        node.addChildToBack(transformBlock(clauseNode.getBody()));\n+        return node;\n     }\n \n     @Override\n     Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+        return newNode(\n+                Token.HOOK,\n+                transform(exprNode.getTestExpression()),\n+                transform(exprNode.getTrueExpression()),\n+                transform(exprNode.getFalseExpression()));\n     }\n \n     @Override\n     Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+        Node node = newNode(Token.CONTINUE);\n+        if (statementNode.getLabel() != null) {\n+            Node labelName = transform(statementNode.getLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n     Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+        return newNode(\n+                Token.DO,\n+                transformBlock(loopNode.getBody()),\n+                transform(loopNode.getCondition()));\n     }\n \n     @Override\n     Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+        return newNode(\n+                Token.GETELEM,\n+                transform(getNode.getTarget()),\n+                transform(getNode.getElement()));\n     }\n \n     @Override\n     Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+        return newNode(Token.EMPTY);\n     }\n \n     @Override\n     Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+        Node node = newNode(transformTokenType(statementNode.getType()));\n+        node.addChildToBack(transform(statementNode.getExpression()));\n+        return node;\n     }\n \n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n+        Node left = transform(loopNode.getIterator());\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+        if (left.getType() == Token.VAR) {\n+            // Make sure we catch for(x in []) and for(let x in [])\n+            left.getFirstChild().setType(Token.NAME);\n+        } else {\n+            left.setType(Token.NAME);\n+        }\n+\n+        Node arr = transform(loopNode.getIteratedObject());\n+        Node body = transformBlock(loopNode.getBody());\n+\n+        Node forNode;\n+\n+        if (loopNode.isForEach()) {\n+            forNode = new Node(Token.FOR_OF, left, arr, body);\n+        } else {\n+            forNode = new Node(Token.FOR_IN, left, arr, body);\n+        }\n+        return forNode;\n+    }\n+\n+    @Override\n+    Node processFunctionCall(FunctionCall callNode) {\n+        Node n;\n+\n+        // condition for CALL or NEW\n+        if (callNode.getTarget() instanceof PropertyGet &&\n+                \"bind\".equals(\n+                        ((PropertyGet) callNode.getTarget()).getProperty().getIdentifier())) {\n+            // bind() calls are handled directly in transform calls\n+            return transform(callNode.getTarget());\n+        } else {\n+            // normal function call\n+            n = newNode(Token.CALL, transform(callNode.getTarget()));\n+            for (AstNode arg : callNode.getArguments()) {\n+                n.addChildToBack(transform(arg));\n+            }\n+            n.setLineno(callNode.getLineno());\n+            n.setCharno(callNode.getCharno());\n+        }\n+\n+        return n;\n+    }\n+\n+    @Override\n+    Node processFunctionNode(FunctionNode functionNode) {\n+        Node n = newNode(Token.FUNCTION);\n+        int functionType = functionNode.getFunctionType();\n+        n.addChildToBack(\n+                new Node(\n+                        Token.NAME,\n+                        functionNode.getFunctionName() != null\n+                                ? functionNode.getFunctionName().getIdentifier()\n+                                : null));\n+        if (functionType == FunctionNode.FUNCTION_EXPRESSION) {\n+            // Anonymous functions only have children.\n+            n.putProp(Node.IS_FUNCTION_EXPRESSION, true);\n+        }\n+        n.addChildToBack(transform(functionNode.getParams()));\n+\n+        boolean isArrowFunction = functionNode.isArrowFunction();\n+\n+        Node body;\n+        if (!isArrowFunction) {\n+            body = transform(functionNode.getBody());\n+        } else {\n+            body = transform(functionNode.getArrowExpression());\n+        }\n+        // an arrow function without a block expression can't have a return statement\n+        boolean hasReturn = !isArrowFunction && NodeUtil.hasReturnStatement(body);\n+        n.addChildToBack(body);\n+        NodeUtil.addFunctionParameters(n, functionNode);\n+\n+        n.putIntProp(Node.FUNCTION_PROP, functionType);\n+        if (hasReturn) {\n+            n.putProp(Node.HAS_GOTO, 0);\n+        }\n+\n+        if (!isArrowFunction) {\n+            n.setEncodedSourceStart(functionNode.getBody().getEncodedSourceStart());\n+            n.setEncodedSourceEnd(functionNode.getBody().getEncodedSourceEnd());\n+        }\n+        n.setLineno(functionNode.getLineno());\n+        n.setCharno(functionNode.getCharno());\n+\n+        return n;\n     }\n \n+    @Override\n+    Node processIfStatement(IfStatement statementNode) {\n+        Node n = newNode(Token.IF);\n+        n.addChildToBack(\n+                transform(statementNode.getCondition()));\n+        n.addChildToBack(\n+                transform(statementNode.getThenPart()));\n+        if (statementNode.getElsePart() != null) {\n+            n.addChildToBack(transform(statementNode.getElsePart()));\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    Node processInfixExpression(InfixExpression infixNode) {\n+        Node node = newNode(transformTokenType(infixNode.getType()));\n+        node.addChildToBack(transform(infixNode.getLeft()));\n+        node.addChildToBack(transform(infixNode.getRight()));\n+        return node;\n+    }\n+\n+    @Override\n+    Node processLabeledStatement(LabeledStatement labelNode) {\n+        Node n = transform(labelNode.getStatement());\n+        Node label = new Node(Token.LABEL_NAME, labelNode.getLabelName());\n+        label.setOriginalName(labelNode.getLabelName());\n+        n.addChildToFront(label);\n+        return n;\n+    }\n+\n+    @Override\n+    Node processLetNode(LetNode letNode) {\n+        Node n = newNode(Token.VAR);\n+        for (VariableDeclaration decl : letNode.getVariables()) {\n+            if (decl.isConst()) {\n+                errorReporter.error(\n+                        \"Const declarations are not supported. Use let instead.\",\n+                        sourceName,\n+                        letNode.getLineno(),\n+                        \"\", 0);\n+            }\n+            n.addChildToBack(newNode(Token.NAME, decl.getIdentifier()));\n+            if (decl.getInitializer() != null) {\n+                n.getLastChild().addChildToBack(transform(decl.getInitializer()));\n+            }\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    Node processName(Name nameNode) {\n+        Node n = newNode(Token.NAME, nameNode.getIdentifier());\n+        return n;\n+    }\n+\n+    @Override\n+    Node processNewExpression(NewExpression newExprNode) {\n+        Node n = new Node(Token.NEW);\n+        n.addChildToBack(transform(newExprNode.getTarget()));\n+        for (AstNode arg : newExprNode.getArguments()) {\n+            n.addChildToBack(transform(arg));\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    Node processNumber(NumberLiteral numberNode) {\n+        Node n = newNode(Token.NUMBER);\n+        n.setDouble(numberNode.getNumber());\n+        return n;\n+    }\n+\n+    @Override\n+    Node processObjectLiteral(ObjectLiteral objLit) {\n+        Node n = newNode(Token.OBJECTLIT);\n+        for (ObjectProperty prop : objLit.getElements()) {\n+            Node key = newNode(Token.STRING_KEY);\n+            if (prop.isGetter()) {\n+                key.setType(Token.GETTER_DEF);\n+            } else if (prop.isSetter()) {\n+                key.setType(Token.SETTER_DEF);\n+            }\n+            if (prop.isQuoted()) {\n+                key.putProp(Node.QUOTED_PROP, objLit);\n+            }\n+            AstNode propName = prop.getLeft();\n+            if (propName instanceof Name) {\n+                key.setString(propName.getString());\n+            } else if (propName instanceof StringLiteral) {\n+                key.setString(propName.getString());\n+                key.setOriginalName(((StringLiteral) propName).getOriginalName());\n+            } else if (propName instanceof NumberLiteral) {\n+                key.setDouble(((NumberLiteral) propName).getNumber());\n+            }\n+\n+            key.addChildToBack(transform(prop.getRight()));\n+            n.addChildToBack(key);\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    Node processParenthesizedExpression(ParenthesizedExpression parenthesizedExpr) {\n+        Node n = newNode(Token.LP);\n+        n.addChildToBack(transform(parenthesizedExpr.getExpression()));\n+        n.addChildToBack(new Node(Token.RP));\n+        return n;\n+    }\n+\n+    @Override\n+    Node processPropertyGet(PropertyGet propertyGetNode) {\n+        Node targetNode = transform(propertyGetNode.getTarget());\n+        Node keyNode =\n+                new Node(Token.STRING).setString(propertyGetNode.getProperty().getIdentifier());\n+        targetNode.addChildToBack(keyNode);\n+        return targetNode;\n+    }\n+\n+    @Override\n+    Node processRegExpLiteral(RegExpLiteral regexpNode) {\n+        Node node = new Node(Token.REGEXP);\n+        node.setString(regexpNode.getValue());\n+        node.setRegExpFlags(regexpNode.getFlags());\n+        return node;\n+    }\n+\n+    @Override\n+    Node processReturnStatement(ReturnStatement statementNode) {\n+        Node node = newNode(Token.RETURN);\n+        if (statementNode.getReturnValue() != null) {\n+            node.addChildToBack(transform(statementNode.getReturnValue()));\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    Node processString(StringLiteral stringNode) {\n+        Node node = newNode(Token.STRING);\n+        node.setString(stringNode.getValue());\n+        if (stringNode.getQuoteCharacter() == '\\'') {\n+            node.putProp(Encoder.ES6_SINGLE_QUOTE_STRING, 1);\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    Node processSwitchCase(SwitchCase switchCaseNode) {\n+        Node n = newNode(Token.CASE);\n+        n.addChildToBack(transform(switchCaseNode.getExpression()));\n+        for (AstNode stmt : switchCaseNode.getStatements()) {\n+            n.addChildToBack(transform(stmt));\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    Node processSwitchStatement(SwitchStatement statementNode) {\n+        Node n = newNode(Token.SWITCH);\n+        n.addChildToBack(transform(statementNode.getExpression()));\n+        for (SwitchCase caseStmt : statementNode.getCases()) {\n+            n.addChildToBack(transform(caseStmt));\n+        }\n+        return n;\n+    }\n+\n+    @Override\n+    Node processThrowStatement(ThrowStatement statementNode) {\n+        return newNode(Token.THROW, transform(statementNode.getExpression()));\n+    }\n+\n+    @Override\n+    Node processTryStatement(TryStatement statementNode) {\n+        Node n = newNode(Token.TRY);\n+        n.addChildToBack(transformBlock(statementNode.getTryBlock()));\n+\n+        if (statementNode.getCatchClauses() != null) {\n+            for (CatchClause clause : statementNode.getCatchClauses()) {\n+                n.addChildToBack(transform(clause));\n+            }\n+        }\n+\n+        if (statementNode.getFinallyBlock() != null) {\n+            Node finallyBlock = transformBlock(statementNode.getFinallyBlock());\n+            finallyBlock.setType(Token.FINALLY);\n+            n.addChildToBack(finallyBlock);\n+        }\n+\n+        return n;\n+    }\n+\n+    @Override\n+    Node processUnaryExpression(UnaryExpression unaryNode) {\n+        int type;\n+        switch (unaryNode.getType()) {\n+            case Token.BITNOT:\n+                type = Token.BITNOT;\n+                break;\n+            case Token.NEG:\n+                type = Token.NEG;\n+                break;\n+            case Token.POS:\n+                type = Token.POS;\n+                break;\n+            case Token.NOT:\n+                type = Token.NOT;\n+                break;\n+            case Token.DELPROP:\n+                type = Token.DELPROP;\n+                break;\n+            case Token.VOID:\n+                type = Token.VOID;\n+                break;\n+            case Token.TYPEOF:\n+                type = Token.TYPEOF;\n+                break;\n+            default:\n+                throw new RuntimeException(\"Unexpected unary operator\");\n+        }\n+        Node node = newNode(type, transform(unaryNode.getOperand()));\n+        return node;\n+    }\n+\n+    @Override\n+    Node processVariableDeclaration(VariableDeclaration declarationNode) {\n+        Node node = newNode(Token.VAR);\n+        for (VariableInitializer initializer : declarationNode.getVariables()) {\n+            Node left = transform(initializer.getTarget());\n+            Node right = null;\n+            if (initializer.getInitializer() != null) {\n+                right = transform(initializer.getInitializer());\n+            }\n+            Node varNode = new Node(Token.NAME, left);\n+            if (right != null) {\n+                varNode.addChildToBack(right);\n+            } else if (initializer.isConst()) {\n+                errorReporter.warning(\n+                        \"missing variable initialization for const \" + left.getString(),\n+                        sourceName,\n+                        initializer.getLineno(),\n+                        \"\", 0);\n+            }\n+            node.addChildToBack(varNode);\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    Node processWhileLoop(WhileLoop loopNode) {\n+        return newNode(\n+                Token.WHILE,\n+                transform(loopNode.getCondition()),\n+                transformBlock(loopNode.getBody()));\n+    }\n+\n+    @Override\n+    Node processWithStatement(WithStatement statementNode) {\n+        // optimization: add a flag to let downstream passes know that this code\n+        // cannot be statically accessed unless the \"with\" object is known.\n+        errorReporter.error(\n+                \"With statements are not supported\",\n+                sourceName,\n+                statementNode.getLineno(),\n+                \"\", 0);\n+        Node obj = transform(statementNode.getExpression());\n+        Node body = transform(statementNode.getStatement());\n+        Node n = new Node(Token.WITH, ob\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}