{
    "patch": "        // next stages\n        for (int k = 1; k < stages; ++k) {\n            for (int j = 0; j < y0.length; ++j) {\n                double sum = a[k - 1][0] * yDotK[0][j];\n                for (int l = 1; l < k; ++l) {\n                    sum += a[k - 1][l] * yDotK[l][j];\n                }\n                yTmp[j] = y[j] + stepSize * sum;\n            }\n\n            // Compute derivatives while checking if first stage is enough\n            final double fourEPS = 4 * eps;\n            boolean tryAgain;\n            do {\n              tryAgain = false;\n              computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n              for (int j = 0; j < y0.length; ++j) {\n                final double ratio = (scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[j])) /\n                    (fourEPS + FastMath.abs(yTmp[j] - y[j]));\n                if (ratio > 1.0) {\n                  // reject the current set of derivatives\n                  if (tryAgain) {\n                    // also the last iteration had a reject, we cannot reduce tolerance anymore\n                    throw new MathIllegalStateException(LocalizedFormats.TOO_LARGE_EULER_STEPSIZE_ADJUSTMENT_AFTER_N_ITERATIONS, maxIterations);\n                  }\n\n                  // reduce tolerance and try again\n                  scalAbsoluteTolerance *= 0.25;\n                  scalRelativeTolerance *= 0.25;\n                  tryAgain = true;\n                  break;\n                }\n              }\n            } while (tryAgain);\n        }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..5be25ee6d 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,41 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+            for (int j = 0; j < y0.length; ++j) {\n+                double sum = a[k - 1][0] * yDotK[0][j];\n+                for (int l = 1; l < k; ++l) {\n+                    sum += a[k - 1][l] * yDotK[l][j];\n+                }\n+                yTmp[j] = y[j] + stepSize * sum;\n+            }\n+\n+            // Compute derivatives while checking if first stage is enough\n+            final double fourEPS = 4 * eps;\n+            boolean tryAgain;\n+            do {\n+              tryAgain = false;\n+              computeDerivatives(stepStart + c[k - 1] * stepSize, yTmp, yDotK[k]);\n+              for (int j = 0; j < y0.length; ++j) {\n+                final double ratio = (scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[j])) /\n+                    (fourEPS + FastMath.abs(yTmp[j] - y[j]));\n+                if (ratio > 1.0) {\n+                  // reject the current set of derivatives\n+                  if (tryAgain) {\n+                    // also the last iteration had a reject, we cannot reduce tolerance anymore\n+                    throw new MathIllegalStateException(LocalizedFormats.TOO_LARGE_EULER_STEPSIZE_ADJUSTMENT_AFTER_N_ITERATIONS, maxIterations);\n+                  }\n+\n+                  // reduce tolerance and try again\n+                  scalAbsoluteTolerance *= 0.25;\n+                  scalRelativeTolerance *= 0.25;\n+                  tryAgain = true;\n+                  break;\n+                }\n+              }\n+            } while (tryAgain);\n+        }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}