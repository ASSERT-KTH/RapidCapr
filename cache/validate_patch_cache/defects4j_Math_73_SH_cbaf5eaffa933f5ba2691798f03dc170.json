{
    "patch": "// check if the interval brackets the root\nif (yMin * yMax >= 0) {\n    throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n}\n\ndouble x = initial;\ndouble fx = yInitial;\ndouble lastSelected = Double.NaN;\ndouble nextSelected = Double.NaN;\n\ndouble delta = 0;\ndouble oldDelta = 0;\ndouble left = Double.NaN;\ndouble right = Double.NaN;\n\n// Brent algorithm\nfor (int iter = 0; iter < maximalIterationCount; ++iter) {\n    if (Math.abs(yMax) < Math.abs(yMin)) {\n        // swap (min, yMin) and (max, yMax) such that yMin is the largest\n        final double tmp1 = min; min = max; max = tmp1;\n        final double tmp2 = yMin; yMin = yMax; yMax = tmp2;\n    }\n    if (Math.abs(delta) <= absoluteAccuracy ||\n            Math.abs(fx) <= functionValueAccuracy) {\n        setResult(x, iter);\n        return result;\n    }\n    if (iter > 0 &&\n            (lastSelected == left ||\n                    lastSelected == right ||\n                    lastSelected == x)) {\n        // The previous step made no progress.\n        // Try a binary search as a safety net.\n        delta = (max - min) / 2d;\n        x = min + delta;\n        fx = f.value(x);\n        if (Math.abs(delta) <= absoluteAccuracy ||\n                Math.abs(fx) <= functionValueAccuracy) {\n            setResult(x, iter);\n            return result;\n        }\n    } else {\n        lastSelected = x;\n        if (Math.abs(oldDelta) < functionValueAccuracy &&\n                Math.abs(fx) > Math.abs(fy)) {\n            // interpolate using only f(x) and f(w)\n            final double delta2 = 2d * (x < w ? oldDelta : -oldDelta);\n            final double tmp3 = fx / fy;\n            left = x;\n            right = w;\n            x = w;\n            fx = fy;\n            final double fw = f.value(w + delta2);\n            fy = fw;\n        } else {\n            // interpolate using f(x), f(y), and f(w)\n            final double delta2 = 2d * (x < w ? oldDelta : -oldDelta);\n            final double tmp4 = fx / fy;\n            final double tmp5 = fx / fw;\n            final double tmp6 = fy / fw;\n            final double p = tmp5 * (fy - fw) - tmp6 * (fx - fw);\n            final double q = (tmp5 - tmp6) * (fx - fy);\n            final double r = p / q;\n            delta = oldDelta;\n            oldDelta = delta * r;\n            w = x;\n            fx = fy;\n            if (Math.abs(oldDelta) > absoluteAccuracy) {\n                x += oldDelta;\n            } else if (delta > 0) {\n                x += absoluteAccuracy;\n            } else {\n                x -= absoluteAccuracy;\n            }\n            fy = f.value(x);\n        }\n    }\n\n    // Maintain the bracket [min, max].\n    if ((fx > 0 && fy > 0) || (fx <= 0 && fy <= 0)) {\n        if (fy != 0d) {\n            left = x;\n            yMin = fy;\n        } else {\n            setResult(x, iter);\n            return result;\n        }\n    } else {\n        right = x;\n        yMax = fy;\n    }\n}\n\nthrow new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..132ee364a 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,100 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+// check if the interval brackets the root\n+if (yMin * yMax >= 0) {\n+    throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n+}\n+\n+double x = initial;\n+double fx = yInitial;\n+double lastSelected = Double.NaN;\n+double nextSelected = Double.NaN;\n+\n+double delta = 0;\n+double oldDelta = 0;\n+double left = Double.NaN;\n+double right = Double.NaN;\n+\n+// Brent algorithm\n+for (int iter = 0; iter < maximalIterationCount; ++iter) {\n+    if (Math.abs(yMax) < Math.abs(yMin)) {\n+        // swap (min, yMin) and (max, yMax) such that yMin is the largest\n+        final double tmp1 = min; min = max; max = tmp1;\n+        final double tmp2 = yMin; yMin = yMax; yMax = tmp2;\n+    }\n+    if (Math.abs(delta) <= absoluteAccuracy ||\n+            Math.abs(fx) <= functionValueAccuracy) {\n+        setResult(x, iter);\n+        return result;\n+    }\n+    if (iter > 0 &&\n+            (lastSelected == left ||\n+                    lastSelected == right ||\n+                    lastSelected == x)) {\n+        // The previous step made no progress.\n+        // Try a binary search as a safety net.\n+        delta = (max - min) / 2d;\n+        x = min + delta;\n+        fx = f.value(x);\n+        if (Math.abs(delta) <= absoluteAccuracy ||\n+                Math.abs(fx) <= functionValueAccuracy) {\n+            setResult(x, iter);\n+            return result;\n+        }\n+    } else {\n+        lastSelected = x;\n+        if (Math.abs(oldDelta) < functionValueAccuracy &&\n+                Math.abs(fx) > Math.abs(fy)) {\n+            // interpolate using only f(x) and f(w)\n+            final double delta2 = 2d * (x < w ? oldDelta : -oldDelta);\n+            final double tmp3 = fx / fy;\n+            left = x;\n+            right = w;\n+            x = w;\n+            fx = fy;\n+            final double fw = f.value(w + delta2);\n+            fy = fw;\n+        } else {\n+            // interpolate using f(x), f(y), and f(w)\n+            final double delta2 = 2d * (x < w ? oldDelta : -oldDelta);\n+            final double tmp4 = fx / fy;\n+            final double tmp5 = fx / fw;\n+            final double tmp6 = fy / fw;\n+            final double p = tmp5 * (fy - fw) - tmp6 * (fx - fw);\n+            final double q = (tmp5 - tmp6) * (fx - fy);\n+            final double r = p / q;\n+            delta = oldDelta;\n+            oldDelta = delta * r;\n+            w = x;\n+            fx = fy;\n+            if (Math.abs(oldDelta) > absoluteAccuracy) {\n+                x += oldDelta;\n+            } else if (delta > 0) {\n+                x += absoluteAccuracy;\n+            } else {\n+                x -= absoluteAccuracy;\n+            }\n+            fy = f.value(x);\n+        }\n+    }\n+\n+    // Maintain the bracket [min, max].\n+    if ((fx > 0 && fy > 0) || (fx <= 0 && fy <= 0)) {\n+        if (fy != 0d) {\n+            left = x;\n+            yMin = fy;\n+        } else {\n+            setResult(x, iter);\n+            return result;\n+        }\n+    } else {\n+        right = x;\n+        yMax = fy;\n+    }\n+}\n+\n+throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}