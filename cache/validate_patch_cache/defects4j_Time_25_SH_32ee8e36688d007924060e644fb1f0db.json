{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    if (offsetLocal > offsetAdjusted) {\n        long prevLocal = previousTransition(instantAdjusted);\n        long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n        if (prevLocal != prevAdjusted) {\n            return offsetLocal;\n        } else if (offsetLocal > 0 && offsetAdjusted == 0 && instantAdjusted >= prevLocal - DateTimeConstants.MILLIS_PER_HOUR) {\n            // Between the current instant (instantLocal - offsetLocal) and its transition instant (prevLocal),\n            // the UTC offset change from offsetLocal to zero.\n            // If the adjusted instant (instantLocal - offsetAdjusted) is within this interval,\n            // the correct offset is still offsetLocal, because in this interval the timezone observes winter time which\n            // takes offsetLocal.\n            return offsetLocal;\n        }\n    } else {\n        final long nextLocal = nextTransition(instantAdjusted);\n        final int offsetNext = getOffset(nextLocal);\n        if (offsetLocal != offsetNext && offsetAdjusted == offsetNext) {\n            return offsetLocal;\n        } else if (offsetLocal == 0 && offsetAdjusted < 0 && instantLocal >= nextLocal - DateTimeConstants.MILLIS_PER_HOUR) {\n            // Between the current instant (instantLocal) and its transition instant (nextLocal),\n            // the UTC offset change from offsetAdjusted to zero.\n            // If the next transition after the adjusted instant (instantAdjusted) is the same as the current transition (nextLocal),\n            // the correct offset is still zero, because in this interval the timezone observes summer time which takes zero offset.\n            final long nextLocal2 = nextTransition(instantLocal);\n            if (nextLocal == nextLocal2) {\n                return offsetLocal;\n            }\n        } else if (offsetLocal == 0 && offsetAdjusted < 0 && instantLocal < nextLocal - DateTimeConstants.MILLIS_PER_HOUR) {\n            // Between the current instant and the nextTransition after the current instant, the offset is zero.\n            // In this case adjust the instant using the offsetLocal.\n            final int prevOffset = getOffset(previousTransition(instantLocal));\n            if (prevOffset != 0) {\n                final long prevTransition = previousTransition(instantLocal - prevOffset);\n                final int prevLocalOffset = getOffset(prevTransition);\n                if (prevLocalOffset < 0) {\n                    // If the previous transition is for summer time, then move one hour forward to get the real previous transition\n                    prevTransition = previousTransition(prevTransition + DateTimeConstants.MILLIS_PER_HOUR);\n                    prevLocalOffset = getOffset(prevTransition);\n                }\n                if (prevLocalOffset != 0) {\n                    // The previous transition must be for winter time\n                    DateTimeZone newTz = fixOffsetForSingleWindow(this, prevLocalOffset);\n                    long newInstant = newTz.nextTransition(instantLocal - prevOffset - prevLocalOffset);\n                    int newOffset = newTz.getOffset(newInstant);\n                    if (newOffset == prevLocalOffset) {\n                        return offsetLocal;\n                    }\n                }\n            }\n            return offsetAdjusted;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..6681992e 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,60 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    if (offsetLocal > offsetAdjusted) {\n+        long prevLocal = previousTransition(instantAdjusted);\n+        long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n+        if (prevLocal != prevAdjusted) {\n+            return offsetLocal;\n+        } else if (offsetLocal > 0 && offsetAdjusted == 0 && instantAdjusted >= prevLocal - DateTimeConstants.MILLIS_PER_HOUR) {\n+            // Between the current instant (instantLocal - offsetLocal) and its transition instant (prevLocal),\n+            // the UTC offset change from offsetLocal to zero.\n+            // If the adjusted instant (instantLocal - offsetAdjusted) is within this interval,\n+            // the correct offset is still offsetLocal, because in this interval the timezone observes winter time which\n+            // takes offsetLocal.\n+            return offsetLocal;\n+        }\n+    } else {\n+        final long nextLocal = nextTransition(instantAdjusted);\n+        final int offsetNext = getOffset(nextLocal);\n+        if (offsetLocal != offsetNext && offsetAdjusted == offsetNext) {\n+            return offsetLocal;\n+        } else if (offsetLocal == 0 && offsetAdjusted < 0 && instantLocal >= nextLocal - DateTimeConstants.MILLIS_PER_HOUR) {\n+            // Between the current instant (instantLocal) and its transition instant (nextLocal),\n+            // the UTC offset change from offsetAdjusted to zero.\n+            // If the next transition after the adjusted instant (instantAdjusted) is the same as the current transition (nextLocal),\n+            // the correct offset is still zero, because in this interval the timezone observes summer time which takes zero offset.\n+            final long nextLocal2 = nextTransition(instantLocal);\n+            if (nextLocal == nextLocal2) {\n+                return offsetLocal;\n+            }\n+        } else if (offsetLocal == 0 && offsetAdjusted < 0 && instantLocal < nextLocal - DateTimeConstants.MILLIS_PER_HOUR) {\n+            // Between the current instant and the nextTransition after the current instant, the offset is zero.\n+            // In this case adjust the instant using the offsetLocal.\n+            final int prevOffset = getOffset(previousTransition(instantLocal));\n+            if (prevOffset != 0) {\n+                final long prevTransition = previousTransition(instantLocal - prevOffset);\n+                final int prevLocalOffset = getOffset(prevTransition);\n+                if (prevLocalOffset < 0) {\n+                    // If the previous transition is for summer time, then move one hour forward to get the real previous transition\n+                    prevTransition = previousTransition(prevTransition + DateTimeConstants.MILLIS_PER_HOUR);\n+                    prevLocalOffset = getOffset(prevTransition);\n+                }\n+                if (prevLocalOffset != 0) {\n+                    // The previous transition must be for winter time\n+                    DateTimeZone newTz = fixOffsetForSingleWindow(this, prevLocalOffset);\n+                    long newInstant = newTz.nextTransition(instantLocal - prevOffset - prevLocalOffset);\n+                    int newOffset = newTz.getOffset(newInstant);\n+                    if (newOffset == prevLocalOffset) {\n+                        return offsetLocal;\n+                    }\n+                }\n+            }\n+            return offsetAdjusted;\n+        }\n+    }\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: cannot assign a value to final variable prevTransition",
    "test_result": "ERROR"
}