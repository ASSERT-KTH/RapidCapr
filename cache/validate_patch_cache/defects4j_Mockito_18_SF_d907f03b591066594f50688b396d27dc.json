{
    "patch": "import java.util.*;\n\npublic class MyMap<K, V> extends HashMap<K, V> {\n    \n    private final Map<Class<?>, Object> returnValues = new HashMap<>();\n    \n    public void setReturnValueFor(Class<?> clazz, Object value) {\n        returnValues.put(clazz, value);\n    }\n    \n    public Object returnValueFor(Class<?> clazz) {\n        return returnValues.get(clazz);\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Set<Map.Entry<K, V>> entrySet() {\n        if (returnValueFor(Set.class) != null) {\n            return (Set<Map.Entry<K, V>>) returnValueFor(Set.class);\n        }\n        return super.entrySet();\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public Collection<V> values() {\n        if (returnValueFor(Collection.class) != null) {\n            return (Collection<V>) returnValueFor(Collection.class);\n        }\n        return super.values();\n    }\n    \n    @SuppressWarnings(\"unchecked\")\n    @Override\n    public V put(K key, V value) {\n        if (returnValueFor(V.class) != null) {\n            return (V) returnValueFor(V.class);\n        }\n        return super.put(key, value);\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\nindex 06697e527..918d86bce 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n@@ -84,7 +84,47 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n             //new instances are used instead of Collections.emptyList(), etc.\n             //to avoid UnsupportedOperationException if code under test modifies returned collection\n-        } else if (type == Collection.class) {\n+import java.util.*;\n+\n+public class MyMap<K, V> extends HashMap<K, V> {\n+    \n+    private final Map<Class<?>, Object> returnValues = new HashMap<>();\n+    \n+    public void setReturnValueFor(Class<?> clazz, Object value) {\n+        returnValues.put(clazz, value);\n+    }\n+    \n+    public Object returnValueFor(Class<?> clazz) {\n+        return returnValues.get(clazz);\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Set<Map.Entry<K, V>> entrySet() {\n+        if (returnValueFor(Set.class) != null) {\n+            return (Set<Map.Entry<K, V>>) returnValueFor(Set.class);\n+        }\n+        return super.entrySet();\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public Collection<V> values() {\n+        if (returnValueFor(Collection.class) != null) {\n+            return (Collection<V>) returnValueFor(Collection.class);\n+        }\n+        return super.values();\n+    }\n+    \n+    @SuppressWarnings(\"unchecked\")\n+    @Override\n+    public V put(K key, V value) {\n+        if (returnValueFor(V.class) != null) {\n+            return (V) returnValueFor(V.class);\n+        }\n+        return super.put(key, value);\n+    }\n+}\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {\n             return new HashSet<Object>();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}