{
    "patch": "        // Evaluate the function at endpoints\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n\n        // Handle special case when function value is 0 at endpoints\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        // Check whether initial guess is a root\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // Check whether initial guess is out of bounds\n        if (initial < min || initial > max) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    OUT_OF_BOUNDS_MESSAGE, initial, min, max);\n        }\n\n        // Locate the bracketing interval using bisection method\n        double a = min;\n        double b = max;\n        double c = initial;\n        double fa = yMin;\n        double fb = yMax;\n        double fc = yInitial;\n\n        for (int i = 0; i < maximalIterationCount; ++i) {\n            // Check whether function value at midpoint is 0\n            double m = 0.5 * (a + b);\n            double fm = f.value(m);\n            if (Math.abs(fm) <= functionValueAccuracy) {\n                setResult(m, i + 1);\n                return result;\n            }\n\n            // Update brackets\n            if (fc * fm < 0) {\n                a = c;\n                b = m;\n                fa = fc;\n                fb = fm;\n            } else {\n                if (fa * fm < 0) {\n                    b = m;\n                    fb = fm;\n                } else {\n                    a = m;\n                    fa = fm;\n                }\n            }\n\n            // Check whether max iteration count has been exceeded\n            if (i == maximalIterationCount - 1) {\n                throw new MaxIterationsExceededException(maximalIterationCount);\n            }\n\n            // Update c, the last guess, with inverse quadratic interpolation\n            double tmp = fb / fa;\n            double p = tmp * (fc - fa);\n            double q = (fb - fa) * (fc - fa);\n            double r = q - p;\n            if (r != 0.0) {\n                tmp = c;\n                c = b - ((b - a) * q) / (2 * r);\n                if (Math.abs(c - tmp) <= absoluteAccuracy) {\n                    setResult(c, i + 1);\n                    return result;\n                }\n            } else {\n                // Update c with bisection if no improvement in guess\n                c = 0.5 * (a + b);\n            }\n\n            // Evaluate function at c and update fc\n            fc = f.value(c);\n        }\n\n        // Should never get here\n        throw new RuntimeException(\"Brent solver failed to converge: \" + \n            \"function is not bracketed or suboptimal function tolerance set\");",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..cd6d2f677 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,53 +95,95 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+        // Evaluate the function at endpoints\n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+        // Handle special case when function value is 0 at endpoints\n+        if (Math.abs(yMin) <= functionValueAccuracy) {\n+            setResult(min, 0);\n+            return result;\n+        }\n+        if (Math.abs(yMax) <= functionValueAccuracy) {\n+            setResult(max, 0);\n+            return result;\n+        }\n \n-        // return the initial guess if it is good enough\n+        // Check whether initial guess is a root\n         double yInitial = f.value(initial);\n         if (Math.abs(yInitial) <= functionValueAccuracy) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n+        // Check whether initial guess is out of bounds\n+        if (initial < min || initial > max) {\n+            throw MathRuntimeException.createIllegalArgumentException(\n+                    OUT_OF_BOUNDS_MESSAGE, initial, min, max);\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        // Locate the bracketing interval using bisection method\n+        double a = min;\n+        double b = max;\n+        double c = initial;\n+        double fa = yMin;\n+        double fb = yMax;\n+        double fc = yInitial;\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        for (int i = 0; i < maximalIterationCount; ++i) {\n+            // Check whether function value at midpoint is 0\n+            double m = 0.5 * (a + b);\n+            double fm = f.value(m);\n+            if (Math.abs(fm) <= functionValueAccuracy) {\n+                setResult(m, i + 1);\n+                return result;\n+            }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+            // Update brackets\n+            if (fc * fm < 0) {\n+                a = c;\n+                b = m;\n+                fa = fc;\n+                fb = fm;\n+            } else {\n+                if (fa * fm < 0) {\n+                    b = m;\n+                    fb = fm;\n+                } else {\n+                    a = m;\n+                    fa = fm;\n+                }\n+            }\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n-        }\n+            // Check whether max iteration count has been exceeded\n+            if (i == maximalIterationCount - 1) {\n+                throw new MaxIterationsExceededException(maximalIterationCount);\n+            }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+            // Update c, the last guess, with inverse quadratic interpolation\n+            double tmp = fb / fa;\n+            double p = tmp * (fc - fa);\n+            double q = (fb - fa) * (fc - fa);\n+            double r = q - p;\n+            if (r != 0.0) {\n+                tmp = c;\n+                c = b - ((b - a) * q) / (2 * r);\n+                if (Math.abs(c - tmp) <= absoluteAccuracy) {\n+                    setResult(c, i + 1);\n+                    return result;\n+                }\n+            } else {\n+                // Update c with bisection if no improvement in guess\n+                c = 0.5 * (a + b);\n+            }\n \n-    }\n+            // Evaluate function at c and update fc\n+            fc = f.value(c);\n+        }\n+\n+        // Should never get here\n+        throw new RuntimeException(\"Brent solver failed to converge: \" + \n+            \"function is not bracketed or suboptimal function tolerance set\");\n \n     /**\n      * Find a zero in the given interval.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}