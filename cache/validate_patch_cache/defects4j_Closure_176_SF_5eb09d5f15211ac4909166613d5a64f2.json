{
    "patch": "private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor = obj.isThis() &&\n        getJSType(syntacticScope.getRootNode()).isConstructor();\n\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        // In general, we don't want to define a property on a struct object,\n        // b/c TypeCheck will later check for improper property creation on\n        // structs. There are two exceptions.\n        // 1) If it's a property created inside the constructor, on the newly\n        //    created instance, allow it.\n        // 2) If it's a prototype property, allow it. For example:\n        //    Foo.prototype.bar = baz;\n        //    where Foo.prototype is a struct and the assignment happens at the\n        //    top level and the constructor Foo is defined in the same file.\n        boolean staticPropCreation = false;\n        Node maybeAssignStm = getprop.getParent().getParent();\n        if (syntacticScope.isGlobal() &&\n            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n          String propCreationFilename = maybeAssignStm.getSourceFileName();\n          Node ctor = objectType.getOwnerFunction().getSource();\n          if (ctor != null &&\n              ctor.getSourceFileName().equals(propCreationFilename)) {\n            staticPropCreation = true;\n          }\n        }\n        if (!propCreationInConstructor && !staticPropCreation) {\n          return; // Early return to avoid creating the property below.\n        }\n      }\n    }\n\n    Node parent = getprop.getParent();\n    Node grandparent = parent.getParent();\n    int grampsType = grandparent.getType();\n    // We determine what sort of slot to put on the object based on the\n    // parent node, unless the parent is an ASSIGN or an EXPR result.\n    // EXPR results happen when you have an expression statement in\n    // your code that doesn't actually do anything.\n    // We just put on OBJECT, because that's what most EXPR results are.\n    if (grampsType == Token.ASSIGN) {\n      Node greatgramps = grandparent.getParent();\n      switch (greatgramps.getType()) {\n        case Token.VAR:\n        case Token.LET:\n        case Token.CONST:\n          // So a destructuring pattern like\n          //   var {x} = {};\n          // will have the right type on x in the global scope.\n          scope.declare(greatgramps.getFirstChild().getFirstChild(),\n              syntacticScope, rightType, null);\n          break;\n        case Token.FUNCTION:\n          FunctionType methodType = ObjectType.fromFunctionNode(\n              greatgramps, syntacticScope);\n          String methodName = parent.getSecondChild().getString();\n          if (!methodType.isQmarkFunction()) {\n            // If the function does not have a declared return type already,\n            // we can infer one from the right hand side of the assignment.\n            JSType returnType = methodType.getReturnType();\n            if (returnType == null) {\n              returnType = rightType;\n            } else if (!rightType.isUnknownType()) {\n              returnType = returnType.getLeastSupertype(rightType);\n            }\n            methodType = methodType.withReturnType(returnType);\n          }\n          objectType.defineDeclaredProperty(propName, rightType, getprop);\n          ObjectType elementsType = methodType.getElementsType();\n          if (elementsType != null) {\n            elementsType.defineDeclaredProperty(propName, rightType, getprop);\n          } else {\n            warnInvalidationOnType(methodType);\n          }\n          break;\n        default:\n          // For object literals and possibly other cases.\n          defineSlot(obj, scope, syntacticScope, propName,\n              rightType, getprop, true);\n          break;\n      }\n    } else if (grampsType == Token.OBJECTLIT) {\n      // If the object literal isn't in a var statement or an assign,\n      // it's just being used as a set of instructions for driving\n      // upcasting/inferring as needed. Any property assignments will\n      // be dealt with when processing the entire object literal\n      // assignment.\n      if (grandparent.getParent() != null &&\n          grandparent.getParent().getType() == Token.EXPR_RESULT) {\n        defineSlot(obj, scope, syntacticScope, propName,\n            rightType, getprop, true);\n      }\n    } else if (grampsType == Token.CLASS_MEMBERS) {\n      Node constructor = NodeUtil.getClassMembersParent(grandparent);\n      if (constructor == null) {\n        defineSlot(obj, scope, syntacticScope, propName,\n            rightType, getprop, true);\n      } else {\n        FunctionType methodType = objectType.getConstructor();\n        objectType.defineDeclaredProperty(propName, rightType, getprop);\n        ObjectType elementsType = methodType.getElementsType();\n        if (elementsType != null) {\n          elementsType.defineDeclaredProperty(propName, rightType, getprop);\n        } else {\n          warnInvalidationOnType(methodType);\n        }\n      }\n    } else {\n      defineSlot(obj, scope, syntacticScope, propName,\n          rightType, getprop, true);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..4429a2d2 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,73 +521,7 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n-\n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n-\n-\n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n-\n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n-        }\n-        break;\n-      case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n-        }\n-\n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n-        break;\n-    }\n-  }\n-\n-  /**\n-   * Defines a property if the property has not been defined yet.\n-   */\n-  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n+private void ensurePropertyDefined(Node getprop, JSType rightType) {\n     String propName = getprop.getLastChild().getString();\n     Node obj = getprop.getFirstChild();\n     JSType nodeType = getJSType(obj);\n@@ -624,6 +558,86 @@ class TypeInference\n           return; // Early return to avoid creating the property below.\n         }\n       }\n+    }\n+\n+    Node parent = getprop.getParent();\n+    Node grandparent = parent.getParent();\n+    int grampsType = grandparent.getType();\n+    // We determine what sort of slot to put on the object based on the\n+    // parent node, unless the parent is an ASSIGN or an EXPR result.\n+    // EXPR results happen when you have an expression statement in\n+    // your code that doesn't actually do anything.\n+    // We just put on OBJECT, because that's what most EXPR results are.\n+    if (grampsType == Token.ASSIGN) {\n+      Node greatgramps = grandparent.getParent();\n+      switch (greatgramps.getType()) {\n+        case Token.VAR:\n+        case Token.LET:\n+        case Token.CONST:\n+          // So a destructuring pattern like\n+          //   var {x} = {};\n+          // will have the right type on x in the global scope.\n+          scope.declare(greatgramps.getFirstChild().getFirstChild(),\n+              syntacticScope, rightType, null);\n+          break;\n+        case Token.FUNCTION:\n+          FunctionType methodType = ObjectType.fromFunctionNode(\n+              greatgramps, syntacticScope);\n+          String methodName = parent.getSecondChild().getString();\n+          if (!methodType.isQmarkFunction()) {\n+            // If the function does not have a declared return type already,\n+            // we can infer one from the right hand side of the assignment.\n+            JSType returnType = methodType.getReturnType();\n+            if (returnType == null) {\n+              returnType = rightType;\n+            } else if (!rightType.isUnknownType()) {\n+              returnType = returnType.getLeastSupertype(rightType);\n+            }\n+            methodType = methodType.withReturnType(returnType);\n+          }\n+          objectType.defineDeclaredProperty(propName, rightType, getprop);\n+          ObjectType elementsType = methodType.getElementsType();\n+          if (elementsType != null) {\n+            elementsType.defineDeclaredProperty(propName, rightType, getprop);\n+          } else {\n+            warnInvalidationOnType(methodType);\n+          }\n+          break;\n+        default:\n+          // For object literals and possibly other cases.\n+          defineSlot(obj, scope, syntacticScope, propName,\n+              rightType, getprop, true);\n+          break;\n+      }\n+    } else if (grampsType == Token.OBJECTLIT) {\n+      // If the object literal isn't in a var statement or an assign,\n+      // it's just being used as a set of instructions for driving\n+      // upcasting/inferring as needed. Any property assignments will\n+      // be dealt with when processing the entire object literal\n+      // assignment.\n+      if (grandparent.getParent() != null &&\n+          grandparent.getParent().getType() == Token.EXPR_RESULT) {\n+        defineSlot(obj, scope, syntacticScope, propName,\n+            rightType, getprop, true);\n+      }\n+    } else if (grampsType == Token.CLASS_MEMBERS) {\n+      Node constructor = NodeUtil.getClassMembersParent(grandparent);\n+      if (constructor == null) {\n+        defineSlot(obj, scope, syntacticScope, propName,\n+            rightType, getprop, true);\n+      } else {\n+        FunctionType methodType = objectType.getConstructor();\n+        objectType.defineDeclaredProperty(propName, rightType, getprop);\n+        ObjectType elementsType = methodType.getElementsType();\n+        if (elementsType != null) {\n+          elementsType.defineDeclaredProperty(propName, rightType, getprop);\n+        } else {\n+          warnInvalidationOnType(methodType);\n+        }\n+      }\n+    } else {\n+      defineSlot(obj, scope, syntacticScope, propName,\n+          rightType, getprop, true);\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}