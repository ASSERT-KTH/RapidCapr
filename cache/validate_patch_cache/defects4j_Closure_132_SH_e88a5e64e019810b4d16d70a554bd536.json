{
    "patch": "              !mayEffectMutableState(lhs)) {\n        // if(x)var y=1;else y=2  ->  var y=x?1:2\n        Node var = getBlockVar(thenBranch);\n        Node elseExpr = getBlockExpression(elseBranch).removeFirstChild();\n        Node hookNode = IR.hook(cond, getBlockExpression(var), elseExpr)\n                            .srcref(n);\n        Node assign = new Node(Token.ASSIGN,\n                              var.removeFirstChild(),\n                              hookNode)\n                          .srcref(thenBranch);\n        Node varParent = var.getParent();\n        Node newBlock;\n        if (varParent == n) {\n          newBlock = NodeUtil.newBlock(IR.var(assign));\n          n.replaceChild(var, newBlock);\n        } else {\n          newBlock = NodeUtil.newBlock(var, IR.var(assign));\n          thenBranch.replaceChild(var, newBlock);\n        }\n        reportCodeChange();\n        return newBlock;\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..b70613dc 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -780,6 +780,27 @@ class PeepholeSubstituteAlternateSyntax\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n               !mayEffectMutableState(lhs)) {\n+        // if(x)var y=1;else y=2  ->  var y=x?1:2\n+        Node var = getBlockVar(thenBranch);\n+        Node elseExpr = getBlockExpression(elseBranch).removeFirstChild();\n+        Node hookNode = IR.hook(cond, getBlockExpression(var), elseExpr)\n+                            .srcref(n);\n+        Node assign = new Node(Token.ASSIGN,\n+                              var.removeFirstChild(),\n+                              hookNode)\n+                          .srcref(thenBranch);\n+        Node varParent = var.getParent();\n+        Node newBlock;\n+        if (varParent == n) {\n+          newBlock = NodeUtil.newBlock(IR.var(assign));\n+          n.replaceChild(var, newBlock);\n+        } else {\n+          newBlock = NodeUtil.newBlock(var, IR.var(assign));\n+          thenBranch.replaceChild(var, newBlock);\n+        }\n+        reportCodeChange();\n+        return newBlock;\n+      }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}