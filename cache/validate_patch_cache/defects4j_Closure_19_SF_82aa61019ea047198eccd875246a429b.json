{
    "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        if (qualifiedName == null) { // Check for null instead of Preconditions\n            qualifiedName = node.getFirstChild().getString() + \".\" + node.getLastChild().getString();\n        }\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..938a2c31 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,7 +154,7 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n     switch (node.getType()) {\n       case Token.NAME:\n         scope.inferSlotType(node.getString(), type);\n@@ -162,15 +162,15 @@ public abstract class ChainableReverseAbstractInterpreter\n \n       case Token.GETPROP:\n         String qualifiedName = node.getQualifiedName();\n-        Preconditions.checkNotNull(qualifiedName);\n+        if (qualifiedName == null) { // Check for null instead of Preconditions\n+            qualifiedName = node.getFirstChild().getString() + \".\" + node.getLastChild().getString();\n+        }\n \n         JSType origType = node.getJSType();\n         origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n-        // \"this\" references aren't currently modeled in the CFG.\n-\n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n             node.toStringTree());",
    "result_reason": "java.lang.IllegalArgumentException: Node cannot be refined.",
    "test_result": "FAIL"
}