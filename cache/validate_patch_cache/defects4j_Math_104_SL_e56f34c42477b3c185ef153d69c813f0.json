{
    "patch": "import org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Precision;\n\npublic class Gamma {\n    private static final double DEFAULT_EPSILON = 10e-15;\n\n    private static final double LANCZOS_G = 607.0 / 128.0;\n\n    private static final double[] LANCZOS = {\n            0.99999999999999709182,\n            57.156235665862923517,\n            -59.597960355475491248,\n            14.136097974741747174,\n            -0.49191381609762019978,\n            .33994649984811888699e-4,\n            .46523628927048575665e-4,\n            -.98374475304879564677e-4,\n            .15808870322491248884e-3,\n            -.21026444172410488319e-3,\n            .21743961811521264320e-3,\n            -.16431810653676389022e-3,\n            .84418223983852743293e-4,\n            -.26190838401581408670e-4,\n            .36899182659531622704e-5,\n    };\n\n    private Gamma() {\n    }\n\n    /**\n     * Returns the regularized gamma function P(a, x).\n     *\n     * @param a the a parameter (a &gt; 0)\n     * @param x the x parameter (x &ge; 0)\n     * @return the regularized gamma function P(a, x)\n     * @throws IllegalArgumentException if {@code a <= 0} or {@code x < 0}\n     */\n    public static double regularizedGammaP(double a, double x) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive\");\n        }\n\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x must be non-negative\");\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        if (Double.isInfinite(a)) {\n            return Double.NaN;\n        }\n\n        if (a > 1000) {\n            return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n        }\n\n        double ret;\n        boolean negIb = false;\n        double temp = a + LANCZOS_G - 0.5;\n        if (x < temp) {\n            negIb = true;\n            ret = lanczos(a);\n            if (Precision.equals(ret, 0, 1)) {\n                return ret;\n            }\n            ret *= MathUtils.gamma(a) * Math.pow(x, a) / continuedFractionA(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n        } else {\n            ret = 1 - gammaQ(a, x);\n        }\n\n        double l = 1;\n        if (x >= 1 + temp) {\n            double logX = Math.log(x);\n            double a0 = 1 / x;\n            double b0 = 0;\n            double a1 = 1;\n            double b1 = 1;\n            double fac = 1;\n            for (int i = 1; i < 100 && Math.abs((fac * b1) / (fac * b0)) > DEFAULT_EPSILON; ++i) {\n                double an = i * (a - i);\n                double a2 = (a1 + a0 * an) * logX - i;\n                double b2 = (b1 + b0 * an);\n                a0 = a1;\n                a1 = a2;\n                b0 = b1;\n                b1 = b2;\n                double t = a1 / b1;\n                fac = t;\n                l *= t;\n            }\n            ret *= l;\n        }\n\n        if (negIb) {\n            ret = 1 - ret;\n        }\n\n        return ret;\n    }\n\n    /**\n     * Returns the regularized gamma function P(a, x).\n     *\n     * @param a        the a parameter (a &gt; 0)\n     * @param x        the x parameter (x &ge; 0)\n     * @param epsilon  the accuracy goal\n     * @param maxIter  the maximum number of iterations to produce the result\n     * @return the regularized gamma function P(a, x)\n     * @throws IllegalArgumentException if {@code a <= 0} or {@code x < 0}\n     */\n    public static double regularizedGammaP(double a, double x, double epsilon, int maxIter) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive\");\n        }\n\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x must be non-negative\");\n        }\n\n        if (x == 0) {\n            return 0;\n        }\n\n        double p = LanczosApproximation.value(a);\n        double q = continuedFractionB(a, x, epsilon, maxIter);\n        return p / (p + q * Math.pow(x, a));\n    }\n\n    /**\n     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n     *\n     * @param a the a parameter (a &gt; 0)\n     * @param x the x parameter (x &ge; 0)\n     * @return the regularized gamma function Q(a, x) = 1 - P(a, x)\n     * @throws IllegalArgumentException if {@code a <= 0} or {@code x < 0}\n     */\n    public static double regularizedGammaQ(double a, double x) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive\");\n        }\n\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x must be non-negative\");\n        }\n\n        if (Double.isInfinite(a)) {\n            return Double.NaN;\n        }\n\n        if (x == 0) {\n            return 1;\n        }\n\n        if (a > 1000) {\n            return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n        }\n\n        double ret;\n        boolean negIb = false;\n        double temp = a + LANCZOS_G - 0.5;\n        if (x < temp) {\n            negIb = true;\n            ret = lanczos(a);\n            if (Precision.equals(ret, 0, 1)) {\n                return ret;\n            }\n            ret *= MathUtils.gamma(a) * Math.pow(x, a) / continuedFractionA(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n        } else {\n            ret = gammaQ(a, x);\n        }\n\n        double l = 1;\n        if (x >= 1 + temp) {\n            double logX = Math.log(x);\n            double a0 = 1 / x;\n            double b0 = 0;\n            double a1 = 1;\n            double b1 = 1;\n            double fac = 1;\n            for (int i = 1; i < 100 && Math.abs((fac * b1) / (fac * b0)) > DEFAULT_EPSILON; ++i) {\n                double an = i * (a - i);\n                double a2 = (a1 + a0 * an) * logX - i;\n                double b2 = (b1 + b0 * an);\n                a0 = a1;\n                a1 = a2;\n                b0 = b1;\n                b1 = b2;\n                double t = a1 / b1;\n                fac = t;\n                l *= t;\n            }\n            ret *= l;\n        }\n\n        if (negIb) {\n            ret = 1 - ret;\n        }\n\n        return ret;\n    }\n\n    /**\n     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n     *\n     * @param a        the a parameter (a &gt; 0)\n     * @param x        the x parameter (x &ge; 0)\n     * @param epsilon  the accuracy goal\n     * @param maxIter  the maximum number of iterations to produce the result\n     * @return the regularized gamma function Q(a, x) = 1 - P(a, x)\n     * @throws IllegalArgumentException if {@code a <= 0} or {@code x < 0}\n     */\n    public static double regularizedGammaQ(double a, double x, double epsilon, int maxIter) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive\");\n        }\n\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x must be non-negative\");\n        }\n\n        if (Double.isInfinite(a)) {\n            return Double.NaN;\n        }\n\n        if (x == 0) {\n            return 1;\n        }\n\n        double q = continuedFractionB(a, x, epsilon, maxIter);\n        return q * Math.pow(x, a) / LanczosApproximation.value(a);\n    }\n\n    /** Compute the series expansion of the natural log of the gamma function using Lanczos approximation\n     *  See http://mathworld.wolfram.com/LanczosApproximation.html for details.\n     *\n     * @param x argument, x &ge; 0.\n     * @return log(\u0393(x)) based on Lanczos approximation.\n     */\n    private static double lanczos(double x) {\n        final double sum = 0.99999999999999709182 +\n                (676.520368121885098567e0 / x) -\n                1259.1392167224028705e0 +\n                771.32342877765307844e0 * x -\n                176.61502916214059965e0 * x * x +\n                12.507343278686904814e0 * x * x * x -\n                0.13857109526572011602e0 * x * x * x * x +\n                0.0000099843695780195714e0 * x * x * x * x * x -\n                0.000000000888173687069e0 * x * x * x * x * x * x +\n                (x + 0.5) * Math.log(x + 5.5) -\n                (x + 5.5);\n        return sum + Math.log(Math.sqrt(2 * Math.PI));\n    }\n\n    /** Continued fraction approximation for the gamma function.\n     *\n     * @param a the a parameter.\n     * @param x the x parameter.\n     * @param epsilon the accuracy goal, should be relative.\n     * @param maxIterations maximal number of iterations to perform.\n     * @return the value of the continued fraction approximation.\n     * @throws IllegalArgumentException if {@code a <= 0} or {@code x < 0}.\n     */\n    private static double continuedFractionA(final double a, final double x, final double epsilon, final int maxIterations) {\n        final double small = 1e-50;\n        double hPrev = 1;\n        double cPrev = small;\n        double aPrev = x;\n        double dPrev = 1 / small;\n        double qPrev = aPrev;\n        double n = 1;\n\n        double hN = aPrev;\n        double cN = hN;\n\n        while (n < maxIterations) {\n            double aNext = n * (n - a);\n            double dNext = x + n - 1;\n            double cNext = aNext * cPrev + dPrev;\n            if (Math.abs(cNext) > Double.MAX_VALUE) {\n                double scale = Math.abs(cNext) / Double.MAX_VALUE + 10;\n                cPrev /= scale;\n                cN /= scale;\n            }\n            double qNext = qPrev + cPrev * (hPrev - qPrev);\n            if (Double.isInfinite(qNext)) {\n                qNext = hN;\n                break;\n            }\n            double hNext = aPrev * qNext + n * hPrev;\n            if (Double.isInfinite(hNext)) {\n                hNext = Double.MAX_VALUE;\n                break;\n            }\n            double deltaN = hNext == 0 ? Math.abs(cNext) : Math.abs((hNext - hN) / hNext);\n            if (deltaN < epsilon) {\n                break;\n            }\n            n++;\n            hPrev = hN;\n            hN = hNext;\n            cPrev = cN;\n            cN = cNext;\n            dPrev = dNext;\n            aPrev = aNext;\n            qPrev = qNext;\n        }\n\n        if (n >= maxIterations) {\n            throw new RuntimeException(\"maximal count (\" + maxIterations + \") exceeded\");\n        }\n\n        return hN;\n    }\n\n    /** Continued fraction approximation for the gamma function.\n     *\n     * @param a the a parameter.\n     * @param x the x parameter.\n     * @param epsilon the accuracy goal, should be relative.\n     * @param maxIterations maximal number of iterations to perform.\n     * @return the value of the continued fraction approximation.\n     * @throws IllegalArgumentException if {@code a <= 0} or {@code x < 0}.\n     */\n    private static double continuedFractionB(double a, double x, double epsilon, int maxIterations){\n        final double small = 1e-50;\n        double fm = 0.0;\n        double cf = 1.0/x;\n        double aplus = cf;\n        int j = 1;\n\n        while (j <= maxIterations) {\n            double aplusold = aplus;\n            double aj = -j*(j-a);\n            double b = x+2.0*j;\n            cf = b+aj*cf;\n            if (Math.abs(cf) > Double.MAX_VALUE) {\n                cf /= Double.MAX_VALUE;\n                aplus /= Double.MAX_VALUE;\n            }\n            if (cf == 0.0) {\n                return aplus;\n            }\n            cf = 1.0/cf;\n            double d = aj*aplus;\n            aplus = cf*aplus;\n            if (Math.abs(aplus) > Double.MAX_VALUE) {\n                cf /= Double.MAX_VALUE;\n                aplus /= Double.MAX_VALUE;\n            }\n            if (Math.abs(d/APRational.MAX_VALUE_DENOMINATOR) > Math.abs(aplus)) {\n                if (fm == 0.0) {\n                    fm = 1.0;\n                } else {\n                    fm *= 2.0;\n                }\n                aplusold /= APRational.MAX_VALUE_DENOMINATOR;\n                aplus /= APRational.MAX_VALUE_DENOMINATOR;\n                if (Math.abs(aplus) > Double.MAX_VALUE) {\n                    cf /= Double.MAX_VALUE;\n                    aplus /= Double.MAX_VALUE;\n                }\n                if (Math.abs(aplusold) < small) {\n                    return aplus;\n                }\n                if (Math.abs(aplus - aplusold)/Math.abs(aplus) < epsilon/((double) j) && Math.abs(cf-1.0) < epsilon/((double) j)) {\n                    return aplus;\n                }\n            }\n            j++;\n        }\n        throw new IllegalStateException(\"maximal count (\" + maxIterations + \") exceeded\");\n    }\n\n    /**\n     * Computes the gamma function of the argument. The result is accurate to {@code 15} decimal\n     * places for arguments smaller than {@code 172}.\n     *\n     * @param x the value\n     * @return the gamma function of x.\n     */\n    public static double gamma(double x) {\n        return Math.exp(logGamma(x));\n    }\n\n    /**\n     * Computes the natural logarithm of the gamma function of the argument. The result is accurate\n     * to {@code 15} decimal places for arguments smaller than {@code 172}. For larger arguments\n     * the result can still be approximated but the accuracy may be lower.\n     *\n     * @param x the value\n     * @return the natural logarithm of the gamma function of x.\n     */\n    public static double logGamma(double x) {\n        double ret;\n        if (Double.isNaN(x) || x <= 0) {\n            ret = Double.NaN;\n        } else if (x < 0.5) {\n            return logGamma1p(x) - Math.log(x);\n        } else if (x <= 2.5) {\n            return logGamma1p((x - 0.5) - 0.5);\n        } else if (x <= 8) {\n            int n = (int) Math.floor(x - 1.5);\n            double prod = 1;\n            for (int i = 1; i <= n; ++i) {\n                prod *= x - i;\n            }\n            return logGamma1p(x - (n + 1)) + Math.log(prod);\n        } else {\n            double sum = lanczos(x);\n            double tmp = x + LANCZOS_G + .5;\n            ret = (x + .5) * Math.log(tmp) - tmp +\n                    HALF_LOG_2_PI + Math.log(sum / x);\n        }\n        return ret;\n    }\n\n    /**\n     * Computes the natural logarithm of the gamma function of the argument plus 1.\n     *\n     * @param x the value\n     * @return the natural logarithm of the gamma function of x + 1\n     */\n    private static double logGamma1p(double x) {\n        if (x < -0.5) {\n            throw new NumberFormatException(\"x must be greater than -0.5\");\n        }\n\n        return Gamma.logGamma(x + 1);\n    }\n\n    // constants and helpers for lanczos approximation\n\n    /**\n     * Constant value for half of log(2*pi).\n     */\n    private static final double HALF_LOG_2_PI = 0.5 * Math.log(2 * Math.PI);\n\n    /**\n     * Class for the computation of the Lanczos approximation of the Gamma function.\n     */\n    private static class LanczosApproximation {\n\n        /** Maximum allowed numerical error. */\n        private static final double DEFAUL",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}