{
    "patch": "        } else if ((parent.isCall() || parent.isNew()) && parent.getFirstChild() == n) {\n            // The rhs of the assignment is the caller, so it's used by the\n            // context. Don't associate it w/ the lhs.\n            // FYI: this fixes only the specific case where the assignment is the\n            // caller expression, but it could be nested deeper in the caller and\n            // we would still get a bug.\n            // See testAssignWithCall2 for an example of this.\n            if (nodeParent && nodeParent.isCall() && nodeParent.getFirstChild() == recordNode) {\n              Node grandparent = nodeParent.getParent();\n              if (grandparent.isAssign() && n == grandparent.getFirstChild()) {\n                Node greatGrandparent = grandparent.getParent();\n                if (greatGrandparent.isCall() && grandparent == greatGrandparent.getFirstChild()) {\n                  // the call is wrapped right above the generated assignment node:\n                  // var $$jscompCall$res = wrapper(f1, f2), v = $$jscompCall$res\n                  //    where f1, f2 are other function calls\n                  recordDepScope(nodeParent, ns);\n                  return;\n                }\n              }\n            }\n            recordDepScope(recordNode.getLastChild(), ns);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 0fc5ae8f..cd8f37d3 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -575,7 +575,27 @@ final class NameAnalyzer implements CompilerPass {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+        } else if ((parent.isCall() || parent.isNew()) && parent.getFirstChild() == n) {\n+            // The rhs of the assignment is the caller, so it's used by the\n+            // context. Don't associate it w/ the lhs.\n+            // FYI: this fixes only the specific case where the assignment is the\n+            // caller expression, but it could be nested deeper in the caller and\n+            // we would still get a bug.\n+            // See testAssignWithCall2 for an example of this.\n+            if (nodeParent && nodeParent.isCall() && nodeParent.getFirstChild() == recordNode) {\n+              Node grandparent = nodeParent.getParent();\n+              if (grandparent.isAssign() && n == grandparent.getFirstChild()) {\n+                Node greatGrandparent = grandparent.getParent();\n+                if (greatGrandparent.isCall() && grandparent == greatGrandparent.getFirstChild()) {\n+                  // the call is wrapped right above the generated assignment node:\n+                  // var $$jscompCall$res = wrapper(f1, f2), v = $$jscompCall$res\n+                  //    where f1, f2 are other function calls\n+                  recordDepScope(nodeParent, ns);\n+                  return;\n+                }\n+              }\n+            }\n+            recordDepScope(recordNode.getLastChild(), ns);\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}