{
    "patch": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n        DateTimeField field = partial.getField(fieldIndex);\n        if (DateTimeUtils.isContiguous(partial) && field.getDurationField().getUnitMillis() >= DateTimeConstants.MONTHS_PER_YEAR) {\n            long instant = 0L;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n            }\n            \n            int monthIndex = fieldIndex;\n            int yearIndex = -1;\n            DateTimeFieldType previousType = null;\n            for (int i = 0, isize = partial.size(); i < isize; i++) {\n                DateTimeFieldType fieldType = partial.getFieldType(i);\n                if (fieldType == DateTimeFieldType.year()) {\n                    yearIndex = i;\n                }\n                if (fieldType == DateTimeFieldType.monthOfYear()) {\n                    previousType = fieldType;\n                    if (i == fieldIndex) {\n                        // monthIndex too big if we absorbed no years\n                        monthIndex = i;\n                    }\n                    if (yearIndex >= 0 && values[yearIndex] == 0) {\n                        // year zero has no leap year, so leap year of Feb 29th is invalid.\n                        // Instead, you obtain values for March 1st.\n                        values[monthIndex] = 3;\n                    }\n                } else if (fieldType == DateTimeFieldType.dayOfMonth()) {\n                    // reset the value of day since it may be invalid\n                    int maxDay = field.getMaximumValue(instant);\n                    values[i] = field.get(maxDay, maxDay, values[i]);\n                } else if (previousType == DateTimeFieldType.monthOfYear() && fieldType == DateTimeFieldType.dayOfMonth()) {\n                    // reset the value of day since it may be invalid\n                    int maxDay = field.getMaximumValue(instant);\n                    values[i] = field.get(maxDay, maxDay, values[i]);\n                } else if (fieldType == DateTimeFieldType.dayOfYear()) {\n                    // reset the value of day since it may be invalid\n                    int maxDay = field.getMaximumValue(instant);\n                    values[i] = field.get(maxDay, maxDay, values[i]);\n                }\n                previousType = fieldType;\n            }\n            instant = add(instant, valueToAdd);\n            return iChronology.get(partial, instant);\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\nindex afca44e6..65d12fe0 100644\n--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -206,12 +206,47 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n         if (valueToAdd == 0) {\n             return values;\n         }\n-            // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n+        DateTimeField field = partial.getField(fieldIndex);\n+        if (DateTimeUtils.isContiguous(partial) && field.getDurationField().getUnitMillis() >= DateTimeConstants.MONTHS_PER_YEAR) {\n             long instant = 0L;\n             for (int i = 0, isize = partial.size(); i < isize; i++) {\n                 instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n             }\n+            \n+            int monthIndex = fieldIndex;\n+            int yearIndex = -1;\n+            DateTimeFieldType previousType = null;\n+            for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                DateTimeFieldType fieldType = partial.getFieldType(i);\n+                if (fieldType == DateTimeFieldType.year()) {\n+                    yearIndex = i;\n+                }\n+                if (fieldType == DateTimeFieldType.monthOfYear()) {\n+                    previousType = fieldType;\n+                    if (i == fieldIndex) {\n+                        // monthIndex too big if we absorbed no years\n+                        monthIndex = i;\n+                    }\n+                    if (yearIndex >= 0 && values[yearIndex] == 0) {\n+                        // year zero has no leap year, so leap year of Feb 29th is invalid.\n+                        // Instead, you obtain values for March 1st.\n+                        values[monthIndex] = 3;\n+                    }\n+                } else if (fieldType == DateTimeFieldType.dayOfMonth()) {\n+                    // reset the value of day since it may be invalid\n+                    int maxDay = field.getMaximumValue(instant);\n+                    values[i] = field.get(maxDay, maxDay, values[i]);\n+                } else if (previousType == DateTimeFieldType.monthOfYear() && fieldType == DateTimeFieldType.dayOfMonth()) {\n+                    // reset the value of day since it may be invalid\n+                    int maxDay = field.getMaximumValue(instant);\n+                    values[i] = field.get(maxDay, maxDay, values[i]);\n+                } else if (fieldType == DateTimeFieldType.dayOfYear()) {\n+                    // reset the value of day since it may be invalid\n+                    int maxDay = field.getMaximumValue(instant);\n+                    values[i] = field.get(maxDay, maxDay, values[i]);\n+                }\n+                previousType = fieldType;\n+            }\n             instant = add(instant, valueToAdd);\n             return iChronology.get(partial, instant);\n         } else {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}