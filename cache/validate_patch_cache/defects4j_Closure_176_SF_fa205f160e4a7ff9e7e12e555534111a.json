{
    "patch": "private void optimizeCondition(\n        ControlFlowGraph<Node> cfg,\n        DiGraph.DiGraphNode<Node, ControlFlowGraph.Branch> trueBranch,\n        DiGraph.DiGraphNode<Node, ControlFlowGraph.Branch> falseBranch,\n        Node condition,\n        JSType booleanType) {\n    Preconditions.checkState(NodeUtil.isStatement(condition.getParent()));\n    if (condition.getBooleanProp(Node.SIDE_EFFECT_FREE_ATOM)) {\n        swapBranches(cfg, trueBranch, falseBranch);\n        condition.setBoolean(!condition.getBoolean());\n        return;\n    }\n    Boolean falsey = NodeUtil.getBooleanValue(condition);\n    if (falsey != null) {\n        DiGraph.DiGraphNode<Node, ControlFlowGraph.Branch> executedBranch = falsey ?\n                falseBranch : trueBranch;\n        cfg.removeEdge(executedBranch, falsey ? trueBranch : falseBranch);\n        cfg.replaceBranchInEdges(executedBranch, trueBranch, falseBranch);\n        return;\n    }\n    Node condExpr = condition.getParent();\n    Node ifBlock = condExpr.getNext();\n    Node elseBlock = ifBlock.getNext();\n    boolean elseIsEmpty = elseBlock.isEmpty();\n    Node blockToKeep = elseIsEmpty ? ifBlock : elseBlock;\n    Node blockToRemove = elseIsEmpty ? elseBlock : ifBlock;\n    Node statementToPutFirst = getFirstStatement(blockToKeep);\n    Node stmtToInsertBefore = getFirstStatement(blockToRemove);\n    Preconditions.checkNotNull(stmtToInsertBefore);\n    Node stmtToInsertAfter = stmtToInsertBefore.getPrevious();\n    Preconditions.checkNotNull(stmtToInsertAfter);\n    // If this is a do-while loop, we need to insert the newly hoisted statements\n    // inside the do-block so that they are executed during every iteration of the loop.\n    if (NodeUtil.isLoop(condExpr) && condExpr.getLastChild().isDo()) {\n        Node loopBody = condExpr.getLastChild().getLastChild();\n        Preconditions.checkState(loopBody.isBlock());\n        Node firstLoopStatement = getFirstStatement(loopBody);\n        // Update the end on the newly hoisted statements to end where the\n        // loop starts.\n        int loopStartLineno = condExpr.getLineno();\n        for (Node sibling = statementToPutFirst; sibling != blockToKeep; sibling = sibling.getNext()) {\n            setSourceInfo(sibling, loopStartLineno);\n        }\n        // Move the hoisted statements into the loop block before the\n        // first node.\n        for (Node sibling = statementToPutFirst; sibling != blockToKeep;) {\n            Node next = sibling.getNext();\n            loopBody.addChildBefore(sibling.detach(), firstLoopStatement);\n            sibling = next;\n        }\n        return;\n    }\n    // Move the statements to the start of the if-block.\n    for (Node sibling = statementToPutFirst; sibling != blockToKeep;) {\n        Node next = sibling.getNext();\n        condExpr.addChildAfter(sibling.detach(), condExpr);\n        sibling = next;\n    }\n    // Ensure that we get source mapping correct with try-catch blocks.\n    if (blockToKeep.isTry()) {\n        moveCatchToFront(blockToKeep.getFirstChild(), condition);\n    }\n    // Fix the CFG.\n    cfg.removeEdge(trueBranch, falseBranch);\n    cfg.replaceBranchInEdges(trueBranch, falseBranch);\n    trueBranch.getValue().negate();\n    falseBranch.getValue().negate();\n    swapBranches(cfg, trueBranch, falseBranch);\n    condition.setToken(Token.AND);\n    condition.replaceChild(condition.getFirstChild(), IR.trueNode());\n    condition.replaceChild(condition.getLastChild(), IR.falseNode());\n}\n\nprivate Node getFirstStatement(Node block) {\n    return block.getFirstChild();\n}\n\nprivate void moveCatchToFront(Node tryNode, Node condition) {\n    Preconditions.checkState(tryNode.isTry());\n    // If the catch block is empty, we can safely move it to the front\n    // because it won't execute.\n    Node catchNode = tryNode.getFirstChild().getNext();\n    Node blockNode = catchNode.getLastChild();\n    if (!blockNode.hasChildren()) {\n        tryNode.addChildToFront(catchNode.detach());\n        setSourceInfo(catchNode, condition);\n    }\n}\n\nprivate void setSourceInfo(Node node, Node refNode) {\n    node.setLineno(refNode.getLineno());\n    node.setCharno(refNode.getCharno());\n    node.setSourceFileName(refNode.getSourceFileName());\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..b126e8bd 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,109 +521,100 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n-\n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n-\n-\n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n-\n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n+private void optimizeCondition(\n+        ControlFlowGraph<Node> cfg,\n+        DiGraph.DiGraphNode<Node, ControlFlowGraph.Branch> trueBranch,\n+        DiGraph.DiGraphNode<Node, ControlFlowGraph.Branch> falseBranch,\n+        Node condition,\n+        JSType booleanType) {\n+    Preconditions.checkState(NodeUtil.isStatement(condition.getParent()));\n+    if (condition.getBooleanProp(Node.SIDE_EFFECT_FREE_ATOM)) {\n+        swapBranches(cfg, trueBranch, falseBranch);\n+        condition.setBoolean(!condition.getBoolean());\n+        return;\n+    }\n+    Boolean falsey = NodeUtil.getBooleanValue(condition);\n+    if (falsey != null) {\n+        DiGraph.DiGraphNode<Node, ControlFlowGraph.Branch> executedBranch = falsey ?\n+                falseBranch : trueBranch;\n+        cfg.removeEdge(executedBranch, falsey ? trueBranch : falseBranch);\n+        cfg.replaceBranchInEdges(executedBranch, trueBranch, falseBranch);\n+        return;\n+    }\n+    Node condExpr = condition.getParent();\n+    Node ifBlock = condExpr.getNext();\n+    Node elseBlock = ifBlock.getNext();\n+    boolean elseIsEmpty = elseBlock.isEmpty();\n+    Node blockToKeep = elseIsEmpty ? ifBlock : elseBlock;\n+    Node blockToRemove = elseIsEmpty ? elseBlock : ifBlock;\n+    Node statementToPutFirst = getFirstStatement(blockToKeep);\n+    Node stmtToInsertBefore = getFirstStatement(blockToRemove);\n+    Preconditions.checkNotNull(stmtToInsertBefore);\n+    Node stmtToInsertAfter = stmtToInsertBefore.getPrevious();\n+    Preconditions.checkNotNull(stmtToInsertAfter);\n+    // If this is a do-while loop, we need to insert the newly hoisted statements\n+    // inside the do-block so that they are executed during every iteration of the loop.\n+    if (NodeUtil.isLoop(condExpr) && condExpr.getLastChild().isDo()) {\n+        Node loopBody = condExpr.getLastChild().getLastChild();\n+        Preconditions.checkState(loopBody.isBlock());\n+        Node firstLoopStatement = getFirstStatement(loopBody);\n+        // Update the end on the newly hoisted statements to end where the\n+        // loop starts.\n+        int loopStartLineno = condExpr.getLineno();\n+        for (Node sibling = statementToPutFirst; sibling != blockToKeep; sibling = sibling.getNext()) {\n+            setSourceInfo(sibling, loopStartLineno);\n         }\n-        break;\n-      case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n+        // Move the hoisted statements into the loop block before the\n+        // first node.\n+        for (Node sibling = statementToPutFirst; sibling != blockToKeep;) {\n+            Node next = sibling.getNext();\n+            loopBody.addChildBefore(sibling.detach(), firstLoopStatement);\n+            sibling = next;\n         }\n+        return;\n+    }\n+    // Move the statements to the start of the if-block.\n+    for (Node sibling = statementToPutFirst; sibling != blockToKeep;) {\n+        Node next = sibling.getNext();\n+        condExpr.addChildAfter(sibling.detach(), condExpr);\n+        sibling = next;\n+    }\n+    // Ensure that we get source mapping correct with try-catch blocks.\n+    if (blockToKeep.isTry()) {\n+        moveCatchToFront(blockToKeep.getFirstChild(), condition);\n+    }\n+    // Fix the CFG.\n+    cfg.removeEdge(trueBranch, falseBranch);\n+    cfg.replaceBranchInEdges(trueBranch, falseBranch);\n+    trueBranch.getValue().negate();\n+    falseBranch.getValue().negate();\n+    swapBranches(cfg, trueBranch, falseBranch);\n+    condition.setToken(Token.AND);\n+    condition.replaceChild(condition.getFirstChild(), IR.trueNode());\n+    condition.replaceChild(condition.getLastChild(), IR.falseNode());\n+}\n \n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n-        break;\n+private Node getFirstStatement(Node block) {\n+    return block.getFirstChild();\n+}\n+\n+private void moveCatchToFront(Node tryNode, Node condition) {\n+    Preconditions.checkState(tryNode.isTry());\n+    // If the catch block is empty, we can safely move it to the front\n+    // because it won't execute.\n+    Node catchNode = tryNode.getFirstChild().getNext();\n+    Node blockNode = catchNode.getLastChild();\n+    if (!blockNode.hasChildren()) {\n+        tryNode.addChildToFront(catchNode.detach());\n+        setSourceInfo(catchNode, condition);\n     }\n-  }\n+}\n \n-  /**\n-   * Defines a property if the property has not been defined yet.\n-   */\n-  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n-    String propName = getprop.getLastChild().getString();\n-    Node obj = getprop.getFirstChild();\n-    JSType nodeType = getJSType(obj);\n-    ObjectType objectType = ObjectType.cast(\n-        nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n-        getJSType(syntacticScope.getRootNode()).isConstructor();\n-\n-    if (objectType == null) {\n-      registry.registerPropertyOnType(propName, nodeType);\n-    } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n-        boolean staticPropCreation = false;\n-        Node maybeAssignStm = getprop.getParent().getParent();\n-        if (syntacticScope.isGlobal() &&\n-            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n-          String propCreationFilename = maybeAssignStm.getSourceFileName();\n-          Node ctor = objectType.getOwnerFunction().getSource();\n-          if (ctor != null &&\n-              ctor.getSourceFileName().equals(propCreationFilename)) {\n-            staticPropCreation = true;\n-          }\n-        }\n-        if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n-        }\n-      }\n+private void setSourceInfo(Node node, Node refNode) {\n+    node.setLineno(refNode.getLineno());\n+    node.setCharno(refNode.getCharno());\n+    node.setSourceFileName(refNode.getSourceFileName());\n+}\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}