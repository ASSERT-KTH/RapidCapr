{
    "patch": "public <T extends EventDetector> void doEvents(final SpacecraftState s0,\n                                               final Collection<T> detectors) throws OrekitException {\n\n    final EventStateMapper<T> mapper = new EventStateMapper<>(detectors);\n    final ODEIntegrator integrator = new DormandPrince853Integrator(1.0e-8, 600, 1.0e-10, 1.0e-10);\n    integrator.setInitialStepSize(60);\n    final EventStateInterpolator interpolator = new EventStateInterpolator();\n    EventHandler<T> eventHandler = new EventHandler<>(detectors, interpolator);\n    eventHandler.init(s0, s0.getDate().durationFrom(s0.shiftedBy(60.0))); // or any duration greater than zero\n    final double tEnd = eventHandler.getMaxCheckInterval();\n\n    while (s0.getDate().durationFrom(eventHandler.getEventTime()) < 0.0) {\n\n        interpolator.clear();\n\n        // integrate one step until an event occurs\n        integrator.integrate(new ODEWrapper(eventHandler,\n                        interpolator,\n                        mapper),\n                s0.getDate().durationFrom(eventHandler.getEventTime()) > 0 ? eventHandler.getEventTime().shiftedBy(tEnd) : s0.shiftedBy(tEnd),\n                mapper.map(s0),\n                mapper.map(s0.shiftedBy(tEnd)));\n\n        if (eventHandler.isLastStep()) {\n            // handle the last iteration without time continuation\n            eventHandler.handleStep(interpolator, true);\n            break;\n        } else {\n\n            // handle the event and prepare step continuation\n            final double[] y      = interpolator.getInterpolatedState().clone();\n            final double  t       = interpolator.getInterpolatedTime();\n            final double[] yDot   = mapper.mapDerivatives(interpolator.getInterpolatedDerivatives().clone(), y, t);\n\n            // handle the event\n            eventHandler.handleStep(interpolator, false);\n            if (eventHandler.resetOccurred()) {\n                // the event handler has triggered changes that\n                // invalidate the derivatives, we need to recompute\n                // them while taking the changes into account\n                final ODEStateAndDerivative state = interpolator.getInterpolatedState();\n                final double[] primary = state.getPrimaryState();\n                final double[] dotPrimary = new double[primary.length];\n                final MainStateEquations main = eventHandler.getPrimaryMapper().getMainEquations();\n                main.computeDerivatives(state.getTime(), primary, yDot, dotPrimary);\n                final double[][] secondary = state.getSecondaryState();\n                final double[][] dotSecondary = new double[secondary.length][secondary[0].length];\n                for (int i = 0; i < secondary.length; ++i) {\n                    final SecondaryStateEquations eq = eventHandler.getSecondaryMappers().get(i).getSecondaryEquations();\n                    eq.computeDerivatives(state.getTime(), primary, secondary, yDot, dotPrimary, dotSecondary[i]);\n                }\n                interpolator.setInterpolatedDerivatives(new ODEStateAndDerivative(state.getTime(), dotPrimary, dotSecondary));\n            } else {\n                // just proceed to next step\n                interpolator.setInterpolatedDerivatives(new ODEStateAndDerivative(t, yDot));\n            }\n\n            final SpacecraftState stepEnd = mapper.map(interpolator.getInterpolatedState());\n            final double      hNew     = integrator.initializeStep(mapper.map(s0), t, y, yDot, eventHandler.isForward(),\n                                                                    interpolator.getInterpolatedState().getSecondaryState());\n\n            if (hNew == 0) {\n                // this is the last iteration, it may have been\n                // set before if the user event handler triggers\n                // its end\n                eventHandler.handleStep(interpolator, true);\n                break;\n            }\n\n            if (!Double.isNaN(hNew)) {\n                // continue iterating\n                eventHandler.stepAccepted(stepEnd);\n                s0 = stepEnd;\n                final double nextT = s0.getDate().durationFrom(eventHandler.getEventTime()) > 0 ? eventHandler.getEventTime().durationFrom(s0) : t + hNew;\n                eventHandler.init(s0, nextT);\n            } else {\n                // this is the last iteration, we stop here\n                eventHandler.handleStep(interpolator, true);\n                break;\n            }\n\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..ba7daa1b9 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,90 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n-\n-            });\n-\n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n+public <T extends EventDetector> void doEvents(final SpacecraftState s0,\n+                                               final Collection<T> detectors) throws OrekitException {\n+\n+    final EventStateMapper<T> mapper = new EventStateMapper<>(detectors);\n+    final ODEIntegrator integrator = new DormandPrince853Integrator(1.0e-8, 600, 1.0e-10, 1.0e-10);\n+    integrator.setInitialStepSize(60);\n+    final EventStateInterpolator interpolator = new EventStateInterpolator();\n+    EventHandler<T> eventHandler = new EventHandler<>(detectors, interpolator);\n+    eventHandler.init(s0, s0.getDate().durationFrom(s0.shiftedBy(60.0))); // or any duration greater than zero\n+    final double tEnd = eventHandler.getMaxCheckInterval();\n+\n+    while (s0.getDate().durationFrom(eventHandler.getEventTime()) < 0.0) {\n+\n+        interpolator.clear();\n+\n+        // integrate one step until an event occurs\n+        integrator.integrate(new ODEWrapper(eventHandler,\n+                        interpolator,\n+                        mapper),\n+                s0.getDate().durationFrom(eventHandler.getEventTime()) > 0 ? eventHandler.getEventTime().shiftedBy(tEnd) : s0.shiftedBy(tEnd),\n+                mapper.map(s0),\n+                mapper.map(s0.shiftedBy(tEnd)));\n+\n+        if (eventHandler.isLastStep()) {\n+            // handle the last iteration without time continuation\n+            eventHandler.handleStep(interpolator, true);\n+            break;\n+        } else {\n+\n+            // handle the event and prepare step continuation\n+            final double[] y      = interpolator.getInterpolatedState().clone();\n+            final double  t       = interpolator.getInterpolatedTime();\n+            final double[] yDot   = mapper.mapDerivatives(interpolator.getInterpolatedDerivatives().clone(), y, t);\n+\n+            // handle the event\n+            eventHandler.handleStep(interpolator, false);\n+            if (eventHandler.resetOccurred()) {\n+                // the event handler has triggered changes that\n+                // invalidate the derivatives, we need to recompute\n+                // them while taking the changes into account\n+                final ODEStateAndDerivative state = interpolator.getInterpolatedState();\n+                final double[] primary = state.getPrimaryState();\n+                final double[] dotPrimary = new double[primary.length];\n+                final MainStateEquations main = eventHandler.getPrimaryMapper().getMainEquations();\n+                main.computeDerivatives(state.getTime(), primary, yDot, dotPrimary);\n+                final double[][] secondary = state.getSecondaryState();\n+                final double[][] dotSecondary = new double[secondary.length][secondary[0].length];\n+                for (int i = 0; i < secondary.length; ++i) {\n+                    final SecondaryStateEquations eq = eventHandler.getSecondaryMappers().get(i).getSecondaryEquations();\n+                    eq.computeDerivatives(state.getTime(), primary, secondary, yDot, dotPrimary, dotSecondary[i]);\n                 }\n+                interpolator.setInterpolatedDerivatives(new ODEStateAndDerivative(state.getTime(), dotPrimary, dotSecondary));\n+            } else {\n+                // just proceed to next step\n+                interpolator.setInterpolatedDerivatives(new ODEStateAndDerivative(t, yDot));\n             }\n \n-            while (!occuringEvents.isEmpty()) {\n-\n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n-\n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+            final SpacecraftState stepEnd = mapper.map(interpolator.getInterpolatedState());\n+            final double      hNew     = integrator.initializeStep(mapper.map(s0), t, y, yDot, eventHandler.isForward(),\n+                                                                    interpolator.getInterpolatedState().getSecondaryState());\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+            if (hNew == 0) {\n+                // this is the last iteration, it may have been\n+                // set before if the user event handler triggers\n+                // its end\n+                eventHandler.handleStep(interpolator, true);\n+                break;\n+            }\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+            if (!Double.isNaN(hNew)) {\n+                // continue iterating\n+                eventHandler.stepAccepted(stepEnd);\n+                s0 = stepEnd;\n+                final double nextT = s0.getDate().durationFrom(eventHandler.getEventTime()) > 0 ? eventHandler.getEventTime().durationFrom(s0) : t + hNew;\n+                eventHandler.init(s0, nextT);\n+            } else {\n+                // this is the last iteration, we stop here\n+                eventHandler.handleStep(interpolator, true);\n+                break;\n+            }\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n+        }\n+    }\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}