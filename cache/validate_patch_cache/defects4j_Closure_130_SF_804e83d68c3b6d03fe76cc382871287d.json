{
    "patch": "private boolean inlineAliasIfPossible(Ref aliasRef, GlobalNamespace namespace) {\n    checkState(aliasRef.getTwin() == null, aliasRef);\n    checkState(aliasRef.type == Type.ALIASING_GET, aliasRef.type);\n\n    Node aliasNode = aliasRef.getNode();\n    Ref lb = aliasRef.getPrevious();\n    Node nameNode = lb == null ? aliasNode.getFirstChild() : lb.getNext();\n    Preconditions.checkNotNull(nameNode, \"empty nameNode\");\n    checkState(nameNode.isName(), nameNode);\n    String name = nameNode.getString();\n    Node parent = aliasNode.getParent();\n    int childCount = parent.getChildCount();\n\n    boolean isLiveBinding = aliasNode.getBooleanProp(Node.IS_LIVE_OBJECT);\n    boolean isObjectLiteral = aliasNode.getType() == Token.OBJECTLIT;\n    boolean isVar = lb != null && lb.getParent() == parent &&\n        (lb.isVar() || lb.getParent().isVanillaFor());\n    boolean isAssign = aliasNode.getParent().isAssign();\n\n    if (isAssign && (!isFunction(parent) || !name.equals(\"prototype\"))) {\n        // Outer referenced value has to stay an object literal in order\n        // to remain compatible with other scopes.  So, we can't inline the\n        // reference unless we're setting a prototype property within a class.\n        return false;\n    }\n\n    // We always inline aliases of named constructors.\n    boolean isNamedConstructor =\n        name.equals(\"prototype\") &&\n        parent.isAssign() &&\n        parent.getFirstChild().isQualifiedName();\n\n    if (lb != null && lb.getParent() == parent &&\n        lb.isClass() &&\n        name.equals(\"prototype\")) {\n        // Class prototypes should not be aliased under any circumstance. Note that since we\n        // cannot reliably detect this case from the single Reference from the alias to the\n        // Class prototype, we rely on noticing that the aliased reference is unused, and verify\n        // that its LHS child is a class with a constructor property.\n        // Assign a null node as the replacement node so that closure can safely delete this\n        // reference later on.\n        Node nullNode = IR.nullNode();\n        nullNode.useSourceInfoFromForTree(aliasNode);\n        parent.replaceChild(aliasNode, nullNode);\n        return true;\n    }\n\n    if (isVar || isNamedConstructor) {\n        if (isLiveBinding &&\n            (!isObjectLiteral ||\n             !parent.getParent().isCall() ||\n             parent.getNext() != null)) {\n            // We can't inline the alias if it's the LHS of an object literal or destructuring\n            // assignment, unless it's also being used in an invocation.\n            return false;\n        }\n\n        if (isObjectLiteral && !isNamedConstructor) {\n            // We can't just splice in an OBJLIT node into a VAR statement or for-in loop\n            // without the risk of breaking the scopes.\n            return false;\n        }\n\n        for (Ref ref : aliasRef.getName().getRefs()) {\n            Node n = ref.getNode();\n            if (n == aliasNode ||\n                NodeUtil.isLhsByDestructuring(n) ||\n                NodeUtil.isExpressionResultUsed(n) ||\n                // For named constructors, don't inline anything that's not used as a constructor\n                (isNamedConstructor && !NodeUtil.isCallOrNew(n))) {\n                continue;\n            }\n\n            Node replacementNode = isNamedConstructor ?\n                callNode(aliasNode.getFirstChild()) : aliasNode.detachFromParent();\n\n            if (ref.getTwin() != null) {\n                // The aliased name is part of a VAR declaration with multiple names,\n                // such as \"var a, b = x;\".  We need to detach the alias node and clone\n                // it once for each variable name that's being declared.\n                NodeUtil.cloneAndPrependTo(\n                    replacementNode, parent.getParent(), getPreviousNode(lb));\n                ref.getTwin().detachFromParent();\n            } else {\n                // Replace the name node in the tree with the aliased node.\n                parent.replaceChild(nameNode, replacementNode);\n            }\n\n            removeUnnecessaryCastIfPresent(replacementNode);\n\n            if (ParentTraversalCallback.getEnclosingFunction(aliasNode) != null) {\n                String foundName = NodeUtil.getBestLValueName(aliasRef.getNode());\n                if (foundName != null) {\n                    changeScopeForLValueUses(foundName, replacementNode, aliasRef);\n                }\n            }\n\n            // Replace all references to the alias name with the original name.\n            referenceReplacer.replaceAll(aliasRef, name);\n            return true;\n        }\n    } else if (!isLiveBinding || childCount == 1) {\n        // If the parent object literal has more than one child, we don't want to\n        // remove its identity unless that's necessary due to live bindings.\n        Node replacementNode = aliasNode.detachFromParent();\n        if (childCount == 1) {\n            // We're inlining the only property in an object literal.  Remove the object literal.\n            parent.getParent().replaceChild(parent, replacementNode);\n        } else {\n            // Replace the name node with the aliased node.\n            parent.replaceChild(nameNode, replacementNode);\n        }\n\n        // Replace all references to the alias name with the original name.\n        referenceReplacer.replaceAll(aliasRef, name);\n        return true;\n    }\n    return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..fd793e10 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -158,43 +158,125 @@ class CollapseProperties implements CompilerPass {\n    *    inlineable.\n    * @see InlineVariables\n    */\n-  private void inlineAliases(GlobalNamespace namespace) {\n-    // Invariant: All the names in the worklist meet condition (a).\n-    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n-    while (!workList.isEmpty()) {\n-      Name name = workList.pop();\n-\n-      // Don't attempt to inline a getter or setter property as a variable.\n-      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n-        continue;\n-      }\n+private boolean inlineAliasIfPossible(Ref aliasRef, GlobalNamespace namespace) {\n+    checkState(aliasRef.getTwin() == null, aliasRef);\n+    checkState(aliasRef.type == Type.ALIASING_GET, aliasRef.type);\n+\n+    Node aliasNode = aliasRef.getNode();\n+    Ref lb = aliasRef.getPrevious();\n+    Node nameNode = lb == null ? aliasNode.getFirstChild() : lb.getNext();\n+    Preconditions.checkNotNull(nameNode, \"empty nameNode\");\n+    checkState(nameNode.isName(), nameNode);\n+    String name = nameNode.getString();\n+    Node parent = aliasNode.getParent();\n+    int childCount = parent.getChildCount();\n+\n+    boolean isLiveBinding = aliasNode.getBooleanProp(Node.IS_LIVE_OBJECT);\n+    boolean isObjectLiteral = aliasNode.getType() == Token.OBJECTLIT;\n+    boolean isVar = lb != null && lb.getParent() == parent &&\n+        (lb.isVar() || lb.getParent().isVanillaFor());\n+    boolean isAssign = aliasNode.getParent().isAssign();\n+\n+    if (isAssign && (!isFunction(parent) || !name.equals(\"prototype\"))) {\n+        // Outer referenced value has to stay an object literal in order\n+        // to remain compatible with other scopes.  So, we can't inline the\n+        // reference unless we're setting a prototype property within a class.\n+        return false;\n+    }\n+\n+    // We always inline aliases of named constructors.\n+    boolean isNamedConstructor =\n+        name.equals(\"prototype\") &&\n+        parent.isAssign() &&\n+        parent.getFirstChild().isQualifiedName();\n+\n+    if (lb != null && lb.getParent() == parent &&\n+        lb.isClass() &&\n+        name.equals(\"prototype\")) {\n+        // Class prototypes should not be aliased under any circumstance. Note that since we\n+        // cannot reliably detect this case from the single Reference from the alias to the\n+        // Class prototype, we rely on noticing that the aliased reference is unused, and verify\n+        // that its LHS child is a class with a constructor property.\n+        // Assign a null node as the replacement node so that closure can safely delete this\n+        // reference later on.\n+        Node nullNode = IR.nullNode();\n+        nullNode.useSourceInfoFromForTree(aliasNode);\n+        parent.replaceChild(aliasNode, nullNode);\n+        return true;\n+    }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+    if (isVar || isNamedConstructor) {\n+        if (isLiveBinding &&\n+            (!isObjectLiteral ||\n+             !parent.getParent().isCall() ||\n+             parent.getNext() != null)) {\n+            // We can't inline the alias if it's the LHS of an object literal or destructuring\n+            // assignment, unless it's also being used in an invocation.\n+            return false;\n+        }\n+\n+        if (isObjectLiteral && !isNamedConstructor) {\n+            // We can't just splice in an OBJLIT node into a VAR statement or for-in loop\n+            // without the risk of breaking the scopes.\n+            return false;\n+        }\n+\n+        for (Ref ref : aliasRef.getName().getRefs()) {\n+            Node n = ref.getNode();\n+            if (n == aliasNode ||\n+                NodeUtil.isLhsByDestructuring(n) ||\n+                NodeUtil.isExpressionResultUsed(n) ||\n+                // For named constructors, don't inline anything that's not used as a constructor\n+                (isNamedConstructor && !NodeUtil.isCallOrNew(n))) {\n+                continue;\n             }\n-          }\n+\n+            Node replacementNode = isNamedConstructor ?\n+                callNode(aliasNode.getFirstChild()) : aliasNode.detachFromParent();\n+\n+            if (ref.getTwin() != null) {\n+                // The aliased name is part of a VAR declaration with multiple names,\n+                // such as \"var a, b = x;\".  We need to detach the alias node and clone\n+                // it once for each variable name that's being declared.\n+                NodeUtil.cloneAndPrependTo(\n+                    replacementNode, parent.getParent(), getPreviousNode(lb));\n+                ref.getTwin().detachFromParent();\n+            } else {\n+                // Replace the name node in the tree with the aliased node.\n+                parent.replaceChild(nameNode, replacementNode);\n+            }\n+\n+            removeUnnecessaryCastIfPresent(replacementNode);\n+\n+            if (ParentTraversalCallback.getEnclosingFunction(aliasNode) != null) {\n+                String foundName = NodeUtil.getBestLValueName(aliasRef.getNode());\n+                if (foundName != null) {\n+                    changeScopeForLValueUses(foundName, replacementNode, aliasRef);\n+                }\n+            }\n+\n+            // Replace all references to the alias name with the original name.\n+            referenceReplacer.replaceAll(aliasRef, name);\n+            return true;\n+        }\n+    } else if (!isLiveBinding || childCount == 1) {\n+        // If the parent object literal has more than one child, we don't want to\n+        // remove its identity unless that's necessary due to live bindings.\n+        Node replacementNode = aliasNode.detachFromParent();\n+        if (childCount == 1) {\n+            // We're inlining the only property in an object literal.  Remove the object literal.\n+            parent.getParent().replaceChild(parent, replacementNode);\n+        } else {\n+            // Replace the name node with the aliased node.\n+            parent.replaceChild(nameNode, replacementNode);\n         }\n-      }\n \n-      // Check if {@code name} has any aliases left after the\n-      // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n-           name.type == Name.Type.FUNCTION) &&\n-          name.aliasingGets == 0 && name.props != null) {\n-        // All of {@code name}'s children meet condition (a), so they can be\n-        // added to the worklist.\n-        workList.addAll(name.props);\n-      }\n+        // Replace all references to the alias name with the original name.\n+        referenceReplacer.replaceAll(aliasRef, name);\n+        return true;\n     }\n-  }\n+    return false;\n+}\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n     // Ensure that the alias is assigned to a local variable at that",
    "result_reason": "error: method inlineAliasIfPossible(Ref,GlobalNamespace) is already defined in class CollapseProperties",
    "test_result": "ERROR"
}