{
    "patch": "    public void integrateUntil(final double t) {\n\n        final double[] y = new double[ode.getDimension()];\n\n        final double t0 = time;\n        final double sign = t >= t0 ? 1.0 : -1.0;\n        while ((sign * (time - t)) < 0) {\n            \n            final double t1 = Math.min(t, time + sign * maxStep);\n            final double dt = t1 - time;\n            \n            // advance the ODE state up to t1\n            final int k = integrator.integrate(ode, time, y, t1, y);\n            \n            time = integrator.getCurrentStepStart();\n            System.arraycopy(y, 0, odeCurrentState, 0, y.length);\n\n            if (k < 0) {\n                // integration failure\n                throw new RuntimeException(\"Integration failed at t=\" + time);\n            } else if (k == 0) {\n                // constant step size, ODE solved successfully\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(new StepInterpolator(t0, t1, y, y, odeCurrentState, odeCurrentState, ode, isLastStep), isLastStep);\n                }\n            } else {\n                // adaptive step size, handle intermediate sub-steps\n                final StepInterpolator interpolator = integrator.getInterpolator();\n                final boolean isLastStep = (sign * (t1 - t)) >= 0;\n                interpolator.setInterpolatedTime(time);\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, false);\n                }\n                while ((interpolator.getCurrentTime() - t1) * interpolator.getNextTime() <= 0) {\n                    interpolator.setInterpolatedTime(t1);\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, false);\n                    }\n                }\n                interpolator.setInterpolatedTime(t1);\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n            }\n            \n            if (stopCondition != null && stopCondition.evaluate(this)) {\n                isLastStep = true;\n            }\n\n            if (isLastStep) {\n                break;\n            }\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..2ea39f49a 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,60 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n+    public void integrateUntil(final double t) {\n+\n+        final double[] y = new double[ode.getDimension()];\n+\n+        final double t0 = time;\n+        final double sign = t >= t0 ? 1.0 : -1.0;\n+        while ((sign * (time - t)) < 0) {\n+            \n+            final double t1 = Math.min(t, time + sign * maxStep);\n+            final double dt = t1 - time;\n+            \n+            // advance the ODE state up to t1\n+            final int k = integrator.integrate(ode, time, y, t1, y);\n+            \n+            time = integrator.getCurrentStepStart();\n+            System.arraycopy(y, 0, odeCurrentState, 0, y.length);\n+\n+            if (k < 0) {\n+                // integration failure\n+                throw new RuntimeException(\"Integration failed at t=\" + time);\n+            } else if (k == 0) {\n+                // constant step size, ODE solved successfully\n+                for (final StepHandler handler : stepHandlers) {\n+                    handler.handleStep(new StepInterpolator(t0, t1, y, y, odeCurrentState, odeCurrentState, ode, isLastStep), isLastStep);\n                 }\n-\n-            });\n-\n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n+            } else {\n+                // adaptive step size, handle intermediate sub-steps\n+                final StepInterpolator interpolator = integrator.getInterpolator();\n+                final boolean isLastStep = (sign * (t1 - t)) >= 0;\n+                interpolator.setInterpolatedTime(time);\n+                for (final StepHandler handler : stepHandlers) {\n+                    handler.handleStep(interpolator, false);\n                 }\n-            }\n-\n-            while (!occuringEvents.isEmpty()) {\n-\n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n-\n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n-\n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n-\n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n+                while ((interpolator.getCurrentTime() - t1) * interpolator.getNextTime() <= 0) {\n+                    interpolator.setInterpolatedTime(t1);\n+                    for (final StepHandler handler : stepHandlers) {\n+                        handler.handleStep(interpolator, false);\n+                    }\n+                }\n+                interpolator.setInterpolatedTime(t1);\n                 for (final StepHandler handler : stepHandlers) {\n                     handler.handleStep(interpolator, isLastStep);\n                 }\n+            }\n+            \n+            if (stopCondition != null && stopCondition.evaluate(this)) {\n+                isLastStep = true;\n+            }\n+\n+            if (isLastStep) {\n+                break;\n+            }\n+        }\n+    }\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}