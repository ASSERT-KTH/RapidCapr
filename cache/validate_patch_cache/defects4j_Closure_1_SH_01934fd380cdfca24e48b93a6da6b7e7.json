{
    "patch": "      Node fnNode = fnScope.getRootNode();\n      Preconditions.checkState(fnNode.isFunction());\n      if (NodeUtil.isGetOrSetKey(fnNode.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n      }\n\n      Node args = getFunctionArgs(fnNode);\n      boolean hasRestArg = NodeUtil.getRestIndex(args) != -1;\n      boolean modifyInvokes = modifyCallSites &&\n          callSiteOptimizationShouldModifyCall(fnScope.getRootVar(), info.scope);\n      if (!modifyInvokes) {\n        // Strip unreferenced args from the end of the list.\n        Node lastArg;\n        while ((lastArg = args.getLastChild()) != null) {\n          if (!NodeUtil.isRest(lastArg) && !isReferenced(fnScope, lastArg)) {\n            args.removeChild(lastArg);\n            compiler.reportChangeToEnclosingScope(args);\n          } else {\n            break;\n          }\n        }\n      } else {\n        referencedArgs.addAll(referenced);\n        if (hasRestArg) {\n          callSiteOptimize(fnNode, referencedArgs, true, info);\n        }\n        if (referencedArgs.size() < args.getChildCount()) {\n          // Remove the args that are unreferenced from the end of the list.\n          for (int i = args.getChildCount() - 1; i >= 0; i--) {\n            Node arg = args.getChildAtIndex(i);\n            if (!referencedArgs.contains(fnScope.getVar(arg.getString()))) {\n              args.removeChildAtIndex(i);\n              compiler.reportChangeToEnclosingScope(args);\n            }\n          }\n        }\n        callSiteOptimize(fnNode, referencedArgs, false, info);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..cd595952 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,44 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+      Node fnNode = fnScope.getRootNode();\n+      Preconditions.checkState(fnNode.isFunction());\n+      if (NodeUtil.isGetOrSetKey(fnNode.getParent())) {\n+        // The parameters object literal setters can not be removed.\n+        return;\n+      }\n+\n+      Node args = getFunctionArgs(fnNode);\n+      boolean hasRestArg = NodeUtil.getRestIndex(args) != -1;\n+      boolean modifyInvokes = modifyCallSites &&\n+          callSiteOptimizationShouldModifyCall(fnScope.getRootVar(), info.scope);\n+      if (!modifyInvokes) {\n+        // Strip unreferenced args from the end of the list.\n+        Node lastArg;\n+        while ((lastArg = args.getLastChild()) != null) {\n+          if (!NodeUtil.isRest(lastArg) && !isReferenced(fnScope, lastArg)) {\n+            args.removeChild(lastArg);\n+            compiler.reportChangeToEnclosingScope(args);\n+          } else {\n+            break;\n+          }\n+        }\n+      } else {\n+        referencedArgs.addAll(referenced);\n+        if (hasRestArg) {\n+          callSiteOptimize(fnNode, referencedArgs, true, info);\n+        }\n+        if (referencedArgs.size() < args.getChildCount()) {\n+          // Remove the args that are unreferenced from the end of the list.\n+          for (int i = args.getChildCount() - 1; i >= 0; i--) {\n+            Node arg = args.getChildAtIndex(i);\n+            if (!referencedArgs.contains(fnScope.getVar(arg.getString()))) {\n+              args.removeChildAtIndex(i);\n+              compiler.reportChangeToEnclosingScope(args);\n+            }\n+          }\n+        }\n+        callSiteOptimize(fnNode, referencedArgs, false, info);\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}