{
    "patch": "        if (val.startsWith(\"+\")) {\n            val = val.substring(1);\n        }\n        if (NumberUtils.isNumber(val)) {\n            // Performance optimisation for integers\n            if (val != null) {\n                if (val.length() > 1 && val.startsWith(\"0\") && !val.startsWith(\"0.\")) {\n                    // Octal or hex (do not support negatives - too easily confused)\n                    char firstSigDigit = val.charAt(1);\n                    if (firstSigDigit == 'x' || firstSigDigit == 'X') {\n                        try {\n                            return createInteger(val);\n                        } catch (NumberFormatException e) {\n                            // NOPMD - ignore\n                        }\n                    } else {\n                        try {\n                            return createInteger(Integer.parseInt(val, 8));\n                        } catch (NumberFormatException e) {\n                            // NOPMD - ignore\n                        }\n                    }\n                }\n                char lastChar = val.charAt(val.length() - 1);\n                int decPos = val.indexOf('.');\n                int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n                if (expPos > 0) {\n                    if (val.indexOf(\"e.\") > -1 || val.indexOf(\"E.\") > -1) {\n                        return null;\n                    }\n                }\n                if (decPos > -1) {\n                    if (decPos != val.length() - 1 || val.lastIndexOf('.') != val.indexOf('.')) {\n                        return null;\n                    }\n                    if (expPos > -1 && expPos < val.length() - 1) {\n                        if (val.indexOf(\".\", expPos) > -1) {\n                            return null;\n                        }\n                    }\n                }\n                if (!Character.isDigit(lastChar)) {\n                    if (expPos > 0 && expPos < val.length() - 1) {\n                        String exp = val.substring(expPos + 1, val.length() - 1);\n                        try {\n                            createInteger(exp);\n                            return null;\n                        } catch (NumberFormatException e) {\n                            // NOPMD - ignore\n                        }\n                    }\n                    switch (lastChar) {\n                        case 'l':\n                        case 'L':\n                            if (decPos == -1 && expPos == -1) {\n                                return createLong(val);\n                            }\n                            return null;\n                        case 'f':\n                        case 'F':\n                            if (decPos == -1) {\n                                if (expPos == -1) {\n                                    return createFloat(val + \"f\");\n                                }\n                                return createFloat(val.substring(0, expPos) + \"f\");\n                            }\n                            if (val.indexOf(\"f\") != val.lastIndexOf(\"f\")) {\n                                return null;\n                            }\n                            return createFloat(val);\n                        case 'd':\n                        case 'D':\n                            if (expPos == -1) {\n                                if (decPos == -1) {\n                                    return createDouble(val);\n                                }\n                                return createDouble(val.substring(0, decPos) + \"d\");\n                            }\n                            if (val.indexOf(\"d\") != val.lastIndexOf(\"d\")) {\n                                return null;\n                            }\n                            return createDouble(val);\n\n                        default:\n                            return null;\n                    }\n                } else {\n                    if (expPos > 0 && expPos < val.length() - 1) {\n                        String exp = val.substring(expPos + 1);\n                        try {\n                            createInteger(exp);\n                            return null;\n                        } catch (NumberFormatException e) {\n                            // NOPMD - ignore\n                        }\n                    }\n                    if (decPos == -1) {\n                        if (expPos == -1) {\n                            return createInteger(val);\n                        }\n                        return createInteger(val.substring(0, expPos));\n                    }\n                    if (decPos == val.lastIndexOf('.')) {\n                        int i = val.length() - decPos - 1;\n                        if (i <= 7) {\n                            return createFloat(val);\n                        } else {\n                            return createDouble(val);\n                        }\n                    } else {\n                        return null;\n                    }\n                }\n            }\n            throw new NumberFormatException(\"\\\"\" + val + \"\\\" is not a valid number.\");\n        }\n        return null;",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex 18a05efe..0ead1496 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -142,6 +142,123 @@ public final class NumberUtils {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n+        if (val.startsWith(\"+\")) {\n+            val = val.substring(1);\n+        }\n+        if (NumberUtils.isNumber(val)) {\n+            // Performance optimisation for integers\n+            if (val != null) {\n+                if (val.length() > 1 && val.startsWith(\"0\") && !val.startsWith(\"0.\")) {\n+                    // Octal or hex (do not support negatives - too easily confused)\n+                    char firstSigDigit = val.charAt(1);\n+                    if (firstSigDigit == 'x' || firstSigDigit == 'X') {\n+                        try {\n+                            return createInteger(val);\n+                        } catch (NumberFormatException e) {\n+                            // NOPMD - ignore\n+                        }\n+                    } else {\n+                        try {\n+                            return createInteger(Integer.parseInt(val, 8));\n+                        } catch (NumberFormatException e) {\n+                            // NOPMD - ignore\n+                        }\n+                    }\n+                }\n+                char lastChar = val.charAt(val.length() - 1);\n+                int decPos = val.indexOf('.');\n+                int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n+                if (expPos > 0) {\n+                    if (val.indexOf(\"e.\") > -1 || val.indexOf(\"E.\") > -1) {\n+                        return null;\n+                    }\n+                }\n+                if (decPos > -1) {\n+                    if (decPos != val.length() - 1 || val.lastIndexOf('.') != val.indexOf('.')) {\n+                        return null;\n+                    }\n+                    if (expPos > -1 && expPos < val.length() - 1) {\n+                        if (val.indexOf(\".\", expPos) > -1) {\n+                            return null;\n+                        }\n+                    }\n+                }\n+                if (!Character.isDigit(lastChar)) {\n+                    if (expPos > 0 && expPos < val.length() - 1) {\n+                        String exp = val.substring(expPos + 1, val.length() - 1);\n+                        try {\n+                            createInteger(exp);\n+                            return null;\n+                        } catch (NumberFormatException e) {\n+                            // NOPMD - ignore\n+                        }\n+                    }\n+                    switch (lastChar) {\n+                        case 'l':\n+                        case 'L':\n+                            if (decPos == -1 && expPos == -1) {\n+                                return createLong(val);\n+                            }\n+                            return null;\n+                        case 'f':\n+                        case 'F':\n+                            if (decPos == -1) {\n+                                if (expPos == -1) {\n+                                    return createFloat(val + \"f\");\n+                                }\n+                                return createFloat(val.substring(0, expPos) + \"f\");\n+                            }\n+                            if (val.indexOf(\"f\") != val.lastIndexOf(\"f\")) {\n+                                return null;\n+                            }\n+                            return createFloat(val);\n+                        case 'd':\n+                        case 'D':\n+                            if (expPos == -1) {\n+                                if (decPos == -1) {\n+                                    return createDouble(val);\n+                                }\n+                                return createDouble(val.substring(0, decPos) + \"d\");\n+                            }\n+                            if (val.indexOf(\"d\") != val.lastIndexOf(\"d\")) {\n+                                return null;\n+                            }\n+                            return createDouble(val);\n+\n+                        default:\n+                            return null;\n+                    }\n+                } else {\n+                    if (expPos > 0 && expPos < val.length() - 1) {\n+                        String exp = val.substring(expPos + 1);\n+                        try {\n+                            createInteger(exp);\n+                            return null;\n+                        } catch (NumberFormatException e) {\n+                            // NOPMD - ignore\n+                        }\n+                    }\n+                    if (decPos == -1) {\n+                        if (expPos == -1) {\n+                            return createInteger(val);\n+                        }\n+                        return createInteger(val.substring(0, expPos));\n+                    }\n+                    if (decPos == val.lastIndexOf('.')) {\n+                        int i = val.length() - decPos - 1;\n+                        if (i <= 7) {\n+                            return createFloat(val);\n+                        } else {\n+                            return createDouble(val);\n+                        }\n+                    } else {\n+                        return null;\n+                    }\n+                }\n+            }\n+            throw new NumberFormatException(\"\\\"\" + val + \"\\\" is not a valid number.\");\n+        }\n+        return null;\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear ",
    "result_reason": "error: method createInteger in class NumberUtils cannot be applied to given types;",
    "test_result": "ERROR"
}