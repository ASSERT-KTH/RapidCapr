{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Pair;\nimport org.apache.commons.math3.util.FastMath;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\npublic class RegularizedGamma {\n    /**\n     * Default accuracy for algorithms.\n     */\n    public static final double DEFAULT_EPSILON = 10e-15;\n\n    /**\n     * lngamma(z + a) at a = 0, -1, -2, ...\n     */\n    private final Map<Integer, Double> lngammaMap = new HashMap<>();\n\n    private final double epsilon;\n\n    /**\n     * Create a new RegularizedGamma with the default accuracy.\n     */\n    public RegularizedGamma() {\n        this(DEFAULT_EPSILON);\n    }\n\n    /**\n     * Create a new RegularizedGamma with a custom accuracy. The accuracy is used\n     * as a tolerance value for convergence checks in the regularized gamma algorithms.\n     * \n     * @param epsilon  the desired accuracy\n     */\n    public RegularizedGamma(double epsilon) {\n        this.epsilon = epsilon;\n    }\n\n    /**\n     * Compute the regularized gamma function P(a, z).\n     * \n     * @param a  the shape parameter\n     * @param z  the integration parameter\n     * @return P(a, z)\n     */\n    public double gamma(double a, double z) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive.\");\n        }\n        if (z < 0) {\n            throw new IllegalArgumentException(\"z cannot be negative.\");\n        }\n\n        if (z == 0) {\n            return 0.0;\n        }\n        if (z >= a + 1) {\n            // From the definition:\n            // P(a,z) = 1 - I_x(a,b), x = z/a , b = 1-x\n            // see http://en.wikipedia.org/wiki/Regularized_Gamma_function\n            final double x = a / (z + a - 0.5);\n            final double b = 1 - x;\n            return 1 - Gamma.regularizedGammaQ(a, z, epsilon, 1000);\n        }\n\n        // Now z is positive but smaller than a+1.\n        // Use the series representation directly.\n        if (!Double.isInfinite(a)) {\n            double term = 1 / a;\n            double sum = term;\n            while (FastMath.abs(term / sum) > epsilon) {\n                sum += term *= (z / (++a));\n            }\n            return sum * FastMath.exp(-z + a * FastMath.log(z) - Gamma.logGamma(a));\n        } else {\n            // Special case: a is infinite, so the series representation won't work.\n            // We use the reflection formula instead:\n            //     Q(\u221e, z) = \u0393(\u221e, z) / \u0393(\u221e) = 0\n            //     P(\u221e, z) = 1 - Q(\u221e, z) = 1\n            // http://en.wikipedia.org/wiki/Regularized_Gamma_function\n            return 1.0;\n        }\n    }\n\n    /**\n     * Compute the natural logarithm of the regularized gamma function ln(P(a, z)).\n     * \n     * @param a  the shape parameter\n     * @param z  the integration parameter\n     * @return ln(P(a, z))\n     */\n    public double logGamma(double a, double z) {\n        if (z < 0) {\n            throw new IllegalArgumentException(\"z cannot be negative.\");\n        }\n\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive.\");\n        }\n        if (a == 1) {\n            return -z;\n        }\n\n        if (z == 0) {\n            return 0.0;\n        }\n\n        if (z >= a + 1) {\n            // From the definition:\n            // P(a,z) = 1 - I_x(a,b), x = z/a , b = 1-x\n            // ln(P(a,z)) = ln(1 - exp(ln(I_x(a,b))))\n            // see http://en.wikipedia.org/wiki/Regularized_Gamma_function\n            final double x = a / (z + a - 0.5);\n            final double b = 1 - x;\n            return FastMath.log(1 - Gamma.regularizedGammaQ(a, z, epsilon, 1000));\n        }\n\n        // Now z is positive but smaller than a+1.\n        // Use the series representation directly.\n        if (!Double.isInfinite(a)) {\n            double term = 1 / a;\n            double sum = term;\n            while (FastMath.abs(term / sum) > epsilon) {\n                sum += term *= (z / (++a));\n            }\n            return FastMath.log(sum) - z + a * FastMath.log(z) - Gamma.logGamma(a);\n        } else {\n            // Special case: a is infinite, so the series representation won't work.\n            // We use the reflection formula instead:\n            //     Q(\u221e, z) = \u0393(\u221e, z) / \u0393(\u221e) = 0\n            //     P(\u221e, z) = 1 - Q(\u221e, z) = 1\n            // http://en.wikipedia.org/wiki/Regularized_Gamma_function\n            return 0.0;\n        }\n    }\n\n    /**\n     * Compute the incomplete gamma function P(a, x).\n     * \n     * @param a the shape parameter\n     * @param x  the integration parameter\n     * @return P(a, x)\n     */\n    public double incompleteGamma(double a, double x) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive.\");\n        }\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x cannot be negative.\");\n        }\n\n        return Gamma.regularizedGammaP(a, x, epsilon, 1000);\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..a04eedee2 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,160 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.util.FastMath;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+public class RegularizedGamma {\n+    /**\n+     * Default accuracy for algorithms.\n+     */\n+    public static final double DEFAULT_EPSILON = 10e-15;\n+\n+    /**\n+     * lngamma(z + a) at a = 0, -1, -2, ...\n+     */\n+    private final Map<Integer, Double> lngammaMap = new HashMap<>();\n+\n+    private final double epsilon;\n+\n+    /**\n+     * Create a new RegularizedGamma with the default accuracy.\n+     */\n+    public RegularizedGamma() {\n+        this(DEFAULT_EPSILON);\n+    }\n+\n+    /**\n+     * Create a new RegularizedGamma with a custom accuracy. The accuracy is used\n+     * as a tolerance value for convergence checks in the regularized gamma algorithms.\n+     * \n+     * @param epsilon  the desired accuracy\n+     */\n+    public RegularizedGamma(double epsilon) {\n+        this.epsilon = epsilon;\n+    }\n+\n+    /**\n+     * Compute the regularized gamma function P(a, z).\n+     * \n+     * @param a  the shape parameter\n+     * @param z  the integration parameter\n+     * @return P(a, z)\n+     */\n+    public double gamma(double a, double z) {\n+        if (a <= 0) {\n+            throw new IllegalArgumentException(\"a must be positive.\");\n+        }\n+        if (z < 0) {\n+            throw new IllegalArgumentException(\"z cannot be negative.\");\n+        }\n+\n+        if (z == 0) {\n+            return 0.0;\n+        }\n+        if (z >= a + 1) {\n+            // From the definition:\n+            // P(a,z) = 1 - I_x(a,b), x = z/a , b = 1-x\n+            // see http://en.wikipedia.org/wiki/Regularized_Gamma_function\n+            final double x = a / (z + a - 0.5);\n+            final double b = 1 - x;\n+            return 1 - Gamma.regularizedGammaQ(a, z, epsilon, 1000);\n+        }\n+\n+        // Now z is positive but smaller than a+1.\n+        // Use the series representation directly.\n+        if (!Double.isInfinite(a)) {\n+            double term = 1 / a;\n+            double sum = term;\n+            while (FastMath.abs(term / sum) > epsilon) {\n+                sum += term *= (z / (++a));\n+            }\n+            return sum * FastMath.exp(-z + a * FastMath.log(z) - Gamma.logGamma(a));\n+        } else {\n+            // Special case: a is infinite, so the series representation won't work.\n+            // We use the reflection formula instead:\n+            //     Q(\u221e, z) = \u0393(\u221e, z) / \u0393(\u221e) = 0\n+            //     P(\u221e, z) = 1 - Q(\u221e, z) = 1\n+            // http://en.wikipedia.org/wiki/Regularized_Gamma_function\n+            return 1.0;\n+        }\n+    }\n+\n+    /**\n+     * Compute the natural logarithm of the regularized gamma function ln(P(a, z)).\n+     * \n+     * @param a  the shape parameter\n+     * @param z  the integration parameter\n+     * @return ln(P(a, z))\n+     */\n+    public double logGamma(double a, double z) {\n+        if (z < 0) {\n+            throw new IllegalArgumentException(\"z cannot be negative.\");\n+        }\n+\n+        if (a <= 0) {\n+            throw new IllegalArgumentException(\"a must be positive.\");\n+        }\n+        if (a == 1) {\n+            return -z;\n+        }\n+\n+        if (z == 0) {\n+            return 0.0;\n+        }\n+\n+        if (z >= a + 1) {\n+            // From the definition:\n+            // P(a,z) = 1 - I_x(a,b), x = z/a , b = 1-x\n+            // ln(P(a,z)) = ln(1 - exp(ln(I_x(a,b))))\n+            // see http://en.wikipedia.org/wiki/Regularized_Gamma_function\n+            final double x = a / (z + a - 0.5);\n+            final double b = 1 - x;\n+            return FastMath.log(1 - Gamma.regularizedGammaQ(a, z, epsilon, 1000));\n+        }\n+\n+        // Now z is positive but smaller than a+1.\n+        // Use the series representation directly.\n+        if (!Double.isInfinite(a)) {\n+            double term = 1 / a;\n+            double sum = term;\n+            while (FastMath.abs(term / sum) > epsilon) {\n+                sum += term *= (z / (++a));\n+            }\n+            return FastMath.log(sum) - z + a * FastMath.log(z) - Gamma.logGamma(a);\n+        } else {\n+            // Special case: a is infinite, so the series representation won't work.\n+            // We use the reflection formula instead:\n+            //     Q(\u221e, z) = \u0393(\u221e, z) / \u0393(\u221e) = 0\n+            //     P(\u221e, z) = 1 - Q(\u221e, z) = 1\n+            // http://en.wikipedia.org/wiki/Regularized_Gamma_function\n+            return 0.0;\n+        }\n+    }\n+\n+    /**\n+     * Compute the incomplete gamma function P(a, x).\n+     * \n+     * @param a the shape parameter\n+     * @param x  the integration parameter\n+     * @return P(a, x)\n+     */\n+    public double incompleteGamma(double a, double x) {\n+        if (a <= 0) {\n+            throw new IllegalArgumentException(\"a must be positive.\");\n+        }\n+        if (x < 0) {\n+            throw new IllegalArgumentException(\"x cannot be negative.\");\n+        }\n+\n+        return Gamma.regularizedGammaP(a, x, epsilon, 1000);\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}