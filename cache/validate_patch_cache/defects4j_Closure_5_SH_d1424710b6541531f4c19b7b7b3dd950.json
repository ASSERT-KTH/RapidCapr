{
    "patch": "import com.google.javascript.jscomp.ControlFlowAnalysis;\nimport com.google.javascript.jscomp.ControlFlowGraph;\nimport com.google.javascript.jscomp.CfgReachabilityAnalyzer;\nimport com.google.javascript.jscomp.CfgReachabilityAnalyzer.NoSideEffectCallAnalyzer;\nimport com.google.javascript.jscomp.CfgReachabilityAnalyzer.ReachingCallback;\nimport com.google.javascript.jscomp.CfgReachabilityAnalyzer.VarInfo;\nimport com.google.javascript.jscomp.Scope;\nimport com.google.javascript.jscomp.Scope.Var;\n\npublic class MinimizeExitPoints implements CompilerPass {\n\n  AbstractCompiler compiler;\n\n  public MinimizeExitPoints(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  public void process(Node externs, Node jsRoot) {\n    NodeTraversal.traverseEs6(compiler, jsRoot, new Callback(compiler));\n  }\n\n  private static class Callback extends NodeTraversal.AbstractPostOrderCallback {\n    private final AbstractCompiler compiler;\n\n    Callback(AbstractCompiler compiler) {\n      this.compiler = compiler;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isFunction()) {\n        visitFunction(t, n);\n      }\n      if (n.isBlock()) {\n        visitBlock(t, n);\n      }\n    }\n\n    private void visitFunction(NodeTraversal t, Node fn) {\n      // When a function is minimized, we'll try to hoist the return statements\n      // to the end of the function. If that's done, the function may have\n      // multiple exit points, and thus its CFG may become disconnected.\n      //\n      // To mitigate this, we use the CFA to remove all return statements\n      // until we know exactly how many exit points remain.\n      // Then, we'll feed the trimmed function to CFA to disconnect the CFG.\n      // After that we create a ReturnInstrumentation object to instrument\n      // the return statements based on the exact number of exit points.\n      //\n      // FunctionLiteral\n      //   FUNCTION\n      //   NAME opt\n      //   PARAM_LIST\n      //   BLOCK\n\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      cfa.process(null, fn);\n\n      ControlFlowGraph<Node> cfgForFnBody = cfa.getCfg();\n\n      int maxExitPointsToRemove = CountExitPointsInFunction.count(fn) - 1;\n      if (maxExitPointsToRemove <= 0) {\n        // Nothing to do, only one way out\n        return;\n      }\n      // Now, minimize the number of exit points by removing all return\n      // statements until we have to.\n      boolean[] shouldRemoveReturn = computeReturnInstrumentation(fn, maxExitPointsToRemove);\n      rewriteFunctionBody(fn, shouldRemoveReturn);\n\n      // Keep the original scope and hoist the whole function.\n      Scope fnScope = t.getScope();\n      Scope blockScope = fnScope.getBlockScope();\n      Node innerBlock = NodeUtil.getFunctionBody(fn);\n      Node outerBlock = innerBlock.getParent();\n      Preconditions.checkState(outerBlock != null && outerBlock.isBlock());\n      int functionIndex = NodeUtil.getFunctionIndex(outerBlock, innerBlock);\n\n      // Now, get the minified version of the function to disconnect the CFG.\n      Node fnNode = new MinimizeExitPointsCodeGenerator(compiler).createMinifiedFnNode(fn);\n\n      ControlFlowGraph<Node> cfgForMinimizedFn =\n          cfgForMinimizedFunction(fnNode, blockScope, compiler);\n      ReachingCallbackImpl reachingCallback = new ReachingCallbackImpl(cfgForMinimizedFn);\n      CfgReachabilityAnalyzer cfgReachabilityAnalyzer =\n          new CfgReachabilityAnalyzer(cfgForMinimizedFn, reachingCallback);\n      cfgReachabilityAnalyzer.analyze();\n\n      // And finally, instrument the returns.\n\n      int exitPoints = countExitPoints(cfgForMinimizedFn, reachingCallback, fnNode);\n      ReturnInstrumentation ri = new ReturnInstrumentation(exitPoints, shouldRemoveReturn);\n      ri.processExitPointsOfFunction(fnNode, cfgForMinimizedFn, blockScope);\n\n      // Placeholder to lowercase the cost of decompilation.\n      if (NodeUtil.isFunctionExpression(fn)) {\n        fnNode.setOnlyCollapseKeys();\n        NodeUtil.markFunctionsDeleted(fnNode, compiler.getCompilerOptions());\n        NodeUtil.markFunctionsDeleted(fnNode, ControlFlowAnalysis.getTerminationStatement(compiler));\n      }\n\n      // Replace the original function.\n      outerBlock.removeChild(innerBlock);\n      outerBlock.addChildAtIndex(fnNode, functionIndex);\n      NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.RETURN_STATEMENT);\n    }\n\n    private void visitBlock(NodeTraversal t, Node n) {\n      if (t.getScope().getBlockDepth() == 1) {\n        if (NodeUtil.referencesThis(n)) {\n          return;\n        }\n\n        boolean needsReturn = true;\n\n        for (Node child : n.children()) {\n          int type = child.getType();\n          if (type == Token.RETURN) {\n            needsReturn = false;\n            break;\n          }\n\n          if (NodeUtil.isStatementBlock(child)) {\n            visitBlock(t, child);\n            if (!needsReturn) {\n              break;\n            }\n          } else if (NodeUtil.isControlStructure(child) || NodeUtil.isLoopStructure(child)) {\n            if (child.hasChildren()) {\n              visitBlock(t, child.getFirstChild());\n              if (!needsReturn) {\n                break;\n              }\n            }\n          }\n        }\n\n        if (needsReturn) {\n          Node lastChild = n.getLastChild();\n          if (lastChild != null && lastChild.isFunction()) {\n            NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.RETURN_STATEMENT);\n            n.addChildToFront(IR.returnNode().useSourceInfoFrom(n));\n          }\n        }\n      }\n    }\n\n    private ControlFlowGraph<Node> cfgForMinimizedFunction(\n        Node fnNode, Scope functionBodyScope, AbstractCompiler compiler) {\n\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      Node body = NodeUtil.getFunctionBody(fnNode);\n      cfa.process(null, body);\n\n      ControlFlowGraph<Node> cfg = cfa.getCfg();\n\n      // The CFG we got might have nodes that belong to an outer function, so\n      // we need to check that and remove those nodes.\n      if (!cfg.isFrozen()) {\n        throw new IllegalStateException(\"The CFG should be frozen by now\");\n      }\n      ControlFlowGraph<Node> cfgForThisFunction = cfg.splitAtFunction(body);\n\n      // Add info about the vars to the control flow graph.\n      Set<String> varsInFunction = new HashSet<>();\n      Scope functionScope = functionBodyScope.getParent();\n      for (Var var : functionScope.getVars()) {\n        if (!var.isParam()) {\n          varsInFunction.add(var.getName());\n        }\n      }\n      addVarReachabilityInfo(compiler, cfgForThisFunction.getEntry(), varsInFunction);\n      for (ControlFlowGraph<Node>.Node cfgNode : cfgForThisFunction.getNodes()) {\n        Node n = cfgNode.getValue();\n        if (n.isName() && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n          cfgNode.putUserInfo(new VarInfo(n.getString(), n, functionScope));\n        }\n      }\n      return cfgForThisFunction;\n    }\n\n    /**\n     * Computes the return instrumentation for a function.\n     *\n     * @param fn The function node.\n     * @param maxReturnStatementsToRemove The maximum number of return statements\n     *     that can be removed.\n     * @return An array of booleans, stating for each return statement whether it should be removed\n     *     or not.\n     */\n    private boolean[] computeReturnInstrumentation(Node fn, int maxReturnStatementsToRemove) {\n      NodeUtil.ClosureRestatement restatement =\n          new NodeUtil.ClosureRestatement(fn, maxReturnStatementsToRemove);\n\n      // First decision for the return statement will not change.\n      boolean[] shouldRemoveReturn = new boolean[restatement.getReturnStatements().size()];\n      if (shouldRemoveReturn.length == 0) {\n        // Nothing to do, only one way out\n        return shouldRemoveReturn;\n      }\n      shouldRemoveReturn[0] = false;\n\n      // Table of optimization step (aka branch index) => side-effects map.\n      HashMap<Integer, BitSet> optStepToSideEffects = new HashMap<>();\n\n      // Table of switch statement condition values => optimization steps.\n      HashMap<Long, List<Integer>> switchValuesToOptSteps = new HashMap<>();\n\n      {\n        Node lastExpr = restatement.getLastExpression();\n        Node scope = fn.getGrandparent();\n        if (lastExpr != null && !NodeUtil.mayHaveSideEffects(lastExpr, scope, compiler)) {\n          // If the last statement of the function does not have side effects,\n          // and there are return statements in the function\n          // body, then we'll need to execute them all.\n          //\n          // This is accomplished by the first element of shouldRemoveReturn,\n          // which is initialized to false.\n          return shouldRemoveReturn;\n        }\n      }\n\n\n      // We can't just remove a return statement if it's in a block that has a\n      // catch or finally block attached to it.\n      checkLabels:\n      for (List<Node> block : restatement.getCfgBlocks()) {\n        boolean hasFinallyOrCatch = false;\n        blockTraversal:\n        for (Node blockNode : block) {\n          Node parent = blockNode.getParent();\n          if (parent == null) {\n            continue blockTraversal;\n          }\n          switch (parent.getType()) {\n            case Token.CATCH:\n            case Token.FINALLY:\n              hasFinallyOrCatch = true;\n              break checkLabels;\n            case Token.TRY:\n              if (parent.getChildCount() == 3) {\n                Node finallyBlock = parent.getLastChild();\n                if (finallyBlock.isBlock()) {\n                  Node finallyChild = finallyBlock.getFirstChild();\n                  if (finallyChild != null) {\n                    Node finallyChildFirstToken = finallyChild.getFirstChild();\n                    if (finallyChildFirstToken != null &&\n                        finallyChildFirstToken.isBlock()) {\n                      hasFinallyOrCatch = true;\n                      break checkLabels;\n                    }\n                  }\n                }\n              }\n              break; // pretend there was a fall-through\n            default:\n              break;\n          }\n        }\n\n        if (hasFinallyOrCatch) {\n          for (Node exitPoint : restatement.getExitPoints(block)) {\n            Node parent = exitPoint.getParent();\n            if (exitPoint.getType() == Token.RETURN && parent.getType() == Token.BLOCK) {\n              Node grandparent = parent.getParent();\n              boolean canRemove = (grandparent != null\n                  && grandparent.getType() != Token.FUNCTION\n                  && grandparent.getType() != Token.SCRIPT);\n              // If the parent is labeled and the label is used, we cannot remove\n              // the return statement.\n              if (canRemove && parent.isLabel()) {\n                canRemove = NodeUtil.isLabelNeverUsed(parent);\n              }\n              if (canRemove) {\n                shouldRemoveReturn[restatement.getReturnStatementIndex(exitPoint)] = true;\n              }\n            }\n          }\n        }\n      }\n\n      // Finally, do dead code elimination on the computed CFG.\n      // Dead branches (i.e. branches without side-effects) will be removed.\n      // This step heavily simplifies the computations done below.\n\n      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n      cfa.process(null, NodeUtil.getFunctionBody(fn));\n      ControlFlowGraph<Node> cfg = cfa.getCfg();\n\n\n      for (int i = 1; i < shouldRemoveReturn.length; i++) {\n        List<Integer> optStepsForValue = null;\n        Node returnStatement = restatement.getReturnStatements().get(i);\n        Node returnExpr;\n        Node switchCase = null;\n        boolean switchCaseIsDefaultValue = false;\n        List<Node> switchGuardExprs = null;\n        List<List<Node>> switchCases = null;\n        boolean switchHasDefault = false;\n\n        switch (returnStatement.getParent().getType()) {\n          case Token.IF: {\n            Node ifParent = returnStatement.getParent();\n            BitSet sideEffects = new BitSet();\n            shouldRemoveReturn[i] =\n                canRemoveReturnHelper(restatement.getCfgBlock(returnStatement.getParent()),\n                    shouldRemoveReturn, sideEffects);\n            optStepToSideEffects.put(i, sideEffects);\n            break;\n          }\n          case Token.RETURN:\n            // First return statement can't be optimized away\n            break;\n          case Token.SWITCH:\n            Node switchNode = returnStatement.getParent();\n            switchCases = new ArrayList<>();  // will get filled in later.\n            switchGuardExprs = new ArrayList<>();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..594677f1 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,323 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+import com.google.javascript.jscomp.ControlFlowAnalysis;\n+import com.google.javascript.jscomp.ControlFlowGraph;\n+import com.google.javascript.jscomp.CfgReachabilityAnalyzer;\n+import com.google.javascript.jscomp.CfgReachabilityAnalyzer.NoSideEffectCallAnalyzer;\n+import com.google.javascript.jscomp.CfgReachabilityAnalyzer.ReachingCallback;\n+import com.google.javascript.jscomp.CfgReachabilityAnalyzer.VarInfo;\n+import com.google.javascript.jscomp.Scope;\n+import com.google.javascript.jscomp.Scope.Var;\n+\n+public class MinimizeExitPoints implements CompilerPass {\n+\n+  AbstractCompiler compiler;\n+\n+  public MinimizeExitPoints(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  public void process(Node externs, Node jsRoot) {\n+    NodeTraversal.traverseEs6(compiler, jsRoot, new Callback(compiler));\n+  }\n+\n+  private static class Callback extends NodeTraversal.AbstractPostOrderCallback {\n+    private final AbstractCompiler compiler;\n+\n+    Callback(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isFunction()) {\n+        visitFunction(t, n);\n+      }\n+      if (n.isBlock()) {\n+        visitBlock(t, n);\n+      }\n+    }\n+\n+    private void visitFunction(NodeTraversal t, Node fn) {\n+      // When a function is minimized, we'll try to hoist the return statements\n+      // to the end of the function. If that's done, the function may have\n+      // multiple exit points, and thus its CFG may become disconnected.\n+      //\n+      // To mitigate this, we use the CFA to remove all return statements\n+      // until we know exactly how many exit points remain.\n+      // Then, we'll feed the trimmed function to CFA to disconnect the CFG.\n+      // After that we create a ReturnInstrumentation object to instrument\n+      // the return statements based on the exact number of exit points.\n+      //\n+      // FunctionLiteral\n+      //   FUNCTION\n+      //   NAME opt\n+      //   PARAM_LIST\n+      //   BLOCK\n+\n+      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+      cfa.process(null, fn);\n+\n+      ControlFlowGraph<Node> cfgForFnBody = cfa.getCfg();\n+\n+      int maxExitPointsToRemove = CountExitPointsInFunction.count(fn) - 1;\n+      if (maxExitPointsToRemove <= 0) {\n+        // Nothing to do, only one way out\n+        return;\n+      }\n+      // Now, minimize the number of exit points by removing all return\n+      // statements until we have to.\n+      boolean[] shouldRemoveReturn = computeReturnInstrumentation(fn, maxExitPointsToRemove);\n+      rewriteFunctionBody(fn, shouldRemoveReturn);\n+\n+      // Keep the original scope and hoist the whole function.\n+      Scope fnScope = t.getScope();\n+      Scope blockScope = fnScope.getBlockScope();\n+      Node innerBlock = NodeUtil.getFunctionBody(fn);\n+      Node outerBlock = innerBlock.getParent();\n+      Preconditions.checkState(outerBlock != null && outerBlock.isBlock());\n+      int functionIndex = NodeUtil.getFunctionIndex(outerBlock, innerBlock);\n+\n+      // Now, get the minified version of the function to disconnect the CFG.\n+      Node fnNode = new MinimizeExitPointsCodeGenerator(compiler).createMinifiedFnNode(fn);\n+\n+      ControlFlowGraph<Node> cfgForMinimizedFn =\n+          cfgForMinimizedFunction(fnNode, blockScope, compiler);\n+      ReachingCallbackImpl reachingCallback = new ReachingCallbackImpl(cfgForMinimizedFn);\n+      CfgReachabilityAnalyzer cfgReachabilityAnalyzer =\n+          new CfgReachabilityAnalyzer(cfgForMinimizedFn, reachingCallback);\n+      cfgReachabilityAnalyzer.analyze();\n+\n+      // And finally, instrument the returns.\n+\n+      int exitPoints = countExitPoints(cfgForMinimizedFn, reachingCallback, fnNode);\n+      ReturnInstrumentation ri = new ReturnInstrumentation(exitPoints, shouldRemoveReturn);\n+      ri.processExitPointsOfFunction(fnNode, cfgForMinimizedFn, blockScope);\n+\n+      // Placeholder to lowercase the cost of decompilation.\n+      if (NodeUtil.isFunctionExpression(fn)) {\n+        fnNode.setOnlyCollapseKeys();\n+        NodeUtil.markFunctionsDeleted(fnNode, compiler.getCompilerOptions());\n+        NodeUtil.markFunctionsDeleted(fnNode, ControlFlowAnalysis.getTerminationStatement(compiler));\n+      }\n+\n+      // Replace the original function.\n+      outerBlock.removeChild(innerBlock);\n+      outerBlock.addChildAtIndex(fnNode, functionIndex);\n+      NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.RETURN_STATEMENT);\n+    }\n+\n+    private void visitBlock(NodeTraversal t, Node n) {\n+      if (t.getScope().getBlockDepth() == 1) {\n+        if (NodeUtil.referencesThis(n)) {\n+          return;\n+        }\n+\n+        boolean needsReturn = true;\n+\n+        for (Node child : n.children()) {\n+          int type = child.getType();\n+          if (type == Token.RETURN) {\n+            needsReturn = false;\n+            break;\n+          }\n+\n+          if (NodeUtil.isStatementBlock(child)) {\n+            visitBlock(t, child);\n+            if (!needsReturn) {\n+              break;\n+            }\n+          } else if (NodeUtil.isControlStructure(child) || NodeUtil.isLoopStructure(child)) {\n+            if (child.hasChildren()) {\n+              visitBlock(t, child.getFirstChild());\n+              if (!needsReturn) {\n+                break;\n+              }\n+            }\n+          }\n+        }\n+\n+        if (needsReturn) {\n+          Node lastChild = n.getLastChild();\n+          if (lastChild != null && lastChild.isFunction()) {\n+            NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.RETURN_STATEMENT);\n+            n.addChildToFront(IR.returnNode().useSourceInfoFrom(n));\n+          }\n+        }\n+      }\n+    }\n+\n+    private ControlFlowGraph<Node> cfgForMinimizedFunction(\n+        Node fnNode, Scope functionBodyScope, AbstractCompiler compiler) {\n+\n+      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+      Node body = NodeUtil.getFunctionBody(fnNode);\n+      cfa.process(null, body);\n+\n+      ControlFlowGraph<Node> cfg = cfa.getCfg();\n+\n+      // The CFG we got might have nodes that belong to an outer function, so\n+      // we need to check that and remove those nodes.\n+      if (!cfg.isFrozen()) {\n+        throw new IllegalStateException(\"The CFG should be frozen by now\");\n+      }\n+      ControlFlowGraph<Node> cfgForThisFunction = cfg.splitAtFunction(body);\n+\n+      // Add info about the vars to the control flow graph.\n+      Set<String> varsInFunction = new HashSet<>();\n+      Scope functionScope = functionBodyScope.getParent();\n+      for (Var var : functionScope.getVars()) {\n+        if (!var.isParam()) {\n+          varsInFunction.add(var.getName());\n+        }\n+      }\n+      addVarReachabilityInfo(compiler, cfgForThisFunction.getEntry(), varsInFunction);\n+      for (ControlFlowGraph<Node>.Node cfgNode : cfgForThisFunction.getNodes()) {\n+        Node n = cfgNode.getValue();\n+        if (n.isName() && !n.getBooleanProp(Node.IS_CONSTANT_NAME)) {\n+          cfgNode.putUserInfo(new VarInfo(n.getString(), n, functionScope));\n+        }\n+      }\n+      return cfgForThisFunction;\n+    }\n+\n+    /**\n+     * Computes the return instrumentation for a function.\n+     *\n+     * @param fn The function node.\n+     * @param maxReturnStatementsToRemove The maximum number of return statements\n+     *     that can be removed.\n+     * @return An array of booleans, stating for each return statement whether it should be removed\n+     *     or not.\n+     */\n+    private boolean[] computeReturnInstrumentation(Node fn, int maxReturnStatementsToRemove) {\n+      NodeUtil.ClosureRestatement restatement =\n+          new NodeUtil.ClosureRestatement(fn, maxReturnStatementsToRemove);\n+\n+      // First decision for the return statement will not change.\n+      boolean[] shouldRemoveReturn = new boolean[restatement.getReturnStatements().size()];\n+      if (shouldRemoveReturn.length == 0) {\n+        // Nothing to do, only one way out\n+        return shouldRemoveReturn;\n+      }\n+      shouldRemoveReturn[0] = false;\n+\n+      // Table of optimization step (aka branch index) => side-effects map.\n+      HashMap<Integer, BitSet> optStepToSideEffects = new HashMap<>();\n+\n+      // Table of switch statement condition values => optimization steps.\n+      HashMap<Long, List<Integer>> switchValuesToOptSteps = new HashMap<>();\n+\n+      {\n+        Node lastExpr = restatement.getLastExpression();\n+        Node scope = fn.getGrandparent();\n+        if (lastExpr != null && !NodeUtil.mayHaveSideEffects(lastExpr, scope, compiler)) {\n+          // If the last statement of the function does not have side effects,\n+          // and there are return statements in the function\n+          // body, then we'll need to execute them all.\n+          //\n+          // This is accomplished by the first element of shouldRemoveReturn,\n+          // which is initialized to false.\n+          return shouldRemoveReturn;\n+        }\n+      }\n+\n+\n+      // We can't just remove a return statement if it's in a block that has a\n+      // catch or finally block attached to it.\n+      checkLabels:\n+      for (List<Node> block : restatement.getCfgBlocks()) {\n+        boolean hasFinallyOrCatch = false;\n+        blockTraversal:\n+        for (Node blockNode : block) {\n+          Node parent = blockNode.getParent();\n+          if (parent == null) {\n+            continue blockTraversal;\n+          }\n+          switch (parent.getType()) {\n+            case Token.CATCH:\n+            case Token.FINALLY:\n+              hasFinallyOrCatch = true;\n+              break checkLabels;\n+            case Token.TRY:\n+              if (parent.getChildCount() == 3) {\n+                Node finallyBlock = parent.getLastChild();\n+                if (finallyBlock.isBlock()) {\n+                  Node finallyChild = finallyBlock.getFirstChild();\n+                  if (finallyChild != null) {\n+                    Node finallyChildFirstToken = finallyChild.getFirstChild();\n+                    if (finallyChildFirstToken != null &&\n+                        finallyChildFirstToken.isBlock()) {\n+                      hasFinallyOrCatch = true;\n+                      break checkLabels;\n+                    }\n+                  }\n+                }\n+              }\n+              break; // pretend there was a fall-through\n+            default:\n+              break;\n+          }\n+        }\n+\n+        if (hasFinallyOrCatch) {\n+          for (Node exitPoint : restatement.getExitPoints(block)) {\n+            Node parent = exitPoint.getParent();\n+            if (exitPoint.getType() == Token.RETURN && parent.getType() == Token.BLOCK) {\n+              Node grandparent = parent.getParent();\n+              boolean canRemove = (grandparent != null\n+                  && grandparent.getType() != Token.FUNCTION\n+                  && grandparent.getType() != Token.SCRIPT);\n+              // If the parent is labeled and the label is used, we cannot remove\n+              // the return statement.\n+              if (canRemove && parent.isLabel()) {\n+                canRemove = NodeUtil.isLabelNeverUsed(parent);\n+              }\n+              if (canRemove) {\n+                shouldRemoveReturn[restatement.getReturnStatementIndex(exitPoint)] = true;\n+              }\n+            }\n+          }\n+        }\n+      }\n+\n+      // Finally, do dead code elimination on the computed CFG.\n+      // Dead branches (i.e. branches without side-effects) will be removed.\n+      // This step heavily simplifies the computations done below.\n+\n+      ControlFlowAnalysis cfa = new ControlFlowAnalysis(compiler, false, true);\n+      cfa.process(null, NodeUtil.getFunctionBody(fn));\n+      ControlFlowGraph<Node> cfg = cfa.getCfg();\n+\n+\n+      for (int i = 1; i < shouldRemoveReturn.length; i++) {\n+        List<Integer> optStepsForValue = null;\n+        Node returnStatement = restatement.getReturnStatements().get(i);\n+        Node returnExpr;\n+        Node switchCase = null;\n+        boolean switchCaseIsDefaultValue = false;\n+        List<Node> switchGuardExprs = null;\n+        List<List<Node>> switchCases = null;\n+        boolean switchHasDefault = false;\n+\n+        switch (returnStatement.getParent().getType()) {\n+          case Token.IF: {\n+            Node ifParent = returnStatement.getParent();\n+            BitSet sideEffects = new BitSet();\n+            shouldRemoveReturn[i] =\n+                canRemoveReturnHelper(restatement.getCfgBlock(returnStatement.getParent()),\n+                    shouldRemoveReturn, sideEffects);\n+            optStepToSideEffects.put(i, sideEffects);\n+            break;\n+          }\n+          case Token.RETURN:\n+            // First return statement can't be optimized away\n+            break;\n+          case Token.SWITCH:\n+            Node switchNode = returnStatement.getParent();\n+            switchCases = new ArrayList<>();  // will get filled in later.\n+            switchGuardExprs = new ArrayList<>();\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}