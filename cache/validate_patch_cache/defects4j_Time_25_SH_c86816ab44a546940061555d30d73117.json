{
    "patch": "if (offsetLocal > offsetAdjusted) {\n    // We are at a DST gap\n    final int minOffsetAdjusted = getOffset(instantLocal - 1L);\n    final int maxOffsetAdjusted = offsetAdjusted;\n    if (minOffsetAdjusted != maxOffsetAdjusted) {\n        long prevTransition = previousTransition(instantAdjusted);\n        if (prevTransition == instantAdjusted - 1L) {\n            // a duplicate local time\n            prevTransition = previousTransition(prevTransition);\n        }\n        if (prevTransition < instantLocal - 1L &&\n                getOffset(prevTransition) == maxOffsetAdjusted) {\n            // gap bridged\n            return maxOffsetAdjusted;\n        }\n        else {\n            return minOffsetAdjusted;\n        }\n    }\n} else {\n    // We are at a DST overlap\n    long nextTransition = nextTransition(instantAdjusted);\n    if (nextTransition < instantLocal - offsetAdjusted) {\n        // We are after the overlap\n        final int nextOffsetLocal = getOffset(nextTransition);\n        if (nextOffsetLocal > offsetAdjusted) {\n            // Move the transition back one hour\n            nextTransition = nextTransition(nextTransition - 3600000L);\n        }\n        return nextOffsetLocal;\n    } else {\n        // We are in the overlap period\n        return offsetAdjusted;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..8406a321 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,41 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal > offsetAdjusted) {\n+    // We are at a DST gap\n+    final int minOffsetAdjusted = getOffset(instantLocal - 1L);\n+    final int maxOffsetAdjusted = offsetAdjusted;\n+    if (minOffsetAdjusted != maxOffsetAdjusted) {\n+        long prevTransition = previousTransition(instantAdjusted);\n+        if (prevTransition == instantAdjusted - 1L) {\n+            // a duplicate local time\n+            prevTransition = previousTransition(prevTransition);\n+        }\n+        if (prevTransition < instantLocal - 1L &&\n+                getOffset(prevTransition) == maxOffsetAdjusted) {\n+            // gap bridged\n+            return maxOffsetAdjusted;\n+        }\n+        else {\n+            return minOffsetAdjusted;\n+        }\n+    }\n+} else {\n+    // We are at a DST overlap\n+    long nextTransition = nextTransition(instantAdjusted);\n+    if (nextTransition < instantLocal - offsetAdjusted) {\n+        // We are after the overlap\n+        final int nextOffsetLocal = getOffset(nextTransition);\n+        if (nextOffsetLocal > offsetAdjusted) {\n+            // Move the transition back one hour\n+            nextTransition = nextTransition(nextTransition - 3600000L);\n+        }\n+        return nextOffsetLocal;\n+    } else {\n+        // We are in the overlap period\n+        return offsetAdjusted;\n+    }\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.AssertionFailedError: expected:<false> but was:<true>",
    "test_result": "FAIL"
}