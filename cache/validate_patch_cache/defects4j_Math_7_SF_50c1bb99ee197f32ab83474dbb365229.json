{
    "patch": "public void doEvents(final double tMin, final double tMax,final double[] y, final double threshold) throws MathIllegalStateException{\n    if (yDot == null) {\n        yDot = computeDerivatives(t, y);\n        ++computations;\n    }\n\n    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n        interpolator.setDenseOutput(true, y);\n        interpolator.storeTime(t);\n    }\n\n    // initialize events states\n    final boolean forward = tMax > t;\n    final Collection<EventState> eventsStates = eventsManager.getEventsStates();\n    for (final EventState state : eventsStates) {\n        state.reinitializeBegin(t, y, forward);\n    }\n\n    while (true) {\n\n        // find the next event\n        double tEvent = tMax;\n        EventState toProcessEvent = null;\n        for (final EventState state : eventsStates) {\n            final double tState = state.getEventTime();\n            if (tState < tEvent) {\n                tEvent = tState;\n                toProcessEvent = state;\n            }\n        }\n\n        if (t > tMin + threshold * (tMax - tMin)) {\n            throw new MathIllegalStateException(LocalizedFormats.EVENTS_STUCK_AT_T0_DURING_INTEGRATION,t);\n        }\n\n        if (toProcessEvent != null && toProcessEvent.isOccurred()) {\n\n            // we check if some events states have been impacted by the last event\n            // and we alert the event detectors\n            final Collection<EventState> occurringEvents = new ArrayList<>(1);\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(toProcessEvent);\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occurringEvents.add(state);\n                }\n            }\n\n            int nbEventsTriggered = occurringEvents.size();\n            if (nbEventsTriggered > 0) {\n                // some events occurs during the step\n                // we sort them\n                final EventState[] occurringArray = occurringEvents.toArray(new EventState[nbEventsTriggered]);\n                Arrays.sort(occurringArray, new Comparator<EventState>() {\n                    /** {@inheritDoc} */\n                    @Override\n                    public int compare(final EventState es0, final EventState es1) {\n                        return orderingSign *\n                                Double.compare(es0.getEventTime(), es1.getEventTime());\n                    }\n                });\n\n                // handle the chronologically first event\n                final EventState currentEvent = occurringArray[0];\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(t);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(eventT, eventY);\n                }\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, false);\n                }\n\n                // handle the triggered events\n                currentEvent.getEventHandler().handleEvent(interpolator, currentEvent.isIncreasing());\n\n                // check if the integration should stop\n                if (stopOnEvent && currentEvent.isStop()) {\n                    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n                        final double[] denseY = interpolator.getDenseOutput().getLastInterpolatedState();\n                        System.arraycopy(denseY, 0, y, 0, y.length);\n                    }\n                    stepStart = stepSize.signum() * tEvent;\n                    System.arraycopy(eventY, 0, y, 0, y.length);\n                    t = eventT;\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, true);\n                    }\n                    return;\n                }\n\n                // update state if the event handler didn't already do it\n                if (!currentEvent.isHandled()) {\n                    currentEvent.stepAccepted(eventT, eventY);\n                }\n\n            } else {\n\n                // we simply move to the event and restart\n                stepStart = stepSize.signum() * tEvent;\n                System.arraycopy(toProcessEvent.getInterpolatedState(), 0, y, 0, y.length);\n                t = tEvent;\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, false);\n                }\n                toProcessEvent.stepAccepted(t, y);\n                toProcessEvent.getEventHandler().handleEvent(interpolator, toProcessEvent.isIncreasing());\n                if (stopOnEvent && toProcessEvent.isStop()) {\n                    // return whatever the event handler gives us\n                    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n                        final double[] denseY = interpolator.getDenseOutput().getLastInterpolatedState();\n                        System.arraycopy(denseY, 0, y, 0, y.length);\n                    }\n                    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n                        interpolator.setSoftPreviousTime(t);\n                        interpolator.setSoftCurrentTime(tMax);\n                    }\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, true);\n                    }\n                    return;\n                }\n            }\n\n        } else {\n          \n            stepSize = initializeStep(forward, 2);\n            if (Math.abs(stepSize) > Math.abs(tMax - t)) {\n                stepSize = tMax - t;\n            }\n\n            final double nextT = t + stepSize;\n\n            // ensure the interpolator covers the last step\n            interpolator.setSoftPreviousTime(t);\n            interpolator.setSoftCurrentTime(nextT);\n\n            // propagate step until the next event time, except if step overshoots end time\n            interpolator.storeTime(t);\n            boolean needStop = false;\n            while (!needStop && (forward ? nextT <= tEvent : nextT >= tEvent)) {\n                // step handling\n                System.arraycopy(y, 0, yDot0, 0, y0.length);\n                stepSize = acceptStep(interpolator, y, yDot, t, yTmp, yDotTmp);\n                if (requiresDenseOutput()) {\n                    interpolator.setInterpolatedTime(nextT);\n                    interpolator.storeTime(nextT);\n                }\n                System.arraycopy(yTmp, 0, y, 0, y.length);\n\n                if ((forward && (nextT >= tMax)) ||\n                        (!forward && (nextT <= tMax))) {\n\n                    // the step overshoots the end time\n                    nextT = tMax;\n                    needStop = true;\n\n                } else {\n\n                    // evaluate events\n                    for (final EventState state : eventsStates) {\n                        state.stepAccepted(nextT, y);\n                    }\n                    final boolean isLastStep = (forward && (nextT >= tMax - 1.0e-12 * Math.abs(tMax))) ||\n                            ((!forward) && (nextT <= tMax + 1.0e-12 * Math.abs(tMax)));\n                    final Collection<EventState> occurringEvents = new ArrayList<>();\n                    for (final EventState state : eventsStates) {\n                        if (state.evaluateStep(interpolator)) {\n                            occurringEvents.add(state);\n                        }\n                    }\n                    if (!occurringEvents.isEmpty()) {\n                        // we have events, we can't go further\n                        // we reset the state before the events occurrence\n                        double dt = t - interpolator.getInterpolatedTime();\n                        System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y.length);\n                        interpolator.setInterpolatedTime(t);\n                        if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n                            interpolator.truncateLast();\n                        }\n\n                        // notify the events and handle the first one\n                        final Comparator<EventState> comparator = new Comparator<EventState>() {\n                            /** {@inheritDoc} */\n                            public int compare(EventState es0, EventState es1) {\n                                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                            }\n                        };\n                        EventState currentEvent;\n                        int nbEventsHandled = 0;\n                        int nbEvents = occurringEvents.size();\n                        boolean stopRegular = false;\n                        boolean eventHandled;\n                        do {\n                            // handle the chronologically first event\n                            final List<EventState> occurringArrayList = new ArrayList<>(occurringEvents);\n                            Collections.sort(occurringArrayList, comparator);\n                            currentEvent = occurringArrayList.get(0);\n\n                            // restrict the interpolator to the first part of the step, up to the event\n                            final double eventT = currentEvent.getEventTime();\n                            interpolator.setSoftPreviousTime(t);\n                            interpolator.setSoftCurrentTime(eventT);\n\n                            // get state at event time\n                            interpolator.setInterpolatedTime(eventT);\n                            final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                            // advance all event states to current time\n                            for (final EventState state : eventsStates) {\n                                state.stepAccepted(eventT, eventY);\n                            }\n\n                            // decide whether to handle the event now or postpone it for later\n                            final EventHandler handler = currentEvent.getEventHandler();\n                            eventHandled = false;\n                            if (stopOnEvent && currentEvent.isStop()) {\n                                // we handle this special case here\n                                dt = tEvent - t;\n                                for (final StepHandler stepHandler : stepHandlers) {\n                                    stepHandler.handleStep(interpolator, true);\n                                }\n\n                                System.arraycopy(eventY, 0, y, 0, y.length);\n                                if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n                                    interpolator.setSoftPreviousTime(t);\n                                    interpolator.setSoftCurrentTime(tMax);\n                                }\n                                currentEvent.setHandled();\n\n                                for (final EventState remaining : occurringEvents) {\n                                    if (!remaining.isHandled()) {\n                                        remaining.stepAccepted(t, y);\n                                    }\n                                }\n\n                                for (final StepHandler stepHandler : stepHandlers) {\n                                    stepHandler.handleStep(interpolator, true);\n                                }\n\n                                return;\n\n                            } else if (currentEvent.isConverged()) {\n                                // use a stored event that has been located within a past step\n                                eventHandled = true;\n\n                            } else {\n                                // get the maximal time separation allowed by the solver between the event time and the next\n                                final double hNext =\n                                        currentEvent.getEventTime() + convergence +\n                                        Math.max(1.0e-8 * Math.abs(currentEvent.getEventTime()), convergence) -\n                                        interpolator.getCurrentTime();\n\n                                // special case for very small separation between event time and next interpolating point\n                                if (Math.abs(hNext) <= 2 * Math.ulp(currentEvent.getEventTime())) {\n                                    // consider next step as an expansion of the current event\n                                    hNext = Math.max(nextT, currentEvent.getEventTime() + convergence) - currentEvent.getEventTime();\n                                }\n\n                                // prepare handling of the events\n                                resetOccurredAndConvergedEvents(false, occurringEvents);\n\n                                // integrate forward until the event time (event is triggered at step end)\n                                final double start = interpolator.getCurrentTime();\n                                integrate(hNext);\n                                ++nbIterations;\n                                currentEvent.stepAccepted(interpolator.getCurrentTime(), interpolator.getInterpolatedState());\n\n                                // handle the events that have occured but have not been handled yet.\n                                // start processing by the events at the current integration date and already located\n                                // during previous steps, then locate the new events\n                                resetOccurredAndConvergedEvents(true, occurringEvents);\n                                nbEventsHandled = occurringEvents.size();\n                                handleEvents(nbEventsHandled, occurringEvents, y, true, handler);\n\n                                // evaluate the need to move the end of the step in order to capture the current event\n                                eventHandlerPortion = handler.eventOccurred(interpolator, currentEvent.getHandlerSign());\n                                if (eventHandlerPortion >= 0.0) {\n                                    // the event was triggered at the end of the step, we need to reduce the next step\n                                    final double dtTmp = currentEvent.getEventTime() - interpolator.getCurrentTime();\n                                    if (Math.abs(dtTmp) <= 2 * Math.ulp(currentEvent.getEventTime())) {\n                                        // there are several events very close to each other, we consider they are simultaneous\n                                        final List<EventState> eventList = new ArrayList<>(occurringEvents);\n                                        Collections.sort(eventList, comparator);\n                                        eventHandled = handleEvent(simultaneousEventsHandlers, interpolator, eventList);\n                                    } else {\n                                        // we reduce the step to match exactly the event time\n                                        interpolator.setSoftCurrentTime(currentEvent.getEventTime());\n                                        System.arraycopy(currentEvent.getInterpolatedState(), 0, y, 0, y.length);\n                                        handler.resetState(interpolator.getInterpolatedTime(), y);\n                                        integrator.setStepSize(currentEvent.getEventTime() - interpolator.getPreviousTime());\n                                    }\n                                    needStop = true;\n                                } else {\n                                    // the event was located in the middle of the step, we need to stop after the event has been processed\n                                    // we reset the state at the event occurrence point\n                                    System.arraycopy(currentEvent.getInterpolatedState(), 0, y, 0, y.length);\n                                    currentEvent.setConverged(true);\n                                }\n                            }\n\n                            // action after an event handler call\n                            if (eventHandled) {\n                                // sub-step handling was already done by the handler, we can go on with another step\n                                break;\n                            } else {\n                                // a new state should be computed before restarting loop\n                                System.arraycopy(y, 0, yDot0, 0, y.length);\n                                System.arraycopy(y, 0, yTmp, 0, y.length);\n                                interpolator.storeTime(interpolator.getCurrentTime());\n                                stepStart = interpolator.getCurrentTime();\n                                if (currentEvent.isResetting()) {\n                                    // some event handler has triggered changes that impact the\n                                    // derivatives continuity, we need to recompute\n                                    // the derivatives and restart from scratch\n                                    System.arraycopy(y, 0, y0, 0, y.length);\n                                    yDot = computeDerivatives(interpolator.getCurrentTime(), y0);\n                                    ++computations;\n                                    for (final EventState state : eventsStates) {\n                                        state.reinitializeBegin(interpolator.getCurrentTime(), y, forward);\n                                        if (state.evaluateStep(interpolator)) {\n                                            occurringEvents.add(state);\n                                        }\n                                    }\n                                    interpolator.storeTime(interpolator.getCurrentTime() - 1.0e-15);\n                                    needStop = true;\n                                    break;\n                                }\n                                stepSize = initializeStep(forward, Math.min(Math.abs(stepSize), Math.abs(tEvent - interpolator.getCurrentTime())), false);\n                                if (stepSize == 0) {\n                                    // we were too close to an event and could not advance anymore\n                                    // we cannot move, we have to stop the integration\n                                    interpolator.setInterpolatedTime(currentEvent.getEventTime());\n                                    System.arraycopy(currentEvent.getInterpolatedState(), 0, y, 0, y.length);\n                                    ++nbEventExceptions;\n                                    throw new EventException(currentEvent);\n                                }\n                                nextT = interpolator.getCurrentTime() + stepSize;\n                                interpolator.setSoftPreviousTime(interpolator.getCurrentTime());\n                                interpolator.setSoftCurrentTime(nextT);\n                            }\n\n                        } while (nbEventsHandled < nbEvents && !needStop);\n\n                    } else {\n                        // no event, the step has completed successfully\n                        t = nextT;\n                        for (final StepHandler handler : stepHandlers) {\n                            handler.handleStep(interpolator, false);\n                        }\n                        break;\n                    }\n                }\n            }\n        }\n        yDot = yDotTmp;\n        System.arraycopy(yTmp, 0, y, 0, y.length);\n        t = interpolator.getCurrentTime();\n    }\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..d8c8361a9 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,29 +313,74 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n+public void doEvents(final double tMin, final double tMax,final double[] y, final double threshold) throws MathIllegalStateException{\n+    if (yDot == null) {\n+        yDot = computeDerivatives(t, y);\n+        ++computations;\n+    }\n+\n+    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n+        interpolator.setDenseOutput(true, y);\n+        interpolator.storeTime(t);\n+    }\n+\n+    // initialize events states\n+    final boolean forward = tMax > t;\n+    final Collection<EventState> eventsStates = eventsManager.getEventsStates();\n+    for (final EventState state : eventsStates) {\n+        state.reinitializeBegin(t, y, forward);\n+    }\n+\n+    while (true) {\n+\n+        // find the next event\n+        double tEvent = tMax;\n+        EventState toProcessEvent = null;\n+        for (final EventState state : eventsStates) {\n+            final double tState = state.getEventTime();\n+            if (tState < tEvent) {\n+                tEvent = tState;\n+                toProcessEvent = state;\n+            }\n+        }\n+\n+        if (t > tMin + threshold * (tMax - tMin)) {\n+            throw new MathIllegalStateException(LocalizedFormats.EVENTS_STUCK_AT_T0_DURING_INTEGRATION,t);\n+        }\n \n-            });\n+        if (toProcessEvent != null && toProcessEvent.isOccurred()) {\n \n+            // we check if some events states have been impacted by the last event\n+            // and we alert the event detectors\n+            final Collection<EventState> occurringEvents = new ArrayList<>(1);\n             for (final EventState state : eventsStates) {\n+                state.stepAccepted(toProcessEvent);\n                 if (state.evaluateStep(interpolator)) {\n                     // the event occurs during the current step\n-                    occuringEvents.add(state);\n+                    occurringEvents.add(state);\n                 }\n             }\n \n-            while (!occuringEvents.isEmpty()) {\n+            int nbEventsTriggered = occurringEvents.size();\n+            if (nbEventsTriggered > 0) {\n+                // some events occurs during the step\n+                // we sort them\n+                final EventState[] occurringArray = occurringEvents.toArray(new EventState[nbEventsTriggered]);\n+                Arrays.sort(occurringArray, new Comparator<EventState>() {\n+                    /** {@inheritDoc} */\n+                    @Override\n+                    public int compare(final EventState es0, final EventState es1) {\n+                        return orderingSign *\n+                                Double.compare(es0.getEventTime(), es1.getEventTime());\n+                    }\n+                });\n \n                 // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+                final EventState currentEvent = occurringArray[0];\n \n                 // restrict the interpolator to the first part of the step, up to the event\n                 final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n+                interpolator.setSoftPreviousTime(t);\n                 interpolator.setSoftCurrentTime(eventT);\n \n                 // get state at event time\n@@ -343,14 +388,304 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                 final double[] eventY = interpolator.getInterpolatedState().clone();\n \n                 // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(eventT, eventY);\n+                }\n \n                 // handle the first part of the step, up to the event\n                 for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                    handler.handleStep(interpolator, false);\n+                }\n+\n+                // handle the triggered events\n+                currentEvent.getEventHandler().handleEvent(interpolator, currentEvent.isIncreasing());\n+\n+                // check if the integration should stop\n+                if (stopOnEvent && currentEvent.isStop()) {\n+                    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n+                        final double[] denseY = interpolator.getDenseOutput().getLastInterpolatedState();\n+                        System.arraycopy(denseY, 0, y, 0, y.length);\n+                    }\n+                    stepStart = stepSize.signum() * tEvent;\n+                    System.arraycopy(eventY, 0, y, 0, y.length);\n+                    t = eventT;\n+                    for (final StepHandler handler : stepHandlers) {\n+                        handler.handleStep(interpolator, true);\n+                    }\n+                    return;\n+                }\n+\n+                // update state if the event handler didn't already do it\n+                if (!currentEvent.isHandled()) {\n+                    currentEvent.stepAccepted(eventT, eventY);\n                 }\n \n+            } else {\n+\n+                // we simply move to the event and restart\n+                stepStart = stepSize.signum() * tEvent;\n+                System.arraycopy(toProcessEvent.getInterpolatedState(), 0, y, 0, y.length);\n+                t = tEvent;\n+                for (final StepHandler handler : stepHandlers) {\n+                    handler.handleStep(interpolator, false);\n+                }\n+                toProcessEvent.stepAccepted(t, y);\n+                toProcessEvent.getEventHandler().handleEvent(interpolator, toProcessEvent.isIncreasing());\n+                if (stopOnEvent && toProcessEvent.isStop()) {\n+                    // return whatever the event handler gives us\n+                    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n+                        final double[] denseY = interpolator.getDenseOutput().getLastInterpolatedState();\n+                        System.arraycopy(denseY, 0, y, 0, y.length);\n+                    }\n+                    if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n+                        interpolator.setSoftPreviousTime(t);\n+                        interpolator.setSoftCurrentTime(tMax);\n+                    }\n+                    for (final StepHandler handler : stepHandlers) {\n+                        handler.handleStep(interpolator, true);\n+                    }\n+                    return;\n+                }\n+            }\n+\n+        } else {\n+          \n+            stepSize = initializeStep(forward, 2);\n+            if (Math.abs(stepSize) > Math.abs(tMax - t)) {\n+                stepSize = tMax - t;\n+            }\n+\n+            final double nextT = t + stepSize;\n+\n+            // ensure the interpolator covers the last step\n+            interpolator.setSoftPreviousTime(t);\n+            interpolator.setSoftCurrentTime(nextT);\n+\n+            // propagate step until the next event time, except if step overshoots end time\n+            interpolator.storeTime(t);\n+            boolean needStop = false;\n+            while (!needStop && (forward ? nextT <= tEvent : nextT >= tEvent)) {\n+                // step handling\n+                System.arraycopy(y, 0, yDot0, 0, y0.length);\n+                stepSize = acceptStep(interpolator, y, yDot, t, yTmp, yDotTmp);\n+                if (requiresDenseOutput()) {\n+                    interpolator.setInterpolatedTime(nextT);\n+                    interpolator.storeTime(nextT);\n+                }\n+                System.arraycopy(yTmp, 0, y, 0, y.length);\n+\n+                if ((forward && (nextT >= tMax)) ||\n+                        (!forward && (nextT <= tMax))) {\n+\n+                    // the step overshoots the end time\n+                    nextT = tMax;\n+                    needStop = true;\n+\n+                } else {\n+\n+                    // evaluate events\n+                    for (final EventState state : eventsStates) {\n+                        state.stepAccepted(nextT, y);\n+                    }\n+                    final boolean isLastStep = (forward && (nextT >= tMax - 1.0e-12 * Math.abs(tMax))) ||\n+                            ((!forward) && (nextT <= tMax + 1.0e-12 * Math.abs(tMax)));\n+                    final Collection<EventState> occurringEvents = new ArrayList<>();\n+                    for (final EventState state : eventsStates) {\n+                        if (state.evaluateStep(interpolator)) {\n+                            occurringEvents.add(state);\n+                        }\n+                    }\n+                    if (!occurringEvents.isEmpty()) {\n+                        // we have events, we can't go further\n+                        // we reset the state before the events occurrence\n+                        double dt = t - interpolator.getInterpolatedTime();\n+                        System.arraycopy(interpolator.getInterpolatedState(), 0, y, 0, y.length);\n+                        interpolator.setInterpolatedTime(t);\n+                        if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n+                            interpolator.truncateLast();\n+                        }\n+\n+                        // notify the events and handle the first one\n+                        final Comparator<EventState> comparator = new Comparator<EventState>() {\n+                            /** {@inheritDoc} */\n+                            public int compare(EventState es0, EventState es1) {\n+                                return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n+                            }\n+                        };\n+                        EventState currentEvent;\n+                        int nbEventsHandled = 0;\n+                        int nbEvents = occurringEvents.size();\n+                        boolean stopRegular = false;\n+                        boolean eventHandled;\n+                        do {\n+                            // handle the chronologically first event\n+                            final List<EventState> occurringArrayList = new ArrayList<>(occurringEvents);\n+                            Collections.sort(occurringArrayList, comparator);\n+                            currentEvent = occurringArrayList.get(0);\n+\n+                            // restrict the interpolator to the first part of the step, up to the event\n+                            final double eventT = currentEvent.getEventTime();\n+                            interpolator.setSoftPreviousTime(t);\n+                            interpolator.setSoftCurrentTime(eventT);\n+\n+                            // get state at event time\n+                            interpolator.setInterpolatedTime(eventT);\n+                            final double[] eventY = interpolator.getInterpolatedState().clone();\n+\n+                            // advance all event states to current time\n+                            for (final EventState state : eventsStates) {\n+                                state.stepAccepted(eventT, eventY);\n+                            }\n+\n+                            // decide whether to handle the event now or postpone it for later\n+                            final EventHandler handler = currentEvent.getEventHandler();\n+                            eventHandled = false;\n+                            if (stopOnEvent && currentEvent.isStop()) {\n+                                // we handle this special case here\n+                                dt = tEvent - t;\n+                                for (final StepHandler stepHandler : stepHandlers) {\n+                                    stepHandler.handleStep(interpolator, true);\n+                                }\n+\n+                                System.arraycopy(eventY, 0, y, 0, y.length);\n+                                if (requiresDenseOutput() && interpolator.requiresDenseOutput()) {\n+                                    interpolator.setSoftPreviousTime(t);\n+                                    interpolator.setSoftCurrentTime(tMax);\n+                                }\n+                                currentEvent.setHandled();\n+\n+                                for (final EventState remaining : occurringEvents) {\n+                                    if (!remaining.isHandled()) {\n+                                        remaining.stepAccepted(t, y);\n+                                    }\n+                                }\n+\n+                                for (final StepHandler stepHandler : stepHandlers) {\n+                                    stepHandler.handleStep(interpolator, true);\n+                                }\n+\n+                                return;\n+\n+                            } else if (currentEvent.isConverged()) {\n+                                // use a stored event that has been located within a past step\n+                                eventHandled = true;\n+\n+                            } else {\n+                                // get the maximal time separation allowed by the solver between the event time and the next\n+                                final double hNext =\n+                                        currentEvent.getEventTime() + convergence +\n+                                        Math.max(1.0e-8 * Math.abs(currentEvent.getEventTime()), convergence) -\n+                                        interpolator.getCurrentTime();\n+\n+                                // special case for very small separation between event time and next interpolating point\n+                                if (Math.abs(hNext) <= 2 * Math.ulp(currentEvent.getEventTime())) {\n+                                    // consider next step as an expansion of the current event\n+                                    hNext = Math.max(nextT, currentEvent.getEventTime() + convergence) - currentEvent.getEventTime();\n+                                }\n+\n+                                // prepare handling of the events\n+                                resetOccurredAndConvergedEvents(false, occurringEvents);\n+\n+                                // integrate forward until the event time (event is triggered at step end)\n+                                final double start = interpolator.getCurrentTime();\n+                                integrate(hNext);\n+                                ++nbIterations;\n+                                currentEvent.stepAccepted(interpolator.getCurrentTime(), interpolator.getInterpolatedState());\n+\n+                                // handle the events that have occured but have not been handled yet.\n+                                // start processing by the events at the current integration date and already located\n+                                // during previous steps, then locate the new events\n+                                resetOccurredAndConvergedEvents(true, occurringEvents);\n+                                nbEventsHandled = occurringEvents.size();\n+                                handleEvents(nbEventsHandled, occurringEvents, y, true, handler);\n+\n+                                // evaluate the need to move the end of the step in order to capture the current event\n+                                eventHandlerPortion = handler.eventOccurred(interpolator, currentEvent.getHandlerSign());\n+                                if (eventHandlerPortion >= 0.0) {\n+                                    // the event was triggered at the end of the step, we need to reduce the next step\n+                                    final double dtTmp = currentEvent.getEventTime() - interpolator.getCurrentTime();\n+                                    if (Math.abs(dtTmp) <= 2 * Math.ulp(currentEvent.getEventTime())) {\n+                                        // there are several events very close to each other, we consider they are simultaneous\n+                                        final List<EventState> eventList = new ArrayList<>(occurringEvents);\n+                                        Collections.sort(eventList, comparator);\n+                                        eventHandled = handleEvent(simultaneousEventsHandlers, interpolator, eventList);\n+                                    } else {\n+                                        // we reduce the step to match exactly the event time\n+                                        interpolator.setSoftCurrentTime(currentEvent.getEventTime());\n+                                        System.arraycopy(currentEvent.getInterpolatedState(), 0, y, 0, y.length);\n+                                        handler.resetState(interpolator.getInterpolatedTime(), y);\n+                                        integrator.setStepSize(currentEvent.getEventTime() - interpolator.getPreviousTime());\n+                                    }\n+                                    needStop = true;\n+                                } else {\n+                                    // the event was located in the middle of the step, we need to stop after the event has been processed\n+                                    // we reset the state at the event occurrence point\n+                                    System.arraycopy(currentEvent.getInterpolatedState(), 0, y, 0, y.length);\n+                                    currentEvent.setConverged(true);\n+                                }\n+                            }\n+\n+                            // action after an event handler call\n+                            if (eventHandled) {\n+                                // sub-step handling was already done by the handler, we can go on with another step\n+                                break;\n+                            } else {\n+                                // a new state should be computed before restarting loop\n+                                System.arraycopy(y, 0, yDot0, 0, y.length);\n+                                System.arraycopy(y, 0, yTmp, 0, y.length);\n+                                interpolator.storeTime(interpolator.getCurrentTime());\n+                                stepStart = interpolator.getCurrentTime();\n+                                if (currentEvent.isResetting()) {\n+                                    // some event handler has triggered changes that impact the\n+                                    // derivatives continuity, we need to recompute\n+                                    // the derivatives and restart from scratch\n+                                    System.arraycopy(y, 0, y0, 0, y.length);\n+                                    yDot = computeDerivatives(interpolator.getCurrentTime(), y0);\n+                                    ++computations;\n+                                    for (final EventState state : eventsStates) {\n+                                        state.reinitializeBegin(interpolator.getCurrentTime(), y, forward);\n+                                        if (state.evaluateStep(interpolator)) {\n+                                            occurringEvents.add(state);\n+                                        }\n+                                    }\n+                                    interpolator.storeTime(interpolator.getCurrentTime() - 1.0e-15);\n+                                    needStop = true;\n+                                    break;\n+                                }\n+                                stepSize = initializeStep(forward, Math.min(Math.abs(stepSize), Math.abs(tEvent - interpolator.getCurrentTime())), false);\n+                                if (stepSize == 0) {\n+                                    // we were too close to an event and could not advance anymore\n+                                    // we cannot move, we have to stop the integration\n+                                    interpolator.setInterpolatedTime(currentEvent.getEventTime());\n+                                    System.arraycopy(currentEvent.getInterpolatedState(), 0, y, 0, y.length);\n+                                    ++nbEventExceptions;\n+                                    throw new EventException(currentEvent);\n+                                }\n+                                nextT = interpolator.getCurrentTime() + stepSize;\n+                                interpolator.setSoftPreviousTime(interpolator.getCurrentTime());\n+                                interpolator.setSoftCurrentTime(nextT);\n+                            }\n+\n+                        } while (nbEventsHandled < nbEvents && !needStop);\n+\n+                    } else {\n+                        // no event, the step has completed successfully\n+                        t = nextT;\n+                        for (final StepHandler handler : stepHandlers) {\n+                            handler.handleStep(interpolator, false);\n+                        }\n+                        break;\n+                    }\n+                }\n+            }\n+        }\n+        yDot = yDotTmp;\n+        System.arraycopy(yTmp, 0, y, 0, y.length);\n+        t = interpolator.getCurrentTime();\n+    }\n+\n+}\n+\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}