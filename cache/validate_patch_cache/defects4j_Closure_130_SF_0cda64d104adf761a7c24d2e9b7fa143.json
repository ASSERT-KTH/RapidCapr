{
    "patch": "private boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n    if (ref.type != Ref.Type.ALIASING_GET) {\n        return false;\n    }\n    Name target = ref.getTarget();\n    if (target == null || target.getDeclaration() != null || target.type == Name.Type.GET || target.type == Name.Type.SET) {\n        return false;\n    }\n\n    String name = target.getBaseName();\n    String uniqueName = target.getUniqueName();\n\n    if (target.scope.getParent() == null) {\n        return false;\n    }\n\n    // Determine whether the alias may be inlined.\n    // It is safe to inline the alias only if the aliasing name does not have a\n    // declaration in its containing scope, and only if the alias is referenced\n    // no more than once in its containing scope.\n    int count = 0;\n    Scope.Var var = new Scope.Var(target, null);\n    for (Ref ref2 : target.getRefs()) {\n        if (ref2 == ref || !ref2.isRead()) {\n            continue;\n        }\n        count++;\n        if (count > 1) {\n            return false;\n        }\n        if (ref2.type == Ref.Type.SET_FROM_GLOBAL && ref2.base != null) {\n            return false;\n        }\n        if (ref2.type == Ref.Type.SET_FROM_GLOBAL && ref2.base == null) {\n            for (Name global : namespace.getNameIndex().getGlobals()) {\n                if (global.hasSameName(target)) {\n                    return false;\n                }\n            }\n        }\n    }\n\n    // Determine whether it is safe to inline the alias in other scopes.\n    boolean hasOtherRefs = false;\n    if (count == 1) {\n        // Check for collision-free renaming.\n        Scope container = ref.scope.getParent();\n        int propertyIndex = container.allocatedProperties.size();\n        Object shortName = nameTable.getOwn(objNameKey, name, uniqueName, 0);\n        while (container != null) {\n            if (container.getParent() == null) { // global scope\n                if (namespace.getNameIndex().getReferencedPropertyNames().contains(shortName)) {\n                    return false;\n                }\n            } else {\n                Object prop = nameTable.getOwn(objPropKey, shortName, propertyIndex);\n                if (container.allocatedProperties.contains(prop)) {\n                    return false;\n                }\n                container.allocatedProperties.add(prop);\n            }\n\n            hasOtherRefs = hasOtherRefs || container.hasThisOrDescendant(ref.getScope());\n            container = container.getParent();\n            propertyIndex--;\n        }\n    } else {\n        hasOtherRefs = true;\n    }\n\n    // If there are no other references to the alias, then inline it.\n    if (!hasOtherRefs) {\n        ref.getScope().replaceRef(ref, new Ref(\n                Ref.Type.SET_FROM_GLOBAL,\n                ref.getScope(),\n                ref.getNode(),\n                target,\n                null,\n                false));\n        target.removeRef(ref);\n        return true;\n    }\n    return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..63809de8 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -158,43 +158,90 @@ class CollapseProperties implements CompilerPass {\n    *    inlineable.\n    * @see InlineVariables\n    */\n-  private void inlineAliases(GlobalNamespace namespace) {\n-    // Invariant: All the names in the worklist meet condition (a).\n-    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n-    while (!workList.isEmpty()) {\n-      Name name = workList.pop();\n-\n-      // Don't attempt to inline a getter or setter property as a variable.\n-      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n-        continue;\n-      }\n+private boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n+    if (ref.type != Ref.Type.ALIASING_GET) {\n+        return false;\n+    }\n+    Name target = ref.getTarget();\n+    if (target == null || target.getDeclaration() != null || target.type == Name.Type.GET || target.type == Name.Type.SET) {\n+        return false;\n+    }\n+\n+    String name = target.getBaseName();\n+    String uniqueName = target.getUniqueName();\n+\n+    if (target.scope.getParent() == null) {\n+        return false;\n+    }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+    // Determine whether the alias may be inlined.\n+    // It is safe to inline the alias only if the aliasing name does not have a\n+    // declaration in its containing scope, and only if the alias is referenced\n+    // no more than once in its containing scope.\n+    int count = 0;\n+    Scope.Var var = new Scope.Var(target, null);\n+    for (Ref ref2 : target.getRefs()) {\n+        if (ref2 == ref || !ref2.isRead()) {\n+            continue;\n+        }\n+        count++;\n+        if (count > 1) {\n+            return false;\n+        }\n+        if (ref2.type == Ref.Type.SET_FROM_GLOBAL && ref2.base != null) {\n+            return false;\n+        }\n+        if (ref2.type == Ref.Type.SET_FROM_GLOBAL && ref2.base == null) {\n+            for (Name global : namespace.getNameIndex().getGlobals()) {\n+                if (global.hasSameName(target)) {\n+                    return false;\n+                }\n             }\n-          }\n         }\n-      }\n+    }\n \n-      // Check if {@code name} has any aliases left after the\n-      // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n-           name.type == Name.Type.FUNCTION) &&\n-          name.aliasingGets == 0 && name.props != null) {\n-        // All of {@code name}'s children meet condition (a), so they can be\n-        // added to the worklist.\n-        workList.addAll(name.props);\n-      }\n+    // Determine whether it is safe to inline the alias in other scopes.\n+    boolean hasOtherRefs = false;\n+    if (count == 1) {\n+        // Check for collision-free renaming.\n+        Scope container = ref.scope.getParent();\n+        int propertyIndex = container.allocatedProperties.size();\n+        Object shortName = nameTable.getOwn(objNameKey, name, uniqueName, 0);\n+        while (container != null) {\n+            if (container.getParent() == null) { // global scope\n+                if (namespace.getNameIndex().getReferencedPropertyNames().contains(shortName)) {\n+                    return false;\n+                }\n+            } else {\n+                Object prop = nameTable.getOwn(objPropKey, shortName, propertyIndex);\n+                if (container.allocatedProperties.contains(prop)) {\n+                    return false;\n+                }\n+                container.allocatedProperties.add(prop);\n+            }\n+\n+            hasOtherRefs = hasOtherRefs || container.hasThisOrDescendant(ref.getScope());\n+            container = container.getParent();\n+            propertyIndex--;\n+        }\n+    } else {\n+        hasOtherRefs = true;\n+    }\n+\n+    // If there are no other references to the alias, then inline it.\n+    if (!hasOtherRefs) {\n+        ref.getScope().replaceRef(ref, new Ref(\n+                Ref.Type.SET_FROM_GLOBAL,\n+                ref.getScope(),\n+                ref.getNode(),\n+                target,\n+                null,\n+                false));\n+        target.removeRef(ref);\n+        return true;\n     }\n-  }\n+    return false;\n+}\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n     // Ensure that the alias is assigned to a local variable at that",
    "result_reason": "error: method inlineAliasIfPossible(Ref,GlobalNamespace) is already defined in class CollapseProperties",
    "test_result": "ERROR"
}