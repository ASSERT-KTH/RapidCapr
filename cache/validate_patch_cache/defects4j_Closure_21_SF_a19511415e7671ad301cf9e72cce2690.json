{
    "patch": "public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() || n.isComma() || n.isTemplateLit() || n.isImportSpec()) {\n      return;\n    }\n\n    if (parent == null) {\n      // Top of the tree, e.g. a SCRIPT node\n      return;\n    }\n\n    // Statements should not be the direct children of an expression.\n    if (parent.isExprResult()) {\n      return;\n    }\n\n    // Block-less statements shouldn't be in a block.\n    // We allow empty blocks {} though, since people like having them around\n    // to attach JSDoc information to (which is a weird but well-established pattern).\n    if (parent.isBlock() && !n.isBlock() && !parent.isFunction()) {\n      return;\n    }\n\n    // Do not try to remove a block or an expr result. We already handle these cases when we visit the child,\n    // and the peephole passes will fix up the tree in more clever ways when these are removed.\n    if (n.isExprResult()) {\n      return;\n    }\n\n    // The first CHILD of an EXPR_VOID is not a real statement.\n    // It is a parent of the real statement. To avoid double counting.\n    if (parent.isVoid()) {\n      return;\n    }\n\n    // This no-op statement was there so that JSDoc information could\n    // be attached to the name. This check should not complain about it.\n    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n      return;\n    }\n\n    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n    // Use a set to avoid duplicates in the warning messages.\n    Set<Integer> warnings = EnumSet.noneOf(Token.class);\n\n    if (parent.getType() == Token.COMMA) {\n      if (isResultUsed) {\n        return;\n      }\n      if (n == parent.getLastChild()) {\n        for (Node an : parent.getAncestors()) {\n          int ancestorType = an.getType();\n          if (ancestorType == Token.COMMA) {\n            continue;\n          }\n          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {\n            return;\n          } else {\n            break;\n          }\n        }\n      }\n    } else if (parent.getType() == Token.LABEL_NAME || parent.getType() == Token.LABEL) {\n      // Ignore warnings in labels.\n      return;\n    } else if (parent.isCall() && parent.getFirstChild() == n) {\n      // Check for side effects of the object and arguments if parent is CALL.\n      Node calleeRoot = parent.getFirstChild();\n      Node callee = NodeUtil.getBestLValue(calleeRoot);\n      if (callee != null && !callee.isName() && NodeUtil.mayHaveSideEffects(callee, t.getCompiler())) {\n        return;\n      }\n      for (Node arg : parent.getLastChild().children()) {\n        if (NodeUtil.mayHaveSideEffects(arg, t.getCompiler())) {\n          return;\n        }\n      }\n    } else if (parent.isHook()) {\n      return;\n    } else if (parent.getType() == Token.AND || parent.getType() == Token.OR) {\n      if (parent.getFirstChild() != n) {\n        return;\n      }\n    } else if (parent.getType() == Token.CASE || parent.getType() == Token.DEFAULT_CASE) {\n      return;\n    } else if (parent.getType() == Token.EXPR_VOID) {\n      isResultUsed = true;\n    } else if (parent.getType() == Token.ARRAY_PATTERN) {\n      return;\n    } else if (parent.getType() == Token.GETELEM) {\n      if (parent.getFirstChild() != n) {\n        return;\n      }\n    } else if (parent.getType() == Token.TRY) {\n      if (n.getType() == Token.BLOCK && !n.hasChildren()) {\n        return;\n      }\n      if (parent.getChildCount() > 3 && parent.getFirstChild().getNext() != n) {\n        return;\n      }\n    } else if (n.isStringKey() && n.getParent().isObjectPattern()) {\n      return;\n    } else if (parent.getType() == Token.DUPLICATE) {\n      // Don't suggest to remove vars added to vars by the compacting pass\n      return;\n    } else if (!NodeUtil.mayHaveSideEffects(parent, t.getCompiler())) {\n      // Skip statements that don't have side effects,\n      // mainly to avoid churn with code like\n      // `if (a); else b();`.\n      return;\n    }\n\n    if (isResultUsed) {\n      return;\n    }\n\n    // Don't warn about the following patterns.\n    if (n.isFunction()) {\n      Node body = n.getLastChild();\n      if (body.isBlock() && !body.hasChildren()) {\n        return;\n      }\n    } else if (n.isVar() && n.hasChildren() && !n.getFirstChild().hasChildren()) {\n      return;\n    }\n\n    if (!NodeUtil.isStatement(n) && !n.isName()) {\n      warnings.add(USELESS_EXPRESSION);\n    }\n\n    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n    if (isSimpleOp) {\n      warnings.add(UNNECESSARY_OPERATOR);\n    }\n\n    if (!warnings.isEmpty()) {\n      String msg = \"This code lacks side-effects. \";\n      if (warnings.contains(USELESS_EXPRESSION)) {\n        if (n.isAdd()) {\n          msg = \"Is there a missing '+' on the previous line? \";\n        } else if (n.isStringLit()) {\n          msg = \"Is there a missing '+' on the previous line or a newline after the string? \";\n        } else {\n          msg += \"Is there a bug? \";\n        }\n      } else {\n        msg += \"The result of the operator is not used. \";\n      }\n      t.getCompiler().report(t.makeError(n, level, warnings.toArray(new Diag[0]), msg));\n      if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n      }\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a0..d21e1fe4 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -81,27 +81,44 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n   }\n \n   @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n+public void visit(NodeTraversal t, Node n, Node parent) {\n     // VOID nodes appear when there are extra semicolons at the BLOCK level.\n     // I've been unable to think of any cases where this indicates a bug,\n     // and apparently some people like keeping these semicolons around,\n     // so we'll allow it.\n-    if (n.isEmpty() ||\n-        n.isComma()) {\n+    if (n.isEmpty() || n.isComma() || n.isTemplateLit() || n.isImportSpec()) {\n       return;\n     }\n \n     if (parent == null) {\n+      // Top of the tree, e.g. a SCRIPT node\n       return;\n     }\n \n-    // Do not try to remove a block or an expr result. We already handle\n-    // these cases when we visit the child, and the peephole passes will\n-    // fix up the tree in more clever ways when these are removed.\n+    // Statements should not be the direct children of an expression.\n+    if (parent.isExprResult()) {\n+      return;\n+    }\n+\n+    // Block-less statements shouldn't be in a block.\n+    // We allow empty blocks {} though, since people like having them around\n+    // to attach JSDoc information to (which is a weird but well-established pattern).\n+    if (parent.isBlock() && !n.isBlock() && !parent.isFunction()) {\n+      return;\n+    }\n+\n+    // Do not try to remove a block or an expr result. We already handle these cases when we visit the child,\n+    // and the peephole passes will fix up the tree in more clever ways when these are removed.\n     if (n.isExprResult()) {\n       return;\n     }\n \n+    // The first CHILD of an EXPR_VOID is not a real statement.\n+    // It is a parent of the real statement. To avoid double counting.\n+    if (parent.isVoid()) {\n+      return;\n+    }\n+\n     // This no-op statement was there so that JSDoc information could\n     // be attached to the name. This check should not complain about it.\n     if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n@@ -109,7 +126,9 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n     }\n \n     boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n+    // Use a set to avoid duplicates in the warning messages.\n+    Set<Integer> warnings = EnumSet.noneOf(Token.class);\n+\n     if (parent.getType() == Token.COMMA) {\n       if (isResultUsed) {\n         return;\n@@ -117,35 +136,108 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n       if (n == parent.getLastChild()) {\n         for (Node an : parent.getAncestors()) {\n           int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n+          if (ancestorType == Token.COMMA) {\n+            continue;\n+          }\n+          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) {\n+            return;\n+          } else {\n+            break;\n+          }\n         }\n       }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n+    } else if (parent.getType() == Token.LABEL_NAME || parent.getType() == Token.LABEL) {\n+      // Ignore warnings in labels.\n+      return;\n+    } else if (parent.isCall() && parent.getFirstChild() == n) {\n+      // Check for side effects of the object and arguments if parent is CALL.\n+      Node calleeRoot = parent.getFirstChild();\n+      Node callee = NodeUtil.getBestLValue(calleeRoot);\n+      if (callee != null && !callee.isName() && NodeUtil.mayHaveSideEffects(callee, t.getCompiler())) {\n+        return;\n+      }\n+      for (Node arg : parent.getLastChild().children()) {\n+        if (NodeUtil.mayHaveSideEffects(arg, t.getCompiler())) {\n+          return;\n+        }\n+      }\n+    } else if (parent.isHook()) {\n+      return;\n+    } else if (parent.getType() == Token.AND || parent.getType() == Token.OR) {\n+      if (parent.getFirstChild() != n) {\n+        return;\n+      }\n+    } else if (parent.getType() == Token.CASE || parent.getType() == Token.DEFAULT_CASE) {\n+      return;\n+    } else if (parent.getType() == Token.EXPR_VOID) {\n+      isResultUsed = true;\n+    } else if (parent.getType() == Token.ARRAY_PATTERN) {\n+      return;\n+    } else if (parent.getType() == Token.GETELEM) {\n+      if (parent.getFirstChild() != n) {\n+        return;\n+      }\n+    } else if (parent.getType() == Token.TRY) {\n+      if (n.getType() == Token.BLOCK && !n.hasChildren()) {\n+        return;\n+      }\n+      if (parent.getChildCount() > 3 && parent.getFirstChild().getNext() != n) {\n         return;\n       }\n+    } else if (n.isStringKey() && n.getParent().isObjectPattern()) {\n+      return;\n+    } else if (parent.getType() == Token.DUPLICATE) {\n+      // Don't suggest to remove vars added to vars by the compacting pass\n+      return;\n+    } else if (!NodeUtil.mayHaveSideEffects(parent, t.getCompiler())) {\n+      // Skip statements that don't have side effects,\n+      // mainly to avoid churn with code like\n+      // `if (a); else b();`.\n+      return;\n     }\n-    if (\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      String msg = \"This code lacks side-effects. Is there a bug?\";\n-      if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n-      } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n+\n+    if (isResultUsed) {\n+      return;\n+    }\n+\n+    // Don't warn about the following patterns.\n+    if (n.isFunction()) {\n+      Node body = n.getLastChild();\n+      if (body.isBlock() && !body.hasChildren()) {\n+        return;\n       }\n+    } else if (n.isVar() && n.hasChildren() && !n.getFirstChild().hasChildren()) {\n+      return;\n+    }\n+\n+    if (!NodeUtil.isStatement(n) && !n.isName()) {\n+      warnings.add(USELESS_EXPRESSION);\n+    }\n \n-      t.getCompiler().report(\n-          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n-      // TODO(johnlenz): determine if it is necessary to\n-      // try to protect side-effect free statements as well.\n+    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n+    if (isSimpleOp) {\n+      warnings.add(UNNECESSARY_OPERATOR);\n+    }\n+\n+    if (!warnings.isEmpty()) {\n+      String msg = \"This code lacks side-effects. \";\n+      if (warnings.contains(USELESS_EXPRESSION)) {\n+        if (n.isAdd()) {\n+          msg = \"Is there a missing '+' on the previous line? \";\n+        } else if (n.isStringLit()) {\n+          msg = \"Is there a missing '+' on the previous line or a newline after the string? \";\n+        } else {\n+          msg += \"Is there a bug? \";\n+        }\n+      } else {\n+        msg += \"The result of the operator is not used. \";\n+      }\n+      t.getCompiler().report(t.makeError(n, level, warnings.toArray(new Diag[0]), msg));\n       if (!NodeUtil.isStatement(n)) {\n         problemNodes.add(n);\n       }\n     }\n-  }\n+}\n \n   /**\n    * Protect side-effect free nodes by making them parameters",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}