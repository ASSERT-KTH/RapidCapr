{
    "patch": "        for (int i = 0; i < count; i++) {\n            long newMillis = savedFields[i].set(millis, resetFields);\n            if (newMillis == millis) {\n                continue;\n            }\n            if (newMillis == iMillis) {\n                throw new IllegalArgumentException(\"New millis returned by field set is invalid.\");\n            }\n            if (newMillis < millis && i > 0) {\n                Arrays.sort(savedFields, i, count);\n                for (int j = 0; j < i; j++) {\n                    if (savedFields[j].set(millis, resetFields) != millis) {\n                        throw new IllegalArgumentException(\"Multiple fields returned inconsistent results\");\n                    }\n                }\n                \n                boolean foundEarlier = false;\n                for (int j = i - 1; j >= 0; j--) {\n                    long diff = savedFields[j].getDifferenceAsLong(newMillis, millis);\n                    if (diff < 0) {\n                        if (!foundEarlier) {\n                            foundEarlier = true;\n                            continue;\n                        }\n                        j++;\n                        Arrays.sort(savedFields, j, i);\n                        millis = savedFields[j].set(millis, resetFields);\n                        break;\n                    } else if (diff > 0) {\n                        Arrays.sort(savedFields, j, i);\n                        millis = savedFields[j].set(millis, resetFields);\n                        break;\n                    }\n                }\n            } else {\n                millis = newMillis;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..d866cdf4 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,42 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+        for (int i = 0; i < count; i++) {\n+            long newMillis = savedFields[i].set(millis, resetFields);\n+            if (newMillis == millis) {\n+                continue;\n+            }\n+            if (newMillis == iMillis) {\n+                throw new IllegalArgumentException(\"New millis returned by field set is invalid.\");\n+            }\n+            if (newMillis < millis && i > 0) {\n+                Arrays.sort(savedFields, i, count);\n+                for (int j = 0; j < i; j++) {\n+                    if (savedFields[j].set(millis, resetFields) != millis) {\n+                        throw new IllegalArgumentException(\"Multiple fields returned inconsistent results\");\n+                    }\n+                }\n+                \n+                boolean foundEarlier = false;\n+                for (int j = i - 1; j >= 0; j--) {\n+                    long diff = savedFields[j].getDifferenceAsLong(newMillis, millis);\n+                    if (diff < 0) {\n+                        if (!foundEarlier) {\n+                            foundEarlier = true;\n+                            continue;\n+                        }\n+                        j++;\n+                        Arrays.sort(savedFields, j, i);\n+                        millis = savedFields[j].set(millis, resetFields);\n+                        break;\n+                    } else if (diff > 0) {\n+                        Arrays.sort(savedFields, j, i);\n+                        millis = savedFields[j].set(millis, resetFields);\n+                        break;\n+                    }\n+                }\n+            } else {\n+                millis = newMillis;\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: 'catch' without 'try'",
    "test_result": "ERROR"
}