{
    "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    double yInitial = f.value(initial);\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n\n    if (yMin * yMax >= 0) {\n        String errorMsg = String.format(\"Interval [%s, %s] does not bracket a root.\", min, max);\n        if (min == max) {\n            errorMsg = String.format(\"Interval [%s] does not bracket a root.\", min);\n        }\n        throw new IllegalArgumentException(errorMsg);\n    }\n\n    if (Math.abs(yInitial) < functionValueAccuracy) {\n        setResult(initial, 0);\n        return result;\n    }\n\n    double a = initial;\n    double b = initial;\n    double fa = yInitial;\n    double fb = yInitial;\n\n    for (int i = 0; i < maximalIterationCount; ++i) {\n        if (fb * yMax >= 0) {\n            b = min;\n            fb = yMin;\n            double d = a - b;\n            double e = d;\n\n        } else {\n            a = max;\n            fa = yMax;\n            double d = a - b;\n            double e = d;\n        }\n\n        if (Math.abs(fa) < Math.abs(fb)) {\n            double tmp1 = a;\n            a = b;\n            b = tmp1;\n            double tmp2 = fa;\n            fa = fb;\n            fb = tmp2;\n        }\n\n        double m = 0.5 * (b - a);\n        double tol = 2.0 * absoluteAccuracy + 0.5 * Math.ulp(m);\n        if (Math.abs(m) <= tol) {\n            setResult((a + b) / 2.0, i);\n            return getResult();\n\n        }\n        if (Math.abs(e) < tol || Math.abs(fa) <= Math.abs(fb)) {\n            d = m;\n            e = d;\n        } else {\n            double s = fb / fa;\n            double p;\n            double q;\n            if (a == initial) {\n                p = 2.0 * m * s;\n                q = 1.0 - s;\n            } else {\n                q = fa / fc;\n                double r = fb / fc;\n                p = s * (2.0 * m * q * (q - r) - (b - a) * (r - 1.0));\n                q = (q - 1.0) * (r - 1.0) * (s - 1.0);\n            }\n            if (p > 0.0) {\n                q = -q;\n            } else {\n                p = -p;\n            }\n            double min1 = 3.0 * m * q - Math.abs(tol * q);\n            double min2 = Math.abs(e * q);\n            if (2.0 * p < (min1 < min2 ? min1 : min2)) {\n                e = d;\n                d = p / q;\n            } else {\n                d = m;\n                e = d;\n            }\n        }\n\n        double tmp = b;\n        b = (Math.abs(d) > tol ? b + d : b + (m > 0 ? tol : -tol));\n        Double mid = Double.valueOf((a + tmp) / 2.0);\n        double fm = f.value(mid.doubleValue());\n        if ((fm > 0 && fa > 0) || (fm <= 0 && fa <= 0)) {\n            yMin = fm;\n            min = mid.doubleValue();\n        } else {\n            yMax = fm;\n            max = mid.doubleValue();\n        }\n\n        if (Math.abs(yMin) < Math.abs(yMax)) {\n            double tmp1 = min;\n            min = max;\n            max = tmp1;\n            double tmp2 = yMin;\n            yMin = yMax;\n            yMax = tmp2;\n        }\n\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, i);\n            return getResult();\n        }\n\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, i);\n            return getResult();\n        }\n\n        if (Math.abs(d) < tol && Math.abs(fm) >= Math.abs(fb)) {\n            d = m;\n            e = d;\n        }\n    }\n\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..e9d0e6f62 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,50 +95,137 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n+public double solve(final UnivariateRealFunction f,\n+                    final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+    clearResult();\n+    verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n+    double yInitial = f.value(initial);\n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n+\n+    if (yMin * yMax >= 0) {\n+        String errorMsg = String.format(\"Interval [%s, %s] does not bracket a root.\", min, max);\n+        if (min == max) {\n+            errorMsg = String.format(\"Interval [%s] does not bracket a root.\", min);\n         }\n+        throw new IllegalArgumentException(errorMsg);\n+    }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n+    if (Math.abs(yInitial) < functionValueAccuracy) {\n+        setResult(initial, 0);\n+        return result;\n+    }\n+\n+    double a = initial;\n+    double b = initial;\n+    double fa = yInitial;\n+    double fb = yInitial;\n+\n+    for (int i = 0; i < maximalIterationCount; ++i) {\n+        if (fb * yMax >= 0) {\n+            b = min;\n+            fb = yMin;\n+            double d = a - b;\n+            double e = d;\n+\n+        } else {\n+            a = max;\n+            fa = yMax;\n+            double d = a - b;\n+            double e = d;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+        if (Math.abs(fa) < Math.abs(fb)) {\n+            double tmp1 = a;\n+            a = b;\n+            b = tmp1;\n+            double tmp2 = fa;\n+            fa = fb;\n+            fb = tmp2;\n         }\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n+        double m = 0.5 * (b - a);\n+        double tol = 2.0 * absoluteAccuracy + 0.5 * Math.ulp(m);\n+        if (Math.abs(m) <= tol) {\n+            setResult((a + b) / 2.0, i);\n+            return getResult();\n+\n+        }\n+        if (Math.abs(e) < tol || Math.abs(fa) <= Math.abs(fb)) {\n+            d = m;\n+            e = d;\n+        } else {\n+            double s = fb / fa;\n+            double p;\n+            double q;\n+            if (a == initial) {\n+                p = 2.0 * m * s;\n+                q = 1.0 - s;\n+            } else {\n+                q = fa / fc;\n+                double r = fb / fc;\n+                p = s * (2.0 * m * q * (q - r) - (b - a) * (r - 1.0));\n+                q = (q - 1.0) * (r - 1.0) * (s - 1.0);\n+            }\n+            if (p > 0.0) {\n+                q = -q;\n+            } else {\n+                p = -p;\n+            }\n+            double min1 = 3.0 * m * q - Math.abs(tol * q);\n+            double min2 = Math.abs(e * q);\n+            if (2.0 * p < (min1 < min2 ? min1 : min2)) {\n+                e = d;\n+                d = p / q;\n+            } else {\n+                d = m;\n+                e = d;\n+            }\n+        }\n+\n+        double tmp = b;\n+        b = (Math.abs(d) > tol ? b + d : b + (m > 0 ? tol : -tol));\n+        Double mid = Double.valueOf((a + tmp) / 2.0);\n+        double fm = f.value(mid.doubleValue());\n+        if ((fm > 0 && fa > 0) || (fm <= 0 && fa <= 0)) {\n+            yMin = fm;\n+            min = mid.doubleValue();\n+        } else {\n+            yMax = fm;\n+            max = mid.doubleValue();\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        if (Math.abs(yMin) < Math.abs(yMax)) {\n+            double tmp1 = min;\n+            min = max;\n+            max = tmp1;\n+            double tmp2 = yMin;\n+            yMin = yMax;\n+            yMax = tmp2;\n         }\n \n+        if (Math.abs(yMax) <= functionValueAccuracy) {\n+            setResult(max, i);\n+            return getResult();\n+        }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        if (Math.abs(yMin) <= functionValueAccuracy) {\n+            setResult(min, i);\n+            return getResult();\n+        }\n \n+        if (Math.abs(d) < tol && Math.abs(fm) >= Math.abs(fb)) {\n+            d = m;\n+            e = d;\n+        }\n     }\n \n+    throw new MaxIterationsExceededException(maximalIterationCount);\n+}\n+\n     /**\n      * Find a zero in the given interval.\n      * <p>",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}