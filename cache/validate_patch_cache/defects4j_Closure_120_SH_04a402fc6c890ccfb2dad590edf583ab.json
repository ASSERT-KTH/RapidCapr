{
    "patch": "private boolean isInitializingDeclarationAt(int index) {\n  if (index < references.size()) {\n    Reference maybeDecl = references.get(index);\n    if (maybeDecl.isVarDeclaration()) {\n      return !maybeDecl.isInitializingDeclaration();\n    }\n  }\n  return false;\n}\n\nprivate boolean isInitializingAssignmentAt(int index) {\n  if (index > 0 && index < references.size()) {\n    Reference maybeDecl = references.get(index - 1);\n    Reference maybeInit = references.get(index);\n    if (maybeDecl.isVarDeclaration() && maybeInit.isSimpleAssignmentToName()) {\n      String varName = maybeDecl.getNode().getString();\n      Node valueNode = maybeInit.getNode().getFirstChild().getNext();\n      // Check if the variable is assigned with a constant value.\n      if (NodeUtil.isLiteralValue(valueNode, true)) {\n        String value = valueNode.getString();\n        Scope hoistScope = maybeInit.getScope().getClosestHoistScope();\n        TypedVar var = hoistScope.getVar(varName);\n        if (var != null && var.isGlobal()) {\n          Object globalValue = var.getInitialValue();\n          return globalValue != null && globalValue.toString().equals(value);\n        }\n      }\n      // Check if the variable is assigned with a value from a parameter or the this object.\n      if (valueNode.isName() &&\n          (valueNode.getString().equals(\"this\") || maybeDecl.getParent().getParent().isParamList())) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\n/**\n * @return The reference that provides the value for the variable at the\n * time of the first read, if known, otherwise null.\n *\n * This is either the variable declaration (\"var a = ...\") or first\n * reference following the declaration if it is an assignment.\n */\nReference getInitializingReference() {\n  int size = references.size();\n  for (int i = 0; i < size; i++) {\n    if (isInitializingDeclarationAt(i)) {\n      return references.get(i);\n    } else if (isInitializingAssignmentAt(i)) {\n      return references.get(i);\n    }\n  }\n  return null;\n}\n\n/**\n * Constants are allowed to be defined after their first use.\n */\nReference getInitializingReferenceForConstants() {\n  int size = references.size();\n  for (int i = 0; i < size; i++) {\n    if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n      return references.get(i);\n    }\n  }\n  return null;\n}\n\n/**\n * @return Whether the variable is only assigned a value once for its\n *     lifetime.\n */\nboolean isAssignedOnceInLifetime() {\n  Reference ref = getOneAndOnlyAssignment();\n  if (ref == null) {\n    return false;\n  }\n  if (ref.isParamOrThis()) {\n    return true;\n  }\n  Scope refScope = ref.getScope();\n  Scope closestHoistScope = refScope.getClosestHoistScope();\n  boolean inLValueAssignedFunction = false;\n  Node refParent = ref.getParent().getParent();\n  if (refParent.isFunction()) {\n    Node fnNameNode = refParent.getFirstChild();\n    inLValueAssignedFunction =\n        NodeUtil.isFunctionDeclaration(fnNameNode)\n            || NodeUtil.isLhsOfAssign(fnNameNode)\n                && NodeUtil.isName(fnNameNode.getFirstChild())\n                && fnNameNode.getFirstChild().getString().equals(ref.getName());\n  }\n  // Check all assignments to this variable.\n  for (Reference otherRef : getVariableReferences()) {\n    if (otherRef == ref) {\n      continue;\n    }\n    Node otherRefParent = otherRef.getParent().getParent();\n    if (otherRef.isParamOrThis()) {\n      continue;\n    }\n    if (otherRef.isLvalue() && inLValueAssignedFunction\n        && otherRef.getScope().getVar(ref.getName()) == closestHoistScope.getVar(ref.getName())\n        && otherRefParent.isAssign() && otherRef.getBasicBlock() == ref.getBasicBlock()) {\n      // This is an assignment in a function whose return, callback, or assignment with the\n      // variable lvalue on the left-hand side will be the initializing assignment for this\n      // reference.\n      continue;\n    }\n    Scope otherRefScope = otherRef.getScope();\n    if (otherRefScope.getClosestHoistScope() != closestHoistScope) {\n      // If this reference and the other reference being compared are not in the same hoist scope,\n      // then they  must be in different functions or blocks or functions nested within another\n      // function. Since it is not known whether the variable is assigned in both scopes or just\n      // one, assume it is assigned in both.\n      continue;\n    }\n    BasicBlock otherRefBlock = otherRef.getBasicBlock();\n    if (otherRefScope.isGlobal() && otherRefBlock != null && !otherRefBlock.isFunction) {\n      // Only consider global assignments in functions.\n      continue;\n    }\n    BasicBlock block = otherRefBlock;\n    if (block == null) {\n      // For references that are not in basic blocks, we need to walk up the AST to find the nearest\n      // enclosing block and see if it is a loop or function.\n      for (Node node = otherRef.getNode(); node != null; node = node.getParent()) {\n        if (node.isFunction()) {\n          block = otherRef.getScope().getBlock();\n          break;\n        } else if (NodeUtil.isLoopStructure(node)) {\n          block = blockForLoopNode(node);\n          break;\n        }\n      }\n    }\n    Preconditions.checkNotNull(block);\n    if (block.isFunction) {\n      // Only consider an assignment within a function as an initializing\n      // assignment if it is the first assignment or declaration of the\n      // variable's lifetime.\n      Reference initRef = getInitializingReference();\n      if (initRef == null || initRef == ref ||\n          (initRef.isVarDeclaration() && initRef.getParent() == ref.getParent())) {\n        return true;\n      } else {\n        return false;\n      }\n    } else if (block.isLoop && block != ref.getBasicBlock()) {\n      return false;\n    }\n  }\n  return true;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..c8f061bc 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,161 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+private boolean isInitializingDeclarationAt(int index) {\n+  if (index < references.size()) {\n+    Reference maybeDecl = references.get(index);\n+    if (maybeDecl.isVarDeclaration()) {\n+      return !maybeDecl.isInitializingDeclaration();\n+    }\n+  }\n+  return false;\n+}\n+\n+private boolean isInitializingAssignmentAt(int index) {\n+  if (index > 0 && index < references.size()) {\n+    Reference maybeDecl = references.get(index - 1);\n+    Reference maybeInit = references.get(index);\n+    if (maybeDecl.isVarDeclaration() && maybeInit.isSimpleAssignmentToName()) {\n+      String varName = maybeDecl.getNode().getString();\n+      Node valueNode = maybeInit.getNode().getFirstChild().getNext();\n+      // Check if the variable is assigned with a constant value.\n+      if (NodeUtil.isLiteralValue(valueNode, true)) {\n+        String value = valueNode.getString();\n+        Scope hoistScope = maybeInit.getScope().getClosestHoistScope();\n+        TypedVar var = hoistScope.getVar(varName);\n+        if (var != null && var.isGlobal()) {\n+          Object globalValue = var.getInitialValue();\n+          return globalValue != null && globalValue.toString().equals(value);\n+        }\n+      }\n+      // Check if the variable is assigned with a value from a parameter or the this object.\n+      if (valueNode.isName() &&\n+          (valueNode.getString().equals(\"this\") || maybeDecl.getParent().getParent().isParamList())) {\n+        return true;\n+      }\n+    }\n+  }\n+  return false;\n+}\n+\n+/**\n+ * @return The reference that provides the value for the variable at the\n+ * time of the first read, if known, otherwise null.\n+ *\n+ * This is either the variable declaration (\"var a = ...\") or first\n+ * reference following the declaration if it is an assignment.\n+ */\n+Reference getInitializingReference() {\n+  int size = references.size();\n+  for (int i = 0; i < size; i++) {\n+    if (isInitializingDeclarationAt(i)) {\n+      return references.get(i);\n+    } else if (isInitializingAssignmentAt(i)) {\n+      return references.get(i);\n+    }\n+  }\n+  return null;\n+}\n+\n+/**\n+ * Constants are allowed to be defined after their first use.\n+ */\n+Reference getInitializingReferenceForConstants() {\n+  int size = references.size();\n+  for (int i = 0; i < size; i++) {\n+    if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n+      return references.get(i);\n+    }\n+  }\n+  return null;\n+}\n+\n+/**\n+ * @return Whether the variable is only assigned a value once for its\n+ *     lifetime.\n+ */\n+boolean isAssignedOnceInLifetime() {\n+  Reference ref = getOneAndOnlyAssignment();\n+  if (ref == null) {\n+    return false;\n+  }\n+  if (ref.isParamOrThis()) {\n+    return true;\n+  }\n+  Scope refScope = ref.getScope();\n+  Scope closestHoistScope = refScope.getClosestHoistScope();\n+  boolean inLValueAssignedFunction = false;\n+  Node refParent = ref.getParent().getParent();\n+  if (refParent.isFunction()) {\n+    Node fnNameNode = refParent.getFirstChild();\n+    inLValueAssignedFunction =\n+        NodeUtil.isFunctionDeclaration(fnNameNode)\n+            || NodeUtil.isLhsOfAssign(fnNameNode)\n+                && NodeUtil.isName(fnNameNode.getFirstChild())\n+                && fnNameNode.getFirstChild().getString().equals(ref.getName());\n+  }\n+  // Check all assignments to this variable.\n+  for (Reference otherRef : getVariableReferences()) {\n+    if (otherRef == ref) {\n+      continue;\n+    }\n+    Node otherRefParent = otherRef.getParent().getParent();\n+    if (otherRef.isParamOrThis()) {\n+      continue;\n+    }\n+    if (otherRef.isLvalue() && inLValueAssignedFunction\n+        && otherRef.getScope().getVar(ref.getName()) == closestHoistScope.getVar(ref.getName())\n+        && otherRefParent.isAssign() && otherRef.getBasicBlock() == ref.getBasicBlock()) {\n+      // This is an assignment in a function whose return, callback, or assignment with the\n+      // variable lvalue on the left-hand side will be the initializing assignment for this\n+      // reference.\n+      continue;\n+    }\n+    Scope otherRefScope = otherRef.getScope();\n+    if (otherRefScope.getClosestHoistScope() != closestHoistScope) {\n+      // If this reference and the other reference being compared are not in the same hoist scope,\n+      // then they  must be in different functions or blocks or functions nested within another\n+      // function. Since it is not known whether the variable is assigned in both scopes or just\n+      // one, assume it is assigned in both.\n+      continue;\n+    }\n+    BasicBlock otherRefBlock = otherRef.getBasicBlock();\n+    if (otherRefScope.isGlobal() && otherRefBlock != null && !otherRefBlock.isFunction) {\n+      // Only consider global assignments in functions.\n+      continue;\n+    }\n+    BasicBlock block = otherRefBlock;\n+    if (block == null) {\n+      // For references that are not in basic blocks, we need to walk up the AST to find the nearest\n+      // enclosing block and see if it is a loop or function.\n+      for (Node node = otherRef.getNode(); node != null; node = node.getParent()) {\n+        if (node.isFunction()) {\n+          block = otherRef.getScope().getBlock();\n+          break;\n+        } else if (NodeUtil.isLoopStructure(node)) {\n+          block = blockForLoopNode(node);\n+          break;\n+        }\n+      }\n+    }\n+    Preconditions.checkNotNull(block);\n+    if (block.isFunction) {\n+      // Only consider an assignment within a function as an initializing\n+      // assignment if it is the first assignment or declaration of the\n+      // variable's lifetime.\n+      Reference initRef = getInitializingReference();\n+      if (initRef == null || initRef == ref ||\n+          (initRef.isVarDeclaration() && initRef.getParent() == ref.getParent())) {\n+        return true;\n+      } else {\n+        return false;\n+      }\n+    } else if (block.isLoop && block != ref.getBasicBlock()) {\n+      return false;\n+    }\n+  }\n+  return true;\n+}\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}