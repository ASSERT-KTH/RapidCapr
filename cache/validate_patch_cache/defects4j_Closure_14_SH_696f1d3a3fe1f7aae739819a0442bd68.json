{
    "patch": "              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n            }\n          }\n          return computeFollowNode(fromNode, parent, cfa);\n        case Token.FUNCTION:\n          // Ignore empty functions\n          if (NodeUtil.isEmptyFunction(parent)) {\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n          // FALLTHROUGH\n        default:\n          // Now that we are done with the special cases follow should be its\n          // immediate sibling, unless its sibling is a function\n          Node nextSibling = node.getNext();\n\n          // Skip function declarations because control doesn't get pass into it.\n          while (nextSibling != null && nextSibling.isFunction()) {\n            nextSibling = nextSibling.getNext();\n          }\n\n          if (nextSibling != null) {\n            return computeFallThrough(nextSibling);\n          } else {\n            // If there are no more siblings, control is transferred up the AST.\n            return computeFollowNode(fromNode, parent, cfa);\n          }\n      }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..f1afa82f 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -768,6 +768,33 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);\n+        case Token.FUNCTION:\n+          // Ignore empty functions\n+          if (NodeUtil.isEmptyFunction(parent)) {\n+            return computeFollowNode(fromNode, parent, cfa);\n+          }\n+          // FALLTHROUGH\n+        default:\n+          // Now that we are done with the special cases follow should be its\n+          // immediate sibling, unless its sibling is a function\n+          Node nextSibling = node.getNext();\n+\n+          // Skip function declarations because control doesn't get pass into it.\n+          while (nextSibling != null && nextSibling.isFunction()) {\n+            nextSibling = nextSibling.getNext();\n+          }\n+\n+          if (nextSibling != null) {\n+            return computeFallThrough(nextSibling);\n+          } else {\n+            // If there are no more siblings, control is transferred up the AST.\n+            return computeFollowNode(fromNode, parent, cfa);\n+          }\n+      }\n+  }\n+            }\n+          }\n+          return computeFollowNode(fromNode, parent, cfa);\n         }\n     }\n ",
    "result_reason": "error: orphaned case",
    "test_result": "ERROR"
}