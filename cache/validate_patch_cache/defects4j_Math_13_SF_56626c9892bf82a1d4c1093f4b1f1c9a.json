{
    "patch": "import org.apache.commons.math3.linear.*;\n\npublic RealMatrix squareRoot(RealMatrix m) {\n    // Convert the matrix to the CSC format\n    int[] ptr = new int[m.getColumnDimension() + 1];\n    int[] ind = new int[m.getData().length];\n    double[] val = new double[m.getData().length];\n    int nnz = 0;\n    for (int j = 0; j < m.getColumnDimension(); j++) {\n        ptr[j] = nnz;\n        for (int i = 0; i < m.getRowDimension(); i++) {\n            double v = m.getEntry(i, j);\n            if (v != 0) {\n                ind[nnz] = i;\n                val[nnz] = v;\n                nnz++;\n            }\n        }\n    }\n    ptr[m.getColumnDimension()] = nnz;\n    SparseRealMatrix sm = new OpenMapRealMatrix(m.getRowDimension(), m.getColumnDimension(), nnz);\n    ((SparseRealMatrix) sm).setSparseColumnMatrix(new SparseColumnMatrix(ptr, ind, val));\n\n    // Compute the square root using the Newton\u2013Schulz algorithm\n    EigenDecomposition dec = new EigenDecomposition(sm);\n    RealMatrix d = dec.getD();\n    RealMatrix v = dec.getV();\n    for (int i = 0; i < d.getRowDimension(); i++) {\n        double sqrt = Math.sqrt(d.getEntry(i, i));\n        d.setEntry(i, i, sqrt);\n    }\n    RealMatrix dinv = new LUDecomposition(d).getSolver().getInverse();\n    RealMatrix b = v.multiply(dinv).multiply(v.transpose());\n    RealMatrix x = sm.scalarMultiply(0.5);\n    RealMatrix prev = null;\n    while (prev == null || MatrixUtils.checkNorm(x.subtract(prev), 1e-9) > 0) {\n        prev = x;\n        x = prev.multiply(3).subtract(b.multiply(prev.multiply(prev))).multiply(0.5);\n    }\n    return x;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..08c17659b 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,45 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+import org.apache.commons.math3.linear.*;\n+\n+public RealMatrix squareRoot(RealMatrix m) {\n+    // Convert the matrix to the CSC format\n+    int[] ptr = new int[m.getColumnDimension() + 1];\n+    int[] ind = new int[m.getData().length];\n+    double[] val = new double[m.getData().length];\n+    int nnz = 0;\n+    for (int j = 0; j < m.getColumnDimension(); j++) {\n+        ptr[j] = nnz;\n+        for (int i = 0; i < m.getRowDimension(); i++) {\n+            double v = m.getEntry(i, j);\n+            if (v != 0) {\n+                ind[nnz] = i;\n+                val[nnz] = v;\n+                nnz++;\n+            }\n+        }\n+    }\n+    ptr[m.getColumnDimension()] = nnz;\n+    SparseRealMatrix sm = new OpenMapRealMatrix(m.getRowDimension(), m.getColumnDimension(), nnz);\n+    ((SparseRealMatrix) sm).setSparseColumnMatrix(new SparseColumnMatrix(ptr, ind, val));\n+\n+    // Compute the square root using the Newton\u2013Schulz algorithm\n+    EigenDecomposition dec = new EigenDecomposition(sm);\n+    RealMatrix d = dec.getD();\n+    RealMatrix v = dec.getV();\n+    for (int i = 0; i < d.getRowDimension(); i++) {\n+        double sqrt = Math.sqrt(d.getEntry(i, i));\n+        d.setEntry(i, i, sqrt);\n     }\n+    RealMatrix dinv = new LUDecomposition(d).getSolver().getInverse();\n+    RealMatrix b = v.multiply(dinv).multiply(v.transpose());\n+    RealMatrix x = sm.scalarMultiply(0.5);\n+    RealMatrix prev = null;\n+    while (prev == null || MatrixUtils.checkNorm(x.subtract(prev), 1e-9) > 0) {\n+        prev = x;\n+        x = prev.multiply(3).subtract(b.multiply(prev.multiply(prev))).multiply(0.5);\n+    }\n+    return x;\n+}\n }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}