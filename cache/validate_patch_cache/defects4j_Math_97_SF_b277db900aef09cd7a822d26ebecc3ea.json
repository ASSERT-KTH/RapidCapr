{
    "patch": "import org.apache.commons.math3.util.Precision;\n\npublic double solve(UnivariateFunction f, double min, double max, double absoluteAccuracy)\n    throws MaxIterationsExceededException, FunctionEvaluationException {\n    clearResult();\n    MathUtils.checkNotNull(f);\n    verifyInterval(min, max);\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    final int maxIterations = getMaximalIterationCount();\n    double x;\n    double yMid;\n    double xMid = Double.NaN;\n    double yPrev = Double.NaN;\n    double xPrev = Double.NaN;\n    double bisect;\n    double delta;\n    int i = 0;\n\n    // Verify bracketing of initial interval\n    if (yMin * yMax >= 0.0) {\n        if (Precision.equals(yMin, 0.0, absoluteAccuracy)) {\n            setResult(min, i);\n            return min;\n        }\n        if (Precision.equals(yMax, 0.0, absoluteAccuracy)) {\n            setResult(max, i);\n            return max;\n        }\n        // linear interpolation can't start\n        throw new NoBracketingException(min, max, yMin, yMax);\n    }\n\n    double xAcc = Precision.getScaledAbsoluteAccuracy(min, max, absoluteAccuracy);\n    while (i < maxIterations) {\n\n        // calculate the midpoint\n        xMid = 0.5 * (min + max);\n        final double yMidPoint = f.value(xMid);\n\n        // check for convergence\n        if ((i != 0) && (Precision.equals(yMidPoint, 0.0, absoluteAccuracy))) {\n            setResult(xMid, i);\n            return getResult();\n        }\n        // check for same y values consecutive iterations (unlikely)\n        if (i != 0) {\n            if (Precision.equals(yMidPoint, yPrev, absoluteAccuracy)) {\n                // If this happens either the function is pathological (i.e.\n                // it's a bizarre polynomial that evaluates to zero at a set of\n                // isolated points), or the iteration has lost accuracy.\n                // Since there is no way to tell the difference, simply cut\n                // the iteration short.\n                setResult(xMid, i);\n                return getResult();\n            }\n        }\n        // evaluate midpoint\n        yMid = f.value(xMid);\n\n        // Create new result object\n        final UnivariateSolverUtils.LocalRootPair previous = new UnivariateSolverUtils.LocalRootPair(xMid, yMid);\n\n        // Increment iteration count\n        ++i;\n\n        // bisect\n        if (yMid * yMin <= 0) {\n\n            // [xMin, xMid] contains a sign change\n            max = xMid;\n            yMax = yMid;\n\n        } else {\n            // [xMid, xMax] contains a sign change\n            min = xMid;\n            yMin = yMid;\n        }\n\n        // check for convergence\n        if (Precision.equals(max - min, xAcc)) {\n            bisect = (max + min) * 0.5;\n            delta = Math.abs(bisect - xMid);\n            if (delta <= xAcc) {\n                setResult(bisect, i);\n                return getResult();\n            }\n        }\n\n        // update previous point\n        xPrev = xMid;\n        yPrev = yMidPoint;\n    }\n\n    // maximum number of iterations exceeded\n    throw new MaxIterationsExceededException(maxIterations);\n\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..ce22875c9 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,34 +122,104 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n-        \n-        clearResult();\n-        verifyInterval(min, max);\n-        \n-        double ret = Double.NaN;\n-        \n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n-        \n-        // Verify bracketing\n-        double sign = yMin * yMax;\n-        if (sign >= 0) {\n-            // check if either value is close to a zero\n-                // neither value is close to zero and min and max do not bracket root.\n-                throw new IllegalArgumentException\n-                (\"Function values at endpoints do not have different signs.\" +\n-                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n-                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+import org.apache.commons.math3.util.Precision;\n+\n+public double solve(UnivariateFunction f, double min, double max, double absoluteAccuracy)\n+    throws MaxIterationsExceededException, FunctionEvaluationException {\n+    clearResult();\n+    MathUtils.checkNotNull(f);\n+    verifyInterval(min, max);\n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n+    final int maxIterations = getMaximalIterationCount();\n+    double x;\n+    double yMid;\n+    double xMid = Double.NaN;\n+    double yPrev = Double.NaN;\n+    double xPrev = Double.NaN;\n+    double bisect;\n+    double delta;\n+    int i = 0;\n+\n+    // Verify bracketing of initial interval\n+    if (yMin * yMax >= 0.0) {\n+        if (Precision.equals(yMin, 0.0, absoluteAccuracy)) {\n+            setResult(min, i);\n+            return min;\n+        }\n+        if (Precision.equals(yMax, 0.0, absoluteAccuracy)) {\n+            setResult(max, i);\n+            return max;\n+        }\n+        // linear interpolation can't start\n+        throw new NoBracketingException(min, max, yMin, yMax);\n+    }\n+\n+    double xAcc = Precision.getScaledAbsoluteAccuracy(min, max, absoluteAccuracy);\n+    while (i < maxIterations) {\n+\n+        // calculate the midpoint\n+        xMid = 0.5 * (min + max);\n+        final double yMidPoint = f.value(xMid);\n+\n+        // check for convergence\n+        if ((i != 0) && (Precision.equals(yMidPoint, 0.0, absoluteAccuracy))) {\n+            setResult(xMid, i);\n+            return getResult();\n+        }\n+        // check for same y values consecutive iterations (unlikely)\n+        if (i != 0) {\n+            if (Precision.equals(yMidPoint, yPrev, absoluteAccuracy)) {\n+                // If this happens either the function is pathological (i.e.\n+                // it's a bizarre polynomial that evaluates to zero at a set of\n+                // isolated points), or the iteration has lost accuracy.\n+                // Since there is no way to tell the difference, simply cut\n+                // the iteration short.\n+                setResult(xMid, i);\n+                return getResult();\n+            }\n+        }\n+        // evaluate midpoint\n+        yMid = f.value(xMid);\n+\n+        // Create new result object\n+        final UnivariateSolverUtils.LocalRootPair previous = new UnivariateSolverUtils.LocalRootPair(xMid, yMid);\n+\n+        // Increment iteration count\n+        ++i;\n+\n+        // bisect\n+        if (yMid * yMin <= 0) {\n+\n+            // [xMin, xMid] contains a sign change\n+            max = xMid;\n+            yMax = yMid;\n+\n         } else {\n-            // solve using only the first endpoint as initial guess\n-            ret = solve(min, yMin, max, yMax, min, yMin);\n-            // either min or max is a root\n+            // [xMid, xMax] contains a sign change\n+            min = xMid;\n+            yMin = yMid;\n+        }\n+\n+        // check for convergence\n+        if (Precision.equals(max - min, xAcc)) {\n+            bisect = (max + min) * 0.5;\n+            delta = Math.abs(bisect - xMid);\n+            if (delta <= xAcc) {\n+                setResult(bisect, i);\n+                return getResult();\n+            }\n         }\n \n-        return ret;\n+        // update previous point\n+        xPrev = xMid;\n+        yPrev = yMidPoint;\n     }\n+\n+    // maximum number of iterations exceeded\n+    throw new MaxIterationsExceededException(maxIterations);\n+\n+}\n         \n     /**\n      * Find a zero starting search according to the three provided points.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}