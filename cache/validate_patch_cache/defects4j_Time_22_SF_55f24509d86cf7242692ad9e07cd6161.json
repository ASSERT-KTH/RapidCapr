{
    "patch": "        super();\n        iPeriod = createFields(duration, getDefaultPeriodType());\n        iDuration = duration;\n    }\n\n    private PeriodType getDefaultPeriodType() {\n        PeriodType periodType;\n        if (iType != null) {\n            periodType = iType.withYearsRemoved();\n        } else {\n            periodType = PeriodType.standard().withYearsRemoved();\n        }\n        return periodType;\n    }\n\n    private static PeriodType createPeriodType(boolean year, boolean month,\n            boolean week, boolean day, boolean hour, boolean minute, boolean second, boolean milli) {\n        if (! (year || month || day || week || hour || minute || second || milli)) {\n            throw new IllegalArgumentException(\"At least one field must be supported\");\n        }\n        return new PeriodType(\n                year ? new Years() : null,\n                month ? new Months() : null,\n                week ? new Weeks() : null,\n                day ? new Days() : null,\n                hour ? new Hours() : null,\n                minute ? new Minutes() : null,\n                second ? new Seconds() : null,\n                milli ? new Millis() : null\n        );\n    }\n\n    private static Period createFields(long duration, PeriodType type) {\n        MutablePeriod period = new MutablePeriod(0L, type);\n        long totalMillis = duration;\n        if (type.isSupported(DurationFieldType.years())) {\n            long years = totalMillis / DateTimeConstants.MILLIS_PER_YEAR;\n            period.setYears((int) years);\n            totalMillis = FieldUtils.safeSubtract(totalMillis, years * DateTimeConstants.MILLIS_PER_YEAR);\n        }\n        if (type.isSupported(DurationFieldType.months())) {\n            long months = totalMillis / DateTimeConstants.MILLIS_PER_MONTH;\n            period.setMonths((int) months);\n            totalMillis = FieldUtils.safeSubtract(totalMillis, months * DateTimeConstants.MILLIS_PER_MONTH);\n        }\n        if (type.isSupported(DurationFieldType.weeks())) {\n            long weeks = totalMillis / DateTimeConstants.MILLIS_PER_WEEK;\n            period.setWeeks((int) weeks);\n            totalMillis = FieldUtils.safeSubtract(totalMillis, weeks * DateTimeConstants.MILLIS_PER_WEEK);\n        }\n        if (type.isSupported(DurationFieldType.days())) {\n            long days = totalMillis / DateTimeConstants.MILLIS_PER_DAY;\n            period.setDays((int) days);\n            totalMillis = FieldUtils.safeSubtract(totalMillis, days * DateTimeConstants.MILLIS_PER_DAY);\n        }\n        if (type.isSupported(DurationFieldType.hours())) {\n            long hours = totalMillis / DateTimeConstants.MILLIS_PER_HOUR;\n            period.setHours((int) hours);\n            totalMillis = FieldUtils.safeSubtract(totalMillis, hours * DateTimeConstants.MILLIS_PER_HOUR);\n        }\n        if (type.isSupported(DurationFieldType.minutes())) {\n            long minutes = totalMillis / DateTimeConstants.MILLIS_PER_MINUTE;\n            period.setMinutes((int) minutes);\n            totalMillis = FieldUtils.safeSubtract(totalMillis, minutes * DateTimeConstants.MILLIS_PER_MINUTE);\n        }\n        if (type.isSupported(DurationFieldType.seconds())) {\n            long seconds = totalMillis / DateTimeConstants.MILLIS_PER_SECOND;\n            period.setSeconds((int) seconds);\n            totalMillis = FieldUtils.safeSubtract(totalMillis, seconds * DateTimeConstants.MILLIS_PER_SECOND);\n        }\n        if (type.isSupported(DurationFieldType.millis())) {\n            period.setMillis((int) totalMillis);\n        } else if (totalMillis != 0) {\n            throw new IllegalArgumentException(\"Duration contains non-zero milliseconds but period type does not support them\");\n        }\n        return period.toPeriod();",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/base/BasePeriod.java b/src/main/java/org/joda/time/base/BasePeriod.java\nindex 679b734a..7cbc7de8 100644\n--- a/src/main/java/org/joda/time/base/BasePeriod.java\n+++ b/src/main/java/org/joda/time/base/BasePeriod.java\n@@ -218,11 +218,83 @@ public abstract class BasePeriod\n      *\n      * @param duration  the duration, in milliseconds\n      */\n-    protected BasePeriod(long duration) {\n-        this(duration, null, null);\n-        // bug [3264409]\n+        super();\n+        iPeriod = createFields(duration, getDefaultPeriodType());\n+        iDuration = duration;\n+    }\n+\n+    private PeriodType getDefaultPeriodType() {\n+        PeriodType periodType;\n+        if (iType != null) {\n+            periodType = iType.withYearsRemoved();\n+        } else {\n+            periodType = PeriodType.standard().withYearsRemoved();\n+        }\n+        return periodType;\n     }\n \n+    private static PeriodType createPeriodType(boolean year, boolean month,\n+            boolean week, boolean day, boolean hour, boolean minute, boolean second, boolean milli) {\n+        if (! (year || month || day || week || hour || minute || second || milli)) {\n+            throw new IllegalArgumentException(\"At least one field must be supported\");\n+        }\n+        return new PeriodType(\n+                year ? new Years() : null,\n+                month ? new Months() : null,\n+                week ? new Weeks() : null,\n+                day ? new Days() : null,\n+                hour ? new Hours() : null,\n+                minute ? new Minutes() : null,\n+                second ? new Seconds() : null,\n+                milli ? new Millis() : null\n+        );\n+    }\n+\n+    private static Period createFields(long duration, PeriodType type) {\n+        MutablePeriod period = new MutablePeriod(0L, type);\n+        long totalMillis = duration;\n+        if (type.isSupported(DurationFieldType.years())) {\n+            long years = totalMillis / DateTimeConstants.MILLIS_PER_YEAR;\n+            period.setYears((int) years);\n+            totalMillis = FieldUtils.safeSubtract(totalMillis, years * DateTimeConstants.MILLIS_PER_YEAR);\n+        }\n+        if (type.isSupported(DurationFieldType.months())) {\n+            long months = totalMillis / DateTimeConstants.MILLIS_PER_MONTH;\n+            period.setMonths((int) months);\n+            totalMillis = FieldUtils.safeSubtract(totalMillis, months * DateTimeConstants.MILLIS_PER_MONTH);\n+        }\n+        if (type.isSupported(DurationFieldType.weeks())) {\n+            long weeks = totalMillis / DateTimeConstants.MILLIS_PER_WEEK;\n+            period.setWeeks((int) weeks);\n+            totalMillis = FieldUtils.safeSubtract(totalMillis, weeks * DateTimeConstants.MILLIS_PER_WEEK);\n+        }\n+        if (type.isSupported(DurationFieldType.days())) {\n+            long days = totalMillis / DateTimeConstants.MILLIS_PER_DAY;\n+            period.setDays((int) days);\n+            totalMillis = FieldUtils.safeSubtract(totalMillis, days * DateTimeConstants.MILLIS_PER_DAY);\n+        }\n+        if (type.isSupported(DurationFieldType.hours())) {\n+            long hours = totalMillis / DateTimeConstants.MILLIS_PER_HOUR;\n+            period.setHours((int) hours);\n+            totalMillis = FieldUtils.safeSubtract(totalMillis, hours * DateTimeConstants.MILLIS_PER_HOUR);\n+        }\n+        if (type.isSupported(DurationFieldType.minutes())) {\n+            long minutes = totalMillis / DateTimeConstants.MILLIS_PER_MINUTE;\n+            period.setMinutes((int) minutes);\n+            totalMillis = FieldUtils.safeSubtract(totalMillis, minutes * DateTimeConstants.MILLIS_PER_MINUTE);\n+        }\n+        if (type.isSupported(DurationFieldType.seconds())) {\n+            long seconds = totalMillis / DateTimeConstants.MILLIS_PER_SECOND;\n+            period.setSeconds((int) seconds);\n+            totalMillis = FieldUtils.safeSubtract(totalMillis, seconds * DateTimeConstants.MILLIS_PER_SECOND);\n+        }\n+        if (type.isSupported(DurationFieldType.millis())) {\n+            period.setMillis((int) totalMillis);\n+        } else if (totalMillis != 0) {\n+            throw new IllegalArgumentException(\"Duration contains non-zero milliseconds but period type does not support them\");\n+        }\n+        return period.toPeriod();\n+\n     /**\n      * Creates a period from the given millisecond duration, which is only really\n      * suitable for durations less than one day.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}