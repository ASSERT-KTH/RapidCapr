{
    "patch": "private void readTypeVariables() {\n    for (Type type : typeVariable.getBounds()) {\n        registerTypeVariablesOn(type);\n    }\n    Type actualTypeArgument = getActualTypeArgumentFor(typeVariable);\n    if (actualTypeArgument != null) {\n        if (actualTypeArgument instanceof Class && ((Class<?>) actualTypeArgument).getTypeParameters().length > 0) {\n            // actualTypeArgument is a raw type, so get its type arguments\n            actualTypeArgument = getTypeArgumentsFromRawType((Class<?>) actualTypeArgument, typeVariable.getGenericDeclaration());\n        }\n        registerTypeVariablesOn(actualTypeArgument);\n    }\n}\n\nprivate Type getTypeArgumentsFromRawType(Class<?> rawType, GenericDeclaration genericDeclaration) {\n    // get the type parameters for the raw type\n    TypeVariable<?>[] typeParameters = rawType.getTypeParameters();\n    // get the type arguments for the generic declaration\n    Type[] typeArguments = genericDeclaration.getTypeParameters();\n    // create a map to store the type parameter to type argument mappings\n    Map<String, Type> typeParameterMappings = new LinkedHashMap<>();\n    // map the type parameter names to their corresponding type arguments\n    for (int i = 0; i < typeParameters.length && i < typeArguments.length; i++) {\n        typeParameterMappings.put(typeParameters[i].getName(), typeArguments[i]);\n    }\n    // create a type factory for creating parameterized types\n    TypeFactory typeFactory = TypeFactory.defaultInstance();\n    // create a list of type arguments using the mappings for the type parameters\n    List<Type> mappedTypeArguments = new ArrayList<>();\n    for (Type typeArgument : typeParameters) {\n        mappedTypeArguments.add(typeParameterMappings.get(typeArgument.getTypeName()));\n    }\n    // create a new parameterized type with the mapped type arguments\n    return typeFactory.parameterizedType(rawType, mappedTypeArguments.toArray(new Type[0]));\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nindex 2d6c07b17..97ee9c9bd 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -372,12 +372,42 @@ public abstract class GenericMetadataSupport {\n             registerTypeParametersOn(typeParameters);\n         }\n \n-        private void readTypeVariables() {\n-            for (Type type : typeVariable.getBounds()) {\n-                registerTypeVariablesOn(type);\n-            }\n-            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n-        }\n+\n+private void readTypeVariables() {\n+    for (Type type : typeVariable.getBounds()) {\n+        registerTypeVariablesOn(type);\n+    }\n+    Type actualTypeArgument = getActualTypeArgumentFor(typeVariable);\n+    if (actualTypeArgument != null) {\n+        if (actualTypeArgument instanceof Class && ((Class<?>) actualTypeArgument).getTypeParameters().length > 0) {\n+            // actualTypeArgument is a raw type, so get its type arguments\n+            actualTypeArgument = getTypeArgumentsFromRawType((Class<?>) actualTypeArgument, typeVariable.getGenericDeclaration());\n+        }\n+        registerTypeVariablesOn(actualTypeArgument);\n+    }\n+}\n+\n+private Type getTypeArgumentsFromRawType(Class<?> rawType, GenericDeclaration genericDeclaration) {\n+    // get the type parameters for the raw type\n+    TypeVariable<?>[] typeParameters = rawType.getTypeParameters();\n+    // get the type arguments for the generic declaration\n+    Type[] typeArguments = genericDeclaration.getTypeParameters();\n+    // create a map to store the type parameter to type argument mappings\n+    Map<String, Type> typeParameterMappings = new LinkedHashMap<>();\n+    // map the type parameter names to their corresponding type arguments\n+    for (int i = 0; i < typeParameters.length && i < typeArguments.length; i++) {\n+        typeParameterMappings.put(typeParameters[i].getName(), typeArguments[i]);\n+    }\n+    // create a type factory for creating parameterized types\n+    TypeFactory typeFactory = TypeFactory.defaultInstance();\n+    // create a list of type arguments using the mappings for the type parameters\n+    List<Type> mappedTypeArguments = new ArrayList<>();\n+    for (Type typeArgument : typeParameters) {\n+        mappedTypeArguments.add(typeParameterMappings.get(typeArgument.getTypeName()));\n+    }\n+    // create a new parameterized type with the mapped type arguments\n+    return typeFactory.parameterizedType(rawType, mappedTypeArguments.toArray(new Type[0]));\n+}\n \n         @Override\n         public Class<?> rawType() {",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}