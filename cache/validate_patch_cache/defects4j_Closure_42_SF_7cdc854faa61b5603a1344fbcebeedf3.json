{
    "patch": "class TransformDispatcher implements TypeSafeDispatcher {\n\n    private static final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n\n    private static final HashMap<Integer,Integer> TOKENS_TO_REPLACE =\n            new ImmutableMap.Builder<Integer,Integer>()\n                    .put(Token.NAME, Token.LABEL_NAME)\n                    .build();\n\n    private final String sourceName;\n    private final ErrorReporter errorReporter;\n    private final TreeLogger logger;\n\n    TransformDispatcher(String sourceName, ErrorReporter errorReporter,\n                        TreeLogger logger) {\n        this.sourceName = sourceName;\n        this.errorReporter = errorReporter;\n        this.logger = logger;\n    }\n\n    private Node newNode(int type, Node first, Node second) {\n        Node node = new Node(type);\n        node.addChildToBack(first);\n        node.addChildToBack(second);\n        return node;\n    }\n\n    private Node newNode(int type, Node first, Node second, Node third) {\n        Node node = new Node(type);\n        node.addChildToBack(first);\n        node.addChildToBack(second);\n        node.addChildToBack(third);\n        return node;\n    }\n\n    private Node newNode(int type, AstNode... children) {\n        Node node = new Node(type);\n        for (AstNode child : children) {\n            node.addChildToBack(transform(child));\n        }\n        return node;\n    }\n\n    private Node transform(AstNode node) {\n        if (node == null) {\n            return null;\n        }\n        switch (node.getType()) {\n            case Token.FUNCTION:\n                return processFunction(node);\n            case Token.ARRAYLIT:\n                return processArrayLiteral((ArrayLiteral) node);\n            case Token.NUMBER:\n            case Token.STRING:\n            case Token.REGEXP:\n            case Token.NULL:\n            case Token.THIS:\n                return new Node(node.getType()).copyInformationFrom(node);\n            case Token.NAME:\n            case Token.LP:\n                // Already removed or replaced. See #processAssignment.\n                if (TOKENS_TO_REPLACE.containsKey(node.getType())) {\n                    return transformLiteral(node.getType(), node.getString());\n                }\n                //$FALL-THROUGH$\n            case Token.TRUE:\n            case Token.FALSE:\n            case Token.OBJECTLIT:\n            case Token.ARRAYCOMP:\n            case Token.OBJECTCOMP:\n            case Token.INC:\n            case Token.DEC:\n            case Token.ASSIGN:\n            case Token.ASSIGN_ADD:\n            case Token.ASSIGN_SUB:\n            case Token.ASSIGN_MUL:\n            case Token.ASSIGN_DIV:\n            case Token.ASSIGN_MOD:\n            case Token.HOOK:\n            case Token.OR:\n            case Token.AND:\n            case Token.BITOR:\n            case Token.BITXOR:\n            case Token.BITAND:\n            case Token.NE:\n            case Token.EQ:\n            case Token.LT:\n            case Token.GT:\n            case Token.LE:\n            case Token.GE:\n            case Token.INSTANCEOF:\n            case Token.ADD:\n            case Token.SUB:\n            case Token.MUL:\n            case Token.DIV:\n            case Token.MOD:\n            case Token.NOT:\n            case Token.BITNOT:\n            case Token.POS:\n            case Token.NEG:\n            case Token.DELPROP:\n            case Token.VOID:\n            case Token.TYPEOF:\n            case Token.GETPROP:\n                return newNode(node.getType(), node.getFirstChild(), node.getLastChild());\n            case Token.CALL:\n            case Token.NEW:\n                if (2 <= node.getChildCount() &&\n                        node.getLastChild().getType() == Token.BLOCK) {\n                    // Ensure there is a CALL node here. If not, it's likely an edge case with no side\n                    // effect, like (function() { })()\n                    Preconditions.checkState(\n                            node.getType() == Token.CALL || node.getType() == Token.NEW);\n                    return transformAnonymousFunction(node.getFirstChild(),\n                            (FunctionNode) node.getLastChild().getFirstChild());\n                }\n                return newNode(node.getType(), node.getFirstChild(),\n                        transform(node.getLastChild()));\n\n            case Token.INCNAME:\n            case Token.DECNAME:\n            case Token.GETPROP_NAMES:\n                return newNode(\n                        node.getType(),\n                        transform(node.getFirstChild()),\n                        node.getString() != null ? Node.newString(node.getString()) : null);\n            case Token.EXPR_RESULT:\n                return processExprStmt(node);\n            case Token.VAR:\n                return processVar(node);\n            case Token.ARGUMENTS:\n                return newNode(Token.NAME, IRFactory.ARGUMENTS);\n            case Token.BREAK:\n            case Token.CONTINUE:\n                return processBreakOrContinue(node);\n            case Token.THROW:\n                return newNode(Token.THROW, transform(node.getFirstChild()));\n            case Token.RETURN:\n                return newNode(Token.RETURN, transform(node.getFirstChild()));\n            case Token.EMPTY:\n                return new Node(Token.EMPTY);\n            case Token.WITH:\n                return newNode(Token.WITH,\n                        transform(node.getFirstChild()),\n                        transformBlock(node.getLastChild()));\n            case Token.IF:\n                return newNode(Token.IF,\n                        transform(node.getFirstChild()),\n                        transformBlock(node.getFirstChild().getNext()),\n                        node.getChildCount() == 3\n                                ? transformBlock(node.getLastChild())\n                                : null);\n            case Token.DO:\n                return newNode(Token.DO,\n                        transformBlock(node.getFirstChild()),\n                        transform(node.getLastChild()));\n            case Token.WHILE:\n                return newNode(Token.WHILE,\n                        transform(node.getFirstChild()),\n                        transformBlock(node.getLastChild()));\n            case Token.FOR:\n                return newNode(Token.FOR,\n                        transform(node.getFirstChild()),\n                        transform(node.getFirstChild().getNext()),\n                        transform(node.getFirstChild().getNext().getNext()),\n                        transformBlock(node.getLastChild()));\n            case Token.FOR_IN:\n                return processForInLoop((ForInLoop) node);\n            case Token.TRY:\n                return processTry((TryStatement) node);\n            case Token.SWITCH:\n                return processSwitch((SwitchStatement) node);\n            default:\n                throw new RuntimeException(\n                        String.format(\"Unhandled node type: %s, full node: %s\",\n                                Token.name(node.getType()), node));\n        }\n    }\n\n    private Node transformLiteral(int type, String value) {\n        return Node.newString(\n                TOKENS_TO_REPLACE.containsKey(type) ? TOKENS_TO_REPLACE.get(type) : type, value);\n    }\n\n    private Node processFunction(AstNode node) {\n        FunctionNode fn = (FunctionNode) node;\n        Preconditions.checkState(!fn.isExpressionClosure());\n        Node name = transform(fn.getFunctionName());\n        return newNode(\n                Token.FUNCTION,\n                name != null ? name : IRFactory.maybeGetAnonymousFunctionName(fn),\n                processVarArgs(fn.getParams()),\n                transform(fn.getBody()));\n    }\n\n    @Nullable\n    private Node transformAnonymousFunction(AstNode lhs, FunctionNode function) {\n        Preconditions.checkState(lhs == null || lhs.getType() == Token.NAME);\n        boolean nameNodeNonEmpty = lhs != null && !IRFactory.maybeGetAnonymousFunctionName(function)\n                .getString().isEmpty();\n        if (nameNodeNonEmpty && !function.getFunctionName().getString().isEmpty()) {\n            errorReporter.error(\n                    \"Function name disallowed, remove variable name to promote anonymous function\",\n                    sourceName,\n                    function.getFunctionName().getLineno(), \"\", 0);\n        }\n        if (lhs == null || !nameNodeNonEmpty) {\n            // Convert the named function:\n            //   foo = function bar() {...}\n            // to the anonymous form:\n            //   bar = function() {...}; bar.name = 'foo';\n            Node rhs = newNode(Token.FUNCTION,\n                    IRFactory.maybeGetAnonymousFunctionName(function),\n                    processVarArgs(function.getParams()),\n                    transform(function.getBody()));\n            rhs.putProp(Node.ORIGINALNAME_PROP, function.getFunctionName().getString());\n            if (nameNodeNonEmpty) {\n                rhs.putProp(Node.NAME_PROP, lhs.getString());\n            }\n            rhs.setLineno(function.getLineno());\n            String name = lhs == null ? IRFactory.maybeGetAnonymousFunctionName(function)\n                    .getString() : lhs.getString();\n            return newNode(Token.ASSIGN,\n                    newNode(Token.NAME, name),\n                    rhs\n            );\n        }\n        if (function.getFunctionName().getString().isEmpty()) {\n            errorReporter.error(\n                    \"Named anonymous function is not allowed. Consider assigning the function \" +\n                            \"to a variable with a valid name instead.\",\n                    sourceName,\n                    function.getLineno(), \"\", 0);\n        }\n        lhs.setType(Token.FUNCTION);\n        lhs.setJsDocNode(function.getJsDocNode());\n        lhs.addChildToFront(processVarArgs(function.getParams()));\n        lhs.addChildToBack(transform(function.getBody()));\n        return lhs;\n    }\n\n    private Node processVarArgs(Node argNode) {\n        List<Node> nodeList = new ArrayList<>();\n        int childCount = argNode.getChildCount();\n        for (int i = 0; i < childCount; i++) {\n            nodeList.add(transform(argNode.getChildAtIndex(i)));\n        }\n        return IRFactory.createArgList(nodeList);\n    }\n\n    private Node processArrayLiteral(ArrayLiteral array) {\n        List<Node> nodeList = new ArrayList<>();\n        for (AstNode element : array.getElements()) {\n            nodeList.add(transform(element));\n        }\n        return newNode(Token.ARRAYLIT, nodeList.toArray(new Node[0]));\n    }\n\n    private Node processExprStmt(AstNode node) {\n        Node first = transform(node.getFirstChild());\n        if (isDirective(node)) {\n            Node statement = new Node(Token.EXPR_RESULT);\n            statement.setIsSyntheticBlock(true);\n            statement.addChildToBack(first);\n            statement.putProp(Node.DIRECTIVE_PROP, Boolean.TRUE);\n            return statement;\n        }\n        return first;\n    }\n\n    private Node processVar(AstNode node) {\n        Preconditions.checkState(node.getType() == Token.VAR);\n        Node result = new Node(Token.BLOCK);\n        for (int i = 0; i < node.getChildCount(); i++) {\n            Node child = newNode(\n                    Token.VAR,\n                    transform(node.getChildAtIndex(i).getFirstChild()));\n            result.addChildToBack(child);\n        }\n        return result;\n    }\n\n    private Node processBreakOrContinue(AstNode node) {\n        Node result = new Node(node.getType());\n        AstNode labelNode = node.getFirstChild();\n        if (labelNode != null) {\n            Preconditions.checkState(labelNode.getType() == Token.LABEL);\n            result.addChildToBack(transform(labelNode.getFirstChild()));\n        }\n        return result;\n    }\n\n    private boolean isDirective(AstNode node) {\n        return node.getType() == Token.EXPR_RESULT &&\n                node.getFirstChild().getType() == Token.STRING &&\n                ALLOWED_DIRECTIVES.contains(node.getFirstChild().getString());\n    }\n\n    private Node newSyntheticBlock(AstNode node, Node... children) {\n        Node block = new Node(Token.BLOCK);\n        block.setIsSyntheticBlock(true);\n        addChildToBlock(block, children);\n        return block;\n    }\n\n    private void addChildToBlock(Node parent, Node... children) {\n        for (Node n : children) {\n            if (n != null) {\n                if (parent == null) {\n                    parent = new Node(Token.BLOCK);\n                    parent.setIsSyntheticBlock(true);\n                }\n                parent.addChildToBack(n);\n            }\n        }\n    }\n\n    private Node processTry(TryStatement tryStatement) {\n        Node tryBlock = transformBlock(tryStatement.getTryBlock());\n        Node finallyBlock = tryStatement.getFinallyBlock() != null\n                ? transformBlock(tryStatement.getFinallyBlock()) : null;\n        List<CatchClause> catchClauses = tryStatement.getCatchClauses();\n        if (catchClauses.isEmpty()) {\n            // We cannot arbitrarily add bogus catch blocks; it can mask problems in legitimate cases.\n            if (finallyBlock == null) {\n                errorReporter.error(\n                        \"Useless try-catch or try-finally block. Did you mean to throw the exception \" +\n                                \"out completely, or do something with it?\",\n                        sourceName,\n                        tryStatement.getLineno(), \"\", 0);\n            }\n            return newSyntheticBlock(tryStatement, tryBlock, finallyBlock);\n        }\n\n        // Try to match \"catch (foo) {...} catch (bar) {...} finally {...}\" constructs, where each\n        // catch block creates an object that is consumed by the next catch block and the finally\n        // block.\n        List<Node> catchNodes = new ArrayList<>();\n        Node catchBlock = transformBlock(catchClauses.get(0).getBody());\n        catchNodes.add(newNode(Token.CATCH, transform(catchClauses.get(0).getVarName()), catchBlock));\n        for (int i = 1; i < catchClauses.size(); i++) {\n            CatchClause catchClause = catchClauses.get(i);\n            if (catchClause.getCatchCondition() != null) {\n                // ES6+ only. Cannot convert, so bail out.\n                errorReporter.error(\n                        \"Catch clause conditions are not supported\",\n                        sourceName,\n                        catchClause.getLineno(), \"\", 0);\n                return newSyntheticBlock(tryStatement, tryBlock, finallyBlock);\n            }\n            Node body = transformBlock(catchClause.getBody());\n            // Try to find the variable declared in the current catch block in the previous blocks.\n            final String varName = catchClause.getVarName().getString();\n            int j = catchNodes.size() - 1;\n            for (; j >= 0; j--) {\n                Node catchNode = catchNodes.get(j);\n                if (catchNode.getFirstChild().getNext().getString().equals(varName)) {\n                    break;\n                }\n            }\n            Node var = new Node(Token.NAME, varName);\n            Node obj = j == -1\n                    ? new Node(Token.EMPTY)\n                    : catchNodes.get(j).getFirstChild().getFirstChild();\n            Node objectLiteral = new Node(Token.OBJECTLIT);\n            objectLiteral.addChildToBack(newNode(Token.STRING, varName));\n            objectLiteral.addChildToBack(var);\n            if (obj.getType() == Token.OBJECTLIT) {\n                // Some edge cases, like double var declaration in same node, require that we check the\n                // type of the var node and ensure it matches the presumed LHS.\n                Node lhs = obj.getFirstChild();\n                Node rhs = lhs.getNext();\n                if (lhs.getType() == Token.STRING && lhs.getString().equals(varName)) {\n                    var.setType(rhs.getType());\n                    var.copyInformationFrom(rhs);\n                }\n            }\n            obj.addChildToBack(objectLiteral);\n            catchNodes.add(newNode(Token.CATCH, newNode(Token.NAME, varName), body));\n        }\n\n        Node tryCatchBlock = newSyntheticBlock(tryStatement, tryBlock);\n        Node parent = null;\n        for (Node catchNode : catchNodes) {\n            if (parent == null) {\n                parent = newNode(Token.TRY, tryCatchBlock, catchNode);\n            } else {\n                parent.getLastChild().addChildToBack(catchNode);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..56c410bc 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,395 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher implements TypeSafeDispatcher {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    private static final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n+\n+    private static final HashMap<Integer,Integer> TOKENS_TO_REPLACE =\n+            new ImmutableMap.Builder<Integer,Integer>()\n+                    .put(Token.NAME, Token.LABEL_NAME)\n+                    .build();\n+\n+    private final String sourceName;\n+    private final ErrorReporter errorReporter;\n+    private final TreeLogger logger;\n+\n+    TransformDispatcher(String sourceName, ErrorReporter errorReporter,\n+                        TreeLogger logger) {\n+        this.sourceName = sourceName;\n+        this.errorReporter = errorReporter;\n+        this.logger = logger;\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    private Node newNode(int type, Node first, Node second) {\n+        Node node = new Node(type);\n+        node.addChildToBack(first);\n+        node.addChildToBack(second);\n+        return node;\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private Node newNode(int type, Node first, Node second, Node third) {\n+        Node node = new Node(type);\n+        node.addChildToBack(first);\n+        node.addChildToBack(second);\n+        node.addChildToBack(third);\n+        return node;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    private Node newNode(int type, AstNode... children) {\n+        Node node = new Node(type);\n+        for (AstNode child : children) {\n+            node.addChildToBack(transform(child));\n+        }\n+        return node;\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    private Node transform(AstNode node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        switch (node.getType()) {\n+            case Token.FUNCTION:\n+                return processFunction(node);\n+            case Token.ARRAYLIT:\n+                return processArrayLiteral((ArrayLiteral) node);\n+            case Token.NUMBER:\n+            case Token.STRING:\n+            case Token.REGEXP:\n+            case Token.NULL:\n+            case Token.THIS:\n+                return new Node(node.getType()).copyInformationFrom(node);\n+            case Token.NAME:\n+            case Token.LP:\n+                // Already removed or replaced. See #processAssignment.\n+                if (TOKENS_TO_REPLACE.containsKey(node.getType())) {\n+                    return transformLiteral(node.getType(), node.getString());\n+                }\n+                //$FALL-THROUGH$\n+            case Token.TRUE:\n+            case Token.FALSE:\n+            case Token.OBJECTLIT:\n+            case Token.ARRAYCOMP:\n+            case Token.OBJECTCOMP:\n+            case Token.INC:\n+            case Token.DEC:\n+            case Token.ASSIGN:\n+            case Token.ASSIGN_ADD:\n+            case Token.ASSIGN_SUB:\n+            case Token.ASSIGN_MUL:\n+            case Token.ASSIGN_DIV:\n+            case Token.ASSIGN_MOD:\n+            case Token.HOOK:\n+            case Token.OR:\n+            case Token.AND:\n+            case Token.BITOR:\n+            case Token.BITXOR:\n+            case Token.BITAND:\n+            case Token.NE:\n+            case Token.EQ:\n+            case Token.LT:\n+            case Token.GT:\n+            case Token.LE:\n+            case Token.GE:\n+            case Token.INSTANCEOF:\n+            case Token.ADD:\n+            case Token.SUB:\n+            case Token.MUL:\n+            case Token.DIV:\n+            case Token.MOD:\n+            case Token.NOT:\n+            case Token.BITNOT:\n+            case Token.POS:\n+            case Token.NEG:\n+            case Token.DELPROP:\n+            case Token.VOID:\n+            case Token.TYPEOF:\n+            case Token.GETPROP:\n+                return newNode(node.getType(), node.getFirstChild(), node.getLastChild());\n+            case Token.CALL:\n+            case Token.NEW:\n+                if (2 <= node.getChildCount() &&\n+                        node.getLastChild().getType() == Token.BLOCK) {\n+                    // Ensure there is a CALL node here. If not, it's likely an edge case with no side\n+                    // effect, like (function() { })()\n+                    Preconditions.checkState(\n+                            node.getType() == Token.CALL || node.getType() == Token.NEW);\n+                    return transformAnonymousFunction(node.getFirstChild(),\n+                            (FunctionNode) node.getLastChild().getFirstChild());\n+                }\n+                return newNode(node.getType(), node.getFirstChild(),\n+                        transform(node.getLastChild()));\n+\n+            case Token.INCNAME:\n+            case Token.DECNAME:\n+            case Token.GETPROP_NAMES:\n+                return newNode(\n+                        node.getType(),\n+                        transform(node.getFirstChild()),\n+                        node.getString() != null ? Node.newString(node.getString()) : null);\n+            case Token.EXPR_RESULT:\n+                return processExprStmt(node);\n+            case Token.VAR:\n+                return processVar(node);\n+            case Token.ARGUMENTS:\n+                return newNode(Token.NAME, IRFactory.ARGUMENTS);\n+            case Token.BREAK:\n+            case Token.CONTINUE:\n+                return processBreakOrContinue(node);\n+            case Token.THROW:\n+                return newNode(Token.THROW, transform(node.getFirstChild()));\n+            case Token.RETURN:\n+                return newNode(Token.RETURN, transform(node.getFirstChild()));\n+            case Token.EMPTY:\n+                return new Node(Token.EMPTY);\n+            case Token.WITH:\n+                return newNode(Token.WITH,\n+                        transform(node.getFirstChild()),\n+                        transformBlock(node.getLastChild()));\n+            case Token.IF:\n+                return newNode(Token.IF,\n+                        transform(node.getFirstChild()),\n+                        transformBlock(node.getFirstChild().getNext()),\n+                        node.getChildCount() == 3\n+                                ? transformBlock(node.getLastChild())\n+                                : null);\n+            case Token.DO:\n+                return newNode(Token.DO,\n+                        transformBlock(node.getFirstChild()),\n+                        transform(node.getLastChild()));\n+            case Token.WHILE:\n+                return newNode(Token.WHILE,\n+                        transform(node.getFirstChild()),\n+                        transformBlock(node.getLastChild()));\n+            case Token.FOR:\n+                return newNode(Token.FOR,\n+                        transform(node.getFirstChild()),\n+                        transform(node.getFirstChild().getNext()),\n+                        transform(node.getFirstChild().getNext().getNext()),\n+                        transformBlock(node.getLastChild()));\n+            case Token.FOR_IN:\n+                return processForInLoop((ForInLoop) node);\n+            case Token.TRY:\n+                return processTry((TryStatement) node);\n+            case Token.SWITCH:\n+                return processSwitch((SwitchStatement) node);\n+            default:\n+                throw new RuntimeException(\n+                        String.format(\"Unhandled node type: %s, full node: %s\",\n+                                Token.name(node.getType()), node));\n+        }\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private Node transformLiteral(int type, String value) {\n+        return Node.newString(\n+                TOKENS_TO_REPLACE.containsKey(type) ? TOKENS_TO_REPLACE.get(type) : type, value);\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    private Node processFunction(AstNode node) {\n+        FunctionNode fn = (FunctionNode) node;\n+        Preconditions.checkState(!fn.isExpressionClosure());\n+        Node name = transform(fn.getFunctionName());\n+        return newNode(\n+                Token.FUNCTION,\n+                name != null ? name : IRFactory.maybeGetAnonymousFunctionName(fn),\n+                processVarArgs(fn.getParams()),\n+                transform(fn.getBody()));\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    @Nullable\n+    private Node transformAnonymousFunction(AstNode lhs, FunctionNode function) {\n+        Preconditions.checkState(lhs == null || lhs.getType() == Token.NAME);\n+        boolean nameNodeNonEmpty = lhs != null && !IRFactory.maybeGetAnonymousFunctionName(function)\n+                .getString().isEmpty();\n+        if (nameNodeNonEmpty && !function.getFunctionName().getString().isEmpty()) {\n+            errorReporter.error(\n+                    \"Function name disallowed, remove variable name to promote anonymous function\",\n+                    sourceName,\n+                    function.getFunctionName().getLineno(), \"\", 0);\n+        }\n+        if (lhs == null || !nameNodeNonEmpty) {\n+            // Convert the named function:\n+            //   foo = function bar() {...}\n+            // to the anonymous form:\n+            //   bar = function() {...}; bar.name = 'foo';\n+            Node rhs = newNode(Token.FUNCTION,\n+                    IRFactory.maybeGetAnonymousFunctionName(function),\n+                    processVarArgs(function.getParams()),\n+                    transform(function.getBody()));\n+            rhs.putProp(Node.ORIGINALNAME_PROP, function.getFunctionName().getString());\n+            if (nameNodeNonEmpty) {\n+                rhs.putProp(Node.NAME_PROP, lhs.getString());\n+            }\n+            rhs.setLineno(function.getLineno());\n+            String name = lhs == null ? IRFactory.maybeGetAnonymousFunctionName(function)\n+                    .getString() : lhs.getString();\n+            return newNode(Token.ASSIGN,\n+                    newNode(Token.NAME, name),\n+                    rhs\n+            );\n+        }\n+        if (function.getFunctionName().getString().isEmpty()) {\n+            errorReporter.error(\n+                    \"Named anonymous function is not allowed. Consider assigning the function \" +\n+                            \"to a variable with a valid name instead.\",\n+                    sourceName,\n+                    function.getLineno(), \"\", 0);\n+        }\n+        lhs.setType(Token.FUNCTION);\n+        lhs.setJsDocNode(function.getJsDocNode());\n+        lhs.addChildToFront(processVarArgs(function.getParams()));\n+        lhs.addChildToBack(transform(function.getBody()));\n+        return lhs;\n+    }\n+\n+    private Node processVarArgs(Node argNode) {\n+        List<Node> nodeList = new ArrayList<>();\n+        int childCount = argNode.getChildCount();\n+        for (int i = 0; i < childCount; i++) {\n+            nodeList.add(transform(argNode.getChildAtIndex(i)));\n+        }\n+        return IRFactory.createArgList(nodeList);\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    private Node processArrayLiteral(ArrayLiteral array) {\n+        List<Node> nodeList = new ArrayList<>();\n+        for (AstNode element : array.getElements()) {\n+            nodeList.add(transform(element));\n+        }\n+        return newNode(Token.ARRAYLIT, nodeList.toArray(new Node[0]));\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    private Node processExprStmt(AstNode node) {\n+        Node first = transform(node.getFirstChild());\n+        if (isDirective(node)) {\n+            Node statement = new Node(Token.EXPR_RESULT);\n+            statement.setIsSyntheticBlock(true);\n+            statement.addChildToBack(first);\n+            statement.putProp(Node.DIRECTIVE_PROP, Boolean.TRUE);\n+            return statement;\n+        }\n+        return first;\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    private Node processVar(AstNode node) {\n+        Preconditions.checkState(node.getType() == Token.VAR);\n+        Node result = new Node(Token.BLOCK);\n+        for (int i = 0; i < node.getChildCount(); i++) {\n+            Node child = newNode(\n+                    Token.VAR,\n+                    transform(node.getChildAtIndex(i).getFirstChild()));\n+            result.addChildToBack(child);\n+        }\n+        return result;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    private Node processBreakOrContinue(AstNode node) {\n+        Node result = new Node(node.getType());\n+        AstNode labelNode = node.getFirstChild();\n+        if (labelNode != null) {\n+            Preconditions.checkState(labelNode.getType() == Token.LABEL);\n+            result.addChildToBack(transform(labelNode.getFirstChild()));\n+        }\n+        return result;\n+    }\n+\n+    private boolean isDirective(AstNode node) {\n+        return node.getType() == Token.EXPR_RESULT &&\n+                node.getFirstChild().getType() == Token.STRING &&\n+                ALLOWED_DIRECTIVES.contains(node.getFirstChild().getString());\n+    }\n+\n+    private Node newSyntheticBlock(AstNode node, Node... children) {\n+        Node block = new Node(Token.BLOCK);\n+        block.setIsSyntheticBlock(true);\n+        addChildToBlock(block, children);\n+        return block;\n+    }\n+\n+    private void addChildToBlock(Node parent, Node... children) {\n+        for (Node n : children) {\n+            if (n != null) {\n+                if (parent == null) {\n+                    parent = new Node(Token.BLOCK);\n+                    parent.setIsSyntheticBlock(true);\n+                }\n+                parent.addChildToBack(n);\n+            }\n+        }\n     }\n \n+    private Node processTry(TryStatement tryStatement) {\n+        Node tryBlock = transformBlock(tryStatement.getTryBlock());\n+        Node finallyBlock = tryStatement.getFinallyBlock() != null\n+                ? transformBlock(tryStatement.getFinallyBlock()) : null;\n+        List<CatchClause> catchClauses = tryStatement.getCatchClauses();\n+        if (catchClauses.isEmpty()) {\n+            // We cannot arbitrarily add bogus catch blocks; it can mask problems in legitimate cases.\n+            if (finallyBlock == null) {\n+                errorReporter.error(\n+                        \"Useless try-catch or try-finally block. Did you mean to throw the exception \" +\n+                                \"out completely, or do something with it?\",\n+                        sourceName,\n+                        tryStatement.getLineno(), \"\", 0);\n+            }\n+            return newSyntheticBlock(tryStatement, tryBlock, finallyBlock);\n+        }\n+\n+        // Try to match \"catch (foo) {...} catch (bar) {...} finally {...}\" constructs, where each\n+        // catch block creates an object that is consumed by the next catch block and the finally\n+        // block.\n+        List<Node> catchNodes = new ArrayList<>();\n+        Node catchBlock = transformBlock(catchClauses.get(0).getBody());\n+        catchNodes.add(newNode(Token.CATCH, transform(catchClauses.get(0).getVarName()), catchBlock));\n+        for (int i = 1; i < catchClauses.size(); i++) {\n+            CatchClause catchClause = catchClauses.get(i);\n+            if (catchClause.getCatchCondition() != null) {\n+                // ES6+ only. Cannot convert, so bail out.\n+                errorReporter.error(\n+                        \"Catch clause conditions are not supported\",\n+                        sourceName,\n+                        catchClause.getLineno(), \"\", 0);\n+                return newSyntheticBlock(tryStatement, tryBlock, finallyBlock);\n+            }\n+            Node body = transformBlock(catchClause.getBody());\n+            // Try to find the variable declared in the current catch block in the previous blocks.\n+            final String varName = catchClause.getVarName().getString();\n+            int j = catchNodes.size() - 1;\n+            for (; j >= 0; j--) {\n+                Node catchNode = catchNodes.get(j);\n+                if (catchNode.getFirstChild().getNext().getString().equals(varName)) {\n+                    break;\n+                }\n+            }\n+            Node var = new Node(Token.NAME, varName);\n+            Node obj = j == -1\n+                    ? new Node(Token.EMPTY)\n+                    : catchNodes.get(j).getFirstChild().getFirstChild();\n+            Node objectLiteral = new Node(Token.OBJECTLIT);\n+            objectLiteral.addChildToBack(newNode(Token.STRING, varName));\n+            objectLiteral.addChildToBack(var);\n+            if (obj.getType() == Token.OBJECTLIT) {\n+                // Some edge cases, like double var declaration in same node, require that we check the\n+                // type of the var node and ensure it matches the presumed LHS.\n+                Node lhs = obj.getFirstChild();\n+                Node rhs = lhs.getNext();\n+                if (lhs.getType() == Token.STRING && lhs.getString().equals(varName)) {\n+                    var.setType(rhs.getType());\n+                    var.copyInformationFrom(rhs);\n+                }\n+            }\n+            obj.addChildToBack(objectLiteral);\n+            catchNodes.add(newNode(Token.CATCH, newNode(Token.NAME, varName), body));\n+        }\n+\n+        Node tryCatchBlock = newSyntheticBlock(tryStatement, tryBlock);\n+        Node parent = null;\n+        for (Node catchNode : catchNodes) {\n+            if (parent == null) {\n+                parent = newNode(Token.TRY, tryCatchBlock, catchNode);\n+            } else {\n+                parent.getLastChild().addChildToBack(catchNode);\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}