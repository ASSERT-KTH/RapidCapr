{
    "patch": "    RemoveUnusedCode remover = new RemoveUnusedCode(compiler);\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    Set<String> removedArgs;\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      removedArgs = remover.removeUnusedFunctionArgs(fnScope);\n      // Strip unreferenced args off the end of the function declaration.\n      int numArgsToRemove = removedArgs.size();\n      for (int i = 0; i < numArgsToRemove; i++) {\n        argList.removeChild(argList.getLastChild());\n      }\n    } else {\n      removedArgs = callSiteOptimizer.optimize(fnScope, referenced);\n    }\n    if (compiler.getOptions().getPropertyOption(JSErrorManager.Option.EXTRA_REQUIRE)\n        == JSErrorManager.Policy.WARNING) {\n      Set<String> referencedNames = new HashSet<>();\n      for (Var v : referenced) {\n        referencedNames.add(v.getName());\n      }\n      // A map to keep track of the number of occurrence of each used function argument name.\n      Map<String, Integer> referencedArgNames = new HashMap<>();\n      for (Node child : argList.children()) {\n        String argName = child.getString();\n        if (referencedNames.contains(argName)) {\n          if (referencedArgNames.containsKey(argName)) {\n            int count = referencedArgNames.get(argName) + 1;\n            referencedArgNames.put(argName, count);\n          } else {\n            referencedArgNames.put(argName, 1);\n          }\n        }\n      }\n      for (String removedArgname : removedArgs) {\n        if (referencedArgNames.containsKey(removedArgname)) {\n          // in this case it means that the function gets called with more arguments than needed.\n          compiler.report(\n              JSError.make(\n                  EXTRA_REQUIRE_MESSAGE,\n                  SourceLocation.UNKNOWN,\n                  removedArgname,\n                  referencedArgNames.get(removedArgname)));\n        }\n      }\n    }\n    compiler.reportCodeChange();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..a57be7de 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,61 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    RemoveUnusedCode remover = new RemoveUnusedCode(compiler);\n+    Node function = fnScope.getRootNode();\n+\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    Set<String> removedArgs;\n+    boolean modifyCallers = modifyCallSites\n+        && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+      removedArgs = remover.removeUnusedFunctionArgs(fnScope);\n+      // Strip unreferenced args off the end of the function declaration.\n+      int numArgsToRemove = removedArgs.size();\n+      for (int i = 0; i < numArgsToRemove; i++) {\n+        argList.removeChild(argList.getLastChild());\n+      }\n+    } else {\n+      removedArgs = callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n+    if (compiler.getOptions().getPropertyOption(JSErrorManager.Option.EXTRA_REQUIRE)\n+        == JSErrorManager.Policy.WARNING) {\n+      Set<String> referencedNames = new HashSet<>();\n+      for (Var v : referenced) {\n+        referencedNames.add(v.getName());\n+      }\n+      // A map to keep track of the number of occurrence of each used function argument name.\n+      Map<String, Integer> referencedArgNames = new HashMap<>();\n+      for (Node child : argList.children()) {\n+        String argName = child.getString();\n+        if (referencedNames.contains(argName)) {\n+          if (referencedArgNames.containsKey(argName)) {\n+            int count = referencedArgNames.get(argName) + 1;\n+            referencedArgNames.put(argName, count);\n+          } else {\n+            referencedArgNames.put(argName, 1);\n+          }\n+        }\n+      }\n+      for (String removedArgname : removedArgs) {\n+        if (referencedArgNames.containsKey(removedArgname)) {\n+          // in this case it means that the function gets called with more arguments than needed.\n+          compiler.report(\n+              JSError.make(\n+                  EXTRA_REQUIRE_MESSAGE,\n+                  SourceLocation.UNKNOWN,\n+                  removedArgname,\n+                  referencedArgNames.get(removedArgname)));\n+        }\n+      }\n+    }\n+    compiler.reportCodeChange();\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}