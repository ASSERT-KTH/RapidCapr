{
    "patch": "  private void maybeAddTypeToVar(NodeTraversal t, Node node, Node parent) {\n    // Only consider NAME nodes that are marked as declarations and are children of VAR.\n    if (node.isName() && parent.isVar() && NodeUtil.isNameDeclaration(parent, node) && !NodeUtil.isEnhancedFor(parent.getParent())) {\n      // Ignore names that already have a type or are being aliased.\n      if ((node.getJSType() != null && !NodeUtil.isNamespaceDecl(node)) || NodeUtil.isLhsOfAssign(node)) {\n        return;\n      }\n\n      // We use a heuristic to determine if the variable is a constant.\n      boolean isConst = NodeUtil.isConstantDeclaration(parent);\n      JSDocInfo jsdoc = node.getJSDocInfo();\n      if (jsdoc != null && jsdoc.getSuppressions() != null && jsdoc.getSuppressions().contains(\"const\")) {\n        isConst = true;\n      }\n\n      // Infer the type of the variable.\n      JSType inferredType = inferType(t, node, parent.getLastChild().getJSType(), isConst);\n\n      // If we inferred a type for the variable, annotate it with that type.\n      if (inferredType != null) {\n        node.setJSType(inferredType);\n      }\n    }\n  }\n\n  private JSType inferType(NodeTraversal t, Node nameNode, JSType initType, boolean isConst) {\n    JSType type = null;\n    if (initType != null && !initType.isUnknownType() && !initType.isNoType()) {\n      type = initType;\n      if (initType.isTemplatizedType() || initType.isUnionType() || initType.isTypeVariable() || initType.isEnumType()) {\n        // Do not use the type derived from the initializer if it is too complex.\n        type = null;\n      }\n    }\n\n    if (type == null) {\n      String name = nameNode.getString();\n      JSDocInfo jsdoc = nameNode.getJSDocInfo();\n      if (jsdoc != null) {\n        // If there is an explicit type annotation, use it.\n        JSType explicitType = jsdoc.getType();\n        if (explicitType != null && !(explicitType instanceof AllType)) {\n          type = explicitType;\n        } else if (jsdoc.hasEnumParameterType()) {\n          // If there is an @enum parameter type annotation, treat the variable as a const enum.\n          if (isConst) {\n            return createEnumType(nameNode, jsdoc.getEnumParameterType().getElements());\n          } else {\n            t.report(nameNode, IS_CONST_WITHOUT_EXPLICIT_TYPE);\n          }\n        } else if (jsdoc.isConstructor() || jsdoc.isInterface()) {\n          // If there is a @constructor or @interface annotation without an explicit type, infer an object type.\n          // Note: For @interface, an interface type is more appropriate here, but this seems to cause some false positives.\n          type = t.getCompiler().getTypeRegistry().createObjectType(null);\n        }\n      }\n\n      if (type == null) {\n        // If we still haven't inferred a type, use the type of the first assignment to the variable, if available.\n        Node varNode = nameNode.getParent();\n        for (Node ancestor : varNode.getAncestors()) {\n          if (ancestor.isFunction()) {\n            break;\n          }\n          if (ancestor.isAssign() && ancestor.getFirstChild() == varNode) {\n            type = ancestor.getLastChild().getJSType();\n            break;\n          }\n          if (ancestor.isVaRest()) {\n            // We don't infer types for variables declared in rest parameter destructuring patterns.\n            return null;\n          }\n        }\n      }\n\n      if (type == null) {\n        // If we still haven't inferred a type, use the unknown type.\n        type = t.getCompiler().getTypeRegistry().getNativeType(UNKNOWN_TYPE);\n      }\n    }\n\n    return type.isRequired() ? type : type.getLeastSupertype(UNKNOWN_TYPE);\n  }\n\n  private JSType createEnumType(Node nameNode, ImmutableList<Node> elements) {\n    List<JSType> members = new ArrayList<>(elements.size());\n    for (Node element : elements) {\n      members.add(element.getJSType());\n    }\n    return JSType.fromEnumType(EnumType.builder(getCommonTypes()).addKeys(nameNode.getString(), members).build());\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..e0c7aff2 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,110 +521,98 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n-\n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n-\n+  private void maybeAddTypeToVar(NodeTraversal t, Node node, Node parent) {\n+    // Only consider NAME nodes that are marked as declarations and are children of VAR.\n+    if (node.isName() && parent.isVar() && NodeUtil.isNameDeclaration(parent, node) && !NodeUtil.isEnhancedFor(parent.getParent())) {\n+      // Ignore names that already have a type or are being aliased.\n+      if ((node.getJSType() != null && !NodeUtil.isNamespaceDecl(node)) || NodeUtil.isLhsOfAssign(node)) {\n+        return;\n+      }\n \n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n+      // We use a heuristic to determine if the variable is a constant.\n+      boolean isConst = NodeUtil.isConstantDeclaration(parent);\n+      JSDocInfo jsdoc = node.getJSDocInfo();\n+      if (jsdoc != null && jsdoc.getSuppressions() != null && jsdoc.getSuppressions().contains(\"const\")) {\n+        isConst = true;\n+      }\n \n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n-        }\n-        break;\n-      case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n-        }\n+      // Infer the type of the variable.\n+      JSType inferredType = inferType(t, node, parent.getLastChild().getJSType(), isConst);\n \n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n-        break;\n+      // If we inferred a type for the variable, annotate it with that type.\n+      if (inferredType != null) {\n+        node.setJSType(inferredType);\n+      }\n     }\n   }\n \n-  /**\n-   * Defines a property if the property has not been defined yet.\n-   */\n-  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n-    String propName = getprop.getLastChild().getString();\n-    Node obj = getprop.getFirstChild();\n-    JSType nodeType = getJSType(obj);\n-    ObjectType objectType = ObjectType.cast(\n-        nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n-        getJSType(syntacticScope.getRootNode()).isConstructor();\n-\n-    if (objectType == null) {\n-      registry.registerPropertyOnType(propName, nodeType);\n-    } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n-        boolean staticPropCreation = false;\n-        Node maybeAssignStm = getprop.getParent().getParent();\n-        if (syntacticScope.isGlobal() &&\n-            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n-          String propCreationFilename = maybeAssignStm.getSourceFileName();\n-          Node ctor = objectType.getOwnerFunction().getSource();\n-          if (ctor != null &&\n-              ctor.getSourceFileName().equals(propCreationFilename)) {\n-            staticPropCreation = true;\n+  private JSType inferType(NodeTraversal t, Node nameNode, JSType initType, boolean isConst) {\n+    JSType type = null;\n+    if (initType != null && !initType.isUnknownType() && !initType.isNoType()) {\n+      type = initType;\n+      if (initType.isTemplatizedType() || initType.isUnionType() || initType.isTypeVariable() || initType.isEnumType()) {\n+        // Do not use the type derived from the initializer if it is too complex.\n+        type = null;\n+      }\n+    }\n+\n+    if (type == null) {\n+      String name = nameNode.getString();\n+      JSDocInfo jsdoc = nameNode.getJSDocInfo();\n+      if (jsdoc != null) {\n+        // If there is an explicit type annotation, use it.\n+        JSType explicitType = jsdoc.getType();\n+        if (explicitType != null && !(explicitType instanceof AllType)) {\n+          type = explicitType;\n+        } else if (jsdoc.hasEnumParameterType()) {\n+          // If there is an @enum parameter type annotation, treat the variable as a const enum.\n+          if (isConst) {\n+            return createEnumType(nameNode, jsdoc.getEnumParameterType().getElements());\n+          } else {\n+            t.report(nameNode, IS_CONST_WITHOUT_EXPLICIT_TYPE);\n           }\n+        } else if (jsdoc.isConstructor() || jsdoc.isInterface()) {\n+          // If there is a @constructor or @interface annotation without an explicit type, infer an object type.\n+          // Note: For @interface, an interface type is more appropriate here, but this seems to cause some false positives.\n+          type = t.getCompiler().getTypeRegistry().createObjectType(null);\n         }\n-        if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n+      }\n+\n+      if (type == null) {\n+        // If we still haven't inferred a type, use the type of the first assignment to the variable, if available.\n+        Node varNode = nameNode.getParent();\n+        for (Node ancestor : varNode.getAncestors()) {\n+          if (ancestor.isFunction()) {\n+            break;\n+          }\n+          if (ancestor.isAssign() && ancestor.getFirstChild() == varNode) {\n+            type = ancestor.getLastChild().getJSType();\n+            break;\n+          }\n+          if (ancestor.isVaRest()) {\n+            // We don't infer types for variables declared in rest parameter destructuring patterns.\n+            return null;\n+          }\n         }\n       }\n \n+      if (type == null) {\n+        // If we still haven't inferred a type, use the unknown type.\n+        type = t.getCompiler().getTypeRegistry().getNativeType(UNKNOWN_TYPE);\n+      }\n+    }\n+\n+    return type.isRequired() ? type : type.getLeastSupertype(UNKNOWN_TYPE);\n+  }\n+\n+  private JSType createEnumType(Node nameNode, ImmutableList<Node> elements) {\n+    List<JSType> members = new ArrayList<>(elements.size());\n+    for (Node element : elements) {\n+      members.add(element.getJSType());\n+    }\n+    return JSType.fromEnumType(EnumType.builder(getCommonTypes()).addKeys(nameNode.getString(), members).build());\n+  }\n+\n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;\n       }",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}