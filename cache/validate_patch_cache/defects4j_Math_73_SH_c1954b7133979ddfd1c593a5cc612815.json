{
    "patch": "        double x0 = min;\n        double x1 = initial;\n        double x2 = max;\n        double y0 = yMin;\n        double y1 = yInitial;\n        double y2 = yMax;\n\n        double oldDelta = 0.0;\n        double delta = 0.0;\n        double x3 = Double.NaN;\n\n        while (true) {\n            if (y1 * y2 > 0) {\n                // Rename x1, x2, y1, and y2 so that x1 < x2\n                if (x1 < x2) {\n                    final double tempX = x1;\n                    x1 = x2;\n                    x2 = tempX;\n                    final double tempY = y1;\n                    y1 = y2;\n                    y2 = tempY;\n                }\n                // Attempt inverse quadratic interpolation\n                if (y0 * y2 < 0) {\n                    final double delta2 = y0 / (y0 - y2);\n                    x3 = x0 + delta2 * (x2 - x0);\n                    if (verifyEvalPoint(x3, x1)) {\n                        delta = Math.abs(x3 - x1);\n                        if (delta <= absoluteAccuracy ||\n                            delta <= relativeAccuracy * Math.max(Math.abs(x1), Math.abs(x3))) {\n                            setResult(x3, iterations);\n                            return result;\n                        }\n                        // Is the new approximated root close enough to an existing one ?\n                        final double x0c = x0 + oldDelta;\n                        final double x3c = x3 + oldDelta;\n                        if ((x3c - x1) * (x1 - x0c) > 0) {\n                            // Interpolation ok, use it.\n                            x0 = x1;\n                            y0 = y1;\n                            x1 = x3;\n                            y1 = f.value(x1);\n                            x2 = max;\n                            y2 = yMax;\n                        }\n                    }\n                }\n                // Interpolation failed or disabled\n                // Simply bisect the interval\n                oldDelta = delta;\n                delta = (x2 - x1) / 2.0;\n                if (delta <= absoluteAccuracy ||\n                    (relativeAccuracy != 0.0 && delta <= relativeAccuracy * Math.max(Math.abs(x1), Math.abs(x2)))) {\n                    setResult(x1, iterations);\n                    return result;\n                }\n                // Choose which half interval to continue with\n                if (y1 * y0 < 0) {\n                    x2 = x1;\n                    y2 = y1;\n                } else {\n                    x1 = x2;\n                    y1 = y2;\n                }\n            } else if (y0 * y1 < 0.0) {\n                x2 = x1;\n                y2 = y1;\n            } else {\n                x0 = x1;\n                y0 = y1;\n            }\n            // we loop back here\n            x1 = Double.NaN;\n            y1 = Double.NaN;\n        }\n",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..8df8c7dc3 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,82 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double x0 = min;\n+        double x1 = initial;\n+        double x2 = max;\n+        double y0 = yMin;\n+        double y1 = yInitial;\n+        double y2 = yMax;\n+\n+        double oldDelta = 0.0;\n+        double delta = 0.0;\n+        double x3 = Double.NaN;\n+\n+        while (true) {\n+            if (y1 * y2 > 0) {\n+                // Rename x1, x2, y1, and y2 so that x1 < x2\n+                if (x1 < x2) {\n+                    final double tempX = x1;\n+                    x1 = x2;\n+                    x2 = tempX;\n+                    final double tempY = y1;\n+                    y1 = y2;\n+                    y2 = tempY;\n+                }\n+                // Attempt inverse quadratic interpolation\n+                if (y0 * y2 < 0) {\n+                    final double delta2 = y0 / (y0 - y2);\n+                    x3 = x0 + delta2 * (x2 - x0);\n+                    if (verifyEvalPoint(x3, x1)) {\n+                        delta = Math.abs(x3 - x1);\n+                        if (delta <= absoluteAccuracy ||\n+                            delta <= relativeAccuracy * Math.max(Math.abs(x1), Math.abs(x3))) {\n+                            setResult(x3, iterations);\n+                            return result;\n+                        }\n+                        // Is the new approximated root close enough to an existing one ?\n+                        final double x0c = x0 + oldDelta;\n+                        final double x3c = x3 + oldDelta;\n+                        if ((x3c - x1) * (x1 - x0c) > 0) {\n+                            // Interpolation ok, use it.\n+                            x0 = x1;\n+                            y0 = y1;\n+                            x1 = x3;\n+                            y1 = f.value(x1);\n+                            x2 = max;\n+                            y2 = yMax;\n+                        }\n+                    }\n+                }\n+                // Interpolation failed or disabled\n+                // Simply bisect the interval\n+                oldDelta = delta;\n+                delta = (x2 - x1) / 2.0;\n+                if (delta <= absoluteAccuracy ||\n+                    (relativeAccuracy != 0.0 && delta <= relativeAccuracy * Math.max(Math.abs(x1), Math.abs(x2)))) {\n+                    setResult(x1, iterations);\n+                    return result;\n+                }\n+                // Choose which half interval to continue with\n+                if (y1 * y0 < 0) {\n+                    x2 = x1;\n+                    y2 = y1;\n+                } else {\n+                    x1 = x2;\n+                    y1 = y2;\n+                }\n+            } else if (y0 * y1 < 0.0) {\n+                x2 = x1;\n+                y2 = y1;\n+            } else {\n+                x0 = x1;\n+                y0 = y1;\n+            }\n+            // we loop back here\n+            x1 = Double.NaN;\n+            y1 = Double.NaN;\n+        }\n+\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}