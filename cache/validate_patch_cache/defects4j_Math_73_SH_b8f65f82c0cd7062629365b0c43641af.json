{
    "patch": "        double yMin = f.value(min);\n        double yMax = f.value(max);\n        verifyBracketing(min,max,f);\n        double x=initial;\n        double y=f.value(x);\n        double oldDelta=0;\n        double delta=0;\n        while (true) {\n            if ((y >= 0 ? y : -y) <= functionValueAccuracy) {\n                setResult(x, oldDelta);\n                return result;\n            }\n            if ((y-yMin)*(yMax-y) > 0.0) {\n                yMin=y;\n                min=x;\n                delta=max-x;\n                x=initial;\n                y=f.value(x);\n            } else if ((y-yMax)*(yMax-yMin) > 0.0) {\n                yMax=y;\n                max=x;\n                delta=x-min;\n                x=initial;\n                y=f.value(x);\n            } else {\n                oldDelta=delta;\n                delta=0.5*(max-min);\n                double temp=delta;\n                if (Math.abs(temp) <= functionValueAccuracy) {\n                    temp=tolerance;\n                }\n                if ((Math.abs(oldDelta) < functionValueAccuracy) ||\n                        (Math.abs(y) <= Math.abs(yOld))) {\n                    temp *= (y >= 0 ? 0.5 : -0.5);\n                    x=initial+temp;\n                } else {\n                    double ratio = y/yOld;\n                    double pt1 = temp/(1.0-ratio);\n                    double pt2 = oldDelta/(ratio*(1.0-ratio));\n                    x=initial+pt1-pt2;\n                }\n                y=f.value(x);\n                if (y > 0.0) {\n                    max=x;\n                } else {\n                    min=x;\n                }\n                if (((max-min) <= Math.max(relativeAccuracy*max, absoluteAccuracy)) ||\n                        (Math.abs(y) <= functionValueAccuracy)) {\n                    setResult(x, oldDelta);\n                    return result;\n                }\n            }\n            yOld=y;\n        }\n\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..b0682ea16 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,63 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n+        verifyBracketing(min,max,f);\n+        double x=initial;\n+        double y=f.value(x);\n+        double oldDelta=0;\n+        double delta=0;\n+        while (true) {\n+            if ((y >= 0 ? y : -y) <= functionValueAccuracy) {\n+                setResult(x, oldDelta);\n+                return result;\n+            }\n+            if ((y-yMin)*(yMax-y) > 0.0) {\n+                yMin=y;\n+                min=x;\n+                delta=max-x;\n+                x=initial;\n+                y=f.value(x);\n+            } else if ((y-yMax)*(yMax-yMin) > 0.0) {\n+                yMax=y;\n+                max=x;\n+                delta=x-min;\n+                x=initial;\n+                y=f.value(x);\n+            } else {\n+                oldDelta=delta;\n+                delta=0.5*(max-min);\n+                double temp=delta;\n+                if (Math.abs(temp) <= functionValueAccuracy) {\n+                    temp=tolerance;\n+                }\n+                if ((Math.abs(oldDelta) < functionValueAccuracy) ||\n+                        (Math.abs(y) <= Math.abs(yOld))) {\n+                    temp *= (y >= 0 ? 0.5 : -0.5);\n+                    x=initial+temp;\n+                } else {\n+                    double ratio = y/yOld;\n+                    double pt1 = temp/(1.0-ratio);\n+                    double pt2 = oldDelta/(ratio*(1.0-ratio));\n+                    x=initial+pt1-pt2;\n+                }\n+                y=f.value(x);\n+                if (y > 0.0) {\n+                    max=x;\n+                } else {\n+                    min=x;\n+                }\n+                if (((max-min) <= Math.max(relativeAccuracy*max, absoluteAccuracy)) ||\n+                        (Math.abs(y) <= functionValueAccuracy)) {\n+                    setResult(x, oldDelta);\n+                    return result;\n+                }\n+            }\n+            yOld=y;\n+        }\n+\n+    }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}