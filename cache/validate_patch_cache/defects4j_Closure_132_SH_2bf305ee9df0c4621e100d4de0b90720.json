{
    "patch": "        if (NodeUtil.mayBeObjectLitKey(lhs)) {\n          // Don't fold if the result would cause a syntax error.\n          if (!NodeUtil.isExpressionNode(parent)) {\n            return n;\n          }\n\n          // if(x) ({y:1});else ({y:2}); -> ({y:x?1:2});\n          // if(x) ({y:(a=1)});else ({y:(a=2)}); -> ({y:(a=x?1:2)});\n          Node objlit1 = lhs.getFirstChild();\n          Node objlit2 = elseExpr.getFirstChild();\n          if (objlit1 == null || !objlit1.isObjectLit() ||\n              objlit2 == null || !objlit2.isObjectLit()) {\n            return n;\n          }\n\n          // Make sure the keys are the same and in the same order\n          boolean keysEqual = NodeUtil.sameKeysAndValues(objlit1, objlit2);\n          if (!keysEqual) {\n            return n;\n          }\n\n          // Fold!\n          Node newObjectLit = IR.objectlit().srcref(objlit1);\n          for (Node key : objlit1.children()) {\n            Node val1 = objlit1.getFirstChild();\n            Node val2 = objlit2.getFirstChild();\n            Node newExpr = IR.hook(cond, val1.detachFromParent(),\n                val2.detachFromParent())\n                              .srcref(objlit1);\n            newObjectLit.addChildToBack(new Node(Token.STRING_KEY,\n                    key.detachFromParent(), newExpr).srcref(key));\n          }\n          Node newExpr = NodeUtil.newExpr(newObjectLit);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..75cfe51f 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,43 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+        if (NodeUtil.mayBeObjectLitKey(lhs)) {\n+          // Don't fold if the result would cause a syntax error.\n+          if (!NodeUtil.isExpressionNode(parent)) {\n+            return n;\n+          }\n+\n+          // if(x) ({y:1});else ({y:2}); -> ({y:x?1:2});\n+          // if(x) ({y:(a=1)});else ({y:(a=2)}); -> ({y:(a=x?1:2)});\n+          Node objlit1 = lhs.getFirstChild();\n+          Node objlit2 = elseExpr.getFirstChild();\n+          if (objlit1 == null || !objlit1.isObjectLit() ||\n+              objlit2 == null || !objlit2.isObjectLit()) {\n+            return n;\n+          }\n+\n+          // Make sure the keys are the same and in the same order\n+          boolean keysEqual = NodeUtil.sameKeysAndValues(objlit1, objlit2);\n+          if (!keysEqual) {\n+            return n;\n+          }\n+\n+          // Fold!\n+          Node newObjectLit = IR.objectlit().srcref(objlit1);\n+          for (Node key : objlit1.children()) {\n+            Node val1 = objlit1.getFirstChild();\n+            Node val2 = objlit2.getFirstChild();\n+            Node newExpr = IR.hook(cond, val1.detachFromParent(),\n+                val2.detachFromParent())\n+                              .srcref(objlit1);\n+            newObjectLit.addChildToBack(new Node(Token.STRING_KEY,\n+                    key.detachFromParent(), newExpr).srcref(key));\n+          }\n+          Node newExpr = NodeUtil.newExpr(newObjectLit);\n+          parent.replaceChild(n, newExpr);\n+          reportCodeChange();\n+\n+          return newExpr;\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}