{
    "patch": "public Dfp regularizedGammaP(final Dfp a, final Dfp x) {\n    final Dfp eps = newInstance(1);\n    eps.divide(newInstanceArray(1, 32));\n    final Dfp fpmin = newInstance(MachineArithmetic.getMinNormalizedPositiveValue());\n    Dfp gln = gammaln(a);\n    if (x.lessThan(0.0)) {\n        return newInstance(NaN);\n    }\n    if (x.lessThan(a.add(1.0))) {\n        Dfp ap = a;\n        Dfp del = newInstance(1.0);\n        Dfp sum = newInstance(1.0).divide(ap);\n        int iter = 0;\n        while (++iter <= 100) {\n            ++ap;\n            del = del.multiply(x).divide(ap);\n            sum = sum.add(del);\n            if (del.lessThan(sum.multiply(eps))) {\n                break;\n            }\n        }\n        return exp(gln.subtract(x.log()).multiply(-1.0)).multiply(sum);\n    } else {\n        Dfp b = newInstance(x.add(1.0).subtract(a));\n        Dfp c = newInstance(1.0).divide(fpmin);\n        Dfp d = newInstance(1.0).divide(b);\n        Dfp h = d;\n        Dfp an = newInstance(1.0).divide(a);\n        Dfp del = h;\n        int iter = 0;\n        while (++iter <= 100) {\n            an = an.multiply(newInstance(iter).subtract(a));\n            b = b.add(newInstance(2.0));\n            d = b.subtract(an.multiply(d));\n            if (d.abs().lessThan(fpmin)) {\n                d = fpmin.multiply(2.0);\n            }\n            c = b.add(an.divide(c));\n            if (c.abs().lessThan(fpmin)) {\n                c = fpmin.multiply(2.0);\n            }\n            d = d.inverse();\n            del = d.multiply(c).multiply(del);\n            h = h.multiply(del);\n            if (del.subtract(newInstance(1.0)).abs().lessThan(eps)) {\n                break;\n            }\n        }\n        return newInstance(1.0).subtract(exp(gln.subtract(x.log()).multiply(-1.0)).multiply(h));\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..c50c39422 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,57 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public Dfp regularizedGammaP(final Dfp a, final Dfp x) {\n+    final Dfp eps = newInstance(1);\n+    eps.divide(newInstanceArray(1, 32));\n+    final Dfp fpmin = newInstance(MachineArithmetic.getMinNormalizedPositiveValue());\n+    Dfp gln = gammaln(a);\n+    if (x.lessThan(0.0)) {\n+        return newInstance(NaN);\n+    }\n+    if (x.lessThan(a.add(1.0))) {\n+        Dfp ap = a;\n+        Dfp del = newInstance(1.0);\n+        Dfp sum = newInstance(1.0).divide(ap);\n+        int iter = 0;\n+        while (++iter <= 100) {\n+            ++ap;\n+            del = del.multiply(x).divide(ap);\n+            sum = sum.add(del);\n+            if (del.lessThan(sum.multiply(eps))) {\n+                break;\n+            }\n+        }\n+        return exp(gln.subtract(x.log()).multiply(-1.0)).multiply(sum);\n+    } else {\n+        Dfp b = newInstance(x.add(1.0).subtract(a));\n+        Dfp c = newInstance(1.0).divide(fpmin);\n+        Dfp d = newInstance(1.0).divide(b);\n+        Dfp h = d;\n+        Dfp an = newInstance(1.0).divide(a);\n+        Dfp del = h;\n+        int iter = 0;\n+        while (++iter <= 100) {\n+            an = an.multiply(newInstance(iter).subtract(a));\n+            b = b.add(newInstance(2.0));\n+            d = b.subtract(an.multiply(d));\n+            if (d.abs().lessThan(fpmin)) {\n+                d = fpmin.multiply(2.0);\n+            }\n+            c = b.add(an.divide(c));\n+            if (c.abs().lessThan(fpmin)) {\n+                c = fpmin.multiply(2.0);\n+            }\n+            d = d.inverse();\n+            del = d.multiply(c).multiply(del);\n+            h = h.multiply(del);\n+            if (del.subtract(newInstance(1.0)).abs().lessThan(eps)) {\n+                break;\n+            }\n+        }\n+        return newInstance(1.0).subtract(exp(gln.subtract(x.log()).multiply(-1.0)).multiply(h));\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}