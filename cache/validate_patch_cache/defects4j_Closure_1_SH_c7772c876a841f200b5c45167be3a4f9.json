{
    "patch": "    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n        // The parameters object literal setters can not be removed.\n        return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    List<Node> argsToRemove = new ArrayList<Node>();\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n        // Gather unreferenced function arguments.\n        for (Node arg : argList.children()) {\n            if (!referenced.contains(fnScope.getVar(arg.getString()))) {\n                argsToRemove.add(arg);\n            } else if (!argsToRemove.isEmpty()) {\n                // If some arguments need to be removed, and this isn't one of them,\n                // then we can't remove any more. If we went any further, we might\n                // end up changing the order of arguments, which could break the\n                // code.\n                break;\n            }\n        }\n\n        if (!argsToRemove.isEmpty()) {\n            // It is important to remove arguments in reverse order since each removal\n            // affects the argList. For example, removing arg1 from (arg1, arg2, arg3)\n            // would change the list to (arg2, arg3). The next removal would remove\n            // arg3 instead of arg2 as intended.\n            for (int i = argsToRemove.size() - 1; i >= 0; i--) {\n                Node arg = argsToRemove.get(i);\n                argList.removeChild(arg);\n                compiler.reportCodeChange();\n            }\n\n            // Remove any trailing commas that may be left.\n            Node lastArg;\n            while ((lastArg = argList.getLastChild()) != null && lastArg.isEmpty()) {\n                argList.removeChild(lastArg);\n                compiler.reportCodeChange();\n            }\n        }\n    } else {\n        callSiteOptimizer.optimize(fnScope, referenced);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..eda24c0e 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,52 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+        // The parameters object literal setters can not be removed.\n+        return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    List<Node> argsToRemove = new ArrayList<Node>();\n+    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+        // Gather unreferenced function arguments.\n+        for (Node arg : argList.children()) {\n+            if (!referenced.contains(fnScope.getVar(arg.getString()))) {\n+                argsToRemove.add(arg);\n+            } else if (!argsToRemove.isEmpty()) {\n+                // If some arguments need to be removed, and this isn't one of them,\n+                // then we can't remove any more. If we went any further, we might\n+                // end up changing the order of arguments, which could break the\n+                // code.\n+                break;\n+            }\n+        }\n+\n+        if (!argsToRemove.isEmpty()) {\n+            // It is important to remove arguments in reverse order since each removal\n+            // affects the argList. For example, removing arg1 from (arg1, arg2, arg3)\n+            // would change the list to (arg2, arg3). The next removal would remove\n+            // arg3 instead of arg2 as intended.\n+            for (int i = argsToRemove.size() - 1; i >= 0; i--) {\n+                Node arg = argsToRemove.get(i);\n+                argList.removeChild(arg);\n+                compiler.reportCodeChange();\n+            }\n+\n+            // Remove any trailing commas that may be left.\n+            Node lastArg;\n+            while ((lastArg = argList.getLastChild()) != null && lastArg.isEmpty()) {\n+                argList.removeChild(lastArg);\n+                compiler.reportCodeChange();\n+            }\n+        }\n+    } else {\n+        callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: variable function is already defined in method removeUnreferencedFunctionArgs(Scope)",
    "test_result": "ERROR"
}