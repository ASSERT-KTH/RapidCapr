{
    "patch": "import java.lang.reflect.Field;\nimport java.util.stream.Stream;\nimport org.mockito.Mockito;\n\npublic class ResetMock {\n    public static <T> void resetMock(T mock) {\n        Object[] rawHandlers = Stream.of(mock)\n                .map(Mockito::getMockHandler)\n                .map(handler -> getField(handler, \"rawHandlers\"))\n                .toArray();\n\n        MockHandler<T> handler = (MockHandler<T>) Mockito.withSettings()\n                .spiedInstance(mock)\n                .getMockHandler();\n\n        Object[] rawHandlersCopy = getField(handler, \"rawHandlers\");\n        setField(handler, \"rawHandlers\", rawHandlers);\n\n        try {\n            Field callbackField = mock.getClass().getDeclaredField(\"$VRRC\");\n            callbackField.setAccessible(true);\n            ((MockitoInvocationHandler) callbackField.get(mock))\n                    .setMockitoInterceptor(handler);\n            setField(handler, \"rawHandlers\", rawHandlersCopy);\n        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private static <T> Object getField(T obj, String fieldName) {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            return field.get(obj);\n        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n\n    private static <T> void setField(T obj, String fieldName, Object value) {\n        try {\n            Field field = obj.getClass().getDeclaredField(fieldName);\n            field.setAccessible(true);\n            field.set(obj, value);\n        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException ex) {\n            throw new RuntimeException(ex);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..7862f0f2f 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,56 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import java.lang.reflect.Field;\n+import java.util.stream.Stream;\n+import org.mockito.Mockito;\n+\n+public class ResetMock {\n+    public static <T> void resetMock(T mock) {\n+        Object[] rawHandlers = Stream.of(mock)\n+                .map(Mockito::getMockHandler)\n+                .map(handler -> getField(handler, \"rawHandlers\"))\n+                .toArray();\n+\n+        MockHandler<T> handler = (MockHandler<T>) Mockito.withSettings()\n+                .spiedInstance(mock)\n+                .getMockHandler();\n+\n+        Object[] rawHandlersCopy = getField(handler, \"rawHandlers\");\n+        setField(handler, \"rawHandlers\", rawHandlers);\n+\n+        try {\n+            Field callbackField = mock.getClass().getDeclaredField(\"$VRRC\");\n+            callbackField.setAccessible(true);\n+            ((MockitoInvocationHandler) callbackField.get(mock))\n+                    .setMockitoInterceptor(handler);\n+            setField(handler, \"rawHandlers\", rawHandlersCopy);\n+        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static <T> Object getField(T obj, String fieldName) {\n+        try {\n+            Field field = obj.getClass().getDeclaredField(fieldName);\n+            field.setAccessible(true);\n+            return field.get(obj);\n+        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+\n+    private static <T> void setField(T obj, String fieldName, Object value) {\n+        try {\n+            Field field = obj.getClass().getDeclaredField(fieldName);\n+            field.setAccessible(true);\n+            field.set(obj, value);\n+        } catch (NoSuchFieldException | SecurityException | IllegalArgumentException | IllegalAccessException ex) {\n+            throw new RuntimeException(ex);\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}