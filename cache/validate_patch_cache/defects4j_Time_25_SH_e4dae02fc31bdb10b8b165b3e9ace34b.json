{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    if ((offsetLocal - offsetAdjusted) < 0) {\n        long nextLocal = nextTransition(instantAdjusted);\n        long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n        if (nextLocal != nextAdjusted) {\n            long prevLocal = previousTransition(nextLocal);\n            long prevAdjusted = previousTransition(nextAdjusted);\n            if (prevAdjusted < prevLocal) {\n                return offsetLocal;\n            }\n            int offsetPrev = getOffset(prevAdjusted);\n            if (offsetPrev == offsetAdjusted) {\n                return offsetAdjusted;\n            }\n            if (offsetPrev > offsetAdjusted) {\n                return offsetLocal;\n            }\n            return findPreviousTransitionOffset(prevAdjusted, offsetLocal, offsetAdjusted);\n        }\n    } else {\n        long nextLocal = nextTransition(instantLocal - offsetLocal);\n        long nextAdjusted = nextTransition(instantAdjusted);\n        if (nextLocal != nextAdjusted) {\n            long nextNextLocal = nextTransition(nextLocal);\n            long nextNextAdjusted = nextTransition(nextAdjusted);\n            if (nextNextAdjusted != nextNextLocal) {\n                return offsetLocal;\n            }\n            int offsetNextNext = getOffset(nextNextLocal);\n            if (offsetNextNext == offsetAdjusted) {\n                return offsetLocal;\n            }\n            if (offsetNextNext < offsetAdjusted) {\n                return offsetAdjusted;\n            }\n            return findNextTransitionOffset(nextLocal, offsetLocal, offsetAdjusted);\n        }\n    }\n}\n\nprivate int findPreviousTransitionOffset(long instant, int lowOffset, int highOffset) {\n    long prev = previousTransition(instant);\n    int offsetPrev = getOffset(prev);\n    if (offsetPrev < highOffset) {\n        return findPreviousTransitionOffset(prev, offsetPrev, highOffset);\n    }\n    if (offsetPrev > highOffset) {\n        return offsetPrev;\n    }\n    long prevPrev = previousTransition(prev);\n    if (prev - prevPrev <= 7 * DateTimeConstants.MILLIS_PER_DAY) {\n        return offsetPrev;\n    }\n    return lowOffset;\n}\n\nprivate int findNextTransitionOffset(long instant, int lowOffset, int highOffset) {\n    long next = nextTransition(instant);\n    int offsetNext = getOffset(next);\n    if (offsetNext > highOffset) {\n        return findNextTransitionOffset(next, lowOffset, offsetNext);\n    }\n    if (offsetNext < highOffset) {\n        return offsetNext;\n    }\n    long nextNext = nextTransition(next);\n    if (nextNext - next <= 7 * DateTimeConstants.MILLIS_PER_DAY) {\n        return offsetNext;\n    }\n    return lowOffset;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..82a3f007 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,77 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    if ((offsetLocal - offsetAdjusted) < 0) {\n+        long nextLocal = nextTransition(instantAdjusted);\n+        long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n+        if (nextLocal != nextAdjusted) {\n+            long prevLocal = previousTransition(nextLocal);\n+            long prevAdjusted = previousTransition(nextAdjusted);\n+            if (prevAdjusted < prevLocal) {\n+                return offsetLocal;\n+            }\n+            int offsetPrev = getOffset(prevAdjusted);\n+            if (offsetPrev == offsetAdjusted) {\n+                return offsetAdjusted;\n+            }\n+            if (offsetPrev > offsetAdjusted) {\n+                return offsetLocal;\n+            }\n+            return findPreviousTransitionOffset(prevAdjusted, offsetLocal, offsetAdjusted);\n+        }\n+    } else {\n+        long nextLocal = nextTransition(instantLocal - offsetLocal);\n+        long nextAdjusted = nextTransition(instantAdjusted);\n+        if (nextLocal != nextAdjusted) {\n+            long nextNextLocal = nextTransition(nextLocal);\n+            long nextNextAdjusted = nextTransition(nextAdjusted);\n+            if (nextNextAdjusted != nextNextLocal) {\n+                return offsetLocal;\n+            }\n+            int offsetNextNext = getOffset(nextNextLocal);\n+            if (offsetNextNext == offsetAdjusted) {\n+                return offsetLocal;\n+            }\n+            if (offsetNextNext < offsetAdjusted) {\n+                return offsetAdjusted;\n+            }\n+            return findNextTransitionOffset(nextLocal, offsetLocal, offsetAdjusted);\n+        }\n+    }\n+}\n+\n+private int findPreviousTransitionOffset(long instant, int lowOffset, int highOffset) {\n+    long prev = previousTransition(instant);\n+    int offsetPrev = getOffset(prev);\n+    if (offsetPrev < highOffset) {\n+        return findPreviousTransitionOffset(prev, offsetPrev, highOffset);\n+    }\n+    if (offsetPrev > highOffset) {\n+        return offsetPrev;\n+    }\n+    long prevPrev = previousTransition(prev);\n+    if (prev - prevPrev <= 7 * DateTimeConstants.MILLIS_PER_DAY) {\n+        return offsetPrev;\n+    }\n+    return lowOffset;\n+}\n+\n+private int findNextTransitionOffset(long instant, int lowOffset, int highOffset) {\n+    long next = nextTransition(instant);\n+    int offsetNext = getOffset(next);\n+    if (offsetNext > highOffset) {\n+        return findNextTransitionOffset(next, lowOffset, offsetNext);\n+    }\n+    if (offsetNext < highOffset) {\n+        return offsetNext;\n+    }\n+    long nextNext = nextTransition(next);\n+    if (nextNext - next <= 7 * DateTimeConstants.MILLIS_PER_DAY) {\n+        return offsetNext;\n+    }\n+    return lowOffset;\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}