{
    "patch": "if (left.getType() == Token.NUMBER &&\n    right.getType() == Token.NUMBER) {        \n    double lval = left.getDouble();\n    double rval = right.getDouble();\n    double result = 0;\n\n    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return n;\n    }\n\n    if (!(rval >= 0 && rval < 32)) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n    }\n\n    int lvalInt = (int) lval;\n    int rvalInt = (int) rval;\n\n    if (n.getType() == Token.LSH) {\n        result = (double) ((int) lval) << rvalInt;\n    } else if (n.getType() == Token.RSH) {\n        result = (double) ((int) lval) >> rvalInt;\n    } else if (n.getType() == Token.URSH) {\n        // Java does not have an unsigned right shift operator, so we need\n        // to convert to an unsigned int. Since JavaScript only has double\n        // floating point numbers, the conversion is done here as well.\n\n        // convert lval to unsigned int\n        long ulval = Double.valueOf(lval).longValue() & 0xffffffffL;\n        result = (double) (ulval >>> rvalInt);\n    } else {\n        throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\n    }\n\n    Node newNumber = Node.newNumber(result);\n    n.getParent().replaceChild(n, newNumber);\n    reportCodeChange();\n    \n    return newNumber;\n}\n\nreturn n;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex d6c194a3..c5f076d4 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -695,7 +695,49 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+if (left.getType() == Token.NUMBER &&\n+    right.getType() == Token.NUMBER) {        \n+    double lval = left.getDouble();\n+    double rval = right.getDouble();\n+    double result = 0;\n+\n+    if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n+        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+        return n;\n+    }\n+\n+    if (!(rval >= 0 && rval < 32)) {\n+        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n+        return n;\n+    }\n+\n+    int lvalInt = (int) lval;\n+    int rvalInt = (int) rval;\n+\n+    if (n.getType() == Token.LSH) {\n+        result = (double) ((int) lval) << rvalInt;\n+    } else if (n.getType() == Token.RSH) {\n+        result = (double) ((int) lval) >> rvalInt;\n+    } else if (n.getType() == Token.URSH) {\n+        // Java does not have an unsigned right shift operator, so we need\n+        // to convert to an unsigned int. Since JavaScript only has double\n+        // floating point numbers, the conversion is done here as well.\n+\n+        // convert lval to unsigned int\n+        long ulval = Double.valueOf(lval).longValue() & 0xffffffffL;\n+        result = (double) (ulval >>> rvalInt);\n+    } else {\n+        throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\n+    }\n+\n+    Node newNumber = Node.newNumber(result);\n+    n.getParent().replaceChild(n, newNumber);\n+    reportCodeChange();\n+    \n+    return newNumber;\n+}\n+\n+return n;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +",
    "result_reason": "error: variable lval is already defined in method tryFoldShift(Node,Node,Node)",
    "test_result": "ERROR"
}