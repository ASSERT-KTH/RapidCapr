{
    "patch": "if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n    if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n            Node lhs = thenOp.getFirstChild();\n            if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n                n.removeChild(cond);\n                Node assignName = thenOp.removeFirstChild();\n                Node thenExpr = thenOp.removeFirstChild();\n                Node elseExpr = elseOp.getLastChild();\n                elseOp.removeChild(elseExpr);\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n                Node expr = NodeUtil.newExpr(assign);\n                parent.replaceChild(n, expr);\n                reportCodeChange();\n                return expr;\n            }\n        }\n        // a && b, a || b (and not other binary operators) can be transformed into\n        // (a) && b, (a) || b. This needs to be done at parsing time because\n        // the AST does not preserve operator precedence:\n        // e.g. (x && y) || z is not the same as x && (y || z) but it can be parsed that way.\n        Node enclosingParent = parent.getParent();\n        if (precedence(enclosingParent) == OR_PRECEDENCE ||\n            precedence(enclosingParent) == AND_PRECEDENCE) {\n            Node left = n;\n            Node newParent = new Node(precedence(enclosingParent) == AND_PRECEDENCE ? Token.AND : Token.OR);\n            newParent.srcref(parent);\n            Node right = elseOp.removeFirstChild();\n            right.srcref(n);\n            newParent.addChildToBack(left);\n            newParent.addChildToBack(right);\n            enclosingParent.replaceChild(parent, newParent);\n            reportCodeChange();\n            return newParent;\n        }\n    }\n    // if(x)foo();else bar(); -> x?foo():bar()\n    n.removeChild(cond);\n    thenOp.detachFromParent();\n    elseOp.detachFromParent();\n    Node expr = IR.exprResult(\n        IR.hook(cond, thenOp, elseOp).srcref(n));\n    parent.replaceChild(n, expr);\n    reportCodeChange();\n    return expr;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..3b1adea5 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,56 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n+    Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n+    Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n+    if (thenOp.getType() == elseOp.getType()) {\n+        // if(x)a=1;else a=2; -> a=x?1:2;\n+        if (NodeUtil.isAssignmentOp(thenOp)) {\n+            Node lhs = thenOp.getFirstChild();\n+            if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n+                n.removeChild(cond);\n+                Node assignName = thenOp.removeFirstChild();\n+                Node thenExpr = thenOp.removeFirstChild();\n+                Node elseExpr = elseOp.getLastChild();\n+                elseOp.removeChild(elseExpr);\n+                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n+                Node expr = NodeUtil.newExpr(assign);\n+                parent.replaceChild(n, expr);\n+                reportCodeChange();\n+                return expr;\n+            }\n+        }\n+        // a && b, a || b (and not other binary operators) can be transformed into\n+        // (a) && b, (a) || b. This needs to be done at parsing time because\n+        // the AST does not preserve operator precedence:\n+        // e.g. (x && y) || z is not the same as x && (y || z) but it can be parsed that way.\n+        Node enclosingParent = parent.getParent();\n+        if (precedence(enclosingParent) == OR_PRECEDENCE ||\n+            precedence(enclosingParent) == AND_PRECEDENCE) {\n+            Node left = n;\n+            Node newParent = new Node(precedence(enclosingParent) == AND_PRECEDENCE ? Token.AND : Token.OR);\n+            newParent.srcref(parent);\n+            Node right = elseOp.removeFirstChild();\n+            right.srcref(n);\n+            newParent.addChildToBack(left);\n+            newParent.addChildToBack(right);\n+            enclosingParent.replaceChild(parent, newParent);\n+            reportCodeChange();\n+            return newParent;\n+        }\n+    }\n+    // if(x)foo();else bar(); -> x?foo():bar()\n+    n.removeChild(cond);\n+    thenOp.detachFromParent();\n+    elseOp.detachFromParent();\n+    Node expr = IR.exprResult(\n+        IR.hook(cond, thenOp, elseOp).srcref(n));\n+    parent.replaceChild(n, expr);\n+    reportCodeChange();\n+    return expr;\n+}\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}