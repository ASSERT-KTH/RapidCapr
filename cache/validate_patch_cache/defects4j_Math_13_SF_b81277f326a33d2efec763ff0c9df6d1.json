{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition dec = new ModifiedEigenDecomposition(m);\n    return dec.getSquareRoot();\n}\n\nprivate class ModifiedEigenDecomposition extends EigenDecomposition {\n    private static final int BLOCK_SIZE = 128;\n\n    public ModifiedEigenDecomposition(RealMatrix matrix) {\n        super(matrix, 1e-12);\n    }\n\n    @Override\n    protected void splitDiagonalBlock(int iBeg, int iEnd, int jBeg, int jEnd) {\n        int n = iEnd - iBeg + 1;\n        RealMatrix subMatrix = getT().getSubMatrix(iBeg, iEnd, jBeg, jEnd);\n\n        // Decompose the diagonal block\n        EigenDecomposition eig = new EigenDecomposition(subMatrix);\n\n        // Copy the eigenvalues and eigenvectors into the main matrix\n        for (int i = 0; i < n; i++) {\n            double lambda = eig.getRealEigenvalue(i);\n            getRealEigenvalues()[iBeg + i] = lambda;\n            getImagEigenvalues()[iBeg + i] = eig.getImagEigenvalue(i);\n            RealVector v = eig.getEigenvector(i);\n            getV().setColumn(iBeg + i, v);\n        }\n\n        // Update the off-diagonal blocks\n        for (int j = jBeg; j < jEnd; j += BLOCK_SIZE) {\n            int jBlockEnd = Math.min(j + BLOCK_SIZE, jEnd);\n\n            RealMatrix vBlock = getV().getSubMatrix(iBeg, iEnd, j, jBlockEnd - 1);\n            subMatrix = getT().getSubMatrix(j, jBlockEnd - 1, jBeg, jEnd);\n            RealMatrix uBlock = vBlock.transpose().multiply(subMatrix);\n\n            vBlock = eig.getSolver().getInverse().multiply(uBlock);\n\n            getT().setSubMatrix(vBlock.multiply(vBlock.transpose()).getData(), j, jBeg);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..34d1d06ab 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,47 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final EigenDecomposition dec = new ModifiedEigenDecomposition(m);\n+    return dec.getSquareRoot();\n+}\n+\n+private class ModifiedEigenDecomposition extends EigenDecomposition {\n+    private static final int BLOCK_SIZE = 128;\n+\n+    public ModifiedEigenDecomposition(RealMatrix matrix) {\n+        super(matrix, 1e-12);\n     }\n+\n+    @Override\n+    protected void splitDiagonalBlock(int iBeg, int iEnd, int jBeg, int jEnd) {\n+        int n = iEnd - iBeg + 1;\n+        RealMatrix subMatrix = getT().getSubMatrix(iBeg, iEnd, jBeg, jEnd);\n+\n+        // Decompose the diagonal block\n+        EigenDecomposition eig = new EigenDecomposition(subMatrix);\n+\n+        // Copy the eigenvalues and eigenvectors into the main matrix\n+        for (int i = 0; i < n; i++) {\n+            double lambda = eig.getRealEigenvalue(i);\n+            getRealEigenvalues()[iBeg + i] = lambda;\n+            getImagEigenvalues()[iBeg + i] = eig.getImagEigenvalue(i);\n+            RealVector v = eig.getEigenvector(i);\n+            getV().setColumn(iBeg + i, v);\n+        }\n+\n+        // Update the off-diagonal blocks\n+        for (int j = jBeg; j < jEnd; j += BLOCK_SIZE) {\n+            int jBlockEnd = Math.min(j + BLOCK_SIZE, jEnd);\n+\n+            RealMatrix vBlock = getV().getSubMatrix(iBeg, iEnd, j, jBlockEnd - 1);\n+            subMatrix = getT().getSubMatrix(j, jBlockEnd - 1, jBeg, jEnd);\n+            RealMatrix uBlock = vBlock.transpose().multiply(subMatrix);\n+\n+            vBlock = eig.getSolver().getInverse().multiply(uBlock);\n+\n+            getT().setSubMatrix(vBlock.multiply(vBlock.transpose()).getData(), j, jBeg);\n+        }\n+    }\n+}\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}