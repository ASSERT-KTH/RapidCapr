{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Pair;\nimport org.apache.commons.math3.util.MathArrays;\nimport org.apache.commons.math3.exception.NumberIsTooSmallException;\n\npublic class RegularizedGammaFix {\n\n    /**\n     * Default constructor.  Prohibit instantiation of utility class.\n     */\n    private RegularizedGammaFix() {\n    }\n\n    /**\n     * Returns the regularized gamma function P(a, x).\n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">Regularized Gamma Function</a>, equation (1).\n     * </li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">Incomplete Gamma Function</a>, equation (4).\n     * </li>\n     * </ul>\n     *\n     * @param a    the a parameter.\n     * @param x    the x parameter.\n     * @return the regularized gamma function P(a, x).\n     * @throws NumberIsTooSmallException if {@code x < 0} or {@code a <= 0}.\n     * @throws ArithmeticException if the result is NaN.\n     */\n    public static double regularizedGammaP(double a, double x) throws NumberIsTooSmallException, ArithmeticException {\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.A_X_VALUES_INVALID, a, 0, false);\n        }\n\n        if (x == 0 || x < a + 1) {\n            return 1 - regularizedGammaQ(a, x);\n        }\n\n        Pair<Double, Double> la = lanczos(a);\n\n        double ret;\n        boolean neg = false;\n        double xpa = x + a;\n        double lng = la.getFirst();\n        double lna = la.getSecond();\n\n        lng += (0.5 * FastMath.log(2 * FastMath.PI));\n        lng += (a + 0.5) * FastMath.log(xpa);\n        lng -= xpa;\n        double front = FastMath.exp(lng);\n        if (x > 1 + a) {\n            double di = 1 / x;\n            double dj = di;\n            double sum = 0;\n            double err = 0;\n            boolean cont = true;\n            for (int j = 1; j <= MathArrays.ARRAY_MAX_GAMMA; j++) {\n                double inc = dj * lna;\n                sum += inc;\n                if (FastMath.abs(inc) < err) {\n                    cont = false;\n                } else {\n                    err = FastMath.abs(inc);\n                }\n                if (FastMath.abs(dj * la.getFirst()) < err) {\n                    cont = false;\n                }\n                dj /= (a + j);\n                dj *= x;\n                if (!cont) {\n                    break;\n                }\n            }\n            ret = sum + lng + FastMath.log(front);\n        } else {\n            double d = 1 / (lna + x - 1);\n            double ss = 1;\n            double s = ss;\n            double z = 0;\n            boolean cont = true;\n            for (int j = 1; j <= MathArrays.ARRAY_MAX_GAMMA; j++) {\n                ss += 1;\n                z += 1 - a;\n                s *= z * d;\n                if (FastMath.abs(z * s) < FastMath.ulp(ss)) {\n                    cont = false;\n                }\n                if (!cont) {\n                    break;\n                }\n            }\n            ret = s * front / a;\n        }\n        if (neg) {\n            ret = -ret;\n        }\n        if (Double.isNaN(ret)) {\n            throw new ArithmeticException(LocalizedFormats.NAN_VALUE);\n        }\n        return ret;\n    }\n\n    /**\n     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n     * The implementation of this method is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">Regularized Gamma Function</a>, equation (1).\n     * </li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">Incomplete Gamma Function</a>, equation (4).\n     * </li>\n     * </ul>\n     *\n     * @param a    the a parameter.\n     * @param x    the x parameter.\n     * @return the regularized gamma function Q(a, x).\n     * @throws NumberIsTooSmallException if {@code x < 0} or {@code a <= 0}.\n     * @throws ArithmeticException if the result is NaN.\n     */\n    public static double regularizedGammaQ(double a, double x) throws NumberIsTooSmallException, ArithmeticException {\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.A_X_VALUES_INVALID, a, 0, false);\n        }\n\n        if (x == 0) {\n            return 1;\n        }\n\n        if (x >= a + 1) {\n            return 1 - regularizedGammaP(a, x);\n        }\n\n        double ret;\n        boolean neg = false;\n        if (x > 1 + Double.MIN_VALUE) {\n            ret = 1 - regularizedGammaPFraction1(a, x);\n        } else {\n            ret = 1 - regularizedGammaFraction2(a, x);\n        }\n        if (neg) {\n            ret = -ret;\n        }\n        if (Double.isNaN(ret)) {\n            throw new ArithmeticException(LocalizedFormats.NAN_VALUE);\n        }\n        return ret;\n    }\n\n    /**\n     * Returns the upper tail of the incomplete gamma function\n     * divided by the gamma function. The implementation of this method\n     * is based on:\n     * <ul>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">Regularized Gamma Function</a>, equation (7).\n     * </li>\n     * </ul>\n     *\n     * @param a    the a parameter.\n     * @param x    the x parameter.\n     * @return the regularized gamma function Q(a, x).\n     * @throws NumberIsTooSmallException if {@code x <= 0} or {@code a <= 0}.\n     * @throws ArithmeticException if the result is NaN.\n     */\n    public static double regularizedGammaQ1(double a, double x) throws NumberIsTooSmallException {\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x <= 0.0) {\n            throw new NumberIsTooSmallException(LocalizedFormats.A_X_VALUES_INVALID, a, 0, false);\n        }\n\n        if (x == Double.POSITIVE_INFINITY) {\n            return 0;\n        }\n\n        if (x < a + 1) {\n            return 1 - regularizedGammaP1(a, x);\n        }\n\n        double la = Gamma.logGamma(a);\n        double ax = a * FastMath.log(x) - x - la;\n        if (ax < -709.782712893384) {\n            return (a < x) ? 1 : 0;\n        }\n        double term = FastMath.exp(-x + a * FastMath.log(x) - la) / a;\n        double sum = term;\n        for (int i = 1; i < 1000; ++i) {\n            term *= x / (a + i);\n            sum += term;\n            if (term / sum < 1e-15) {\n                return sum;\n            }\n        }\n        return 1 - sum;\n    }\n\n    /**\n     * Computes the continued fraction for the gamma function, <br/>\n     * P(a, x) = gamma(a, x)/Gamma(a) <br/>\n     * where\n     * <pre>\n     * P(a, x) = 1/[x + 1/(a+1) -&gamma;[2!/(x+3/(a+2)-&gamma;[3!/(x+5/(a+4)-&gamma;[4!(x+7/(a+6)-&gamma;[5!/(x+9/(a+8)-&gamma;[6!(x+11/(a+10)-&hyp;]]]]]]]]]]]\n     * </pre>\n     * and &gamma;, &#8712;, (0,1), is Euler's constant.\n     * <p>\n     * This method returns P(a, x) evaluated in a manner that\n     * avoids overflow and with the least amount of cancellation\n     * error. The implementation of this method is based on equation (5.2)\n     * of:\n     * <ul>\n     * <li>\n     * A&S, 13.5.1.\n     * </li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction</a> equations (76) -- (80).\n     * </li>\n     * <li>\n     * <a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma Function</a> equations (14), (15), (24), and (25).\n     * </li>\n     * </ul>\n     * Estimates range from the largest double down to a value less than\n     * the smallest double in the smallest double normalized number.\n     *\n     * @param a the a parameter.\n     * @param x the x parameter.\n     * @return the value of the continued fraction evaluated at {@code x}.\n     * @throws NumberIsTooSmallException if {@code a <= 0}.\n     * @throws ArithmeticException if the algorithm fails to converge.\n     */\n    public static double regularizedGammaPQContinuedFraction(double a, double x) throws NumberIsTooSmallException, ArithmeticException {\n        if (a <= 0) {\n            throw new NumberIsTooSmallException(a, 0, false);\n        }\n        double ret;\n        boolean reversed = false;\n        double apn = 0 + (1 / 0.0);\n        double bpn = 1.0;\n        double aqn = 1.0;\n        double bqn = x;\n        double an = 1.0;\n        double bn = x;\n        double convergent;\n        int n = 0;\n        while (n < MathArrays.ARRAY_MAX_GAMMA) {\n            ++n;\n            double a1 = n * (a - n);\n            double b1 = n + n * (x - a - 1);\n            an = aqn * an + a1 * apn;\n            bn = bqn * bn + b1 * bpn;\n            double aq1 = an / bn;\n            double bq1 = 1.0;\n            convergent = aq1 * bn / (bq1 * an);\n            if (FastMath.abs((convergent - aqn) / convergent) < 1e-15) {\n                bn = MathUtils.normalize(bn / convergent);\n                ret = FastMath.exp(-x + (a * FastMath.log(x)) - Gamma.logGamma(a)) * convergent;\n                break;\n            }\n            aqp = apn;\n            bqp = bpn;\n            apn = an;\n            bpn = bn;\n            aqn = aq1;\n            bqn = bq1;\n            if (FastMath.max(FastMath.abs(an), FastMath.abs(bn)) > 1e292) {\n                apn = MathUtils.normalize(apn);\n                bpn = MathUtils.normalize(bpn);\n                aqn = MathUtils.normalize(aqn);\n                bqn = MathUtils.normalize(bqn);\n            }\n            if (FastMath.abs(bqn) > 0x1.0p500) {\n                apn = MathUtils.normalize(apn / bqn);\n                bpn = MathUtils.normalize(bpn / bqn);\n                aqn = MathUtils.normalize(aqn / bqn);\n                bqn = MathUtils.normalize(1.0);\n            }\n            if ((n % 10) == 0) {\n                apn = MathUtils.normalize(apn);\n                bpn = MathUtils.normalize(bpn);\n                aqn = MathUtils.normalize(aqn);\n                bqn = MathUtils.normalize(bqn);\n            }\n            if ((n == MathArrays.ARRAY_MAX_GAMMA - 1)) {\n                throw new ArithmeticException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION);\n            }\n        }\n        if (n == MathArrays.ARRAY_MAX_GAMMA) {\n            throw new ArithmeticException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION);\n        }\n        return ret;\n    }\n\n    /**\n     * This routine returns the continued fraction expansion needed for\n     * computing the incomplete gamma function when the parameters are large,\n     * <pre>\n     * Q(a, z) = &Gamma;(a, z)/&Gamma;(a) = z<sup>a</sup>e<sup>-z</sup>&Gamma;(a, z)/(a-1 + z + (1-a)(2!/(a+2)) + (1-a)(2a+5)/(2!*(a+3)) + ...),\n     *        ~ z<sup>a</sup>e<sup>-z</sup>&Gamma;(a, z)/(a-1 + z + (1-a)(2!/(a+2))),\n     * </pre>\n     * see A&S 6.5.  For large {@code a} and {@code z}, the routine terminates\n     * because of a divergence in the series being summed, {@code pbeta}.\n     *\n     * @param a    the a parameter.\n     * @param z    the z parameter.\n     * @return the value of the continued fraction.\n     * @throws NumberIsTooSmallException if {@code a < 0}\n     * @throws ArithmeticException if the algorithm fails to converge.\n     */\n    private static double regularizedGammaFraction2(double a, double z) throws NumberIsTooSmallException, ArithmeticException {\n        if (a < 0) {\n            throw new NumberIsTooSmallException(a, 0, false);\n        }\n\n        double c = 1.0 / 30.0;\n        double d = 1.0 / 35.0;\n        double e = 1.0 / 50.0;\n        double eps = 1.0e-15;\n        double f = 1.0 / ((691.0 / 256.0) - (1.0 / 16.0) * z);\n        double g = z - a + 1.0;\n        double ap = a + 1.0;\n        double sum = f * g / ap;\n        double del = sum;\n        int i = 1;\n        while ((FastMath.abs(del) > FastMath.abs(sum) * eps) && (i < 100)) {\n            ++i;\n            ap += 2.0;\n            c += d;\n            d += e;\n            g = z - a + ap * g;\n            del = f * g * c / ap;\n            sum += del;\n        }\n        return sum;\n    }\n\n    /**\n     * Returns the Lanczos approximation used to compute the gamma function.\n     * The implementation of this method is based on equation (1) from:\n     * <ul>\n     * <li>\n     * G. Nemes, D. Laurie, J. P. Bowler, \"The Lanczos approximation for complex gamma functions,\" SIAM Journal on\n     * Numerical Analysis, vol. 24, no. 2, pp. 365-369, 1987.\n     * </li>\n     * </ul>\n     *\n     * @param z the input value.\n     * @return a 2-element array holding the computed values for the Lanczos approximation for the input value.\n     */\n    private static Pair<Double, Double> lanczos(double z) {\n        double v = 0;\n        double jv = 0;\n        for (int i = lanczosLength - 1; i >= 0; i--) {\n            v = lanczosCoefficients[i] + v * z;\n            jv = lanczosCoefficients[i + 1] + jv * z;\n        }\n        double zgh = z + gLanczosG + 0.5;\n        return new Pair<>(0.5 * FastMath.log(2 * FastMath.PI) + (z + 0.5) * FastMath.log(zgh) - zgh + FastMath.log(v), jv / v);\n    }\n\n    /** The Lanczos coefficients. */\n    private static final double[] lanczosCoefficients;\n\n    /** The Lanczos length. */\n    private static final int lanczosLength;\n\n    private static final double gLanczosG = 4.7421875;\n\n    static {\n        // Compute the Lanczos coefficients.\n        // These can be obtained from http://web.mala.bc.ca/pughg/phdThesis/phdThesis.pdf\n        // There is also a typo in section 2.2.6. The correct constant is g = 4.7421875, not 4.7425875.\n        lanczosCoefficients = new double[] {\n            0.99999999999999709182,\n            57.156235665862923517,\n            -59.597960355475491248,\n            14.136097974741747174,\n            -0.49191381609762019978,\n            0.33994649984811888699e-4,\n            0.46523628927048575665e-4,\n            -0.98374475304879564677e-4,\n            0.15808870322491248884e-3,\n            -0.21026444",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..620d33f01 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,389 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.Pair;\n+import org.apache.commons.math3.util.MathArrays;\n+import org.apache.commons.math3.exception.NumberIsTooSmallException;\n+\n+public class RegularizedGammaFix {\n+\n+    /**\n+     * Default constructor.  Prohibit instantiation of utility class.\n+     */\n+    private RegularizedGammaFix() {\n+    }\n+\n+    /**\n+     * Returns the regularized gamma function P(a, x).\n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">Regularized Gamma Function</a>, equation (1).\n+     * </li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">Incomplete Gamma Function</a>, equation (4).\n+     * </li>\n+     * </ul>\n+     *\n+     * @param a    the a parameter.\n+     * @param x    the x parameter.\n+     * @return the regularized gamma function P(a, x).\n+     * @throws NumberIsTooSmallException if {@code x < 0} or {@code a <= 0}.\n+     * @throws ArithmeticException if the result is NaN.\n+     */\n+    public static double regularizedGammaP(double a, double x) throws NumberIsTooSmallException, ArithmeticException {\n+        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.A_X_VALUES_INVALID, a, 0, false);\n+        }\n+\n+        if (x == 0 || x < a + 1) {\n+            return 1 - regularizedGammaQ(a, x);\n+        }\n+\n+        Pair<Double, Double> la = lanczos(a);\n+\n+        double ret;\n+        boolean neg = false;\n+        double xpa = x + a;\n+        double lng = la.getFirst();\n+        double lna = la.getSecond();\n+\n+        lng += (0.5 * FastMath.log(2 * FastMath.PI));\n+        lng += (a + 0.5) * FastMath.log(xpa);\n+        lng -= xpa;\n+        double front = FastMath.exp(lng);\n+        if (x > 1 + a) {\n+            double di = 1 / x;\n+            double dj = di;\n+            double sum = 0;\n+            double err = 0;\n+            boolean cont = true;\n+            for (int j = 1; j <= MathArrays.ARRAY_MAX_GAMMA; j++) {\n+                double inc = dj * lna;\n+                sum += inc;\n+                if (FastMath.abs(inc) < err) {\n+                    cont = false;\n+                } else {\n+                    err = FastMath.abs(inc);\n+                }\n+                if (FastMath.abs(dj * la.getFirst()) < err) {\n+                    cont = false;\n+                }\n+                dj /= (a + j);\n+                dj *= x;\n+                if (!cont) {\n+                    break;\n+                }\n+            }\n+            ret = sum + lng + FastMath.log(front);\n+        } else {\n+            double d = 1 / (lna + x - 1);\n+            double ss = 1;\n+            double s = ss;\n+            double z = 0;\n+            boolean cont = true;\n+            for (int j = 1; j <= MathArrays.ARRAY_MAX_GAMMA; j++) {\n+                ss += 1;\n+                z += 1 - a;\n+                s *= z * d;\n+                if (FastMath.abs(z * s) < FastMath.ulp(ss)) {\n+                    cont = false;\n+                }\n+                if (!cont) {\n+                    break;\n+                }\n+            }\n+            ret = s * front / a;\n+        }\n+        if (neg) {\n+            ret = -ret;\n+        }\n+        if (Double.isNaN(ret)) {\n+            throw new ArithmeticException(LocalizedFormats.NAN_VALUE);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns the regularized gamma function Q(a, x) = 1 - P(a, x).\n+     * The implementation of this method is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">Regularized Gamma Function</a>, equation (1).\n+     * </li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/IncompleteGammaFunction.html\">Incomplete Gamma Function</a>, equation (4).\n+     * </li>\n+     * </ul>\n+     *\n+     * @param a    the a parameter.\n+     * @param x    the x parameter.\n+     * @return the regularized gamma function Q(a, x).\n+     * @throws NumberIsTooSmallException if {@code x < 0} or {@code a <= 0}.\n+     * @throws ArithmeticException if the result is NaN.\n+     */\n+    public static double regularizedGammaQ(double a, double x) throws NumberIsTooSmallException, ArithmeticException {\n+        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.A_X_VALUES_INVALID, a, 0, false);\n+        }\n+\n+        if (x == 0) {\n+            return 1;\n+        }\n+\n+        if (x >= a + 1) {\n+            return 1 - regularizedGammaP(a, x);\n+        }\n+\n+        double ret;\n+        boolean neg = false;\n+        if (x > 1 + Double.MIN_VALUE) {\n+            ret = 1 - regularizedGammaPFraction1(a, x);\n+        } else {\n+            ret = 1 - regularizedGammaFraction2(a, x);\n+        }\n+        if (neg) {\n+            ret = -ret;\n+        }\n+        if (Double.isNaN(ret)) {\n+            throw new ArithmeticException(LocalizedFormats.NAN_VALUE);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * Returns the upper tail of the incomplete gamma function\n+     * divided by the gamma function. The implementation of this method\n+     * is based on:\n+     * <ul>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/RegularizedGammaFunction.html\">Regularized Gamma Function</a>, equation (7).\n+     * </li>\n+     * </ul>\n+     *\n+     * @param a    the a parameter.\n+     * @param x    the x parameter.\n+     * @return the regularized gamma function Q(a, x).\n+     * @throws NumberIsTooSmallException if {@code x <= 0} or {@code a <= 0}.\n+     * @throws ArithmeticException if the result is NaN.\n+     */\n+    public static double regularizedGammaQ1(double a, double x) throws NumberIsTooSmallException {\n+        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x <= 0.0) {\n+            throw new NumberIsTooSmallException(LocalizedFormats.A_X_VALUES_INVALID, a, 0, false);\n+        }\n+\n+        if (x == Double.POSITIVE_INFINITY) {\n+            return 0;\n+        }\n+\n+        if (x < a + 1) {\n+            return 1 - regularizedGammaP1(a, x);\n+        }\n+\n+        double la = Gamma.logGamma(a);\n+        double ax = a * FastMath.log(x) - x - la;\n+        if (ax < -709.782712893384) {\n+            return (a < x) ? 1 : 0;\n+        }\n+        double term = FastMath.exp(-x + a * FastMath.log(x) - la) / a;\n+        double sum = term;\n+        for (int i = 1; i < 1000; ++i) {\n+            term *= x / (a + i);\n+            sum += term;\n+            if (term / sum < 1e-15) {\n+                return sum;\n+            }\n+        }\n+        return 1 - sum;\n+    }\n+\n+    /**\n+     * Computes the continued fraction for the gamma function, <br/>\n+     * P(a, x) = gamma(a, x)/Gamma(a) <br/>\n+     * where\n+     * <pre>\n+     * P(a, x) = 1/[x + 1/(a+1) -&gamma;[2!/(x+3/(a+2)-&gamma;[3!/(x+5/(a+4)-&gamma;[4!(x+7/(a+6)-&gamma;[5!/(x+9/(a+8)-&gamma;[6!(x+11/(a+10)-&hyp;]]]]]]]]]]]\n+     * </pre>\n+     * and &gamma;, &#8712;, (0,1), is Euler's constant.\n+     * <p>\n+     * This method returns P(a, x) evaluated in a manner that\n+     * avoids overflow and with the least amount of cancellation\n+     * error. The implementation of this method is based on equation (5.2)\n+     * of:\n+     * <ul>\n+     * <li>\n+     * A&S, 13.5.1.\n+     * </li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/ContinuedFraction.html\">Continued Fraction</a> equations (76) -- (80).\n+     * </li>\n+     * <li>\n+     * <a href=\"http://mathworld.wolfram.com/GammaFunction.html\">Gamma Function</a> equations (14), (15), (24), and (25).\n+     * </li>\n+     * </ul>\n+     * Estimates range from the largest double down to a value less than\n+     * the smallest double in the smallest double normalized number.\n+     *\n+     * @param a the a parameter.\n+     * @param x the x parameter.\n+     * @return the value of the continued fraction evaluated at {@code x}.\n+     * @throws NumberIsTooSmallException if {@code a <= 0}.\n+     * @throws ArithmeticException if the algorithm fails to converge.\n+     */\n+    public static double regularizedGammaPQContinuedFraction(double a, double x) throws NumberIsTooSmallException, ArithmeticException {\n+        if (a <= 0) {\n+            throw new NumberIsTooSmallException(a, 0, false);\n+        }\n+        double ret;\n+        boolean reversed = false;\n+        double apn = 0 + (1 / 0.0);\n+        double bpn = 1.0;\n+        double aqn = 1.0;\n+        double bqn = x;\n+        double an = 1.0;\n+        double bn = x;\n+        double convergent;\n+        int n = 0;\n+        while (n < MathArrays.ARRAY_MAX_GAMMA) {\n+            ++n;\n+            double a1 = n * (a - n);\n+            double b1 = n + n * (x - a - 1);\n+            an = aqn * an + a1 * apn;\n+            bn = bqn * bn + b1 * bpn;\n+            double aq1 = an / bn;\n+            double bq1 = 1.0;\n+            convergent = aq1 * bn / (bq1 * an);\n+            if (FastMath.abs((convergent - aqn) / convergent) < 1e-15) {\n+                bn = MathUtils.normalize(bn / convergent);\n+                ret = FastMath.exp(-x + (a * FastMath.log(x)) - Gamma.logGamma(a)) * convergent;\n+                break;\n+            }\n+            aqp = apn;\n+            bqp = bpn;\n+            apn = an;\n+            bpn = bn;\n+            aqn = aq1;\n+            bqn = bq1;\n+            if (FastMath.max(FastMath.abs(an), FastMath.abs(bn)) > 1e292) {\n+                apn = MathUtils.normalize(apn);\n+                bpn = MathUtils.normalize(bpn);\n+                aqn = MathUtils.normalize(aqn);\n+                bqn = MathUtils.normalize(bqn);\n+            }\n+            if (FastMath.abs(bqn) > 0x1.0p500) {\n+                apn = MathUtils.normalize(apn / bqn);\n+                bpn = MathUtils.normalize(bpn / bqn);\n+                aqn = MathUtils.normalize(aqn / bqn);\n+                bqn = MathUtils.normalize(1.0);\n+            }\n+            if ((n % 10) == 0) {\n+                apn = MathUtils.normalize(apn);\n+                bpn = MathUtils.normalize(bpn);\n+                aqn = MathUtils.normalize(aqn);\n+                bqn = MathUtils.normalize(bqn);\n+            }\n+            if ((n == MathArrays.ARRAY_MAX_GAMMA - 1)) {\n+                throw new ArithmeticException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION);\n+            }\n+        }\n+        if (n == MathArrays.ARRAY_MAX_GAMMA) {\n+            throw new ArithmeticException(LocalizedFormats.NON_CONVERGENT_CONTINUED_FRACTION);\n+        }\n+        return ret;\n+    }\n+\n+    /**\n+     * This routine returns the continued fraction expansion needed for\n+     * computing the incomplete gamma function when the parameters are large,\n+     * <pre>\n+     * Q(a, z) = &Gamma;(a, z)/&Gamma;(a) = z<sup>a</sup>e<sup>-z</sup>&Gamma;(a, z)/(a-1 + z + (1-a)(2!/(a+2)) + (1-a)(2a+5)/(2!*(a+3)) + ...),\n+     *        ~ z<sup>a</sup>e<sup>-z</sup>&Gamma;(a, z)/(a-1 + z + (1-a)(2!/(a+2))),\n+     * </pre>\n+     * see A&S 6.5.  For large {@code a} and {@code z}, the routine terminates\n+     * because of a divergence in the series being summed, {@code pbeta}.\n+     *\n+     * @param a    the a parameter.\n+     * @param z    the z parameter.\n+     * @return the value of the continued fraction.\n+     * @throws NumberIsTooSmallException if {@code a < 0}\n+     * @throws ArithmeticException if the algorithm fails to converge.\n+     */\n+    private static double regularizedGammaFraction2(double a, double z) throws NumberIsTooSmallException, ArithmeticException {\n+        if (a < 0) {\n+            throw new NumberIsTooSmallException(a, 0, false);\n+        }\n+\n+        double c = 1.0 / 30.0;\n+        double d = 1.0 / 35.0;\n+        double e = 1.0 / 50.0;\n+        double eps = 1.0e-15;\n+        double f = 1.0 / ((691.0 / 256.0) - (1.0 / 16.0) * z);\n+        double g = z - a + 1.0;\n+        double ap = a + 1.0;\n+        double sum = f * g / ap;\n+        double del = sum;\n+        int i = 1;\n+        while ((FastMath.abs(del) > FastMath.abs(sum) * eps) && (i < 100)) {\n+            ++i;\n+            ap += 2.0;\n+            c += d;\n+            d += e;\n+            g = z - a + ap * g;\n+            del = f * g * c / ap;\n+            sum += del;\n+        }\n+        return sum;\n+    }\n+\n+    /**\n+     * Returns the Lanczos approximation used to compute the gamma function.\n+     * The implementation of this method is based on equation (1) from:\n+     * <ul>\n+     * <li>\n+     * G. Nemes, D. Laurie, J. P. Bowler, \"The Lanczos approximation for complex gamma functions,\" SIAM Journal on\n+     * Numerical Analysis, vol. 24, no. 2, pp. 365-369, 1987.\n+     * </li>\n+     * </ul>\n+     *\n+     * @param z the input value.\n+     * @return a 2-element array holding the computed values for the Lanczos approximation for the input value.\n+     */\n+    private static Pair<Double, Double> lanczos(double z) {\n+        double v = 0;\n+        double jv = 0;\n+        for (int i = lanczosLength - 1; i >= 0; i--) {\n+            v = lanczosCoefficients[i] + v * z;\n+            jv = lanczosCoefficients[i + 1] + jv * z;\n+        }\n+        double zgh = z + gLanczosG + 0.5;\n+        return new Pair<>(0.5 * FastMath.log(2 * FastMath.PI) + (z + 0.5) * FastMath.log(zgh) - zgh + FastMath.log(v), jv / v);\n+    }\n+\n+    /** The Lanczos coefficients. */\n+    private static final double[] lanczosCoefficients;\n+\n+    /** The Lanczos length. */\n+    private static final int lanczosLength;\n+\n+    private static final double gLanczosG = 4.7421875;\n+\n+    static {\n+        // Compute the Lanczos coefficients.\n+        // These can be obtained from http://web.mala.bc.ca/pughg/phdThesis/phdThesis.pdf\n+        // There is also a typo in section 2.2.6. The correct constant is g = 4.7421875, not 4.7425875.\n+        lanczosCoefficients = new double[] {\n+            0.99999999999999709182,\n+            57.156235665862923517,\n+            -59.597960355475491248,\n+            14.136097974741747174,\n+            -0.49191381609762019978,\n+            0.33994649984811888699e-4,\n+            0.46523628927048575665e-4,\n+            -0.98374475304879564677e-4,\n+            0.15808870322491248884e-3,\n+            -0.21026444\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: '}' expected",
    "test_result": "ERROR"
}