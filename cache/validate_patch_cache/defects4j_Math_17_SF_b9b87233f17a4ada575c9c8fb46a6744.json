{
    "patch": "public Dfp multiply(final int x) {\n    if (isNaN()) {\n        return newInstance(getField(), qnan);\n    } else if (x == 0) {\n        return newInstance(getField(), 0);\n    }\n\n    int intSign = getSign();\n\n    if (intSign == 0) {\n        return newInstance(getField(), 0);\n    }\n\n    int intDigits[] = new int[10 + digits.length];\n\n    for (int i = 0; i < intDigits.length; i++) {\n        intDigits[i] = 0;\n    }\n\n    for (int i = digits.length - 1; i >= 0; i--) {\n        int carry = 0;\n        int factor = digits[i];\n        int temp;\n\n        for (int j = intDigits.length - 1; j >= 0; j--) {\n            temp = intDigits[j] * 10 + factor * x + carry;\n            intDigits[j] = temp % 10000;\n            carry = temp / 10000;\n        }\n    }\n\n    int virtualDecimalPoint = decimalPoint;\n\n    while (intDigits[virtualDecimalPoint] == 0 && virtualDecimalPoint < intDigits.length - 1) {\n        virtualDecimalPoint++;\n    }\n\n    while (intDigits[virtualDecimalPoint] >= 10000) {\n        int carry = intDigits[virtualDecimalPoint] / 10000;\n        intDigits[virtualDecimalPoint] %= 10000;\n        virtualDecimalPoint++;\n        intDigits[virtualDecimalPoint] += carry;\n    }\n\n    while (intDigits[virtualDecimalPoint] == 0 && virtualDecimalPoint > 0) {\n        virtualDecimalPoint--;\n    }\n\n    if (intSign < 0) {\n        int firstnonzero = virtualDecimalPoint;\n\n        while (intDigits[firstnonzero] == 0) {\n            firstnonzero++;\n        }\n\n        if (firstnonzero != virtualDecimalPoint) {\n            intDigits[firstnonzero - 1] = 10000 - intDigits[firstnonzero - 1];\n            int i;\n\n            for (i = firstnonzero; i < intDigits.length; i++) {\n                intDigits[i] = 9999 - intDigits[i];\n            }\n\n            for (i = intDigits.length - 1; i > firstnonzero - 1; i--) {\n                intDigits[i]++;\n\n                if (intDigits[i] < 10000) {\n                    break;\n                } else {\n                    intDigits[i] %= 10000;\n                }\n            }\n        } else {\n            intDigits[virtualDecimalPoint] = 10000 - intDigits[virtualDecimalPoint];\n\n            for (int i = virtualDecimalPoint + 1; i < intDigits.length; i++) {\n                intDigits[i] = 9999 - intDigits[i];\n            }\n\n            intDigits[intDigits.length - 1]++;\n        }\n    }\n\n    return newInstance(getField(), intSign, intDigits, virtualDecimalPoint);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..fbe1bee18 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1599,10 +1599,92 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param x multiplicand\n      * @return product of this and x\n      */\n-    public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n+public Dfp multiply(final int x) {\n+    if (isNaN()) {\n+        return newInstance(getField(), qnan);\n+    } else if (x == 0) {\n+        return newInstance(getField(), 0);\n     }\n \n+    int intSign = getSign();\n+\n+    if (intSign == 0) {\n+        return newInstance(getField(), 0);\n+    }\n+\n+    int intDigits[] = new int[10 + digits.length];\n+\n+    for (int i = 0; i < intDigits.length; i++) {\n+        intDigits[i] = 0;\n+    }\n+\n+    for (int i = digits.length - 1; i >= 0; i--) {\n+        int carry = 0;\n+        int factor = digits[i];\n+        int temp;\n+\n+        for (int j = intDigits.length - 1; j >= 0; j--) {\n+            temp = intDigits[j] * 10 + factor * x + carry;\n+            intDigits[j] = temp % 10000;\n+            carry = temp / 10000;\n+        }\n+    }\n+\n+    int virtualDecimalPoint = decimalPoint;\n+\n+    while (intDigits[virtualDecimalPoint] == 0 && virtualDecimalPoint < intDigits.length - 1) {\n+        virtualDecimalPoint++;\n+    }\n+\n+    while (intDigits[virtualDecimalPoint] >= 10000) {\n+        int carry = intDigits[virtualDecimalPoint] / 10000;\n+        intDigits[virtualDecimalPoint] %= 10000;\n+        virtualDecimalPoint++;\n+        intDigits[virtualDecimalPoint] += carry;\n+    }\n+\n+    while (intDigits[virtualDecimalPoint] == 0 && virtualDecimalPoint > 0) {\n+        virtualDecimalPoint--;\n+    }\n+\n+    if (intSign < 0) {\n+        int firstnonzero = virtualDecimalPoint;\n+\n+        while (intDigits[firstnonzero] == 0) {\n+            firstnonzero++;\n+        }\n+\n+        if (firstnonzero != virtualDecimalPoint) {\n+            intDigits[firstnonzero - 1] = 10000 - intDigits[firstnonzero - 1];\n+            int i;\n+\n+            for (i = firstnonzero; i < intDigits.length; i++) {\n+                intDigits[i] = 9999 - intDigits[i];\n+            }\n+\n+            for (i = intDigits.length - 1; i > firstnonzero - 1; i--) {\n+                intDigits[i]++;\n+\n+                if (intDigits[i] < 10000) {\n+                    break;\n+                } else {\n+                    intDigits[i] %= 10000;\n+                }\n+            }\n+        } else {\n+            intDigits[virtualDecimalPoint] = 10000 - intDigits[virtualDecimalPoint];\n+\n+            for (int i = virtualDecimalPoint + 1; i < intDigits.length; i++) {\n+                intDigits[i] = 9999 - intDigits[i];\n+            }\n+\n+            intDigits[intDigits.length - 1]++;\n+        }\n+    }\n+\n+    return newInstance(getField(), intSign, intDigits, virtualDecimalPoint);\n+}\n+\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n      * There are speed advantages in this special case.\n      * @param x multiplicand",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}