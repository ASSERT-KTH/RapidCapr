{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.MathUtils;\n\npublic class MyClass {\n    \n    public static void main(String[] args) {\n        double result = regularizedGamma(0.5, 0.5, 10e-15, 1000);\n        System.out.println(result);\n    }\n\n    public static double regularizedGamma(double a, double x, double epsilon, int maxIterations) {\n        MathUtils.checkNotNull(a);\n        MathUtils.checkNotNull(x);\n        MathUtils.checkNotNull(epsilon);\n        MathUtils.checkNotNull(maxIterations);\n\n        if (a <= 0.0) {\n            throw new IllegalArgumentException(\"a must be > 0.0\");\n        }\n\n        if (x < 0.0) {\n            throw new IllegalArgumentException(\"x must be >= 0.0\");\n        }\n\n        double ret;\n        if (x < a + 1.0) {\n            ret = series(a, x, epsilon, maxIterations);\n        } else {\n            ret = 1.0 - continuedFraction(a, x, epsilon, maxIterations);\n        }\n\n        return ret;\n    }\n\n    public static double series(double a, double x, double epsilon, int maxIterations) {\n        double n = 0.0;\n        double an = 1.0 / a;\n        double sum = an;\n\n        while (Math.abs(an) > epsilon && n < maxIterations && sum + an != sum) {\n            n += 1.0;\n            an *= x / (a + n);\n            sum += an;\n        }\n\n        return sum * Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a));\n    }\n\n    public static double continuedFraction(double a, double x, double epsilon, int maxIterations) {\n        double fpmin = Double.MIN_VALUE / epsilon;\n        double c = 1.0;\n        double d = 1.0 / (1.0 - a * x);\n        double h = d;\n\n        for (int i = 1; i <= maxIterations; i++) {\n            double an = -i * (i - a);\n            b = b + 2.0;\n            d = an * d + b;\n            \n            if (Math.abs(d) < fpmin) {\n                d = fpmin;\n            }\n\n            c = an + b / c;\n            \n            if (Math.abs(c) < fpmin) {\n                c = fpmin;\n            }\n\n            d = 1.0 / d;\n            double del = d * c;\n            h *= del;\n\n            if (Math.abs(del - 1.0) <= epsilon) {\n                return h;\n            }\n\n        }\n\n        throw new IllegalStateException(\"Failed to converge continued fraction\");\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..e4ec9eaba 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,88 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.MathUtils;\n+\n+public class MyClass {\n+    \n+    public static void main(String[] args) {\n+        double result = regularizedGamma(0.5, 0.5, 10e-15, 1000);\n+        System.out.println(result);\n+    }\n+\n+    public static double regularizedGamma(double a, double x, double epsilon, int maxIterations) {\n+        MathUtils.checkNotNull(a);\n+        MathUtils.checkNotNull(x);\n+        MathUtils.checkNotNull(epsilon);\n+        MathUtils.checkNotNull(maxIterations);\n+\n+        if (a <= 0.0) {\n+            throw new IllegalArgumentException(\"a must be > 0.0\");\n+        }\n+\n+        if (x < 0.0) {\n+            throw new IllegalArgumentException(\"x must be >= 0.0\");\n+        }\n+\n+        double ret;\n+        if (x < a + 1.0) {\n+            ret = series(a, x, epsilon, maxIterations);\n+        } else {\n+            ret = 1.0 - continuedFraction(a, x, epsilon, maxIterations);\n+        }\n+\n+        return ret;\n+    }\n+\n+    public static double series(double a, double x, double epsilon, int maxIterations) {\n+        double n = 0.0;\n+        double an = 1.0 / a;\n+        double sum = an;\n+\n+        while (Math.abs(an) > epsilon && n < maxIterations && sum + an != sum) {\n+            n += 1.0;\n+            an *= x / (a + n);\n+            sum += an;\n+        }\n+\n+        return sum * Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a));\n+    }\n+\n+    public static double continuedFraction(double a, double x, double epsilon, int maxIterations) {\n+        double fpmin = Double.MIN_VALUE / epsilon;\n+        double c = 1.0;\n+        double d = 1.0 / (1.0 - a * x);\n+        double h = d;\n+\n+        for (int i = 1; i <= maxIterations; i++) {\n+            double an = -i * (i - a);\n+            b = b + 2.0;\n+            d = an * d + b;\n+            \n+            if (Math.abs(d) < fpmin) {\n+                d = fpmin;\n+            }\n+\n+            c = an + b / c;\n+            \n+            if (Math.abs(c) < fpmin) {\n+                c = fpmin;\n+            }\n+\n+            d = 1.0 / d;\n+            double del = d * c;\n+            h *= del;\n+\n+            if (Math.abs(del - 1.0) <= epsilon) {\n+                return h;\n+            }\n+\n+        }\n+\n+        throw new IllegalStateException(\"Failed to converge continued fraction\");\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}