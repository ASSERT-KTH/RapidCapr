{
    "patch": "public class IRFactory extends NodeTransformer implements TypeSafeDispatcher {\n    private final ErrorReporter errorReporter;\n    private final String sourceName;\n    private Scope scope;\n\n    private static final Set<String> ALLOWED_DIRECTIVES =\n            ImmutableSet.of(\"use strict\", \"use asm\");\n\n    public IRFactory(ErrorReporter errorReporter, String sourceName) {\n        this.errorReporter = errorReporter;\n        this.sourceName = sourceName;\n    }\n\n    private Node createName(String name) {\n        return Node.newString(Token.NAME, name);\n    }\n\n    private Node createNumber(double value) {\n        return Node.newNumber(value);\n    }\n\n    private Node createString(String value) {\n        return Node.newString(value);\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) return false;\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n               n.getFirstChild().isString() &&\n               ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    @Override\n    Node processBlock(Block blockNode) {\n        return processGeneric(blockNode);\n    }\n\n    @Override\n    Node processBreakStatement(BreakStatement statementNode) {\n        Node node = newNode(Token.BREAK);\n        if (statementNode.getBreakLabel() != null) {\n            Node labelName = transform(statementNode.getBreakLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    Node processCatchClause(CatchClause clauseNode) {\n        AstNode catchVar = clauseNode.getVarName();\n        Node node = newNode(Token.CATCH, transform(catchVar));\n        if (clauseNode.getCatchCondition() != null) {\n            errorReporter.error(\n                    \"Catch clauses are not supported\",\n                    sourceName,\n                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n        }\n        node.addChildToBack(transformBlock(clauseNode.getBody()));\n        return node;\n    }\n\n    @Override\n    Node processConditionalExpression(ConditionalExpression exprNode) {\n        return newNode(\n                Token.HOOK,\n                transform(exprNode.getTestExpression()),\n                transform(exprNode.getTrueExpression()),\n                transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    Node processContinueStatement(ContinueStatement statementNode) {\n        Node node = newNode(Token.CONTINUE);\n        if (statementNode.getLabel() != null) {\n            Node labelName = transform(statementNode.getLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    Node processDoLoop(DoLoop loopNode) {\n        return newNode(\n                Token.DO,\n                transformBlock(loopNode.getBody()),\n                transform(loopNode.getCondition()));\n    }\n\n    @Override\n    Node processElementGet(ElementGet getNode) {\n        return newNode(\n                Token.GETELEM,\n                transform(getNode.getTarget()),\n                transform(getNode.getElement()));\n    }\n\n    @Override\n    Node processEmptyExpression(EmptyExpression exprNode) {\n        Node node = newNode(Token.EMPTY);\n        return node;\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n        Node node = newNode(transformTokenType(statementNode.getType()));\n        node.addChildToBack(transform(statementNode.getExpression()));\n        return node;\n    }\n\n    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n        Node varNode = null;\n        AstNode iterVar = loopNode.getIterator();\n        if (iterVar instanceof VariableDeclaration) {\n            varNode = transform(iterVar);\n        } else if (iterVar != null) {\n            varNode = newNode(Token.VAR, transform(iterVar));\n        }\n\n        return newNode(\n                Token.FOR,\n                varNode,\n                transform(loopNode.getIteratedObject()),\n                transformBlock(loopNode.getBody())\n        );\n    }\n\n    @Override\n    Node processForLoop(ForLoop loopNode) {\n        Node init = transform(loopNode.getInitializer());\n        Node cond = transform(loopNode.getCondition());\n        Node incr = transform(loopNode.getIncrement());\n\n        return newNode(\n                Token.FOR,\n                init,\n                cond,\n                incr,\n                transformBlock(loopNode.getBody())\n        );\n    }\n\n    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n        return newNode(\n                Token.CALL,\n                transform(callNode.getTarget()),\n                transform(callNode.getArguments())\n        );\n    }\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n        Node fnNode =\n                newNode(Token.FUNCTION, createName(functionNode.getName()));\n        fnNode.putProp(Node.FUNCTION_PROP, functionNode);\n\n        Scope savedScope = scope;\n        scope = functionNode.getScope();\n        pushScope(fnNode);\n        fnNode.addChildToBack(transform(functionNode.getParams()));\n        fnNode.addChildToBack(transform(functionNode.getBody()));\n        popScope();\n        scope = savedScope;\n\n        return fnNode;\n    }\n\n    @Override\n    Node processIfStatement(IfStatement statementNode) {\n        return newNode(\n                Token.IF,\n                transform(statementNode.getCondition()),\n                transformBlock(statementNode.getThenPart()),\n                transformBlock(statementNode.getElsePart()));\n    }\n\n    @Override\n    Node processInfixExpression(InfixExpression exprNode) {\n        return newNode(\n                transformTokenType(exprNode.getType()),\n                transform(exprNode.getLeft()),\n                transform(exprNode.getRight())\n        );\n    }\n\n    @Override\n    Node processKeywordLiteral(KeywordLiteral literalNode) {\n        int tt = transformTokenType(literalNode.getType());\n        if (tt != Token.TRUE && tt != Token.FALSE) {\n            return newNode(tt);\n        }\n\n        Node node = newNode(tt);\n        node.putBooleanProp(Node.PRIMARY_EXPR_HAS_SIDE_EFFECTS, false);\n        return node;\n    }\n\n    @Override\n    Node processName(Name nameNode) {\n        return createName(nameNode.getIdentifier());\n    }\n\n    @Override\n    Node processNewExpression(NewExpression nexNode) {\n        return newNode(\n                Token.NEW,\n                transform(nexNode.getTarget()),\n                transform(nexNode.getArguments())\n        );\n    }\n\n    @Override\n    Node processNumberLiteral(NumberLiteral literalNode) {\n        return createNumber(literalNode.getNumber());\n    }\n\n    @Override\n    Node processObjectLiteral(ObjectLiteral litNode) {\n        Node objNode = newNode(Token.OBJECTLIT);\n        for (ObjectProperty prop : litNode.getElements()) {\n            objNode.addChildToBack(transform(prop));\n        }\n        return objNode;\n    }\n\n    @Override\n    Node processObjectProperty(ObjectProperty propNode) {\n        Node keyNode = transform(propNode.getLeft());\n        if (propNode.isGetter()) {\n            return newNode(Token.GETTER_DEF, keyNode,\n                            transformFunctionBody(propNode.getRight()));\n        } else if (propNode.isSetter()) {\n            return newNode(Token.SETTER_DEF, keyNode,\n                            transformFunctionBody(propNode.getRight()));\n        }\n        return newNode(Token.STRING_KEY, keyNode, transform(propNode.getRight()));\n    }\n\n    @Override\n    Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n        Node node = newNode(Token.LP);\n        node.addChildToBack(transform(exprNode.getExpression()));\n        return node;\n    }\n\n    @Override\n    Node processRegExpLiteral(RegExpLiteral literalNode) {\n        return Node.newRegExp(literalNode.getValue());\n    }\n\n    @Override\n    Node processReturnStatement(ReturnStatement statementNode) {\n        Node returnNode =\n                newNode(Token.RETURN, transform(statementNode.getReturnValue()));\n        returnNode.setIsSyntheticBlock(true);\n        return returnNode;\n    }\n\n    @Override\n    Node processStringLiteral(StringLiteral literalNode) {\n        return createString(literalNode.getValue());\n    }\n\n    @Override\n    Node processSwitchCase(SwitchCase caseNode) {\n        Node node = newNode(Token.CASE, transform(caseNode.getExpression()));\n        for (AstNode stmt : caseNode.getStatements()) {\n            node.addChildToBack(transform(stmt));\n        }\n\n        return node;\n    }\n\n    @Override\n    Node processSwitchStatement(SwitchStatement statementNode) {\n        Node node = newNode(\n                Token.SWITCH,\n                transform(statementNode.getExpression())\n        );\n        for (SwitchCase caseNode : statementNode.getCases()) {\n            node.addChildToBack(transform(caseNode));\n        }\n\n        return node;\n    }\n\n    @Override\n    Node processThrowStatement(ThrowStatement statementNode) {\n        return newNode(\n                Token.THROW,\n                transform(statementNode.getExpression())\n        );\n    }\n\n    @Override\n    Node processTryStatement(TryStatement tryNode) {\n        Node tryBlockNode =\n                newNode(Token.BLOCK, transformBlock(tryNode.getTryBlock()));\n        Node tryNode =\n                newNode(Token.TRY, tryBlockNode);\n\n        for (CatchClause clauseNode : tryNode.getCatchClauses()) {\n            tryNode.addChildToBack(transform(clauseNode));\n        }\n\n        if (tryNode.getCatchClauses().isEmpty() &&\n            tryNode.getFinallyBlock() == null) {\n            // Attach an empty catch clause to ensure the try statement has\n            // at least one child to avoid being removed by the peephole passes.\n            CatchClause emptyCatch = new CatchClause();\n            emptyCatch.setVarName(new Name());\n            emptyCatch.setBody(new Block());\n            tryNode.addChildToBack(transform(emptyCatch));\n            // Also attach a fake finally block to the try statement to avoid\n            // further problems.\n            tryNode.addChildToBack(Node.newTarget());\n        }\n\n        if (tryNode.getFinallyBlock() != null) {\n            tryNode.addChildToBack(\n                    newNode(Token.FINALLY,\n                            transformBlock(tryNode.getFinallyBlock()))\n            );\n        }\n\n        return tryNode;\n    }\n\n    @Override\n    Node processUnaryExpression(UnaryExpression exprNode) {\n        Node node;\n        int type = exprNode.getType();\n        // Natives.FUNCTION indicates that the Node's parent should determine\n        // if it should have a side effect.\n        if (type == Token.DELPROP) {\n            node = newNode(type, transform(exprNode.getOperand()));\n            node.putBooleanProp(Node.PRIMARY_EXPR_HAS_SIDE_EFFECTS, false);\n            return node;\n        }\n        if (type == Token.TYPEOF) {\n            node = newNode(type, transform(exprNode.getOperand()));\n            node.putBooleanProp(Node.PRIMARY_EXPR_HAS_SIDE_EFFECTS, false);\n            return node;\n        }\n        return newNode(type, transform(exprNode.getOperand()));\n    }\n\n    @Override\n    Node processVariableDeclaration(VariableDeclaration decl) {\n        Node node = newNode(Token.VAR);\n        for (VariableInitializer init : decl.getVariables()) {\n            node.addChildToBack(transform(init));\n        }\n        return node;\n    }\n\n    @Override\n    Node processVariableInitializer(VariableInitializer init) {\n        Node node = newNode(Token.NAME,\n                             createName(init.getTarget().getIdentifier()));\n        if (init.getInitializer() != null) {\n            node.addChildToBack(transform(init.getInitializer()));\n        }\n        return node;\n    }\n\n    @Override\n    Node processWhileLoop(WhileLoop loopNode) {\n        return newNode(\n                Token.WHILE,\n                transform(loopNode.getCondition()),\n                transformBlock(loopNode.getBody())\n        );\n    }\n\n    @Override\n    Node processWithStatement(WithStatement statementNode) {\n        return newNode(\n                Token.WITH,\n                transform(statementNode.getExpression()),\n                transformBlock(statementNode.getStatement())\n        );\n    }\n\n    private Node transformFunctionBody(AstNode node) {\n        if (node instanceof EmptyExpression) {\n            return Node.newBlock();\n        }\n        return transform(node);\n    }\n\n    @Override\n    public Node transform(AstNode node) {\n        return node == null ? null : node.visit(this);\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..997e0165 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,410 @@ class IRFactory {\n       }\n     }\n \n+public class IRFactory extends NodeTransformer implements TypeSafeDispatcher {\n+    private final ErrorReporter errorReporter;\n+    private final String sourceName;\n+    private Scope scope;\n+\n+    private static final Set<String> ALLOWED_DIRECTIVES =\n+            ImmutableSet.of(\"use strict\", \"use asm\");\n+\n+    public IRFactory(ErrorReporter errorReporter, String sourceName) {\n+        this.errorReporter = errorReporter;\n+        this.sourceName = sourceName;\n+    }\n+\n+    private Node createName(String name) {\n+        return Node.newString(Token.NAME, name);\n+    }\n+\n+    private Node createNumber(double value) {\n+        return Node.newNumber(value);\n+    }\n+\n+    private Node createString(String value) {\n+        return Node.newString(value);\n+    }\n+\n     private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+        if (n == null) return false;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+               n.getFirstChild().isString() &&\n+               ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n     @Override\n     Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+        return processGeneric(blockNode);\n     }\n \n     @Override\n     Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+        Node node = newNode(Token.BREAK);\n+        if (statementNode.getBreakLabel() != null) {\n+            Node labelName = transform(statementNode.getBreakLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n     Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+        AstNode catchVar = clauseNode.getVarName();\n+        Node node = newNode(Token.CATCH, transform(catchVar));\n+        if (clauseNode.getCatchCondition() != null) {\n+            errorReporter.error(\n+                    \"Catch clauses are not supported\",\n+                    sourceName,\n+                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+        }\n+        node.addChildToBack(transformBlock(clauseNode.getBody()));\n+        return node;\n     }\n \n     @Override\n     Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+        return newNode(\n+                Token.HOOK,\n+                transform(exprNode.getTestExpression()),\n+                transform(exprNode.getTrueExpression()),\n+                transform(exprNode.getFalseExpression()));\n     }\n \n     @Override\n     Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+        Node node = newNode(Token.CONTINUE);\n+        if (statementNode.getLabel() != null) {\n+            Node labelName = transform(statementNode.getLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n     Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+        return newNode(\n+                Token.DO,\n+                transformBlock(loopNode.getBody()),\n+                transform(loopNode.getCondition()));\n     }\n \n     @Override\n     Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+        return newNode(\n+                Token.GETELEM,\n+                transform(getNode.getTarget()),\n+                transform(getNode.getElement()));\n     }\n \n     @Override\n     Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+        Node node = newNode(Token.EMPTY);\n+        return node;\n     }\n \n     @Override\n     Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+        Node node = newNode(transformTokenType(statementNode.getType()));\n+        node.addChildToBack(transform(statementNode.getExpression()));\n+        return node;\n     }\n \n     @Override\n     Node processForInLoop(ForInLoop loopNode) {\n+        Node varNode = null;\n+        AstNode iterVar = loopNode.getIterator();\n+        if (iterVar instanceof VariableDeclaration) {\n+            varNode = transform(iterVar);\n+        } else if (iterVar != null) {\n+            varNode = newNode(Token.VAR, transform(iterVar));\n+        }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+        return newNode(\n+                Token.FOR,\n+                varNode,\n+                transform(loopNode.getIteratedObject()),\n+                transformBlock(loopNode.getBody())\n+        );\n+    }\n+\n+    @Override\n+    Node processForLoop(ForLoop loopNode) {\n+        Node init = transform(loopNode.getInitializer());\n+        Node cond = transform(loopNode.getCondition());\n+        Node incr = transform(loopNode.getIncrement());\n+\n+        return newNode(\n+                Token.FOR,\n+                init,\n+                cond,\n+                incr,\n+                transformBlock(loopNode.getBody())\n+        );\n+    }\n+\n+    @Override\n+    Node processFunctionCall(FunctionCall callNode) {\n+        return newNode(\n+                Token.CALL,\n+                transform(callNode.getTarget()),\n+                transform(callNode.getArguments())\n+        );\n+    }\n+\n+    @Override\n+    Node processFunctionNode(FunctionNode functionNode) {\n+        Node fnNode =\n+                newNode(Token.FUNCTION, createName(functionNode.getName()));\n+        fnNode.putProp(Node.FUNCTION_PROP, functionNode);\n+\n+        Scope savedScope = scope;\n+        scope = functionNode.getScope();\n+        pushScope(fnNode);\n+        fnNode.addChildToBack(transform(functionNode.getParams()));\n+        fnNode.addChildToBack(transform(functionNode.getBody()));\n+        popScope();\n+        scope = savedScope;\n+\n+        return fnNode;\n+    }\n+\n+    @Override\n+    Node processIfStatement(IfStatement statementNode) {\n+        return newNode(\n+                Token.IF,\n+                transform(statementNode.getCondition()),\n+                transformBlock(statementNode.getThenPart()),\n+                transformBlock(statementNode.getElsePart()));\n+    }\n+\n+    @Override\n+    Node processInfixExpression(InfixExpression exprNode) {\n+        return newNode(\n+                transformTokenType(exprNode.getType()),\n+                transform(exprNode.getLeft()),\n+                transform(exprNode.getRight())\n+        );\n+    }\n+\n+    @Override\n+    Node processKeywordLiteral(KeywordLiteral literalNode) {\n+        int tt = transformTokenType(literalNode.getType());\n+        if (tt != Token.TRUE && tt != Token.FALSE) {\n+            return newNode(tt);\n+        }\n+\n+        Node node = newNode(tt);\n+        node.putBooleanProp(Node.PRIMARY_EXPR_HAS_SIDE_EFFECTS, false);\n+        return node;\n+    }\n+\n+    @Override\n+    Node processName(Name nameNode) {\n+        return createName(nameNode.getIdentifier());\n+    }\n+\n+    @Override\n+    Node processNewExpression(NewExpression nexNode) {\n+        return newNode(\n+                Token.NEW,\n+                transform(nexNode.getTarget()),\n+                transform(nexNode.getArguments())\n+        );\n+    }\n+\n+    @Override\n+    Node processNumberLiteral(NumberLiteral literalNode) {\n+        return createNumber(literalNode.getNumber());\n+    }\n+\n+    @Override\n+    Node processObjectLiteral(ObjectLiteral litNode) {\n+        Node objNode = newNode(Token.OBJECTLIT);\n+        for (ObjectProperty prop : litNode.getElements()) {\n+            objNode.addChildToBack(transform(prop));\n+        }\n+        return objNode;\n+    }\n+\n+    @Override\n+    Node processObjectProperty(ObjectProperty propNode) {\n+        Node keyNode = transform(propNode.getLeft());\n+        if (propNode.isGetter()) {\n+            return newNode(Token.GETTER_DEF, keyNode,\n+                            transformFunctionBody(propNode.getRight()));\n+        } else if (propNode.isSetter()) {\n+            return newNode(Token.SETTER_DEF, keyNode,\n+                            transformFunctionBody(propNode.getRight()));\n+        }\n+        return newNode(Token.STRING_KEY, keyNode, transform(propNode.getRight()));\n+    }\n+\n+    @Override\n+    Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n+        Node node = newNode(Token.LP);\n+        node.addChildToBack(transform(exprNode.getExpression()));\n+        return node;\n+    }\n+\n+    @Override\n+    Node processRegExpLiteral(RegExpLiteral literalNode) {\n+        return Node.newRegExp(literalNode.getValue());\n+    }\n+\n+    @Override\n+    Node processReturnStatement(ReturnStatement statementNode) {\n+        Node returnNode =\n+                newNode(Token.RETURN, transform(statementNode.getReturnValue()));\n+        returnNode.setIsSyntheticBlock(true);\n+        return returnNode;\n+    }\n+\n+    @Override\n+    Node processStringLiteral(StringLiteral literalNode) {\n+        return createString(literalNode.getValue());\n+    }\n+\n+    @Override\n+    Node processSwitchCase(SwitchCase caseNode) {\n+        Node node = newNode(Token.CASE, transform(caseNode.getExpression()));\n+        for (AstNode stmt : caseNode.getStatements()) {\n+            node.addChildToBack(transform(stmt));\n+        }\n+\n+        return node;\n+    }\n+\n+    @Override\n+    Node processSwitchStatement(SwitchStatement statementNode) {\n+        Node node = newNode(\n+                Token.SWITCH,\n+                transform(statementNode.getExpression())\n+        );\n+        for (SwitchCase caseNode : statementNode.getCases()) {\n+            node.addChildToBack(transform(caseNode));\n+        }\n+\n+        return node;\n+    }\n+\n+    @Override\n+    Node processThrowStatement(ThrowStatement statementNode) {\n+        return newNode(\n+                Token.THROW,\n+                transform(statementNode.getExpression())\n+        );\n     }\n \n+    @Override\n+    Node processTryStatement(TryStatement tryNode) {\n+        Node tryBlockNode =\n+                newNode(Token.BLOCK, transformBlock(tryNode.getTryBlock()));\n+        Node tryNode =\n+                newNode(Token.TRY, tryBlockNode);\n+\n+        for (CatchClause clauseNode : tryNode.getCatchClauses()) {\n+            tryNode.addChildToBack(transform(clauseNode));\n+        }\n+\n+        if (tryNode.getCatchClauses().isEmpty() &&\n+            tryNode.getFinallyBlock() == null) {\n+            // Attach an empty catch clause to ensure the try statement has\n+            // at least one child to avoid being removed by the peephole passes.\n+            CatchClause emptyCatch = new CatchClause();\n+            emptyCatch.setVarName(new Name());\n+            emptyCatch.setBody(new Block());\n+            tryNode.addChildToBack(transform(emptyCatch));\n+            // Also attach a fake finally block to the try statement to avoid\n+            // further problems.\n+            tryNode.addChildToBack(Node.newTarget());\n+        }\n+\n+        if (tryNode.getFinallyBlock() != null) {\n+            tryNode.addChildToBack(\n+                    newNode(Token.FINALLY,\n+                            transformBlock(tryNode.getFinallyBlock()))\n+            );\n+        }\n+\n+        return tryNode;\n+    }\n+\n+    @Override\n+    Node processUnaryExpression(UnaryExpression exprNode) {\n+        Node node;\n+        int type = exprNode.getType();\n+        // Natives.FUNCTION indicates that the Node's parent should determine\n+        // if it should have a side effect.\n+        if (type == Token.DELPROP) {\n+            node = newNode(type, transform(exprNode.getOperand()));\n+            node.putBooleanProp(Node.PRIMARY_EXPR_HAS_SIDE_EFFECTS, false);\n+            return node;\n+        }\n+        if (type == Token.TYPEOF) {\n+            node = newNode(type, transform(exprNode.getOperand()));\n+            node.putBooleanProp(Node.PRIMARY_EXPR_HAS_SIDE_EFFECTS, false);\n+            return node;\n+        }\n+        return newNode(type, transform(exprNode.getOperand()));\n+    }\n+\n+    @Override\n+    Node processVariableDeclaration(VariableDeclaration decl) {\n+        Node node = newNode(Token.VAR);\n+        for (VariableInitializer init : decl.getVariables()) {\n+            node.addChildToBack(transform(init));\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    Node processVariableInitializer(VariableInitializer init) {\n+        Node node = newNode(Token.NAME,\n+                             createName(init.getTarget().getIdentifier()));\n+        if (init.getInitializer() != null) {\n+            node.addChildToBack(transform(init.getInitializer()));\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    Node processWhileLoop(WhileLoop loopNode) {\n+        return newNode(\n+                Token.WHILE,\n+                transform(loopNode.getCondition()),\n+                transformBlock(loopNode.getBody())\n+        );\n+    }\n+\n+    @Override\n+    Node processWithStatement(WithStatement statementNode) {\n+        return newNode(\n+                Token.WITH,\n+                transform(statementNode.getExpression()),\n+                transformBlock(statementNode.getStatement())\n+        );\n+    }\n+\n+    private Node transformFunctionBody(AstNode node) {\n+        if (node instanceof EmptyExpression) {\n+            return Node.newBlock();\n+        }\n+        return transform(node);\n+    }\n+\n+    @Override\n+    public Node transform(AstNode node) {\n+        return node == null ? null : node.visit(this);\n+    }\n+}\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: class IRFactory is already defined in package com.google.javascript.jscomp.parsing",
    "test_result": "ERROR"
}