{
    "patch": "public class IRFactory {\n\n    private final String sourceName;\n    private final ErrorReporter errorReporter;\n    private final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n\n    public IRFactory(String filename, ErrorReporter errorReporter) {\n        this.sourceName = filename;\n        this.errorReporter = errorReporter;\n    }\n\n    public Node transform(AstNode node) {\n        return TransformDispatcher.transform(node, this);\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) {\n            return false;\n        }\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT && n.getFirstChild().isString()\n                && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    private Node processGeneric(Node node) {\n        int count = node.getChildCount();\n        Node newNode = new Node(node.getType(), node.getLineno(), node.getCharno());\n\n        if (isDirective(node)) {\n            newNode.addChildToBack(transform(node.getFirstChild()));\n        } else {\n            for (int i = 0; i < count; i++) {\n                newNode.addChildToBack(transform(node.getChildAtIndex(i)));\n            }\n        }\n\n        return newNode;\n    }\n\n    @SuppressWarnings(\"unused\")\n    static class TransformDispatcher extends TypeSafeDispatcher {\n\n        private final IRFactory factory;\n\n        TransformDispatcher(IRFactory factory) {\n            this.factory = factory;\n        }\n\n        @Override\n        public Node processArrayComprehension(ArrayComprehension node) {\n            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n        }\n\n        @Override\n        public Node processArrayComprehensionLoop(ArrayComprehensionLoop node) {\n            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n        }\n\n        @Override\n        public Node processArrayLiteral(ArrayLiteral node) {\n            Node newNode = new Node(Token.ARRAYLIT);\n            for (AstNode child : node.getElements()) {\n                newNode.addChildToBack(transform(child));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processObjectLiteral(ObjectLiteral node) {\n            Node newNode = new Node(Token.OBJECTLIT);\n            for (ObjectProperty prop : node.getElements()) {\n                newNode.addChildToBack(transform(prop.getLeft()));\n                newNode.addChildToBack(transform(prop.getRight()));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processBlock(Block node) {\n            return processGeneric(node);\n        }\n\n        @Override\n        public Node processBreakStatement(BreakStatement node) {\n            Node newNode = new Node(Token.BREAK);\n            if (node.getBreakLabel() != null) {\n                newNode.addChildToBack(transform(node.getBreakLabel()));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processName(Name node) {\n            String ident = node.getIdentifier();\n            return new Node(Token.NAME, new Ident(ident));\n        }\n\n        @Override\n        public Node processNumber(NumberLiteral node) {\n            return new Node(Token.NUMBER, node.getDouble());\n        }\n\n        @Override\n        public Node processString(StringLiteral node) {\n            return new Node(Token.STRING, node.getValue());\n        }\n\n        @Override\n        public Node processRegExp(RegExpLiteral node) {\n            return new Node(Token.REGEXP, node.getValue(), node.getFlags());\n        }\n\n        @Override\n        public Node processFunction(FunctionNode node) {\n            Node name = null;\n            if (node.getFunctionName() != null) {\n                name = transform(node.getFunctionName());\n            }\n\n            Node params = new Node(Token.PARAM_LIST);\n            for (AstNode param : node.getParams()) {\n                params.addChildToBack(transform(param));\n            }\n\n            Node body = transform(node.getBody());\n\n            Node newNode = new Node(Token.FUNCTION, name, params, body);\n            newNode.setIsExpression(node.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION);\n            return newNode;\n        }\n\n        @Override\n        public Node processIfStatement(IfStatement node) {\n            Node testExpr = transform(node.getCondition());\n            Node ifTrue = transform(node.getThenPart());\n            Node ifFalse = null;\n            if (node.getElsePart() != null) {\n                ifFalse = transform(node.getElsePart());\n            }\n\n            return new Node(Token.IF, testExpr, ifTrue, ifFalse);\n        }\n\n        @Override\n        public Node processLabeledStatement(LabeledStatement node) {\n            Node stmt = transform(node.getStatement());\n            Node label = transform(node.getLabeledStatement());\n            label.setLabel(node.getLabelName());\n            return new Node(Token.LABEL, label).addChildToBack(stmt);\n        }\n\n        @Override\n        public Node processNewExpression(NewExpression node) {\n            Node newNode = new Node(Token.NEW);\n            newNode.addChildToBack(transform(node.getTarget()));\n            for (AstNode arg : node.getArguments()) {\n                newNode.addChildToBack(transform(arg));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processParenthesizedExpression(ParenthesizedExpression node) {\n            Node newNode = new Node(Token.LP);\n            newNode.addChildToBack(transform(node.getExpression()));\n            return newNode;\n        }\n\n        @Override\n        public Node processPropertyGet(PropertyGet node) {\n            return new Node(Token.GETPROP, transform(node.getTarget()),\n                    new Node(Token.STRING, node.getProperty()));\n        }\n\n        @Override\n        public Node processRegExpLiteral(RegExpLiteral node) {\n            return new Node(Token.REGEXP, node.getValue(), node.getFlags());\n        }\n\n        @Override\n        public Node processReturnStatement(ReturnStatement node) {\n            Node newNode = new Node(Token.RETURN);\n            if (node.getReturnValue() != null) {\n                newNode.addChildToBack(transform(node.getReturnValue()));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processSwitchStatement(SwitchStatement node) {\n            Node expr = transform(node.getExpression());\n            Node cases = new Node(Token.CASEBLOCK);\n\n            for (SwitchCase sc : node.getCases()) {\n                Node caseNode;\n                if (sc.getExpression() == null) {\n                    caseNode = new Node(Token.DEFAULT);\n                } else {\n                    caseNode = new Node(Token.CASE, transform(sc.getExpression()));\n                }\n\n                for (AstNode statement : sc.getStatements()) {\n                    caseNode.addChildToBack(transform(statement));\n                }\n                cases.addChildToBack(caseNode);\n            }\n\n            return new Node(Token.SWITCH, expr, cases);\n        }\n\n        @Override\n        public Node processThrowStatement(ThrowStatement node) {\n            return new Node(Token.THROW, transform(node.getExpression()));\n        }\n\n        @Override\n        public Node processTryStatement(TryStatement node) {\n            Node tryBlock = transform(node.getTryBlock());\n            Node catchBlock = null;\n            if (node.getCatchBlock() != null) {\n                Node catchParam = transform(node.getCatchBlock().getCaughtException());\n                Node catchBody = transform(node.getCatchBlock());\n                catchBlock = new Node(Token.CATCH, catchParam, catchBody);\n            }\n\n            Node finallyBlock = null;\n            if (node.getFinallyBlock() != null) {\n                finallyBlock = transform(node.getFinallyBlock());\n            }\n\n            return new Node(Token.TRY, tryBlock, catchBlock, finallyBlock);\n        }\n\n        @Override\n        public Node processUnaryExpression(UnaryExpression node) {\n            Node newNode = new Node(node.getType());\n            newNode.addChildToBack(transform(node.getOperand()));\n            return newNode;\n        }\n\n        @Override\n        public Node processVariableDeclaration(VariableDeclaration node) {\n            Node newNode = new Node(Token.LET);\n            if (node.getType() == Token.VAR) {\n                newNode.setType(Token.VAR);\n            }\n            for (VariableInitializer child : node.getVariables()) {\n                newNode.addChildToBack(transform(child));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processVariableInitializer(VariableInitializer node) {\n            Node newNode = new Node(Token.NAME, new Ident(node.getTarget().getIdentifier()));\n            if (node.getInitializer() != null) {\n                newNode.addChildToBack(transform(node.getInitializer()));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processWhileLoop(WhileLoop node) {\n            return new Node(Token.WHILE, transform(node.getCondition()),\n                    transform(node.getBody()));\n        }\n\n        @Override\n        public Node processWithStatement(WithStatement node) {\n            throw new UnsupportedOperationException(\"With statements not supported\");\n        }\n\n        @Override\n        public Node processDoLoop(DoLoop loopNode) {\n            return new Node(Token.DO, transform(loopNode.getBody()),\n                    transform(loopNode.getCondition()));\n        }\n\n        @Override\n        public Node processForInLoop(ForInLoop loopNode) {\n            Node lhs = transform(loopNode.getIterator());\n            Node obj = transform(loopNode.getIteratedObject());\n            Node body = transformBlock(loopNode.getBody());\n\n            if (lhs.getType() == Token.VAR) {\n                lhs.setType(Token.LET);\n                for (Node c = lhs.getFirstChild(); c != null; c = c.getNext()) {\n                    c.setType(Token.LET);\n                }\n            }\n\n            return new Node(Token.FOR_OF, lhs, obj, body);\n        }\n\n        @Override\n        public Node processForLoop(ForLoop loopNode) {\n            Node init = null;\n            if (loopNode.getInitializer() != null) {\n                init = transform(loopNode.getInitializer());\n            }\n\n            Node test = null;\n            if (loopNode.getCondition() != null) {\n                test = transform(loopNode.getCondition());\n            }\n\n            Node incr = null;\n            if (loopNode.getIncrement() != null) {\n                incr = transform(loopNode.getIncrement());\n            }\n\n            return new Node(Token.FOR, init, test, incr, transform(loopNode.getBody()));\n        }\n\n        @Override\n        public Node processFunctionCall(FunctionCall node) {\n            Node newNode = new Node(Token.CALL, transform(node.getTarget()));\n            for (AstNode arg : node.getArguments()) {\n                newNode.addChildToBack(transform(arg));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processScript(Script node) {\n            Node newNode = new Node(Token.SCRIPT);\n            for (AstNode element : node.getElements()) {\n                newNode.addChildToBack(transform(element));\n            }\n            return newNode;\n        }\n\n        @Override\n        public Node processAssignment(Assignment node) {\n            Node newNode = new Node(node.getType());\n            newNode.addChildToBack(transform(node.getLeft()));\n            newNode.addChildToBack(transform(node.getRight()));\n            return newNode;\n        }\n\n        @Override\n        public Node processUnaryExpressionNotPlusMinus(UnaryExpression node) {\n            Node newNode = new Node(node.getType());\n            newNode.addChildToBack(transform(node.getOperand()));\n            return newNode;\n        }\n\n        @Override\n        public Node processComment(Comment node) {\n            return new Node(Token.EMPTY);\n        }\n\n        @Override\n        public Node processDefault(AstNode node) {\n            throw new UnsupportedOperationException(\"Unexpected node type\");\n        }\n\n        @Override\n        public Node processExpressionStatement(ExpressionStatement statementNode) {\n            Node node = new Node(transformTokenType(statementNode.getType()));\n            node.addChildToBack(transform(statementNode.getExpression()));\n            return node;\n        }\n\n        private Token transformTokenType(int tokenType) {\n            switch (tokenType) {\n                case Token.EXPR_VOID:\n                    return Token.VOID;\n                case Token.EXPR_RESULT:\n                    return Token.EMPTY;\n                case Token.RETURN:\n                case Token.CONTINUE:\n                case Token.BREAK:\n                case Token.DEBUGGER:\n                    return Token.byType(tokenType);\n                default:\n                    throw new IllegalArgumentException(\"Unexpected token type: \" + tokenType);\n            }\n        }\n    }\n\n    public Node transformBlock(Block block) {\n        return transform(block);\n    }\n\n    public Node transformBlock(AstNode block) {\n        Node result = new Node(Token.BLOCK);\n        for (Node n = transform(block.getFirstChild()); n != null; n = n.getNext()) {\n            result.addChildToBack(n);\n        }\n        return result;\n    }\n\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..683424c9 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,402 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+    private final String sourceName;\n+    private final ErrorReporter errorReporter;\n+    private final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public IRFactory(String filename, ErrorReporter errorReporter) {\n+        this.sourceName = filename;\n+        this.errorReporter = errorReporter;\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node transform(AstNode node) {\n+        return TransformDispatcher.transform(node, this);\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n+    private boolean isDirective(Node n) {\n+        if (n == null) {\n+            return false;\n+        }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT && n.getFirstChild().isString()\n+                && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+    private Node processGeneric(Node node) {\n+        int count = node.getChildCount();\n+        Node newNode = new Node(node.getType(), node.getLineno(), node.getCharno());\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+        if (isDirective(node)) {\n+            newNode.addChildToBack(transform(node.getFirstChild()));\n+        } else {\n+            for (int i = 0; i < count; i++) {\n+                newNode.addChildToBack(transform(node.getChildAtIndex(i)));\n+            }\n+        }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+        return newNode;\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+    @SuppressWarnings(\"unused\")\n+    static class TransformDispatcher extends TypeSafeDispatcher {\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+        private final IRFactory factory;\n+\n+        TransformDispatcher(IRFactory factory) {\n+            this.factory = factory;\n+        }\n+\n+        @Override\n+        public Node processArrayComprehension(ArrayComprehension node) {\n+            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n+        }\n+\n+        @Override\n+        public Node processArrayComprehensionLoop(ArrayComprehensionLoop node) {\n+            throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n+        }\n+\n+        @Override\n+        public Node processArrayLiteral(ArrayLiteral node) {\n+            Node newNode = new Node(Token.ARRAYLIT);\n+            for (AstNode child : node.getElements()) {\n+                newNode.addChildToBack(transform(child));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processObjectLiteral(ObjectLiteral node) {\n+            Node newNode = new Node(Token.OBJECTLIT);\n+            for (ObjectProperty prop : node.getElements()) {\n+                newNode.addChildToBack(transform(prop.getLeft()));\n+                newNode.addChildToBack(transform(prop.getRight()));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processBlock(Block node) {\n+            return processGeneric(node);\n+        }\n+\n+        @Override\n+        public Node processBreakStatement(BreakStatement node) {\n+            Node newNode = new Node(Token.BREAK);\n+            if (node.getBreakLabel() != null) {\n+                newNode.addChildToBack(transform(node.getBreakLabel()));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processName(Name node) {\n+            String ident = node.getIdentifier();\n+            return new Node(Token.NAME, new Ident(ident));\n+        }\n+\n+        @Override\n+        public Node processNumber(NumberLiteral node) {\n+            return new Node(Token.NUMBER, node.getDouble());\n+        }\n+\n+        @Override\n+        public Node processString(StringLiteral node) {\n+            return new Node(Token.STRING, node.getValue());\n+        }\n+\n+        @Override\n+        public Node processRegExp(RegExpLiteral node) {\n+            return new Node(Token.REGEXP, node.getValue(), node.getFlags());\n+        }\n+\n+        @Override\n+        public Node processFunction(FunctionNode node) {\n+            Node name = null;\n+            if (node.getFunctionName() != null) {\n+                name = transform(node.getFunctionName());\n+            }\n+\n+            Node params = new Node(Token.PARAM_LIST);\n+            for (AstNode param : node.getParams()) {\n+                params.addChildToBack(transform(param));\n+            }\n+\n+            Node body = transform(node.getBody());\n+\n+            Node newNode = new Node(Token.FUNCTION, name, params, body);\n+            newNode.setIsExpression(node.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION);\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processIfStatement(IfStatement node) {\n+            Node testExpr = transform(node.getCondition());\n+            Node ifTrue = transform(node.getThenPart());\n+            Node ifFalse = null;\n+            if (node.getElsePart() != null) {\n+                ifFalse = transform(node.getElsePart());\n+            }\n+\n+            return new Node(Token.IF, testExpr, ifTrue, ifFalse);\n+        }\n+\n+        @Override\n+        public Node processLabeledStatement(LabeledStatement node) {\n+            Node stmt = transform(node.getStatement());\n+            Node label = transform(node.getLabeledStatement());\n+            label.setLabel(node.getLabelName());\n+            return new Node(Token.LABEL, label).addChildToBack(stmt);\n+        }\n+\n+        @Override\n+        public Node processNewExpression(NewExpression node) {\n+            Node newNode = new Node(Token.NEW);\n+            newNode.addChildToBack(transform(node.getTarget()));\n+            for (AstNode arg : node.getArguments()) {\n+                newNode.addChildToBack(transform(arg));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processParenthesizedExpression(ParenthesizedExpression node) {\n+            Node newNode = new Node(Token.LP);\n+            newNode.addChildToBack(transform(node.getExpression()));\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processPropertyGet(PropertyGet node) {\n+            return new Node(Token.GETPROP, transform(node.getTarget()),\n+                    new Node(Token.STRING, node.getProperty()));\n+        }\n+\n+        @Override\n+        public Node processRegExpLiteral(RegExpLiteral node) {\n+            return new Node(Token.REGEXP, node.getValue(), node.getFlags());\n+        }\n+\n+        @Override\n+        public Node processReturnStatement(ReturnStatement node) {\n+            Node newNode = new Node(Token.RETURN);\n+            if (node.getReturnValue() != null) {\n+                newNode.addChildToBack(transform(node.getReturnValue()));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processSwitchStatement(SwitchStatement node) {\n+            Node expr = transform(node.getExpression());\n+            Node cases = new Node(Token.CASEBLOCK);\n+\n+            for (SwitchCase sc : node.getCases()) {\n+                Node caseNode;\n+                if (sc.getExpression() == null) {\n+                    caseNode = new Node(Token.DEFAULT);\n+                } else {\n+                    caseNode = new Node(Token.CASE, transform(sc.getExpression()));\n+                }\n+\n+                for (AstNode statement : sc.getStatements()) {\n+                    caseNode.addChildToBack(transform(statement));\n+                }\n+                cases.addChildToBack(caseNode);\n+            }\n+\n+            return new Node(Token.SWITCH, expr, cases);\n+        }\n+\n+        @Override\n+        public Node processThrowStatement(ThrowStatement node) {\n+            return new Node(Token.THROW, transform(node.getExpression()));\n+        }\n+\n+        @Override\n+        public Node processTryStatement(TryStatement node) {\n+            Node tryBlock = transform(node.getTryBlock());\n+            Node catchBlock = null;\n+            if (node.getCatchBlock() != null) {\n+                Node catchParam = transform(node.getCatchBlock().getCaughtException());\n+                Node catchBody = transform(node.getCatchBlock());\n+                catchBlock = new Node(Token.CATCH, catchParam, catchBody);\n+            }\n+\n+            Node finallyBlock = null;\n+            if (node.getFinallyBlock() != null) {\n+                finallyBlock = transform(node.getFinallyBlock());\n+            }\n+\n+            return new Node(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+        }\n+\n+        @Override\n+        public Node processUnaryExpression(UnaryExpression node) {\n+            Node newNode = new Node(node.getType());\n+            newNode.addChildToBack(transform(node.getOperand()));\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processVariableDeclaration(VariableDeclaration node) {\n+            Node newNode = new Node(Token.LET);\n+            if (node.getType() == Token.VAR) {\n+                newNode.setType(Token.VAR);\n+            }\n+            for (VariableInitializer child : node.getVariables()) {\n+                newNode.addChildToBack(transform(child));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processVariableInitializer(VariableInitializer node) {\n+            Node newNode = new Node(Token.NAME, new Ident(node.getTarget().getIdentifier()));\n+            if (node.getInitializer() != null) {\n+                newNode.addChildToBack(transform(node.getInitializer()));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processWhileLoop(WhileLoop node) {\n+            return new Node(Token.WHILE, transform(node.getCondition()),\n+                    transform(node.getBody()));\n+        }\n+\n+        @Override\n+        public Node processWithStatement(WithStatement node) {\n+            throw new UnsupportedOperationException(\"With statements not supported\");\n+        }\n+\n+        @Override\n+        public Node processDoLoop(DoLoop loopNode) {\n+            return new Node(Token.DO, transform(loopNode.getBody()),\n+                    transform(loopNode.getCondition()));\n+        }\n+\n+        @Override\n+        public Node processForInLoop(ForInLoop loopNode) {\n+            Node lhs = transform(loopNode.getIterator());\n+            Node obj = transform(loopNode.getIteratedObject());\n+            Node body = transformBlock(loopNode.getBody());\n+\n+            if (lhs.getType() == Token.VAR) {\n+                lhs.setType(Token.LET);\n+                for (Node c = lhs.getFirstChild(); c != null; c = c.getNext()) {\n+                    c.setType(Token.LET);\n+                }\n+            }\n+\n+            return new Node(Token.FOR_OF, lhs, obj, body);\n+        }\n+\n+        @Override\n+        public Node processForLoop(ForLoop loopNode) {\n+            Node init = null;\n+            if (loopNode.getInitializer() != null) {\n+                init = transform(loopNode.getInitializer());\n+            }\n+\n+            Node test = null;\n+            if (loopNode.getCondition() != null) {\n+                test = transform(loopNode.getCondition());\n+            }\n+\n+            Node incr = null;\n+            if (loopNode.getIncrement() != null) {\n+                incr = transform(loopNode.getIncrement());\n+            }\n+\n+            return new Node(Token.FOR, init, test, incr, transform(loopNode.getBody()));\n+        }\n+\n+        @Override\n+        public Node processFunctionCall(FunctionCall node) {\n+            Node newNode = new Node(Token.CALL, transform(node.getTarget()));\n+            for (AstNode arg : node.getArguments()) {\n+                newNode.addChildToBack(transform(arg));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processScript(Script node) {\n+            Node newNode = new Node(Token.SCRIPT);\n+            for (AstNode element : node.getElements()) {\n+                newNode.addChildToBack(transform(element));\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processAssignment(Assignment node) {\n+            Node newNode = new Node(node.getType());\n+            newNode.addChildToBack(transform(node.getLeft()));\n+            newNode.addChildToBack(transform(node.getRight()));\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processUnaryExpressionNotPlusMinus(UnaryExpression node) {\n+            Node newNode = new Node(node.getType());\n+            newNode.addChildToBack(transform(node.getOperand()));\n+            return newNode;\n+        }\n+\n+        @Override\n+        public Node processComment(Comment node) {\n+            return new Node(Token.EMPTY);\n+        }\n+\n+        @Override\n+        public Node processDefault(AstNode node) {\n+            throw new UnsupportedOperationException(\"Unexpected node type\");\n+        }\n+\n+        @Override\n+        public Node processExpressionStatement(ExpressionStatement statementNode) {\n+            Node node = new Node(transformTokenType(statementNode.getType()));\n+            node.addChildToBack(transform(statementNode.getExpression()));\n+            return node;\n+        }\n+\n+        private Token transformTokenType(int tokenType) {\n+            switch (tokenType) {\n+                case Token.EXPR_VOID:\n+                    return Token.VOID;\n+                case Token.EXPR_RESULT:\n+                    return Token.EMPTY;\n+                case Token.RETURN:\n+                case Token.CONTINUE:\n+                case Token.BREAK:\n+                case Token.DEBUGGER:\n+                    return Token.byType(tokenType);\n+                default:\n+                    throw new IllegalArgumentException(\"Unexpected token type: \" + tokenType);\n+            }\n+        }\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node transformBlock(Block block) {\n+        return transform(block);\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    public Node transformBlock(AstNode block) {\n+        Node result = new Node(Token.BLOCK);\n+        for (Node n = transform(block.getFirstChild()); n != null; n = n.getNext()) {\n+            result.addChildToBack(n);\n+        }\n+        return result;\n     }\n \n+}\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: class IRFactory is already defined in package com.google.javascript.jscomp.parsing",
    "test_result": "ERROR"
}