{
    "patch": "  private void propToObj(ObjectType objType, String prop, JSType type) {\n    JSType currPropType = objType.getPropertyType(prop);\n    if (currPropType == null) {\n      objType.defineInferredProperty(prop, type, null);\n    } else {\n      JSType newPropType = JSType.meet(currPropType, type);\n      if (!newPropType.equals(currPropType)) {\n        objType.defineInferredProperty(prop, newPropType, null);\n      }\n    }\n  }\n\n  private void inferPropertyTypesFromCalleeAndArguments(\n      Node callNode, ObjectType calleeType, List<JSType> argTypes) {\n    FunctionType funType = calleeType.getFunType();\n    if (funType == null) {\n      return;\n    }\n\n    ImmutableList.Builder<NormalizedProp> propsToVisit = ImmutableList.builder();\n    for (Node formal : functionArgumentNames(callNode)) {\n      propsToVisit.addAll(getNormalizedProps(funType.getMaxArity(), formal.getString()));\n    }\n    int i = 0;\n    for (NormalizedProp prop : propsToVisit.build()) {\n      JSType formalType = funType.getFormalType(i);\n      if (prop.isArrayIndex()) {\n        inferIndexType(callNode.getFirstChild().getJSType(), formalType, argTypes.get(i));\n      } else {\n        propToObj(callNode.getFirstChild().getOrCreateJSType().toMaybeObjectType(),\n            prop.getPropName(), argTypes.get(i));\n      }\n      i++;\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e10920..833b9a0b 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1118,24 +1118,44 @@ class TypeInference\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n+  private void propToObj(ObjectType objType, String prop, JSType type) {\n+    JSType currPropType = objType.getPropertyType(prop);\n+    if (currPropType == null) {\n+      objType.defineInferredProperty(prop, type, null);\n+    } else {\n+      JSType newPropType = JSType.meet(currPropType, type);\n+      if (!newPropType.equals(currPropType)) {\n+        objType.defineInferredProperty(prop, newPropType, null);\n       }\n     }\n   }\n \n+  private void inferPropertyTypesFromCalleeAndArguments(\n+      Node callNode, ObjectType calleeType, List<JSType> argTypes) {\n+    FunctionType funType = calleeType.getFunType();\n+    if (funType == null) {\n+      return;\n+    }\n+\n+    ImmutableList.Builder<NormalizedProp> propsToVisit = ImmutableList.builder();\n+    for (Node formal : functionArgumentNames(callNode)) {\n+      propsToVisit.addAll(getNormalizedProps(funType.getMaxArity(), formal.getString()));\n+    }\n+    int i = 0;\n+    for (NormalizedProp prop : propsToVisit.build()) {\n+      JSType formalType = funType.getFormalType(i);\n+      if (prop.isArrayIndex()) {\n+        inferIndexType(callNode.getFirstChild().getJSType(), formalType, argTypes.get(i));\n+      } else {\n+        propToObj(callNode.getFirstChild().getOrCreateJSType().toMaybeObjectType(),\n+            prop.getPropName(), argTypes.get(i));\n+      }\n+      i++;\n+    }\n+  }\n+    }\n+  }\n+\n   /**\n    * If we access a property of a symbol, then that symbol is not\n    * null or undefined.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}