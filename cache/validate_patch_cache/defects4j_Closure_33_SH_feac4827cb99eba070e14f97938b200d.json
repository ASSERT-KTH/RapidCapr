{
    "patch": " if (!constraintObj.isNominalConstructor() && !constraintObj.isFunctionType()) {\n      // Handle the case where the constraint object is a record type.\n      //\n      // param constraintObj {{prop: (number|undefined)}}\n      // function f(constraintObj) {}\n      // f({});\n      //\n      // We want to modify the object literal to match the constraint, by\n      // taking any each property on the record and trying to match\n      // properties on this object.\n      if (constraintObj.isRecordType()) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getOwnPropertyType(prop);\n          if (propType.isRecordType()) {\n            ObjectType ot = ObjectType.cast(propType.getDisplayName());\n            if (ot != null && ot.hasOwnProperty(\"prop\")) {\n              // Use the common properties of the object types to match\n              // nested objects recursively.\n              for (String nestedProp : ot.getOwnPropertyNames()) {\n                if (hasOwnProperty(prop + \".\" + nestedProp)) {\n                  JSType thisNestedPropType = getProp(prop + \".\" + nestedProp).getType();\n                  JSType otherNestedPropType = ot.getPropertyType(nestedProp);\n                  thisNestedPropType.matchConstraint(otherNestedPropType);\n                }\n              }\n            }\n            // The nested object does not (yet) exist on this object.\n            else {\n              defineInferredProperty(\n                  prop, registry.createNullableType(propType), null);\n            }\n          } else {\n            if (!isPropertyTypeDeclared(prop)) {\n              JSType typeToInfer = propType;\n              if (!hasProperty(prop)) {\n                typeToInfer =\n                    getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);\n              }\n              defineInferredProperty(prop, typeToInfer, null);\n            }\n          }\n        }\n      }\n\n      // Handle the case where the constraint object is a function type.\n      //\n      // param constraintObj {function(...)}\n      // function f(constraintObj) {}\n      // f(function() {/* some code here */});\n      //\n      // We want to do two things in this branch:\n      // 1. Build up the parameter and return types of this function,\n      //    possibly using the main JSTypeRegistry to look up any parameter/\n      //    return types.\n      // 2. Infer properties on the 'this' variable of the function type.\n      else {\n        FunctionType functionType = (FunctionType) constraintObj;\n        // Infer the properties of the 'this' variable.\n        ObjectType thisObjType = functionType.getTypeOfThis();\n        if (thisObjType != null) {\n          for (String prop : thisObjType.getOwnPropertyNames()) {\n            // Don't infer the types of properties that are declared.\n            if (!isPropertyTypeDeclared(prop)) {\n              JSType typeToInfer = thisObjType.getPropertyType(prop);\n              if (!hasProperty(prop) && functionType.hasRestFormals()) {\n                typeToInfer = typeToInfer.getCommonSupertype(getNativeType(\n                    JSTypeNative.VOID_TYPE).getFunctionTypeWithRestFormals());\n              }\n              defineInferredProperty(prop, typeToInfer, null);\n            }\n          }\n        }\n        // Infer the parameter and return types.\n        Iterator<Node> formalItr = functionType.getFormals().iterator();\n        for (Node arg : arguments) {\n          JSType typeToInfer = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n          if (formalItr.hasNext()) {\n            typeToInfer = formalItr.next().getJSType();\n          } else if (functionType.hasRestFormals()) {\n            typeToInfer = functionType.getRestFormalsType();\n          }\n          arg.getFirstChild().inferAnnotation(typeToInfer);\n        }\n        if (functionType.hasReturnValue()) {\n          returnType.inferAnnotation(functionType.getReturnType());\n        }\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex b6e3fc78..4da0089e 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -554,6 +554,94 @@ class PrototypeObjectType extends ObjectType {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n+ if (!constraintObj.isNominalConstructor() && !constraintObj.isFunctionType()) {\n+      // Handle the case where the constraint object is a record type.\n+      //\n+      // param constraintObj {{prop: (number|undefined)}}\n+      // function f(constraintObj) {}\n+      // f({});\n+      //\n+      // We want to modify the object literal to match the constraint, by\n+      // taking any each property on the record and trying to match\n+      // properties on this object.\n+      if (constraintObj.isRecordType()) {\n+        for (String prop : constraintObj.getOwnPropertyNames()) {\n+          JSType propType = constraintObj.getOwnPropertyType(prop);\n+          if (propType.isRecordType()) {\n+            ObjectType ot = ObjectType.cast(propType.getDisplayName());\n+            if (ot != null && ot.hasOwnProperty(\"prop\")) {\n+              // Use the common properties of the object types to match\n+              // nested objects recursively.\n+              for (String nestedProp : ot.getOwnPropertyNames()) {\n+                if (hasOwnProperty(prop + \".\" + nestedProp)) {\n+                  JSType thisNestedPropType = getProp(prop + \".\" + nestedProp).getType();\n+                  JSType otherNestedPropType = ot.getPropertyType(nestedProp);\n+                  thisNestedPropType.matchConstraint(otherNestedPropType);\n+                }\n+              }\n+            }\n+            // The nested object does not (yet) exist on this object.\n+            else {\n+              defineInferredProperty(\n+                  prop, registry.createNullableType(propType), null);\n+            }\n+          } else {\n+            if (!isPropertyTypeDeclared(prop)) {\n+              JSType typeToInfer = propType;\n+              if (!hasProperty(prop)) {\n+                typeToInfer =\n+                    getNativeType(JSTypeNative.VOID_TYPE).getLeastSupertype(propType);\n+              }\n+              defineInferredProperty(prop, typeToInfer, null);\n+            }\n+          }\n+        }\n+      }\n+\n+      // Handle the case where the constraint object is a function type.\n+      //\n+      // param constraintObj {function(...)}\n+      // function f(constraintObj) {}\n+      // f(function() {/* some code here */});\n+      //\n+      // We want to do two things in this branch:\n+      // 1. Build up the parameter and return types of this function,\n+      //    possibly using the main JSTypeRegistry to look up any parameter/\n+      //    return types.\n+      // 2. Infer properties on the 'this' variable of the function type.\n+      else {\n+        FunctionType functionType = (FunctionType) constraintObj;\n+        // Infer the properties of the 'this' variable.\n+        ObjectType thisObjType = functionType.getTypeOfThis();\n+        if (thisObjType != null) {\n+          for (String prop : thisObjType.getOwnPropertyNames()) {\n+            // Don't infer the types of properties that are declared.\n+            if (!isPropertyTypeDeclared(prop)) {\n+              JSType typeToInfer = thisObjType.getPropertyType(prop);\n+              if (!hasProperty(prop) && functionType.hasRestFormals()) {\n+                typeToInfer = typeToInfer.getCommonSupertype(getNativeType(\n+                    JSTypeNative.VOID_TYPE).getFunctionTypeWithRestFormals());\n+              }\n+              defineInferredProperty(prop, typeToInfer, null);\n+            }\n+          }\n+        }\n+        // Infer the parameter and return types.\n+        Iterator<Node> formalItr = functionType.getFormals().iterator();\n+        for (Node arg : arguments) {\n+          JSType typeToInfer = getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+          if (formalItr.hasNext()) {\n+            typeToInfer = formalItr.next().getJSType();\n+          } else if (functionType.hasRestFormals()) {\n+            typeToInfer = functionType.getRestFormalsType();\n+          }\n+          arg.getFirstChild().inferAnnotation(typeToInfer);\n+        }\n+        if (functionType.hasReturnValue()) {\n+          returnType.inferAnnotation(functionType.getReturnType());\n+        }\n+      }\n+    }\n \n     // Handle the case where the constraint object is a record type.\n     //",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}