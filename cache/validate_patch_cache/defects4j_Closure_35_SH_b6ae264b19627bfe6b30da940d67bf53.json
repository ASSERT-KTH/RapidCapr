{
    "patch": " if (constraintObj != null && constraintObj.isRecordType()) {\n       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n       if (objType != null) {\n         for (String prop : constraintObj.getOwnPropertyNames()) {\n           JSType propType = constraintObj.getPropertyType(prop);\n           if (!objType.isPropertyTypeDeclared(prop)) {\n             JSType typeToInfer = propType;\n             if (!objType.hasProperty(prop)) {\n               if (propType.isConstructor()) {\n                 // We don't usually consider constructors when inferring record types.\n                 // e.g., we don't want to infer `function(new:Date)`, because it does not add\n                 // any information to the inferred type of `x`.  Instead, we want to infer `{}`.\n                 // However, in the case of a constructor we still want to know the return type.\n                 FunctionType constructorFn = propType.toMaybeFunctionType();\n                 JSType returnType = constructorFn.getReturnType();\n                 typeToInfer = returnType;\n               } else {\n                 typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(\n                     propType.getContainedTypeOrDefault(getNativeType(UNKNOWN_TYPE)));\n               }\n             }\n             objType.defineInferredProperty(prop, typeToInfer, null);\n           }\n         }\n+       } else if (type.isObjectType()) {\n+         if (constraintObj.mayHaveStrayProperties()) {\n+           constraintObj = constraintObj.withoutStrayProperties();\n+           type = type.withoutPropertyRestrictions();\n+         }\n+         type.matchConstraint(constraintObj);\n       }\n     }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e10920..fb777f32 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1118,21 +1118,38 @@ class TypeInference\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+ if (constraintObj != null && constraintObj.isRecordType()) {\n+       ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n+       if (objType != null) {\n+         for (String prop : constraintObj.getOwnPropertyNames()) {\n+           JSType propType = constraintObj.getPropertyType(prop);\n+           if (!objType.isPropertyTypeDeclared(prop)) {\n+             JSType typeToInfer = propType;\n+             if (!objType.hasProperty(prop)) {\n+               if (propType.isConstructor()) {\n+                 // We don't usually consider constructors when inferring record types.\n+                 // e.g., we don't want to infer `function(new:Date)`, because it does not add\n+                 // any information to the inferred type of `x`.  Instead, we want to infer `{}`.\n+                 // However, in the case of a constructor we still want to know the return type.\n+                 FunctionType constructorFn = propType.toMaybeFunctionType();\n+                 JSType returnType = constructorFn.getReturnType();\n+                 typeToInfer = returnType;\n+               } else {\n+                 typeToInfer = getNativeType(VOID_TYPE).getLeastSupertype(\n+                     propType.getContainedTypeOrDefault(getNativeType(UNKNOWN_TYPE)));\n+               }\n+             }\n+             objType.defineInferredProperty(prop, typeToInfer, null);\n+           }\n+         }\n++       } else if (type.isObjectType()) {\n++         if (constraintObj.mayHaveStrayProperties()) {\n++           constraintObj = constraintObj.withoutStrayProperties();\n++           type = type.withoutPropertyRestrictions();\n++         }\n++         type.matchConstraint(constraintObj);\n+       }\n+     }\n     }\n   }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}