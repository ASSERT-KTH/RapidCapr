{
    "patch": "    Set<String> unreferenced = new HashSet<>();\n    Set<String> referenced = new HashSet<>();\n\n    NodeTraversal.traverse(compiler, function, new NodeTraversal.AbstractPostOrderCallback() {\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName()) {\n          String name = n.getString();\n          if (n.getParent().isParamList()) {\n            if (!referenced.contains(name)) {\n              unreferenced.add(name);\n            }\n          } else if (fnScope.isDeclared(name, true)) {\n            if (!(parent.isFunction() && n == parent.getFirstChild()) &&\n                !(parent.isCatch() && n == parent.getFirstChild().getSecondChild())) {\n              referenced.add(name);\n            }\n          }\n        }\n      }\n    });\n\n    // The parameters of object literal setters can not be removed.\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      referenced.addAll(unreferenced);\n      return;\n    }\n\n    // Remove all unreferenced parameters, but keep a minimum of fnScope.getParamsCount() args.\n    Node argList = getFunctionArgList(function);\n    Var[] varParams = fnScope.getParams();\n    int varParamsCount = varParams.length;\n\n    int paramsCount = NodeUtil.getArgCount(argList);\n    int minParamsCount = fnScope.getMinArguments();\n    int newParamsCount = Math.max(varParamsCount, Math.max(paramsCount - unreferenced.size(), minParamsCount));\n\n    if (newParamsCount < paramsCount) {\n      // The 2nd argument to splice is the deleteCount, which is: array.length - newParamsCount.\n      int deleteCount = paramsCount - newParamsCount;\n      argList.removeChildren(newParamsCount, paramsCount);\n      compiler.reportCodeChange();\n      fnScope.setMinArguments(newParamsCount);\n      fnScope.setMaxArguments(newParamsCount);\n      paramsCount = newParamsCount;\n    }\n\n    for (int i = 0; i < varParamsCount; i++) {\n      Node param = argList.getChildAtIndex(i);\n      Var var = varParams[i];\n      if (!referenced.contains(var.getName())) {\n        argList.removeChild(param);\n        compiler.reportCodeChange();\n        paramsCount--;\n      }\n    }\n\n    if (callSiteMutator != null && paramsCount + callSiteMutator.extraParamsCount() > newParamsCount) {\n      callSiteMutator.mutateCallSites(fnScope, referenced);\n      // We may mutate the call sites to add extra arguments, but we don't want to keep them in the AST.\n      while (paramsCount > newParamsCount) {\n        argList.removeChild(argList.getLastChild());\n        compiler.reportCodeChange();\n        paramsCount--;\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..510a4a7d 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,72 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Set<String> unreferenced = new HashSet<>();\n+    Set<String> referenced = new HashSet<>();\n+\n+    NodeTraversal.traverse(compiler, function, new NodeTraversal.AbstractPostOrderCallback() {\n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (n.isName()) {\n+          String name = n.getString();\n+          if (n.getParent().isParamList()) {\n+            if (!referenced.contains(name)) {\n+              unreferenced.add(name);\n+            }\n+          } else if (fnScope.isDeclared(name, true)) {\n+            if (!(parent.isFunction() && n == parent.getFirstChild()) &&\n+                !(parent.isCatch() && n == parent.getFirstChild().getSecondChild())) {\n+              referenced.add(name);\n+            }\n+          }\n+        }\n+      }\n+    });\n+\n+    // The parameters of object literal setters can not be removed.\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      referenced.addAll(unreferenced);\n+      return;\n+    }\n+\n+    // Remove all unreferenced parameters, but keep a minimum of fnScope.getParamsCount() args.\n+    Node argList = getFunctionArgList(function);\n+    Var[] varParams = fnScope.getParams();\n+    int varParamsCount = varParams.length;\n+\n+    int paramsCount = NodeUtil.getArgCount(argList);\n+    int minParamsCount = fnScope.getMinArguments();\n+    int newParamsCount = Math.max(varParamsCount, Math.max(paramsCount - unreferenced.size(), minParamsCount));\n+\n+    if (newParamsCount < paramsCount) {\n+      // The 2nd argument to splice is the deleteCount, which is: array.length - newParamsCount.\n+      int deleteCount = paramsCount - newParamsCount;\n+      argList.removeChildren(newParamsCount, paramsCount);\n+      compiler.reportCodeChange();\n+      fnScope.setMinArguments(newParamsCount);\n+      fnScope.setMaxArguments(newParamsCount);\n+      paramsCount = newParamsCount;\n+    }\n+\n+    for (int i = 0; i < varParamsCount; i++) {\n+      Node param = argList.getChildAtIndex(i);\n+      Var var = varParams[i];\n+      if (!referenced.contains(var.getName())) {\n+        argList.removeChild(param);\n+        compiler.reportCodeChange();\n+        paramsCount--;\n+      }\n+    }\n+\n+    if (callSiteMutator != null && paramsCount + callSiteMutator.extraParamsCount() > newParamsCount) {\n+      callSiteMutator.mutateCallSites(fnScope, referenced);\n+      // We may mutate the call sites to add extra arguments, but we don't want to keep them in the AST.\n+      while (paramsCount > newParamsCount) {\n+        argList.removeChild(argList.getLastChild());\n+        compiler.reportCodeChange();\n+        paramsCount--;\n+      }\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}