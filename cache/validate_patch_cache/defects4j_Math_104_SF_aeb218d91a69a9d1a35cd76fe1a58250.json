{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.MathUtils;\n\npublic class MyMath {\n    \n    public static double regularizedGamma(double a, double x) {\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            return Double.NaN;\n        }\n        if (x == 0.0) {\n            return 0.0;\n        }\n        if (x >= a + 1.0) {\n            double b = a + x + 1.0;\n            double c = 0.0;\n            double pkm2 = 1.0;\n            double qkm2 = x;\n            double pkm1 = x + 1.0;\n            double qkm1 = b * x;\n            double ans = pkm1 / qkm1;\n            double error = 1.0 / qkm1;\n            do {\n                c += 1.0;\n                double a1 = c * (a - c);\n                double b1 = c * ((b - c) + 1.0);\n                double pkm2Temp = pkm1;\n                pkm1 = pkm1 * b1 + qkm1 * a1;\n                qkm1 = qkm1 * b1 + pkm2 * a1;\n                pkm2 = pkm2Temp;\n                a1 = x + c;\n                b1 = b + c * (-2.0 + b);\n                ans = pkm1 / qkm1;\n                error = Math.abs((pkm1 / qkm1) * error - 1.0);\n            } while (error > MathUtils.EPSILON && c < MathUtils.MAX_ITERATIONS);\n            return ans;\n        } else {\n            double b = x + 1.0 - a;\n            double c = 1.0 / Gamma.EULER;\n            double d = 1.0 / b;\n            double h = d;\n            for (int i = 1; i < MathUtils.MAX_ITERATIONS; i++) {\n                double an = -i * (i - a);\n                b += 2.0;\n                d = an * d + b;\n                if (Math.abs(d) < MathUtils.MIN_DOUBLE) {\n                    d = MathUtils.MIN_DOUBLE;\n                }\n                c = b + an / c;\n                if (Math.abs(c) < MathUtils.MIN_DOUBLE) {\n                    c = MathUtils.MIN_DOUBLE;\n                }\n                d = 1.0 / d;\n                double del = d * c;\n                h *= del;\n                if (Math.abs(del - 1.0) < MathUtils.EPSILON) {\n                    return h * Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a));\n                }\n            }\n            return Double.NaN;\n        }\n    }\n\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..6f66f2113 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,69 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.MathUtils;\n+\n+public class MyMath {\n+    \n+    public static double regularizedGamma(double a, double x) {\n+        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n+            return Double.NaN;\n+        }\n+        if (x == 0.0) {\n+            return 0.0;\n+        }\n+        if (x >= a + 1.0) {\n+            double b = a + x + 1.0;\n+            double c = 0.0;\n+            double pkm2 = 1.0;\n+            double qkm2 = x;\n+            double pkm1 = x + 1.0;\n+            double qkm1 = b * x;\n+            double ans = pkm1 / qkm1;\n+            double error = 1.0 / qkm1;\n+            do {\n+                c += 1.0;\n+                double a1 = c * (a - c);\n+                double b1 = c * ((b - c) + 1.0);\n+                double pkm2Temp = pkm1;\n+                pkm1 = pkm1 * b1 + qkm1 * a1;\n+                qkm1 = qkm1 * b1 + pkm2 * a1;\n+                pkm2 = pkm2Temp;\n+                a1 = x + c;\n+                b1 = b + c * (-2.0 + b);\n+                ans = pkm1 / qkm1;\n+                error = Math.abs((pkm1 / qkm1) * error - 1.0);\n+            } while (error > MathUtils.EPSILON && c < MathUtils.MAX_ITERATIONS);\n+            return ans;\n+        } else {\n+            double b = x + 1.0 - a;\n+            double c = 1.0 / Gamma.EULER;\n+            double d = 1.0 / b;\n+            double h = d;\n+            for (int i = 1; i < MathUtils.MAX_ITERATIONS; i++) {\n+                double an = -i * (i - a);\n+                b += 2.0;\n+                d = an * d + b;\n+                if (Math.abs(d) < MathUtils.MIN_DOUBLE) {\n+                    d = MathUtils.MIN_DOUBLE;\n+                }\n+                c = b + an / c;\n+                if (Math.abs(c) < MathUtils.MIN_DOUBLE) {\n+                    c = MathUtils.MIN_DOUBLE;\n+                }\n+                d = 1.0 / d;\n+                double del = d * c;\n+                h *= del;\n+                if (Math.abs(del - 1.0) < MathUtils.EPSILON) {\n+                    return h * Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a));\n+                }\n+            }\n+            return Double.NaN;\n+        }\n+    }\n+\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}