{
    "patch": "private void checkDuplicateDeclaration(NodeTraversal t, Node nameNode, Var var) {\n  String name = nameNode.getQualifiedName();\n  Scope.Var existingVar = t.getScope().getVar(name);\n  if (existingVar != null) {\n    if (existingVar == var) {\n      // it's the same variable in the same scope, so it's okay\n      return;\n    }\n    if (existingVar.getScope().isBlockScope() ||\n        var.getScope().isBlockScope()) {\n      // Redeclarations between function and block scopes are fine.\n      if (!existingVar.getScope().isFunctionBlockScope() ||\n          !var.getScope().isFunctionBlockScope()) {\n        String desc = existingVar.isParam()\n            ? \"duplicate parameter\"\n            : \"duplicate declaration\";\n        JSError error = JSError.make(\n            nameNode,\n            DUPLICATE_VARS,\n            desc + \", original definition at \" +\n                existingVar.getNode().getSourceFileName() + \":\" +\n                existingVar.getNode().getLineno());\n        t.getCompiler().report(error);\n      }\n    } else if (!var.isGlobal() && !existingVar.isLocal()) {\n      t.getCompiler().report(\n          JSError.make(nameNode, VAR_MULTIPLY_DECLARED_ERROR, name));\n    } else if (existingVar.isExtern()) {\n      if (!var.isExtern()) {\n        // Redeclarations of externs (like window or document) are allowed\n        // here as long as the new declaration is also an extern.\n        t.getCompiler().report(JSError.make(\n            nameNode,\n            VAR_MULTIPLY_DECLARED_ERROR, name));\n      }\n    } else if (!var.isExtern()) {\n      t.getCompiler().report(JSError.make(\n          nameNode,\n          VAR_MULTIPLY_DECLARED_ERROR, name));\n    }\n  } else if (t.getScope().isDeclared(name, false)) {\n    // ignoring if already declared in the same scope\n    if (t.getScope().getVar(name).getNode() != nameNode.getParent()) {\n      t.getCompiler().report(\n          JSError.make(nameNode, VAR_DECLARED_IN_UNNAMED_FUNCTION));\n    }\n  } else if (var.getNameNode() != null && !var.isExtern()) {\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(nameNode);\n    if (info != null && info.isConstant() && var.hasNameNode()) {\n      // If a constant is declared and defined in the same statement, don't\n      // treat it as a duplicate declaration.\n      return;\n    }\n\n    /*\n     *  The following code is to detect invalid redeclaration in Rhino.\n     *   var scope = new Object();\n     *   with (scope) {\n     *     var a = 1; // assign to scope\n     *     var a; // SyntaxError in Rhino, legal in ECMA\n     *   }\n     *  Rhino declares 'a' in scope, which makes the second declaration\n     *  illegal, and the parser chokes. To accommodate Rhino, we delay\n     *  the reporting of the duplicate declaration to the name declaration.\n     */\n    var.setNameNode(nameNode);\n\n    // a little white lie, to make it look like we declared it here\n    Scope s = t.getScope();\n    s.declare(name, nameNode, var.input);\n    s.getVar(name).setOriginalName(nameNode.getString());\n\n    if (var.getParentNode().isCatch()) {\n      s.setCatchName(name);\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex ae8a3200..2b3f4991 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1300,7 +1300,7 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * @param n The node being visited.\n    * @param parent The parent of <code>n</code>\n    */\n-  private void visitGetProp(NodeTraversal t, Node n, Node parent) {\n+\n     // obj.prop or obj.method()\n     // Lots of types can appear on the left, a call to a void function can\n     // never be on the left. getPropertyType will decide what is acceptable",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}