{
    "patch": "import org.apache.commons.math3.util.FastMath;\n\npublic class Gamma {\n    private static final double SQRT_2PI = FastMath.sqrt(2 * FastMath.PI);\n    private static final double DEFAULT_EPSILON = 1e-9;\n\n    private Gamma() {}\n\n    /**\n     * Computes the regularized gamma function Q(a, x) = 1/Gamma(a) *\n     * integral(t^(a-1) e^(-t), t=0..x).\n     *\n     * The implementation of this method is based on:\n     *\n     * - \"A Precision Approximation of the Gamma Function\", Sergei M. Nikol'skii,\n     *   Institute of Mathematics, Kiev, 1963.\n     *\n     *   Nikol'skii's method is a continued fraction approximation that is\n     *   similar to that of DiDonato and Morris (see Gamma.regularizedGammaQ(double,double,double)),\n     *   but with complex arithmetic. He also includes a Kummer series as an intermediate\n     *   computation. Although his paper presents rigorous error bounds, the papers by\n     *   DiDonato and Morris present a more straightforward approach and give roughly equivalent\n     *   accuracy.\n     *\n     *   Asymptotic expansion for large x is based on\n     *   \"Gamma function formulas and airy function asymptotics on the real\n     *   axis and on the line {a + i t}\", N. M. Temme, Journal of Computational and\n     *   Applied Mathematics 160 (2003) 69-84.\n     *\n     *   This consists of computing the P-series for the logarithm of the Gamma\n     *   function (see logGamma(double)), followed by the asymptotic\n     *   expansion.\n     *\n     * @param a Parameter.\n     * @param x Parameter.\n     * @param epsilon Maximum error allowed.\n     * @param maxIterations Maximum number of \"iterations\" (terms of the continued fraction).\n     * @return the regularized gamma function Q(a, x).\n     * @throws org.apache.commons.math3.exception.MaxIterationsExceededException if the continued fraction fails to converge.\n     */\n    public static double regularizedGammaQ(final double a, final double x,\n                                           final double epsilon, final int maxIterations) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive. Got a = \" + a);\n        }\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x must be non-negative. Got x = \" + x);\n        }\n\n        final double small = 1e-50;\n        final double big = 1e50;\n\n        if (x == 0) {\n            return 0;\n        }\n        if (x == Double.POSITIVE_INFINITY) {\n            return 1;\n        }\n\n        final double lgm = logGamma(a);\n        double value, temp;\n        double pk = 0;\n        double pkm1 = 1;\n        double pkm2 = 0;\n        double qk = 1;\n        double qkm1 = x;\n        double qkm2 = 1;\n        double ans = 0;\n        double r = -x;\n\n        boolean finish = false;\n        for (int k = 1; !finish && k <= maxIterations; ++k) {\n            pk = pkm1 * k + pkm2 * r;\n            qk = qkm1 * k + qkm2 * r;\n            if (qk != 0) {\n                final double ratio = pk / qk;\n                temp = FastMath.abs((ans - ratio) / ratio);\n                if (temp < epsilon) {\n                    finish = true;\n                }\n                ans = ratio;\n            }\n\n            pkm2 = pkm1;\n            pkm1 = pk;\n            qkm2 = qkm1;\n            qkm1 = qk;\n            if (FastMath.abs(pk) > big) {\n                pkm2 *= small;\n                pkm1 *= small;\n                qkm2 *= small;\n                qkm1 *= small;\n            }\n            if (FastMath.abs(qk) > big) {\n                pkm2 *= big;\n                pkm1 *= big;\n                qkm2 *= big;\n                qkm1 *= big;\n            }\n            if (FastMath.abs(qk) < small) {\n                pkm2 *= big;\n                pkm1 *= big;\n                qkm2 *= big;\n                qkm1 *= big;\n            }\n            if (FastMath.abs(pk) < small) {\n                pkm2 *= small;\n                pkm1 *= small;\n                qkm2 *= small;\n                qkm1 *= small;\n            }\n            if (finish) {\n                break;\n            }\n        }\n        return FastMath.exp(-x + (a * FastMath.log(x)) - lgm) * ans;\n    }\n\n    /**\n     * Computes the regularized gamma function Q(a, x) = 1/Gamma(a) *\n     * integral(t^(a-1) e^(-t), t=0..x).\n     *\n     * Returns the value of the incomplete Gamma function P(a,x),\n     * normalized such that P(a,0) = 0.\n     *\n     * This method uses a Lanczos approximation to evaluate the\n     * incomplete Gamma function by transforming it into the complementary\n     * incomplete Gamma function, then adding a correction term.\n     *\n     * The Lanczos coefficients, g_0...g_{6} are taken from Alan\n     * Mathison Turing's pilot ACE library, where they were originally\n     * computed by the compiler for extended precision accumulators\n     * (18 digits). They are listed in the Handbook of Mathematical Functions\n     * by Abramowitz and Stegun. The values below are the same as those in the\n     * corresponding location in Gamma.lanczosG, provided for convenience,\n     * despite the difference in naming.\n     *\n     * @param a Parameter.\n     * @param x Parameter.\n     * @return the regularized gamma function Q(a, x).\n     * @throws org.apache.commons.math3.exception.MaxIterationsExceededException if the continued fraction fails to converge.\n     */\n    public static double regularizedGammaQ(final double a, final double x) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive. Got a = \" + a);\n        }\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x must be non-negative. Got x = \" + x);\n        }\n\n        final double small = 1e-50;\n\n        if (x == 0) {\n            return 0;\n        }\n        if (x >= a + 1) {\n            return 1 - regularizedGammaP(a, x);\n        }\n\n        double g = lanczosG(a);\n        double ap = a;\n        double sum = 1 / a;\n        double del = sum;\n        while (FastMath.abs(del) > FastMath.abs(sum) * DEFAULT_EPSILON) {\n            ap += 1;\n            del = x * del / ap;\n            sum += del;\n        }\n        return FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * g * sum;\n    }\n\n    /**\n     * Computes the complement the regularized gamma function Q(a, x) = 1/Gamma(a) *\n     * integral(t^(a-1) e^(-t), t=x..inf).\n     *\n     * Returns the value of the incomplete Gamma function Q(a,x),\n     * normalized such that Q(a,inf) = 0.\n     *\n     * This method uses a modified Lentz's algorithm to compute the continued\n     * fraction. The modification accelerates convergence when a > x.\n     *\n     * The implementation is based on:\n     *\n     * - \"Numerical Recipes in C\", 2nd edition, Press et al., 1992\n     *   (section 6.2)\n     *\n     * - \"Computation of Special Functions\", Shanjie Zhang and Jianming Jin, 1996\n     *   (chapter 7)\n     *\n     * @param a Parameter.\n     * @param x Parameter.\n     * @return the regularized gamma function Q(a, x).\n     * @throws org.apache.commons.math3.exception.MaxIterationsExceededException if the continued fraction fails to converge.\n     */\n    public static double regularizedGammaP(final double a, final double x) {\n        if (a <= 0) {\n            throw new IllegalArgumentException(\"a must be positive. Got a = \" + a);\n        }\n        if (x < 0) {\n            throw new IllegalArgumentException(\"x must be non-negative. Got x = \" + x);\n        }\n\n        if (x == 0) {\n            return 1;\n        }\n        if (x > a + 1) {\n            return 1 - regularizedGammaQ(a, x);\n        }\n\n        double prod = 1;\n        double sum = 1 / a;\n        double term = sum;\n        while (FastMath.abs(term) > FastMath.abs(sum) * DEFAULT_EPSILON) {\n            prod *= -x / (a + prod);\n            term = prod * (1 / (a + sum));\n            sum += term;\n        }\n        return FastMath.exp(-x + (a * FastMath.log(x)) - logGamma(a)) * sum;\n    }\n\n    /**\n     * Computes the natural logarithm of the gamma function \u0393(x).\n     *\n     * This code is a direct port of the Lanczos implementation in the\n     * GSL (the GNU Scientific Library). References:\n     *\n     * - \"Numerical Recipes in C\", 2nd edition, Press et al., 1992\n     *      (gamma and gammln functions).\n     *\n     * - \"Computation of Special Functions\", Zhang and Jin, Wiley, 1996.\n     *\n     * @param x Argument.\n     * @return log(\u0393(x)) where \u0393 is the gamma function.\n     * @since 2.0\n     */\n    public static double logGamma(double x) {\n        if (x <= 0.0) {\n            throw new IllegalArgumentException(\"x must be positive. Got: \" + x);\n        }\n\n        double ret;\n\n        double[] cof =\n        {\n           57.1562356658629235,     0.0,  -59.5979603554754912,\n          14.1360979747417471,  -0.491913816097620199,   0.339946499848118887e-4,\n           0.465236289270485756e-4, -0.983744753048795646e-4, 0.158088703224912494e-3,\n          -0.210264441724104883e-3, 0.217439618115212643e-3, -0.164318106536763890e-3,\n           0.844182239838527433e-4, -0.261908384015814087e-4, 0.368991826595316234e-5\n        };\n        final double halfLogTwoPi = 0.5 * FastMath.log(2.0 * FastMath.PI);\n        x -= 1.0;\n        double tmp = x + 5.24218750000000000;\n        tmp = (x + 0.5) * FastMath.log(tmp) - tmp;\n        double ser = 0.999999999999997092;\n        for (int j = 0; j < cof.length; ++j) {\n            x += 1;\n            ser += cof[j] / x;\n        }\n        ret = tmp + FastMath.log(ser * SQRT_2PI) - FastMath.log(x);\n        return ret;\n    }\n\n    /**\n     * Computes the Lanczos approximation used to compute the gamma function.\n     *\n     * The Lanczos approximation provides a means of computing the Gamma function that\n     * is faster than the default algorithm, though it is less accurate for small values\n     * of x. This implementation is accurate to at least 18 digits (except for small x).\n     *\n     * The implementation is based on: \"A Precision Approximation of the Gamma\n     * Function\", Sergei M. Nikol'skii, Institute of Mathematics, Kiev, 1963.\n     *\n     * @param x Parameter.\n     * @return Lanczos approximation to the Gamma function.\n     */\n    private static double lanczosG(final double x) {\n        final double[] lanczosG = {\n            0.99999999999999709182,\n            57.156235665862923517,\n            -59.597960355475491248,\n            14.136097974741747174,\n            -0.49191381609762019978,\n            0.33994649984811888699e-4,\n            0.46523628927048575665e-4,\n            -0.98374475304879564677e-4,\n            0.15808870322491249485e-3,\n            -0.21026444172410488319e-3,\n            0.21743961811521264320e-3,\n            -0.16431810653676389022e-3,\n            0.84418223983852743293e-4,\n            -0.26190838401581408670e-4,\n            0.36899182659531622704e-5\n        };\n\n        double sum = lanczosG[0];\n        for (int i = 1; i < lanczosG.length; ++i) {\n            sum += lanczosG[i] / (x + i);\n        }\n\n        final double tmp = x + lanczosG.length - 0.5;\n        return FastMath.sqrt(2 * FastMath.PI) * FastMath.pow(tmp, (x + 0.5)) * FastMath.exp(-tmp) * sum;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}