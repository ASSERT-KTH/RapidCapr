{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    if (Math.abs(offsetLocal - offsetAdjusted) == 1) {\n        // One hour DST boundary gap\n\n        // Estimate boundaries based on time zone with larger offset\n        int maxOffset = offsetLocal > offsetAdjusted ? offsetLocal : offsetAdjusted;\n        int minOffset = offsetLocal < offsetAdjusted ? offsetLocal : offsetAdjusted;\n\n        // Find transitions for maxOffset\n        long nextTransition = nextTransition(instantAdjusted);\n        long prevTransition = previousTransition(instantAdjusted);\n\n        // Adjust transitions for minOffset\n        long nextTransitionMin = nextTransition - (maxOffset - minOffset) * DateTimeConstants.MILLIS_PER_HOUR;\n        long prevTransitionMin = previousTransition(nextTransitionMin);\n\n        // Check if instant is inside gap\n        if (instantLocal >= prevTransitionMin && instantLocal < nextTransitionMin) {\n            return maxOffset;\n        }\n    }\n    else {\n        // Multiple hour DST boundary gap\n\n        // Find prior adjustment for Local Time's Minute of transition\n        int priorLocalMinuteOffset = getOffset(previousTransition(instantAdjusted));\n\n        // Determine min/max range of valid Offsets for the Local Time\n        boolean offsetRangeStartFound = false;\n        int minOffset = 0;\n        int maxOffset = 0;\n        for (int candidateHourOffset = -12; candidateHourOffset <= 14; candidateHourOffset++) {\n            int candidateMinuteOffset = getOffset(instantLocal - (candidateHourOffset * DateTimeConstants.MILLIS_PER_HOUR) - 1);\n\n            if (!offsetRangeStartFound && candidateMinuteOffset == priorLocalMinuteOffset) {\n                minOffset = candidateHourOffset;\n                offsetRangeStartFound = true;\n            }\n            if (offsetRangeStartFound && candidateMinuteOffset == priorLocalMinuteOffset) {\n                maxOffset = candidateHourOffset;\n            }\n            if (offsetRangeStartFound && candidateMinuteOffset != priorLocalMinuteOffset) {\n                break;\n            }\n        }\n\n        // Adjust for boundary direction (spring forward or fall back)\n        boolean movingForward = offsetAdjusted > offsetLocal;\n        if (movingForward) {\n            return maxOffset;\n        }\n        else {\n            return minOffset;\n        }\n    }\n}\nreturn offsetAdjusted;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..2399afc0 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,63 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    if (Math.abs(offsetLocal - offsetAdjusted) == 1) {\n+        // One hour DST boundary gap\n+\n+        // Estimate boundaries based on time zone with larger offset\n+        int maxOffset = offsetLocal > offsetAdjusted ? offsetLocal : offsetAdjusted;\n+        int minOffset = offsetLocal < offsetAdjusted ? offsetLocal : offsetAdjusted;\n+\n+        // Find transitions for maxOffset\n+        long nextTransition = nextTransition(instantAdjusted);\n+        long prevTransition = previousTransition(instantAdjusted);\n+\n+        // Adjust transitions for minOffset\n+        long nextTransitionMin = nextTransition - (maxOffset - minOffset) * DateTimeConstants.MILLIS_PER_HOUR;\n+        long prevTransitionMin = previousTransition(nextTransitionMin);\n+\n+        // Check if instant is inside gap\n+        if (instantLocal >= prevTransitionMin && instantLocal < nextTransitionMin) {\n+            return maxOffset;\n+        }\n+    }\n+    else {\n+        // Multiple hour DST boundary gap\n+\n+        // Find prior adjustment for Local Time's Minute of transition\n+        int priorLocalMinuteOffset = getOffset(previousTransition(instantAdjusted));\n+\n+        // Determine min/max range of valid Offsets for the Local Time\n+        boolean offsetRangeStartFound = false;\n+        int minOffset = 0;\n+        int maxOffset = 0;\n+        for (int candidateHourOffset = -12; candidateHourOffset <= 14; candidateHourOffset++) {\n+            int candidateMinuteOffset = getOffset(instantLocal - (candidateHourOffset * DateTimeConstants.MILLIS_PER_HOUR) - 1);\n+\n+            if (!offsetRangeStartFound && candidateMinuteOffset == priorLocalMinuteOffset) {\n+                minOffset = candidateHourOffset;\n+                offsetRangeStartFound = true;\n+            }\n+            if (offsetRangeStartFound && candidateMinuteOffset == priorLocalMinuteOffset) {\n+                maxOffset = candidateHourOffset;\n+            }\n+            if (offsetRangeStartFound && candidateMinuteOffset != priorLocalMinuteOffset) {\n+                break;\n+            }\n+        }\n+\n+        // Adjust for boundary direction (spring forward or fall back)\n+        boolean movingForward = offsetAdjusted > offsetLocal;\n+        if (movingForward) {\n+            return maxOffset;\n+        }\n+        else {\n+            return minOffset;\n+        }\n+    }\n+}\n+return offsetAdjusted;\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.AssertionFailedError: expected:<false> but was:<true>",
    "test_result": "FAIL"
}