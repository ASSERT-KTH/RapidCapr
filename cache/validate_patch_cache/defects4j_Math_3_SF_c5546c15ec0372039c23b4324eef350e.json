{
    "patch": "    public static double linearCombination(final double[] a, final double[] b)\n            throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n\n        // Revert to scalar multiplication when arrays are too small or NaN\n        if (len < 2 || Double.isNaN(a[0]) || Double.isNaN(b[0])) {\n            double dot = 0d;\n            for (int i = 0; i < len; i++) {\n                dot += a[i] * b[i];\n            }\n            return dot;\n        }\n\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n\n        final double a0 = a[0];\n        final double b0 = b[0];\n        prodHigh[0] = a0 * b0;\n        final double cHigh = SPLIT_FACTOR * a0;\n        final double aHigh = cHigh - (cHigh - a0);\n        final double aLow = a0 - aHigh;\n        final double dHigh = SPLIT_FACTOR * b0;\n        final double bHigh = dHigh - (dHigh - b0);\n        final double bLow = b0 - bHigh;\n        final double prodLow = aLow * bLow - (((prodHigh[0] -\n                                               aHigh * bHigh) -\n                                              aLow * bHigh) -\n                                             aHigh * bLow);\n        prodLowSum += prodLow;\n\n        double sHighPrev = prodHigh[0];\n        double sPrime = 0d;\n        double sLowSum = 0d;\n\n        for (int i = 1; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n\n            final double prodHighCur = prodHigh[i - 1];\n            final double prodHighNext = prodHigh[i];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n            sHighPrev = sHighCur;\n        }\n\n        double result = sHighPrev + (prodLowSum + sLowSum);\n\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n\n        return result;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..e721b1c93 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -812,18 +812,44 @@ public class MathArrays {\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n     public static double linearCombination(final double[] a, final double[] b)\n-        throws DimensionMismatchException {\n+            throws DimensionMismatchException {\n         final int len = a.length;\n         if (len != b.length) {\n             throw new DimensionMismatchException(len, b.length);\n         }\n \n-            // Revert to scalar multiplication.\n+        // Revert to scalar multiplication when arrays are too small or NaN\n+        if (len < 2 || Double.isNaN(a[0]) || Double.isNaN(b[0])) {\n+            double dot = 0d;\n+            for (int i = 0; i < len; i++) {\n+                dot += a[i] * b[i];\n+            }\n+            return dot;\n+        }\n \n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n \n-        for (int i = 0; i < len; i++) {\n+        final double a0 = a[0];\n+        final double b0 = b[0];\n+        prodHigh[0] = a0 * b0;\n+        final double cHigh = SPLIT_FACTOR * a0;\n+        final double aHigh = cHigh - (cHigh - a0);\n+        final double aLow = a0 - aHigh;\n+        final double dHigh = SPLIT_FACTOR * b0;\n+        final double bHigh = dHigh - (dHigh - b0);\n+        final double bLow = b0 - bHigh;\n+        final double prodLow = aLow * bLow - (((prodHigh[0] -\n+                                               aHigh * bHigh) -\n+                                              aLow * bHigh) -\n+                                             aHigh * bLow);\n+        prodLowSum += prodLow;\n+\n+        double sHighPrev = prodHigh[0];\n+        double sPrime = 0d;\n+        double sLowSum = 0d;\n+\n+        for (int i = 1; i < len; i++) {\n             final double ai = a[i];\n             final double ca = SPLIT_FACTOR * ai;\n             final double aHigh = ca - (ca - ai);\n@@ -839,21 +865,12 @@ public class MathArrays {\n                                                    aLow * bHigh) -\n                                                   aHigh * bLow);\n             prodLowSum += prodLow;\n-        }\n-\n-\n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n \n-        final int lenMinusOne = len - 1;\n-        for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n+            final double prodHighCur = prodHigh[i - 1];\n+            final double prodHighNext = prodHigh[i];\n             final double sHighCur = sHighPrev + prodHighNext;\n             sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n+            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n             sHighPrev = sHighCur;\n         }\n ",
    "result_reason": "error: variable aHigh is already defined in method linearCombination(double[],double[])",
    "test_result": "ERROR"
}