{
    "patch": "    int arrayLength = 0;\n    if (left.isArrayLit()) {\n      arrayLength = left.getChildCount();\n    } else if (NodeUtil.isNameOrGetProp(left)) {\n      String qualifiedName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(left));\n      Var v = getScope().getVar(qualifiedName);\n      if (v != null && v.isNumber() && v.getNameNode().getFirstChild().isNumber()) {\n        arrayLength = (int) v.getNameNode().getFirstChild().getDouble();\n      }\n    }\n\n    if (arrayLength <= intIndex) {\n      error(INDEX_OUT_OF_BOUNDS_ERROR, right);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 0b2636f4..93bb0ece 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1280,6 +1280,19 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     // If GETPROP/GETELEM is used as assignment target the array literal is\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n+    int arrayLength = 0;\n+    if (left.isArrayLit()) {\n+      arrayLength = left.getChildCount();\n+    } else if (NodeUtil.isNameOrGetProp(left)) {\n+      String qualifiedName = NodeUtil.getBestLValueName(NodeUtil.getBestLValue(left));\n+      Var v = getScope().getVar(qualifiedName);\n+      if (v != null && v.isNumber() && v.getNameNode().getFirstChild().isNumber()) {\n+        arrayLength = (int) v.getNameNode().getFirstChild().getDouble();\n+      }\n+    }\n+\n+    if (arrayLength <= intIndex) {\n+      error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n \n     if (right.getType() != Token.NUMBER) {\n       // Sometimes people like to use complex expressions to index into",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}