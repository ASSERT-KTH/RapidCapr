{
    "patch": "private boolean isFoldableExpressBlock(Node n) {\n  if (n.getType() == Token.BLOCK) {\n    if (n.hasOneChild()) {\n      Node maybeExpr = n.getFirstChild();\n      if (NodeUtil.isExpressionNode(maybeExpr)) {\n        return isFoldableExpression(maybeExpr, false);\n      } else if (maybeExpr.getType() == Token.EXPR_RESULT) {\n        return isFoldableExpression(maybeExpr.getFirstChild(), true);\n      }\n    }\n  }\n  return false;\n}\n\nprivate boolean isFoldableExpression(Node expr, boolean isExprResult) {\n  // Check if the expression is a function\n  if (expr.getType() == Token.FUNCTION) {\n    // Handle cases where the function has a return statement\n    Node functionBody = expr.getLastChild();\n    boolean hasReturnStatement = functionBody.getLastChild() != null\n        && functionBody.getLastChild().getType() == Token.RETURN;\n    return !hasReturnStatement;\n  }\n\n  // Handle other types of expressions\n  switch (expr.getType()) {\n    case Token.HOOK:\n      // Handle conditional expressions (ternary operator)\n      Node trueExpr = isFoldableExpression(expr.getChildAtIndex(1), false) ? expr.getChildAtIndex(1)\n          : expr.getChildAtIndex(2);\n      return isFoldableExpression(trueExpr, false);\n\n    case Token.NOT:\n      // Handle negation of expression\n      Node child = expr.getFirstChild();\n      if (child.getType() == Token.NAME) {\n        String name = child.getString();\n        return !isExprResult || !name.startsWith(\"event\");\n      }\n      break;\n\n    case Token.NAME:\n      // Handle name expressions\n      String name = expr.getString();\n      return !isExprResult || !name.startsWith(\"on\");\n\n    case Token.GETPROP:\n      // Handle property access expressions\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      if (left.getType() == Token.NAME && right.getType() == Token.STRING) {\n        String propName = right.getString();\n        if (propName.equals(\"returnValue\")) {\n          // Handle the special case of returnValue property access in an event handler\n          Node grandParent = expr.getParent().getParent();\n          if (grandParent.getType() == Token.CALL) {\n            Node callee = grandParent.getFirstChild();\n            Node eventHandler = callee.getFirstChild();\n            if (eventHandler.getLastChild().getString().equals(\"handler\")) {\n              String nameExpr = eventHandler.getFirstChild().getString();\n              return !isExprResult || !nameExpr.startsWith(\"on\");\n            }\n          }\n        }\n      }\n      break;\n\n    case Token.AND:\n    case Token.OR:\n      // Handle logical and expressions\n      Node leftOp = expr.getFirstChild();\n      Node rightOp = leftOp.getNext();\n      return isFoldableExpression(leftOp, false) && isFoldableExpression(rightOp, false);\n\n    case Token.EQ:\n    case Token.NE:\n      // Handle equality/inequality expressions\n      Node leftEq = expr.getFirstChild();\n      Node rightEq = leftEq.getNext();\n      if (isExprResult && leftEq.getType() == Token.THIS \n          && rightEq.getType() == Token.GETPROP\n          && rightEq.getFirstChild().getString().equals(\"returnValue\")) {\n        return false;\n      }\n      if (isExprResult && rightEq.getType() == Token.THIS \n          && leftEq.getType() == Token.GETPROP\n          && leftEq.getFirstChild().getString().equals(\"returnValue\")) {\n        return false;\n      }\n      return isFoldableExpression(leftEq, false) && isFoldableExpression(rightEq, false);\n\n    case Token.INC:\n    case Token.DEC:\n      // Handle increment/decrement expressions\n      return false;\n\n    case Token.ASSIGN:\n      // Handle assignment expressions\n      if (!isExprResult) {\n        return false;\n      }\n      Node leftAssign = expr.getFirstChild();\n      Node rightAssign = leftAssign.getNext();\n      if (leftAssign.getType() != Token.NAME) {\n        return false;\n      }\n      String nameAssign = leftAssign.getString();\n      return !(nameAssign.startsWith(\"on\") || nameAssign.startsWith(\"goog\"));\n\n    case Token.NUMBER:\n    case Token.STRING:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n      // Handle literals\n      return true;\n\n    default:\n      // Handle all other expressions\n      break;\n  }\n\n  return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..926fa855 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,27 +516,131 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+private boolean isFoldableExpressBlock(Node n) {\n+  if (n.getType() == Token.BLOCK) {\n+    if (n.hasOneChild()) {\n+      Node maybeExpr = n.getFirstChild();\n+      if (NodeUtil.isExpressionNode(maybeExpr)) {\n+        return isFoldableExpression(maybeExpr, false);\n+      } else if (maybeExpr.getType() == Token.EXPR_RESULT) {\n+        return isFoldableExpression(maybeExpr.getFirstChild(), true);\n       }\n     }\n+  }\n+  return false;\n+}\n \n-    return false;\n+private boolean isFoldableExpression(Node expr, boolean isExprResult) {\n+  // Check if the expression is a function\n+  if (expr.getType() == Token.FUNCTION) {\n+    // Handle cases where the function has a return statement\n+    Node functionBody = expr.getLastChild();\n+    boolean hasReturnStatement = functionBody.getLastChild() != null\n+        && functionBody.getLastChild().getType() == Token.RETURN;\n+    return !hasReturnStatement;\n+  }\n+\n+  // Handle other types of expressions\n+  switch (expr.getType()) {\n+    case Token.HOOK:\n+      // Handle conditional expressions (ternary operator)\n+      Node trueExpr = isFoldableExpression(expr.getChildAtIndex(1), false) ? expr.getChildAtIndex(1)\n+          : expr.getChildAtIndex(2);\n+      return isFoldableExpression(trueExpr, false);\n+\n+    case Token.NOT:\n+      // Handle negation of expression\n+      Node child = expr.getFirstChild();\n+      if (child.getType() == Token.NAME) {\n+        String name = child.getString();\n+        return !isExprResult || !name.startsWith(\"event\");\n+      }\n+      break;\n+\n+    case Token.NAME:\n+      // Handle name expressions\n+      String name = expr.getString();\n+      return !isExprResult || !name.startsWith(\"on\");\n+\n+    case Token.GETPROP:\n+      // Handle property access expressions\n+      Node left = expr.getFirstChild();\n+      Node right = left.getNext();\n+      if (left.getType() == Token.NAME && right.getType() == Token.STRING) {\n+        String propName = right.getString();\n+        if (propName.equals(\"returnValue\")) {\n+          // Handle the special case of returnValue property access in an event handler\n+          Node grandParent = expr.getParent().getParent();\n+          if (grandParent.getType() == Token.CALL) {\n+            Node callee = grandParent.getFirstChild();\n+            Node eventHandler = callee.getFirstChild();\n+            if (eventHandler.getLastChild().getString().equals(\"handler\")) {\n+              String nameExpr = eventHandler.getFirstChild().getString();\n+              return !isExprResult || !nameExpr.startsWith(\"on\");\n+            }\n+          }\n+        }\n+      }\n+      break;\n+\n+    case Token.AND:\n+    case Token.OR:\n+      // Handle logical and expressions\n+      Node leftOp = expr.getFirstChild();\n+      Node rightOp = leftOp.getNext();\n+      return isFoldableExpression(leftOp, false) && isFoldableExpression(rightOp, false);\n+\n+    case Token.EQ:\n+    case Token.NE:\n+      // Handle equality/inequality expressions\n+      Node leftEq = expr.getFirstChild();\n+      Node rightEq = leftEq.getNext();\n+      if (isExprResult && leftEq.getType() == Token.THIS \n+          && rightEq.getType() == Token.GETPROP\n+          && rightEq.getFirstChild().getString().equals(\"returnValue\")) {\n+        return false;\n+      }\n+      if (isExprResult && rightEq.getType() == Token.THIS \n+          && leftEq.getType() == Token.GETPROP\n+          && leftEq.getFirstChild().getString().equals(\"returnValue\")) {\n+        return false;\n+      }\n+      return isFoldableExpression(leftEq, false) && isFoldableExpression(rightEq, false);\n+\n+    case Token.INC:\n+    case Token.DEC:\n+      // Handle increment/decrement expressions\n+      return false;\n+\n+    case Token.ASSIGN:\n+      // Handle assignment expressions\n+      if (!isExprResult) {\n+        return false;\n+      }\n+      Node leftAssign = expr.getFirstChild();\n+      Node rightAssign = leftAssign.getNext();\n+      if (leftAssign.getType() != Token.NAME) {\n+        return false;\n+      }\n+      String nameAssign = leftAssign.getString();\n+      return !(nameAssign.startsWith(\"on\") || nameAssign.startsWith(\"goog\"));\n+\n+    case Token.NUMBER:\n+    case Token.STRING:\n+    case Token.TRUE:\n+    case Token.FALSE:\n+    case Token.NULL:\n+      // Handle literals\n+      return true;\n+\n+    default:\n+      // Handle all other expressions\n+      break;\n   }\n \n+  return false;\n+}\n+\n   /**\n    * @return The expression node.\n    */",
    "result_reason": "junit.framework.ComparisonFailure: expected:<function(){[x||]y()}> but was:<function(){[if(!x)]y()}>",
    "test_result": "FAIL"
}