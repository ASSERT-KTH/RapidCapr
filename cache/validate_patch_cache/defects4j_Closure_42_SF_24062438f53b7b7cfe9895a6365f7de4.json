{
    "patch": "import com.google.common.collect.ImmutableSet;\nimport org.mozilla.javascript.ErrorReporter;\nimport org.mozilla.javascript.Node;\nimport org.mozilla.javascript.Token;\nimport org.mozilla.javascript.ast.*;\n\nimport java.util.Set;\n\nclass IRFactory {\n  private final String sourceName;\n  private final AstRoot astRoot;\n  private final Node executionScopeNode;\n  private final ErrorReporter errorReporter;\n  private final Compiler compiler = new Compiler();\n\n  private static final Set<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\n          \"use strict\",\n          \"use asm\");  \n\n  IRFactory(String source,\n            String sourceName,\n            AstRoot astRoot,\n            Node executionScopeNode,\n            ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.astRoot = astRoot;\n    this.executionScopeNode = executionScopeNode;\n    this.errorReporter = errorReporter;\n  }\n\n  private Node newNode(int type) {\n    return new Node(type);\n  }\n\n  private Node newNode(int type, Node... children) {\n    return new Node(type, children);\n  }\n\n  private Node transform(AstNode node) {\n    return NodeTraversal.traverse(compiler, node, this);\n  }\n\n  private Node transformBlock(AstNode node) {\n    if (node == null) {\n      return newNode(Token.EMPTY);\n    } else if (node instanceof Block) {\n      return transform(node);\n    } else {\n      Node block = newNode(Token.BLOCK);\n      block.addChildToBack(transform(node));\n      return block;\n    }\n  }\n\n  private int transformTokenType(int type) {\n    switch (type) {\n      case Token.LE:\n        return Token.LT;\n      case Token.GE:\n        return Token.GT;\n      case Token.SHEQ:\n        return Token.EQ;\n      case Token.SHNE:\n        return Token.NE;\n      default:\n        return type;\n    }\n  }\n\n  private Node processGeneric(AstNode node) {\n    Node result = newNode(Token.BLOCK);\n    for (Node child : transformChildren(node)) {\n      if (isDirective(child)) {\n        result.addChildToFront(child);\n      } else if (child.getType() != Token.EMPTY) {\n        result.addChildToBack(child);\n      }\n    }\n    return result;\n  }\n\n  private Iterable<Node> transformChildren(AstNode node) {\n    return new Iterable<Node>() {\n      @Override\n      public java.util.Iterator<Node> iterator() {\n        return new java.util.Iterator<Node>() {\n          AstNode currentChild = node.getFirstChild();\n\n          @Override\n          public boolean hasNext() {\n            return currentChild != null;\n          }\n\n          @Override\n          public Node next() {\n            Node result = transform(currentChild);\n            currentChild = currentChild.getNext();\n            return result;\n          }\n\n          @Override\n          public void remove() {\n            throw new UnsupportedOperationException(\"Not implemented.\");\n          }\n        };\n      }\n\n      @SuppressWarnings(\"unused\")\n      public void remove() {\n        throw new UnsupportedOperationException(\"Not implemented.\");\n      }\n    };\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n        n.getFirstChild().isString() &&\n        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  Node generateFunction(FunctionNode functionNode) {\n      Node function = newNode(Token.FUNCTION);\n      function.setLineno(functionNode.getLineno());\n      function.setCharno(functionNode.getCharno());\n\n      String name = functionNode.getFunctionName();\n      if (name != null) {\n        function.addChildToBack(Node.newString(Token.NAME, name));\n      }\n\n      Node paramList = Node.newString(Token.PARAM_LIST);\n      AstNode[] params = functionNode.getParams();\n      for (AstNode param : params) {\n        Node paramNode =\n            param instanceof InfixExpression && ((InfixExpression)param).getType() == Token.IN ?\n            newNode(Token.TARGET) : newNode(Token.NAME);\n        paramNode.setString(param.getString());\n        paramList.addChildToBack(paramNode);\n      }\n      function.addChildToBack(paramList);\n\n      Node block = Node.newString(Token.BLOCK);\n      Node.Block lastBlock = new Node.Block();\n      NodeTraversal.Callback recordLabels = new NodeTraversal.Callback() {\n        @Override\n        public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n          if (n.getType() == Token.LABEL) {\n            // Avoid adding empty blocks before the first label.\n            if (lastBlock.hasChildren()) {\n              block.addChildrenToBack(lastBlock);\n              lastBlock = new Node.Block();\n            }\n            lastBlock.addChildrenToBack(newNode(Token.LABEL, n.getFirstChild().getIdentifier()));\n            lastBlock.addChildrenToBack(newNode(Token.EMPTY));\n          }\n          return true;\n        }\n\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n        }\n      };\n      NodeTraversal.traverse(compiler, functionNode.getBody(), recordLabels);\n      lastBlock.addChildrenToBack(transformBlock(functionNode.getBody()));\n      block.addChildrenToBack(lastBlock);\n      function.addChildToBack(block);\n\n      return function;\n  }\n\n  private Node makeSampleLoopSummary(Node loopNode) {\n    // Return the bare minimum to put the AST in a valid state.\n    return newNode(\n        Token.FOR,\n        Node.newString(Token.EMPTY),\n        Node.newString(Token.EMPTY),\n        transformBlock(loopNode.getBody()));\n  }\n\n  private Node makeSampleIfSummary() {\n    return newNode(Token.IF);\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {}\n\n  Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  Node processForInLoop(ForInLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getIterator()),\n        transform(loopNode.getIteratedObject()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  Node processForLoop(ForLoop loopNode) {\n    Node loop = newNode(\n        Token.FOR,\n        Node.newString(Token.EMPTY),\n        transform(loopNode.getCondition()),\n        Node.newString(Token.EMPTY));\n\n    if (loopNode.getInitializer() != null) {\n      loop.getFirstChild().addChildToBack(transform(loopNode.getInitializer()));\n    }\n\n    if (loopNode.getIncrement() != null) {\n      loop.getLastChild().addChildToBack(transform(loopNode.getIncrement()));\n    }\n\n    loop.addChildToBack(transformBlock(loopNode.getBody()));\n\n    return loop;\n  }\n\n  Node processFunctionCall(FunctionCall callNode) {\n    Node call = newNode(Token.CALL);\n    call.addChildToBack(transform(callNode.getTarget()));\n    for (AstNode arg : callNode.getArguments()) {\n      call.addChildToBack(transfor",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..c94031bd 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,306 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.common.collect.ImmutableSet;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+import org.mozilla.javascript.ast.*;\n+\n+import java.util.Set;\n+\n+class IRFactory {\n+  private final String sourceName;\n+  private final AstRoot astRoot;\n+  private final Node executionScopeNode;\n+  private final ErrorReporter errorReporter;\n+  private final Compiler compiler = new Compiler();\n+\n+  private static final Set<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\n+          \"use strict\",\n+          \"use asm\");  \n+\n+  IRFactory(String source,\n+            String sourceName,\n+            AstRoot astRoot,\n+            Node executionScopeNode,\n+            ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.astRoot = astRoot;\n+    this.executionScopeNode = executionScopeNode;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  private Node newNode(int type) {\n+    return new Node(type);\n+  }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private Node newNode(int type, Node... children) {\n+    return new Node(type, children);\n+  }\n+\n+  private Node transform(AstNode node) {\n+    return NodeTraversal.traverse(compiler, node, this);\n+  }\n+\n+  private Node transformBlock(AstNode node) {\n+    if (node == null) {\n+      return newNode(Token.EMPTY);\n+    } else if (node instanceof Block) {\n+      return transform(node);\n+    } else {\n+      Node block = newNode(Token.BLOCK);\n+      block.addChildToBack(transform(node));\n+      return block;\n     }\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  private int transformTokenType(int type) {\n+    switch (type) {\n+      case Token.LE:\n+        return Token.LT;\n+      case Token.GE:\n+        return Token.GT;\n+      case Token.SHEQ:\n+        return Token.EQ;\n+      case Token.SHNE:\n+        return Token.NE;\n+      default:\n+        return type;\n     }\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  private Node processGeneric(AstNode node) {\n+    Node result = newNode(Token.BLOCK);\n+    for (Node child : transformChildren(node)) {\n+      if (isDirective(child)) {\n+        result.addChildToFront(child);\n+      } else if (child.getType() != Token.EMPTY) {\n+        result.addChildToBack(child);\n       }\n-      return node;\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  private Iterable<Node> transformChildren(AstNode node) {\n+    return new Iterable<Node>() {\n+      @Override\n+      public java.util.Iterator<Node> iterator() {\n+        return new java.util.Iterator<Node>() {\n+          AstNode currentChild = node.getFirstChild();\n+\n+          @Override\n+          public boolean hasNext() {\n+            return currentChild != null;\n+          }\n+\n+          @Override\n+          public Node next() {\n+            Node result = transform(currentChild);\n+            currentChild = currentChild.getNext();\n+            return result;\n+          }\n+\n+          @Override\n+          public void remove() {\n+            throw new UnsupportedOperationException(\"Not implemented.\");\n+          }\n+        };\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+      @SuppressWarnings(\"unused\")\n+      public void remove() {\n+        throw new UnsupportedOperationException(\"Not implemented.\");\n+      }\n+    };\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+        n.getFirstChild().isString() &&\n+        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  Node generateFunction(FunctionNode functionNode) {\n+      Node function = newNode(Token.FUNCTION);\n+      function.setLineno(functionNode.getLineno());\n+      function.setCharno(functionNode.getCharno());\n+\n+      String name = functionNode.getFunctionName();\n+      if (name != null) {\n+        function.addChildToBack(Node.newString(Token.NAME, name));\n       }\n-      return node;\n+\n+      Node paramList = Node.newString(Token.PARAM_LIST);\n+      AstNode[] params = functionNode.getParams();\n+      for (AstNode param : params) {\n+        Node paramNode =\n+            param instanceof InfixExpression && ((InfixExpression)param).getType() == Token.IN ?\n+            newNode(Token.TARGET) : newNode(Token.NAME);\n+        paramNode.setString(param.getString());\n+        paramList.addChildToBack(paramNode);\n+      }\n+      function.addChildToBack(paramList);\n+\n+      Node block = Node.newString(Token.BLOCK);\n+      Node.Block lastBlock = new Node.Block();\n+      NodeTraversal.Callback recordLabels = new NodeTraversal.Callback() {\n+        @Override\n+        public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+          if (n.getType() == Token.LABEL) {\n+            // Avoid adding empty blocks before the first label.\n+            if (lastBlock.hasChildren()) {\n+              block.addChildrenToBack(lastBlock);\n+              lastBlock = new Node.Block();\n+            }\n+            lastBlock.addChildrenToBack(newNode(Token.LABEL, n.getFirstChild().getIdentifier()));\n+            lastBlock.addChildrenToBack(newNode(Token.EMPTY));\n+          }\n+          return true;\n+        }\n+\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+        }\n+      };\n+      NodeTraversal.traverse(compiler, functionNode.getBody(), recordLabels);\n+      lastBlock.addChildrenToBack(transformBlock(functionNode.getBody()));\n+      block.addChildrenToBack(lastBlock);\n+      function.addChildToBack(block);\n+\n+      return function;\n+  }\n+\n+  private Node makeSampleLoopSummary(Node loopNode) {\n+    // Return the bare minimum to put the AST in a valid state.\n+    return newNode(\n+        Token.FOR,\n+        Node.newString(Token.EMPTY),\n+        Node.newString(Token.EMPTY),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  private Node makeSampleIfSummary() {\n+    return newNode(Token.IF);\n+  }\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal nodeTraversal, Node node, Node parent) {}\n+\n+  Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  Node processForInLoop(ForInLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getIterator()),\n+        transform(loopNode.getIteratedObject()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  Node processForLoop(ForLoop loopNode) {\n+    Node loop = newNode(\n+        Token.FOR,\n+        Node.newString(Token.EMPTY),\n+        transform(loopNode.getCondition()),\n+        Node.newString(Token.EMPTY));\n+\n+    if (loopNode.getInitializer() != null) {\n+      loop.getFirstChild().addChildToBack(transform(loopNode.getInitializer()));\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    if (loopNode.getIncrement() != null) {\n+      loop.getLastChild().addChildToBack(transform(loopNode.getIncrement()));\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    loop.addChildToBack(transformBlock(loopNode.getBody()));\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+    return loop;\n+  }\n+\n+  Node processFunctionCall(FunctionCall callNode) {\n+    Node call = newNode(Token.CALL);\n+    call.addChildToBack(transform(callNode.getTarget()));\n+    for (AstNode arg : callNode.getArguments()) {\n+      call.addChildToBack(transfor\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}