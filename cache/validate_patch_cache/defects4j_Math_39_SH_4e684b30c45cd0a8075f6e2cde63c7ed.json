{
    "patch": "        double proposedFirstStep = (forward ? t - stepStart : stepStart - t);\n        if (FastMath.abs(proposedFirstStep) <= FastMath.ulp(stepStart)) {\n            // correct sign to match integration direction\n            proposedFirstStep = (proposedFirstStep >= 0) ? FastMath.ulp(stepStart) : -FastMath.ulp(stepStart);\n        }\n        double hNew = filterStep(FastMath.min(Math.abs(proposedFirstStep), maxStep), forward, false);\n        if (FastMath.abs(hNew) < functionValueAccuracy) {\n            if (hNew >= 0) {\n                hNew = functionValueAccuracy;\n            } else {\n                hNew = -functionValueAccuracy;\n            }\n        }\n        if (proposedFirstStep < 0) {\n            hNew = -hNew;\n        }\n        final double nextT = stepStart + hNew;\n        isLastStep = forward ? (nextT >= t) : (nextT <= t);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..fa4957835 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,24 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+        double proposedFirstStep = (forward ? t - stepStart : stepStart - t);\n+        if (FastMath.abs(proposedFirstStep) <= FastMath.ulp(stepStart)) {\n+            // correct sign to match integration direction\n+            proposedFirstStep = (proposedFirstStep >= 0) ? FastMath.ulp(stepStart) : -FastMath.ulp(stepStart);\n+        }\n+        double hNew = filterStep(FastMath.min(Math.abs(proposedFirstStep), maxStep), forward, false);\n+        if (FastMath.abs(hNew) < functionValueAccuracy) {\n+            if (hNew >= 0) {\n+                hNew = functionValueAccuracy;\n+            } else {\n+                hNew = -functionValueAccuracy;\n+            }\n+        }\n+        if (proposedFirstStep < 0) {\n+            hNew = -hNew;\n+        }\n+        final double nextT = stepStart + hNew;\n+        isLastStep = forward ? (nextT >= t) : (nextT <= t);\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: variable hNew is already defined in method integrate(ExpandableStatefulODE,double)",
    "test_result": "ERROR"
}