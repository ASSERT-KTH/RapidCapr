{
    "patch": "public Complex parse(String source, ParsePosition pos) {\n    int initialIndex = pos.getIndex();\n    int sourceLen = source.length();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse real\n    Number re = parseNumber(source, getRealFormat(), pos);\n    if (re == null) {\n        // invalid real number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse sign\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    int sign = 0;\n    switch (c) {\n    case 0 :\n        // no sign\n        // return real only complex number\n        return new Complex(re.doubleValue(), 0.0);\n    case '-' :\n        sign = -1;\n        break;\n    case '+' :\n        sign = 1;\n        break;\n    default :\n        // invalid sign\n        // set index back to initial, error index should be the last\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // check if the imaginary character is present\n    String imaginaryCharacter = getImaginaryCharacter();\n    int imaginaryLen = imaginaryCharacter.length();\n    if (pos.getIndex() + imaginaryLen > sourceLen || !source.substring(pos.getIndex(), pos.getIndex() + imaginaryLen).equals(imaginaryCharacter)) {\n        // imaginary character not present\n        return new Complex(re.doubleValue(), 0.0);\n    }\n    pos.setIndex(pos.getIndex() + imaginaryLen);\n\n    // parse imaginary\n    Number im = parseNumber(source, getRealFormat(), pos);\n    if (im == null) {\n        // invalid imaginary number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/complex/ComplexFormat.java b/src/java/org/apache/commons/math/complex/ComplexFormat.java\nindex b404bc415..a83401ed0 100644\n--- a/src/java/org/apache/commons/math/complex/ComplexFormat.java\n+++ b/src/java/org/apache/commons/math/complex/ComplexFormat.java\n@@ -317,76 +317,71 @@ public class ComplexFormat extends Format implements Serializable {\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Complex} object.\n      */\n-    public Complex parse(String source, ParsePosition pos) {\n-        int initialIndex = pos.getIndex();\n+public Complex parse(String source, ParsePosition pos) {\n+    int initialIndex = pos.getIndex();\n+    int sourceLen = source.length();\n \n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n+    // parse whitespace\n+    parseAndIgnoreWhitespace(source, pos);\n \n-        // parse real\n-        Number re = parseNumber(source, getRealFormat(), pos);\n-        if (re == null) {\n-            // invalid real number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse sign\n-        int startIndex = pos.getIndex();\n-        char c = parseNextCharacter(source, pos);\n-        int sign = 0;\n-        switch (c) {\n-        case 0 :\n-            // no sign\n-            // return real only complex number\n-            return new Complex(re.doubleValue(), 0.0);\n-        case '-' :\n-            sign = -1;\n-            break;\n-        case '+' :\n-            sign = 1;\n-            break;\n-        default :\n-            // invalid sign\n-            // set index back to initial, error index should be the last\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n-            return null;\n-        }\n+    // parse real\n+    Number re = parseNumber(source, getRealFormat(), pos);\n+    if (re == null) {\n+        // invalid real number\n+        // set index back to initial, error index should already be set\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        return null;\n+    }\n \n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n+    // parse sign\n+    int startIndex = pos.getIndex();\n+    char c = parseNextCharacter(source, pos);\n+    int sign = 0;\n+    switch (c) {\n+    case 0 :\n+        // no sign\n+        // return real only complex number\n+        return new Complex(re.doubleValue(), 0.0);\n+    case '-' :\n+        sign = -1;\n+        break;\n+    case '+' :\n+        sign = 1;\n+        break;\n+    default :\n+        // invalid sign\n+        // set index back to initial, error index should be the last\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        pos.setErrorIndex(startIndex);\n+        return null;\n+    }\n \n-        // parse imaginary\n-        Number im = parseNumber(source, getRealFormat(), pos);\n-        if (im == null) {\n-            // invalid imaginary number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n+    // parse whitespace\n+    parseAndIgnoreWhitespace(source, pos);\n \n-        // parse imaginary character\n-        int n = getImaginaryCharacter().length();\n-        startIndex = pos.getIndex();\n-        int endIndex = startIndex + n;\n-        if (\n-            source.substring(startIndex, endIndex).compareTo(\n-            getImaginaryCharacter()) != 0) {\n-            // set index back to initial, error index should be the start index\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n-            return null;\n-        }\n-        pos.setIndex(endIndex);\n+    // check if the imaginary character is present\n+    String imaginaryCharacter = getImaginaryCharacter();\n+    int imaginaryLen = imaginaryCharacter.length();\n+    if (pos.getIndex() + imaginaryLen > sourceLen || !source.substring(pos.getIndex(), pos.getIndex() + imaginaryLen).equals(imaginaryCharacter)) {\n+        // imaginary character not present\n+        return new Complex(re.doubleValue(), 0.0);\n+    }\n+    pos.setIndex(pos.getIndex() + imaginaryLen);\n \n-        return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+    // parse imaginary\n+    Number im = parseNumber(source, getRealFormat(), pos);\n+    if (im == null) {\n+        // invalid imaginary number\n+        // set index back to initial, error index should already be set\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        return null;\n     }\n+\n+    return new Complex(re.doubleValue(), im.doubleValue() * sign);\n+}\n      \n     /**\n      * Parses <code>source</code> until a non-whitespace character is found.",
    "result_reason": "junit.framework.AssertionFailedError: expected:<org.apache.commons.math.complex.Complex@44d4f3f0> but was:<org.apache.commons.math.complex.Complex@ade6866e>",
    "test_result": "FAIL"
}