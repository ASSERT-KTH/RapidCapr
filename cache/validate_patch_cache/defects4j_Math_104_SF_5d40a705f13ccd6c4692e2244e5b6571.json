{
    "patch": "public static double regularizedGamma(double a, double x) {\n    final double gamma = gamma(a);\n    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n        return gamma;\n    }\n    return regularizedGammaP(a, x, gamma);\n}\n\npublic static double regularizedGammaP(double a, double x) {\n    final double gamma = gamma(a);\n    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n        return gamma;\n    }\n    return regularizedGammaP(a, x, gamma);\n}\n\npublic static double regularizedGammaQ(double a, double x) {\n    final double gamma = gamma(a);\n    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n        return gamma;\n    }\n    return regularizedGammaQ(a, x, gamma);\n}\n\npublic static double regularizedGammaP(double a, double x, double gamma) {\n    if (Double.isNaN(x) || Double.isInfinite(x) || (a <= 0.0)) {\n        return Double.NaN;\n    }\n\n    if (x < (a + 1.0)) {\n        final double igf = incompleteGammaFraction(a, x);\n        return igf * gamma / a;\n    }\n\n    return 1.0 - regularizedGammaQ(a, x, gamma);\n}\n\npublic static double regularizedGammaQ(double a, double x, double gamma) {\n    if (Double.isNaN(x) || Double.isInfinite(x) || (a <= 0.0)) {\n        return Double.NaN;\n    }\n\n    if (x < (a + 1.0)) {\n        final double igf = incompleteGammaFraction(a, x);\n        return 1.0 - (igf * gamma / a);\n    }\n\n    final double igfg = incompleteGammaFraction(a, x);\n    final double igfc = (1.0 / regularizedGammaP(a, x, gamma));\n    return igfc * Math.exp(-x + a * Math.log(x) - logGamma(a)) / igfg;\n}\n\npublic static double incompleteGammaFraction(final double a, double x) {\n    return new ContinuedFraction() {\n        @Override\n        protected double getA(int n, double x) {\n            if ((n % 2) == 0) {\n                return (n / 2) * (a - n / 2) * x;\n            }\n            return -((a + (n - 1) / 2) * (a + n / 2) * x);\n        }\n\n        @Override\n        protected double getB(int n, double x) {\n            return n + 1.0 - a;\n        }\n    }.evaluate(x, 1e-14, Integer.MAX_VALUE);\n}\n\npublic static double gamma(double x) {\n    if (x == 0.0) {\n        return Double.POSITIVE_INFINITY;\n    }\n\n    if (Double.isNaN(x) || (x < 0.0)) {\n        return Double.NaN;\n    }\n\n    if (x < 0.5) {\n        return Math.PI / (Math.sin(Math.PI * x) * gamma(1.0 - x));\n    }\n\n    double z = x - 1.0;\n    double p = 0.9999999999998099;\n    p += 676.5203681218851 / (z + 1.0);\n    p -= 1259.1392167224028 / (z + 2.0);\n    p += 771.3234287776531 / (z + 3.0);\n    p -= 176.6150291621406 / (z + 4.0);\n    p += 12.507343278686905 / (z + 5.0);\n    p -= 0.13857109526572012 / (z + 6.0);\n    p += 9.984369578019571e-6 / (z + 7.0);\n    p += 1.5056327351493116e-7 / (z + 8.0);\n\n    return Math.sqrt(2.0 * Math.PI) * Math.pow(z + 7.5, z + 0.5) * Math.exp(-(z + 7.5))\n            * p;\n}\n\npublic static double logGamma(double x) {\n    if (Double.isNaN(x) || (x <= 0.0)) {\n        return Double.NaN;\n    }\n\n    if (x < 0.5) {\n        return Math.log(Math.PI / (Math.sin(Math.PI * x) * gamma(1.0 - x))) - logGamma(1.0 - x);\n    }\n\n    double res = (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12 * x);\n\n    double x2 = x * x;\n    double x3 = x2 * x;\n    res -= 1.0 / (360 * x3);\n    res += 1.0 / (1260 * x2 * x2);\n    res -= 1.0 / (1680 * x3 * x2);\n    res += 1.0 / (1188 * x3 * x3);\n    res -= 691.0 / (360360 * x2 * x3);\n    res -= 1.0 / (156 * x2 * x2 * x2);\n    return res;\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..f6d54be44 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,124 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGamma(double a, double x) {\n+    final double gamma = gamma(a);\n+    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n+        return gamma;\n+    }\n+    return regularizedGammaP(a, x, gamma);\n+}\n+\n+public static double regularizedGammaP(double a, double x) {\n+    final double gamma = gamma(a);\n+    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n+        return gamma;\n+    }\n+    return regularizedGammaP(a, x, gamma);\n+}\n+\n+public static double regularizedGammaQ(double a, double x) {\n+    final double gamma = gamma(a);\n+    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n+        return gamma;\n+    }\n+    return regularizedGammaQ(a, x, gamma);\n+}\n+\n+public static double regularizedGammaP(double a, double x, double gamma) {\n+    if (Double.isNaN(x) || Double.isInfinite(x) || (a <= 0.0)) {\n+        return Double.NaN;\n+    }\n+\n+    if (x < (a + 1.0)) {\n+        final double igf = incompleteGammaFraction(a, x);\n+        return igf * gamma / a;\n+    }\n+\n+    return 1.0 - regularizedGammaQ(a, x, gamma);\n+}\n+\n+public static double regularizedGammaQ(double a, double x, double gamma) {\n+    if (Double.isNaN(x) || Double.isInfinite(x) || (a <= 0.0)) {\n+        return Double.NaN;\n+    }\n+\n+    if (x < (a + 1.0)) {\n+        final double igf = incompleteGammaFraction(a, x);\n+        return 1.0 - (igf * gamma / a);\n+    }\n+\n+    final double igfg = incompleteGammaFraction(a, x);\n+    final double igfc = (1.0 / regularizedGammaP(a, x, gamma));\n+    return igfc * Math.exp(-x + a * Math.log(x) - logGamma(a)) / igfg;\n+}\n+\n+public static double incompleteGammaFraction(final double a, double x) {\n+    return new ContinuedFraction() {\n+        @Override\n+        protected double getA(int n, double x) {\n+            if ((n % 2) == 0) {\n+                return (n / 2) * (a - n / 2) * x;\n+            }\n+            return -((a + (n - 1) / 2) * (a + n / 2) * x);\n+        }\n+\n+        @Override\n+        protected double getB(int n, double x) {\n+            return n + 1.0 - a;\n+        }\n+    }.evaluate(x, 1e-14, Integer.MAX_VALUE);\n+}\n+\n+public static double gamma(double x) {\n+    if (x == 0.0) {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+\n+    if (Double.isNaN(x) || (x < 0.0)) {\n+        return Double.NaN;\n+    }\n+\n+    if (x < 0.5) {\n+        return Math.PI / (Math.sin(Math.PI * x) * gamma(1.0 - x));\n+    }\n+\n+    double z = x - 1.0;\n+    double p = 0.9999999999998099;\n+    p += 676.5203681218851 / (z + 1.0);\n+    p -= 1259.1392167224028 / (z + 2.0);\n+    p += 771.3234287776531 / (z + 3.0);\n+    p -= 176.6150291621406 / (z + 4.0);\n+    p += 12.507343278686905 / (z + 5.0);\n+    p -= 0.13857109526572012 / (z + 6.0);\n+    p += 9.984369578019571e-6 / (z + 7.0);\n+    p += 1.5056327351493116e-7 / (z + 8.0);\n+\n+    return Math.sqrt(2.0 * Math.PI) * Math.pow(z + 7.5, z + 0.5) * Math.exp(-(z + 7.5))\n+            * p;\n+}\n+\n+public static double logGamma(double x) {\n+    if (Double.isNaN(x) || (x <= 0.0)) {\n+        return Double.NaN;\n+    }\n+\n+    if (x < 0.5) {\n+        return Math.log(Math.PI / (Math.sin(Math.PI * x) * gamma(1.0 - x))) - logGamma(1.0 - x);\n+    }\n+\n+    double res = (x - 0.5) * Math.log(x) - x + 0.5 * Math.log(2 * Math.PI) + 1.0 / (12 * x);\n+\n+    double x2 = x * x;\n+    double x3 = x2 * x;\n+    res -= 1.0 / (360 * x3);\n+    res += 1.0 / (1260 * x2 * x2);\n+    res -= 1.0 / (1680 * x3 * x2);\n+    res += 1.0 / (1188 * x3 * x3);\n+    res -= 691.0 / (360360 * x2 * x3);\n+    res -= 1.0 / (156 * x2 * x2 * x2);\n+    return res;\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}