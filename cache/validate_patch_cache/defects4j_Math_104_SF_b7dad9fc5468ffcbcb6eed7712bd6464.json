{
    "patch": "import org.apache.commons.math3.util.FastMath;\n\npublic class GammaFunction {\n\n    private static final double DEFAULT_EPSILON = 1e-15;\n\n    /**\n     * Computes the value of log gamma function for the given input.\n     * @param x input value\n     * @return log gamma(x)\n     */\n    public static double logGamma(double x) {\n        if(x <= 0) {\n            throw new IllegalArgumentException(\"x must be positive\");\n        }\n\n        double v = 1.0;\n        double tmp = x + 5.5;\n        tmp -= (x + 0.5) * FastMath.log(tmp);\n\n        for(int i = 0; i < 6; i++) {\n            v *= (x + i);\n        }\n\n        return FastMath.log(v * FastMath.sqrt(2 * FastMath.PI)) - tmp;\n    }\n\n    /**\n     * Computes the upper incomplete gamma function for the given input.\n     * @param a shape parameter of the gamma distribution\n     * @param x integration limit\n     * @return upper incomplete gamma function\n     */\n    public static double gammaQ(double a, double x) {\n        if(a <= 0.0 || x < 0.0) {\n            throw new IllegalArgumentException(\"a must be positive and x must be non-negative\");\n        }\n\n        double gamSer = 0.0;\n        double gamCF = 0.0;\n\n        if(x < a + 1.0) {\n            gamSer = gammaSeries(a, x);\n            return 1.0 - gamSer;\n        } else {\n            gamCF = gammaCF(a, x);\n            return gamCF;\n        }\n    }\n\n    /**\n     * Computes gamma(a, x), the normalized lower incomplete gamma function.\n     * @param a shape parameter of the gamma distribution\n     * @param x integration limit\n     * @return gamma(a, x), the normalized lower incomplete gamma function\n     */\n    public static double gammaP(double a, double x) {\n        if(a <= 0.0 || x < 0.0) {\n            throw new IllegalArgumentException(\"a must be positive and x must be non-negative\");\n        }\n\n        double gamSer = 0.0;\n        double gamCF = 0.0;\n\n        if(x < a + 1.0) {\n            gamSer = gammaSeries(a, x);\n            return gamSer / incompleteGammaFraction(a, x);\n        } else {\n            gamCF = gammaCF(a, x);\n            return 1.0 - gamCF / incompleteGammaFraction(a, x);\n        }\n    }\n\n    /**\n     * Returns the incomplete gamma fraction Q(a, x) evaluated by continued fraction.\n     * @param a shape parameter of the gamma distribution\n     * @param x integration limit\n     * @return incomplete gamma fraction\n     */\n    private static double incompleteGammaFraction(double a, double x) {\n        double eps = DEFAULT_EPSILON;\n        double fpmin = Double.MIN_VALUE / eps;\n\n        double an = 1.0 / a;\n        double b = 1.0 / (1.0 - x * an);\n        double c = b;\n        double d = 0.0;\n        if (b == 0.0) {\n            b = fpmin;\n            c = b;\n        }\n        double h = 1.0;\n\n        for (int i = 1; i <= 100; i++) {\n            final double a1 = i * (a - i);\n            final double a2 = (i * 2.0) + 1.0 - a + x;\n\n            d = a2 * b + a1 * d;\n            if (d == 0.0) d = fpmin;\n            c = a2 + a1 / c;\n            if (c == 0.0) c = fpmin;\n            d = 1.0 / d;\n            final double del = c * d;\n            h *= del;\n            if (Math.abs(del - 1.0) < eps) break;\n        }\n\n        return Math.exp(-x + a * FastMath.log(x) - logGamma(a)) * h;\n    }\n\n    /**\n     * Returns the series approximation to the incomplete gamma function.\n     * @param a shape parameter of the gamma distribution\n     * @param x integration limit\n     * @return gammaSeries\n     */\n    private static double gammaSeries(double a, double x) {\n        double eps = DEFAULT_EPSILON;\n        double gln = logGamma(a);\n        double ap = a;\n        double sum = 1.0 / a;\n        double del = sum;\n        for (int n = 1; n <= 100; n++) {\n            ap += 1.0;\n            del *= x / ap;\n            sum += del;\n            if (Math.abs(del) < Math.abs(sum) * eps) {\n                return sum * Math.exp(-x + a * Math.log(x) - gln);\n            }\n        }\n        throw new ArithmeticException(\"gammaSeries failed to converge\");\n    }\n\n    /**\n     * Returns the continued fraction approximation to the incomplete gamma function.\n     * @param a shape parameter of the gamma distribution\n     * @param x integration limit\n     * @return gammaCF\n     */\n    private static double gammaCF(double a, double x) {\n        double eps = DEFAULT_EPSILON;\n        double gln = logGamma(a);\n        double g = 0.0;\n        double f = 1.0;\n        double b = x + 1.0 - a;\n        double c = 1.0 / eps;\n        double d = 1.0 / b;\n        double h = d;\n\n        for (int i = 1; i <= 100; i++) {\n            final double an = -i * (i - a);\n            b += 2.0;\n            d = an * d + b;\n            if (Math.abs(d) < Double.MIN_VALUE) {\n                d = Double.MIN_VALUE;\n            }\n            c = b + an / c;\n            if (Math.abs(c) < Double.MIN_VALUE) {\n                c = Double.MIN_VALUE;\n            }\n            d = 1.0 / d;\n            final double del = d * c;\n            h = h * del;\n            if (Math.abs(del - 1.0) < eps) {\n                break;\n            }\n        }\n\n        return Math.exp(-x + a * Math.log(x) - gln) * h;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..8288fd486 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,177 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.util.FastMath;\n+\n+public class GammaFunction {\n+\n+    private static final double DEFAULT_EPSILON = 1e-15;\n+\n+    /**\n+     * Computes the value of log gamma function for the given input.\n+     * @param x input value\n+     * @return log gamma(x)\n+     */\n+    public static double logGamma(double x) {\n+        if(x <= 0) {\n+            throw new IllegalArgumentException(\"x must be positive\");\n+        }\n+\n+        double v = 1.0;\n+        double tmp = x + 5.5;\n+        tmp -= (x + 0.5) * FastMath.log(tmp);\n+\n+        for(int i = 0; i < 6; i++) {\n+            v *= (x + i);\n+        }\n+\n+        return FastMath.log(v * FastMath.sqrt(2 * FastMath.PI)) - tmp;\n+    }\n+\n+    /**\n+     * Computes the upper incomplete gamma function for the given input.\n+     * @param a shape parameter of the gamma distribution\n+     * @param x integration limit\n+     * @return upper incomplete gamma function\n+     */\n+    public static double gammaQ(double a, double x) {\n+        if(a <= 0.0 || x < 0.0) {\n+            throw new IllegalArgumentException(\"a must be positive and x must be non-negative\");\n+        }\n+\n+        double gamSer = 0.0;\n+        double gamCF = 0.0;\n+\n+        if(x < a + 1.0) {\n+            gamSer = gammaSeries(a, x);\n+            return 1.0 - gamSer;\n+        } else {\n+            gamCF = gammaCF(a, x);\n+            return gamCF;\n+        }\n+    }\n+\n+    /**\n+     * Computes gamma(a, x), the normalized lower incomplete gamma function.\n+     * @param a shape parameter of the gamma distribution\n+     * @param x integration limit\n+     * @return gamma(a, x), the normalized lower incomplete gamma function\n+     */\n+    public static double gammaP(double a, double x) {\n+        if(a <= 0.0 || x < 0.0) {\n+            throw new IllegalArgumentException(\"a must be positive and x must be non-negative\");\n+        }\n+\n+        double gamSer = 0.0;\n+        double gamCF = 0.0;\n+\n+        if(x < a + 1.0) {\n+            gamSer = gammaSeries(a, x);\n+            return gamSer / incompleteGammaFraction(a, x);\n+        } else {\n+            gamCF = gammaCF(a, x);\n+            return 1.0 - gamCF / incompleteGammaFraction(a, x);\n+        }\n+    }\n+\n+    /**\n+     * Returns the incomplete gamma fraction Q(a, x) evaluated by continued fraction.\n+     * @param a shape parameter of the gamma distribution\n+     * @param x integration limit\n+     * @return incomplete gamma fraction\n+     */\n+    private static double incompleteGammaFraction(double a, double x) {\n+        double eps = DEFAULT_EPSILON;\n+        double fpmin = Double.MIN_VALUE / eps;\n+\n+        double an = 1.0 / a;\n+        double b = 1.0 / (1.0 - x * an);\n+        double c = b;\n+        double d = 0.0;\n+        if (b == 0.0) {\n+            b = fpmin;\n+            c = b;\n+        }\n+        double h = 1.0;\n+\n+        for (int i = 1; i <= 100; i++) {\n+            final double a1 = i * (a - i);\n+            final double a2 = (i * 2.0) + 1.0 - a + x;\n+\n+            d = a2 * b + a1 * d;\n+            if (d == 0.0) d = fpmin;\n+            c = a2 + a1 / c;\n+            if (c == 0.0) c = fpmin;\n+            d = 1.0 / d;\n+            final double del = c * d;\n+            h *= del;\n+            if (Math.abs(del - 1.0) < eps) break;\n+        }\n+\n+        return Math.exp(-x + a * FastMath.log(x) - logGamma(a)) * h;\n+    }\n+\n+    /**\n+     * Returns the series approximation to the incomplete gamma function.\n+     * @param a shape parameter of the gamma distribution\n+     * @param x integration limit\n+     * @return gammaSeries\n+     */\n+    private static double gammaSeries(double a, double x) {\n+        double eps = DEFAULT_EPSILON;\n+        double gln = logGamma(a);\n+        double ap = a;\n+        double sum = 1.0 / a;\n+        double del = sum;\n+        for (int n = 1; n <= 100; n++) {\n+            ap += 1.0;\n+            del *= x / ap;\n+            sum += del;\n+            if (Math.abs(del) < Math.abs(sum) * eps) {\n+                return sum * Math.exp(-x + a * Math.log(x) - gln);\n+            }\n+        }\n+        throw new ArithmeticException(\"gammaSeries failed to converge\");\n+    }\n+\n+    /**\n+     * Returns the continued fraction approximation to the incomplete gamma function.\n+     * @param a shape parameter of the gamma distribution\n+     * @param x integration limit\n+     * @return gammaCF\n+     */\n+    private static double gammaCF(double a, double x) {\n+        double eps = DEFAULT_EPSILON;\n+        double gln = logGamma(a);\n+        double g = 0.0;\n+        double f = 1.0;\n+        double b = x + 1.0 - a;\n+        double c = 1.0 / eps;\n+        double d = 1.0 / b;\n+        double h = d;\n+\n+        for (int i = 1; i <= 100; i++) {\n+            final double an = -i * (i - a);\n+            b += 2.0;\n+            d = an * d + b;\n+            if (Math.abs(d) < Double.MIN_VALUE) {\n+                d = Double.MIN_VALUE;\n+            }\n+            c = b + an / c;\n+            if (Math.abs(c) < Double.MIN_VALUE) {\n+                c = Double.MIN_VALUE;\n+            }\n+            d = 1.0 / d;\n+            final double del = d * c;\n+            h = h * del;\n+            if (Math.abs(del - 1.0) < eps) {\n+                break;\n+            }\n+        }\n+\n+        return Math.exp(-x + a * Math.log(x) - gln) * h;\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}