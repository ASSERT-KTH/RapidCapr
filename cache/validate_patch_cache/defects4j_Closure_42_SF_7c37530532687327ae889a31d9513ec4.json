{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.ErrorManager;\nimport com.google.javascript.jscomp.NodeUtil;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.jscomp.SourceMap;\nimport com.google.javascript.rhino.*;\nimport java.util.Objects;\n\nclass IRFactory {\n\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n  private final boolean preserveAnnotations;\n\n  public IRFactory(ErrorReporter errorReporter, String sourceName, boolean preserveAnnotations) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n    this.preserveAnnotations = preserveAnnotations;\n  }\n\n  /**\n  * Produces an AST from the given JavaScript code.\n  */\n  public Node parse(String js) {\n    Parser p = new Parser();\n    Node n;\n    try {\n        n = p.parse(js, sourceName, 1);\n    } catch (Throwable e) {\n        errorReporter.error(e.getMessage(), sourceName, 1, \"\", 0);\n        n = new Node(Token.EMPTY);\n    }\n    return transform(n);\n  }\n\n  /**\n  * Transforms a spidermonkey AST into a closure AST\n  */\n  private Node transform(AstNode spiderMonkeyNode) {\n    TransformDispatcher dispatcher = new TransformDispatcher();\n    return dispatcher.transform(spiderMonkeyNode);\n  }\n\n  /**\n  * Dispatches spidermonkey nodes to the appropriate transformer method.\n  * @see com.google.javascript.rhino.TypeSafeDispatcher\n  */\n  private class TransformDispatcher implements NodeTransformer<AstNode> {\n\n    @Override\n    public Node transform(AstNode node) {\n        Token type = transformTokenType(node.getType());\n        Node newNode = new Node(type);\n        switch (type) {\n            case SCRIPT:\n                return transformScriptNode(node, newNode);\n            case BLOCK:\n                return transformBlockNode(node, newNode);\n            case LABEL:\n                return transformLabelNode(node, newNode);\n            case WHILE:\n                return transformWhileNode(node, newNode);\n            case DO:\n                return transformDoNode(node, newNode);\n            case FOR:\n                return transformForNode(node, newNode);\n            case FOR_IN:\n                return transformForInNode(node, newNode);\n            case SWITCH:\n                return transformSwitchNode(node, newNode);\n            case CASE:\n                return transformCaseNode(node, newNode);\n            case DEFAULT_CASE:\n                return transformDefaultCaseNode(node, newNode);\n            case IF:\n                return transformIfNode(node, newNode);\n            case NAME:\n                return transformNameNode(node);\n            case NUMBER:\n            case STRING:\n            case TRUE:\n            case FALSE:\n            case NULL:\n            case THIS:\n            case REGEXP:\n                return new Node(type, node.getString());\n            case ARRAYLIT:\n                return transformArrayLit(node, newNode);\n            case OBJECTLIT:\n                return transformObjectLit(node, newNode);\n            case GETPROP:\n                return transformPropAccess(node, newNode);\n            case CALL:\n                return transformCall(node, newNode);\n            case FUNCTION:\n                return transformFunction(node, newNode);\n            case RETURN:\n                return transformReturn(node, newNode);\n            case VAR:\n                return transformVariable(node, newNode);\n            case ASSIGN:\n                return transformAssign(node, newNode);\n            case HOOK:\n                return transformConditional(node, newNode);\n            case OR:\n            case AND:\n                return transformLogical(node, newNode);\n            case BITOR:\n            case BITXOR:\n            case BITAND:\n                return transformBitOp(node, newNode);\n            case EQ:\n            case NE:\n            case SHEQ:\n            case SHNE:\n            case LT:\n            case GT:\n            case LE:\n            case GE:\n                return transformBinary(node, newNode);\n            case LSH:\n            case RSH:\n            case URSH:\n            case ADD:\n            case SUB:\n            case MUL:\n            case DIV:\n            case MOD:\n                return transformArith(node, newNode);\n            case BITNOT:\n            case NEG:\n            case POS:\n            case NOT:\n                return transformUnary(node, newNode);\n            case ARRAY_PATTERN:\n                return transformArrayPattern(node, newNode);\n            case OBJECT_PATTERN:\n                return transformObjectPattern(node, newNode);\n            case DEFAULT_VALUE:\n                return transformDefaultValue(node, newNode);\n            case REST:\n                return transformRest(node, newNode);\n            default:\n                errorReporter.error(\"Unimplemented feature: \" + type, sourceName, node.getLineno(), \"\", 0);\n                return newNode;\n        }\n    }\n\n    private Node transformScriptNode(AstNode node, Node newNode) {\n        Token type = transformTokenType(node.getType());\n        if (preserveAnnotations) {\n            String src = node.toSource();\n            newNode.setOriginalName(node.getJsDocNode().getOriginalCommentString());\n            newNode.setStaticSourceFile(new SourceFile(sourceName, src));\n            newNode.setSourceFileName(sourceName);\n        }\n        NodeUtil.addFeatureToScript(newNode, Feature.get(node.getJsDocNode()));\n        List<AstNode> children = node.getDirectChildren();\n        for (AstNode child : children) {\n            newNode.addChildToBack(transform(child));\n        }\n        return newNode;\n    }\n\n    private Node transformBlockNode(AstNode node, Node newNode) {\n        List<AstNode> children = node.getDirectChildren();\n        for (AstNode child : children) {\n            newNode.addChildToBack(transform(child));\n        }\n        return newNode;\n    }\n\n    private Node transformLabelNode(AstNode node, Node newNode) {\n        Token type = transformTokenType(node.getType());\n        newNode.addChildToBack(newNode(type, node.getLabelName()));\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        return newNode;\n    }\n\n    private Node transformWhileNode(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        newNode.addChildToBack(transformBlock(node.getSecondChild()));\n        return newNode;\n    }\n\n    private Node transformDoNode(AstNode node, Node newNode) {\n        newNode.addChildToBack(transformBlock(node.getFirstChild()));\n        newNode.addChildToBack(transform(node.getSecondChild()));\n        return newNode;\n    }\n\n    private Node transformForNode(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        newNode.addChildToBack(transform(node.getSecondChild()));\n        newNode.addChildToBack(transform(node.getThirdChild()));\n        newNode.addChildToBack(transformBlock(node.getFourthChild()));\n        return newNode;\n    }\n\n    private Node transformForInNode(AstNode node, Node newNode) {\n        AstNode lhs = node.getFirstChild();\n        AstNode rhs = node.getSecondChild();\n        Node object = transform(rhs);\n        Node body = transformBlock(node.getLastChild());\n        Node result;\n        if (lhs instanceof Name) {\n            result = newNode(Token.FOR);\n\n            Node lhsNode = transform(lhs);\n            lhsNode.setIsStatement(true);\n\n            result.addChildToBack(lhsNode);\n            result.addChildToBack(object);\n            result.addChildToBack(body);\n        } else if (lhs instanceof InfixExpression && lhs.getType() == Token.LE) {\n            AstNode lhsOperand = lhs.getFirstChild();\n            AstNode rhsOperand = lhs.getLastChild();\n            Node lhsNode = transform(lhsOperand);\n            Node rhsNode = transform(rhsOperand);\n            lhsNode.addChildToFront(new Node(Token.VAR, lhsNode.cloneTree()));\n            Node lhsVarNode = lhsNode.getFirstChild();\n            lhsVarNode.insertBefore(new Node(Token.ASSIGN, lhsVarNode.detachFromParent(), rhsNode));\n            Node initializer = lhsNode.getFirstChild();\n            lhsNode.removeChild(initializer);\n            Node condition = newNode(Token.TRUE);\n            Node increment = newNode(Token.EMPTY);\n            result = newNode(Token.FOR);\n            result.addChildToBack(initializer);\n            result.addChildToBack(condition);\n            result.addChildToBack(increment);\n            result.addChildToBack(body);\n        } else {\n            result = newNode(Token.EMPTY);\n            errorReporter.error(\n                    \"Invalid left-hand side in for-in loop\",\n                    sourceName,\n                    lhs.getLineno(), \"\", 0);\n        }\n        return result;\n    }\n\n    private Node transformSwitchNode(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        List<AstNode> children = node.getDirectChildren();\n        for (int i = 1; i < children.size(); i++) {\n            AstNode child = children.get(i);\n            if (child.getType() == Token.CASE) {\n                newNode.addChildToBack(transform(child));\n            }\n        }\n        return newNode;\n    }\n\n    private Node transformCaseNode(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        List<AstNode> children = node.getDirectChildren();\n        for (int i = 1; i < children.size(); i++) {\n            AstNode child = children.get(i);\n            if (child.getType() != Token.CASE && child.getType() != Token.DEFAULT_CASE) {\n                newNode.addChildToBack(transform(child));\n            }\n        }\n        return newNode;\n    }\n\n    private Node transformDefaultCaseNode(AstNode node, Node newNode) {\n        List<AstNode> children = node.getDirectChildren();\n        for (AstNode child : children) {\n            if (child.getType() != Token.CASE && child.getType() != Token.DEFAULT_CASE) {\n                newNode.addChildToBack(transform(child));\n            }\n        }\n        return newNode;\n    }\n\n    private Node transformIfNode(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        newNode.addChildToBack(transformBlock(node.getSecondChild()));\n        if (node.getChildCount() == 3) {\n            newNode.addChildToBack(transformBlock(node.getLastChild()));\n        }\n        return newNode;\n    }\n\n    private Node transformNameNode(AstNode node) {\n        Token type = transformTokenType(node.getType());\n        String identifier = getIdentifier(node);\n        return new Node(type, identifier);\n    }\n\n    private Node transformArrayLit(AstNode node, Node newNode) {\n        List<AstNode> children = node.getDirectChildren();\n        for (AstNode child : children) {\n            if (child.getType() == Token.COMMA) {\n                newNode.addChildToBack(new Node(Token.EMPTY));\n            } else {\n                newNode.addChildToBack(transform(child));\n            }\n        }\n        return newNode;\n    }\n\n    private Node transformObjectLit(AstNode node, Node newNode) {\n        List<AstNode> elements = node.getElements();\n        for (AstNode element : elements) {\n            if (element.getType() == Token.COMMA) {\n                newNode.addChildToBack(new Node(Token.EMPTY));\n            } else {\n                Node child = transform(element);\n                if (element instanceof PropertyGet) {\n                    // Replace GETPROP with string.\n                    child.removeChild(child.getLastChild());\n                } else if (element instanceof XmlExpression) {\n                    // Extract the expression and add ATTRIBUTE_NAME as a first child\n                    AstNode childNode = Objects.requireNonNull(child.getFirstChild());\n                    String propertyName = getIdentifier(childNode);\n                    child = transform(childNode.getNext());\n                    child.addChildToFront(new Node(Token.STRING_KEY, propertyName));\n                }\n                newNode.addChildToBack(child);\n            }\n        }\n        return newNode;\n    }\n\n    private Node transformPropAccess(AstNode node, Node newNode) {\n        Token type = transformTokenType(node.getType());\n        String identifier = getIdentifier(node);\n        newNode.addChildToBack(newNode(type, identifier));\n        newNode.addChildToBack(transform(node.getLastChild()));\n        return newNode;\n    }\n\n    private Node transformCall(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        List<AstNode> children = node.getArguments();\n        for (AstNode child : children) {\n            newNode.addChildToBack(transform(child));\n        }\n        return newNode;\n    }\n\n    private Node transformFunction(AstNode node, Node newNode) {\n        Token type = transformTokenType(node.getType());\n        newNode.setIsArrowFunction(node instanceof FunctionNode && ((FunctionNode) node).isArrowFunction());\n        newNode.addChildToBack(newNode(Token.FUNCTION));\n        newNode.addChildToBack(transform(node.getName()));\n        List<AstNode> params;\n        if (node instanceof FunctionNode) {\n            params = ((FunctionNode) node).getParams();\n        } else {\n            params = node.getDirectChildren();\n        }\n        Node paramList = new Node(Token.PARAM_LIST);\n        for (AstNode child : params) {\n            paramList.addChildToBack(transform(child));\n        }\n        newNode.addChildToBack(paramList);\n        newNode.addChildToBack(transform(node.getBody()));\n        if (node instanceof FunctionNode) {\n            FunctionNode fNode = (FunctionNode) node;\n            boolean isExpression = fNode.getParent() != null &&\n                    (fNode.getParent().getType() == Token.EXPR_RESULT ||\n                            fNode.getParent().getType() == Token.VAR);\n            newNode.setIsExpressionClosure(isExpression);\n            if (fNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n                newNode.setIsExpressionResult(true);\n            }\n        } else if (node.getType() == Token.FUNCTION) {\n            newNode.setIsGeneratorFunction(node instanceof GeneratorExpression);\n            newNode.setIsExpressionResult(true);\n        }\n        List<Comment> comments = node.getComments();\n        for (Comment comment : comments) {\n            newNode.addNonJSDocChild(newNode(Token.EMPTY, comment.getValue()));\n        }\n        return newNode;\n    }\n\n    private Node transformReturn(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        return newNode;\n    }\n\n    private Node transformVariable(AstNode node, Node newNode) {\n        Token type = transformTokenType(node.getType());\n        newNode.addChildToBack(newNode(Token.VAR));\n        List<AstNode> children = node.getDirectChildren();\n        for (AstNode child : children) {\n            newNode.addChildToBack(transform(child));\n        }\n        return newNode;\n    }\n\n    private Node transformAssign(AstNode node, Node newNode) {\n        Token type = transformTokenType(node.getType());\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        newNode.addChildToBack(transform(node.getLastChild()));\n        return newNode;\n    }\n\n    private Node transformConditional(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        newNode.addChildToBack(transform(node.getSecondChild()));\n        newNode.addChildToBack(transform(node.getLastChild()));\n        return newNode;\n    }\n\n    private Node transformLogical(AstNode node, Node newNode) {\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        newNode.addChildToBack(transform(node.getLastChild()));\n        return newNode;\n    }\n\n    private Node transformBitOp(AstNode node, Node newNode) {\n        Token type = transformTokenType(node.getType());\n        newNode.addChildToBack(newNode(type));\n        newNode.addChildToBack(transform(node.getFirstChild()));\n        newNode.addChildToBack(transform(node.getLastChild()));\n        return newNode;\n    }\n\n    private Node transformBinary(AstNode node, Node newNode) {\n        Token type = transformTokenType(nod",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..d60c60a2 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,431 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.NodeUtil;\n+import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.jscomp.SourceMap;\n+import com.google.javascript.rhino.*;\n+import java.util.Objects;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+class IRFactory {\n+\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+  private final boolean preserveAnnotations;\n+\n+  public IRFactory(ErrorReporter errorReporter, String sourceName, boolean preserveAnnotations) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+    this.preserveAnnotations = preserveAnnotations;\n+  }\n+\n+  /**\n+  * Produces an AST from the given JavaScript code.\n+  */\n+  public Node parse(String js) {\n+    Parser p = new Parser();\n+    Node n;\n+    try {\n+        n = p.parse(js, sourceName, 1);\n+    } catch (Throwable e) {\n+        errorReporter.error(e.getMessage(), sourceName, 1, \"\", 0);\n+        n = new Node(Token.EMPTY);\n+    }\n+    return transform(n);\n+  }\n+\n+  /**\n+  * Transforms a spidermonkey AST into a closure AST\n+  */\n+  private Node transform(AstNode spiderMonkeyNode) {\n+    TransformDispatcher dispatcher = new TransformDispatcher();\n+    return dispatcher.transform(spiderMonkeyNode);\n+  }\n+\n+  /**\n+  * Dispatches spidermonkey nodes to the appropriate transformer method.\n+  * @see com.google.javascript.rhino.TypeSafeDispatcher\n+  */\n+  private class TransformDispatcher implements NodeTransformer<AstNode> {\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node transform(AstNode node) {\n+        Token type = transformTokenType(node.getType());\n+        Node newNode = new Node(type);\n+        switch (type) {\n+            case SCRIPT:\n+                return transformScriptNode(node, newNode);\n+            case BLOCK:\n+                return transformBlockNode(node, newNode);\n+            case LABEL:\n+                return transformLabelNode(node, newNode);\n+            case WHILE:\n+                return transformWhileNode(node, newNode);\n+            case DO:\n+                return transformDoNode(node, newNode);\n+            case FOR:\n+                return transformForNode(node, newNode);\n+            case FOR_IN:\n+                return transformForInNode(node, newNode);\n+            case SWITCH:\n+                return transformSwitchNode(node, newNode);\n+            case CASE:\n+                return transformCaseNode(node, newNode);\n+            case DEFAULT_CASE:\n+                return transformDefaultCaseNode(node, newNode);\n+            case IF:\n+                return transformIfNode(node, newNode);\n+            case NAME:\n+                return transformNameNode(node);\n+            case NUMBER:\n+            case STRING:\n+            case TRUE:\n+            case FALSE:\n+            case NULL:\n+            case THIS:\n+            case REGEXP:\n+                return new Node(type, node.getString());\n+            case ARRAYLIT:\n+                return transformArrayLit(node, newNode);\n+            case OBJECTLIT:\n+                return transformObjectLit(node, newNode);\n+            case GETPROP:\n+                return transformPropAccess(node, newNode);\n+            case CALL:\n+                return transformCall(node, newNode);\n+            case FUNCTION:\n+                return transformFunction(node, newNode);\n+            case RETURN:\n+                return transformReturn(node, newNode);\n+            case VAR:\n+                return transformVariable(node, newNode);\n+            case ASSIGN:\n+                return transformAssign(node, newNode);\n+            case HOOK:\n+                return transformConditional(node, newNode);\n+            case OR:\n+            case AND:\n+                return transformLogical(node, newNode);\n+            case BITOR:\n+            case BITXOR:\n+            case BITAND:\n+                return transformBitOp(node, newNode);\n+            case EQ:\n+            case NE:\n+            case SHEQ:\n+            case SHNE:\n+            case LT:\n+            case GT:\n+            case LE:\n+            case GE:\n+                return transformBinary(node, newNode);\n+            case LSH:\n+            case RSH:\n+            case URSH:\n+            case ADD:\n+            case SUB:\n+            case MUL:\n+            case DIV:\n+            case MOD:\n+                return transformArith(node, newNode);\n+            case BITNOT:\n+            case NEG:\n+            case POS:\n+            case NOT:\n+                return transformUnary(node, newNode);\n+            case ARRAY_PATTERN:\n+                return transformArrayPattern(node, newNode);\n+            case OBJECT_PATTERN:\n+                return transformObjectPattern(node, newNode);\n+            case DEFAULT_VALUE:\n+                return transformDefaultValue(node, newNode);\n+            case REST:\n+                return transformRest(node, newNode);\n+            default:\n+                errorReporter.error(\"Unimplemented feature: \" + type, sourceName, node.getLineno(), \"\", 0);\n+                return newNode;\n+        }\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private Node transformScriptNode(AstNode node, Node newNode) {\n+        Token type = transformTokenType(node.getType());\n+        if (preserveAnnotations) {\n+            String src = node.toSource();\n+            newNode.setOriginalName(node.getJsDocNode().getOriginalCommentString());\n+            newNode.setStaticSourceFile(new SourceFile(sourceName, src));\n+            newNode.setSourceFileName(sourceName);\n+        }\n+        NodeUtil.addFeatureToScript(newNode, Feature.get(node.getJsDocNode()));\n+        List<AstNode> children = node.getDirectChildren();\n+        for (AstNode child : children) {\n+            newNode.addChildToBack(transform(child));\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    private Node transformBlockNode(AstNode node, Node newNode) {\n+        List<AstNode> children = node.getDirectChildren();\n+        for (AstNode child : children) {\n+            newNode.addChildToBack(transform(child));\n+        }\n+        return newNode;\n+    }\n+\n+    private Node transformLabelNode(AstNode node, Node newNode) {\n+        Token type = transformTokenType(node.getType());\n+        newNode.addChildToBack(newNode(type, node.getLabelName()));\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformWhileNode(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        newNode.addChildToBack(transformBlock(node.getSecondChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformDoNode(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transformBlock(node.getFirstChild()));\n+        newNode.addChildToBack(transform(node.getSecondChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformForNode(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        newNode.addChildToBack(transform(node.getSecondChild()));\n+        newNode.addChildToBack(transform(node.getThirdChild()));\n+        newNode.addChildToBack(transformBlock(node.getFourthChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformForInNode(AstNode node, Node newNode) {\n+        AstNode lhs = node.getFirstChild();\n+        AstNode rhs = node.getSecondChild();\n+        Node object = transform(rhs);\n+        Node body = transformBlock(node.getLastChild());\n+        Node result;\n+        if (lhs instanceof Name) {\n+            result = newNode(Token.FOR);\n+\n+            Node lhsNode = transform(lhs);\n+            lhsNode.setIsStatement(true);\n+\n+            result.addChildToBack(lhsNode);\n+            result.addChildToBack(object);\n+            result.addChildToBack(body);\n+        } else if (lhs instanceof InfixExpression && lhs.getType() == Token.LE) {\n+            AstNode lhsOperand = lhs.getFirstChild();\n+            AstNode rhsOperand = lhs.getLastChild();\n+            Node lhsNode = transform(lhsOperand);\n+            Node rhsNode = transform(rhsOperand);\n+            lhsNode.addChildToFront(new Node(Token.VAR, lhsNode.cloneTree()));\n+            Node lhsVarNode = lhsNode.getFirstChild();\n+            lhsVarNode.insertBefore(new Node(Token.ASSIGN, lhsVarNode.detachFromParent(), rhsNode));\n+            Node initializer = lhsNode.getFirstChild();\n+            lhsNode.removeChild(initializer);\n+            Node condition = newNode(Token.TRUE);\n+            Node increment = newNode(Token.EMPTY);\n+            result = newNode(Token.FOR);\n+            result.addChildToBack(initializer);\n+            result.addChildToBack(condition);\n+            result.addChildToBack(increment);\n+            result.addChildToBack(body);\n+        } else {\n+            result = newNode(Token.EMPTY);\n+            errorReporter.error(\n+                    \"Invalid left-hand side in for-in loop\",\n+                    sourceName,\n+                    lhs.getLineno(), \"\", 0);\n+        }\n+        return result;\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    private Node transformSwitchNode(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        List<AstNode> children = node.getDirectChildren();\n+        for (int i = 1; i < children.size(); i++) {\n+            AstNode child = children.get(i);\n+            if (child.getType() == Token.CASE) {\n+                newNode.addChildToBack(transform(child));\n+            }\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    private Node transformCaseNode(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        List<AstNode> children = node.getDirectChildren();\n+        for (int i = 1; i < children.size(); i++) {\n+            AstNode child = children.get(i);\n+            if (child.getType() != Token.CASE && child.getType() != Token.DEFAULT_CASE) {\n+                newNode.addChildToBack(transform(child));\n+            }\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    private Node transformDefaultCaseNode(AstNode node, Node newNode) {\n+        List<AstNode> children = node.getDirectChildren();\n+        for (AstNode child : children) {\n+            if (child.getType() != Token.CASE && child.getType() != Token.DEFAULT_CASE) {\n+                newNode.addChildToBack(transform(child));\n+            }\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    private Node transformIfNode(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        newNode.addChildToBack(transformBlock(node.getSecondChild()));\n+        if (node.getChildCount() == 3) {\n+            newNode.addChildToBack(transformBlock(node.getLastChild()));\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    private Node transformNameNode(AstNode node) {\n+        Token type = transformTokenType(node.getType());\n+        String identifier = getIdentifier(node);\n+        return new Node(type, identifier);\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    private Node transformArrayLit(AstNode node, Node newNode) {\n+        List<AstNode> children = node.getDirectChildren();\n+        for (AstNode child : children) {\n+            if (child.getType() == Token.COMMA) {\n+                newNode.addChildToBack(new Node(Token.EMPTY));\n+            } else {\n+                newNode.addChildToBack(transform(child));\n+            }\n+        }\n+        return newNode;\n+    }\n+\n+    private Node transformObjectLit(AstNode node, Node newNode) {\n+        List<AstNode> elements = node.getElements();\n+        for (AstNode element : elements) {\n+            if (element.getType() == Token.COMMA) {\n+                newNode.addChildToBack(new Node(Token.EMPTY));\n+            } else {\n+                Node child = transform(element);\n+                if (element instanceof PropertyGet) {\n+                    // Replace GETPROP with string.\n+                    child.removeChild(child.getLastChild());\n+                } else if (element instanceof XmlExpression) {\n+                    // Extract the expression and add ATTRIBUTE_NAME as a first child\n+                    AstNode childNode = Objects.requireNonNull(child.getFirstChild());\n+                    String propertyName = getIdentifier(childNode);\n+                    child = transform(childNode.getNext());\n+                    child.addChildToFront(new Node(Token.STRING_KEY, propertyName));\n+                }\n+                newNode.addChildToBack(child);\n+            }\n+        }\n+        return newNode;\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    private Node transformPropAccess(AstNode node, Node newNode) {\n+        Token type = transformTokenType(node.getType());\n+        String identifier = getIdentifier(node);\n+        newNode.addChildToBack(newNode(type, identifier));\n+        newNode.addChildToBack(transform(node.getLastChild()));\n+        return newNode;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    private Node transformCall(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        List<AstNode> children = node.getArguments();\n+        for (AstNode child : children) {\n+            newNode.addChildToBack(transform(child));\n+        }\n+        return newNode;\n+    }\n+\n+    private Node transformFunction(AstNode node, Node newNode) {\n+        Token type = transformTokenType(node.getType());\n+        newNode.setIsArrowFunction(node instanceof FunctionNode && ((FunctionNode) node).isArrowFunction());\n+        newNode.addChildToBack(newNode(Token.FUNCTION));\n+        newNode.addChildToBack(transform(node.getName()));\n+        List<AstNode> params;\n+        if (node instanceof FunctionNode) {\n+            params = ((FunctionNode) node).getParams();\n+        } else {\n+            params = node.getDirectChildren();\n+        }\n+        Node paramList = new Node(Token.PARAM_LIST);\n+        for (AstNode child : params) {\n+            paramList.addChildToBack(transform(child));\n+        }\n+        newNode.addChildToBack(paramList);\n+        newNode.addChildToBack(transform(node.getBody()));\n+        if (node instanceof FunctionNode) {\n+            FunctionNode fNode = (FunctionNode) node;\n+            boolean isExpression = fNode.getParent() != null &&\n+                    (fNode.getParent().getType() == Token.EXPR_RESULT ||\n+                            fNode.getParent().getType() == Token.VAR);\n+            newNode.setIsExpressionClosure(isExpression);\n+            if (fNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n+                newNode.setIsExpressionResult(true);\n+            }\n+        } else if (node.getType() == Token.FUNCTION) {\n+            newNode.setIsGeneratorFunction(node instanceof GeneratorExpression);\n+            newNode.setIsExpressionResult(true);\n+        }\n+        List<Comment> comments = node.getComments();\n+        for (Comment comment : comments) {\n+            newNode.addNonJSDocChild(newNode(Token.EMPTY, comment.getValue()));\n+        }\n+        return newNode;\n+    }\n+\n+    private Node transformReturn(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformVariable(AstNode node, Node newNode) {\n+        Token type = transformTokenType(node.getType());\n+        newNode.addChildToBack(newNode(Token.VAR));\n+        List<AstNode> children = node.getDirectChildren();\n+        for (AstNode child : children) {\n+            newNode.addChildToBack(transform(child));\n+        }\n+        return newNode;\n     }\n \n+    private Node transformAssign(AstNode node, Node newNode) {\n+        Token type = transformTokenType(node.getType());\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        newNode.addChildToBack(transform(node.getLastChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformConditional(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        newNode.addChildToBack(transform(node.getSecondChild()));\n+        newNode.addChildToBack(transform(node.getLastChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformLogical(AstNode node, Node newNode) {\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        newNode.addChildToBack(transform(node.getLastChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformBitOp(AstNode node, Node newNode) {\n+        Token type = transformTokenType(node.getType());\n+        newNode.addChildToBack(newNode(type));\n+        newNode.addChildToBack(transform(node.getFirstChild()));\n+        newNode.addChildToBack(transform(node.getLastChild()));\n+        return newNode;\n+    }\n+\n+    private Node transformBinary(AstNode node, Node newNode) {\n+        Token type = transformTokenType(nod\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}