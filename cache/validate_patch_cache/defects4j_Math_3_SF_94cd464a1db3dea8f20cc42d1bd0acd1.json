{
    "patch": "    public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n        final int len = a.length;\n        if (len != b.length) {\n            throw new DimensionMismatchException(len, b.length);\n        }\n        if (len == 1) {\n            // Handling special case when length of arrays is 1\n            return a[0] * b[0];\n        }\n        // Revert to scalar multiplication.\n        final double[] prodHigh = new double[len];\n        double prodLowSum = 0;\n        for (int i = 0; i < len; i++) {\n            final double ai = a[i];\n            final double ca = SPLIT_FACTOR * ai;\n            final double aHigh = ca - (ca - ai);\n            final double aLow = ai - aHigh;\n            final double bi = b[i];\n            final double cb = SPLIT_FACTOR * bi;\n            final double bHigh = cb - (cb - bi);\n            final double bLow = bi - bHigh;\n            prodHigh[i] = ai * bi;\n            final double prodLow = aLow * bLow - (((prodHigh[i] -\n                                                    aHigh * bHigh) -\n                                                   aLow * bHigh) -\n                                                  aHigh * bLow);\n            prodLowSum += prodLow;\n        }\n        double sHighPrev = prodHigh[0] + prodHigh[1];\n        double sPrime = sHighPrev - prodHigh[1];\n        double sLowSum = (prodHigh[1] - (sHighPrev - sPrime)) + (prodHigh[0] - sPrime);\n        final int lenMinusOne = len - 1;\n        for (int i = 1; i < lenMinusOne; i++) {\n            final double prodHighCur = prodHigh[i];\n            final double prodHighNext = prodHigh[i + 1];\n            final double sHighCur = sHighPrev + prodHighNext;\n            sPrime = sHighCur - prodHighNext;\n            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n            sHighPrev = sHighCur;\n        }\n        double result = sHighPrev + (prodLowSum + sLowSum);\n        if (Double.isNaN(result)) {\n            // either we have split infinite numbers or some coefficients were NaNs,\n            // just rely on the naive implementation and let IEEE754 handle this\n            result = 0;\n            for (int i = 0; i < len; ++i) {\n                result += a[i] * b[i];\n            }\n        }\n        return result;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..3d71d71a1 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -817,18 +817,18 @@ public class MathArrays {\n         if (len != b.length) {\n             throw new DimensionMismatchException(len, b.length);\n         }\n-\n-            // Revert to scalar multiplication.\n-\n+        if (len == 1) {\n+            // Handling special case when length of arrays is 1\n+            return a[0] * b[0];\n+        }\n+        // Revert to scalar multiplication.\n         final double[] prodHigh = new double[len];\n         double prodLowSum = 0;\n-\n         for (int i = 0; i < len; i++) {\n             final double ai = a[i];\n             final double ca = SPLIT_FACTOR * ai;\n             final double aHigh = ca - (ca - ai);\n             final double aLow = ai - aHigh;\n-\n             final double bi = b[i];\n             final double cb = SPLIT_FACTOR * bi;\n             final double bHigh = cb - (cb - bi);\n@@ -840,25 +840,19 @@ public class MathArrays {\n                                                   aHigh * bLow);\n             prodLowSum += prodLow;\n         }\n-\n-\n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n-\n+        double sHighPrev = prodHigh[0] + prodHigh[1];\n+        double sPrime = sHighPrev - prodHigh[1];\n+        double sLowSum = (prodHigh[1] - (sHighPrev - sPrime)) + (prodHigh[0] - sPrime);\n         final int lenMinusOne = len - 1;\n         for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n+            final double prodHighCur = prodHigh[i];\n+            final double prodHighNext = prodHigh[i + 1];\n             final double sHighCur = sHighPrev + prodHighNext;\n             sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n+            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n             sHighPrev = sHighCur;\n         }\n-\n         double result = sHighPrev + (prodLowSum + sLowSum);\n-\n         if (Double.isNaN(result)) {\n             // either we have split infinite numbers or some coefficients were NaNs,\n             // just rely on the naive implementation and let IEEE754 handle this\n@@ -867,7 +861,6 @@ public class MathArrays {\n                 result += a[i] * b[i];\n             }\n         }\n-\n         return result;\n     }\n ",
    "result_reason": "junit.framework.AssertionFailedError: expected:<-1.8551294182586249> but was:<-1.3404489300209106E16>",
    "test_result": "FAIL"
}