{
    "patch": "      // Functions with explicit 'this' types that are NOT called in a GETPROP\n      // or GETELEM must be treated with suspicion. Many global objects have\n      // a 'this' of type Object, which is unsafe.  If the function can also\n      // return a type that is not a subtype of the 'this' type, then it is\n      // definitely dangerous.\n\n      JSType thisType = functionType.getTypeOfThis();\n      if (thisType != null && !thisType.isUnknownType()) {\n        JSTypeRegistry registry = t.getCompiler().getTypeRegistry();\n\n        JSType objectType = registry.getNativeObjectType(\n            registry.getNativeType(JSTypeNative.OBJECT_TYPE));\n\n        ObjectType thisObjectType = thisType.autobox().toMaybeObjectType();\n        if (thisObjectType == null) {\n          // The function specifies a non-object 'this' type, so there is no way\n          // that this call could be used to violate the static contract.\n          // TODO: Actually there is still a risk if the function returns a subtype\n          // of 'thisType' that does not override all properties/methods.\n          // We cannot check it now because subtype information of function\n          // result type is not available yet in this method.\n          // Because of this we have to skip the return check by not calling\n          // ensureTyped in that case.\n        } else if (!thisObjectType.isEquivalentTo(objectType)) {\n          Node parent = n.getParent();\n          if (parent.isGetProp() || parent.isGetElem()) {\n            ensureTyped(t, n, functionType.getReturnType());\n          } else {\n            ObjectType returnTypeObject = functionType.getReturnType().autobox().toMaybeObjectType();\n            if (returnTypeObject != null && !thisObjectType.isSubclassOf(returnTypeObject)) {\n              report(t, n, INVALID_THIS_TYPE, returnTypeObject.toString(), thisObjectType.toString());\n            }\n            else {\n              ensureTyped(t, n, functionType.getReturnType());\n            }\n          }\n        }\n      }\n\n      visitParameterList(t, n, functionType);\n      if (thisType == null || thisType.isUnknownType() || thisType.isAnyType()) {\n        ensureTyped(t, n, functionType.getReturnType());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..cec76d87 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,48 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+      // Functions with explicit 'this' types that are NOT called in a GETPROP\n+      // or GETELEM must be treated with suspicion. Many global objects have\n+      // a 'this' of type Object, which is unsafe.  If the function can also\n+      // return a type that is not a subtype of the 'this' type, then it is\n+      // definitely dangerous.\n+\n+      JSType thisType = functionType.getTypeOfThis();\n+      if (thisType != null && !thisType.isUnknownType()) {\n+        JSTypeRegistry registry = t.getCompiler().getTypeRegistry();\n+\n+        JSType objectType = registry.getNativeObjectType(\n+            registry.getNativeType(JSTypeNative.OBJECT_TYPE));\n+\n+        ObjectType thisObjectType = thisType.autobox().toMaybeObjectType();\n+        if (thisObjectType == null) {\n+          // The function specifies a non-object 'this' type, so there is no way\n+          // that this call could be used to violate the static contract.\n+          // TODO: Actually there is still a risk if the function returns a subtype\n+          // of 'thisType' that does not override all properties/methods.\n+          // We cannot check it now because subtype information of function\n+          // result type is not available yet in this method.\n+          // Because of this we have to skip the return check by not calling\n+          // ensureTyped in that case.\n+        } else if (!thisObjectType.isEquivalentTo(objectType)) {\n+          Node parent = n.getParent();\n+          if (parent.isGetProp() || parent.isGetElem()) {\n+            ensureTyped(t, n, functionType.getReturnType());\n+          } else {\n+            ObjectType returnTypeObject = functionType.getReturnType().autobox().toMaybeObjectType();\n+            if (returnTypeObject != null && !thisObjectType.isSubclassOf(returnTypeObject)) {\n+              report(t, n, INVALID_THIS_TYPE, returnTypeObject.toString(), thisObjectType.toString());\n+            }\n+            else {\n+              ensureTyped(t, n, functionType.getReturnType());\n+            }\n+          }\n+        }\n+      }\n+\n+      visitParameterList(t, n, functionType);\n+      if (thisType == null || thisType.isUnknownType() || thisType.isAnyType()) {\n+        ensureTyped(t, n, functionType.getReturnType());\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}