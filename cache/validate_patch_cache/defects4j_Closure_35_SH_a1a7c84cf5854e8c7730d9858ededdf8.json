{
    "patch": "package com.google.javascript.jscomp;\n\nimport com.google.common.collect.ImmutableMap;\nimport com.google.javascript.jscomp.AbstractCompiler.LintingPass;\nimport com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.NodeTraversal.ChangeScopeRootCallback;\nimport com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.rhino.InputId;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.JSDocInfoBuilder;\nimport com.google.javascript.rhino.JSModule;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.StaticScope;\nimport com.google.javascript.rhino.StaticSourceFile;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.TypeI;\nimport com.google.javascript.rhino.TypeIRegistry;\nimport com.google.javascript.rhino.jstype.JSType;\nimport com.google.javascript.rhino.jstype.JSTypeNative;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\nimport com.google.javascript.rhino.jstype.NamedType;\nimport com.google.javascript.rhino.jstype.NullType;\nimport com.google.javascript.rhino.jstype.ObjectType;\nimport com.google.javascript.rhino.jstype.TemplatizedType;\nimport com.google.javascript.rhino.jstype.UnionType;\nimport java.io.Serializable;\nimport java.util.ArrayDeque;\nimport java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.Comparator;\nimport java.util.Deque;\nimport java.util.HashMap;\nimport java.util.HashSet;\nimport java.util.IdentityHashMap;\nimport java.util.LinkedHashMap;\nimport java.util.LinkedHashSet;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Map;\nimport java.util.Objects;\nimport java.util.Queue;\nimport java.util.Set;\nimport java.util.SortedSet;\nimport java.util.TreeSet;\nimport java.util.function.Consumer;\nimport javax.annotation.Nullable;\n\n/**\n * Eliminates code that can never be executed.\n *\n * <p>This implementation uses a preprocessor to eliminate blocks of code quickly, without having\n * to traverse the whole AST. Blocks of code that are not entirely removed by the preprocessor are\n * later traversed again ({@link #process}), this time using a {@link ControlFlowGraph}.\n *\n * <p>The CFG is used to calculate if a basic block can be entirely removed, by merging blocks\n * reachable from the start node with the end block of the basic block being analyzed. This is\n * repeated to eliminate as many blocks as possible. If a block is eliminated, the edges going into\n * that block are re-connected to the incoming block of the predecessor block, or the start node.\n *\n * <p>Blocks of code that are within the scope of variable declarations can be eliminated only if no\n * code within the block can throw an exception. Otherwise, those blocks of code are transformed to\n * blocks where the declarations and the first executable statement are separated.\n *\n * <p>This pass can create unused parameters since an entire function/property can be removed and\n * the corresponding function schema (argument names and return types) are not updated.\n *\n * <p>It can also generate type violations if the code is incorrect.\n *\n * <p>This pass is a LINT pass because it only removes code, which should not change the runtime\n * behavior other than throwing a ReferenceError in dev mode. However, there are tests\n * (testRemoveUnreachableCode3 and testRemoveUnreachableCode4) which show that some code will throw\n * a ReferenceError in dev mode.\n */\nclass UnreachableCodeElimination extends AbstractPostOrderCallback\n    implements ScopedCallback, LintingPass {\n\n  private final AbstractCompiler compiler;\n  private final List<Node> allNodesWithVars = new ArrayList<>();\n  private final Map<String, FunctionInfo> functionMap = new LinkedHashMap<>();\n  private final ControlFlowGraph<Node> cfg = new ControlFlowGraph<>();\n  private final Deque<IfInfo> ifInfoStack = new ArrayDeque<>();\n  private final JSTypeRegistry typeRegistry;\n  private final Set<String> changedFunctionNames = new HashSet<>();\n\n  private boolean compilerAllowsMethodCallDecomposing;\n  private boolean compilerAllowsObjectSpread;\n  private Node rootNode = null;\n\n  private static class FunctionInfo {\n    final JSType returnType;\n    final ImmutableMap<String, JSType> arguments;\n\n    FunctionInfo(JSType returnType, ImmutableMap<String, JSType> arguments) {\n      this.returnType = returnType;\n      this.arguments = arguments;\n    }\n\n    @Override\n    public boolean equals(Object other) {\n      if (this == other) {\n        return true;\n      }\n      if (!(other instanceof FunctionInfo)) {\n        return false;\n      }\n      FunctionInfo otherFinfo = (FunctionInfo) other;\n      return returnType.equals(otherFinfo.returnType) && arguments.equals(otherFinfo.arguments);\n    }\n\n    @Override\n    public int hashCode() {\n      return Objects.hash(returnType, arguments);\n    }\n  }\n\n  /**\n   * Information about multi-level if statements.\n   *\n   * <p>We need to keep track of labels, blocks, and nodes that correspond to:\n   *\n   * <ol>\n   *   <li>the entire if block\n   *   <li>if's \"then\" block\n   *   <li>if's optional \"else\" block\n   * </ol>\n   *\n   * <p>All three labels are present in the node hierarchy if there is an else block:\n   *\n   * <pre>\n   * IFNODE     -- if block's label\n   * \u251c\u2500\u2500 BLOCK -- then block's label\n   * \u2514\u2500\u2500 BLOCK -- else block's label that hangs off the \"IFNODE\"\n   *     \u2514\u2500\u2500 BLOCK -- else block's label nested inside the \"else\" subtree\n   * </pre>\n   *\n   * <p>The top of the ifInfoStack contains information about the outermost if label, the second\n   * one from the top corresponds to the current if statement being traversed, etc.\n   */\n  private static class IfInfo {\n    final String topLevelIfLabel;\n    final String ifBlockLabel;\n    final String thenBlockLabel;\n    /** {@code null} if there is no ELSE part of the clause. */\n    @Nullable final String elseBlockLabel;\n\n    public IfInfo(\n        String topLevelIfLabel,\n        String ifBlockLabel,\n        String thenBlockLabel,\n        @Nullable String elseBlockLabel) {\n      this.topLevelIfLabel = topLevelIfLabel;\n      this.ifBlockLabel = ifBlockLabel;\n      this.thenBlockLabel = thenBlockLabel;\n      this.elseBlockLabel = elseBlockLabel;\n    }\n    /** True if there is no nested ELSE statement inside the top-level IF block. */\n    boolean isLastStatementInTopLevelIf() {\n      return topLevelIfLabel.equals(ifBlockLabel);\n    }\n  }\n\n  private class Preprocessor implements Callback, ChangeScopeRootCallback {\n    private boolean currentScriptIsModule = false;\n    private String currentSourceName = \"\";\n\n    private final PriorityQueue<Block> blocksToKeep = new PriorityQueue<>();\n    private final Map<BasicBlock, Block> basicBlockToBlock = new IdentityHashMap<>();\n    private final Deque<Block> blockStack = new ArrayDeque<>();\n\n    /**\n     * Adds a new top-level block to the CFG.\n     *\n     * <p>It is a block outside any functions or IF statements.\n     */\n    private void startTopLevelBlock(NodeTraversal t) {\n      final Node start = cfg.createEntry();\n      final Node end = cfg.createNode(Token.BLOCK);\n      final BasicBlock<Node> basic = new BasicBlock<>(start, end);\n      cfg.addBasicBlock(basic);\n      cfg.connect(end, cfg.createExit());\n\n      Block block = new Block(basic);\n\n      blocksToKeep.offer(block);\n      basicBlockToBlock.put(basic, block);\n      blockStack.push(block);\n      rootNode = end;\n      processNode(start);\n    }\n\n    private Block getCurrentBlock() {\n      return blockStack.peek();\n    }\n\n    private void finishCurrentBlock(Node endNode) {\n      Block block = getCurrentBlock();\n      cfg.connect(block.getBasicBlock().getLastNode(), endNode);\n      Node exit = block.getBasicBlock().getEnd().getFirstChild();\n      boolean isReachable = block.processExitNode(exit);\n      blockStack.pop();\n\n      if (isReachable || !block.containsCleanup) {\n        blocksToKeep.offer(block);\n        for (BasicBlock<Node> reach : cfg.getDirectedGraph().getReachable(basicBlockToBlock.get(block.getBasicBlock()))) {\n          Block toKeep = basicBlockToBlock.get(reach);\n          if (toKeep != null) {\n            blocksToKeep.offer(toKeep);\n          }\n        }\n      }\n    }\n\n    /**\n     * Start a new block for a numbered statement within an IF statement.\n     *\n     * <p>If the previous numbered statement was not reachable, the new block's start node will be\n     * unreachable.\n     *\n     * @param numberedConstant The constant attached to the {@code number} node\n     * @param n The start node of the block\n     * @return true if a new block was started. false if the start node should be processed in the\n     *     current block.\n     */\n    private boolean startNewNumberedBlockIf(int numberedConstant, Node n) {\n      Block previous = getCurrentBlock();\n      Node condition = n.getFirstChild();\n      BasicBlock<Node> ifBlock = cfg.createBasicBlock(condition);\n      cfg.addBasicBlock(ifBlock);\n      IfInfo currentIfInfo = ifInfoStack.peekLast();\n\n      // If the condition matches either true or false passed as function argument, the condition\n      // is always truthy.\n      boolean conditionTruthyAlways =\n          currentIfInfo != null\n              && isFunctionArgument(currentIfInfo.arguments, condition)\n              && (constantFoldsToTrue(condition.getNext(), numberedConstant)\n                  || constantFoldsToFalse(condition.getNext(), numberedConstant));\n      boolean lastStatementInTopLevelIf =\n          currentIfInfo != null && currentIfInfo.isLastStatementInTopLevelIf();\n      boolean needToConnectToPreviousBlock =\n          !previous.getBasicBlock().isEmpty() && !previous.containsCleanup;\n\n      boolean isReachable = previous.isReachable();\n      if (!isReachable && !needToConnectToPreviousBlock && !conditionTruthyAlways) {\n        ifNodeRemoved(n);\n        return true;\n      }\n      boolean hasElse =\n          NodeUtil.isStatementBlock(n.getNext()) && NodeUtil.isStatementBlock(n.getNext().getNext());\n\n      Node thenBranch = n.getNext().getFirstChild();\n      Node elseBranch = hasElse ? n.getNext().getNext().getFirstChild() : null;\n      Node ifEnd = hasElse ? n.getNext().getNext().getLastChild() : n.getNext().getLastChild();\n\n      final Node endNode = cfg.createNode(Token.BLOCK, ifEnd);\n      BasicBlock<Node> endBlock = cfg.createBasicBlock(endNode);\n      cfg.addBasicBlock(endBlock);\n      cfg.connect(endNode, cfg.createExit());\n\n      // Used for testing purposes only.\n      if (isTrackingIfTestExpressions() && !conditionTruthyAlways) {\n        testExpressions.add(new TestExpression(condition, thenBranch, elseBranch));\n      }\n\n      BasicBlock<Node> elseBlock = null;\n      if (hasElse) {\n        elseBlock = cfg.createBasicBlock(elseBranch);\n        cfg.addBasicBlock(elseBlock);\n        if (isReachable || conditionTruthyAlways) {\n          previous = previous.setCheckedSuccessorsCount(2);\n          cfg.connect(previous.getBasicBlock().getLastNode(), ifBlock);\n        } else {\n          // Copy the checked successors from the previous block so that the n.getNext().getNext()\n          // block can have this information in its else branch. It's not clear if this can\n          // actually happen, but making this logic smart to handle all possible scenarios may be\n          // difficult.\n          //\n          // Also, we don't want to connect the previous which is unreachable to ifBlock such that\n          // the enter/exit nodes of unreachable blocks don't get erroneously connected.\n          checkState(needToConnectToPreviousBlock);\n          previous.incrementUncheckedSuccessors();\n        }\n        previous = basicBlockToBlock.get(elseBlock);\n        cfg.connect(ifBlock, endBlock);\n      } else {\n        previous = previous.setCheckedSuccessorsCount(1);\n        if (lastStatementInTopLevelIf && isReachable) {\n          // Cut out a chain of blocks created by if1();if2();if3();..\n          cfg.connect(previous.getBasicBlock().getLastNode(), ifBlock);\n          previous = basicBlockToBlock.get(ifBlock);\n        } else {\n          cfg.connect(previous.getBasicBlock().getLastNode(), ifBlock);\n        }\n        cfg.connect(ifBlock, endBlock);\n        previous = basicBlockToBlock.get(ifBlock);\n      }\n      previous.processEnterNode(condition);\n      blockStack.push(previous);\n\n      if (hasElse) {\n        nodeStack.push(elseBranch);\n        basicBlockToBlock.put(elseBlock, previous);\n        IfInfo info =\n            new IfInfo(\n                currentIfInfo == null ? \"\" : currentIfInfo.topLevelIfLabel,\n                currentIfInfo == null ? \"\" : currentIfInfo.ifBlockLabel,\n                previous.getBasicBlock().getLabel(),\n                endBlock.getLabel());\n        ifInfoStack.addLast(info);\n      } else {\n        nodeStack.push(thenBranch);\n        if (lastStatementInTopLevelIf && isReachable) {\n          // The last THEN branch in an top-level IF statement will never execute if the IF and all\n          // previous THEN statements evaluate to a constant false, so we fast forward if we encounter\n          // this branch.\n          cfg.connect(previous.getBasicBlock().getLastNode(), endBlock);\n        }\n      }\n\n      basicBlockToBlock.put(ifBlock, previous);\n      basicBlockToBlock.put(endBlock, previous);\n      return false;\n    }\n\n    /**\n     * Removes a NODE connected to the IF condition. The node is assumed to be unreachable.\n     *\n     * <p>Cuts the edges between the node and its predecessors. If the node is the only statement\n     * in an IF's THEN block, add a placeholder block instead of the empty THEN block.\n     *\n     * <p>For example, the code block below contains an unreachable variable declaration \"var s2 =\n     * s1;\", the \"THEN\" part of the IF statement contains no statements, and the \"ELSE\" part is\n     * non-null.\n     *\n     * <pre>\n     * if (condition) { // start IF block\n     *   var s1 = \"1\";\n     *   var s2 = s1;\n     * } else {\n     *   var s3 = \"2\";\n     * }\n     * </pre>\n     *\n     * Transform it into:\n     *\n     * <pre>\n     * if (condition) {\n     *   var s1 = \"1\";\n     * } else {\n     *   var s3 = \"2\";\n     * }\n     * </pre>\n     *\n     * <p>If the block being removed contains any declaration with an initializer requiring a type,\n     * add a bailout block to the front of the else block as follows:\n     *\n     * <pre>\n     * if (condition) { // start IF block\n     *   var s1 = /** @type {string} / (\"1\" + \"1\");\n     *   if (goog.isString(s1)) {\n     *     var s2 = s1;\n     *   }\n     * } else {\n     *  void 0;\n     *  var s4;\n     *  var s3 = \"2\";\n     *  s4 = s3;\n     * }\n     * </pre>\n     *\n     * Transform it into:\n     *\n     * <pre>\n     * if (condition) {\n     *   var s1 = /** ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e10920..92c10b8a 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1118,22 +1118,385 @@ class TypeInference\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n+package com.google.javascript.jscomp;\n+\n+import com.google.common.collect.ImmutableMap;\n+import com.google.javascript.jscomp.AbstractCompiler.LintingPass;\n+import com.google.javascript.jscomp.NodeTraversal.AbstractPostOrderCallback;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.jscomp.NodeTraversal.ChangeScopeRootCallback;\n+import com.google.javascript.jscomp.NodeTraversal.ScopedCallback;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.rhino.InputId;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfoBuilder;\n+import com.google.javascript.rhino.JSModule;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.StaticScope;\n+import com.google.javascript.rhino.StaticSourceFile;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.TypeI;\n+import com.google.javascript.rhino.TypeIRegistry;\n+import com.google.javascript.rhino.jstype.JSType;\n+import com.google.javascript.rhino.jstype.JSTypeNative;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n+import com.google.javascript.rhino.jstype.NamedType;\n+import com.google.javascript.rhino.jstype.NullType;\n+import com.google.javascript.rhino.jstype.ObjectType;\n+import com.google.javascript.rhino.jstype.TemplatizedType;\n+import com.google.javascript.rhino.jstype.UnionType;\n+import java.io.Serializable;\n+import java.util.ArrayDeque;\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.Comparator;\n+import java.util.Deque;\n+import java.util.HashMap;\n+import java.util.HashSet;\n+import java.util.IdentityHashMap;\n+import java.util.LinkedHashMap;\n+import java.util.LinkedHashSet;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Map;\n+import java.util.Objects;\n+import java.util.Queue;\n+import java.util.Set;\n+import java.util.SortedSet;\n+import java.util.TreeSet;\n+import java.util.function.Consumer;\n+import javax.annotation.Nullable;\n+\n+/**\n+ * Eliminates code that can never be executed.\n+ *\n+ * <p>This implementation uses a preprocessor to eliminate blocks of code quickly, without having\n+ * to traverse the whole AST. Blocks of code that are not entirely removed by the preprocessor are\n+ * later traversed again ({@link #process}), this time using a {@link ControlFlowGraph}.\n+ *\n+ * <p>The CFG is used to calculate if a basic block can be entirely removed, by merging blocks\n+ * reachable from the start node with the end block of the basic block being analyzed. This is\n+ * repeated to eliminate as many blocks as possible. If a block is eliminated, the edges going into\n+ * that block are re-connected to the incoming block of the predecessor block, or the start node.\n+ *\n+ * <p>Blocks of code that are within the scope of variable declarations can be eliminated only if no\n+ * code within the block can throw an exception. Otherwise, those blocks of code are transformed to\n+ * blocks where the declarations and the first executable statement are separated.\n+ *\n+ * <p>This pass can create unused parameters since an entire function/property can be removed and\n+ * the corresponding function schema (argument names and return types) are not updated.\n+ *\n+ * <p>It can also generate type violations if the code is incorrect.\n+ *\n+ * <p>This pass is a LINT pass because it only removes code, which should not change the runtime\n+ * behavior other than throwing a ReferenceError in dev mode. However, there are tests\n+ * (testRemoveUnreachableCode3 and testRemoveUnreachableCode4) which show that some code will throw\n+ * a ReferenceError in dev mode.\n+ */\n+class UnreachableCodeElimination extends AbstractPostOrderCallback\n+    implements ScopedCallback, LintingPass {\n+\n+  private final AbstractCompiler compiler;\n+  private final List<Node> allNodesWithVars = new ArrayList<>();\n+  private final Map<String, FunctionInfo> functionMap = new LinkedHashMap<>();\n+  private final ControlFlowGraph<Node> cfg = new ControlFlowGraph<>();\n+  private final Deque<IfInfo> ifInfoStack = new ArrayDeque<>();\n+  private final JSTypeRegistry typeRegistry;\n+  private final Set<String> changedFunctionNames = new HashSet<>();\n+\n+  private boolean compilerAllowsMethodCallDecomposing;\n+  private boolean compilerAllowsObjectSpread;\n+  private Node rootNode = null;\n+\n+  private static class FunctionInfo {\n+    final JSType returnType;\n+    final ImmutableMap<String, JSType> arguments;\n+\n+    FunctionInfo(JSType returnType, ImmutableMap<String, JSType> arguments) {\n+      this.returnType = returnType;\n+      this.arguments = arguments;\n+    }\n+\n+    @Override\n+    public boolean equals(Object other) {\n+      if (this == other) {\n+        return true;\n+      }\n+      if (!(other instanceof FunctionInfo)) {\n+        return false;\n+      }\n+      FunctionInfo otherFinfo = (FunctionInfo) other;\n+      return returnType.equals(otherFinfo.returnType) && arguments.equals(otherFinfo.arguments);\n+    }\n+\n+    @Override\n+    public int hashCode() {\n+      return Objects.hash(returnType, arguments);\n+    }\n+  }\n+\n+  /**\n+   * Information about multi-level if statements.\n+   *\n+   * <p>We need to keep track of labels, blocks, and nodes that correspond to:\n+   *\n+   * <ol>\n+   *   <li>the entire if block\n+   *   <li>if's \"then\" block\n+   *   <li>if's optional \"else\" block\n+   * </ol>\n+   *\n+   * <p>All three labels are present in the node hierarchy if there is an else block:\n+   *\n+   * <pre>\n+   * IFNODE     -- if block's label\n+   * \u251c\u2500\u2500 BLOCK -- then block's label\n+   * \u2514\u2500\u2500 BLOCK -- else block's label that hangs off the \"IFNODE\"\n+   *     \u2514\u2500\u2500 BLOCK -- else block's label nested inside the \"else\" subtree\n+   * </pre>\n+   *\n+   * <p>The top of the ifInfoStack contains information about the outermost if label, the second\n+   * one from the top corresponds to the current if statement being traversed, etc.\n+   */\n+  private static class IfInfo {\n+    final String topLevelIfLabel;\n+    final String ifBlockLabel;\n+    final String thenBlockLabel;\n+    /** {@code null} if there is no ELSE part of the clause. */\n+    @Nullable final String elseBlockLabel;\n+\n+    public IfInfo(\n+        String topLevelIfLabel,\n+        String ifBlockLabel,\n+        String thenBlockLabel,\n+        @Nullable String elseBlockLabel) {\n+      this.topLevelIfLabel = topLevelIfLabel;\n+      this.ifBlockLabel = ifBlockLabel;\n+      this.thenBlockLabel = thenBlockLabel;\n+      this.elseBlockLabel = elseBlockLabel;\n+    }\n+    /** True if there is no nested ELSE statement inside the top-level IF block. */\n+    boolean isLastStatementInTopLevelIf() {\n+      return topLevelIfLabel.equals(ifBlockLabel);\n+    }\n+  }\n+\n+  private class Preprocessor implements Callback, ChangeScopeRootCallback {\n+    private boolean currentScriptIsModule = false;\n+    private String currentSourceName = \"\";\n+\n+    private final PriorityQueue<Block> blocksToKeep = new PriorityQueue<>();\n+    private final Map<BasicBlock, Block> basicBlockToBlock = new IdentityHashMap<>();\n+    private final Deque<Block> blockStack = new ArrayDeque<>();\n+\n+    /**\n+     * Adds a new top-level block to the CFG.\n+     *\n+     * <p>It is a block outside any functions or IF statements.\n+     */\n+    private void startTopLevelBlock(NodeTraversal t) {\n+      final Node start = cfg.createEntry();\n+      final Node end = cfg.createNode(Token.BLOCK);\n+      final BasicBlock<Node> basic = new BasicBlock<>(start, end);\n+      cfg.addBasicBlock(basic);\n+      cfg.connect(end, cfg.createExit());\n+\n+      Block block = new Block(basic);\n+\n+      blocksToKeep.offer(block);\n+      basicBlockToBlock.put(basic, block);\n+      blockStack.push(block);\n+      rootNode = end;\n+      processNode(start);\n+    }\n+\n+    private Block getCurrentBlock() {\n+      return blockStack.peek();\n+    }\n+\n+    private void finishCurrentBlock(Node endNode) {\n+      Block block = getCurrentBlock();\n+      cfg.connect(block.getBasicBlock().getLastNode(), endNode);\n+      Node exit = block.getBasicBlock().getEnd().getFirstChild();\n+      boolean isReachable = block.processExitNode(exit);\n+      blockStack.pop();\n+\n+      if (isReachable || !block.containsCleanup) {\n+        blocksToKeep.offer(block);\n+        for (BasicBlock<Node> reach : cfg.getDirectedGraph().getReachable(basicBlockToBlock.get(block.getBasicBlock()))) {\n+          Block toKeep = basicBlockToBlock.get(reach);\n+          if (toKeep != null) {\n+            blocksToKeep.offer(toKeep);\n           }\n         }\n       }\n     }\n+\n+    /**\n+     * Start a new block for a numbered statement within an IF statement.\n+     *\n+     * <p>If the previous numbered statement was not reachable, the new block's start node will be\n+     * unreachable.\n+     *\n+     * @param numberedConstant The constant attached to the {@code number} node\n+     * @param n The start node of the block\n+     * @return true if a new block was started. false if the start node should be processed in the\n+     *     current block.\n+     */\n+    private boolean startNewNumberedBlockIf(int numberedConstant, Node n) {\n+      Block previous = getCurrentBlock();\n+      Node condition = n.getFirstChild();\n+      BasicBlock<Node> ifBlock = cfg.createBasicBlock(condition);\n+      cfg.addBasicBlock(ifBlock);\n+      IfInfo currentIfInfo = ifInfoStack.peekLast();\n+\n+      // If the condition matches either true or false passed as function argument, the condition\n+      // is always truthy.\n+      boolean conditionTruthyAlways =\n+          currentIfInfo != null\n+              && isFunctionArgument(currentIfInfo.arguments, condition)\n+              && (constantFoldsToTrue(condition.getNext(), numberedConstant)\n+                  || constantFoldsToFalse(condition.getNext(), numberedConstant));\n+      boolean lastStatementInTopLevelIf =\n+          currentIfInfo != null && currentIfInfo.isLastStatementInTopLevelIf();\n+      boolean needToConnectToPreviousBlock =\n+          !previous.getBasicBlock().isEmpty() && !previous.containsCleanup;\n+\n+      boolean isReachable = previous.isReachable();\n+      if (!isReachable && !needToConnectToPreviousBlock && !conditionTruthyAlways) {\n+        ifNodeRemoved(n);\n+        return true;\n+      }\n+      boolean hasElse =\n+          NodeUtil.isStatementBlock(n.getNext()) && NodeUtil.isStatementBlock(n.getNext().getNext());\n+\n+      Node thenBranch = n.getNext().getFirstChild();\n+      Node elseBranch = hasElse ? n.getNext().getNext().getFirstChild() : null;\n+      Node ifEnd = hasElse ? n.getNext().getNext().getLastChild() : n.getNext().getLastChild();\n+\n+      final Node endNode = cfg.createNode(Token.BLOCK, ifEnd);\n+      BasicBlock<Node> endBlock = cfg.createBasicBlock(endNode);\n+      cfg.addBasicBlock(endBlock);\n+      cfg.connect(endNode, cfg.createExit());\n+\n+      // Used for testing purposes only.\n+      if (isTrackingIfTestExpressions() && !conditionTruthyAlways) {\n+        testExpressions.add(new TestExpression(condition, thenBranch, elseBranch));\n+      }\n+\n+      BasicBlock<Node> elseBlock = null;\n+      if (hasElse) {\n+        elseBlock = cfg.createBasicBlock(elseBranch);\n+        cfg.addBasicBlock(elseBlock);\n+        if (isReachable || conditionTruthyAlways) {\n+          previous = previous.setCheckedSuccessorsCount(2);\n+          cfg.connect(previous.getBasicBlock().getLastNode(), ifBlock);\n+        } else {\n+          // Copy the checked successors from the previous block so that the n.getNext().getNext()\n+          // block can have this information in its else branch. It's not clear if this can\n+          // actually happen, but making this logic smart to handle all possible scenarios may be\n+          // difficult.\n+          //\n+          // Also, we don't want to connect the previous which is unreachable to ifBlock such that\n+          // the enter/exit nodes of unreachable blocks don't get erroneously connected.\n+          checkState(needToConnectToPreviousBlock);\n+          previous.incrementUncheckedSuccessors();\n+        }\n+        previous = basicBlockToBlock.get(elseBlock);\n+        cfg.connect(ifBlock, endBlock);\n+      } else {\n+        previous = previous.setCheckedSuccessorsCount(1);\n+        if (lastStatementInTopLevelIf && isReachable) {\n+          // Cut out a chain of blocks created by if1();if2();if3();..\n+          cfg.connect(previous.getBasicBlock().getLastNode(), ifBlock);\n+          previous = basicBlockToBlock.get(ifBlock);\n+        } else {\n+          cfg.connect(previous.getBasicBlock().getLastNode(), ifBlock);\n+        }\n+        cfg.connect(ifBlock, endBlock);\n+        previous = basicBlockToBlock.get(ifBlock);\n+      }\n+      previous.processEnterNode(condition);\n+      blockStack.push(previous);\n+\n+      if (hasElse) {\n+        nodeStack.push(elseBranch);\n+        basicBlockToBlock.put(elseBlock, previous);\n+        IfInfo info =\n+            new IfInfo(\n+                currentIfInfo == null ? \"\" : currentIfInfo.topLevelIfLabel,\n+                currentIfInfo == null ? \"\" : currentIfInfo.ifBlockLabel,\n+                previous.getBasicBlock().getLabel(),\n+                endBlock.getLabel());\n+        ifInfoStack.addLast(info);\n+      } else {\n+        nodeStack.push(thenBranch);\n+        if (lastStatementInTopLevelIf && isReachable) {\n+          // The last THEN branch in an top-level IF statement will never execute if the IF and all\n+          // previous THEN statements evaluate to a constant false, so we fast forward if we encounter\n+          // this branch.\n+          cfg.connect(previous.getBasicBlock().getLastNode(), endBlock);\n+        }\n+      }\n+\n+      basicBlockToBlock.put(ifBlock, previous);\n+      basicBlockToBlock.put(endBlock, previous);\n+      return false;\n+    }\n+\n+    /**\n+     * Removes a NODE connected to the IF condition. The node is assumed to be unreachable.\n+     *\n+     * <p>Cuts the edges between the node and its predecessors. If the node is the only statement\n+     * in an IF's THEN block, add a placeholder block instead of the empty THEN block.\n+     *\n+     * <p>For example, the code block below contains an unreachable variable declaration \"var s2 =\n+     * s1;\", the \"THEN\" part of the IF statement contains no statements, and the \"ELSE\" part is\n+     * non-null.\n+     *\n+     * <pre>\n+     * if (condition) { // start IF block\n+     *   var s1 = \"1\";\n+     *   var s2 = s1;\n+     * } else {\n+     *   var s3 = \"2\";\n+     * }\n+     * </pre>\n+     *\n+     * Transform it into:\n+     *\n+     * <pre>\n+     * if (condition) {\n+     *   var s1 = \"1\";\n+     * } else {\n+     *   var s3 = \"2\";\n+     * }\n+     * </pre>\n+     *\n+     * <p>If the block being removed contains any declaration with an initializer requiring a type,\n+     * add a bailout block to the front of the else block as follows:\n+     *\n+     * <pre>\n+     * if (condition) { // start IF block\n+     *   var s1 = /** @type {string} / (\"1\" + \"1\");\n+     *   if (goog.isString(s1)) {\n+     *     var s2 = s1;\n+     *   }\n+     * } else {\n+     *  void 0;\n+     *  var s4;\n+     *  var s3 = \"2\";\n+     *  s4 = s3;\n+     * }\n+     * </pre>\n+     *\n+     * Transform it into:\n+     *\n+     * <pre>\n+     * if (condition) {\n+     *   var s1 = /** \n+    }\n   }\n \n   /**",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}