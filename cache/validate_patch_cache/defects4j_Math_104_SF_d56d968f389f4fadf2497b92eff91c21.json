{
    "patch": "public static double regularizedGammaP(double a, double x) {\n    if (Double.isInfinite(a) || Double.isInfinite(x)) {\n        return Double.NaN;\n    }\n    if (a <= 0.0 || x < 0.0) {\n        return Double.NaN;\n    }\n    if (x == 0.0) {\n        return 0.0;\n    }\n    if (x >= a + GAMMA_XBIG) {\n        return 1.0;\n    }\n\n    double ret = 0.0;\n    boolean finiteSum = false;\n    double term = a * Math.log(x) - x - lnGamma(a);\n    if (term < -Precision.LIBRARY_2BIG) {\n        return 0.0;\n    }\n    term = Math.exp(term);\n    ret = term;\n    int i = 0;\n    while (i < MAX_ITERATION) {\n        if (term == 0.0) {\n            finiteSum = true;\n            break;\n        }\n        ret += term;\n        if (ret == ret + 1.0) {\n            finiteSum = true;\n            break;\n        }\n\n        final double temp = a + i;\n        if (temp >= GAMMA_SERIES_SWITCH_POINT) {\n            final double c = inverseGamma1pm1(temp);\n            double d = 1.0 / ret;\n            double h = d * c;\n            i++;\n            do {\n                d = -(temp + i - 1.0) * d / x;\n                h *= d + 1.0 / ret;\n\n                if (Double.isInfinite(h)) {\n                    finiteSum = true;\n                    break;\n                }\n            } while (Math.abs(d / h) > MACHINE_EPSILON);\n            if (finiteSum) {\n                break;\n            }\n            ret = 1.0 / (1.0 + h);\n            break;\n        }\n        term *= x / (a + i + 1.0);\n        i++;\n    }\n    if (!finiteSum && ret != 0.0) {\n        ret = ret * Math.exp(-x + a * Math.log(x) - lnGamma(a)) / a;\n    }\n    return ret;\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..25167f812 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,69 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x) {\n+    if (Double.isInfinite(a) || Double.isInfinite(x)) {\n+        return Double.NaN;\n+    }\n+    if (a <= 0.0 || x < 0.0) {\n+        return Double.NaN;\n+    }\n+    if (x == 0.0) {\n+        return 0.0;\n+    }\n+    if (x >= a + GAMMA_XBIG) {\n+        return 1.0;\n+    }\n+\n+    double ret = 0.0;\n+    boolean finiteSum = false;\n+    double term = a * Math.log(x) - x - lnGamma(a);\n+    if (term < -Precision.LIBRARY_2BIG) {\n+        return 0.0;\n+    }\n+    term = Math.exp(term);\n+    ret = term;\n+    int i = 0;\n+    while (i < MAX_ITERATION) {\n+        if (term == 0.0) {\n+            finiteSum = true;\n+            break;\n+        }\n+        ret += term;\n+        if (ret == ret + 1.0) {\n+            finiteSum = true;\n+            break;\n+        }\n+\n+        final double temp = a + i;\n+        if (temp >= GAMMA_SERIES_SWITCH_POINT) {\n+            final double c = inverseGamma1pm1(temp);\n+            double d = 1.0 / ret;\n+            double h = d * c;\n+            i++;\n+            do {\n+                d = -(temp + i - 1.0) * d / x;\n+                h *= d + 1.0 / ret;\n+\n+                if (Double.isInfinite(h)) {\n+                    finiteSum = true;\n+                    break;\n+                }\n+            } while (Math.abs(d / h) > MACHINE_EPSILON);\n+            if (finiteSum) {\n+                break;\n+            }\n+            ret = 1.0 / (1.0 + h);\n+            break;\n+        }\n+        term *= x / (a + i + 1.0);\n+        i++;\n+    }\n+    if (!finiteSum && ret != 0.0) {\n+        ret = ret * Math.exp(-x + a * Math.log(x) - lnGamma(a)) / a;\n+    }\n+    return ret;\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}