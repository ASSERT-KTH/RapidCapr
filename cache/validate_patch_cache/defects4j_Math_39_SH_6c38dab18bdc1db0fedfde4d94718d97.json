{
    "patch": "      if (firstTime || !fsal) {\n        // first stage\n        computeDerivatives(stepStart, y, yDotK[0]);\n      }\n\n      if (firstTime) {\n        final double[] scale = new double[mainSetDimension];\n        if (vecAbsoluteTolerance == null) {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n            }\n        } else {\n            for (int i = 0; i < scale.length; ++i) {\n              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n            }\n        }\n        // enforce a maximum step size that allows the target time to be reached\n        double hMax = Math.abs(t - stepStart) * maxStep;\n        if (hMax == 0) {\n            hMax = maxStep;\n        }\n        hNew = FastMath.min(hMax, initializeStep(forward, getOrder(), scale,\n                                                  stepStart, y, yDotK[0], yTmp, yDotK[1]));\n        firstTime = false;\n      } else {\n        hNew = stepSize;\n      }\n\n      stepSize = hNew;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..9634e36aa 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,35 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+      if (firstTime || !fsal) {\n+        // first stage\n+        computeDerivatives(stepStart, y, yDotK[0]);\n+      }\n+\n+      if (firstTime) {\n+        final double[] scale = new double[mainSetDimension];\n+        if (vecAbsoluteTolerance == null) {\n+            for (int i = 0; i < scale.length; ++i) {\n+              scale[i] = scalAbsoluteTolerance + scalRelativeTolerance * FastMath.abs(y[i]);\n+            }\n+        } else {\n+            for (int i = 0; i < scale.length; ++i) {\n+              scale[i] = vecAbsoluteTolerance[i] + vecRelativeTolerance[i] * FastMath.abs(y[i]);\n+            }\n+        }\n+        // enforce a maximum step size that allows the target time to be reached\n+        double hMax = Math.abs(t - stepStart) * maxStep;\n+        if (hMax == 0) {\n+            hMax = maxStep;\n+        }\n+        hNew = FastMath.min(hMax, initializeStep(forward, getOrder(), scale,\n+                                                  stepStart, y, yDotK[0], yTmp, yDotK[1]));\n+        firstTime = false;\n+      } else {\n+        hNew = stepSize;\n+      }\n+\n+      stepSize = hNew;\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: maxStep has private access in AdaptiveStepsizeIntegrator",
    "test_result": "ERROR"
}