{
    "patch": "            // We need to check for a DST gap that crosses one or more days\n            // to avoid an infinite loop when DST transitions occur at midnight\n            allTransitions:\n            while (true) {\n                final long nextLocal = nextTransition(instantAdjusted);\n                final long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n                if (nextLocal == nextAdjusted) {\n                    // The next transition occurs on the same date in both zones, so no gap exists\n                    break allTransitions;\n                }\n                if (nextAdjusted == instantLocal - offsetAdjusted) {\n                    // Next transition is today and has already occurred in zone while not adjusted\n                    // We need to adjust the \"next transition\" to tomorrow and continue to search\n                    instantAdjusted = nextLocal + DateTimeConstants.MILLIS_PER_DAY;\n                    continue allTransitions;\n                }\n                // At least one day has been skipped in 'zone', now arrive at the same date as 'local'\n                final long newInstantLocal = nextAdjusted + offsetAdjusted;\n                instantAdjusted = nextLocal;\n                offsetAdjusted = getOffset(newInstantLocal);\n                // check if there's no longer a DST gap, in which case return the adjusted offset\n                if (offsetLocal == offsetAdjusted) {\n                    break allTransitions;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..87abf958 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,29 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+            // We need to check for a DST gap that crosses one or more days\n+            // to avoid an infinite loop when DST transitions occur at midnight\n+            allTransitions:\n+            while (true) {\n+                final long nextLocal = nextTransition(instantAdjusted);\n+                final long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n+                if (nextLocal == nextAdjusted) {\n+                    // The next transition occurs on the same date in both zones, so no gap exists\n+                    break allTransitions;\n+                }\n+                if (nextAdjusted == instantLocal - offsetAdjusted) {\n+                    // Next transition is today and has already occurred in zone while not adjusted\n+                    // We need to adjust the \"next transition\" to tomorrow and continue to search\n+                    instantAdjusted = nextLocal + DateTimeConstants.MILLIS_PER_DAY;\n+                    continue allTransitions;\n+                }\n+                // At least one day has been skipped in 'zone', now arrive at the same date as 'local'\n+                final long newInstantLocal = nextAdjusted + offsetAdjusted;\n+                instantAdjusted = nextLocal;\n+                offsetAdjusted = getOffset(newInstantLocal);\n+                // check if there's no longer a DST gap, in which case return the adjusted offset\n+                if (offsetLocal == offsetAdjusted) {\n+                    break allTransitions;\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}