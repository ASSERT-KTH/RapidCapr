{
    "patch": "import org.apache.commons.math.MathInternalError;\nimport org.apache.commons.math.exception.MaxCountExceededException;\nimport org.apache.commons.math.exception.TooManyEvaluationsException;\nimport org.apache.commons.math.util.FastMath;\n\npublic class BrentSolver extends AbstractUnivariateSolver {\n    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n    private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n    private static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n    private static final int    DEFAULT_MAXIMAL_ITERATIONS    = 100;\n\n    private final double functionValueAccuracy;\n    private final int maximalIterationCount;\n    private final double lowerBound;\n    private final double upperBound;\n    private final AllowedSolution allowed;\n\n    public BrentSolver(double absoluteAccuracy, double relativeAccuracy,\n                       double functionValueAccuracy,\n                       int maximalIterationCount) {\n        super(relativeAccuracy, absoluteAccuracy);\n        this.functionValueAccuracy = functionValueAccuracy;\n        this.maximalIterationCount = maximalIterationCount;\n        this.lowerBound = 0;\n        this.upperBound = 0;\n        this.allowed = AllowedSolution.ANY_SIDE;\n    }\n\n    public BrentSolver(double absoluteAccuracy, double relativeAccuracy,\n                       double functionValueAccuracy,\n                       int maximalIterationCount,\n                       double lowerBound, double upperBound,\n                       AllowedSolution allowed) {\n        super(relativeAccuracy, absoluteAccuracy);\n        this.functionValueAccuracy = functionValueAccuracy;\n        this.maximalIterationCount = maximalIterationCount;\n        this.lowerBound = FastMath.min(lowerBound, upperBound);\n        this.upperBound = FastMath.max(lowerBound, upperBound);\n        this.allowed = allowed;\n    }\n\n    public BrentSolver() {\n        this(DEFAULT_ABSOLUTE_ACCURACY,\n             DEFAULT_RELATIVE_ACCURACY,\n             DEFAULT_FUNCTION_VALUE_ACCURACY,\n             DEFAULT_MAXIMAL_ITERATIONS);\n    }\n\n    @Override\n    protected final double doSolve() throws TooManyEvaluationsException, NoBracketingException {\n        double min = getMin();\n        double max = getMax();\n        double initial = getStartValue();\n        verifySequence(min, initial, max);\n\n        double functionValueMin = computeObjectiveValue(min);\n        double functionValueInit = computeObjectiveValue(initial);\n        double functionValueMax = computeObjectiveValue(max);\n\n        if (functionValueMin == 0) {\n            return min;\n        }\n        if (functionValueMax == 0) {\n            return max;\n        }\n\n        if (functionValueInit == 0) {\n            return initial;\n        }\n        verifyBracketing(min, max);\n\n        double oldX = initial;\n        double oldY = functionValueInit;\n        double minX = min;\n        double maxX = max;\n        double minF = functionValueMin;\n        double maxF = functionValueMax;\n        double midX = initial;\n        double midF = functionValueInit;\n        double delta = 0;\n        double absMinF, absMaxF;\n        int numIterations = 0;\n        int i = -1;\n        boolean bisect = false;\n        while (true) {\n\n            double a = minX;\n            double b = maxX;\n            double fullRange = b - a;\n            double d = 0.5 * fullRange;\n            double middle = a + d;\n\n            double x, f;\n            if ((oldY < 0 && midF < 0) || (oldY >= 0 && midF >= 0)) {\n                // Secant-Ridder\n                x = middle + 0.5 * delta;\n                f = computeObjectiveValue(x);\n                ++i;\n                double rtol = getRelativeAccuracy() * FastMath.max(FastMath.abs(midF), FastMath.abs(f));\n                if ((f == 0) || (FastMath.abs(f) < functionValueAccuracy)) {\n                    return x;\n                }\n                if (i != 0) {\n                    if (bisect || (FastMath.abs(x - oldX) < rtol)) {\n                        bisect = true;\n                        delta = 0.5 * fullRange;\n                        x = a + delta;\n                        f = computeObjectiveValue(x);\n                        ++i;\n                        if ((f == 0) || (FastMath.abs(f) < functionValueAccuracy)) {\n                            return x;\n                        }\n                        if ((f > 0 && midF < 0) || (f < 0 && midF >= 0)) {\n                            bisect = false;\n                        }\n                    }\n                    if (bisect ||\n                        (FastMath.abs(f) <= FastMath.abs(oldY))) {\n                        delta = 0.5 * delta;\n                        bisect = true;\n                    } else {\n                        double r3 = f / oldY;\n                        double p;\n                        double q;\n                        if (FastMath.abs(oldX - a) > functionValueAccuracy) {\n                            p = (midF - oldY) * (x - oldX) / (oldX - a);\n                            q = (midF - oldY) * (midX - oldX) / (oldX - a);\n                        } else {\n                            p = (midF - f) / (maxX - midX);\n                            q = (f - oldY) / (x - oldX);\n                        }\n                        double r1 = p - r3 * q;\n                        double r2 = FastMath.sqrt(r1 * r1 - p * q * (r3-1));\n                        if (r1 < 0) {\n                            r2 = -r2;\n                        }\n                        double nextX = oldX - q / (r1 + r2);\n                        if (nextX == oldX) {\n                            delta = 0.5 * fullRange;\n                            bisect = true;\n                        } else {\n                            delta = FastMath.abs(nextX - oldX);\n                            bisect = false;\n                        }\n                    }\n                } else {\n                    delta = FastMath.abs(x - oldX);\n                    bisect = true;\n                }\n                double newY = computeObjectiveValue(x);\n                oldX = x;\n                oldY = newY;\n            } else {\n                // Bisection\n                delta = 0.5 * fullRange;\n                bisect = true;\n            }\n\n            if (bisect) {\n                x = middle;\n                f = computeObjectiveValue(x);\n                ++i;\n                if ((f == 0) || (FastMath.abs(delta) < functionValueAccuracy)) {\n                    return x;\n                }\n            }\n\n            if (f < 0) {\n                minX = x;\n                minF = f;\n            } else {\n                maxX = x;\n                maxF = f;\n            }\n\n            if ((maxX - minX) <= FastMath.max(getAbsoluteAccurac",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..abd4e30de 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,209 +140,182 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n-            return x[1];\n-        }\n-\n-        // evaluate first  endpoint\n-        y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n-            return x[0];\n-        }\n-\n-        int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n-\n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n+import org.apache.commons.math.MathInternalError;\n+import org.apache.commons.math.exception.MaxCountExceededException;\n+import org.apache.commons.math.exception.TooManyEvaluationsException;\n+import org.apache.commons.math.util.FastMath;\n \n-        } else {\n+public class BrentSolver extends AbstractUnivariateSolver {\n+    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n+    private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n+    private static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n+    private static final int    DEFAULT_MAXIMAL_ITERATIONS    = 100;\n+\n+    private final double functionValueAccuracy;\n+    private final int maximalIterationCount;\n+    private final double lowerBound;\n+    private final double upperBound;\n+    private final AllowedSolution allowed;\n+\n+    public BrentSolver(double absoluteAccuracy, double relativeAccuracy,\n+                       double functionValueAccuracy,\n+                       int maximalIterationCount) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+        this.functionValueAccuracy = functionValueAccuracy;\n+        this.maximalIterationCount = maximalIterationCount;\n+        this.lowerBound = 0;\n+        this.upperBound = 0;\n+        this.allowed = AllowedSolution.ANY_SIDE;\n+    }\n \n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n-            }\n+    public BrentSolver(double absoluteAccuracy, double relativeAccuracy,\n+                       double functionValueAccuracy,\n+                       int maximalIterationCount,\n+                       double lowerBound, double upperBound,\n+                       AllowedSolution allowed) {\n+        super(relativeAccuracy, absoluteAccuracy);\n+        this.functionValueAccuracy = functionValueAccuracy;\n+        this.maximalIterationCount = maximalIterationCount;\n+        this.lowerBound = FastMath.min(lowerBound, upperBound);\n+        this.upperBound = FastMath.max(lowerBound, upperBound);\n+        this.allowed = allowed;\n+    }\n \n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n-            } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n-            }\n+    public BrentSolver() {\n+        this(DEFAULT_ABSOLUTE_ACCURACY,\n+             DEFAULT_RELATIVE_ACCURACY,\n+             DEFAULT_FUNCTION_VALUE_ACCURACY,\n+             DEFAULT_MAXIMAL_ITERATIONS);\n+    }\n \n+    @Override\n+    protected final double doSolve() throws TooManyEvaluationsException, NoBracketingException {\n+        double min = getMin();\n+        double max = getMax();\n+        double initial = getStartValue();\n+        verifySequence(min, initial, max);\n+\n+        double functionValueMin = computeObjectiveValue(min);\n+        double functionValueInit = computeObjectiveValue(initial);\n+        double functionValueMax = computeObjectiveValue(max);\n+\n+        if (functionValueMin == 0) {\n+            return min;\n+        }\n+        if (functionValueMax == 0) {\n+            return max;\n         }\n \n-        // prepare a work array for inverse polynomial interpolation\n-        final double[] tmpX = new double[x.length];\n-\n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n+        if (functionValueInit == 0) {\n+            return initial;\n+        }\n+        verifyBracketing(min, max);\n+\n+        double oldX = initial;\n+        double oldY = functionValueInit;\n+        double minX = min;\n+        double maxX = max;\n+        double minF = functionValueMin;\n+        double maxF = functionValueMax;\n+        double midX = initial;\n+        double midF = functionValueInit;\n+        double delta = 0;\n+        double absMinF, absMaxF;\n+        int numIterations = 0;\n+        int i = -1;\n+        boolean bisect = false;\n         while (true) {\n \n-            // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n-                switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n+            double a = minX;\n+            double b = maxX;\n+            double fullRange = b - a;\n+            double d = 0.5 * fullRange;\n+            double middle = a + d;\n+\n+            double x, f;\n+            if ((oldY < 0 && midF < 0) || (oldY >= 0 && midF >= 0)) {\n+                // Secant-Ridder\n+                x = middle + 0.5 * delta;\n+                f = computeObjectiveValue(x);\n+                ++i;\n+                double rtol = getRelativeAccuracy() * FastMath.max(FastMath.abs(midF), FastMath.abs(f));\n+                if ((f == 0) || (FastMath.abs(f) < functionValueAccuracy)) {\n+                    return x;\n                 }\n-            }\n-\n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n-            } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n-            }\n-\n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n+                if (i != 0) {\n+                    if (bisect || (FastMath.abs(x - oldX) < rtol)) {\n+                        bisect = true;\n+                        delta = 0.5 * fullRange;\n+                        x = a + delta;\n+                        f = computeObjectiveValue(x);\n+                        ++i;\n+                        if ((f == 0) || (FastMath.abs(f) < functionValueAccuracy)) {\n+                            return x;\n+                        }\n+                        if ((f > 0 && midF < 0) || (f < 0 && midF >= 0)) {\n+                            bisect = false;\n+                        }\n+                    }\n+                    if (bisect ||\n+                        (FastMath.abs(f) <= FastMath.abs(oldY))) {\n+                        delta = 0.5 * delta;\n+                        bisect = true;\n                     } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n+                        double r3 = f / oldY;\n+                        double p;\n+                        double q;\n+                        if (FastMath.abs(oldX - a) > functionValueAccuracy) {\n+                            p = (midF - oldY) * (x - oldX) / (oldX - a);\n+                            q = (midF - oldY) * (midX - oldX) / (oldX - a);\n+                        } else {\n+                            p = (midF - f) / (maxX - midX);\n+                            q = (f - oldY) / (x - oldX);\n+                        }\n+                        double r1 = p - r3 * q;\n+                        double r2 = FastMath.sqrt(r1 * r1 - p * q * (r3-1));\n+                        if (r1 < 0) {\n+                            r2 = -r2;\n+                        }\n+                        double nextX = oldX - q / (r1 + r2);\n+                        if (nextX == oldX) {\n+                            delta = 0.5 * fullRange;\n+                            bisect = true;\n+                        } else {\n+                            delta = FastMath.abs(nextX - oldX);\n+                            bisect = false;\n+                        }\n                     }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n+                } else {\n+                    delta = FastMath.abs(x - oldX);\n+                    bisect = true;\n                 }\n-\n-            } while (Double.isNaN(nextX) && (end - start > 1));\n-\n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n-            }\n-\n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n+                double newY = computeObjectiveValue(x);\n+                oldX = x;\n+                oldY = newY;\n+            } else {\n+                // Bisection\n+                delta = 0.5 * fullRange;\n+                bisect = true;\n             }\n \n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n-\n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n+            if (bisect) {\n+                x = middle;\n+                f = computeObjectiveValue(x);\n+                ++i;\n+                if ((f == 0) || (FastMath.abs(delta) < functionValueAccuracy)) {\n+                    return x;\n                 }\n-\n             }\n \n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n+            if (f < 0) {\n+                minX = x;\n+                minF = f;\n             } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n+                maxX = x;\n+                maxF = f;\n             }\n \n-        }\n-\n-    }\n+            if ((maxX - minX) <= FastMath.max(getAbsoluteAccurac\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}