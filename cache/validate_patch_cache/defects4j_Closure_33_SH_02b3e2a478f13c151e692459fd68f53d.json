{
    "patch": "    if (!this.isNominalConstructor() && !this.isFunctionType()) {\n      return;\n    }\n\n    if (this.isNominalConstructor() && !constraintObj.isNominalConstructor()) {\n      return;\n    }\n\n    if (this.isRecordType()) {\n      JSType funType = getFunType();\n      for (String prop : funType.getOwnPropertyNames()) {\n        JSType propType = funType.getPropertyType(prop);\n        if (!isPropertyTypeDeclared(prop)) {\n          // If this type has a template type, don't infer it for the constraint object\n          propType = templateTypeMap != null ? replaceTemplateTypesWithUnknown(propType) : propType;\n          typeRegistry = typeRegistry.withPropertyInferred(this, prop, propType);\n        }\n      }\n    } else if (this.isFunctionType()) {\n      JSType unqThisType = this.getThisType().substituteGenericsWithUnknown();\n      if (!constraintObj.getThisType().isSubtype(unqThisType)) {\n        return;\n      }\n\n      if (constraintObj.isFunctionType()) {\n        if (!this.getReferenceName().equals(constraintObj.getReferenceName())) {\n          return;\n        }\n        if (this.getMinArity() > constraintObj.getMaxArity()) {\n          return;\n        }\n        if (this.getMaxArity() < constraintObj.getMinArity()) {\n          return;\n        }\n        JSType elementType = getNativeType(JSTypeNative.EMPTY_TYPE);\n        if (this.isConstructor() && hasConstructorObject()) {\n          checkState(this.getClassType() != null, this);\n          elementType =\n              elementType.getLeastSupertype(\n                  this.getClassType().toObjectType().getInstantiatedReturnType());\n        } else if (this.isGeneric()) {\n          elementType = elementType.getGreatestSubtype(this.getTypeOfThis());\n        }\n        int thisArity = this.getMaxArityBound();\n        int otherArity = constraintObj.getArity();\n        for (int i = thisArity, otherI = otherArity; i >= 0 && otherI >= 0; i--, otherI--) {\n          if (otherI < constraintObj.getMinArity()) {\n            break;\n          }\n          ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n          for (int j = 0; j < i; j++) {\n            TypeI paramI = this.getFormalType(j);\n            builder.add(paramI.getTypeOfThis().substituteGenericsWithUnknown());\n          }\n          JSTypeRestArgsType restArgType =\n              otherI == i ? null : constraintObj.getFormalType(otherI).getRestVar();\n          JSType functionType =\n              new JSTypeFunctionBuilder(typeRegistry)\n                  .addReceiverType(this.getThisType())\n                  .addTypeParams(this.getTypeParameters().getTypes())\n                  .addFormalTypes(builder.build())\n                  .addRestFormals(restArgType)\n                  .addReturnType(elementType)\n                  .buildFunction();\n          typeRegistry = typeRegistry.withPropertyInferred(this, FUNCTION_TYPE_MARKER, functionType);",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex b6e3fc78..9add4c54 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -554,6 +554,71 @@ class PrototypeObjectType extends ObjectType {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n+    if (!this.isNominalConstructor() && !this.isFunctionType()) {\n+      return;\n+    }\n+\n+    if (this.isNominalConstructor() && !constraintObj.isNominalConstructor()) {\n+      return;\n+    }\n+\n+    if (this.isRecordType()) {\n+      JSType funType = getFunType();\n+      for (String prop : funType.getOwnPropertyNames()) {\n+        JSType propType = funType.getPropertyType(prop);\n+        if (!isPropertyTypeDeclared(prop)) {\n+          // If this type has a template type, don't infer it for the constraint object\n+          propType = templateTypeMap != null ? replaceTemplateTypesWithUnknown(propType) : propType;\n+          typeRegistry = typeRegistry.withPropertyInferred(this, prop, propType);\n+        }\n+      }\n+    } else if (this.isFunctionType()) {\n+      JSType unqThisType = this.getThisType().substituteGenericsWithUnknown();\n+      if (!constraintObj.getThisType().isSubtype(unqThisType)) {\n+        return;\n+      }\n+\n+      if (constraintObj.isFunctionType()) {\n+        if (!this.getReferenceName().equals(constraintObj.getReferenceName())) {\n+          return;\n+        }\n+        if (this.getMinArity() > constraintObj.getMaxArity()) {\n+          return;\n+        }\n+        if (this.getMaxArity() < constraintObj.getMinArity()) {\n+          return;\n+        }\n+        JSType elementType = getNativeType(JSTypeNative.EMPTY_TYPE);\n+        if (this.isConstructor() && hasConstructorObject()) {\n+          checkState(this.getClassType() != null, this);\n+          elementType =\n+              elementType.getLeastSupertype(\n+                  this.getClassType().toObjectType().getInstantiatedReturnType());\n+        } else if (this.isGeneric()) {\n+          elementType = elementType.getGreatestSubtype(this.getTypeOfThis());\n+        }\n+        int thisArity = this.getMaxArityBound();\n+        int otherArity = constraintObj.getArity();\n+        for (int i = thisArity, otherI = otherArity; i >= 0 && otherI >= 0; i--, otherI--) {\n+          if (otherI < constraintObj.getMinArity()) {\n+            break;\n+          }\n+          ImmutableList.Builder<JSType> builder = ImmutableList.builder();\n+          for (int j = 0; j < i; j++) {\n+            TypeI paramI = this.getFormalType(j);\n+            builder.add(paramI.getTypeOfThis().substituteGenericsWithUnknown());\n+          }\n+          JSTypeRestArgsType restArgType =\n+              otherI == i ? null : constraintObj.getFormalType(otherI).getRestVar();\n+          JSType functionType =\n+              new JSTypeFunctionBuilder(typeRegistry)\n+                  .addReceiverType(this.getThisType())\n+                  .addTypeParams(this.getTypeParameters().getTypes())\n+                  .addFormalTypes(builder.build())\n+                  .addRestFormals(restArgType)\n+                  .addReturnType(elementType)\n+                  .buildFunction();\n+          typeRegistry = typeRegistry.withPropertyInferred(this, FUNCTION_TYPE_MARKER, functionType);\n \n     // Handle the case where the constraint object is a record type.\n     //",
    "result_reason": "error: reached end of file while parsing",
    "test_result": "ERROR"
}