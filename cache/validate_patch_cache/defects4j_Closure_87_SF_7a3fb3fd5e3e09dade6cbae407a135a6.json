{
    "patch": "private boolean isFoldableExpression(Node expr, boolean isExpressionResult) {\n  switch (expr.getType()) {\n    case Token.FUNCTION:\n      Node functionBody = expr.getLastChild();\n      boolean hasReturnStatement =\n          functionBody != null &&\n              functionBody.getLastChild() != null &&\n              functionBody.getLastChild().getType() == Token.RETURN;\n      return !hasReturnStatement;\n\n    case Token.HOOK:\n      Node condition = expr.getFirstChild();\n      Node trueExpression = condition.getNext();\n      Node falseExpression = trueExpression.getNext();\n      return isFoldableExpression(condition, false) &&\n          isFoldableExpression(trueExpression, isExpressionResult) &&\n          isFoldableExpression(falseExpression, isExpressionResult);\n\n    case Token.NOT:\n      Node child = expr.getFirstChild();\n      if (child.getType() == Token.GETPROP) {\n        Node grandChild = child.getFirstChild();\n        if (grandChild.getNext().getString().equals(\"returnValue\")) {\n          Node greatGrandChild = grandChild.getFirstChild();\n          if (greatGrandChild.getType() == Token.NAME &&\n              greatGrandChild.getString().startsWith(\"on\")) {\n            return !isExpressionResult;\n          }\n        }\n      }\n      break;\n\n    case Token.GETPROP:\n      if (expr.getFirstChild().getType() == Token.NAME) {\n        String propertyName = expr.getLastChild().getString();\n        if (propertyName.equals(\"returnValue\")) {\n          Node parent = expr.getParent();\n          if (parent.getType() == Token.CALL &&\n              parent.getFirstChild().getType() == Token.GETPROP) {\n            Node grandParent = parent.getParent();\n            if (grandParent.getType() == Token.EXPR_RESULT) {\n              return isFoldableExpression(parent.getFirstChild(), true);\n            }\n          }\n        }\n      }\n      break;\n\n    case Token.NAME:\n      String name = expr.getString();\n      if (name.equals(\"undefined\")) {\n        break;\n      }\n      if (name.equals(\"NaN\") ||\n          name.equals(\"Infinity\") ||\n          name.equals(\"goog$nullFunction\") ||\n          name.equals(\"goog$abstractMethod\") ||\n          name.startsWith(\"jscomp$\") ||\n          name.startsWith(\"$jscomp$\")) {\n        return true;\n      }\n      if (!isExpressionResult && name.startsWith(\"event\")) {\n        break;\n      }\n      if (name.startsWith(\"on\")) {\n        return !isExpressionResult;\n      }\n      break;\n\n    case Token.AND:\n    case Token.OR:\n    case Token.EQ:\n    case Token.NE:\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      return isFoldableExpression(left, false) &&\n          isFoldableExpression(right, false);\n\n    case Token.STRING:\n    case Token.NUMBER:\n    case Token.NULL:\n    case Token.TRUE:\n    case Token.FALSE:\n      return true;\n\n    default:\n      break;\n  }\n\n  return false;\n}\n\nprivate boolean isFoldableExpressBlock(Node n) {\n  return n.isBlock()\n      && n.getFirstChild() != null\n      && isFoldableExpression(n.getFirstChild(), false);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..1e97460f 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,27 +516,104 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+private boolean isFoldableExpression(Node expr, boolean isExpressionResult) {\n+  switch (expr.getType()) {\n+    case Token.FUNCTION:\n+      Node functionBody = expr.getLastChild();\n+      boolean hasReturnStatement =\n+          functionBody != null &&\n+              functionBody.getLastChild() != null &&\n+              functionBody.getLastChild().getType() == Token.RETURN;\n+      return !hasReturnStatement;\n+\n+    case Token.HOOK:\n+      Node condition = expr.getFirstChild();\n+      Node trueExpression = condition.getNext();\n+      Node falseExpression = trueExpression.getNext();\n+      return isFoldableExpression(condition, false) &&\n+          isFoldableExpression(trueExpression, isExpressionResult) &&\n+          isFoldableExpression(falseExpression, isExpressionResult);\n+\n+    case Token.NOT:\n+      Node child = expr.getFirstChild();\n+      if (child.getType() == Token.GETPROP) {\n+        Node grandChild = child.getFirstChild();\n+        if (grandChild.getNext().getString().equals(\"returnValue\")) {\n+          Node greatGrandChild = grandChild.getFirstChild();\n+          if (greatGrandChild.getType() == Token.NAME &&\n+              greatGrandChild.getString().startsWith(\"on\")) {\n+            return !isExpressionResult;\n+          }\n+        }\n       }\n-    }\n+      break;\n+\n+    case Token.GETPROP:\n+      if (expr.getFirstChild().getType() == Token.NAME) {\n+        String propertyName = expr.getLastChild().getString();\n+        if (propertyName.equals(\"returnValue\")) {\n+          Node parent = expr.getParent();\n+          if (parent.getType() == Token.CALL &&\n+              parent.getFirstChild().getType() == Token.GETPROP) {\n+            Node grandParent = parent.getParent();\n+            if (grandParent.getType() == Token.EXPR_RESULT) {\n+              return isFoldableExpression(parent.getFirstChild(), true);\n+            }\n+          }\n+        }\n+      }\n+      break;\n \n-    return false;\n+    case Token.NAME:\n+      String name = expr.getString();\n+      if (name.equals(\"undefined\")) {\n+        break;\n+      }\n+      if (name.equals(\"NaN\") ||\n+          name.equals(\"Infinity\") ||\n+          name.equals(\"goog$nullFunction\") ||\n+          name.equals(\"goog$abstractMethod\") ||\n+          name.startsWith(\"jscomp$\") ||\n+          name.startsWith(\"$jscomp$\")) {\n+        return true;\n+      }\n+      if (!isExpressionResult && name.startsWith(\"event\")) {\n+        break;\n+      }\n+      if (name.startsWith(\"on\")) {\n+        return !isExpressionResult;\n+      }\n+      break;\n+\n+    case Token.AND:\n+    case Token.OR:\n+    case Token.EQ:\n+    case Token.NE:\n+      Node left = expr.getFirstChild();\n+      Node right = left.getNext();\n+      return isFoldableExpression(left, false) &&\n+          isFoldableExpression(right, false);\n+\n+    case Token.STRING:\n+    case Token.NUMBER:\n+    case Token.NULL:\n+    case Token.TRUE:\n+    case Token.FALSE:\n+      return true;\n+\n+    default:\n+      break;\n   }\n \n+  return false;\n+}\n+\n+private boolean isFoldableExpressBlock(Node n) {\n+  return n.isBlock()\n+      && n.getFirstChild() != null\n+      && isFoldableExpression(n.getFirstChild(), false);\n+}\n+\n   /**\n    * @return The expression node.\n    */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}