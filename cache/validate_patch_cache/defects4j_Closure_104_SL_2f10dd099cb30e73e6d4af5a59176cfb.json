{
    "patch": "    if (that instanceof UnionType) {\n      UnionType thatUnion = (UnionType) that;\n      // This accumulator holds all the types that could match `this`.\n      JSTypeAccumulator accumulator = new JSTypeAccumulator(registry);\n      // There are three cases we need to handle with this union that are more\n      //     complicated than finding the greatest lower bound as normal:\n      // 1) When a type in the union is a subtype of `this`. In this case, that\n      //    type should be retained if it is the only type in the union that is\n      //    a supertype of `this`.\n      // 2) When the union of `this` and `that` is too large to compute. This\n      //    happens when the cross-product of the types in the two unions is too\n      //    large, for example if `this` is the union of 2 non-primitive types\n      //    and `that` is the union of 3 non-primitive types.\n      // 3) When the union of `this` and `that` is the empty set. In this case,\n      //    we return the NoneType.\n      // Otherwise, we simply accumulate the types that satisfy (1) above, then\n      // compute the greatest lower bound of the accumulated types.\n\n      if (thatUnion.mayHaveNonScalar()) {\n        // Case (2): If we're not sure how big the union of `this` and `that` is\n        // then abort.\n        return getNativeType(JSTypeNative.NO_TYPE);\n      }\n\n      if (thatUnion.isEmptyType()) {\n        // Case (3)\n        return getNativeType(JSTypeNative.NO_TYPE);\n      }\n\n      boolean containsSubtype = false;\n      for (JSType thisType : alternates) {\n        if (that.isSubtype(thisType)) {\n          if (thisType.isSubtype(that)) {\n            accumulator = new JSTypeAccumulator(registry);\n            accumulator.add(thisType);\n            containsSubtype = false;\n            break;\n          } else {\n            accumulator.add(thisType);\n            containsSubtype = true;\n          }\n        }\n      }\n      if (accumulator.size() > 0) {\n        if (accumulator.size() == 1 && !containsSubtype) {\n          return accumulator.iterator().next();\n        }\n        // Case (1)\n        JSTypeAccumulator thatAccumulator = new JSTypeAccumulator(registry);\n        for (JSType thatType : thatUnion.alternates) {\n          if (this.isSubtype(thatType)) {\n            thatAccumulator.add(thatType);\n          }\n        }\n        // Then compute the greatest lower bound. We know this exists because\n        // we've already handled the cases where the two sets of types have an\n        // empty intersection, or their intersection is too large to compute.\n        return accumulator.getGreatestSubtype(thatAccumulator.build());\n      }\n    } else if (that.isSubtype(this)) {\n      return builder.addAlternate(that).build();\n    }\n    // Cases where neither `this` is a subtype of `that` nor `that` is a subtype\n    // of `this`.\n    if (this.isObject() && that.isObject()) {\n        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n    }\n    return getNativeType(JSTypeNative.NO_TYPE);\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/UnionType.java b/src/com/google/javascript/rhino/jstype/UnionType.java\nindex a9c9a0ae..cb3c0466 100644\n--- a/src/com/google/javascript/rhino/jstype/UnionType.java\n+++ b/src/com/google/javascript/rhino/jstype/UnionType.java\n@@ -288,7 +288,75 @@ public class UnionType extends JSType {\n       builder.addAlternate(that);\n     }\n     JSType result = builder.build();\n-    if (result != null) {\n+    if (that instanceof UnionType) {\n+      UnionType thatUnion = (UnionType) that;\n+      // This accumulator holds all the types that could match `this`.\n+      JSTypeAccumulator accumulator = new JSTypeAccumulator(registry);\n+      // There are three cases we need to handle with this union that are more\n+      //     complicated than finding the greatest lower bound as normal:\n+      // 1) When a type in the union is a subtype of `this`. In this case, that\n+      //    type should be retained if it is the only type in the union that is\n+      //    a supertype of `this`.\n+      // 2) When the union of `this` and `that` is too large to compute. This\n+      //    happens when the cross-product of the types in the two unions is too\n+      //    large, for example if `this` is the union of 2 non-primitive types\n+      //    and `that` is the union of 3 non-primitive types.\n+      // 3) When the union of `this` and `that` is the empty set. In this case,\n+      //    we return the NoneType.\n+      // Otherwise, we simply accumulate the types that satisfy (1) above, then\n+      // compute the greatest lower bound of the accumulated types.\n+\n+      if (thatUnion.mayHaveNonScalar()) {\n+        // Case (2): If we're not sure how big the union of `this` and `that` is\n+        // then abort.\n+        return getNativeType(JSTypeNative.NO_TYPE);\n+      }\n+\n+      if (thatUnion.isEmptyType()) {\n+        // Case (3)\n+        return getNativeType(JSTypeNative.NO_TYPE);\n+      }\n+\n+      boolean containsSubtype = false;\n+      for (JSType thisType : alternates) {\n+        if (that.isSubtype(thisType)) {\n+          if (thisType.isSubtype(that)) {\n+            accumulator = new JSTypeAccumulator(registry);\n+            accumulator.add(thisType);\n+            containsSubtype = false;\n+            break;\n+          } else {\n+            accumulator.add(thisType);\n+            containsSubtype = true;\n+          }\n+        }\n+      }\n+      if (accumulator.size() > 0) {\n+        if (accumulator.size() == 1 && !containsSubtype) {\n+          return accumulator.iterator().next();\n+        }\n+        // Case (1)\n+        JSTypeAccumulator thatAccumulator = new JSTypeAccumulator(registry);\n+        for (JSType thatType : thatUnion.alternates) {\n+          if (this.isSubtype(thatType)) {\n+            thatAccumulator.add(thatType);\n+          }\n+        }\n+        // Then compute the greatest lower bound. We know this exists because\n+        // we've already handled the cases where the two sets of types have an\n+        // empty intersection, or their intersection is too large to compute.\n+        return accumulator.getGreatestSubtype(thatAccumulator.build());\n+      }\n+    } else if (that.isSubtype(this)) {\n+      return builder.addAlternate(that).build();\n+    }\n+    // Cases where neither `this` is a subtype of `that` nor `that` is a subtype\n+    // of `this`.\n+    if (this.isObject() && that.isObject()) {\n+        return getNativeType(JSTypeNative.NO_OBJECT_TYPE);\n+    }\n+    return getNativeType(JSTypeNative.NO_TYPE);\n+  }\n       return result;\n     } else if (this.isObject() && that.isObject()) {\n       return getNativeType(JSTypeNative.NO_OBJECT_TYPE);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}