{
    "patch": "if(hasFiniteBounds) {\n   int infiniteBoundsCount = 0;\n   int finiteBoundsCount = 0;\n   for (int i = 0; i < lB.length; i++) {\n      if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n         finiteBoundsCount++;\n      }\n      if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n         infiniteBoundsCount++;\n      }\n   }\n   if (infiniteBoundsCount > 0 && finiteBoundsCount == 0) {\n      // If all bounds are infinite, the normalize method will not work.\n      throw new NumberIsTooLargeException(Double.POSITIVE_INFINITY, 0, true);\n   } else if (infiniteBoundsCount > 0 && finiteBoundsCount > 0) {\n      // If there is at least one finite bound, none can be infinite,\n      // because mixed cases are not supported by the current code.\n      throw new MathUnsupportedOperationException();\n   } else {\n      // Convert API to internal handling of boundaries.\n      boundaries = new double[2][];\n      boundaries[0] = lB;\n      boundaries[1] = uB;\n\n      // Abort early if the normalization will overflow (cf. \"encode\" method).\n      double boundaryRange = boundaries[1][0] - boundaries[0][0];\n      if (Double.isInfinite(boundaryRange)) {\n         throw new NumberIsTooLargeException(boundaryRange, 0, true);\n      }\n   }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 51d1c6428..142dff7bd 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -537,6 +537,37 @@ public class CMAESOptimizer\n                 boundaries[1] = uB;\n \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n+if(hasFiniteBounds) {\n+   int infiniteBoundsCount = 0;\n+   int finiteBoundsCount = 0;\n+   for (int i = 0; i < lB.length; i++) {\n+      if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n+         finiteBoundsCount++;\n+      }\n+      if (Double.isInfinite(lB[i]) || Double.isInfinite(uB[i])) {\n+         infiniteBoundsCount++;\n+      }\n+   }\n+   if (infiniteBoundsCount > 0 && finiteBoundsCount == 0) {\n+      // If all bounds are infinite, the normalize method will not work.\n+      throw new NumberIsTooLargeException(Double.POSITIVE_INFINITY, 0, true);\n+   } else if (infiniteBoundsCount > 0 && finiteBoundsCount > 0) {\n+      // If there is at least one finite bound, none can be infinite,\n+      // because mixed cases are not supported by the current code.\n+      throw new MathUnsupportedOperationException();\n+   } else {\n+      // Convert API to internal handling of boundaries.\n+      boundaries = new double[2][];\n+      boundaries[0] = lB;\n+      boundaries[1] = uB;\n+\n+      // Abort early if the normalization will overflow (cf. \"encode\" method).\n+      double boundaryRange = boundaries[1][0] - boundaries[0][0];\n+      if (Double.isInfinite(boundaryRange)) {\n+         throw new NumberIsTooLargeException(boundaryRange, 0, true);\n+      }\n+   }\n+}\n             }\n         } else {\n             // Convert API to internal handling of boundaries.",
    "result_reason": "all tests passed",
    "test_result": "PASS"
}