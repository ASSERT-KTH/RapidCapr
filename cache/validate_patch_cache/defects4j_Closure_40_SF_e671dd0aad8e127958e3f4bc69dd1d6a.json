{
    "patch": "private JsName getName(String name, boolean isFunction) {\n  if (isFunction) {\n    return createFunctionName(name);\n  } else {\n    return createFieldName(name);\n  }\n}\n\nprivate JsName createFieldName(String name) {\n  if (!name.contains(\".\")) {\n    return createName(name);\n  } else {\n    String[] parts = name.split(\"\\\\.\");\n\n    JsNameMap currMap = globalVarReferences;\n\n    JsName currName = null;\n    for (String part : parts) {\n      if (currName == null) {\n        currName = currMap.get(part);\n      } else {\n        JsPropertyMap propMap = currName.getPropertyMap();\n        if (propMap == null) {\n          propMap = new JsPropertyMap();\n          currName.setPropertyMap(propMap);\n        }\n        currName = propMap.get(part);\n      }\n\n      if (currName == null) {\n        return null; // error\n      }\n\n      currMap = currName.getChildNames();\n    }\n\n    return currName;\n  }\n}\n\nprivate JsName createFunctionName(String name) {\n  JsName ns = functionNames.get(name);\n  if (ns == null) {\n    ns = createName(name);\n    functionNames.put(name, ns);\n  }\n  return ns;\n}\n\nprivate JsName createName(String name) {\n  JsName ns = nameMap.get(name);\n  if (ns == null) {\n    ns = new JsName(name);\n    nameMap.put(name, ns);\n  }\n  return ns;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 088a9933..d61297d4 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -593,54 +593,64 @@ final class NameAnalyzer implements CompilerPass {\n   private class FindDeclarationsAndSetters extends AbstractPostOrderCallback {\n \n     @Override\n-    public void visit(NodeTraversal t, Node n, Node parent) {\n+private JsName getName(String name, boolean isFunction) {\n+  if (isFunction) {\n+    return createFunctionName(name);\n+  } else {\n+    return createFieldName(name);\n+  }\n+}\n \n-      // Record global variable and function declarations\n-      if (t.inGlobalScope()) {\n-        if (NodeUtil.isVarDeclaration(n)) {\n-          NameInformation ns = createNameInformation(t, n, parent);\n-          Preconditions.checkNotNull(ns);\n-          recordSet(ns.name, n);\n-        } else if (NodeUtil.isFunctionDeclaration(n)) {\n-          Node nameNode = n.getFirstChild();\n-          NameInformation ns = createNameInformation(t, nameNode, n);\n-          if (ns != null) {\n-            JsName nameInfo = getName(nameNode.getString(), true);\n-            recordSet(nameInfo.name, nameNode);\n-          }\n-        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n-          NameInformation ns = createNameInformation(t, n, parent);\n-          if (ns != null) {\n-            recordSet(ns.name, n);\n-          }\n-        }\n-      }\n+private JsName createFieldName(String name) {\n+  if (!name.contains(\".\")) {\n+    return createName(name);\n+  } else {\n+    String[] parts = name.split(\"\\\\.\");\n \n-      // Record assignments and call sites\n-      if (n.isAssign()) {\n-        Node nameNode = n.getFirstChild();\n+    JsNameMap currMap = globalVarReferences;\n \n-        NameInformation ns = createNameInformation(t, nameNode, n);\n-        if (ns != null) {\n-          if (ns.isPrototype) {\n-            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n-          } else {\n-            recordSet(ns.name, nameNode);\n-          }\n-        }\n-      } else if (n.isCall()) {\n-        Node nameNode = n.getFirstChild();\n-        NameInformation ns = createNameInformation(t, nameNode, n);\n-        if (ns != null && ns.onlyAffectsClassDef) {\n-          JsName name = getName(ns.name, false);\n-          if (name != null) {\n-          refNodes.add(new ClassDefiningFunctionNode(\n-              name, n, parent, parent.getParent()));\n-          }\n+    JsName currName = null;\n+    for (String part : parts) {\n+      if (currName == null) {\n+        currName = currMap.get(part);\n+      } else {\n+        JsPropertyMap propMap = currName.getPropertyMap();\n+        if (propMap == null) {\n+          propMap = new JsPropertyMap();\n+          currName.setPropertyMap(propMap);\n         }\n+        currName = propMap.get(part);\n+      }\n+\n+      if (currName == null) {\n+        return null; // error\n       }\n+\n+      currMap = currName.getChildNames();\n     }\n \n+    return currName;\n+  }\n+}\n+\n+private JsName createFunctionName(String name) {\n+  JsName ns = functionNames.get(name);\n+  if (ns == null) {\n+    ns = createName(name);\n+    functionNames.put(name, ns);\n+  }\n+  return ns;\n+}\n+\n+private JsName createName(String name) {\n+  JsName ns = nameMap.get(name);\n+  if (ns == null) {\n+    ns = new JsName(name);\n+    nameMap.put(name, ns);\n+  }\n+  return ns;\n+}\n+\n     /**\n      * Records the assignment of a value to a global name.\n      *",
    "result_reason": "error: NameAnalyzer.FindDeclarationsAndSetters is not abstract and does not override abstract method visit(NodeTraversal,Node,Node) in Callback",
    "test_result": "ERROR"
}