{
    "patch": "import java.util.ArrayList;\nimport java.util.Collection;\nimport java.util.Collections;\nimport java.util.List;\n\nimport org.hipparchus.ode.events.Action;\nimport org.hipparchus.ode.events.EventHandler;\nimport org.hipparchus.ode.events.EventState;\nimport org.hipparchus.ode.events.EventStateFilter;\nimport org.hipparchus.ode.events.EventHandler.Action;\nimport org.hipparchus.ode.AbstractIntegrator;\nimport org.hipparchus.ode.Integrator;\nimport org.hipparchus.synchronization.TimeStamped;\nimport org.orekit.errors.OrekitException;\nimport org.orekit.errors.OrekitMessages;\nimport org.orekit.propagation.Propagator;\nimport org.orekit.propagation.SpacecraftState;\nimport org.orekit.propagation.events.EventDetector;\nimport org.orekit.propagation.events.EventDetector.Action;\nimport org.orekit.propagation.events.EventDetector.MaxIterationCountExceededException;\nimport org.orekit.propagation.events.EventExceptionHandler;\nimport org.orekit.propagation.integration.AbstractIntegratedPropagator;\nimport org.orekit.propagation.integration.AbstractIntegratedPropagator.StateMapper;\nimport org.orekit.propagation.integration.AbstractIntegratedState;\nimport org.orekit.propagation.integration.StateMapper;\nimport org.orekit.propagation.integration.TimestampedEventLocator;\nimport org.orekit.time.AbsoluteDate;\nimport org.orekit.utils.Constants;\n\n// ...\n\npublic <T extends EventDetector> void doEvents(final SpacecraftState s0,\n                                              final Collection<T> detectors)\n        throws OrekitException {\n\n    final EventHandlerManager manager =\n            new EventHandlerManager(s0, Collections.unmodifiableCollection(detectors));\n    final AbstractIntegrator integrator = new DormandPrince853Integrator(0.001, 5000, 1e-15, 1e-15);\n    final double minStep = 0.001;\n    final double maxStep = 5000;\n    final double tolerance = 1e-15 * Constants.JULIAN_DAY;\n    final EventExceptionHandler handler = new ContinueOnEvent();\n\n    final EventStateFilter<T> filter = new EventStateFilter<T>() {\n\n        @Override\n        public Action eventOccurred(final SpacecraftState s, final T detector, final boolean increasing) {\n            return detector.eventOccurred(s, increasing);\n        }\n\n        @Override\n        public int getMaxIterationCount() {\n            // May be overridden by some detectors\n            return EventDetector.DEFAULT_MAX_ITER;\n        }\n\n        @Override\n        public double getThreshold() {\n            // May be overridden by some detectors\n            return EventDetector.DEFAULT_THRESHOLD;\n        }\n\n        @Override\n        public double getMaxCheckInterval() {\n            // May be overridden by some detectors\n            return EventDetector.DEFAULT_MAXCHECK;\n        }\n    };\n\n    // create locators wrapping the detectors\n    final List<TimestampedEventLocator> wrapped =\n            new ArrayList<TimestampedEventLocator>(detectors.size());\n    for (final EventDetector detector : detectors) {\n        // notify the detector before propagation starts\n        detector.init(s0.getDate(), s0.getFrame());\n        // add the event corresponding to the detector to the list\n        final SpacecraftState state = detector.createInitialState(s0);\n        wrapped.add(new TimestampedEventLocator(filter.create(state, detector),\n                                                 detector.getMaxCheckInterval(),\n                                                 detector.getThreshold(),\n                                                 detector.getMaxIterationCount()));\n        // register the start event to the event state manager\n        manager.add(state, detector.getMaxCheckInterval(), detector.getThreshold(),\n                    detector.getMaxIterationCount());\n    }\n\n    final AbstractIntegratedState initialState =\n            createInitialState(s0, detectorToState(wrapped));\n    final AbstractIntegratedPropagator abstractPropagator =\n            new AbstractIntegratedPropagator(initialState, integrator, StateMapper.ZERO, handler);\n    abstractPropagator.setSlaveMode();  // event handlers should act on masters only\n    abstractPropagator.setMasterMode(new EventHandlerWrapper(manager, detectorToHandler(wrapped),\n                                                              handler, tolerance,\n                                                              minStep, maxStep));\n    abstractPropagator.propagate(s0.getDate().shiftedBy(Double.POSITIVE_INFINITY));\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..b5781bdd7 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,102 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n-\n-            });\n-\n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n-                }\n-            }\n-\n-            while (!occuringEvents.isEmpty()) {\n+import java.util.ArrayList;\n+import java.util.Collection;\n+import java.util.Collections;\n+import java.util.List;\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+import org.hipparchus.ode.events.Action;\n+import org.hipparchus.ode.events.EventHandler;\n+import org.hipparchus.ode.events.EventState;\n+import org.hipparchus.ode.events.EventStateFilter;\n+import org.hipparchus.ode.events.EventHandler.Action;\n+import org.hipparchus.ode.AbstractIntegrator;\n+import org.hipparchus.ode.Integrator;\n+import org.hipparchus.synchronization.TimeStamped;\n+import org.orekit.errors.OrekitException;\n+import org.orekit.errors.OrekitMessages;\n+import org.orekit.propagation.Propagator;\n+import org.orekit.propagation.SpacecraftState;\n+import org.orekit.propagation.events.EventDetector;\n+import org.orekit.propagation.events.EventDetector.Action;\n+import org.orekit.propagation.events.EventDetector.MaxIterationCountExceededException;\n+import org.orekit.propagation.events.EventExceptionHandler;\n+import org.orekit.propagation.integration.AbstractIntegratedPropagator;\n+import org.orekit.propagation.integration.AbstractIntegratedPropagator.StateMapper;\n+import org.orekit.propagation.integration.AbstractIntegratedState;\n+import org.orekit.propagation.integration.StateMapper;\n+import org.orekit.propagation.integration.TimestampedEventLocator;\n+import org.orekit.time.AbsoluteDate;\n+import org.orekit.utils.Constants;\n+\n+// ...\n+\n+public <T extends EventDetector> void doEvents(final SpacecraftState s0,\n+                                              final Collection<T> detectors)\n+        throws OrekitException {\n+\n+    final EventHandlerManager manager =\n+            new EventHandlerManager(s0, Collections.unmodifiableCollection(detectors));\n+    final AbstractIntegrator integrator = new DormandPrince853Integrator(0.001, 5000, 1e-15, 1e-15);\n+    final double minStep = 0.001;\n+    final double maxStep = 5000;\n+    final double tolerance = 1e-15 * Constants.JULIAN_DAY;\n+    final EventExceptionHandler handler = new ContinueOnEvent();\n+\n+    final EventStateFilter<T> filter = new EventStateFilter<T>() {\n+\n+        @Override\n+        public Action eventOccurred(final SpacecraftState s, final T detector, final boolean increasing) {\n+            return detector.eventOccurred(s, increasing);\n+        }\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+        @Override\n+        public int getMaxIterationCount() {\n+            // May be overridden by some detectors\n+            return EventDetector.DEFAULT_MAX_ITER;\n+        }\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+        @Override\n+        public double getThreshold() {\n+            // May be overridden by some detectors\n+            return EventDetector.DEFAULT_THRESHOLD;\n+        }\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+        @Override\n+        public double getMaxCheckInterval() {\n+            // May be overridden by some detectors\n+            return EventDetector.DEFAULT_MAXCHECK;\n+        }\n+    };\n+\n+    // create locators wrapping the detectors\n+    final List<TimestampedEventLocator> wrapped =\n+            new ArrayList<TimestampedEventLocator>(detectors.size());\n+    for (final EventDetector detector : detectors) {\n+        // notify the detector before propagation starts\n+        detector.init(s0.getDate(), s0.getFrame());\n+        // add the event corresponding to the detector to the list\n+        final SpacecraftState state = detector.createInitialState(s0);\n+        wrapped.add(new TimestampedEventLocator(filter.create(state, detector),\n+                                                 detector.getMaxCheckInterval(),\n+                                                 detector.getThreshold(),\n+                                                 detector.getMaxIterationCount()));\n+        // register the start event to the event state manager\n+        manager.add(state, detector.getMaxCheckInterval(), detector.getThreshold(),\n+                    detector.getMaxIterationCount());\n+    }\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n+    final AbstractIntegratedState initialState =\n+            createInitialState(s0, detectorToState(wrapped));\n+    final AbstractIntegratedPropagator abstractPropagator =\n+            new AbstractIntegratedPropagator(initialState, integrator, StateMapper.ZERO, handler);\n+    abstractPropagator.setSlaveMode();  // event handlers should act on masters only\n+    abstractPropagator.setMasterMode(new EventHandlerWrapper(manager, detectorToHandler(wrapped),\n+                                                              handler, tolerance,\n+                                                              minStep, maxStep));\n+    abstractPropagator.propagate(s0.getDate().shiftedBy(Double.POSITIVE_INFINITY));\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}