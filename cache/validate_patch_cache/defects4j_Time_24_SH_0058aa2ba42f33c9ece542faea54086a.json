{
    "patch": "try {\n    for (int i = 0; i < count; i++) {\n        try {\n            millis = savedFields[i].set(millis, resetFields);\n        } catch (IllegalFieldValueException e1) {\n            if (iSavedFieldsShared) {\n                iSavedFields = (SavedField[])iSavedFields.clone();\n                iSavedFieldsShared = false;\n                savedFields = iSavedFields;\n            }\n            int bestIndex = indexOfSupportedResetField(savedFields, i, e1.getIllegalFieldValue());\n            if (bestIndex < 0) {\n                if (text != null) {\n                    e1.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                }\n                throw e1;\n            }\n            DurationField[] fields = new DurationField[bestIndex - i + 1];\n            for (int j = i; j <= bestIndex; ++j) {\n                fields[j - i] = savedFields[j].iField.getDurationField();\n            }\n            int oldValue = savedFields[bestIndex].getValue();\n            int min = savedFields[bestIndex].getMinimumValue();\n            int max = savedFields[bestIndex].getMaximumValue();\n            boolean extended = savedFields[bestIndex].isSavedFieldForDateTime();\n            for (int value = min; value < max; ++value) {\n                savedFields[bestIndex].setValue(value, extended);\n                long newMillis = savedFields[i].set(millis, resetFields);\n                if (newMillis < millis) {\n                    for (int j = i + 1; j <= bestIndex; j++) {\n                        try {\n                            newMillis = savedFields[j].set(newMillis, resetFields);\n                        } catch (IllegalFieldValueException e2) {\n                            if (text != null) {\n                                e2.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                            }\n                            throw e2;\n                        }\n                    }\n                    for (int j = bestIndex + 1; j < count; j++) {\n                        try {\n                            newMillis = savedFields[j].set(newMillis, resetFields);\n                        } catch (IllegalFieldValueException e2) {\n                            if (text != null) {\n                                e2.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                            }\n                            throw e2;\n                        }\n                    }\n                    millis = newMillis;\n                    break;\n                }\n            }\n            if (millis == savedFields[bestIndex].setValue(oldValue, extended)) {\n                if (text != null) {\n                    throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Value \" + e1.getIllegalFieldValue() + \n                            \" for \" + savedFields[i].getName() + \" is not supported. Supported values are: \" + Arrays.toString(getSupportedValues(fields)) + \".\");\n                } else {\n                    throw new IllegalArgumentException(\"Value \" + e1.getIllegalFieldValue() + \n                            \" for \" + savedFields[i].getName() + \" is not supported. Supported values are: \" + Arrays.toString(getSupportedValues(fields)) + \".\");\n                }\n            }\n        }\n    }\n} catch (IllegalFieldValueException e) {\n    if (text != null) {\n        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n    }\n    throw e;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..4326b51e 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,76 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+try {\n+    for (int i = 0; i < count; i++) {\n+        try {\n+            millis = savedFields[i].set(millis, resetFields);\n+        } catch (IllegalFieldValueException e1) {\n+            if (iSavedFieldsShared) {\n+                iSavedFields = (SavedField[])iSavedFields.clone();\n+                iSavedFieldsShared = false;\n+                savedFields = iSavedFields;\n+            }\n+            int bestIndex = indexOfSupportedResetField(savedFields, i, e1.getIllegalFieldValue());\n+            if (bestIndex < 0) {\n+                if (text != null) {\n+                    e1.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                }\n+                throw e1;\n+            }\n+            DurationField[] fields = new DurationField[bestIndex - i + 1];\n+            for (int j = i; j <= bestIndex; ++j) {\n+                fields[j - i] = savedFields[j].iField.getDurationField();\n+            }\n+            int oldValue = savedFields[bestIndex].getValue();\n+            int min = savedFields[bestIndex].getMinimumValue();\n+            int max = savedFields[bestIndex].getMaximumValue();\n+            boolean extended = savedFields[bestIndex].isSavedFieldForDateTime();\n+            for (int value = min; value < max; ++value) {\n+                savedFields[bestIndex].setValue(value, extended);\n+                long newMillis = savedFields[i].set(millis, resetFields);\n+                if (newMillis < millis) {\n+                    for (int j = i + 1; j <= bestIndex; j++) {\n+                        try {\n+                            newMillis = savedFields[j].set(newMillis, resetFields);\n+                        } catch (IllegalFieldValueException e2) {\n+                            if (text != null) {\n+                                e2.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                            }\n+                            throw e2;\n+                        }\n+                    }\n+                    for (int j = bestIndex + 1; j < count; j++) {\n+                        try {\n+                            newMillis = savedFields[j].set(newMillis, resetFields);\n+                        } catch (IllegalFieldValueException e2) {\n+                            if (text != null) {\n+                                e2.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                            }\n+                            throw e2;\n+                        }\n+                    }\n+                    millis = newMillis;\n+                    break;\n+                }\n+            }\n+            if (millis == savedFields[bestIndex].setValue(oldValue, extended)) {\n+                if (text != null) {\n+                    throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Value \" + e1.getIllegalFieldValue() + \n+                            \" for \" + savedFields[i].getName() + \" is not supported. Supported values are: \" + Arrays.toString(getSupportedValues(fields)) + \".\");\n+                } else {\n+                    throw new IllegalArgumentException(\"Value \" + e1.getIllegalFieldValue() + \n+                            \" for \" + savedFields[i].getName() + \" is not supported. Supported values are: \" + Arrays.toString(getSupportedValues(fields)) + \".\");\n+                }\n+            }\n+        }\n+    }\n+} catch (IllegalFieldValueException e) {\n+    if (text != null) {\n+        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+    }\n+    throw e;\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}