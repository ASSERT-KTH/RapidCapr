{
    "patch": "ObjectType thisType = functionType.getTypeOfThis();\nif (thisType != null && !(NodeUtil.isGet(parent) || NodeUtil.isGetElem(parent))) {\n  report(t, n, FUNCTION_WITHOUT_GETTHIS, childType.toString());\n  ensureTyped(t, n);\n  return;\n}\n\nList<JSType> formalParamTypes = functionType.getParameterTypes();\nList<Node> actualParams = new ArrayList<>();\nNodeUtil.getArgumentsForCallOrNew(n, actualParams);\n\nif (formalParamTypes.size() != actualParams.size()) {\n  report(t, n, MISMATCHED_PARAMETERS, String.valueOf(formalParamTypes.size()),\n         String.valueOf(actualParams.size()));\n}\n\nJSType returnType = functionType.getReturnType();\nint minSize = Math.min(formalParamTypes.size(), actualParams.size());\nfor (int i = 0; i < minSize; i++) {\n  Node param = actualParams.get(i);\n  JSType paramType = getJSType(param);\n  JSType formalParamType = formalParamTypes.get(i);\n\n  JSType unifiedType = paramType.getLeastSupertype(formalParamType);\n  boolean isValid = unifiedType.isValidType();\n\n  if (!isValid) {\n    report(\n        t,\n        param,\n        INVALID_ARGUMENT_TYPE,\n        String.valueOf(i + 1),\n        unifiedType.toString(),\n        formalParamType.toString());\n  }\n}\n\nensureTyped(t, n, returnType);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..0a058f4e 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,44 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+ObjectType thisType = functionType.getTypeOfThis();\n+if (thisType != null && !(NodeUtil.isGet(parent) || NodeUtil.isGetElem(parent))) {\n+  report(t, n, FUNCTION_WITHOUT_GETTHIS, childType.toString());\n+  ensureTyped(t, n);\n+  return;\n+}\n+\n+List<JSType> formalParamTypes = functionType.getParameterTypes();\n+List<Node> actualParams = new ArrayList<>();\n+NodeUtil.getArgumentsForCallOrNew(n, actualParams);\n+\n+if (formalParamTypes.size() != actualParams.size()) {\n+  report(t, n, MISMATCHED_PARAMETERS, String.valueOf(formalParamTypes.size()),\n+         String.valueOf(actualParams.size()));\n+}\n+\n+JSType returnType = functionType.getReturnType();\n+int minSize = Math.min(formalParamTypes.size(), actualParams.size());\n+for (int i = 0; i < minSize; i++) {\n+  Node param = actualParams.get(i);\n+  JSType paramType = getJSType(param);\n+  JSType formalParamType = formalParamTypes.get(i);\n+\n+  JSType unifiedType = paramType.getLeastSupertype(formalParamType);\n+  boolean isValid = unifiedType.isValidType();\n+\n+  if (!isValid) {\n+    report(\n+        t,\n+        param,\n+        INVALID_ARGUMENT_TYPE,\n+        String.valueOf(i + 1),\n+        unifiedType.toString(),\n+        formalParamType.toString());\n+  }\n+}\n+\n+ensureTyped(t, n, returnType);\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}