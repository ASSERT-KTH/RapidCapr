{
    "patch": "public abstract class TransformDispatcher extends TypeSafeDispatcher<Node> {\n  private ErrorReporter errorReporter;\n  private String sourceName;\n  private final Set<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\", \"use asm\");\n\n  TransformDispatcher() {}\n\n  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n        n.getFirstChild().isString() &&\n        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  protected Node transform(AstNode node) {\n    return node == null ? null : node.visit(this);\n  }\n\n  protected Node transformBlock(AstNode node) {\n    Block blockNode = (Block) node;\n    Node result = newNode(Token.BLOCK);\n    int kidCount = blockNode.getChildCount();\n    for (int i = 0; i < kidCount; i++) {\n      AstNode kidNode = blockNode.getChildAtIndex(i);\n      Node newKidNode = transform(kidNode);\n      if (newKidNode != null) {\n        result.addChildToBack(newKidNode);\n      }\n    }\n    return result;\n  }\n\n  protected Node transformLabel(AstNode node) {\n    Node result = newNode(Token.LABEL);\n    // Name is always first child\n    result.addChildToBack(transform(node.getFirstChild()));\n    // Statement is always second child\n    result.addChildToBack(transform(node.getLastChild()));\n    return result;\n  }\n\n  protected Node transformName(AstNode node) {\n    String identifier = node.getString();\n    if (Token.BREAK == node.getType()) {\n      return transformBreak(identifier, node);\n    } else if (Token.CONTINUE == node.getType()) {\n      return transformContinue(identifier, node);\n    } else if (Token.LABEL_NAME == node.getType()) {\n      // Treat labeled name as just a regular NAME\n      return transform(new Name(identifier));\n    }\n    Node n = newNode(Token.NAME, identifier);\n    if (node instanceof Name) {\n      n.setScope(((Name) node).getScope());\n    }\n    return n;\n  }\n\n  protected Node transformString(AstNode node) {\n    return newNode(Token.STRING, node.getString());\n  }\n\n  protected Node transformNumber(AstNode node) {\n    return newNode(Token.NUMBER, Double.parseDouble(node.getString()));\n  }\n\n  protected Node newNode(int type, AstNode... children) {\n    Node n = IRFactory.createNode(type);\n    for (AstNode child : children) {\n      if (child != null) {\n        n.addChildToBack(child.visit(this));\n      }\n    }\n    return n;\n  }\n\n  protected Node newNode(int type) {\n    return IRFactory.createNode(type);\n  }\n\n  protected Node transformBreak(String identifier, AstNode node) {\n    Node n = newNode(Token.BREAK);\n    if (identifier != null) {\n      Node label = IRFactory.createName(identifier);\n      // Change the NAME to LABEL_NAME\n      label.setType(Token.LABEL_NAME);\n      n.addChildToBack(label);\n    }\n    // Mark as a synthetic node so that it doesn't show up in mappings.\n    if (node != null) {\n      IRFactory.markDebugInfo(n, node.getLineno(), 0);\n    }\n    return n;\n  }\n\n  protected Node transformContinue(String identifier, AstNode node) {\n    Node n = newNode(Token.CONTINUE);\n    if (identifier != null) {\n      Node label = IRFactory.createName(identifier);\n      // Change the NAME to LABEL_NAME\n      label.setType(Token.LABEL_NAME);\n      n.addChildToBack(label);\n    }\n    // Mark as a synthetic node so that it doesn't show up in mappings.\n    if (node != null) {\n      IRFactory.markDebugInfo(n, node.getLineno(), 0);\n    }\n    return n;\n  }\n\n  protected boolean isNormalBlock(AstNode node) {\n    if (!(node instanceof Block)) {\n      return false;\n    }\n    Block block = (Block)node;\n    if (block.getChildCount() != 1) {\n      return false;\n    }\n    // Make sure there are no directives in the block.\n    Node first = block.getFirstChild();\n    return !isDirective(first);\n  }\n\n  protected Node transformFunction(FunctionNode functionNode) {\n    Node functionParentNode = newNode(Token.FUNCTION);\n    Node nameNode = functionNode.getName() == null ? null : newNode(Token.NAME, functionNode.getName());\n    Node paramsNode = newNode(Token.PARAM_LIST);\n    for (int i = 0; i < functionNode.getParamCount(); i++) {\n      paramsNode.addChildToBack(newNode(Token.NAME, functionNode.getParamOrVarName(i)));\n    }\n\n    // If there is no \"real\" body, then this is an interface-only declaration.\n    Node bodyNode = null;\n    List<AstNode> statements;\n    if (functionNode.getBody() == null) {\n      // Fake an empty function body.\n      bodyNode = newNode(Token.BLOCK);\n      statements = Collections.emptyList();\n    } else if (isNormalBlock(functionNode.getBody())) {\n      bodyNode = transformBlock(functionNode.getBody());\n      statements = functionNode.getBody().getStatements();\n    } else {\n      // Normalize the function body with a block.\n      Block normalizedBlock = IRFactory.createBlock();\n      normalizedBlock.addAll(functionNode.getBody().getStatements());\n      bodyNode = transformBlock(normalizedBlock);\n      statements = normalizedBlock.getStatements();\n    }\n\n    for (AstNode statement : statements) {\n      // In nested scopes (of a function with \"var\" declarations), introduce VAR\n      // instead of adding to the existing enclosing VAR.\n      if (statement.getType() == Token.VAR) {\n        // VAR_LIST is the first child of the VAR node.\n        int varCount = statement.getFirstChild().getChildCount();\n        for (int i = 0; i < varCount; i++) {\n          Node varNode = statement.getFirstChild().getChildAt(i).visit(this);\n          varNode.putProp(Node.IS_CATCH_SCOPE,  // Do this lazily for efficiency\n              functionNode.getBody().getScope().getParentScope() != null);\n          functionParentNode.addChildToBack(newNode(varNode.getType(), varNode));\n        }\n      } else {\n        functionParentNode.addChildToBack(statement.visit(this));\n      }\n    }\n\n    functionParentNode.addChildToFront(paramsNode);\n    if (nameNode != null) {\n      functionParentNode.addChildToFront(nameNode);\n    }\n    functionParentNode.addChildToBack(bodyNode);\n\n    functionParentNode.putProp(Node.ORIGINALNAME_PROP, functionNode.getFunctionName());\n    JSDocInfo info = functionNode.getJSDocInfo();\n    if (info != null) {\n      functionParentNode.setJSDocInfo(info);\n    }\n    return functionParentNode;\n  }\n\n  protected Node transformThrow(AstNode node) {\n    Node exceptionNode = newNode(Token.THROW, node.visit(this));\n    return exceptionNode;\n  }\n\n  protected Node transformLabeledStatement(LabeledStatement labeledStatement) {\n    Node labelNode = transform(labeledStatement.getLabel());\n    Node statementNode = transform(labeledStatement.getStatement());\n    Node node = newNode(Token.LABEL, labelNode, statementNode);\n    return node;\n  }\n\n  @Override\n  protected Node visit(AstNode node) {\n    throw new RuntimeException(\"Unexpected node type: \" + node.getClass());\n  }\n\n  // Add a dummy return so we don't have to add one to the end of every method.\n  @Override\n  protected Node defaultValue(AstNode node) {\n    return null;\n  }\n\n  @Override\n  protected Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  protected Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  protected Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  protected Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  protected Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  @Override\n  protected Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  @Override\n  protected Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  protected Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  protected Node processForInLoop(ForInLoop loopNode) {\n    Node left = transform(loopNode.getIterator());\n\n    if (left.getType() == Token.VAR) {\n      // Make sure we catch for(x in []) and for(let x in [])\n      left.getFirstChild().setType(Token.NAME);\n    } else {\n      left.setType(Token.NAME);\n    }\n\n    Node arr = transform(loopNode.getIteratedObject());\n    Node body = transformBlock(loopNode.getBody());\n\n    if (loopNode.isForEach()) {\n      return newNode(Token.FOR_OF, left, arr, body);\n    }\n    return newNode(Token.FOR_IN, left, arr, body);\n  }\n\n  @Override\n  protected Node processForLoop(ForLoop loopNode) {\n    Node node = newNode(Token.FOR);\n\n    // Initializer. Can be a declaration or an expression.\n    if (loopNode.getInitializer() != null) {\n      Node initializerNode = transform(loopNode.getInitializer());\n      int type = initializerNode.getType();\n      if (type == Token.VAR || type == Token.LET || type == Token.CONST) {\n        node.addChildToBack(initializerNode);\n      } else {\n        // WRAP the expression with an EXPR_RESULT node, to meet the expectation\n        // of the FOR loop construction.\n        Node exprStmtNode = newNode(Token.EXPR_RESULT, initializerNode);\n        node.addChildToBack(exprStmtNode);\n      }\n    } else {\n      // No initializer means an empty VAR block.\n      node.addChildToBack(newNode(Token.VAR));\n    }\n\n    // Test\n    if (loopNode.getCondition() != null) {\n      node.addChildToBack(transform(loopNode.getCondition()));\n    } else {\n      node.addChildToBack(newNode(Token.EMPTY));\n    }\n\n    // Increment\n    if (loopNode.getIncrement() != null) {\n      // WRAP the expression with an EXPR_RESULT node, to meet the expectation\n      // of the FOR loop construction.\n      Node exprStmtNode = newNode(Token.EXPR_RESULT, transform(loopNode.getIncrement()));\n      node.addChildToBack(exprStmtNode);\n    }\n\n    // Body\n    node.addChildToBack(transformBlock(loopNode.getBody()));\n\n    return node;\n  }\n\n  @Override\n  protected Node processFunction(FunctionNode functionNode) {\n    return transformFunction(functionNode);\n  }\n\n  @Override\n  protected Node processIfStatement(IfStatement statementNode) {\n    return newNode(\n        Token.IF,\n        transform(statementNode.getCondition()),\n        transformBlock(statementNode.getThenPart()),\n        statementNode.getElsePart() == null ? null : transformBlock(statementNode.getElsePart()));\n  }\n\n  @Override\n  protected Node processInfixExpression(InfixExpression exprNode) {\n    Node left = transform(exprNode.getLeft());\n    Node right = transform(exprNode.getRight());\n    Node newNode;\n    if (exprNode.getType() == Token.COMMA) {\n      newNode = new Node(Token.COMMA);\n      newNode.addChildToBack(left);\n      newNode.addChildToBack(right);\n    } else if (!exprNode.isAssignment()) {\n      newNode =\n          new Node(exprNode.getType(), left, right);\n    } else { // Assignments require special casing.\n      // Compound assignments need to be swapped,\n      // e.g. (a += b) -> (a = a + b)\n      if (exprNode instanceof Assignment) {\n        left = transform(exprNode.getLeft().cloneNode());\n        AstNode rightClone = exprNode.getRight().cloneNode();\n        AstNode operator = exprNode.getOperator().cloneNode();\n        right = new InfixExpression(operator, left, rightClone, exprNode.getLineno());\n        ((InfixExpression) right).setIsAssignment(true);\n        newNode = new Node(Token.ASSIGN, left, right);\n      } else {\n        if (exprNode.getLeft().getType() == Token.GETPROP) {\n          // a.b = <expr> -> a['b'] = <expr>\n          Node target = left.removeFirstChild();\n          String property = left.getFirstChild().getString();\n          Node newTarget = new Node(Token.GETELEM, target, newNode(Token.STRING, property));\n          newNode = new Node(Token.ASSIGN, newTarget, right);\n        } else if (exprNode.getLeft().getType() == Token.GETELEM) {\n          // a[b] = <expr> -> (tmp = a) && (tmp[b] = <expr>) && <expr>\n          Node target = left.removeFirstChild();\n          Node property = left.removeFirstChild();\n          Node tmp = IRFactory.createName(inventName());\n          Node assign = IRFactory.createAssign(IRFactory.createGetElem(tmp.cloneNode(), property), right);\n          assign.setLineno(exprNode.getLineno());\n          Node stmt = newNode(Token.AND, IRFactory.createAssign(tmp, target), assign);\n        ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..417a0f7f 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,407 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public abstract class TransformDispatcher extends TypeSafeDispatcher<Node> {\n+  private ErrorReporter errorReporter;\n+  private String sourceName;\n+  private final Set<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\", \"use asm\");\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  TransformDispatcher() {}\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+        n.getFirstChild().isString() &&\n+        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  protected Node transform(AstNode node) {\n+    return node == null ? null : node.visit(this);\n+  }\n+\n+  protected Node transformBlock(AstNode node) {\n+    Block blockNode = (Block) node;\n+    Node result = newNode(Token.BLOCK);\n+    int kidCount = blockNode.getChildCount();\n+    for (int i = 0; i < kidCount; i++) {\n+      AstNode kidNode = blockNode.getChildAtIndex(i);\n+      Node newKidNode = transform(kidNode);\n+      if (newKidNode != null) {\n+        result.addChildToBack(newKidNode);\n       }\n-      return node;\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  protected Node transformLabel(AstNode node) {\n+    Node result = newNode(Token.LABEL);\n+    // Name is always first child\n+    result.addChildToBack(transform(node.getFirstChild()));\n+    // Statement is always second child\n+    result.addChildToBack(transform(node.getLastChild()));\n+    return result;\n+  }\n+\n+  protected Node transformName(AstNode node) {\n+    String identifier = node.getString();\n+    if (Token.BREAK == node.getType()) {\n+      return transformBreak(identifier, node);\n+    } else if (Token.CONTINUE == node.getType()) {\n+      return transformContinue(identifier, node);\n+    } else if (Token.LABEL_NAME == node.getType()) {\n+      // Treat labeled name as just a regular NAME\n+      return transform(new Name(identifier));\n+    }\n+    Node n = newNode(Token.NAME, identifier);\n+    if (node instanceof Name) {\n+      n.setScope(((Name) node).getScope());\n+    }\n+    return n;\n+  }\n+\n+  protected Node transformString(AstNode node) {\n+    return newNode(Token.STRING, node.getString());\n+  }\n+\n+  protected Node transformNumber(AstNode node) {\n+    return newNode(Token.NUMBER, Double.parseDouble(node.getString()));\n+  }\n+\n+  protected Node newNode(int type, AstNode... children) {\n+    Node n = IRFactory.createNode(type);\n+    for (AstNode child : children) {\n+      if (child != null) {\n+        n.addChildToBack(child.visit(this));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n+    return n;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  protected Node newNode(int type) {\n+    return IRFactory.createNode(type);\n+  }\n+\n+  protected Node transformBreak(String identifier, AstNode node) {\n+    Node n = newNode(Token.BREAK);\n+    if (identifier != null) {\n+      Node label = IRFactory.createName(identifier);\n+      // Change the NAME to LABEL_NAME\n+      label.setType(Token.LABEL_NAME);\n+      n.addChildToBack(label);\n     }\n+    // Mark as a synthetic node so that it doesn't show up in mappings.\n+    if (node != null) {\n+      IRFactory.markDebugInfo(n, node.getLineno(), 0);\n+    }\n+    return n;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  protected Node transformContinue(String identifier, AstNode node) {\n+    Node n = newNode(Token.CONTINUE);\n+    if (identifier != null) {\n+      Node label = IRFactory.createName(identifier);\n+      // Change the NAME to LABEL_NAME\n+      label.setType(Token.LABEL_NAME);\n+      n.addChildToBack(label);\n+    }\n+    // Mark as a synthetic node so that it doesn't show up in mappings.\n+    if (node != null) {\n+      IRFactory.markDebugInfo(n, node.getLineno(), 0);\n+    }\n+    return n;\n+  }\n+\n+  protected boolean isNormalBlock(AstNode node) {\n+    if (!(node instanceof Block)) {\n+      return false;\n+    }\n+    Block block = (Block)node;\n+    if (block.getChildCount() != 1) {\n+      return false;\n+    }\n+    // Make sure there are no directives in the block.\n+    Node first = block.getFirstChild();\n+    return !isDirective(first);\n+  }\n+\n+  protected Node transformFunction(FunctionNode functionNode) {\n+    Node functionParentNode = newNode(Token.FUNCTION);\n+    Node nameNode = functionNode.getName() == null ? null : newNode(Token.NAME, functionNode.getName());\n+    Node paramsNode = newNode(Token.PARAM_LIST);\n+    for (int i = 0; i < functionNode.getParamCount(); i++) {\n+      paramsNode.addChildToBack(newNode(Token.NAME, functionNode.getParamOrVarName(i)));\n+    }\n+\n+    // If there is no \"real\" body, then this is an interface-only declaration.\n+    Node bodyNode = null;\n+    List<AstNode> statements;\n+    if (functionNode.getBody() == null) {\n+      // Fake an empty function body.\n+      bodyNode = newNode(Token.BLOCK);\n+      statements = Collections.emptyList();\n+    } else if (isNormalBlock(functionNode.getBody())) {\n+      bodyNode = transformBlock(functionNode.getBody());\n+      statements = functionNode.getBody().getStatements();\n+    } else {\n+      // Normalize the function body with a block.\n+      Block normalizedBlock = IRFactory.createBlock();\n+      normalizedBlock.addAll(functionNode.getBody().getStatements());\n+      bodyNode = transformBlock(normalizedBlock);\n+      statements = normalizedBlock.getStatements();\n+    }\n+\n+    for (AstNode statement : statements) {\n+      // In nested scopes (of a function with \"var\" declarations), introduce VAR\n+      // instead of adding to the existing enclosing VAR.\n+      if (statement.getType() == Token.VAR) {\n+        // VAR_LIST is the first child of the VAR node.\n+        int varCount = statement.getFirstChild().getChildCount();\n+        for (int i = 0; i < varCount; i++) {\n+          Node varNode = statement.getFirstChild().getChildAt(i).visit(this);\n+          varNode.putProp(Node.IS_CATCH_SCOPE,  // Do this lazily for efficiency\n+              functionNode.getBody().getScope().getParentScope() != null);\n+          functionParentNode.addChildToBack(newNode(varNode.getType(), varNode));\n+        }\n+      } else {\n+        functionParentNode.addChildToBack(statement.visit(this));\n       }\n-      return node;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    functionParentNode.addChildToFront(paramsNode);\n+    if (nameNode != null) {\n+      functionParentNode.addChildToFront(nameNode);\n     }\n+    functionParentNode.addChildToBack(bodyNode);\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    functionParentNode.putProp(Node.ORIGINALNAME_PROP, functionNode.getFunctionName());\n+    JSDocInfo info = functionNode.getJSDocInfo();\n+    if (info != null) {\n+      functionParentNode.setJSDocInfo(info);\n     }\n+    return functionParentNode;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  protected Node transformThrow(AstNode node) {\n+    Node exceptionNode = newNode(Token.THROW, node.visit(this));\n+    return exceptionNode;\n+  }\n+\n+  protected Node transformLabeledStatement(LabeledStatement labeledStatement) {\n+    Node labelNode = transform(labeledStatement.getLabel());\n+    Node statementNode = transform(labeledStatement.getStatement());\n+    Node node = newNode(Token.LABEL, labelNode, statementNode);\n+    return node;\n+  }\n+\n+  @Override\n+  protected Node visit(AstNode node) {\n+    throw new RuntimeException(\"Unexpected node type: \" + node.getClass());\n+  }\n+\n+  // Add a dummy return so we don't have to add one to the end of every method.\n+  @Override\n+  protected Node defaultValue(AstNode node) {\n+    return null;\n+  }\n+\n+  @Override\n+  protected Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  protected Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  protected Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  protected Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n+\n+  @Override\n+  protected Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  protected Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  protected Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  protected Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  protected Node processForInLoop(ForInLoop loopNode) {\n+    Node left = transform(loopNode.getIterator());\n+\n+    if (left.getType() == Token.VAR) {\n+      // Make sure we catch for(x in []) and for(let x in [])\n+      left.getFirstChild().setType(Token.NAME);\n+    } else {\n+      left.setType(Token.NAME);\n+    }\n+\n+    Node arr = transform(loopNode.getIteratedObject());\n+    Node body = transformBlock(loopNode.getBody());\n+\n+    if (loopNode.isForEach()) {\n+      return newNode(Token.FOR_OF, left, arr, body);\n+    }\n+    return newNode(Token.FOR_IN, left, arr, body);\n+  }\n+\n+  @Override\n+  protected Node processForLoop(ForLoop loopNode) {\n+    Node node = newNode(Token.FOR);\n+\n+    // Initializer. Can be a declaration or an expression.\n+    if (loopNode.getInitializer() != null) {\n+      Node initializerNode = transform(loopNode.getInitializer());\n+      int type = initializerNode.getType();\n+      if (type == Token.VAR || type == Token.LET || type == Token.CONST) {\n+        node.addChildToBack(initializerNode);\n+      } else {\n+        // WRAP the expression with an EXPR_RESULT node, to meet the expectation\n+        // of the FOR loop construction.\n+        Node exprStmtNode = newNode(Token.EXPR_RESULT, initializerNode);\n+        node.addChildToBack(exprStmtNode);\n+      }\n+    } else {\n+      // No initializer means an empty VAR block.\n+      node.addChildToBack(newNode(Token.VAR));\n+    }\n+\n+    // Test\n+    if (loopNode.getCondition() != null) {\n+      node.addChildToBack(transform(loopNode.getCondition()));\n+    } else {\n+      node.addChildToBack(newNode(Token.EMPTY));\n+    }\n+\n+    // Increment\n+    if (loopNode.getIncrement() != null) {\n+      // WRAP the expression with an EXPR_RESULT node, to meet the expectation\n+      // of the FOR loop construction.\n+      Node exprStmtNode = newNode(Token.EXPR_RESULT, transform(loopNode.getIncrement()));\n+      node.addChildToBack(exprStmtNode);\n+    }\n+\n+    // Body\n+    node.addChildToBack(transformBlock(loopNode.getBody()));\n+\n+    return node;\n+  }\n+\n+  @Override\n+  protected Node processFunction(FunctionNode functionNode) {\n+    return transformFunction(functionNode);\n+  }\n+\n+  @Override\n+  protected Node processIfStatement(IfStatement statementNode) {\n+    return newNode(\n+        Token.IF,\n+        transform(statementNode.getCondition()),\n+        transformBlock(statementNode.getThenPart()),\n+        statementNode.getElsePart() == null ? null : transformBlock(statementNode.getElsePart()));\n+  }\n+\n+  @Override\n+  protected Node processInfixExpression(InfixExpression exprNode) {\n+    Node left = transform(exprNode.getLeft());\n+    Node right = transform(exprNode.getRight());\n+    Node newNode;\n+    if (exprNode.getType() == Token.COMMA) {\n+      newNode = new Node(Token.COMMA);\n+      newNode.addChildToBack(left);\n+      newNode.addChildToBack(right);\n+    } else if (!exprNode.isAssignment()) {\n+      newNode =\n+          new Node(exprNode.getType(), left, right);\n+    } else { // Assignments require special casing.\n+      // Compound assignments need to be swapped,\n+      // e.g. (a += b) -> (a = a + b)\n+      if (exprNode instanceof Assignment) {\n+        left = transform(exprNode.getLeft().cloneNode());\n+        AstNode rightClone = exprNode.getRight().cloneNode();\n+        AstNode operator = exprNode.getOperator().cloneNode();\n+        right = new InfixExpression(operator, left, rightClone, exprNode.getLineno());\n+        ((InfixExpression) right).setIsAssignment(true);\n+        newNode = new Node(Token.ASSIGN, left, right);\n+      } else {\n+        if (exprNode.getLeft().getType() == Token.GETPROP) {\n+          // a.b = <expr> -> a['b'] = <expr>\n+          Node target = left.removeFirstChild();\n+          String property = left.getFirstChild().getString();\n+          Node newTarget = new Node(Token.GETELEM, target, newNode(Token.STRING, property));\n+          newNode = new Node(Token.ASSIGN, newTarget, right);\n+        } else if (exprNode.getLeft().getType() == Token.GETELEM) {\n+          // a[b] = <expr> -> (tmp = a) && (tmp[b] = <expr>) && <expr>\n+          Node target = left.removeFirstChild();\n+          Node property = left.removeFirstChild();\n+          Node tmp = IRFactory.createName(inventName());\n+          Node assign = IRFactory.createAssign(IRFactory.createGetElem(tmp.cloneNode(), property), right);\n+          assign.setLineno(exprNode.getLineno());\n+          Node stmt = newNode(Token.AND, IRFactory.createAssign(tmp, target), assign);\n+        \n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}