{
    "patch": "JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n    Set<JSType> resolvedTypes = new HashSet<>();\n    JSType currentType = this;\n\n    do {\n        boolean resolved = currentType.resolveViaRegistry(t, enclosing);\n\n        while (!resolved) {\n            resolved = currentType.resolveViaProperties(t, enclosing);\n\n            if (resolved) {\n                currentType.finishPropertyContinuations();\n                break;\n            }\n\n            boolean cycleDetected = currentType.detectImplicitPrototypeCycle();\n            if (cycleDetected) {\n                currentType.handleTypeCycle(t);\n                break;\n            }\n        }\n\n        resolvedTypes.add(currentType);\n        if (currentType.isResolved() || resolvedTypes.contains(currentType.getReference())) {\n            break;\n        }\n\n        JSType lastType = currentType;\n        currentType = currentType.getReference();\n        lastType.setReference(null);\n    } while (true);\n\n    if (currentType.isResolved()) {\n        currentType.super.resolveInternal(t, enclosing);\n        currentType.finishPropertyContinuations();\n        return currentType.registry.isLastGeneration() ? currentType.getReferencedType() : currentType;\n    } else {\n        return currentType;\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/NamedType.java b/src/com/google/javascript/rhino/jstype/NamedType.java\nindex 70142c45..fa42ca72 100644\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n@@ -181,35 +181,46 @@ class NamedType extends ProxyObjectType {\n    * Resolve the referenced type within the enclosing scope.\n    */\n   @Override\n-  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n-    // TODO(user): Investigate whether it is really necessary to keep two\n-    // different mechanisms for resolving named types, and if so, which order\n-    // makes more sense. Now, resolution via registry is first in order to\n-    // avoid triggering the warnings built into the resolution via properties.\n-    boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n-      handleTypeCycle(t);\n-    }\n+JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n+    Set<JSType> resolvedTypes = new HashSet<>();\n+    JSType currentType = this;\n+\n+    do {\n+        boolean resolved = currentType.resolveViaRegistry(t, enclosing);\n+\n+        while (!resolved) {\n+            resolved = currentType.resolveViaProperties(t, enclosing);\n+\n+            if (resolved) {\n+                currentType.finishPropertyContinuations();\n+                break;\n+            }\n+\n+            boolean cycleDetected = currentType.detectImplicitPrototypeCycle();\n+            if (cycleDetected) {\n+                currentType.handleTypeCycle(t);\n+                break;\n+            }\n+        }\n \n-    if (resolved) {\n-      super.resolveInternal(t, enclosing);\n-      finishPropertyContinuations();\n-      return registry.isLastGeneration() ?\n-          getReferencedType() : this;\n-    }\n+        resolvedTypes.add(currentType);\n+        if (currentType.isResolved() || resolvedTypes.contains(currentType.getReference())) {\n+            break;\n+        }\n \n-    resolveViaProperties(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n-      handleTypeCycle(t);\n-    }\n+        JSType lastType = currentType;\n+        currentType = currentType.getReference();\n+        lastType.setReference(null);\n+    } while (true);\n \n-    super.resolveInternal(t, enclosing);\n-    if (isResolved()) {\n-      finishPropertyContinuations();\n+    if (currentType.isResolved()) {\n+        currentType.super.resolveInternal(t, enclosing);\n+        currentType.finishPropertyContinuations();\n+        return currentType.registry.isLastGeneration() ? currentType.getReferencedType() : currentType;\n+    } else {\n+        return currentType;\n     }\n-    return registry.isLastGeneration() ?\n-        getReferencedType() : this;\n-  }\n+}\n \n   /**\n    * Resolves a named type by looking it up in the registry.",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}