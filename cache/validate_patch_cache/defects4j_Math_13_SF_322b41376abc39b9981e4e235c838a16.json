{
    "patch": "        final int n = m.getRowDimension();\n        final EigenDecomposition dec = new EigenDecomposition(m);\n\n        // Use Schur-Parlett algorithm for large matrices\n        if (n > 1000) {\n            final double[] realEigenvalues = dec.getRealEigenvalues();\n            final RealMatrix t = dec.getT();\n            final double[] tData = t.getData()[0];\n    \n            for (int i = 0; i < n; i++) {\n                tData[i] = FastMath.sqrt(FastMath.abs(realEigenvalues[i]));\n            }\n    \n            final RealMatrix sqrtLambda = t.transpose().multiply(t);\n            final RealMatrix v = dec.getV();\n            final RealMatrix vInv = v.transpose();\n            final RealMatrix sqrtM = v.multiply(sqrtLambda).multiply(vInv);\n    \n            return sqrtM;\n        } else { // Use default algorithm for small matrices\n            return dec.getSquareRoot();\n        }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..2d9eb0b7c 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,26 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n+        final int n = m.getRowDimension();\n+        final EigenDecomposition dec = new EigenDecomposition(m);\n+\n+        // Use Schur-Parlett algorithm for large matrices\n+        if (n > 1000) {\n+            final double[] realEigenvalues = dec.getRealEigenvalues();\n+            final RealMatrix t = dec.getT();\n+            final double[] tData = t.getData()[0];\n+    \n+            for (int i = 0; i < n; i++) {\n+                tData[i] = FastMath.sqrt(FastMath.abs(realEigenvalues[i]));\n+            }\n+    \n+            final RealMatrix sqrtLambda = t.transpose().multiply(t);\n+            final RealMatrix v = dec.getV();\n+            final RealMatrix vInv = v.transpose();\n+            final RealMatrix sqrtM = v.multiply(sqrtLambda).multiply(vInv);\n+    \n+            return sqrtM;\n+        } else { // Use default algorithm for small matrices\n             return dec.getSquareRoot();\n-    }\n+        }\n }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}