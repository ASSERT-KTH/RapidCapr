{
    "patch": "        // fix overflowing SavedField values\n        for (int i = 0; i < count; i++) {\n            int next = i + 1;\n            if (next < count) {\n                DateTimeField nextField = savedFields[next].iField;\n                DurationField field = savedFields[i].iField.getDurationField();\n                long nextValue = nextField.getDurationField().getField(iChrono).getType().equals(DurationFieldType.months()) ?\n                        iChrono.months().set(0, nextField.getValue(millis)) :\n                        nextField.getDurationField().getField(iChrono).getUnitMillis() * nextField.get(nextField.getMillis(millis), nextField.getOffset(millis));\n                long gap = FieldUtils.safeSubtract(nextValue, savedFields[i].getMillis());\n                if (gap > field.getUnitMillis() && savedFields[i].getZone() == nextField.getZone()) { // overflow\n                    int steps = (int)Math.signum(gap);\n                    long stepMillis = field.getUnitMillis() * steps;\n                    do {\n                        savedFields[i].addMillis(stepMillis);\n                        gap = FieldUtils.safeSubtract(nextValue, savedFields[i].getMillis());\n                        resetFields = true;\n                    } while (gap > field.getUnitMillis() && gap < -field.getUnitMillis());\n                }\n                if (gap == 0 && savedFields[i].getZone() != nextField.getZone()) {\n                    // midnight gap, but that isn't really a gap, so merge the two saved fields\n                    savedFields[i].setZoneRetainFields(nextField.getZone());\n                    System.arraycopy(savedFields, next + 1, savedFields, next, count - next - 1);\n                    iSavedFieldsCount--;\n                    i--;\n                    count--;\n                } else {\n                    savedFields[i].setOffset(savedFields[i].getZone().getOffset(savedFields[i].getMillis()));",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..9c53e44b 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,34 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+        // fix overflowing SavedField values\n+        for (int i = 0; i < count; i++) {\n+            int next = i + 1;\n+            if (next < count) {\n+                DateTimeField nextField = savedFields[next].iField;\n+                DurationField field = savedFields[i].iField.getDurationField();\n+                long nextValue = nextField.getDurationField().getField(iChrono).getType().equals(DurationFieldType.months()) ?\n+                        iChrono.months().set(0, nextField.getValue(millis)) :\n+                        nextField.getDurationField().getField(iChrono).getUnitMillis() * nextField.get(nextField.getMillis(millis), nextField.getOffset(millis));\n+                long gap = FieldUtils.safeSubtract(nextValue, savedFields[i].getMillis());\n+                if (gap > field.getUnitMillis() && savedFields[i].getZone() == nextField.getZone()) { // overflow\n+                    int steps = (int)Math.signum(gap);\n+                    long stepMillis = field.getUnitMillis() * steps;\n+                    do {\n+                        savedFields[i].addMillis(stepMillis);\n+                        gap = FieldUtils.safeSubtract(nextValue, savedFields[i].getMillis());\n+                        resetFields = true;\n+                    } while (gap > field.getUnitMillis() && gap < -field.getUnitMillis());\n+                }\n+                if (gap == 0 && savedFields[i].getZone() != nextField.getZone()) {\n+                    // midnight gap, but that isn't really a gap, so merge the two saved fields\n+                    savedFields[i].setZoneRetainFields(nextField.getZone());\n+                    System.arraycopy(savedFields, next + 1, savedFields, next, count - next - 1);\n+                    iSavedFieldsCount--;\n+                    i--;\n+                    count--;\n+                } else {\n+                    savedFields[i].setOffset(savedFields[i].getZone().getOffset(savedFields[i].getMillis()));\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: 'catch' without 'try'",
    "test_result": "ERROR"
}