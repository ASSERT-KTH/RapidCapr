{
    "patch": "if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n    double result;\n    int lvalInt = (int) left.getDouble();\n    int rvalInt = (int) right.getDouble();\n\n    // Check the bounds of rvalInt.\n    if ((n.getType() == Token.URSH && (rvalInt < 0 || rvalInt >= 32)) ||\n        (!(n.getType() == Token.URSH) && (rvalInt < -32 || rvalInt >= 32))) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n    }\n\n    // Perform the indicated shift operation.\n    switch (n.getType()) {\n        case Token.LSH:\n            result = lvalInt << rvalInt;\n            break;\n        case Token.RSH:\n            result = lvalInt >> rvalInt;\n            break;\n        case Token.URSH:\n            result = Integer.toUnsignedLong(lvalInt) >>> rvalInt;\n            break;\n        default:\n            throw new AssertionError(\"Unknown shift operator: \" +\n                    Node.tokenToName(n.getType()));\n    }\n\n    // Replace the node with a new Number node and return it.\n    Node resultNode = Node.newNumber(result);\n    n.getParent().replaceChild(n, resultNode);\n    reportCodeChange();\n    return resultNode;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex d6c194a3..a959439e 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -695,7 +695,40 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+if (left.getType() == Token.NUMBER && right.getType() == Token.NUMBER) {\n+    double result;\n+    int lvalInt = (int) left.getDouble();\n+    int rvalInt = (int) right.getDouble();\n+\n+    // Check the bounds of rvalInt.\n+    if ((n.getType() == Token.URSH && (rvalInt < 0 || rvalInt >= 32)) ||\n+        (!(n.getType() == Token.URSH) && (rvalInt < -32 || rvalInt >= 32))) {\n+        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n+        return n;\n+    }\n+\n+    // Perform the indicated shift operation.\n+    switch (n.getType()) {\n+        case Token.LSH:\n+            result = lvalInt << rvalInt;\n+            break;\n+        case Token.RSH:\n+            result = lvalInt >> rvalInt;\n+            break;\n+        case Token.URSH:\n+            result = Integer.toUnsignedLong(lvalInt) >>> rvalInt;\n+            break;\n+        default:\n+            throw new AssertionError(\"Unknown shift operator: \" +\n+                    Node.tokenToName(n.getType()));\n+    }\n+\n+    // Replace the node with a new Number node and return it.\n+    Node resultNode = Node.newNumber(result);\n+    n.getParent().replaceChild(n, resultNode);\n+    reportCodeChange();\n+    return resultNode;\n+}\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +",
    "result_reason": "error: variable result is already defined in method tryFoldShift(Node,Node,Node)",
    "test_result": "ERROR"
}