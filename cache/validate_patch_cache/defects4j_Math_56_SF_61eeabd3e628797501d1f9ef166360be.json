{
    "patch": "public int[] getCounts(int index) {\n    if (index < 0 || index >= totalSize) {\n        throw new OutOfRangeException(index, 0, totalSize);\n    }\n\n    int[] indices = new int[dimension];\n    int remainingIndex = index;\n\n    for (int i = 0; i < last; i++) {\n        int offset = uniCounterOffset[i];\n        int count = 0;\n        while (remainingIndex >= offset) {\n            count++;\n            remainingIndex -= offset;\n        }\n        indices[i] = count;\n    }\n\n    if (last == 1) {\n        indices[0] = remainingIndex;\n    } else {\n        if (remainingIndex == 0) {\n            indices[last - 2]--;\n            indices[last - 1] = uniCounterOffset[last - 2] - 1;\n        } else {\n            indices[last - 1] = remainingIndex - 1;\n        }\n    }\n\n    return indices;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\nindex 56c9ffebc..6e94c98c6 100644\n--- a/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n+++ b/src/main/java/org/apache/commons/math/util/MultidimensionalCounter.java\n@@ -213,38 +213,38 @@ public class MultidimensionalCounter implements Iterable<Integer> {\n      * @throws OutOfRangeException if {@code index} is not between\n      * {@code 0} and the value returned by {@link #getSize()} (excluded).\n      */\n-    public int[] getCounts(int index) {\n-        if (index < 0 ||\n-            index >= totalSize) {\n-            throw new OutOfRangeException(index, 0, totalSize);\n-        }\n+public int[] getCounts(int index) {\n+    if (index < 0 || index >= totalSize) {\n+        throw new OutOfRangeException(index, 0, totalSize);\n+    }\n \n-        final int[] indices = new int[dimension];\n+    int[] indices = new int[dimension];\n+    int remainingIndex = index;\n \n+    for (int i = 0; i < last; i++) {\n+        int offset = uniCounterOffset[i];\n         int count = 0;\n-        for (int i = 0; i < last; i++) {\n-            int idx = 0;\n-            final int offset = uniCounterOffset[i];\n-            while (count <= index) {\n-                count += offset;\n-                ++idx;\n-            }\n-            --idx;\n-            count -= offset;\n-            indices[i] = idx;\n+        while (remainingIndex >= offset) {\n+            count++;\n+            remainingIndex -= offset;\n         }\n+        indices[i] = count;\n+    }\n \n-        int idx = 1;\n-        while (count < index) {\n-            count += idx;\n-            ++idx;\n+    if (last == 1) {\n+        indices[0] = remainingIndex;\n+    } else {\n+        if (remainingIndex == 0) {\n+            indices[last - 2]--;\n+            indices[last - 1] = uniCounterOffset[last - 2] - 1;\n+        } else {\n+            indices[last - 1] = remainingIndex - 1;\n         }\n-        --idx;\n-        indices[last] = idx;\n-\n-        return indices;\n     }\n \n+    return indices;\n+}\n+\n     /**\n      * Convert to unidimensional counter.\n      *",
    "result_reason": "junit.framework.AssertionFailedError: Wrong multidimensional index for [0][0] expected:<0> but was:<-1>",
    "test_result": "FAIL"
}