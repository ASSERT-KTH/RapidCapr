{
    "patch": "        double x0 = min;\n        double x1 = initial;\n        double x2 = max;\n        double f0 = f.value(x0);\n        double f1 = f.value(x1);\n        double f2 = f.value(x2);\n\n        if ((f0 > 0 && f2 > 0) || (f0 < 0 && f2 < 0)) {\n            throw new IllegalArgumentException(\"Function values at endpoints do not have opposite signs.\");\n        }\n\n        double a = f0;\n        double b = f1;\n        double c = a;\n        double d = x1 - x0;\n        double e = d;\n\n        while (true) {\n            if (abs(f1) < abs(f2)) {\n                x0 = x1;\n                x1 = x2;\n                x2 = x0;\n                f0 = f1;\n                f1 = f2;\n                f2 = f0;\n            }\n\n            double tol = 2 * Double.MIN_VALUE * abs(x1) + functionValueAccuracy;\n            double xm = 0.5 * (x2 - x1);\n\n            if (abs(xm) <= tol || abs(f1) <= functionValueAccuracy) {\n                setResult(x1, iterations.getCount());\n                return result;\n            }\n\n            if (abs(e) >= tol && abs(a) > abs(b)) {\n                double s = b / a;\n\n                double p;\n                double q;\n                if (x0 == x2) {\n                    p = 2 * xm * s;\n                    q = 1 - s;\n                } else {\n                    q = a / c;\n                    double r = b / c;\n                    p = s * (2 * xm * q * (q - r) - (x1 - x0) * (r - 1));\n                    q = (q - 1) * (r - 1) * (s - 1);\n                }\n\n                if (p > 0) {\n                    q = -q;\n                }\n\n                p = abs(p);\n\n                double min1 = 3 * xm * q - abs(tol * q);\n                double min2 = abs(e * q);\n                if (2 * p < (min1 < min2 ? min1 : min2)) {\n                    e = d;\n                    d = p / q;\n                } else {\n                    d = xm;\n                    e = d;\n                }\n            } else {\n                d = xm;\n                e = d;\n            }\n\n            x0 = x1;\n            f0 = f1;\n            if (abs(d) > tol) {\n                x1 += d;\n            } else if (xm > 0) {\n                x1 += tol;\n            } else {\n                x1 -= tol;\n            }\n            f1 = f.value(x1);\n            if ((f1 > 0 && f2 > 0) || (f1 < 0 && f2 < 0)) {\n                x0 = x2;\n                f0 = f2;\n                d = x1 - x2;\n                e = d;\n            }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..212f42209 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,92 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double x0 = min;\n+        double x1 = initial;\n+        double x2 = max;\n+        double f0 = f.value(x0);\n+        double f1 = f.value(x1);\n+        double f2 = f.value(x2);\n+\n+        if ((f0 > 0 && f2 > 0) || (f0 < 0 && f2 < 0)) {\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have opposite signs.\");\n+        }\n+\n+        double a = f0;\n+        double b = f1;\n+        double c = a;\n+        double d = x1 - x0;\n+        double e = d;\n+\n+        while (true) {\n+            if (abs(f1) < abs(f2)) {\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = x0;\n+                f0 = f1;\n+                f1 = f2;\n+                f2 = f0;\n+            }\n+\n+            double tol = 2 * Double.MIN_VALUE * abs(x1) + functionValueAccuracy;\n+            double xm = 0.5 * (x2 - x1);\n+\n+            if (abs(xm) <= tol || abs(f1) <= functionValueAccuracy) {\n+                setResult(x1, iterations.getCount());\n+                return result;\n+            }\n+\n+            if (abs(e) >= tol && abs(a) > abs(b)) {\n+                double s = b / a;\n+\n+                double p;\n+                double q;\n+                if (x0 == x2) {\n+                    p = 2 * xm * s;\n+                    q = 1 - s;\n+                } else {\n+                    q = a / c;\n+                    double r = b / c;\n+                    p = s * (2 * xm * q * (q - r) - (x1 - x0) * (r - 1));\n+                    q = (q - 1) * (r - 1) * (s - 1);\n+                }\n+\n+                if (p > 0) {\n+                    q = -q;\n+                }\n+\n+                p = abs(p);\n+\n+                double min1 = 3 * xm * q - abs(tol * q);\n+                double min2 = abs(e * q);\n+                if (2 * p < (min1 < min2 ? min1 : min2)) {\n+                    e = d;\n+                    d = p / q;\n+                } else {\n+                    d = xm;\n+                    e = d;\n+                }\n+            } else {\n+                d = xm;\n+                e = d;\n+            }\n+\n+            x0 = x1;\n+            f0 = f1;\n+            if (abs(d) > tol) {\n+                x1 += d;\n+            } else if (xm > 0) {\n+                x1 += tol;\n+            } else {\n+                x1 -= tol;\n+            }\n+            f1 = f.value(x1);\n+            if ((f1 > 0 && f2 > 0) || (f1 < 0 && f2 < 0)) {\n+                x0 = x2;\n+                f0 = f2;\n+                d = x1 - x2;\n+                e = d;\n+            }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}