{
    "patch": "      if (functionType.getTypeOfThis() != null) {\n        Node parent = n.getParent();\n        if (parent == null || !parent.isGetProp() && !parent.isGetElem()) {\n          // The function was called without a this parameter and so\n          // it's this must be undefined.\n          report(t, n, FUNCTION_CALLED_WITH_WRONG_THIS_TYPE,\n                 functionType.toString(), \"undefined\");\n          ensureTyped(t, n, JSType.UNDEFINED);\n        } else {\n          JSType expectedThisType = getJSType(parent.getFirstChild());\n          if (!expectedThisType.isSubtypeOf(functionType.getTypeOfThis())) {\n            // The function was not called with an appropriate object\n            // as its this parameter, so fallback to the type in the\n            // jsdoc or the function type (if the jsdoc does not exist).\n            expectedThisType = expectedThisType.getGreatestSubtype(functionType.getTypeOfThis());\n            report(t, n, FUNCTION_CALLED_WITH_WRONG_THIS_TYPE,\n                   functionType.toString(), expectedThisType.toString());\n            // Set the type of the 'this' to match the expected type.\n            setJSType(parent.getFirstChild(), expectedThisType);\n          }\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..1b2db018 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,27 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+      if (functionType.getTypeOfThis() != null) {\n+        Node parent = n.getParent();\n+        if (parent == null || !parent.isGetProp() && !parent.isGetElem()) {\n+          // The function was called without a this parameter and so\n+          // it's this must be undefined.\n+          report(t, n, FUNCTION_CALLED_WITH_WRONG_THIS_TYPE,\n+                 functionType.toString(), \"undefined\");\n+          ensureTyped(t, n, JSType.UNDEFINED);\n+        } else {\n+          JSType expectedThisType = getJSType(parent.getFirstChild());\n+          if (!expectedThisType.isSubtypeOf(functionType.getTypeOfThis())) {\n+            // The function was not called with an appropriate object\n+            // as its this parameter, so fallback to the type in the\n+            // jsdoc or the function type (if the jsdoc does not exist).\n+            expectedThisType = expectedThisType.getGreatestSubtype(functionType.getTypeOfThis());\n+            report(t, n, FUNCTION_CALLED_WITH_WRONG_THIS_TYPE,\n+                   functionType.toString(), expectedThisType.toString());\n+            // Set the type of the 'this' to match the expected type.\n+            setJSType(parent.getFirstChild(), expectedThisType);\n+          }\n+        }\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}