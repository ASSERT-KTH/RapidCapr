{
    "patch": "/**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n        Reference ref = getOneAndOnlyAssignment();\n        if (ref == null) {\n            return false;\n        }\n\n        // Make sure this assignment is not in a loop or finally block.\n        boolean foundDeclaration = false;\n        boolean mayBeInitializedLater = false;\n        for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {\n            if (block == ref.getBasicBlock()) {\n                continue;\n            } else if (block.isLoop || block.isFinallyBlock) {\n                return false;\n            } else if (block.isFunction && foundDeclaration) {\n                // We've iterated all the way up to the function without finding\n                // another declaration. If an initialization is found later in the\n                // function, the variable is not considered assigned once.\n                return !mayBeInitializedLater;\n            }\n\n            if (isInitializingDeclarationAt(block.getLastChildIndex())) {\n                if (foundDeclaration) {\n                    // Multiple declarations, variable cannot be assigned only once.\n                    return false;\n                }\n                foundDeclaration = true;\n            } else if (isInitializingAssignmentAt(block.getLastChildIndex())) {\n                // Only consider an assignment as initializing if it is the first\n                // initialization of the variable, or if it is in the same statement\n                // as the first initialization.\n                Reference initRef;\n                if (isInitializingDeclarationAt(block.getLastChildIndex() - 1)) {\n                    initRef = references.get(block.getLastChildIndex() - 1);\n                } else {\n                    initRef = getInitializingReference();\n                }\n                if (initRef != null && initRef.getParent() == ref.getParent()) {\n                    if (foundDeclaration) {\n                        // Multiple declarations, variable cannot be assigned only once.\n                        return false;\n                    }\n                    foundDeclaration = true;\n                } else if (initRef == ref) {\n                    return true;\n                } else {\n                    mayBeInitializedLater = true;\n                }\n            }\n        }\n\n        return !mayBeInitializedLater;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..1aebf8ca 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,62 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+/**\n+     * @return Whether the variable is only assigned a value once for its\n+     *     lifetime.\n+     */\n+    boolean isAssignedOnceInLifetime() {\n+        Reference ref = getOneAndOnlyAssignment();\n+        if (ref == null) {\n+            return false;\n+        }\n+\n+        // Make sure this assignment is not in a loop or finally block.\n+        boolean foundDeclaration = false;\n+        boolean mayBeInitializedLater = false;\n+        for (BasicBlock block = ref.getBasicBlock(); block != null; block = block.getParent()) {\n+            if (block == ref.getBasicBlock()) {\n+                continue;\n+            } else if (block.isLoop || block.isFinallyBlock) {\n+                return false;\n+            } else if (block.isFunction && foundDeclaration) {\n+                // We've iterated all the way up to the function without finding\n+                // another declaration. If an initialization is found later in the\n+                // function, the variable is not considered assigned once.\n+                return !mayBeInitializedLater;\n+            }\n+\n+            if (isInitializingDeclarationAt(block.getLastChildIndex())) {\n+                if (foundDeclaration) {\n+                    // Multiple declarations, variable cannot be assigned only once.\n+                    return false;\n+                }\n+                foundDeclaration = true;\n+            } else if (isInitializingAssignmentAt(block.getLastChildIndex())) {\n+                // Only consider an assignment as initializing if it is the first\n+                // initialization of the variable, or if it is in the same statement\n+                // as the first initialization.\n+                Reference initRef;\n+                if (isInitializingDeclarationAt(block.getLastChildIndex() - 1)) {\n+                    initRef = references.get(block.getLastChildIndex() - 1);\n+                } else {\n+                    initRef = getInitializingReference();\n+                }\n+                if (initRef != null && initRef.getParent() == ref.getParent()) {\n+                    if (foundDeclaration) {\n+                        // Multiple declarations, variable cannot be assigned only once.\n+                        return false;\n+                    }\n+                    foundDeclaration = true;\n+                } else if (initRef == ref) {\n+                    return true;\n+                } else {\n+                    mayBeInitializedLater = true;\n+                }\n+            }\n+        }\n+\n+        return !mayBeInitializedLater;\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}