{
    "patch": "        double x0 = min;\n        double f0 = yMin;\n        double x2 = max;\n        double f2 = yMax;\n        double x1 = initial;\n        double f1 = yInitial;\n        double fmin;\n        double fmax;\n\n        if (!(f1 * f2 < 0)) {\n            throw new IllegalArgumentException(\"Initial guess does not bracket a root in the given interval\");\n        }\n\n        if (Math.abs(f1) < Math.abs(f2)) {\n            // swap so that f(x1) > f(x2)\n            double temp = x2;\n            x2 = x1;\n            x1 = temp;\n            temp = f2;\n            f2 = f1;\n            f1 = temp;\n        }\n\n        fmin = f1;\n        fmax = f2;\n        double x3 = x1;\n        double f3 = f1;\n\n        boolean done = false;\n        while (!done) {\n            double previousInterval = x2 - x0;\n            double delta;\n            double tolerance;\n            if (Math.abs(fmin) > Math.abs(fmax)) {\n                // swap so that f(x2) > f(x3)\n                double temp = x3;\n                x3 = x2;\n                x2 = x1;\n                x1 = temp;\n                temp = f3;\n                f3 = f2;\n                f2 = f1;\n                f1 = temp;\n                delta = x1 - x0;\n                tolerance = relativeAccuracy * Math.abs(x2) + absoluteAccuracy;\n            } else {\n                delta = x2 - x1;\n                tolerance = relativeAccuracy * Math.abs(x1) + absoluteAccuracy;\n            }\n            if (Math.abs(delta) < tolerance) {\n                done = true;\n            } else {\n                double r3;\n                if (f1 != f3 && f2 != f3) {\n                    // Inverse quadratic interpolation\n                    double a = ((f1 - f2) * (x1 - x3) / (x2 - x1) - (f1 - f3) * (x1 - x2) / (x3 - x1))\n                            / ((x1 - x3) * (x2 - x3) * (x1 - x2));\n                    double b = ((f1 - f2) * (x1 - x3) * (x1 - x2) / (x2 - x1)\n                            - (f1 - f3) * (x1 - x2) * (x1 - x3) / (x3 - x1))\n                            / ((x1 - x3) * (x2 - x3) * (x1 - x2));\n                    double c = f1 * (x1 - x2) * (x1 - x3) / ((x3 - x1) * (x2 - x1))\n                            + f2 * (x2 - x1) * (x2 - x3) / ((x2 - x3) * (x1 - x2))\n                            + f3 * (x3 - x1) * (x3 - x2) / ((x3 - x2) * (x1 - x3));\n                    if (b * b >= 4 * a * c) {\n                        r3 = x1 - 0.5 *(2 * c) / (b + Math.signum(b) * Math.sqrt(b * b - 4 * a * c));\n                    } else {\n                        // Linear interpolation\n                        r3 = x1 - c / b;\n                    }\n                } else {\n                    // Secant method\n                    r3 = x1 - f1 * (x2 - x1) / (f2 - f1);\n                }\n                double fR3 = f.value(r3);\n                previousInterval = Math.abs(x2 - x0);\n                x3 = x2;\n                f3 = f2;\n                if (f1 * fR3 < 0) {\n                    x2 = r3;\n                    f2 = fR3;\n                } else {\n                    x1 = r3;\n                    f1 = fR3;\n                }\n                if (Math.abs(f1) < Math.abs(f2)) {\n                    // swap so that f(x1) > f(x2)\n                    double temp = x2;\n                    x2 = x1;\n                    x1 = temp;\n                    temp = f2;\n                    f2 = f1;\n                    f1 = temp;\n                }\n                if (Math.abs(f1) <= Math.abs(f3) || Math.abs(f2) <= Math.abs(f3)) {\n                    // maintain bracketing\n                    x2 = x3 - Math.signum(x3 - x0) * 0.5 * previousInterval;\n                    f2 = f.value(x2);\n                }\n            }\n            if (!(f1 * f2 < 0)) {\n                throw new NoBracketingException(x1, x2, f1, f2);\n            }\n        }\n\n        setResult((x1 + x2) / 2, iterationCount);\n\n        return result;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..cf6dea90d 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,114 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double x0 = min;\n+        double f0 = yMin;\n+        double x2 = max;\n+        double f2 = yMax;\n+        double x1 = initial;\n+        double f1 = yInitial;\n+        double fmin;\n+        double fmax;\n+\n+        if (!(f1 * f2 < 0)) {\n+            throw new IllegalArgumentException(\"Initial guess does not bracket a root in the given interval\");\n+        }\n+\n+        if (Math.abs(f1) < Math.abs(f2)) {\n+            // swap so that f(x1) > f(x2)\n+            double temp = x2;\n+            x2 = x1;\n+            x1 = temp;\n+            temp = f2;\n+            f2 = f1;\n+            f1 = temp;\n+        }\n+\n+        fmin = f1;\n+        fmax = f2;\n+        double x3 = x1;\n+        double f3 = f1;\n+\n+        boolean done = false;\n+        while (!done) {\n+            double previousInterval = x2 - x0;\n+            double delta;\n+            double tolerance;\n+            if (Math.abs(fmin) > Math.abs(fmax)) {\n+                // swap so that f(x2) > f(x3)\n+                double temp = x3;\n+                x3 = x2;\n+                x2 = x1;\n+                x1 = temp;\n+                temp = f3;\n+                f3 = f2;\n+                f2 = f1;\n+                f1 = temp;\n+                delta = x1 - x0;\n+                tolerance = relativeAccuracy * Math.abs(x2) + absoluteAccuracy;\n+            } else {\n+                delta = x2 - x1;\n+                tolerance = relativeAccuracy * Math.abs(x1) + absoluteAccuracy;\n+            }\n+            if (Math.abs(delta) < tolerance) {\n+                done = true;\n+            } else {\n+                double r3;\n+                if (f1 != f3 && f2 != f3) {\n+                    // Inverse quadratic interpolation\n+                    double a = ((f1 - f2) * (x1 - x3) / (x2 - x1) - (f1 - f3) * (x1 - x2) / (x3 - x1))\n+                            / ((x1 - x3) * (x2 - x3) * (x1 - x2));\n+                    double b = ((f1 - f2) * (x1 - x3) * (x1 - x2) / (x2 - x1)\n+                            - (f1 - f3) * (x1 - x2) * (x1 - x3) / (x3 - x1))\n+                            / ((x1 - x3) * (x2 - x3) * (x1 - x2));\n+                    double c = f1 * (x1 - x2) * (x1 - x3) / ((x3 - x1) * (x2 - x1))\n+                            + f2 * (x2 - x1) * (x2 - x3) / ((x2 - x3) * (x1 - x2))\n+                            + f3 * (x3 - x1) * (x3 - x2) / ((x3 - x2) * (x1 - x3));\n+                    if (b * b >= 4 * a * c) {\n+                        r3 = x1 - 0.5 *(2 * c) / (b + Math.signum(b) * Math.sqrt(b * b - 4 * a * c));\n+                    } else {\n+                        // Linear interpolation\n+                        r3 = x1 - c / b;\n+                    }\n+                } else {\n+                    // Secant method\n+                    r3 = x1 - f1 * (x2 - x1) / (f2 - f1);\n+                }\n+                double fR3 = f.value(r3);\n+                previousInterval = Math.abs(x2 - x0);\n+                x3 = x2;\n+                f3 = f2;\n+                if (f1 * fR3 < 0) {\n+                    x2 = r3;\n+                    f2 = fR3;\n+                } else {\n+                    x1 = r3;\n+                    f1 = fR3;\n+                }\n+                if (Math.abs(f1) < Math.abs(f2)) {\n+                    // swap so that f(x1) > f(x2)\n+                    double temp = x2;\n+                    x2 = x1;\n+                    x1 = temp;\n+                    temp = f2;\n+                    f2 = f1;\n+                    f1 = temp;\n+                }\n+                if (Math.abs(f1) <= Math.abs(f3) || Math.abs(f2) <= Math.abs(f3)) {\n+                    // maintain bracketing\n+                    x2 = x3 - Math.signum(x3 - x0) * 0.5 * previousInterval;\n+                    f2 = f.value(x2);\n+                }\n+            }\n+            if (!(f1 * f2 < 0)) {\n+                throw new NoBracketingException(x1, x2, f1, f2);\n+            }\n+        }\n+\n+        setResult((x1 + x2) / 2, iterationCount);\n+\n+        return result;\n+    }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}