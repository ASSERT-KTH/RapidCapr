{
    "patch": "import java.util.Comparator;\n\nimport org.apache.commons.math3.optim.PointValuePair;\nimport org.apache.commons.math3.util.FastMath;\n\npublic class SimplexOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<Sphere, PointValuePair> {\n    \n    /** Scaling factor for the simplex points. */\n    private double sideLength;\n\n    /** Contraction coefficient for the simplex points. */\n    private double contraction;\n\n    /** Expansion coefficient for the simplex points. */\n    private double expansion;\n\n    /** Reflection coefficient for the simplex points. */\n    private double reflection;\n\n    /** Minimum relative error for simplex size. */\n    private final double sizeRelativeTolerance;\n\n    /**\n     * The simplex.\n     */\n    private RealPointValuePair[] simplex;\n\n    /**\n     * Build a simplex optimizer with default settings.\n     */\n    public SimplexOptimizer() {\n        super(null, 0, 0);\n        sideLength = 1;\n        expansion = 2;\n        contraction = 0.5;\n        reflection = 1;\n        sizeRelativeTolerance = 0;\n    }\n\n    /**\n     * Build a simplex optimizer with a specified convergence tolerance.\n     *\n     * @param relativeThreshold Convergence tolerance for the simplex size.\n     */\n    public SimplexOptimizer(final double relativeThreshold) {\n        super(null, 0, 0);\n        sideLength = 1;\n        expansion = 2;\n        contraction = 0.5;\n        reflection = 1;\n        this.sizeRelativeTolerance = relativeThreshold;\n    }\n\n    /**\n     * Build a simplex optimizer with specified convergence and optimizer settings.\n     *\n     * @param sideLength Scaling factor for the simplex points.\n     * @param contraction Contraction coefficient for the simplex points.\n     * @param expansion Expansion coefficient for the simplex points.\n     * @param reflection Reflection coefficient for the simplex points.\n     * @param relativeThreshold Convergence tolerance for the simplex size.\n     * @param maxEval Maximum number of evaluations.\n     * @param startStarts Number of random start locations.\n     */\n    public SimplexOptimizer(final double sideLength, final double contraction,\n                            final double expansion, final double reflection,\n                            final double relativeThreshold,\n                            final int maxEval,\n                            final int startStarts) {\n        super(null, maxEval, startStarts);\n        this.sideLength = sideLength;\n        this.contraction = contraction;\n        this.expansion = expansion;\n        this.reflection = reflection;\n        sizeRelativeTolerance = relativeThreshold;\n    }\n\n    /**\n     * Get the reflection coefficient for the simplex points.\n     * @return the reflection coefficient\n     */\n    public double getReflectionCoefficient() {\n        return reflection;\n    }\n\n    /**\n     * Get the expansion coefficient for the simplex points.\n     * @return the expansion coefficient\n     */\n    public double getExpansionCoefficient() {\n        return expansion;\n    }\n\n    /**\n     * Get the contraction coefficient for the simplex points.\n     * @return the contraction coefficient\n     */\n    public double getContractionCoefficient() {\n        return contraction;\n    }\n\n    /**\n     * Get the scaling factor for the simplex points.\n     * @return the scaling factor\n     */\n    public double getSideLength() {\n        return sideLength;\n    }\n\n    /**\n     * Set the reflection coefficient for the simplex points.\n     * @param reflection the reflection coefficient\n     */\n    public void setReflectionCoefficient(final double reflection) {\n        this.reflection = reflection;\n    }\n\n    /**\n     * Set the expansion coefficient for the simplex points.\n     * @param expansion the expansion coefficient\n     */\n    public void setExpansionCoefficient(final double expansion) {\n        this.expansion = expansion;\n    }\n\n    /**\n     * Set the contraction coefficient for the simplex points.\n     * @param contraction the contraction coefficient\n     */\n    public void setContractionCoefficient(final double contraction) {\n        this.contraction = contraction;\n    }\n\n    /**\n     * Set the scaling factor for the simplex points.\n     * @param sideLength the scaling factor\n     */\n    public void setSideLength(final double sideLength) {\n        this.sideLength = sideLength;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    public PointValuePair doOptimize() {\n\n        final MultivariateFunction evaluationFunction = getObjectiveFunction();\n        final Comparator<RealPointValuePair> comparator = new Comparator<RealPointValuePair>() {\n            /** {@inheritDoc} */\n            @Override\n            public int compare(final RealPointValuePair o1,\n                               final RealPointValuePair o2) {\n                // maximize o1 minus o2 since we are minimizing the cost\n                return Double.compare(evaluationFunction.value(o2.getPoint()) -\n                                       evaluationFunction.value(o1.getPoint()), 0);\n            }\n        };\n\n        // initialize the simplex\n        final int n = getDimension();\n        final double[] step = new double[n];\n        for (int i = 0; i < n; ++i) {\n            step[i] = sideLength * FastMath.max(1, FastMath.abs(getStartValue(i)));\n        }\n        simplex = new RealPointValuePair[n + 1];\n        simplex[0] = new RealPointValuePair(getStartPoint(), 0);\n\n        for (int i = 0; i < n; ++i) {\n            final double[] tmp = getStartPoint().clone();\n            tmp[i] += step[i];\n            simplex[i + 1] = new RealPointValuePair(tmp, 0);\n        }\n\n        evaluateAll(simplex, comparator);\n        while (getEvaluations() < getMaxEvaluations()) {\n\n            final RealPointValuePair best = simplex[0];\n            final RealPointValuePair secondWorst = simplex[n - 1];\n            final RealPointValuePair worst = simplex[n];\n\n            // check convergence\n            if (isConverged(sizeRelativeTolerance,\n                            best.getValue(),\n                            worst.getValue())) {\n                return new PointValuePair(best.getPoint(), best.getValue());\n            }\n\n            // compute the reflection point\n            final RealPointValuePair reflected = evaluateNewSimplex(simplex, reflection, comparator);\n            if (comparator.compare(reflected, secondWorst) > 0 &&\n                comparator.compare(reflected, best) < 0) {\n                // accept the reflected simplex\n                simplex[n] = reflected;\n            } else if (comparator.compare(reflected, best) >= 0) {\n                final RealPointValuePair[] contractedSimplex = contract(comparator, best, simplex, contraction);\n                final RealPointValuePair contracted = evaluateNewSimplex(contractedSimplex, 0, comparator);\n\n                if (comparator.compare(contracted, best) >= 0) {\n                    /*\n                     * The contracted simplex is at least as good as the reflected simplex,\n                     * so we accept the contracted simplex.\n                     */\n                    simplex = contractedSimplex;\n                } else {\n                    /*\n                     * The reflected simplex was better than the contracted simplex,\n                     * so we accept the reflected simplex.\n                     */\n                    simplex[n] = reflected;\n                }\n            } else { // comparator.compare(reflected, secondWorst) <= 0\n                final RealPointValuePair expanded = evaluateNewSimplex(simplex, expansion, comparator);\n\n                if (comparator.compare(expanded, reflected) < 0) {\n                    // the expanded simplex was better than the reflected simplex, so accept it\n                    simplex[n] = expanded;\n                } else {\n                    // accept the reflected simplex\n                    simplex[n] = reflected;\n                }\n            }\n\n            evaluateAll(simplex, comparator);\n\n        }\n\n        final RealPointValuePair[] cornerPoints = simplex.clone();\n        for (int i = 0; i <= n; ++i) {\n            final double[] newPoint = simplex[i].getPoint().clone();\n            for (int j = 0; j < n; ++j) {\n                newPoint[j] /= 2;\n            }\n            simplex[i] = new RealPointValuePair(newPoint, 0);\n        }\n        evaluateAll(simplex, comparator);\n        return new PointValuePair(simplex[0].getPoint(),\n                Double.isInfinite(simplex[0].getValue()) ? best.getValue() : simplex[0].getValue());\n    }\n    \n    /**\n     * Constructs a new simplex by contracting an existing one.\n     *\n     * @param comparator Comparator to use for sorting the simplex points.\n     * @param best The best point of the simplex\n     * @param simplex Original simplex.\n     * @param contraction Coefficient to scale the direction of the contraction.\n     * @return a new simplex contructed by contracting an existing one.\n     */\n    private RealPointValuePair[] contract(final Comparator<RealPointValuePair> comparator,\n                                        final RealPointValuePair best,\n                                        final RealPointValuePair[] simplex,\n                                        final double contraction) {\n        final int n = simplex.length - 1;\n        final RealPointValuePair[] contractedSimplex = new RealPointValuePair[n + 1];\n        for (int i = 0; i < n; i++) {\n            contractedSimplex[i] = new RealPointValuePair(\n                    contractPoint(simplex[i].getPoint(), best.getPoint(), contraction),\n                    Double.NaN\n            );\n        }\n        contractedSimplex[n] = best;\n        sortSimplex(contractedSimplex, comparator);\n        return contractedSimplex;\n    }\n\n    /**\n     * Apply the reflection transformation to the simplex and evaluate the new point.\n     *\n     * @param simplex Simplex.\n     * @param coefficient Reflection coefficient.\n     * @param comparator Comparator to use when evaluating the new point.\n     * @return a new point with reflection transformation applied to the simplex.\n     */\n    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] simplex, final double coefficient,\n        final Comparator<RealPointValuePair> comparator) {\n\n        final int n = getDimension();\n        final RealPointValuePair best = simplex[0];\n\n        // Compute the center of the simplex points except worst\n        final double[] xBar = new double[n];\n        for (int i = 0; i < n; i++) {\n            xBar[i] = 0;\n            for (int j = 0; j < n; j++) {\n                xBar[i] += simplex[j].getPoint()[i];\n            }\n            xBar[i] -= simplex[n].getPoint()[i];\n            xBar[i] /= n;\n        }\n\n        // Compute reflected point\n        final double[] reflected = new double[n];\n        for (int i = 0; i < n; i++) {\n            reflected[i] = (1 + coefficient) * xBar[i] - coefficient * simplex[n].getPoint()[i];\n        }\n\n        final RealPointValuePair reflectedVertex = new RealPointValuePair(reflected,\n                                                                      Double.NaN);\n\n        // If the reflected point is better than the worst point in the simplex, use the reflected point\n        if (comparator.compare(reflectedVertex, best) < 0) {\n            return reflectedVertex;\n        }\n\n        // If the reflected point is not better than the best point in the simplex, perform a contraction\n        final double[] contracted = contractPoint(simplex[n].getPoint(), xBar, reflection);\n        final RealPointValuePair contractedVertex = new RealPointValuePair(contracted,\n                                                                       Double.NaN);\n\n        if (comparator.compare(contractedVertex, simplex[n]) < 0) {\n            return contractedVertex;\n        }\n\n        // Otherwise perform an inside contraction\n        for (int i = 1; i < simplex.length; i++) {\n            final double[] contractedInside = contractPoint(simplex[i].getPoint(),\n                                                          xBar,\n                                                          contraction);\n            simplex[i] = new RealPointValuePair(contractedInside,\n                                              Double.NaN);\n        }\n        evaluateAll(simplex, comparator);\n        return simplex[0];\n    }\n\n    /**\n     * Computes a new point by contracting towards the best point of the simplex, using the specified coefficient.\n     *\n     * @param point Point to contract on.\n     * @param bestBest Best point.\n     * @param contraction Coefficient for the contraction.\n     * @return the coordinates of the contracted simplex point.\n     */\n    private double[] contractPoint(final double[] point, final double[] bestBest, final double contraction) {\n        final double[] contracted = new double[point.length];\n        for (int i = 0; i < point.length; i++) {\n            contracted[i] = bestBest[i] + contraction * (point[i] - bestBest[i]);\n        }\n        return contracted;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..2ca7b8ba3 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,46 +58,347 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+import java.util.Comparator;\n+\n+import org.apache.commons.math3.optim.PointValuePair;\n+import org.apache.commons.math3.util.FastMath;\n+\n+public class SimplexOptimizer extends BaseAbstractMultivariateSimpleBoundsOptimizer<Sphere, PointValuePair> {\n+    \n+    /** Scaling factor for the simplex points. */\n+    private double sideLength;\n+\n+    /** Contraction coefficient for the simplex points. */\n+    private double contraction;\n+\n+    /** Expansion coefficient for the simplex points. */\n+    private double expansion;\n+\n+    /** Reflection coefficient for the simplex points. */\n+    private double reflection;\n+\n+    /** Minimum relative error for simplex size. */\n+    private final double sizeRelativeTolerance;\n+\n+    /**\n+     * The simplex.\n+     */\n+    private RealPointValuePair[] simplex;\n+\n+    /**\n+     * Build a simplex optimizer with default settings.\n+     */\n+    public SimplexOptimizer() {\n+        super(null, 0, 0);\n+        sideLength = 1;\n+        expansion = 2;\n+        contraction = 0.5;\n+        reflection = 1;\n+        sizeRelativeTolerance = 0;\n+    }\n+\n+    /**\n+     * Build a simplex optimizer with a specified convergence tolerance.\n+     *\n+     * @param relativeThreshold Convergence tolerance for the simplex size.\n+     */\n+    public SimplexOptimizer(final double relativeThreshold) {\n+        super(null, 0, 0);\n+        sideLength = 1;\n+        expansion = 2;\n+        contraction = 0.5;\n+        reflection = 1;\n+        this.sizeRelativeTolerance = relativeThreshold;\n+    }\n+\n+    /**\n+     * Build a simplex optimizer with specified convergence and optimizer settings.\n+     *\n+     * @param sideLength Scaling factor for the simplex points.\n+     * @param contraction Contraction coefficient for the simplex points.\n+     * @param expansion Expansion coefficient for the simplex points.\n+     * @param reflection Reflection coefficient for the simplex points.\n+     * @param relativeThreshold Convergence tolerance for the simplex size.\n+     * @param maxEval Maximum number of evaluations.\n+     * @param startStarts Number of random start locations.\n+     */\n+    public SimplexOptimizer(final double sideLength, final double contraction,\n+                            final double expansion, final double reflection,\n+                            final double relativeThreshold,\n+                            final int maxEval,\n+                            final int startStarts) {\n+        super(null, maxEval, startStarts);\n+        this.sideLength = sideLength;\n+        this.contraction = contraction;\n+        this.expansion = expansion;\n+        this.reflection = reflection;\n+        sizeRelativeTolerance = relativeThreshold;\n+    }\n+\n+    /**\n+     * Get the reflection coefficient for the simplex points.\n+     * @return the reflection coefficient\n+     */\n+    public double getReflectionCoefficient() {\n+        return reflection;\n+    }\n+\n+    /**\n+     * Get the expansion coefficient for the simplex points.\n+     * @return the expansion coefficient\n+     */\n+    public double getExpansionCoefficient() {\n+        return expansion;\n+    }\n+\n+    /**\n+     * Get the contraction coefficient for the simplex points.\n+     * @return the contraction coefficient\n+     */\n+    public double getContractionCoefficient() {\n+        return contraction;\n+    }\n+\n+    /**\n+     * Get the scaling factor for the simplex points.\n+     * @return the scaling factor\n+     */\n+    public double getSideLength() {\n+        return sideLength;\n+    }\n+\n+    /**\n+     * Set the reflection coefficient for the simplex points.\n+     * @param reflection the reflection coefficient\n+     */\n+    public void setReflectionCoefficient(final double reflection) {\n+        this.reflection = reflection;\n+    }\n+\n+    /**\n+     * Set the expansion coefficient for the simplex points.\n+     * @param expansion the expansion coefficient\n+     */\n+    public void setExpansionCoefficient(final double expansion) {\n+        this.expansion = expansion;\n+    }\n+\n+    /**\n+     * Set the contraction coefficient for the simplex points.\n+     * @param contraction the contraction coefficient\n+     */\n+    public void setContractionCoefficient(final double contraction) {\n+        this.contraction = contraction;\n+    }\n+\n+    /**\n+     * Set the scaling factor for the simplex points.\n+     * @param sideLength the scaling factor\n+     */\n+    public void setSideLength(final double sideLength) {\n+        this.sideLength = sideLength;\n+    }\n \n-        while (true) {\n+    /** {@inheritDoc} */\n+    @Override\n+    public PointValuePair doOptimize() {\n \n-            incrementIterationsCounter();\n+        final MultivariateFunction evaluationFunction = getObjectiveFunction();\n+        final Comparator<RealPointValuePair> comparator = new Comparator<RealPointValuePair>() {\n+            /** {@inheritDoc} */\n+            @Override\n+            public int compare(final RealPointValuePair o1,\n+                               final RealPointValuePair o2) {\n+                // maximize o1 minus o2 since we are minimizing the cost\n+                return Double.compare(evaluationFunction.value(o2.getPoint()) -\n+                                       evaluationFunction.value(o1.getPoint()), 0);\n+            }\n+        };\n \n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n+        // initialize the simplex\n+        final int n = getDimension();\n+        final double[] step = new double[n];\n+        for (int i = 0; i < n; ++i) {\n+            step[i] = sideLength * FastMath.max(1, FastMath.abs(getStartValue(i)));\n+        }\n+        simplex = new RealPointValuePair[n + 1];\n+        simplex[0] = new RealPointValuePair(getStartPoint(), 0);\n \n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n+        for (int i = 0; i < n; ++i) {\n+            final double[] tmp = getStartPoint().clone();\n+            tmp[i] += step[i];\n+            simplex[i + 1] = new RealPointValuePair(tmp, 0);\n+        }\n+\n+        evaluateAll(simplex, comparator);\n+        while (getEvaluations() < getMaxEvaluations()) {\n+\n+            final RealPointValuePair best = simplex[0];\n+            final RealPointValuePair secondWorst = simplex[n - 1];\n+            final RealPointValuePair worst = simplex[n];\n \n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n+            // check convergence\n+            if (isConverged(sizeRelativeTolerance,\n+                            best.getValue(),\n+                            worst.getValue())) {\n+                return new PointValuePair(best.getPoint(), best.getValue());\n+            }\n+\n+            // compute the reflection point\n+            final RealPointValuePair reflected = evaluateNewSimplex(simplex, reflection, comparator);\n+            if (comparator.compare(reflected, secondWorst) > 0 &&\n+                comparator.compare(reflected, best) < 0) {\n+                // accept the reflected simplex\n+                simplex[n] = reflected;\n+            } else if (comparator.compare(reflected, best) >= 0) {\n+                final RealPointValuePair[] contractedSimplex = contract(comparator, best, simplex, contraction);\n+                final RealPointValuePair contracted = evaluateNewSimplex(contractedSimplex, 0, comparator);\n+\n+                if (comparator.compare(contracted, best) >= 0) {\n+                    /*\n+                     * The contracted simplex is at least as good as the reflected simplex,\n+                     * so we accept the contracted simplex.\n+                     */\n+                    simplex = contractedSimplex;\n+                } else {\n+                    /*\n+                     * The reflected simplex was better than the contracted simplex,\n+                     * so we accept the reflected simplex.\n+                     */\n+                    simplex[n] = reflected;\n+                }\n+            } else { // comparator.compare(reflected, secondWorst) <= 0\n+                final RealPointValuePair expanded = evaluateNewSimplex(simplex, expansion, comparator);\n+\n+                if (comparator.compare(expanded, reflected) < 0) {\n+                    // the expanded simplex was better than the reflected simplex, so accept it\n+                    simplex[n] = expanded;\n+                } else {\n                     // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n+                    simplex[n] = reflected;\n                 }\n+            }\n \n-                return;\n+            evaluateAll(simplex, comparator);\n \n+        }\n+\n+        final RealPointValuePair[] cornerPoints = simplex.clone();\n+        for (int i = 0; i <= n; ++i) {\n+            final double[] newPoint = simplex[i].getPoint().clone();\n+            for (int j = 0; j < n; ++j) {\n+                newPoint[j] /= 2;\n             }\n+            simplex[i] = new RealPointValuePair(newPoint, 0);\n+        }\n+        evaluateAll(simplex, comparator);\n+        return new PointValuePair(simplex[0].getPoint(),\n+                Double.isInfinite(simplex[0].getValue()) ? best.getValue() : simplex[0].getValue());\n+    }\n+    \n+    /**\n+     * Constructs a new simplex by contracting an existing one.\n+     *\n+     * @param comparator Comparator to use for sorting the simplex points.\n+     * @param best The best point of the simplex\n+     * @param simplex Original simplex.\n+     * @param contraction Coefficient to scale the direction of the contraction.\n+     * @return a new simplex contructed by contracting an existing one.\n+     */\n+    private RealPointValuePair[] contract(final Comparator<RealPointValuePair> comparator,\n+                                        final RealPointValuePair best,\n+                                        final RealPointValuePair[] simplex,\n+                                        final double contraction) {\n+        final int n = simplex.length - 1;\n+        final RealPointValuePair[] contractedSimplex = new RealPointValuePair[n + 1];\n+        for (int i = 0; i < n; i++) {\n+            contractedSimplex[i] = new RealPointValuePair(\n+                    contractPoint(simplex[i].getPoint(), best.getPoint(), contraction),\n+                    Double.NaN\n+            );\n+        }\n+        contractedSimplex[n] = best;\n+        sortSimplex(contractedSimplex, comparator);\n+        return contractedSimplex;\n+    }\n \n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n+    /**\n+     * Apply the reflection transformation to the simplex and evaluate the new point.\n+     *\n+     * @param simplex Simplex.\n+     * @param coefficient Reflection coefficient.\n+     * @param comparator Comparator to use when evaluating the new point.\n+     * @return a new point with reflection transformation applied to the simplex.\n+     */\n+    private RealPointValuePair evaluateNewSimplex(final RealPointValuePair[] simplex, final double coefficient,\n+        final Comparator<RealPointValuePair> comparator) {\n \n-            // check convergence\n-                return;\n+        final int n = getDimension();\n+        final RealPointValuePair best = simplex[0];\n+\n+        // Compute the center of the simplex points except worst\n+        final double[] xBar = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            xBar[i] = 0;\n+            for (int j = 0; j < n; j++) {\n+                xBar[i] += simplex[j].getPoint()[i];\n             }\n+            xBar[i] -= simplex[n].getPoint()[i];\n+            xBar[i] /= n;\n+        }\n+\n+        // Compute reflected point\n+        final double[] reflected = new double[n];\n+        for (int i = 0; i < n; i++) {\n+            reflected[i] = (1 + coefficient) * xBar[i] - coefficient * simplex[n].getPoint()[i];\n+        }\n+\n+        final RealPointValuePair reflectedVertex = new RealPointValuePair(reflected,\n+                                                                      Double.NaN);\n \n+        // If the reflected point is better than the worst point in the simplex, use the reflected point\n+        if (comparator.compare(reflectedVertex, best) < 0) {\n+            return reflectedVertex;\n         }\n \n+        // If the reflected point is not better than the best point in the simplex, perform a contraction\n+        final double[] contracted = contractPoint(simplex[n].getPoint(), xBar, reflection);\n+        final RealPointValuePair contractedVertex = new RealPointValuePair(contracted,\n+                                                                       Double.NaN);\n+\n+        if (comparator.compare(contractedVertex, simplex[n]) < 0) {\n+            return contractedVertex;\n+        }\n+\n+        // Otherwise perform an inside contraction\n+        for (int i = 1; i < simplex.length; i++) {\n+            final double[] contractedInside = contractPoint(simplex[i].getPoint(),\n+                                                          xBar,\n+                                                          contraction);\n+            simplex[i] = new RealPointValuePair(contractedInside,\n+                                              Double.NaN);\n+        }\n+        evaluateAll(simplex, comparator);\n+        return simplex[0];\n     }\n \n+    /**\n+     * Computes a new point by contracting towards the best point of the simplex, using the specified coefficient.\n+     *\n+     * @param point Point to contract on.\n+     * @param bestBest Best point.\n+     * @param contraction Coefficient for the contraction.\n+     * @return the coordinates of the contracted simplex point.\n+     */\n+    private double[] contractPoint(final double[] point, final double[] bestBest, final double contraction) {\n+        final double[] contracted = new double[point.length];\n+        for (int i = 0; i < point.length; i++) {\n+            contracted[i] = bestBest[i] + contraction * (point[i] - bestBest[i]);\n+        }\n+        return contracted;\n+    }\n+}\n+\n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)\n      * @param coeff linear coefficient",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}