{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.rhino.FunctionNode;\nimport com.google.javascript.rhino.IR;\nimport com.google.javascript.rhino.JSDocInfo;\nimport com.google.javascript.rhino.JSDocInfoBuilder;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.TypeI;\nimport com.google.javascript.rhino.jstype.JSTypeExpression;\n\nimport java.util.ArrayList;\nimport java.util.HashSet;\nimport java.util.List;\nimport java.util.Set;\n\n/**\n * Automated program repair tool.\n *\n */\npublic class IRFactory {\n\n  private final AbstractCompiler compiler;\n  private final ErrorReporter errorReporter;\n\n  public IRFactory(AbstractCompiler compiler, ErrorReporter errorReporter) {\n    this.compiler = compiler;\n    this.errorReporter = errorReporter;\n  }\n\n  private final Set<String> ALLOWED_DIRECTIVES = new HashSet<String>() {\n    {\n      add(\"use strict\");\n    }\n  };\n\n  public Node transform(Node node) {\n    return NodeTraversal.traverse(compiler, node, new TransformTraversal());\n  }\n\n  public Node transformIfChanged(Node node) {\n    NodeTraversal.traverse(compiler, node, new TransformTraversal());\n    return node;\n  }\n\n  private class TransformTraversal implements Callback {\n\n    private final TypeSafeDispatcher delegate =\n            new TransformDispatcher(compiler, errorReporter);\n\n    @Override\n    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n      return true;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      delegate.dispatch(t, n, parent);\n    }\n\n  }\n\n  private class TransformDispatcher extends AbstractVisitor {\n    public TransformDispatcher(AbstractCompiler compiler, ErrorReporter errorReporter) {\n      super(compiler, errorReporter);\n    }\n\n    @Override\n    public void processArrayAccess(ArrayAccess arrayAccess) {\n      node = newNode(\n          Token.GETELEM,\n          transform(arrayAccess.getTarget()),\n          transform(arrayAccess.getIndex()));\n    }\n\n    @Override\n    public void processArrayLiteral(ArrayLiteral arrayLiteral) {\n      node = newNode(Token.ARRAYLIT);\n      for (AstNode element : arrayLiteral.getElements()) {\n        Node child = (element == null) ? newNode(Token.EMPTY) : transform(element);\n        node.addChildToBack(child);\n      }\n    }\n\n    @Override\n    public void processAssignment(Assignment assignment) {\n      Expression left = assignment.getLeft();\n      Expression right = assignment.getRight();\n      Node assign = newNode(Token.ASSIGN);\n\n      if (left instanceof PropertyGet) {\n        assign.addChildToBack(newNode(Token.GETPROP,\n            transform(((PropertyGet) left).getTarget()),\n            newNode(Token.STRING, ((PropertyGet) left).getProperty().getIdentifier())));\n      } else if (left instanceof Name) {\n        Node newName = newNode(Token.NAME, ((Name) left).getIdentifier());\n        newName.putProp(Node.ORIGINALNAME_PROP, ((Name) left).getIdentifier());\n        assign.addChildToBack(newName);\n      } else if (left instanceof ArrayAccess) {\n        assign.addChildToBack(newNode(Token.GETELEM,\n            transform(((ArrayAccess) left).getTarget()),\n            transform(((ArrayAccess) left).getIndex())));\n      } else {\n        errorReporter.error(\"Unsupported left operand\", sourceName, left.getLineno(), \"\", 0);\n        return;\n      }\n\n      if (assignment.getType() == TokenType.ASSIGN) {\n        assign.addChildToBack(transform(right));\n      } else if (assignment.getType() == TokenType.ASSIGN_BITOR) {\n        assign.addChildToBack(\n            newNode(\n                Token.BITOR,\n                assign.getFirstChild().cloneNode(),\n                transform(right)));\n      } else {\n        errorReporter.error(\"Unsupported assignment type\", sourceName, left.getLineno(), \"\", 0);\n        return;\n      }\n\n      node = assign;\n    }\n\n    @Override\n    public void processBlock(AstNode node) {\n      this.node = processGeneric(node);\n    }\n\n    @Override\n    public void processBlock(Block block) {\n      this.node = processGeneric(block);\n    }\n\n    @Override\n    public void processBreak(BreakStatement breakStatement) {\n      Node node = newNode(Token.BREAK);\n      if (breakStatement.getLabel() != null) {\n        Node labelName = transform(breakStatement.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      this.node = node;\n    }\n\n    @Override\n    public void processCall(Call call) {\n      Node target = transform(call.getTarget());\n      Node callNode = newNode(Token.CALL, target);\n      for (AstNode arg : call.getArguments()) {\n        callNode.addChildToBack(transform(arg));\n      }\n      this.node = callNode;\n    }\n\n    @Override\n    public void processCase(CaseClause caseClause) {\n      this.node = newNode(Token.CASE, transform(caseClause.getExpression()));\n      for (AstNode statement : caseClause.getStatements()) {\n        node.addChildToBack(transform(statement));\n      }\n    }\n\n    @Override\n    public void processCastExpression(CastExpression castExpression) {\n      this.node = transform(castExpression.getExpression());\n    }\n\n    @Override\n    public void processCatch(CatchClause catchClause) {\n      Node catchVar = transform(catchClause.getVarName());\n      Node block = transform(catchClause.getBody());\n      this.node = newNode(Token.CATCH, catchVar, block);\n    }\n\n    @Override\n    public void processComment(Comment comment) {\n      if (comment.isLineComment()) {\n        this.node = newNode(Token.EMPTY);\n      } else {\n        this.node = newNode(Token.SCRIPT, newNode(Token.EMPTY), newNode(Token.EMPTY));\n      }\n    }\n\n    @Override\n    public void processConditional(ConditionalExpression conditionalExpression) {\n      Node test = transform(conditionalExpression.getTestExpression());\n      Node thenExpr = transform(conditionalExpression.getTrueExpression());\n      Node elseExpr = transform(conditionalExpression.getFalseExpression());\n      this.node = newNode(Token.HOOK, test, thenExpr, elseExpr);\n    }\n\n    @Override\n    public void processContinue(ContinueStatement continueStatement) {\n      Node node = newNode(Token.CONTINUE);\n      if (continueStatement.getLabel() != null) {\n        Node labelName = transform(continueStatement.getLabel());\n        // Change the NAME to LABEL_NAME\n        labelName.setType(Token.LABEL_NAME);\n        node.addChildToBack(labelName);\n      }\n      this.node = node;\n    }\n\n    @Override\n    public void processDefault(DefaultClause defaultClause) {\n      this.node = newNode(Token.DEFAULT);\n      for (AstNode statement : defaultClause.getStatements()) {\n        node.addChildToBack(transform(statement));\n      }\n    }\n\n    @Override\n    public void processDoLoop(DoLoop doLoop) {\n      Node node = newNode(Token.DO, transform(doLoop.getBody()), transform(doLoop.getCondition()));\n      this.node = node;\n    }\n\n    @Override\n    public void processElementGet(ElementGet elementGet) {\n      this.node = newNode(Token.GETELEM, transform(elementGet.getTarget()), transform(elementGet.getElement()));\n    }\n\n    @Override\n    public void processEmpty(EmptyExpression emptyExpression) {\n      this.node = newNode(Token.EMPTY);\n    }\n\n    @Override\n    public void processExpression(ExpressionStatement expressionStatement) {\n      this.node = newNode(Token.EXPR_RESULT, transform(expressionStatement.getExpression()));\n    }\n\n    @Override\n    public void processFor(ForLoop forLoop) {\n      Node node = newNode(Token.FOR);\n      AstNode init = forLoop.getInitializer();\n      Node newInit = newNode(Token.EMPTY);\n      if (init != null) {\n        newInit = transform(init);\n      }\n      node.addChildToBack(newInit);\n\n      Expression test = forLoop.getCondition();\n      Node newTest = newNode(Token.EMPTY);\n      if (test != null) {\n        newTest = transform(test);\n      }\n      node.addChildToBack(newTest);\n\n      Expression incr = forLoop.getIncrement();\n      Node newIncr = newNode(Token.EMPTY);\n      if (incr != null) {\n        newIncr = transform(incr);\n      }\n      node.addChildToBack(newIncr);\n\n      node.addChildToBack(transform(forLoop.getBody()));\n      this.node = node;\n    }\n\n    @Override\n    public void processForIn(ForInLoop forInLoop) {\n      Node node = newNode(Token.FOR);\n\n      Node newDecl = newNode(Token.VAR, newNode(Token.NAME, forInLoop.getIterator().toSource()));\n      node.addChildToBack(newDecl);\n      node.addChildToBack(transform(forInLoop.getIteratedObject()));\n      node.addChildToBack(transform(forInLoop.getBody()));\n      this.node = node;\n    }\n\n    @Override\n    public void processFunction(FunctionNode functionNode) {\n      // We don't want to output functions.\n      this.node = null;\n    }\n\n    @Override\n    public void processIf(IfStatement ifStatement) {\n      Node node = newNode(\n          Token.IF,\n          transform(ifStatement.getCondition()),\n          transform(ifStatement.getThenPart()));\n      if (ifStatement.getElsePart() != null) {\n        node.addChildToBack(transform(ifStatement.getElsePart()));\n      }\n      this.node = node;\n    }\n\n    @Override\n    public void processLabeledStatement(LabeledStatement labeledStatement) {\n      Node labelName = transform(labeledStatement.getStatementLabel());\n      Node labeledItem = transform(labeledStatement.getStatement());\n      this.node = newNode(Token.LABEL, labelName, labeledItem);\n    }\n\n    @Override\n    public void processLetNode(LetNode let) {\n      Node letNode = newNode(Token.LET);\n      for (VariableDeclaration decl : let.getVariables()) {\n        Node node = newNode(Token.NAME, decl.getTarget().getIdentifier());\n        node.addChildToBack(transform(decl.getInitializer()));\n        letNode.addChildToBack(node);\n      }\n      this.node = letNode;\n    }\n\n    @Override\n    public void processName(Name name) {\n      String identifier = name.getIdentifier();\n      if (identifier.equals(\"undefined\")) {\n        this.node = newNode(Token.VOID, newNode(Token.NUMBER, \"0\"));\n      } else if (identifier.equals(\"eval\")) {\n        this.node = newNode(Token.NAME, \"_undefined_eval\");\n        this.node.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n      } else {\n        Node newName = newNode(Token.NAME, identifier);\n        newName.putProp(Node.ORIGINALNAME_PROP, identifier);\n        this.node = newName;\n      }\n    }\n\n    @Override\n    public void processNameDeclaration(NameDeclaration nameDeclaration) {\n      List<AstNode> variables = nameDeclaration.getVariables();\n      for (AstNode variable : variables) {\n        Node newNode = transform(variable);\n        JSDocInfo info = NodeUtil.getBestJSDocInfo(variable);\n        if (info != null && info.hasType()) {\n          JSTypeExpression type = info.getType();\n          JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n          builder.recordType(type);\n          newNode.setJSDocInfo(builder.build());\n        }\n        if (nameDeclaration.isConst()) {\n          newNode.putBooleanProp(Node.IS_CONSTANT_VAR, true);\n        }\n        node.addChildToBack(newNode);\n      }\n    }\n\n    @Override\n    public void processNew(NewExpression newExpression) {\n      Node target = transform(newExpression.getTarget());\n      Node callNode = newNode(Token.NEW, target);\n      for (AstNode arg : newExpression.getArguments()) {\n        callNode.addChildToBack(transform(arg));\n      }\n      this.node = callNode;\n    }\n\n    @Override\n    public void processNumber(NumberLiteral numberLiteral) {\n      String value = numberLiteral.getValue();\n      if (value.equals(\"NaN\")) {\n        this.node = newNode(Token.NAME, \"NaN\");\n      } else {\n        this.node = newNode(Token.NUMBER, value);\n      }\n    }\n\n    @Override\n    public void processObjectLiteral(ObjectLiteral objectLiteral) {\n      Node obj = newNode(Token.OBJECTLIT);\n      for (ObjectProperty property : objectLiteral.getElements()) {\n        if (property instanceof ObjectProperty) {\n          Node key = property.getKey() instanceof Name ?\n              newName(property.getKey().getIdentifier()) :\n              newNode(Token.STRING, property.getKey().getString());\n          obj.addChildToBack(newNode(Token.MEMBER_DEF, key, transform(property.getValue())));\n        } else {\n          ObjectGet objGet = (ObjectGet) property;\n          obj.addChildToBack(newNode(Token.MEMBER_DEF,\n                  newName(objGet.getProperty().getIdentifier()),\n                  IR.function(IR.name(\"\"), IR.paramList(IR.name(\"\")),\n                          IR.block(IR.returnNode(transform(objGet.getBody())))))));\n        }\n      }\n      this.node = obj;\n    }\n\n    @Override\n    public void processObjectProperty(ObjectProperty objectProperty) {\n      Object key = objectProperty.getKey();\n      if (key instanceof StringLiteral) {\n        this.node = newNode(Token.STRING, ((StringLiteral) key).getValue());\n      } else if (key instanceof Name) {\n        this.node = newNode(Token.NAME, ((Name) key).getIdentifier());\n      } else if (key instanceof NumberLiteral) {\n        this.node = newNode(Token.NUMBER, ((NumberLiteral) key).getValue());\n      } else {\n        throw new RuntimeException(\"Unexpected property key type: \" + key.getClass());\n      }\n      this.node = newNode(Token.MEMBER_DEF, node, transfor",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..69c04e44 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,404 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.rhino.FunctionNode;\n+import com.google.javascript.rhino.IR;\n+import com.google.javascript.rhino.JSDocInfo;\n+import com.google.javascript.rhino.JSDocInfoBuilder;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.TypeI;\n+import com.google.javascript.rhino.jstype.JSTypeExpression;\n+\n+import java.util.ArrayList;\n+import java.util.HashSet;\n+import java.util.List;\n+import java.util.Set;\n+\n+/**\n+ * Automated program repair tool.\n+ *\n+ */\n+public class IRFactory {\n+\n+  private final AbstractCompiler compiler;\n+  private final ErrorReporter errorReporter;\n+\n+  public IRFactory(AbstractCompiler compiler, ErrorReporter errorReporter) {\n+    this.compiler = compiler;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  private final Set<String> ALLOWED_DIRECTIVES = new HashSet<String>() {\n+    {\n+      add(\"use strict\");\n+    }\n+  };\n+\n+  public Node transform(Node node) {\n+    return NodeTraversal.traverse(compiler, node, new TransformTraversal());\n+  }\n+\n+  public Node transformIfChanged(Node node) {\n+    NodeTraversal.traverse(compiler, node, new TransformTraversal());\n+    return node;\n+  }\n+\n+  private class TransformTraversal implements Callback {\n+\n+    private final TypeSafeDispatcher delegate =\n+            new TransformDispatcher(compiler, errorReporter);\n+\n+    @Override\n+    public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+      return true;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      delegate.dispatch(t, n, parent);\n+    }\n+\n+  }\n+\n+  private class TransformDispatcher extends AbstractVisitor {\n+    public TransformDispatcher(AbstractCompiler compiler, ErrorReporter errorReporter) {\n+      super(compiler, errorReporter);\n+    }\n+\n+    @Override\n+    public void processArrayAccess(ArrayAccess arrayAccess) {\n+      node = newNode(\n+          Token.GETELEM,\n+          transform(arrayAccess.getTarget()),\n+          transform(arrayAccess.getIndex()));\n+    }\n+\n+    @Override\n+    public void processArrayLiteral(ArrayLiteral arrayLiteral) {\n+      node = newNode(Token.ARRAYLIT);\n+      for (AstNode element : arrayLiteral.getElements()) {\n+        Node child = (element == null) ? newNode(Token.EMPTY) : transform(element);\n+        node.addChildToBack(child);\n+      }\n+    }\n+\n+    @Override\n+    public void processAssignment(Assignment assignment) {\n+      Expression left = assignment.getLeft();\n+      Expression right = assignment.getRight();\n+      Node assign = newNode(Token.ASSIGN);\n+\n+      if (left instanceof PropertyGet) {\n+        assign.addChildToBack(newNode(Token.GETPROP,\n+            transform(((PropertyGet) left).getTarget()),\n+            newNode(Token.STRING, ((PropertyGet) left).getProperty().getIdentifier())));\n+      } else if (left instanceof Name) {\n+        Node newName = newNode(Token.NAME, ((Name) left).getIdentifier());\n+        newName.putProp(Node.ORIGINALNAME_PROP, ((Name) left).getIdentifier());\n+        assign.addChildToBack(newName);\n+      } else if (left instanceof ArrayAccess) {\n+        assign.addChildToBack(newNode(Token.GETELEM,\n+            transform(((ArrayAccess) left).getTarget()),\n+            transform(((ArrayAccess) left).getIndex())));\n+      } else {\n+        errorReporter.error(\"Unsupported left operand\", sourceName, left.getLineno(), \"\", 0);\n+        return;\n+      }\n+\n+      if (assignment.getType() == TokenType.ASSIGN) {\n+        assign.addChildToBack(transform(right));\n+      } else if (assignment.getType() == TokenType.ASSIGN_BITOR) {\n+        assign.addChildToBack(\n+            newNode(\n+                Token.BITOR,\n+                assign.getFirstChild().cloneNode(),\n+                transform(right)));\n+      } else {\n+        errorReporter.error(\"Unsupported assignment type\", sourceName, left.getLineno(), \"\", 0);\n+        return;\n+      }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+      node = assign;\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public void processBlock(AstNode node) {\n+      this.node = processGeneric(node);\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n+    public void processBlock(Block block) {\n+      this.node = processGeneric(block);\n+    }\n+\n+    @Override\n+    public void processBreak(BreakStatement breakStatement) {\n       Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n+      if (breakStatement.getLabel() != null) {\n+        Node labelName = transform(breakStatement.getLabel());\n         // Change the NAME to LABEL_NAME\n         labelName.setType(Token.LABEL_NAME);\n         node.addChildToBack(labelName);\n       }\n-      return node;\n+      this.node = node;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    public void processCall(Call call) {\n+      Node target = transform(call.getTarget());\n+      Node callNode = newNode(Token.CALL, target);\n+      for (AstNode arg : call.getArguments()) {\n+        callNode.addChildToBack(transform(arg));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+      this.node = callNode;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public void processCase(CaseClause caseClause) {\n+      this.node = newNode(Token.CASE, transform(caseClause.getExpression()));\n+      for (AstNode statement : caseClause.getStatements()) {\n+        node.addChildToBack(transform(statement));\n+      }\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n+    public void processCastExpression(CastExpression castExpression) {\n+      this.node = transform(castExpression.getExpression());\n+    }\n+\n+    @Override\n+    public void processCatch(CatchClause catchClause) {\n+      Node catchVar = transform(catchClause.getVarName());\n+      Node block = transform(catchClause.getBody());\n+      this.node = newNode(Token.CATCH, catchVar, block);\n+    }\n+\n+    @Override\n+    public void processComment(Comment comment) {\n+      if (comment.isLineComment()) {\n+        this.node = newNode(Token.EMPTY);\n+      } else {\n+        this.node = newNode(Token.SCRIPT, newNode(Token.EMPTY), newNode(Token.EMPTY));\n+      }\n+    }\n+\n+    @Override\n+    public void processConditional(ConditionalExpression conditionalExpression) {\n+      Node test = transform(conditionalExpression.getTestExpression());\n+      Node thenExpr = transform(conditionalExpression.getTrueExpression());\n+      Node elseExpr = transform(conditionalExpression.getFalseExpression());\n+      this.node = newNode(Token.HOOK, test, thenExpr, elseExpr);\n+    }\n+\n+    @Override\n+    public void processContinue(ContinueStatement continueStatement) {\n       Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n+      if (continueStatement.getLabel() != null) {\n+        Node labelName = transform(continueStatement.getLabel());\n         // Change the NAME to LABEL_NAME\n         labelName.setType(Token.LABEL_NAME);\n         node.addChildToBack(labelName);\n       }\n-      return node;\n+      this.node = node;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public void processDefault(DefaultClause defaultClause) {\n+      this.node = newNode(Token.DEFAULT);\n+      for (AstNode statement : defaultClause.getStatements()) {\n+        node.addChildToBack(transform(statement));\n+      }\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public void processDoLoop(DoLoop doLoop) {\n+      Node node = newNode(Token.DO, transform(doLoop.getBody()), transform(doLoop.getCondition()));\n+      this.node = node;\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public void processElementGet(ElementGet elementGet) {\n+      this.node = newNode(Token.GETELEM, transform(elementGet.getTarget()), transform(elementGet.getElement()));\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public void processEmpty(EmptyExpression emptyExpression) {\n+      this.node = newNode(Token.EMPTY);\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public void processExpression(ExpressionStatement expressionStatement) {\n+      this.node = newNode(Token.EXPR_RESULT, transform(expressionStatement.getExpression()));\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    @Override\n+    public void processFor(ForLoop forLoop) {\n+      Node node = newNode(Token.FOR);\n+      AstNode init = forLoop.getInitializer();\n+      Node newInit = newNode(Token.EMPTY);\n+      if (init != null) {\n+        newInit = transform(init);\n+      }\n+      node.addChildToBack(newInit);\n+\n+      Expression test = forLoop.getCondition();\n+      Node newTest = newNode(Token.EMPTY);\n+      if (test != null) {\n+        newTest = transform(test);\n+      }\n+      node.addChildToBack(newTest);\n+\n+      Expression incr = forLoop.getIncrement();\n+      Node newIncr = newNode(Token.EMPTY);\n+      if (incr != null) {\n+        newIncr = transform(incr);\n+      }\n+      node.addChildToBack(newIncr);\n+\n+      node.addChildToBack(transform(forLoop.getBody()));\n+      this.node = node;\n+    }\n+\n+    @Override\n+    public void processForIn(ForInLoop forInLoop) {\n+      Node node = newNode(Token.FOR);\n+\n+      Node newDecl = newNode(Token.VAR, newNode(Token.NAME, forInLoop.getIterator().toSource()));\n+      node.addChildToBack(newDecl);\n+      node.addChildToBack(transform(forInLoop.getIteratedObject()));\n+      node.addChildToBack(transform(forInLoop.getBody()));\n+      this.node = node;\n+    }\n+\n+    @Override\n+    public void processFunction(FunctionNode functionNode) {\n+      // We don't want to output functions.\n+      this.node = null;\n+    }\n+\n+    @Override\n+    public void processIf(IfStatement ifStatement) {\n+      Node node = newNode(\n+          Token.IF,\n+          transform(ifStatement.getCondition()),\n+          transform(ifStatement.getThenPart()));\n+      if (ifStatement.getElsePart() != null) {\n+        node.addChildToBack(transform(ifStatement.getElsePart()));\n+      }\n+      this.node = node;\n+    }\n+\n+    @Override\n+    public void processLabeledStatement(LabeledStatement labeledStatement) {\n+      Node labelName = transform(labeledStatement.getStatementLabel());\n+      Node labeledItem = transform(labeledStatement.getStatement());\n+      this.node = newNode(Token.LABEL, labelName, labeledItem);\n     }\n \n+    @Override\n+    public void processLetNode(LetNode let) {\n+      Node letNode = newNode(Token.LET);\n+      for (VariableDeclaration decl : let.getVariables()) {\n+        Node node = newNode(Token.NAME, decl.getTarget().getIdentifier());\n+        node.addChildToBack(transform(decl.getInitializer()));\n+        letNode.addChildToBack(node);\n+      }\n+      this.node = letNode;\n+    }\n+\n+    @Override\n+    public void processName(Name name) {\n+      String identifier = name.getIdentifier();\n+      if (identifier.equals(\"undefined\")) {\n+        this.node = newNode(Token.VOID, newNode(Token.NUMBER, \"0\"));\n+      } else if (identifier.equals(\"eval\")) {\n+        this.node = newNode(Token.NAME, \"_undefined_eval\");\n+        this.node.putBooleanProp(Node.IS_CONSTANT_NAME, true);\n+      } else {\n+        Node newName = newNode(Token.NAME, identifier);\n+        newName.putProp(Node.ORIGINALNAME_PROP, identifier);\n+        this.node = newName;\n+      }\n+    }\n+\n+    @Override\n+    public void processNameDeclaration(NameDeclaration nameDeclaration) {\n+      List<AstNode> variables = nameDeclaration.getVariables();\n+      for (AstNode variable : variables) {\n+        Node newNode = transform(variable);\n+        JSDocInfo info = NodeUtil.getBestJSDocInfo(variable);\n+        if (info != null && info.hasType()) {\n+          JSTypeExpression type = info.getType();\n+          JSDocInfoBuilder builder = new JSDocInfoBuilder(false);\n+          builder.recordType(type);\n+          newNode.setJSDocInfo(builder.build());\n+        }\n+        if (nameDeclaration.isConst()) {\n+          newNode.putBooleanProp(Node.IS_CONSTANT_VAR, true);\n+        }\n+        node.addChildToBack(newNode);\n+      }\n+    }\n+\n+    @Override\n+    public void processNew(NewExpression newExpression) {\n+      Node target = transform(newExpression.getTarget());\n+      Node callNode = newNode(Token.NEW, target);\n+      for (AstNode arg : newExpression.getArguments()) {\n+        callNode.addChildToBack(transform(arg));\n+      }\n+      this.node = callNode;\n+    }\n+\n+    @Override\n+    public void processNumber(NumberLiteral numberLiteral) {\n+      String value = numberLiteral.getValue();\n+      if (value.equals(\"NaN\")) {\n+        this.node = newNode(Token.NAME, \"NaN\");\n+      } else {\n+        this.node = newNode(Token.NUMBER, value);\n+      }\n+    }\n+\n+    @Override\n+    public void processObjectLiteral(ObjectLiteral objectLiteral) {\n+      Node obj = newNode(Token.OBJECTLIT);\n+      for (ObjectProperty property : objectLiteral.getElements()) {\n+        if (property instanceof ObjectProperty) {\n+          Node key = property.getKey() instanceof Name ?\n+              newName(property.getKey().getIdentifier()) :\n+              newNode(Token.STRING, property.getKey().getString());\n+          obj.addChildToBack(newNode(Token.MEMBER_DEF, key, transform(property.getValue())));\n+        } else {\n+          ObjectGet objGet = (ObjectGet) property;\n+          obj.addChildToBack(newNode(Token.MEMBER_DEF,\n+                  newName(objGet.getProperty().getIdentifier()),\n+                  IR.function(IR.name(\"\"), IR.paramList(IR.name(\"\")),\n+                          IR.block(IR.returnNode(transform(objGet.getBody())))))));\n+        }\n+      }\n+      this.node = obj;\n+    }\n+\n+    @Override\n+    public void processObjectProperty(ObjectProperty objectProperty) {\n+      Object key = objectProperty.getKey();\n+      if (key instanceof StringLiteral) {\n+        this.node = newNode(Token.STRING, ((StringLiteral) key).getValue());\n+      } else if (key instanceof Name) {\n+        this.node = newNode(Token.NAME, ((Name) key).getIdentifier());\n+      } else if (key instanceof NumberLiteral) {\n+        this.node = newNode(Token.NUMBER, ((NumberLiteral) key).getValue());\n+      } else {\n+        throw new RuntimeException(\"Unexpected property key type: \" + key.getClass());\n+      }\n+      this.node = newNode(Token.MEMBER_DEF, node, transfor\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}