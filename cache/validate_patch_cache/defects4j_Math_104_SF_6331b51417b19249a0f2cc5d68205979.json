{
    "patch": "import org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.FastMath;\n\npublic class Gamma {\n    /**\n     * Private constructor.\n     */\n    private Gamma() {\n        super();\n    }\n\n    /**\n     * <p>Computes the natural logarithm of the gamma function of <code>x</code>.\n     * This method computes the value of ln[\u0393(x)] for x &gt; 0.</p>\n     *\n     * @param x Argument.\n     * @return the value of ln[\u0393(x)].\n     */\n    public static double logGamma(final double x) {\n        if (Double.isNaN(x) || (x <= 0.0)) {\n            return Double.NaN;\n        }\n\n        /* Compute gamma(x) for x > 0 */\n        double gamma = Gamma.evaluate(x);\n        return FastMath.log(gamma);\n    }\n\n    /**\n     * <p>Computes the value of the gamma function of <code>x</code>.</p>\n     *\n     * <p>References:\n     * <ul>\n     * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">\n     * Gamma Function</a> from MathWorld.</li>\n     * <li><a href=\"http://www.it.usyd.edu.au/people/myskjaer/Research/LNCGaussAppr.html\">\n     * Lanczos Approximation</a> by Peter Myskjaer.</li>\n     * <li><a href=\"http://www.jesus.ox.ac.uk/~davies/pdf/GammaTheorem.pdf\">\n     * A Precision Approximation of the Gamma Function</a>,\n     * Nigel J. G. Crossley, Christian Kanzow, and Agnes S. M. Selby\n     * Department of Mathematics, UMIST, Manchester M60 1QD, UK.</li>\n     * </ul></p>\n     *\n     * @param x Argument.\n     * @return the value of \u0393(x).\n     * @throws OverflowException if the result is too large to be represented\n     * by a finite double.\n     * @throws MathIllegalArgumentException if x <= 0 and is not an integer.\n     */\n    private static double evaluate(final double x) {\n        if (Double.isNaN(x)) {\n            return x;\n        }\n\n        final double ret;\n        final double absX = FastMath.abs(x);\n        if (absX <= 20.0) {\n            if (x >= 1.0) {\n                /* A&S 6.1.36 */\n                double prod = 1.0;\n                double a = x;\n                double b = x + 1.0;\n                while (b < 3.0) {\n                    prod *= (a / b);\n                    a += 1.0;\n                    b += 1.0;\n                }\n                ret = prod / (1.0 + 0.5772156649015329 * x);\n            } else {\n                /* A&S 6.1.33 */\n                double prod = 1.0;\n                double tmpprod;\n                if (x < 1.0) {\n                    /* Use Euler's reflection formula (6.1.8) to shift\n                     * x to a value > 1.\n                     */\n                    prod /= x * FastMath.sin(FastMath.PI * x);\n                    x = 1.0 - x;\n                }\n                /* x is now >= 1 */\n                /* Step 1 */\n                while (x < 2.0) {\n                    prod *= x;\n                    x += 1.0;\n                }\n                /* Step 2 */\n                tmpprod = 1.0 + GC_1 / x;\n                tmpprod += GC_2 / (x * (x + 1.0));\n                tmpprod += GC_3 / (x * (x + 1.0) * (x + 2.0));\n                tmpprod += GC_4 / (x * (x + 1.0) * (x + 2.0) * (x + 3.0));\n                ret = prod * FastMath.exp(-x + (x - 0.5) * FastMath.log(x) + SQRT_TWO_PI * tmpprod / x);\n            }\n        } else {\n            /* Don't attempt too large a value of |x|. */\n            ret = Double.POSITIVE_INFINITY;\n        }\n        return ret;\n    }\n\n    /** g(1) in the Lanczos approximation. */\n    private static final double LG_1 = 0.99999999999999709182;\n    /** The constant {@link #LG_1} as a BigDecimal. */\n    private static final BigDecimal LG_1_BD = new BigDecimal(LG_1, MathUtils.EXT_PRECISION);\n    /** g(2) in the Lanczos approximation. */\n    private static final double LG_2 = 676.520368121885098567e0;\n    /** The constant {@link #LG_2} as a BigDecimal. */\n    private static final BigDecimal LG_2_BD = new BigDecimal(LG_2, MathUtils.EXT_PRECISION);\n    /** g(3) in the Lanczos approximation. */\n    private static final double LG_3 = -1259.1392167224028705e0;\n    /** The constant {@link #LG_3} as a BigDecimal. */\n    private static final BigDecimal LG_3_BD = new BigDecimal(LG_3, MathUtils.EXT_PRECISION);\n    /** g(4) in the Lanczos approximation. */\n    private static final double LG_4 = 771.3234287757671253e0;\n    /** The constant {@link #LG_4} as a BigDecimal. */\n    private static final BigDecimal LG_4_BD = new BigDecimal(LG_4, MathUtils.EXT_PRECISION);\n    /** g(5) in the Lanczos approximation. */\n    private static final double LG_5 = -176.61502914983862379e0;\n    /** The constant {@link #LG_5} as a BigDecimal. */\n    private static final BigDecimal LG_5_BD = new BigDecimal(LG_5, MathUtils.EXT_PRECISION);\n    /** g(6) in the Lanczos approximation. */\n    private static final double LG_6 = 12.507343278686904814e0;\n    /** The constant {@link #LG_6} as a BigDecimal. */\n    private static final BigDecimal LG_6_BD = new BigDecimal(LG_6, MathUtils.EXT_PRECISION);\n\n    /** ArithmeticUtils.PI / 2. */\n    private static final double HALF_PI = 1.570796326794896619;\n    /** The constant {@link #HALF_PI} as a BigDecimal. */\n    private static final BigDecimal HALF_PI_BD = new BigDecimal(HALF_PI, MathUtils.EXT_PRECISION);\n    /** &radic;(2 *&pi;) */\n    private static final double SQRT_TWO_PI = FastMath.sqrt(2 * FastMath.PI);\n    /** The constant {@link #SQRT_TWO_PI} as a BigDecimal. */\n    private static final BigDecimal SQRT_TWO_PI_BD = new BigDecimal(SQRT_TWO_PI, MathUtils.EXT_PRECISION);\n    /** ln(g) in the Lanczos approximation. */\n    private static final double LOG_G = 607.0 / 128.0;\n    /** The constant {@link #LOG_G} as a BigDecimal. */\n    private static final BigDecimal LOG_G_BD = new BigDecimal(LOG_G, MathUtils.EXT_PRECISION);\n    /** Constants for the computation of the Lanczos approximation in the\n     * interval (1,2). */\n    private static final double LT1P5 = 0.5;\n    /** Constants for the computation of the Lanczos approximation in the\n     * interval (1,2). */\n    private static final double LANCZOS_G = 607.0 / 128.0;\n    /** Constants for the computation of the Lanczos approximation in the\n     * interval (1,2). */\n    private static final double LANCZOS_G_MINUS = -0.5;\n    /** Constants for the computation of the Lanczos approximation in the\n     * interval (1,2). */\n    private static final double[] LANCZOS_NUM = {\n            0.99999999999999709182,\n            57.156235665862923517,\n            -59.597960355475491248,\n            14.136097974741747174,\n            -0.49191381609762019978,\n            0.33994649984811888699e-4,\n            0.46523628927048575665e-4,\n            -0.98374475304879564677e-4,\n            0.15808870322491248884e-3,\n            -0.21026444172410488319e-3,\n            0.21743961811521264320e-3,\n            -0.16431810653676389022e-3,\n            0.84418223983852743293e-4,\n            -0.26190838401581408670e-4,\n            0.36899182659531622704e-5\n    };\n    /** Constants for the computation of the Lanczos approximation in the\n     * interval (1,2). */\n    private static final double[] LANCZOS_DEN = {\n            1.00000000000000001678,\n            0.57721566490153286061,\n            -0.65587807152025388108,\n            -0.42002635034095235542,\n            -0.16653861138229148950,\n            -0.42197734555544336746e-1,\n            -0.96219715278769735639e-2,\n            -0.72189432466630995408e-2,\n            0.11651675918590651105e-1,\n            -0.21524167411495097281e-1,\n            0.12805028238811618636e-1,\n            -0.20134854780788238622e-2,\n            0.69374567766952334075e-2,\n            -0.49077583652580835222e-2,\n            0.10706222768261074068e-2\n    };\n    /** Constants for the computation of the Lanczos approximation in the\n     * interval (2,2.5). */\n    private static final double[] T Lanczos_DEN_STOP = {\n            0.99999999999999999997,\n            78.555948258616981548,\n            -142.24581228662382100,\n            89.348171427576726139,\n            -22.722670517582439600,\n            2.1760977124425010741,\n            -0.89665029791428482804e-2,\n            0.23856169751297926704e-3,\n            -0.33009037894481220100e-5\n    };\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..fb47ea262 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,203 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.FastMath;\n+\n+public class Gamma {\n+    /**\n+     * Private constructor.\n+     */\n+    private Gamma() {\n+        super();\n+    }\n+\n+    /**\n+     * <p>Computes the natural logarithm of the gamma function of <code>x</code>.\n+     * This method computes the value of ln[\u0393(x)] for x &gt; 0.</p>\n+     *\n+     * @param x Argument.\n+     * @return the value of ln[\u0393(x)].\n+     */\n+    public static double logGamma(final double x) {\n+        if (Double.isNaN(x) || (x <= 0.0)) {\n+            return Double.NaN;\n+        }\n+\n+        /* Compute gamma(x) for x > 0 */\n+        double gamma = Gamma.evaluate(x);\n+        return FastMath.log(gamma);\n+    }\n+\n+    /**\n+     * <p>Computes the value of the gamma function of <code>x</code>.</p>\n+     *\n+     * <p>References:\n+     * <ul>\n+     * <li><a href=\"http://mathworld.wolfram.com/GammaFunction.html\">\n+     * Gamma Function</a> from MathWorld.</li>\n+     * <li><a href=\"http://www.it.usyd.edu.au/people/myskjaer/Research/LNCGaussAppr.html\">\n+     * Lanczos Approximation</a> by Peter Myskjaer.</li>\n+     * <li><a href=\"http://www.jesus.ox.ac.uk/~davies/pdf/GammaTheorem.pdf\">\n+     * A Precision Approximation of the Gamma Function</a>,\n+     * Nigel J. G. Crossley, Christian Kanzow, and Agnes S. M. Selby\n+     * Department of Mathematics, UMIST, Manchester M60 1QD, UK.</li>\n+     * </ul></p>\n+     *\n+     * @param x Argument.\n+     * @return the value of \u0393(x).\n+     * @throws OverflowException if the result is too large to be represented\n+     * by a finite double.\n+     * @throws MathIllegalArgumentException if x <= 0 and is not an integer.\n+     */\n+    private static double evaluate(final double x) {\n+        if (Double.isNaN(x)) {\n+            return x;\n+        }\n+\n+        final double ret;\n+        final double absX = FastMath.abs(x);\n+        if (absX <= 20.0) {\n+            if (x >= 1.0) {\n+                /* A&S 6.1.36 */\n+                double prod = 1.0;\n+                double a = x;\n+                double b = x + 1.0;\n+                while (b < 3.0) {\n+                    prod *= (a / b);\n+                    a += 1.0;\n+                    b += 1.0;\n+                }\n+                ret = prod / (1.0 + 0.5772156649015329 * x);\n+            } else {\n+                /* A&S 6.1.33 */\n+                double prod = 1.0;\n+                double tmpprod;\n+                if (x < 1.0) {\n+                    /* Use Euler's reflection formula (6.1.8) to shift\n+                     * x to a value > 1.\n+                     */\n+                    prod /= x * FastMath.sin(FastMath.PI * x);\n+                    x = 1.0 - x;\n+                }\n+                /* x is now >= 1 */\n+                /* Step 1 */\n+                while (x < 2.0) {\n+                    prod *= x;\n+                    x += 1.0;\n+                }\n+                /* Step 2 */\n+                tmpprod = 1.0 + GC_1 / x;\n+                tmpprod += GC_2 / (x * (x + 1.0));\n+                tmpprod += GC_3 / (x * (x + 1.0) * (x + 2.0));\n+                tmpprod += GC_4 / (x * (x + 1.0) * (x + 2.0) * (x + 3.0));\n+                ret = prod * FastMath.exp(-x + (x - 0.5) * FastMath.log(x) + SQRT_TWO_PI * tmpprod / x);\n+            }\n+        } else {\n+            /* Don't attempt too large a value of |x|. */\n+            ret = Double.POSITIVE_INFINITY;\n+        }\n+        return ret;\n+    }\n+\n+    /** g(1) in the Lanczos approximation. */\n+    private static final double LG_1 = 0.99999999999999709182;\n+    /** The constant {@link #LG_1} as a BigDecimal. */\n+    private static final BigDecimal LG_1_BD = new BigDecimal(LG_1, MathUtils.EXT_PRECISION);\n+    /** g(2) in the Lanczos approximation. */\n+    private static final double LG_2 = 676.520368121885098567e0;\n+    /** The constant {@link #LG_2} as a BigDecimal. */\n+    private static final BigDecimal LG_2_BD = new BigDecimal(LG_2, MathUtils.EXT_PRECISION);\n+    /** g(3) in the Lanczos approximation. */\n+    private static final double LG_3 = -1259.1392167224028705e0;\n+    /** The constant {@link #LG_3} as a BigDecimal. */\n+    private static final BigDecimal LG_3_BD = new BigDecimal(LG_3, MathUtils.EXT_PRECISION);\n+    /** g(4) in the Lanczos approximation. */\n+    private static final double LG_4 = 771.3234287757671253e0;\n+    /** The constant {@link #LG_4} as a BigDecimal. */\n+    private static final BigDecimal LG_4_BD = new BigDecimal(LG_4, MathUtils.EXT_PRECISION);\n+    /** g(5) in the Lanczos approximation. */\n+    private static final double LG_5 = -176.61502914983862379e0;\n+    /** The constant {@link #LG_5} as a BigDecimal. */\n+    private static final BigDecimal LG_5_BD = new BigDecimal(LG_5, MathUtils.EXT_PRECISION);\n+    /** g(6) in the Lanczos approximation. */\n+    private static final double LG_6 = 12.507343278686904814e0;\n+    /** The constant {@link #LG_6} as a BigDecimal. */\n+    private static final BigDecimal LG_6_BD = new BigDecimal(LG_6, MathUtils.EXT_PRECISION);\n+\n+    /** ArithmeticUtils.PI / 2. */\n+    private static final double HALF_PI = 1.570796326794896619;\n+    /** The constant {@link #HALF_PI} as a BigDecimal. */\n+    private static final BigDecimal HALF_PI_BD = new BigDecimal(HALF_PI, MathUtils.EXT_PRECISION);\n+    /** &radic;(2 *&pi;) */\n+    private static final double SQRT_TWO_PI = FastMath.sqrt(2 * FastMath.PI);\n+    /** The constant {@link #SQRT_TWO_PI} as a BigDecimal. */\n+    private static final BigDecimal SQRT_TWO_PI_BD = new BigDecimal(SQRT_TWO_PI, MathUtils.EXT_PRECISION);\n+    /** ln(g) in the Lanczos approximation. */\n+    private static final double LOG_G = 607.0 / 128.0;\n+    /** The constant {@link #LOG_G} as a BigDecimal. */\n+    private static final BigDecimal LOG_G_BD = new BigDecimal(LOG_G, MathUtils.EXT_PRECISION);\n+    /** Constants for the computation of the Lanczos approximation in the\n+     * interval (1,2). */\n+    private static final double LT1P5 = 0.5;\n+    /** Constants for the computation of the Lanczos approximation in the\n+     * interval (1,2). */\n+    private static final double LANCZOS_G = 607.0 / 128.0;\n+    /** Constants for the computation of the Lanczos approximation in the\n+     * interval (1,2). */\n+    private static final double LANCZOS_G_MINUS = -0.5;\n+    /** Constants for the computation of the Lanczos approximation in the\n+     * interval (1,2). */\n+    private static final double[] LANCZOS_NUM = {\n+            0.99999999999999709182,\n+            57.156235665862923517,\n+            -59.597960355475491248,\n+            14.136097974741747174,\n+            -0.49191381609762019978,\n+            0.33994649984811888699e-4,\n+            0.46523628927048575665e-4,\n+            -0.98374475304879564677e-4,\n+            0.15808870322491248884e-3,\n+            -0.21026444172410488319e-3,\n+            0.21743961811521264320e-3,\n+            -0.16431810653676389022e-3,\n+            0.84418223983852743293e-4,\n+            -0.26190838401581408670e-4,\n+            0.36899182659531622704e-5\n+    };\n+    /** Constants for the computation of the Lanczos approximation in the\n+     * interval (1,2). */\n+    private static final double[] LANCZOS_DEN = {\n+            1.00000000000000001678,\n+            0.57721566490153286061,\n+            -0.65587807152025388108,\n+            -0.42002635034095235542,\n+            -0.16653861138229148950,\n+            -0.42197734555544336746e-1,\n+            -0.96219715278769735639e-2,\n+            -0.72189432466630995408e-2,\n+            0.11651675918590651105e-1,\n+            -0.21524167411495097281e-1,\n+            0.12805028238811618636e-1,\n+            -0.20134854780788238622e-2,\n+            0.69374567766952334075e-2,\n+            -0.49077583652580835222e-2,\n+            0.10706222768261074068e-2\n+    };\n+    /** Constants for the computation of the Lanczos approximation in the\n+     * interval (2,2.5). */\n+    private static final double[] T Lanczos_DEN_STOP = {\n+            0.99999999999999999997,\n+            78.555948258616981548,\n+            -142.24581228662382100,\n+            89.348171427576726139,\n+            -22.722670517582439600,\n+            2.1760977124425010741,\n+            -0.89665029791428482804e-2,\n+            0.23856169751297926704e-3,\n+            -0.33009037894481220100e-5\n+    };\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}