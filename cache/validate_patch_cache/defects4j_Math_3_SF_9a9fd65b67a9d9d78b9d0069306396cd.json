{
    "patch": "public static double linearCombination(final double[] a, final double[] b)\n        throws DimensionMismatchException {\n    final int len = a.length;\n\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n    if (len == 0) {\n        return 0.0;\n    }\n    if (len == 1) {\n        return a[0] * b[0];\n    }\n\n    // Revert to scalar multiplication.\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0;\n    double scalProd = 0;\n\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double bi = b[i];\n        final double prod = ai * bi;\n        prodHigh[i] = prod;\n        scalProd += prod;\n        prodLowSum += ((ai - prod) * bi + (bi - prod) * ai);\n    }\n\n    double s = prodHigh[len - 1];\n    double eps = 0;\n    for (int i = len - 2; i >= 0; i--) {\n        double t = eps + prodHigh[i];\n        eps = s - t;\n        s = t;\n    }\n\n    double result = (s + eps) + prodLowSum;\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0;\n        for (int i = 0; i < len; ++i) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..3be9f46cd 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -811,65 +811,53 @@ public class MathArrays {\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n-    public static double linearCombination(final double[] a, final double[] b)\n+public static double linearCombination(final double[] a, final double[] b)\n         throws DimensionMismatchException {\n-        final int len = a.length;\n-        if (len != b.length) {\n-            throw new DimensionMismatchException(len, b.length);\n-        }\n-\n-            // Revert to scalar multiplication.\n-\n-        final double[] prodHigh = new double[len];\n-        double prodLowSum = 0;\n-\n-        for (int i = 0; i < len; i++) {\n-            final double ai = a[i];\n-            final double ca = SPLIT_FACTOR * ai;\n-            final double aHigh = ca - (ca - ai);\n-            final double aLow = ai - aHigh;\n-\n-            final double bi = b[i];\n-            final double cb = SPLIT_FACTOR * bi;\n-            final double bHigh = cb - (cb - bi);\n-            final double bLow = bi - bHigh;\n-            prodHigh[i] = ai * bi;\n-            final double prodLow = aLow * bLow - (((prodHigh[i] -\n-                                                    aHigh * bHigh) -\n-                                                   aLow * bHigh) -\n-                                                  aHigh * bLow);\n-            prodLowSum += prodLow;\n-        }\n-\n+    final int len = a.length;\n \n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n+    if (len != b.length) {\n+        throw new DimensionMismatchException(len, b.length);\n+    }\n+    if (len == 0) {\n+        return 0.0;\n+    }\n+    if (len == 1) {\n+        return a[0] * b[0];\n+    }\n \n-        final int lenMinusOne = len - 1;\n-        for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n-            final double sHighCur = sHighPrev + prodHighNext;\n-            sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n-            sHighPrev = sHighCur;\n-        }\n+    // Revert to scalar multiplication.\n+    final double[] prodHigh = new double[len];\n+    double prodLowSum = 0;\n+    double scalProd = 0;\n+\n+    for (int i = 0; i < len; i++) {\n+        final double ai = a[i];\n+        final double bi = b[i];\n+        final double prod = ai * bi;\n+        prodHigh[i] = prod;\n+        scalProd += prod;\n+        prodLowSum += ((ai - prod) * bi + (bi - prod) * ai);\n+    }\n \n-        double result = sHighPrev + (prodLowSum + sLowSum);\n+    double s = prodHigh[len - 1];\n+    double eps = 0;\n+    for (int i = len - 2; i >= 0; i--) {\n+        double t = eps + prodHigh[i];\n+        eps = s - t;\n+        s = t;\n+    }\n \n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = 0;\n-            for (int i = 0; i < len; ++i) {\n-                result += a[i] * b[i];\n-            }\n+    double result = (s + eps) + prodLowSum;\n+    if (Double.isNaN(result)) {\n+        // either we have split infinite numbers or some coefficients were NaNs,\n+        // just rely on the naive implementation and let IEEE754 handle this\n+        result = 0;\n+        for (int i = 0; i < len; ++i) {\n+            result += a[i] * b[i];\n         }\n-\n-        return result;\n     }\n+    return result;\n+}\n \n     /**\n      * Compute a linear combination accurately.",
    "result_reason": "junit.framework.AssertionFailedError: expected:<-1.8551294182586249> but was:<4.193908949667578E27>",
    "test_result": "FAIL"
}