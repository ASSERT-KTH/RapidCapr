{
    "patch": "public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        // Validate input\n        clearResult();\n        verifyInterval(min, max);\n        verifySequence(min, initial, max);\n\n        // Compute values for min, initial and max\n        double yMin = f.value(min);\n        double yInitial = f.value(initial);\n        double yMax = f.value(max);\n\n        // Check if initial guess is already the root\n        if (yInitial == 0) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // Check if end-points are roots\n        if (yMin * yMax <= 0) {\n            if (yMin == 0) {\n                setResult(min, 0);\n                return result;\n            }\n            if (yMax == 0) {\n                setResult(max, 0);\n                return result;\n            }\n        } else {\n            throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        // Set-up iteration variables\n        double a = Math.min(initial, max);\n        double b = Math.max(initial, min);\n        double c = initial;\n        double yC = yInitial;\n        double d = b - a;\n        double e = d;\n\n        int i = 0;\n        while (i < maximalIterationCount) {\n            i++;\n            double previousD = d;\n\n            // Determine if bisection is necessary\n            if (Math.abs(yC) < Math.abs(yMax)) {\n                // Perform bisection step\n                a = b;\n                b = c;\n                c = a;\n                yMin = yInitial;\n                yInitial = yC;\n                yC = yMin;\n            }\n\n            // Check if we're close enough to the root\n            if (Math.abs(yC) <= functionValueAccuracy || Math.abs(d) <= absoluteAccuracy) {\n                setResult(c, i);\n                return result;\n            }\n\n            // Compute the parabolic step\n            double delta;\n            if (Math.abs(previousD) > absoluteAccuracy) {\n                double r = (yC - yInitial) * (c - b);\n                double q = (yC - yMax) * (c - a);\n                double p = (yC - yMax) * (b - a);\n                delta = q - p;\n                double absDelta = Math.abs(delta);\n                double max1 = Math.max(Math.abs(q), Math.abs(p));\n                if (absDelta >= max1 * 0.5 * Math.abs(e) ||\n                        delta <= max1 * (a - c) || delta >= max1 * (b - c)) {\n                    delta = e * (yC < yInitial ? sign(d) : sign(b - a));\n                } else {\n                    e = d;\n                    d = delta / max1;\n                }\n            } else {\n                delta = e * (yC < yInitial ? sign(d) : sign(b - a));\n            }\n\n            // Update variables for next iteration\n            double tempB = b;\n            double tempYB = yInitial;\n\n            if (Math.abs(delta) >= absoluteAccuracy) {\n                b = c - delta;\n                if (b - a < 0.5 * previousD) {\n                    b = a + 0.5 * previousD;\n                }\n            } else {\n                b += sign(b - a) * absoluteAccuracy;\n            }\n\n            // Compute the value of the function at the step point\n            double tempYC = yC;\n            yC = f.value(b);\n\n            // Update variables for next iteration\n            if (Math.abs(yC) < Math.abs(tempYB)) {\n                a = b;\n                b = c;\n                c = b;\n                yMin = yInitial;\n                yInitial = tempYC;\n                yC = yMin;\n            } else if (Math.abs(yC) > Math.abs(tempYC)) {\n                c = tempB;\n                yMin = tempYB;\n                yInitial = tempYC;\n                yC = yMin;\n            } else {\n                a = b;\n                c = tempB;\n                yMin = yInitial;\n                yInitial = tempYC;\n                yC = yMin;\n            }\n\n            // Check for convergence\n            if (Math.abs(yC) <= functionValueAccuracy || Math.abs(d) <= absoluteAccuracy) {\n                setResult(b, i);\n                return result;\n            }\n\n            // Update interval size\n            d = b - a;\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }\n\n    private double sign(double x) {\n        return (x >= 0) ? 1 : -1;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..fa25b2265 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,52 +95,142 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n+public double solve(final UnivariateRealFunction f, final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n+        // Validate input\n         clearResult();\n+        verifyInterval(min, max);\n         verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n+        // Compute values for min, initial and max\n+        double yMin = f.value(min);\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+        double yMax = f.value(max);\n+\n+        // Check if initial guess is already the root\n+        if (yInitial == 0) {\n             setResult(initial, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n+        // Check if end-points are roots\n+        if (yMin * yMax <= 0) {\n+            if (yMin == 0) {\n+                setResult(min, 0);\n+                return result;\n+            }\n+            if (yMax == 0) {\n+                setResult(max, 0);\n+                return result;\n+            }\n+        } else {\n+            throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+        // Set-up iteration variables\n+        double a = Math.min(initial, max);\n+        double b = Math.max(initial, min);\n+        double c = initial;\n+        double yC = yInitial;\n+        double d = b - a;\n+        double e = d;\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n-            return result;\n-        }\n+        int i = 0;\n+        while (i < maximalIterationCount) {\n+            i++;\n+            double previousD = d;\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+            // Determine if bisection is necessary\n+            if (Math.abs(yC) < Math.abs(yMax)) {\n+                // Perform bisection step\n+                a = b;\n+                b = c;\n+                c = a;\n+                yMin = yInitial;\n+                yInitial = yC;\n+                yC = yMin;\n+            }\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+            // Check if we're close enough to the root\n+            if (Math.abs(yC) <= functionValueAccuracy || Math.abs(d) <= absoluteAccuracy) {\n+                setResult(c, i);\n+                return result;\n+            }\n+\n+            // Compute the parabolic step\n+            double delta;\n+            if (Math.abs(previousD) > absoluteAccuracy) {\n+                double r = (yC - yInitial) * (c - b);\n+                double q = (yC - yMax) * (c - a);\n+                double p = (yC - yMax) * (b - a);\n+                delta = q - p;\n+                double absDelta = Math.abs(delta);\n+                double max1 = Math.max(Math.abs(q), Math.abs(p));\n+                if (absDelta >= max1 * 0.5 * Math.abs(e) ||\n+                        delta <= max1 * (a - c) || delta >= max1 * (b - c)) {\n+                    delta = e * (yC < yInitial ? sign(d) : sign(b - a));\n+                } else {\n+                    e = d;\n+                    d = delta / max1;\n+                }\n+            } else {\n+                delta = e * (yC < yInitial ? sign(d) : sign(b - a));\n+            }\n+\n+            // Update variables for next iteration\n+            double tempB = b;\n+            double tempYB = yInitial;\n+\n+            if (Math.abs(delta) >= absoluteAccuracy) {\n+                b = c - delta;\n+                if (b - a < 0.5 * previousD) {\n+                    b = a + 0.5 * previousD;\n+                }\n+            } else {\n+                b += sign(b - a) * absoluteAccuracy;\n+            }\n+\n+            // Compute the value of the function at the step point\n+            double tempYC = yC;\n+            yC = f.value(b);\n+\n+            // Update variables for next iteration\n+            if (Math.abs(yC) < Math.abs(tempYB)) {\n+                a = b;\n+                b = c;\n+                c = b;\n+                yMin = yInitial;\n+                yInitial = tempYC;\n+                yC = yMin;\n+            } else if (Math.abs(yC) > Math.abs(tempYC)) {\n+                c = tempB;\n+                yMin = tempYB;\n+                yInitial = tempYC;\n+                yC = yMin;\n+            } else {\n+                a = b;\n+                c = tempB;\n+                yMin = yInitial;\n+                yInitial = tempYC;\n+                yC = yMin;\n+            }\n+\n+            // Check for convergence\n+            if (Math.abs(yC) <= functionValueAccuracy || Math.abs(d) <= absoluteAccuracy) {\n+                setResult(b, i);\n+                return result;\n+            }\n+\n+            // Update interval size\n+            d = b - a;\n         }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n+    }\n \n+    private double sign(double x) {\n+        return (x >= 0) ? 1 : -1;\n     }\n \n     /**",
    "result_reason": "junit.framework.AssertionFailedError: expected:<0.61> but was:<1.0>",
    "test_result": "FAIL"
}