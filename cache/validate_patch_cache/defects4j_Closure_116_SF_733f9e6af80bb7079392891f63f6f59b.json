{
    "patch": "private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n    return CanInlineResult.NO;\n  }\n\n  Node block = fnNode.getLastChild();\n\n  Node paramList = NodeUtil.getFunctionParameters(fnNode);\n  if (paramList.hasChildren() && paramList.getFirstChild().isRest()) {\n    // do not attempt to inline functions with rest parameters\n    return CanInlineResult.NO;\n  }\n\n  Node argList = callNode.getFirstChild().getNext();\n  Node thisArg = null;\n\n  if (!callNode.getFirstChild().isName()) {\n    if (NodeUtil.isFunctionObjectCall(callNode)) {\n      if (argList == null || !argList.isThis()) {\n        return CanInlineResult.NO;\n      }\n      thisArg = argList;\n      argList = argList.getNext();\n    } else {\n      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode), callNode);\n    }\n  }\n\n  Node param = paramList.getFirstChild();\n  Node firstOptional = null;\n  int i = 0;\n  while (argList != null || param != null) {\n    if (param != null && param.isOptional()) {\n      firstOptional = param;\n    }\n\n    if (argList == null) {\n      if (param.isDefaultValue() || param.isOptional()) {\n        // No argument, but the parameter has a default value.\n      } else {\n        // No argument and no default value.\n        return CanInlineResult.NO;\n      }\n    } else {\n      if (argList.isSpread()) {\n        Node rest = argList.getNext();\n        if (rest != null) {\n          return CanInlineResult.NO;\n        }\n        if (param.isRest()) {\n          return CanInlineResult.MAYBE_WITH_REST_VALUES;\n        } else if (NodeUtil.hasDirectCallOnFunctionCalls(argList, compiler)) {\n          // We won't inline this function, so don't waste time checking it.\n          return CanInlineResult.NO;\n        } else {\n          InlineCost cost = shouldInlineArgument(argList.getFirstChild());\n          if (cost.always()) {\n            // `INLINE_GETs` and `INLINE_NODE_COUNT` in the returned cost are dropped on\n            // the floor here because they describe the argument that has just been checked.\n            if (!ArgumentCostUtil.hasSideEffects(cost)) {\n              // The spread argument has no side-effect and can be inlined. This means that the spread\n              // operator can be replaced with its operand.\n              argList.getParent().replaceChild(argList, argList.getFirstChild());\n            } else {\n              return CanInlineResult.NO;\n            }\n          } else if (cost.never()) {\n            return CanInlineResult.NO;\n          } else if (param.isRest() && cost.withinLimit()) {\n            return CanInlineResult.MAYBE_WITH_REST_VALUES;\n          }\n          // else (param is not rest and `cost` is within the limit) continue the loop\n        }\n        argList = null;\n      } else {\n        InlineCost cost = shouldInlineArgument(argList);\n        if (cost.always()) {\n          // `INLINE_GETs` and `INLINE_NODE_COUNT` in the returned cost are dropped on\n          // the floor here because they describe the argument that has just been checked.\n          if (NodeUtil.mayHaveSideEffects(argList, compiler)\n              || NodeUtil.mustPreserveReturnValue(argList)) {\n            return CanInlineResult.NO;\n          }\n          if (param == null || param.isRest()) {\n            return CanInlineResult.MAYBE_WITH_REST_VALUES;\n          } else {\n            // Inline the argument now. Replace the single-value GETARG and the CALL_NODE with the single argument.\n            argList.getParent().replaceChild(argList, IR.name(param.getIdentifier()));\n            callNode.getFirstChild().replaceChild(argList, argList.getFirstChild());\n          }\n        } else if (cost.never()) {\n          return CanInlineResult.NO;\n        } else if (param == null) {\n          // more arguments than parameters, so we cannot inline\n          return CanInlineResult.NO;\n        } else if (param.isRest() && cost.withinLimit()) {\n          return CanInlineResult.MAYBE_WITH_REST_VALUES;\n        }\n        // else (param is not rest and `cost` is within the limit) continue the loop\n        argList = argList.getNext();\n      }\n    }\n    param = param != null ? param.getNext() : null;\n    i++;\n  }\n\n  // check for parameter count mismatch\n  if (param != null && !(firstOptional != null && param == firstOptional)) {\n    return CanInlineResult.NO;\n  }\n\n  // check for side-effects in the called function\n  if (NodeUtil.containsFunctionNode(block)) {\n    return CanInlineResult.NO;\n  }\n\n  // check for side-effects in the this object argument, if any\n  if (thisArg != null && NodeUtil.mayHaveSideEffects(thisArg, compiler)) {\n    return CanInlineResult.NO;\n  }\n\n  // everything checks out, we can inline the function call\n  return CanInlineResult.YES;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FunctionInjector.java b/src/com/google/javascript/jscomp/FunctionInjector.java\nindex c3fc14b2..b04a34d9 100644\n--- a/src/com/google/javascript/jscomp/FunctionInjector.java\n+++ b/src/com/google/javascript/jscomp/FunctionInjector.java\n@@ -686,68 +686,131 @@ class FunctionInjector {\n    *     x = foo(i++);\n    * </pre>\n    */\n-  private CanInlineResult canInlineReferenceDirectly(\n-      Node callNode, Node fnNode) {\n-    if (!isDirectCallNodeReplacementPossible(fnNode)) {\n-      return CanInlineResult.NO;\n-    }\n+private CanInlineResult canInlineReferenceDirectly(Node callNode, Node fnNode) {\n+  if (!isDirectCallNodeReplacementPossible(fnNode)) {\n+    return CanInlineResult.NO;\n+  }\n \n-    Node block = fnNode.getLastChild();\n+  Node block = fnNode.getLastChild();\n \n+  Node paramList = NodeUtil.getFunctionParameters(fnNode);\n+  if (paramList.hasChildren() && paramList.getFirstChild().isRest()) {\n+    // do not attempt to inline functions with rest parameters\n+    return CanInlineResult.NO;\n+  }\n \n-    // CALL NODE: [ NAME, ARG1, ARG2, ... ]\n-    Node cArg = callNode.getFirstChild().getNext();\n+  Node argList = callNode.getFirstChild().getNext();\n+  Node thisArg = null;\n \n-    // Functions called via 'call' and 'apply' have a this-object as\n-    // the first parameter, but this is not part of the called function's\n-    // parameter list.\n-    if (!callNode.getFirstChild().isName()) {\n-      if (NodeUtil.isFunctionObjectCall(callNode)) {\n-        // TODO(johnlenz): Support replace this with a value.\n-        if (cArg == null || !cArg.isThis()) {\n-          return CanInlineResult.NO;\n-        }\n-        cArg = cArg.getNext();\n-      } else {\n-        // \".apply\" call should be filtered before this.\n-        Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode));\n+  if (!callNode.getFirstChild().isName()) {\n+    if (NodeUtil.isFunctionObjectCall(callNode)) {\n+      if (argList == null || !argList.isThis()) {\n+        return CanInlineResult.NO;\n       }\n+      thisArg = argList;\n+      argList = argList.getNext();\n+    } else {\n+      Preconditions.checkState(!NodeUtil.isFunctionObjectApply(callNode), callNode);\n+    }\n+  }\n+\n+  Node param = paramList.getFirstChild();\n+  Node firstOptional = null;\n+  int i = 0;\n+  while (argList != null || param != null) {\n+    if (param != null && param.isOptional()) {\n+      firstOptional = param;\n     }\n \n-    // FUNCTION NODE -> LP NODE: [ ARG1, ARG2, ... ]\n-    Node fnParam = NodeUtil.getFunctionParameters(fnNode).getFirstChild();\n-    while (cArg != null || fnParam != null) {\n-      // For each named parameter check if a mutable argument use more than one.\n-      if (fnParam != null) {\n-        if (cArg != null) {\n-\n-          // Check for arguments that are evaluated more than once.\n-          // Note: Unlike block inlining, there it is not possible that a\n-          // parameter reference will be in a loop.\n-          if (NodeUtil.mayEffectMutableState(cArg, compiler)\n-              && NodeUtil.getNameReferenceCount(\n-                  block, fnParam.getString()) > 1) {\n+    if (argList == null) {\n+      if (param.isDefaultValue() || param.isOptional()) {\n+        // No argument, but the parameter has a default value.\n+      } else {\n+        // No argument and no default value.\n+        return CanInlineResult.NO;\n+      }\n+    } else {\n+      if (argList.isSpread()) {\n+        Node rest = argList.getNext();\n+        if (rest != null) {\n+          return CanInlineResult.NO;\n+        }\n+        if (param.isRest()) {\n+          return CanInlineResult.MAYBE_WITH_REST_VALUES;\n+        } else if (NodeUtil.hasDirectCallOnFunctionCalls(argList, compiler)) {\n+          // We won't inline this function, so don't waste time checking it.\n+          return CanInlineResult.NO;\n+        } else {\n+          InlineCost cost = shouldInlineArgument(argList.getFirstChild());\n+          if (cost.always()) {\n+            // `INLINE_GETs` and `INLINE_NODE_COUNT` in the returned cost are dropped on\n+            // the floor here because they describe the argument that has just been checked.\n+            if (!ArgumentCostUtil.hasSideEffects(cost)) {\n+              // The spread argument has no side-effect and can be inlined. This means that the spread\n+              // operator can be replaced with its operand.\n+              argList.getParent().replaceChild(argList, argList.getFirstChild());\n+            } else {\n+              return CanInlineResult.NO;\n+            }\n+          } else if (cost.never()) {\n             return CanInlineResult.NO;\n+          } else if (param.isRest() && cost.withinLimit()) {\n+            return CanInlineResult.MAYBE_WITH_REST_VALUES;\n           }\n+          // else (param is not rest and `cost` is within the limit) continue the loop\n         }\n-\n-        // Move to the next name.\n-        fnParam = fnParam.getNext();\n-      }\n-\n-      // For every call argument check for side-effects, even if there\n-      // isn't a named parameter to match.\n-      if (cArg != null) {\n-        if (NodeUtil.mayHaveSideEffects(cArg, compiler)) {\n+        argList = null;\n+      } else {\n+        InlineCost cost = shouldInlineArgument(argList);\n+        if (cost.always()) {\n+          // `INLINE_GETs` and `INLINE_NODE_COUNT` in the returned cost are dropped on\n+          // the floor here because they describe the argument that has just been checked.\n+          if (NodeUtil.mayHaveSideEffects(argList, compiler)\n+              || NodeUtil.mustPreserveReturnValue(argList)) {\n+            return CanInlineResult.NO;\n+          }\n+          if (param == null || param.isRest()) {\n+            return CanInlineResult.MAYBE_WITH_REST_VALUES;\n+          } else {\n+            // Inline the argument now. Replace the single-value GETARG and the CALL_NODE with the single argument.\n+            argList.getParent().replaceChild(argList, IR.name(param.getIdentifier()));\n+            callNode.getFirstChild().replaceChild(argList, argList.getFirstChild());\n+          }\n+        } else if (cost.never()) {\n+          return CanInlineResult.NO;\n+        } else if (param == null) {\n+          // more arguments than parameters, so we cannot inline\n           return CanInlineResult.NO;\n+        } else if (param.isRest() && cost.withinLimit()) {\n+          return CanInlineResult.MAYBE_WITH_REST_VALUES;\n         }\n-        cArg = cArg.getNext();\n+        // else (param is not rest and `cost` is within the limit) continue the loop\n+        argList = argList.getNext();\n       }\n     }\n+    param = param != null ? param.getNext() : null;\n+    i++;\n+  }\n+\n+  // check for parameter count mismatch\n+  if (param != null && !(firstOptional != null && param == firstOptional)) {\n+    return CanInlineResult.NO;\n+  }\n \n-    return CanInlineResult.YES;\n+  // check for side-effects in the called function\n+  if (NodeUtil.containsFunctionNode(block)) {\n+    return CanInlineResult.NO;\n   }\n \n+  // check for side-effects in the this object argument, if any\n+  if (thisArg != null && NodeUtil.mayHaveSideEffects(thisArg, compiler)) {\n+    return CanInlineResult.NO;\n+  }\n+\n+  // everything checks out, we can inline the function call\n+  return CanInlineResult.YES;\n+}\n+\n   /**\n    * Determine if inlining the function is likely to reduce the code size.\n    * @param namesToAlias",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}