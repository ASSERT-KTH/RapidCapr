{
    "patch": "    \n    final Node body = NodeUtil.getFunctionBody(function);\n    final Node argList = NodeUtil.getFunctionParameters(function);\n    final NodeList<Node> arguments = argList.children();\n    final Set<String> referencedNames = Sets.newHashSet();\n    final Set<String> referencedInNested = Sets.newHashSet();\n    NodeTraversal.traverse(compiler, body, new NodeTraversal.Callback() {\n      @Override\n      public void visit(NodeTraversal nodeTraversal, Node n, Node parent) {\n        if (n.isName() && !n.getString().isEmpty()) {\n          String name = n.getString();\n          if (arguments.contains(n) || referencedNames.contains(name)) {\n            // the parameter is referenced or has been marked as referenced already\n            return;\n          }\n          // check if the name is referenced in nested scopes\n          Scope scope = nodeTraversal.getScope();\n          while (scope != null && scope.getRootNode() != function\n              && referencedInNested.add(name)) {\n            Var var = scope.getVar(name);\n            if (var != null) {\n              // the name is referenced in a nested function\n              return;\n            }\n            scope = scope.getParent();\n          }\n          referencedNames.add(name);\n        }\n      }\n    });\n\n    ListIterator<Node> argIter = arguments.last().listIterator();\n    for (int i = arguments.size() - 1; i >= 0; i--) {\n      Node arg = arguments.get(i);\n      if (!referencedNames.contains(arg.getString()) || referencedInNested.contains(arg.getString())) {\n        // the argument is not referenced\n        argIter.previous();\n        argIter.remove();\n        compiler.reportCodeChange();\n      } else {\n        break; // stop removing arguments",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..e976440a 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,47 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    \n+    final Node body = NodeUtil.getFunctionBody(function);\n+    final Node argList = NodeUtil.getFunctionParameters(function);\n+    final NodeList<Node> arguments = argList.children();\n+    final Set<String> referencedNames = Sets.newHashSet();\n+    final Set<String> referencedInNested = Sets.newHashSet();\n+    NodeTraversal.traverse(compiler, body, new NodeTraversal.Callback() {\n+      @Override\n+      public void visit(NodeTraversal nodeTraversal, Node n, Node parent) {\n+        if (n.isName() && !n.getString().isEmpty()) {\n+          String name = n.getString();\n+          if (arguments.contains(n) || referencedNames.contains(name)) {\n+            // the parameter is referenced or has been marked as referenced already\n+            return;\n+          }\n+          // check if the name is referenced in nested scopes\n+          Scope scope = nodeTraversal.getScope();\n+          while (scope != null && scope.getRootNode() != function\n+              && referencedInNested.add(name)) {\n+            Var var = scope.getVar(name);\n+            if (var != null) {\n+              // the name is referenced in a nested function\n+              return;\n+            }\n+            scope = scope.getParent();\n+          }\n+          referencedNames.add(name);\n+        }\n+      }\n+    });\n+\n+    ListIterator<Node> argIter = arguments.last().listIterator();\n+    for (int i = arguments.size() - 1; i >= 0; i--) {\n+      Node arg = arguments.get(i);\n+      if (!referencedNames.contains(arg.getString()) || referencedInNested.contains(arg.getString())) {\n+        // the argument is not referenced\n+        argIter.previous();\n+        argIter.remove();\n+        compiler.reportCodeChange();\n+      } else {\n+        break; // stop removing arguments\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}