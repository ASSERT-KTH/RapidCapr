{
    "patch": "public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n    // overridden as superclass algorithm can't handle\n    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n    if (valueToAdd == 0) {\n        return values;\n    }\n    // month is largest field and being added to, such as month-day\n    if (DateTimeUtils.isContiguous(partial)) {\n        long instant = 0L;\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n        }\n        instant = add(instant, valueToAdd);\n        return iChronology.get(partial, instant);\n    } else {\n        int yearValue = DateTimeUtils.safeAdd(values[DateTimeFieldType.yearIndex()], valueToAdd);\n        int monthValue = values[DateTimeFieldType.monthOfYearIndex()];\n        int dayValue = values[DateTimeFieldType.dayOfMonthIndex()];\n        for (int i = 0, isize = partial.size(); i < isize; i++) {\n            if (partial.getFieldType(i).equals(DateTimeFieldType.year())) {\n                yearValue = partial.getFieldType(i).getField(iChronology).set(yearValue, values[i]);\n            }\n            else if (partial.getFieldType(i).equals(DateTimeFieldType.monthOfYear())) {\n                monthValue = partial.getFieldType(i).getField(iChronology).set(monthValue, values[i]);\n            }\n            else if (partial.getFieldType(i).equals(DateTimeFieldType.dayOfMonth())) {\n                dayValue = partial.getFieldType(i).getField(iChronology).set(dayValue, values[i]);\n            }\n        }\n        try {\n            long instant = iChronology.getDateTimeMillis(yearValue, monthValue, dayValue, 0);\n            return iChronology.get(partial, instant);\n        } catch (IllegalArgumentException e) {\n            if (monthValue != 2 || dayValue != 29) {\n                throw e;\n            }\n            instant = iChronology.getDateTimeMillis(yearValue, 3, 1, 0);\n            instant = add(instant, -1);\n            return iChronology.get(partial, instant);\n        }\n    }\n}\n\nprivate long add(long instant, int months) {\n    if (months == 0) {\n        return instant;\n    }\n    long yearMonth = (iChronology.year().get(instant) * 12) + iChronology.monthOfYear().get(instant) - 1;\n    int calcYear = (int) (yearMonth / 12);\n    int calcMonth = (int) (yearMonth % 12) + 1;\n    int jumpYears = months / 12;\n    calcYear += jumpYears;\n    calcMonth += months % 12;\n    if (calcMonth <= 0) {\n        calcMonth += 12;\n        calcYear -= 1;\n    }\n    if (calcMonth > 12) {\n        calcMonth -= 12;\n        calcYear += 1;\n    }\n    int dom = iChronology.dayOfMonth().get(instant);\n    int maxDom = iChronology.getDaysInMonthMax();\n    if (dom > maxDom) {\n        dom = maxDom;\n    }\n    int year = iChronology.year().set(0, calcYear);\n    int monthOfYear = iChronology.monthOfYear().set(0, calcMonth);\n    int dayOfMonth = iChronology.dayOfMonth().set(0, dom);\n    long resolved = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, \n                                                   iChronology.millisOfSecond().get(instant));\n    if (resolved < instant && calcYear > 0) {\n        throw new IllegalArgumentException(\"Invalid result: year overflow\");\n    }\n    if (resolved > instant && calcYear < 0) {\n        throw new IllegalArgumentException(\"Invalid result: year overflow\");\n    }\n    return resolved;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\nindex afca44e6..ff5b7c1b 100644\n--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -200,24 +200,85 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n     }\n \n     //-----------------------------------------------------------------------\n-    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n-        // overridden as superclass algorithm can't handle\n-        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n-        if (valueToAdd == 0) {\n-            return values;\n+public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n+    // overridden as superclass algorithm can't handle\n+    // 2004-02-29 + 48 months -> 2008-02-29 type dates\n+    if (valueToAdd == 0) {\n+        return values;\n+    }\n+    // month is largest field and being added to, such as month-day\n+    if (DateTimeUtils.isContiguous(partial)) {\n+        long instant = 0L;\n+        for (int i = 0, isize = partial.size(); i < isize; i++) {\n+            instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+        }\n+        instant = add(instant, valueToAdd);\n+        return iChronology.get(partial, instant);\n+    } else {\n+        int yearValue = DateTimeUtils.safeAdd(values[DateTimeFieldType.yearIndex()], valueToAdd);\n+        int monthValue = values[DateTimeFieldType.monthOfYearIndex()];\n+        int dayValue = values[DateTimeFieldType.dayOfMonthIndex()];\n+        for (int i = 0, isize = partial.size(); i < isize; i++) {\n+            if (partial.getFieldType(i).equals(DateTimeFieldType.year())) {\n+                yearValue = partial.getFieldType(i).getField(iChronology).set(yearValue, values[i]);\n+            }\n+            else if (partial.getFieldType(i).equals(DateTimeFieldType.monthOfYear())) {\n+                monthValue = partial.getFieldType(i).getField(iChronology).set(monthValue, values[i]);\n+            }\n+            else if (partial.getFieldType(i).equals(DateTimeFieldType.dayOfMonth())) {\n+                dayValue = partial.getFieldType(i).getField(iChronology).set(dayValue, values[i]);\n+            }\n         }\n-            // month is largest field and being added to, such as month-day\n-        if (DateTimeUtils.isContiguous(partial)) {\n-            long instant = 0L;\n-            for (int i = 0, isize = partial.size(); i < isize; i++) {\n-                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+        try {\n+            long instant = iChronology.getDateTimeMillis(yearValue, monthValue, dayValue, 0);\n+            return iChronology.get(partial, instant);\n+        } catch (IllegalArgumentException e) {\n+            if (monthValue != 2 || dayValue != 29) {\n+                throw e;\n             }\n-            instant = add(instant, valueToAdd);\n+            instant = iChronology.getDateTimeMillis(yearValue, 3, 1, 0);\n+            instant = add(instant, -1);\n             return iChronology.get(partial, instant);\n-        } else {\n-            return super.add(partial, fieldIndex, values, valueToAdd);\n         }\n     }\n+}\n+\n+private long add(long instant, int months) {\n+    if (months == 0) {\n+        return instant;\n+    }\n+    long yearMonth = (iChronology.year().get(instant) * 12) + iChronology.monthOfYear().get(instant) - 1;\n+    int calcYear = (int) (yearMonth / 12);\n+    int calcMonth = (int) (yearMonth % 12) + 1;\n+    int jumpYears = months / 12;\n+    calcYear += jumpYears;\n+    calcMonth += months % 12;\n+    if (calcMonth <= 0) {\n+        calcMonth += 12;\n+        calcYear -= 1;\n+    }\n+    if (calcMonth > 12) {\n+        calcMonth -= 12;\n+        calcYear += 1;\n+    }\n+    int dom = iChronology.dayOfMonth().get(instant);\n+    int maxDom = iChronology.getDaysInMonthMax();\n+    if (dom > maxDom) {\n+        dom = maxDom;\n+    }\n+    int year = iChronology.year().set(0, calcYear);\n+    int monthOfYear = iChronology.monthOfYear().set(0, calcMonth);\n+    int dayOfMonth = iChronology.dayOfMonth().set(0, dom);\n+    long resolved = iChronology.getDateTimeMillis(year, monthOfYear, dayOfMonth, \n+                                                   iChronology.millisOfSecond().get(instant));\n+    if (resolved < instant && calcYear > 0) {\n+        throw new IllegalArgumentException(\"Invalid result: year overflow\");\n+    }\n+    if (resolved > instant && calcYear < 0) {\n+        throw new IllegalArgumentException(\"Invalid result: year overflow\");\n+    }\n+    return resolved;\n+}\n \n     //-----------------------------------------------------------------------\n     /**",
    "result_reason": "error: method add(long,int) is already defined in class BasicMonthOfYearDateTimeField",
    "test_result": "ERROR"
}