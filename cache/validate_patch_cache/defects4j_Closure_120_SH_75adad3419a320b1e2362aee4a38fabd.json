{
    "patch": "Node cfgNode = getCfg().getNode(ref.getNode().getId());\nList<DiGraphEdge<Node, Branch>> edges = getCfg().getOutEdges(cfgNode);\n\n// A variable that has control flow branches that meet both of the following requirements is not assigned once:\n// 1. has an unconditional branch to another node in the CFG\n// 2. has an ON_EX branch to exit the CFG\nboolean hasUnconditionalBranch = false;\nboolean hasOnExBranch = false;\n\nfor (DiGraphEdge<Node, Branch> edge : edges) {\n  Branch branchType = edge.getValue();\n  Node successorNode = edge.getEnd();\n\n  if (branchType == Branch.UNCOND) {\n    hasUnconditionalBranch = true;\n    // Check the current node's descendants because following branches would also force the data flow to diverge.\n    if (hasDescendant(successorNode, cfgNode)) {\n      return false;\n    }\n  } else if (branchType == Branch.ON_EX) {\n    hasOnExBranch = true;\n    // Return true and don't check the current node's descendants because any existing data flow must terminate here.\n    return true;\n  }\n}\n\n// If the node has no branches to exit the CFG, then all control flow paths must converge at some point.\nif (!hasOnExBranch) {\n  return !hasUnconditionalBranch;\n}\n\nreturn false;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..0b2f7d61 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,38 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+Node cfgNode = getCfg().getNode(ref.getNode().getId());\n+List<DiGraphEdge<Node, Branch>> edges = getCfg().getOutEdges(cfgNode);\n+\n+// A variable that has control flow branches that meet both of the following requirements is not assigned once:\n+// 1. has an unconditional branch to another node in the CFG\n+// 2. has an ON_EX branch to exit the CFG\n+boolean hasUnconditionalBranch = false;\n+boolean hasOnExBranch = false;\n+\n+for (DiGraphEdge<Node, Branch> edge : edges) {\n+  Branch branchType = edge.getValue();\n+  Node successorNode = edge.getEnd();\n+\n+  if (branchType == Branch.UNCOND) {\n+    hasUnconditionalBranch = true;\n+    // Check the current node's descendants because following branches would also force the data flow to diverge.\n+    if (hasDescendant(successorNode, cfgNode)) {\n+      return false;\n+    }\n+  } else if (branchType == Branch.ON_EX) {\n+    hasOnExBranch = true;\n+    // Return true and don't check the current node's descendants because any existing data flow must terminate here.\n+    return true;\n+  }\n+}\n+\n+// If the node has no branches to exit the CFG, then all control flow paths must converge at some point.\n+if (!hasOnExBranch) {\n+  return !hasUnconditionalBranch;\n+}\n+\n+return false;\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}