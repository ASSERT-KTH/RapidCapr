{
    "patch": "public class GammaFunction {\n\n    public static double regularizedGammaP(double a, double x) {\n        if (Double.isNaN(a) || Double.isNaN(x)) {\n            return Double.NaN;\n        }\n\n        if ((a <= 0.0) || (x < 0.0)) {\n            return Double.NaN;\n        }\n\n        if (x == 0.0) {\n            return 0.0;\n        }\n\n        if (x >= a + 1.0) {\n            return 1.0 - regularizedGammaQ(a, x);\n        }\n\n        double r = a;\n        double c = 1.0;\n        double ans = 1.0;\n\n        while (true) {\n            double g = c * x / r;\n            ans *= 1.0 + g;\n            if (Math.abs(g) < Double.MIN_VALUE) {\n                break;\n            }\n            r += 1.0;\n            c = g / (r - a);\n        }\n\n        return Math.exp(-x + a * Math.log(x) - logGamma(a)) * ans / a;\n    }\n\n    public static double regularizedGammaQ(final double a, double x) {\n        /* This function was derived by rewriting a continued fraction\n           representation and expanding the numerator in the last term of\n           the continued fraction using the equality (a+b)(a-b) = a^2 - b^2\n           The argument x is assumed to be positive and the check for x==0 is\n           made in regularizedGammaP. */\n        if (Double.isNaN(a) || Double.isNaN(x)) {\n            return Double.NaN;\n        }\n\n        if ((a <= 0.0) || (x < 0.0)) {\n            return Double.NaN;\n        }\n\n        if (x == 0.0) {\n            return 1.0;\n        }\n\n        if (x < a + 1.0) {\n            return 1.0 - regularizedGammaP(a, x);\n        }\n\n        final double b0 = 0.0;\n        final double b1 = 1.0;\n        double p0 = 1.0;\n        double p1 = x;\n        double q0 = 0.0;\n        double q1 = 1.0;\n        double ans = b1 * p1;\n\n        /* continued fraction */\n        double a1 = x;\n        double a2 = x + 1.0 - a;\n        double t2 = b1;\n        double t = 0.0;\n        double n = 1.0;\n        double relativeErrorBound = 10e-15;\n        boolean cont = true;\n        while (cont) {\n            /* computes a continued fraction term, avoids overflows/underflows */\n            double a3 = n * (a - n);\n            a1 = (a2 + a1 * a3) / t2;\n            a2 = n * (x + n - a);\n            t = a1 * t2 + t * a2;\n            a3 = t2 + a1 * a2;\n            t2 = a3;\n            if (t > 0) {\n                t = relativeErrorBound * Math.floor(t / relativeErrorBound + 0.5);\n            } else {\n                t = relativeErrorBound * Math.ceil(t / relativeErrorBound - 0.5);\n            }\n            ans = t * ans;\n            /* checks within relative tolerance if the continued fraction can be stopped */\n            if (Math.abs(t / ans) < relativeErrorBound) {\n                cont = false;\n            }\n            ++n;\n        }\n\n        return 1.0 - ans * Math.exp(-x + a * Math.log(x) - logGamma(a));\n    }\n\n\n    public static double logGamma(double x) {\n        double ret = Double.NaN;\n        double tmp;\n        double ser;\n        double[] cof = new double[]{76.18009172947146, -86.50532032941677, 24.01409824083091,\n                -1.231739572450155, 0.1208650973866179E-2, -0.5395239384953E-5};\n        if (Double.isNaN(x)) {\n            return ret;\n        }\n        if (x <= 0.0) {\n            return ret;\n        }\n        ret = (tmp = x + 5.5) - (x + 0.5) * Math.log(tmp);\n        ser = 1.000000000190015;\n        for (int j = 0; j <= 5; ++j) {\n            ser += cof[j] / ++x;\n        }\n        return -ret + Math.log(2.5066282746310005 * ser / tmp);\n    }\n\n}\n",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..0ccb1776e 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,127 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public class GammaFunction {\n+\n+    public static double regularizedGammaP(double a, double x) {\n+        if (Double.isNaN(a) || Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+\n+        if ((a <= 0.0) || (x < 0.0)) {\n+            return Double.NaN;\n+        }\n+\n+        if (x == 0.0) {\n+            return 0.0;\n+        }\n+\n+        if (x >= a + 1.0) {\n+            return 1.0 - regularizedGammaQ(a, x);\n+        }\n+\n+        double r = a;\n+        double c = 1.0;\n+        double ans = 1.0;\n+\n+        while (true) {\n+            double g = c * x / r;\n+            ans *= 1.0 + g;\n+            if (Math.abs(g) < Double.MIN_VALUE) {\n+                break;\n+            }\n+            r += 1.0;\n+            c = g / (r - a);\n+        }\n+\n+        return Math.exp(-x + a * Math.log(x) - logGamma(a)) * ans / a;\n+    }\n+\n+    public static double regularizedGammaQ(final double a, double x) {\n+        /* This function was derived by rewriting a continued fraction\n+           representation and expanding the numerator in the last term of\n+           the continued fraction using the equality (a+b)(a-b) = a^2 - b^2\n+           The argument x is assumed to be positive and the check for x==0 is\n+           made in regularizedGammaP. */\n+        if (Double.isNaN(a) || Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+\n+        if ((a <= 0.0) || (x < 0.0)) {\n+            return Double.NaN;\n+        }\n+\n+        if (x == 0.0) {\n+            return 1.0;\n+        }\n+\n+        if (x < a + 1.0) {\n+            return 1.0 - regularizedGammaP(a, x);\n+        }\n+\n+        final double b0 = 0.0;\n+        final double b1 = 1.0;\n+        double p0 = 1.0;\n+        double p1 = x;\n+        double q0 = 0.0;\n+        double q1 = 1.0;\n+        double ans = b1 * p1;\n+\n+        /* continued fraction */\n+        double a1 = x;\n+        double a2 = x + 1.0 - a;\n+        double t2 = b1;\n+        double t = 0.0;\n+        double n = 1.0;\n+        double relativeErrorBound = 10e-15;\n+        boolean cont = true;\n+        while (cont) {\n+            /* computes a continued fraction term, avoids overflows/underflows */\n+            double a3 = n * (a - n);\n+            a1 = (a2 + a1 * a3) / t2;\n+            a2 = n * (x + n - a);\n+            t = a1 * t2 + t * a2;\n+            a3 = t2 + a1 * a2;\n+            t2 = a3;\n+            if (t > 0) {\n+                t = relativeErrorBound * Math.floor(t / relativeErrorBound + 0.5);\n+            } else {\n+                t = relativeErrorBound * Math.ceil(t / relativeErrorBound - 0.5);\n+            }\n+            ans = t * ans;\n+            /* checks within relative tolerance if the continued fraction can be stopped */\n+            if (Math.abs(t / ans) < relativeErrorBound) {\n+                cont = false;\n+            }\n+            ++n;\n+        }\n+\n+        return 1.0 - ans * Math.exp(-x + a * Math.log(x) - logGamma(a));\n+    }\n+\n+\n+    public static double logGamma(double x) {\n+        double ret = Double.NaN;\n+        double tmp;\n+        double ser;\n+        double[] cof = new double[]{76.18009172947146, -86.50532032941677, 24.01409824083091,\n+                -1.231739572450155, 0.1208650973866179E-2, -0.5395239384953E-5};\n+        if (Double.isNaN(x)) {\n+            return ret;\n+        }\n+        if (x <= 0.0) {\n+            return ret;\n+        }\n+        ret = (tmp = x + 5.5) - (x + 0.5) * Math.log(tmp);\n+        ser = 1.000000000190015;\n+        for (int j = 0; j <= 5; ++j) {\n+            ser += cof[j] / ++x;\n+        }\n+        return -ret + Math.log(2.5066282746310005 * ser / tmp);\n+    }\n+\n+}\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}