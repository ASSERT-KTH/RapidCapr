{
    "patch": "        // Avoid folding event handlers\n        if (isEventHandler(maybeExpr)) {\n          return false;\n        }\n\n        // Fold expressions that aren't assignments, object literals, etc.\n        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n          Node expr = maybeExpr.getFirstChild();\n          return isFoldableExpression(expr);\n        }\n\n        return NodeUtil.isExpressionNode(maybeExpr);\n      }\n    }\n\n    return false;\n  }\n  \n  private boolean isFoldableExpression(Node n) {\n    // Recurse over expressions until we find either a name or a primitive.\n    switch (n.getType()) {\n      case Token.ADD:\n      case Token.BITAND:\n      case Token.BITOR:\n      case Token.BITXOR:\n      case Token.CA:\n      case Token.COMMA:\n      case Token.DELPROP:\n      case Token.DIV:\n      case Token.EQ:\n      case Token.FUNCTION:\n      case Token.GE:\n      case Token.GETPROP:\n      case Token.GT:\n      case Token.HOOK:\n      case Token.INSTANCEOF:\n      case Token.IN:\n      case Token.LE:\n      case Token.LSH:\n      case Token.LT:\n      case Token.MOD:\n      case Token.MUL:\n      case Token.NAME:\n      case Token.NE:\n      case Token.NEG:\n      case Token.NEW:\n      case Token.NOT:\n      case Token.NULL:\n      case Token.NUMBER:\n      case Token.OR:\n      case Token.POS:\n      case Token.REGEXP:\n      case Token.RSH:\n      case Token.STRING:\n      case Token.SUB:\n      case Token.THIS:\n      case Token.TRUE:\n      case Token.TYPEOF:\n      case Token.URSH:\n      case Token.VOID:\n        return true;\n\n      case Token.AND:\n      case Token.DEC:\n      case Token.INC:\n      case Token.OROR:\n      case Token.NOT_EQ:\n      case Token.EQ_EQ:\n      case Token.SHEQ:\n      case Token.SHNE:\n        return isFoldableExpression(n.getFirstChild())\n            && isFoldableExpression(n.getLastChild())\n            && !n.isAssign();\n\n      case Token.ARRAYLIT:\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n          if (!isFoldableExpression(child)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.CALL:\n        // Avoid folding certain expressions\n        if (isEventHandler(n)) {\n          return false;\n        }\n\n        // If this is a call to a built-in constructor, we can fold it.\n        return n.getFirstChild().getType() == Token.NAME\n            && isBuiltinConstructor(n.getFirstChild().getString())\n            && isFoldableExpression(n.getLastChild());\n\n      case Token.OBJECTLIT:\n        for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n          Node value = key.getFirstChild();\n          if (!isFoldableExpression(value)) {\n            return false;\n          }\n        }\n        return true;\n\n      case Token.ASSIGN:\n        if (n.getFirstChild().getType() != Token.NAME) {\n          return false;\n        }\n        return isFoldableExpression(n.getLastChild());\n\n      case Token.PARAM_LIST:\n      case Token.SCRIPT:\n      case Token.BLOCK:\n        // An expression should never be a list or a script or a block,\n        // so if we get here, the expression is not foldable.\n        return false;\n\n      default:\n        throw new IllegalStateException(\"Unsupported node type: \" + n + \"\\n\"\n            + \"Node type: \" + n.getType() + \"\\n\"\n            + \"Node value: \" + n.getString() + \"\\n\"\n            + \"Node children: \" + n.hasChildren());\n    }\n  }\n\n  private boolean isEventHandler(Node n) {\n    if (n.getLastChild() == null) {\n      return false;\n    }\n    if (n.getLastChild().getType() != Token.STRING) {\n      return false;\n    }\n    if (!n.getLastChild().getString().equals(\"handler\")) {\n      return false;\n    }\n    String name = NodeUtil.getNearestAncestorOfType(n, Token.FUNCTION).getFirstChild().getString();\n    return name != null && name.startsWith(\"on\");\n  }\n\n  private boolean isBuiltinConstructor(String name) {\n    return \"Array\".equals(name)\n        || \"Boolean\".equals(name)\n        || \"Date\".equals(name)\n        || \"Error\".equals(name)\n        || \"Function\".equals(name)\n        || \"Math\".equals(name)\n        || \"Number\".equals(name)\n        || \"Object\".equals(name)\n        || \"RegExp\".equals(name)\n        || \"String\".equals(name)\n        || \"XML\".equals(name)\n        || \"XMLList\".equals(name);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..c62b1867 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,26 +516,156 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+        // Avoid folding event handlers\n+        if (isEventHandler(maybeExpr)) {\n+          return false;\n+        }\n+\n+        // Fold expressions that aren't assignments, object literals, etc.\n+        if (maybeExpr.getType() == Token.EXPR_RESULT) {\n+          Node expr = maybeExpr.getFirstChild();\n+          return isFoldableExpression(expr);\n+        }\n+\n+        return NodeUtil.isExpressionNode(maybeExpr);\n       }\n     }\n \n     return false;\n   }\n+  \n+  private boolean isFoldableExpression(Node n) {\n+    // Recurse over expressions until we find either a name or a primitive.\n+    switch (n.getType()) {\n+      case Token.ADD:\n+      case Token.BITAND:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+      case Token.CA:\n+      case Token.COMMA:\n+      case Token.DELPROP:\n+      case Token.DIV:\n+      case Token.EQ:\n+      case Token.FUNCTION:\n+      case Token.GE:\n+      case Token.GETPROP:\n+      case Token.GT:\n+      case Token.HOOK:\n+      case Token.INSTANCEOF:\n+      case Token.IN:\n+      case Token.LE:\n+      case Token.LSH:\n+      case Token.LT:\n+      case Token.MOD:\n+      case Token.MUL:\n+      case Token.NAME:\n+      case Token.NE:\n+      case Token.NEG:\n+      case Token.NEW:\n+      case Token.NOT:\n+      case Token.NULL:\n+      case Token.NUMBER:\n+      case Token.OR:\n+      case Token.POS:\n+      case Token.REGEXP:\n+      case Token.RSH:\n+      case Token.STRING:\n+      case Token.SUB:\n+      case Token.THIS:\n+      case Token.TRUE:\n+      case Token.TYPEOF:\n+      case Token.URSH:\n+      case Token.VOID:\n+        return true;\n+\n+      case Token.AND:\n+      case Token.DEC:\n+      case Token.INC:\n+      case Token.OROR:\n+      case Token.NOT_EQ:\n+      case Token.EQ_EQ:\n+      case Token.SHEQ:\n+      case Token.SHNE:\n+        return isFoldableExpression(n.getFirstChild())\n+            && isFoldableExpression(n.getLastChild())\n+            && !n.isAssign();\n+\n+      case Token.ARRAYLIT:\n+        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+          if (!isFoldableExpression(child)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+\n+      case Token.CALL:\n+        // Avoid folding certain expressions\n+        if (isEventHandler(n)) {\n+          return false;\n+        }\n+\n+        // If this is a call to a built-in constructor, we can fold it.\n+        return n.getFirstChild().getType() == Token.NAME\n+            && isBuiltinConstructor(n.getFirstChild().getString())\n+            && isFoldableExpression(n.getLastChild());\n+\n+      case Token.OBJECTLIT:\n+        for (Node key = n.getFirstChild(); key != null; key = key.getNext()) {\n+          Node value = key.getFirstChild();\n+          if (!isFoldableExpression(value)) {\n+            return false;\n+          }\n+        }\n+        return true;\n+\n+      case Token.ASSIGN:\n+        if (n.getFirstChild().getType() != Token.NAME) {\n+          return false;\n+        }\n+        return isFoldableExpression(n.getLastChild());\n+\n+      case Token.PARAM_LIST:\n+      case Token.SCRIPT:\n+      case Token.BLOCK:\n+        // An expression should never be a list or a script or a block,\n+        // so if we get here, the expression is not foldable.\n+        return false;\n+\n+      default:\n+        throw new IllegalStateException(\"Unsupported node type: \" + n + \"\\n\"\n+            + \"Node type: \" + n.getType() + \"\\n\"\n+            + \"Node value: \" + n.getString() + \"\\n\"\n+            + \"Node children: \" + n.hasChildren());\n+    }\n+  }\n+\n+  private boolean isEventHandler(Node n) {\n+    if (n.getLastChild() == null) {\n+      return false;\n+    }\n+    if (n.getLastChild().getType() != Token.STRING) {\n+      return false;\n+    }\n+    if (!n.getLastChild().getString().equals(\"handler\")) {\n+      return false;\n+    }\n+    String name = NodeUtil.getNearestAncestorOfType(n, Token.FUNCTION).getFirstChild().getString();\n+    return name != null && name.startsWith(\"on\");\n+  }\n+\n+  private boolean isBuiltinConstructor(String name) {\n+    return \"Array\".equals(name)\n+        || \"Boolean\".equals(name)\n+        || \"Date\".equals(name)\n+        || \"Error\".equals(name)\n+        || \"Function\".equals(name)\n+        || \"Math\".equals(name)\n+        || \"Number\".equals(name)\n+        || \"Object\".equals(name)\n+        || \"RegExp\".equals(name)\n+        || \"String\".equals(name)\n+        || \"XML\".equals(name)\n+        || \"XMLList\".equals(name);\n \n   /**\n    * @return The expression node.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}