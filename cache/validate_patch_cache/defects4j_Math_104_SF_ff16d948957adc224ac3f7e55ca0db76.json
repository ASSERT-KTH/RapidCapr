{
    "patch": "public static double regularizedGammaP(double a, double x) {\n    double igammaepsilon = 10e-7;\n    double igammabignumber = 1.0 / igammaepsilon;\n    double igammabignumberinv = 1.0 * igammaepsilon;\n    if (Double.isNaN(a) ||\n            Double.isNaN(x) ||\n            (a <= 0.0) ||\n            (x < 0.0)) {\n        return Double.NaN;\n    } else if (x == Double.POSITIVE_INFINITY) {\n        return 0.0;\n    } else if (x == 0.0) {\n        return 1.0;\n    } else if (a > igammabignumber) {\n\n        // This computation differs from the igamma(a, x) method in that we start\n        // the backward recurrence at j = n - 1 instead of at j = n. The reason is\n        // that the present method is more accurate when a is very large and x is\n        // close to a. The analysis that leads to this conclusion is too lengthy\n        // to reproduce here.\n\n        // x >= 1 && a > big, x ~ a\n        double v = 0.0;\n        double inv = 1.0 / x;\n        double dv = 1.0;\n        double z = x + a;\n        double p = z * inv;\n        double delta = p * RELATIVE_IGAMMA_ERROR;\n        if (delta < 1.0e-33) {\n            delta = 1.0e-33;\n        }\n        delta /= inv;\n        int n = (int) Math.floor(a / 2.0);\n        for (int i = 1; i <= n; i++) {\n            double pm1 = p;\n            double am1 = a - i + 1.0;\n            double denom = am1 * dv + pm1;\n            double aterm = am1 * inv;\n            double pt = p + aterm;\n            if (Math.abs(denom) > 1.0e-6) {\n                dv = pm1 / denom;\n                v += dv;\n                p = pt + v;\n            } else {\n                dv = am1 * inv;\n                v += dv;\n                p = pt + v;\n            }\n            if (p != 0.0) {\n                delta = Math.abs(dv / p) * RELATIVE_IGAMMA_ERROR;\n            }\n            if (delta < 1.0e-33) {\n                delta = 1.0e-33;\n            }\n            delta /= inv;\n            if (i >= 10 && p < delta * z) {\n                break;\n            }\n        }\n        double ga = Math.exp(a * Math.log(z) - z - Gamma.logGamma(a));\n        return (1.0 - ga * p);\n    } else {\n        double sum = 1.0 / a;\n        double term = 1.0 / a;\n        double n = 1.0;\n        while (Math.abs(term) > igammaepsilon * sum) {\n            term *= x / (a + n);\n            sum += term;\n            n += 1.0;\n        }\n        double answer = Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a)) * sum;\n        return answer;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..b242da122 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,80 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x) {\n+    double igammaepsilon = 10e-7;\n+    double igammabignumber = 1.0 / igammaepsilon;\n+    double igammabignumberinv = 1.0 * igammaepsilon;\n+    if (Double.isNaN(a) ||\n+            Double.isNaN(x) ||\n+            (a <= 0.0) ||\n+            (x < 0.0)) {\n+        return Double.NaN;\n+    } else if (x == Double.POSITIVE_INFINITY) {\n+        return 0.0;\n+    } else if (x == 0.0) {\n+        return 1.0;\n+    } else if (a > igammabignumber) {\n+\n+        // This computation differs from the igamma(a, x) method in that we start\n+        // the backward recurrence at j = n - 1 instead of at j = n. The reason is\n+        // that the present method is more accurate when a is very large and x is\n+        // close to a. The analysis that leads to this conclusion is too lengthy\n+        // to reproduce here.\n+\n+        // x >= 1 && a > big, x ~ a\n+        double v = 0.0;\n+        double inv = 1.0 / x;\n+        double dv = 1.0;\n+        double z = x + a;\n+        double p = z * inv;\n+        double delta = p * RELATIVE_IGAMMA_ERROR;\n+        if (delta < 1.0e-33) {\n+            delta = 1.0e-33;\n+        }\n+        delta /= inv;\n+        int n = (int) Math.floor(a / 2.0);\n+        for (int i = 1; i <= n; i++) {\n+            double pm1 = p;\n+            double am1 = a - i + 1.0;\n+            double denom = am1 * dv + pm1;\n+            double aterm = am1 * inv;\n+            double pt = p + aterm;\n+            if (Math.abs(denom) > 1.0e-6) {\n+                dv = pm1 / denom;\n+                v += dv;\n+                p = pt + v;\n+            } else {\n+                dv = am1 * inv;\n+                v += dv;\n+                p = pt + v;\n+            }\n+            if (p != 0.0) {\n+                delta = Math.abs(dv / p) * RELATIVE_IGAMMA_ERROR;\n+            }\n+            if (delta < 1.0e-33) {\n+                delta = 1.0e-33;\n+            }\n+            delta /= inv;\n+            if (i >= 10 && p < delta * z) {\n+                break;\n+            }\n+        }\n+        double ga = Math.exp(a * Math.log(z) - z - Gamma.logGamma(a));\n+        return (1.0 - ga * p);\n+    } else {\n+        double sum = 1.0 / a;\n+        double term = 1.0 / a;\n+        double n = 1.0;\n+        while (Math.abs(term) > igammaepsilon * sum) {\n+            term *= x / (a + n);\n+            sum += term;\n+            n += 1.0;\n+        }\n+        double answer = Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a)) * sum;\n+        return answer;\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}