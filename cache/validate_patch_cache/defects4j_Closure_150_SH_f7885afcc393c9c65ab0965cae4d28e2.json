{
    "patch": "  // Handles variable declarations and function declarations\n  private void handleDeclaration(NodeTraversal t, Node n, Node parent) {\n    Node root = t.getScope().getRootNode();\n    switch (n.getType()) {\n      case Token.VAR:\n      case Token.CONST:\n      case Token.LET:\n        defineVar(n, parent);\n        break;\n      case Token.FUNCTION:\n        if (NodeUtil.isFunctionExpression(n) || (!NodeUtil.isFunctionDeclaration(n) && NodeUtil.isStatement(n))) {\n          // Handle function expressions and later handle function declarations\n          Node enclosingStatement = NodeUtil.getEnclosingStatement(n);\n          // If enclosingStatement is null, n is a nested function and the current scope\n          // is already correct for handling it.\n          if (enclosingStatement != null) {\n            Scope currentScope = t.getScope();\n            Scope enclosingScope = Scope.createScopeNode(enclosingStatement, t.getScope(), t.getCompiler());\n            t.pushScope(enclosingScope);\n            // Traverse enclosing statement before traversing nested functions.\n            traverseNode(enclosingStatement, n, t);\n            t.popScope(); // Reset the scope to original value\n            if (currentScope != t.getScope()) {\n              t.getScope().setEscaped();\n            }\n          }\n          defineFunctionExpression(n, parent, root);\n        } else if (NodeUtil.isFunctionDeclaration(n) && parent == root.getLastChild()\n            && !root.hasChildren()) {\n          defineDeclaredFunction(n, parent);\n        } else {\n          deferredFunctionDeclarations.add(n);\n        }\n        break;\n      case Token.CLASS:\n        defineClass(n);\n        break;\n      default:\n        break;\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..92072bf3 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1448,21 +1448,47 @@ final class TypedScopeCreator implements ScopeCreator {\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n+  // Handles variable declarations and function declarations\n+  private void handleDeclaration(NodeTraversal t, Node n, Node parent) {\n+    Node root = t.getScope().getRootNode();\n+    switch (n.getType()) {\n+      case Token.VAR:\n+      case Token.CONST:\n+      case Token.LET:\n+        defineVar(n, parent);\n+        break;\n+      case Token.FUNCTION:\n+        if (NodeUtil.isFunctionExpression(n) || (!NodeUtil.isFunctionDeclaration(n) && NodeUtil.isStatement(n))) {\n+          // Handle function expressions and later handle function declarations\n+          Node enclosingStatement = NodeUtil.getEnclosingStatement(n);\n+          // If enclosingStatement is null, n is a nested function and the current scope\n+          // is already correct for handling it.\n+          if (enclosingStatement != null) {\n+            Scope currentScope = t.getScope();\n+            Scope enclosingScope = Scope.createScopeNode(enclosingStatement, t.getScope(), t.getCompiler());\n+            t.pushScope(enclosingScope);\n+            // Traverse enclosing statement before traversing nested functions.\n+            traverseNode(enclosingStatement, n, t);\n+            t.popScope(); // Reset the scope to original value\n+            if (currentScope != t.getScope()) {\n+              t.getScope().setEscaped();\n+            }\n           }\n+          defineFunctionExpression(n, parent, root);\n+        } else if (NodeUtil.isFunctionDeclaration(n) && parent == root.getLastChild()\n+            && !root.hasChildren()) {\n           defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+        } else {\n+          deferredFunctionDeclarations.add(n);\n+        }\n+        break;\n+      case Token.CLASS:\n+        defineClass(n);\n+        break;\n+      default:\n+        break;\n+    }\n+  }\n     }\n \n     /** Handle bleeding functions and function parameters. */",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}