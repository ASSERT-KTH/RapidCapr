{
    "patch": "    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // If there is a single argument and it is unused remove it if it is\n      // undefined in the function body.\n      Node lastArg = argList.getLastChild();\n      if (lastArg == null) {\n        return;\n      }\n\n      Var var = fnScope.getVar(lastArg.getString());\n      if (referenced.contains(var)) {\n        return;\n      }\n\n      Node body = function.getLastChild();\n\n      // Don't bother if the argument is used in a nested function, since that\n      // means we can't know if it is globally unused.\n      FindNestedFunctions fn =\n          new FindNestedFunctions(lastArg.getQualifiedName(), null);\n      NodeTraversal.traverse(compiler, body, fn);\n      if (fn.results.size() > 0) {\n        return;\n      }\n\n      // Don't bother if the argument is used in any way other than as a simple\n      // reference in the function body.\n      // For example don't try to remove 'b' if the expression is\n      // a.b += 1, since it is difficult to prove that nothing else will break.\n      Node lastArgRef = NodeUtil.newQName(compiler, lastArg.getString());\n      lastArgRef.setInputId(lastArg.getInputId());\n      boolean simpleReference = true;\n      for (Node sideEffectNode : sideEffectNodes) {\n        if (NodeUtil.isReferenceName(sideEffectNode, lastArg.getString())\n            && !NodeUtil.isExpressionResultUsed(sideEffectNode)) {\n          // Ignore direct assignments and for-in loops; these are simples\n          if (!sideEffectNode.isAssign()\n              && !sideEffectNode.isForIn()) {\n            simpleReference = false;\n            break;\n          }\n          // We can remove the argument if the for-in replaces the sole\n          // reference to the argument instead of a property thereof. This is\n          // semantically identical.\n          else if (sideEffectNode.isForIn()\n                   && NodeUtil.mayEffectMutableState(\n                          sideEffectNode.getLastChild())) {\n            Node itemName = sideEffectNode.getFirstChild();\n            if (NodeUtil.isReferenceName(\n                    itemName.getFirstChild(), lastArg.getString())) {\n              simpleReference = false;\n              break;\n            }\n          }\n        }\n      }\n      if (!simpleReference) {\n        return;\n      }\n\n      Node oldValue = NodeUtil.getRValueOfLValue(lastArgRef);\n      Node newValue = NodeUtil.newUndefinedNode(oldValue);\n\n      for (Node sideEffectNode : sideEffectNodes) {\n        if (NodeUtil.isReferenceName(sideEffectNode, lastArg.getString())\n            && !NodeUtil.isExpressionResultUsed(sideEffectNode)) {\n          // Ignore direct assignments and for-in loops; these are handled\n          // by the below switch\n          if (sideEffectNode.isAssign()\n              || sideEffectNode.isForIn()) {\n            continue;\n          }\n          Preconditions.checkState(\n              sideEffectNode.getParent().getType() == Token.EXPR_RESULT);\n          sideEffectNode.getParent().replaceChild(sideEffectNode, newValue.cloneTree());\n          compiler.reportCodeChange();\n        } else if (sideEffectNode.isAssign()\n                   && NodeUtil.isLValue(sideEffectNode.getFirstChild())\n                   && lastArg.getString().equals(NodeUtil.getName(sideEffectNode.getFirstChild()))) {\n          Node parent = sideEffectNode.getParent();\n\n          switch (parent.getType()) {\n            case Token.EXPR_RESULT:\n              parent.removeChild(sideEffectNode);\n              break;\n\n            case Token.COMMA:\n              if (parent.getFirstChild() == sideEffectNode) {\n                parent.replaceChild(sideEffectNode, newValue.cloneTree());\n                break;\n              }\n              Node previous = sideEffectNode.getPrevious();\n              Preconditions.checkState(previous.getType() == Token.COMMA);\n              previous.detach();\n              parent.replaceChild(sideEffectNode, newValue.cloneTree());\n\n              // Remove the whole expression if sideEffectNode is the last of\n              // a comma expression list\n              while (parent.getLastChild().isEmpty()) {\n                parent.removeChild(parent.getLastChild());\n              }\n              if (parent.getChildCount() == 1) {\n                parent.getParent().replaceChild(parent, parent.getFirstChild());\n              }\n              break;\n\n            case Token.RETURN:\n              Preconditions.checkState(\n                  sideEffectNode.getParent().getFirstChild() == sideEffectNode);\n              Node undef = NodeUtil.newUndefinedNode(parent);\n              parent.addChildToFront(undef);\n              break;\n\n            default:\n              throw new IllegalStateException(\"Unexpected parent type \"\n                  + parent.getType() + \" of \" + sideEffectNode.toStringTree());\n          }\n          compiler.reportCodeChange();\n        } else if (sideEffectNode.isForIn()\n                   && NodeUtil.mayEffectMutableState(\n                          sideEffectNode.getLastChild())) {\n          Preconditions.checkState(\n              sideEffectNode.getFirstChild().getFirstChild().isName());\n          String variableName =\n              sideEffectNode.getFirstChild().getFirstChild().getString();\n          if (!variableName.equals(lastArg.getString())) {\n            continue;\n          }\n\n          Node itemName = sideEffectNode.getFirstChild();\n          Node obj = sideEffectNode.getSecondChild();\n\n          Preconditions.checkState(itemName.getType() == Token.NAME);\n          Preconditions.checkState(obj.getType() == Token.NAME);\n          Preconditions.checkState(referenced.contains(fnScope.getVar(obj.getString())));\n\n          // Don't mess with the loop variable if it's referenced elsewhere.\n          FindNestedFunctions itemFn =\n              new FindNestedFunctions(lastArg.getQualifiedName(), null);\n          NodeTraversal.traverse(compiler, itemName, itemFn);\n          if (itemFn.results.size() > 1) {\n            continue;\n          }\n\n          Node loopVar = NodeUtil.newVarNode(itemName, lastArgRef.cloneTree().srcref(itemName));\n          Node assign = IR.exprResult(\n              IR.assign(NodeUtil.newQualifiedName(compiler, variableName, lastArg.getString()).srcref(itemName),\n                        lastArgRef.cloneTree().srcref(itemName)).srcref(itemName));\n          sideEffectNode.getParent().replaceChild(sideEffectNode, loopVar);\n          IR.block(sideEffectNode.getParent(), assign).srcref(sideEffectNode);\n          compiler.reportCodeChange();\n        }\n      }\n\n      argList.removeChild(lastArg);\n      compiler.reportCodeChange();\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..a9199c65 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,174 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers = modifyCallSites\n+        && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+      // If there is a single argument and it is unused remove it if it is\n+      // undefined in the function body.\n+      Node lastArg = argList.getLastChild();\n+      if (lastArg == null) {\n+        return;\n+      }\n+\n+      Var var = fnScope.getVar(lastArg.getString());\n+      if (referenced.contains(var)) {\n+        return;\n+      }\n+\n+      Node body = function.getLastChild();\n+\n+      // Don't bother if the argument is used in a nested function, since that\n+      // means we can't know if it is globally unused.\n+      FindNestedFunctions fn =\n+          new FindNestedFunctions(lastArg.getQualifiedName(), null);\n+      NodeTraversal.traverse(compiler, body, fn);\n+      if (fn.results.size() > 0) {\n+        return;\n+      }\n+\n+      // Don't bother if the argument is used in any way other than as a simple\n+      // reference in the function body.\n+      // For example don't try to remove 'b' if the expression is\n+      // a.b += 1, since it is difficult to prove that nothing else will break.\n+      Node lastArgRef = NodeUtil.newQName(compiler, lastArg.getString());\n+      lastArgRef.setInputId(lastArg.getInputId());\n+      boolean simpleReference = true;\n+      for (Node sideEffectNode : sideEffectNodes) {\n+        if (NodeUtil.isReferenceName(sideEffectNode, lastArg.getString())\n+            && !NodeUtil.isExpressionResultUsed(sideEffectNode)) {\n+          // Ignore direct assignments and for-in loops; these are simples\n+          if (!sideEffectNode.isAssign()\n+              && !sideEffectNode.isForIn()) {\n+            simpleReference = false;\n+            break;\n+          }\n+          // We can remove the argument if the for-in replaces the sole\n+          // reference to the argument instead of a property thereof. This is\n+          // semantically identical.\n+          else if (sideEffectNode.isForIn()\n+                   && NodeUtil.mayEffectMutableState(\n+                          sideEffectNode.getLastChild())) {\n+            Node itemName = sideEffectNode.getFirstChild();\n+            if (NodeUtil.isReferenceName(\n+                    itemName.getFirstChild(), lastArg.getString())) {\n+              simpleReference = false;\n+              break;\n+            }\n+          }\n+        }\n+      }\n+      if (!simpleReference) {\n+        return;\n+      }\n+\n+      Node oldValue = NodeUtil.getRValueOfLValue(lastArgRef);\n+      Node newValue = NodeUtil.newUndefinedNode(oldValue);\n+\n+      for (Node sideEffectNode : sideEffectNodes) {\n+        if (NodeUtil.isReferenceName(sideEffectNode, lastArg.getString())\n+            && !NodeUtil.isExpressionResultUsed(sideEffectNode)) {\n+          // Ignore direct assignments and for-in loops; these are handled\n+          // by the below switch\n+          if (sideEffectNode.isAssign()\n+              || sideEffectNode.isForIn()) {\n+            continue;\n+          }\n+          Preconditions.checkState(\n+              sideEffectNode.getParent().getType() == Token.EXPR_RESULT);\n+          sideEffectNode.getParent().replaceChild(sideEffectNode, newValue.cloneTree());\n+          compiler.reportCodeChange();\n+        } else if (sideEffectNode.isAssign()\n+                   && NodeUtil.isLValue(sideEffectNode.getFirstChild())\n+                   && lastArg.getString().equals(NodeUtil.getName(sideEffectNode.getFirstChild()))) {\n+          Node parent = sideEffectNode.getParent();\n+\n+          switch (parent.getType()) {\n+            case Token.EXPR_RESULT:\n+              parent.removeChild(sideEffectNode);\n+              break;\n+\n+            case Token.COMMA:\n+              if (parent.getFirstChild() == sideEffectNode) {\n+                parent.replaceChild(sideEffectNode, newValue.cloneTree());\n+                break;\n+              }\n+              Node previous = sideEffectNode.getPrevious();\n+              Preconditions.checkState(previous.getType() == Token.COMMA);\n+              previous.detach();\n+              parent.replaceChild(sideEffectNode, newValue.cloneTree());\n+\n+              // Remove the whole expression if sideEffectNode is the last of\n+              // a comma expression list\n+              while (parent.getLastChild().isEmpty()) {\n+                parent.removeChild(parent.getLastChild());\n+              }\n+              if (parent.getChildCount() == 1) {\n+                parent.getParent().replaceChild(parent, parent.getFirstChild());\n+              }\n+              break;\n+\n+            case Token.RETURN:\n+              Preconditions.checkState(\n+                  sideEffectNode.getParent().getFirstChild() == sideEffectNode);\n+              Node undef = NodeUtil.newUndefinedNode(parent);\n+              parent.addChildToFront(undef);\n+              break;\n+\n+            default:\n+              throw new IllegalStateException(\"Unexpected parent type \"\n+                  + parent.getType() + \" of \" + sideEffectNode.toStringTree());\n+          }\n+          compiler.reportCodeChange();\n+        } else if (sideEffectNode.isForIn()\n+                   && NodeUtil.mayEffectMutableState(\n+                          sideEffectNode.getLastChild())) {\n+          Preconditions.checkState(\n+              sideEffectNode.getFirstChild().getFirstChild().isName());\n+          String variableName =\n+              sideEffectNode.getFirstChild().getFirstChild().getString();\n+          if (!variableName.equals(lastArg.getString())) {\n+            continue;\n+          }\n+\n+          Node itemName = sideEffectNode.getFirstChild();\n+          Node obj = sideEffectNode.getSecondChild();\n+\n+          Preconditions.checkState(itemName.getType() == Token.NAME);\n+          Preconditions.checkState(obj.getType() == Token.NAME);\n+          Preconditions.checkState(referenced.contains(fnScope.getVar(obj.getString())));\n+\n+          // Don't mess with the loop variable if it's referenced elsewhere.\n+          FindNestedFunctions itemFn =\n+              new FindNestedFunctions(lastArg.getQualifiedName(), null);\n+          NodeTraversal.traverse(compiler, itemName, itemFn);\n+          if (itemFn.results.size() > 1) {\n+            continue;\n+          }\n+\n+          Node loopVar = NodeUtil.newVarNode(itemName, lastArgRef.cloneTree().srcref(itemName));\n+          Node assign = IR.exprResult(\n+              IR.assign(NodeUtil.newQualifiedName(compiler, variableName, lastArg.getString()).srcref(itemName),\n+                        lastArgRef.cloneTree().srcref(itemName)).srcref(itemName));\n+          sideEffectNode.getParent().replaceChild(sideEffectNode, loopVar);\n+          IR.block(sideEffectNode.getParent(), assign).srcref(sideEffectNode);\n+          compiler.reportCodeChange();\n+        }\n+      }\n+\n+      argList.removeChild(lastArg);\n+      compiler.reportCodeChange();\n+    } else {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}