{
    "patch": "            while (t < tEnd) {\n                \n                if (handler != null && handler.handleStep(stepInterpolator, last)) {\n                    return;\n                }\n\n                final double previousT = t;\n                final double maxT = FastMath.min(t + h, tEnd);\n                boolean needToIterate = true;\n                \n                while (needToIterate) {\n                    stepInterpolator.reinitialize(stepStart, y, stepSize, scaled, equations);\n                    if (incompleteState) {\n                        // we need to propagate again the initial state\n                        stepInterpolator.setInterpolatedTime(t0);\n                        System.arraycopy(stepInterpolator.getInterpolatedState(), 0, y, 0, y0.length);\n                        Arrays.fill(yDot, 0.0);\n                        equations.computeDerivatives(t0, y, yDot);\n                        hasInterpolated = false;\n                    } else if (!hasInterpolated) {\n                        // initialize high order scaled derivatives\n                        computeHighOrderDerivatives(stepSize);\n                        hasInterpolated = initializeScheme(stepSize, y, yDot, scale, scaled);\n                    }\n                    interpolator.storeTime(t);\n                    for (final StepInterpolator subStepInterpolator : highOrder) {\n                        subStepInterpolator.storeTime(t);\n                    }\n                    while (t < maxT) {\n                        final double[] eventStep = null;\n                        final double[] eventState = null;\n                        final double eventTime = resetOccurredEvent(t, y, yDot, eventStep, eventState);\n                        if (eventTime <= maxT) {\n                            // we need to add the event to the events states, since it\n                            // was either triggered during the last step or during\n                            // the initialization steps\n                            eventsStates.add(new EventState(eventState, eventTime, eventsHandlers[eventStep == null ? 0 : eventStep[0]]));\n                            if (isLastStep(eventTime)) {\n                                last = true;\n                                resetOccurredEvent(eventStep, eventState, y, yDot);\n                                System.arraycopy(eventState, 0, y, 0, y.length);\n                                stepStart = eventTime;\n                                isIncomplete = equations.isTimeInvariant();\n                                return;\n                            }\n                        }\n                        do{\n                            needToIterate = acceptStep(t, y, yDot, targetY);\n                            if (needToIterate) {\n                                final double prevStep = stepSize;\n                                final double scaleFactor = computeStepGrowShrinkFactor(error, maxError);\n                                stepSize = filterStep(prevStep * scaleFactor);\n                                final double nextT = t + stepSize;\n                                interpolator.setSoftPreviousTime(previousT);\n                                interpolator.setSoftCurrentTime(t);\n                                interpolator.setInterpolatedTime(nextT);\n                                Arrays.fill(yDot, 0.0);\n                                equations.computeDerivatives(nextT, targetY, yDot);\n                            }\n                        } while (needToIterate);\n                    }\n                }\n            }\n\n            isLast = true;\n\n            resetOccurredEvent(null, null, y, yDot);\n\n            if (handler != null) {\n                handler.finish(t, y);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..c45b40d79 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,76 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n+            while (t < tEnd) {\n+                \n+                if (handler != null && handler.handleStep(stepInterpolator, last)) {\n+                    return;\n                 }\n \n-            });\n-\n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n+                final double previousT = t;\n+                final double maxT = FastMath.min(t + h, tEnd);\n+                boolean needToIterate = true;\n+                \n+                while (needToIterate) {\n+                    stepInterpolator.reinitialize(stepStart, y, stepSize, scaled, equations);\n+                    if (incompleteState) {\n+                        // we need to propagate again the initial state\n+                        stepInterpolator.setInterpolatedTime(t0);\n+                        System.arraycopy(stepInterpolator.getInterpolatedState(), 0, y, 0, y0.length);\n+                        Arrays.fill(yDot, 0.0);\n+                        equations.computeDerivatives(t0, y, yDot);\n+                        hasInterpolated = false;\n+                    } else if (!hasInterpolated) {\n+                        // initialize high order scaled derivatives\n+                        computeHighOrderDerivatives(stepSize);\n+                        hasInterpolated = initializeScheme(stepSize, y, yDot, scale, scaled);\n+                    }\n+                    interpolator.storeTime(t);\n+                    for (final StepInterpolator subStepInterpolator : highOrder) {\n+                        subStepInterpolator.storeTime(t);\n+                    }\n+                    while (t < maxT) {\n+                        final double[] eventStep = null;\n+                        final double[] eventState = null;\n+                        final double eventTime = resetOccurredEvent(t, y, yDot, eventStep, eventState);\n+                        if (eventTime <= maxT) {\n+                            // we need to add the event to the events states, since it\n+                            // was either triggered during the last step or during\n+                            // the initialization steps\n+                            eventsStates.add(new EventState(eventState, eventTime, eventsHandlers[eventStep == null ? 0 : eventStep[0]]));\n+                            if (isLastStep(eventTime)) {\n+                                last = true;\n+                                resetOccurredEvent(eventStep, eventState, y, yDot);\n+                                System.arraycopy(eventState, 0, y, 0, y.length);\n+                                stepStart = eventTime;\n+                                isIncomplete = equations.isTimeInvariant();\n+                                return;\n+                            }\n+                        }\n+                        do{\n+                            needToIterate = acceptStep(t, y, yDot, targetY);\n+                            if (needToIterate) {\n+                                final double prevStep = stepSize;\n+                                final double scaleFactor = computeStepGrowShrinkFactor(error, maxError);\n+                                stepSize = filterStep(prevStep * scaleFactor);\n+                                final double nextT = t + stepSize;\n+                                interpolator.setSoftPreviousTime(previousT);\n+                                interpolator.setSoftCurrentTime(t);\n+                                interpolator.setInterpolatedTime(nextT);\n+                                Arrays.fill(yDot, 0.0);\n+                                equations.computeDerivatives(nextT, targetY, yDot);\n+                            }\n+                        } while (needToIterate);\n+                    }\n                 }\n             }\n \n-            while (!occuringEvents.isEmpty()) {\n-\n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n-\n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+            isLast = true;\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+            resetOccurredEvent(null, null, y, yDot);\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n+            if (handler != null) {\n+                handler.finish(t, y);\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}