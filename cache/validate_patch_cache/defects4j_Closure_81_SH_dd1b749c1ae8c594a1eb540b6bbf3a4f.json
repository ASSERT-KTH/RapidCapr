{
    "patch": "      Name name = functionNode.getFunctionName();\n      if (name == null) {\n        name = new Name(\"\");\n      }\n      boolean hasBlockBody = functionNode.getBody() instanceof Block;\n      Node node = newNode(Token.FUNCTION);\n\n      node.addChildToBack(transform(name));\n\n      List<AstNode> params = functionNode.getParams();\n      if (!hasBlockBody) {\n        // If the body isn't a block, and the only statement is a return, we can\n        // use the \"resultExpression\" as the final expression of the function.\n        if (functionNode.getBody() instanceof ReturnStatement) {\n          ReturnStatement ret = (ReturnStatement) functionNode.getBody();\n          if (ret.getReturnValue() == null) {\n            // Empty return, just transform {}.\n            node.addChildToBack(\n                newNode(Token.BLOCK, transformBlock(new Block())), // {}\n                // null default, used if the function is terminated with\n                // a semicolon.\n                null);\n            return node;\n          }\n          node.addChildToBack(\n              newNode(\n                  Token.RETURN,\n                  transform(ret.getReturnValue())),\n              null);\n          return node;\n        }\n        params.addAll(0, functionNode.getFunctionParams());\n      }\n\n      Node paramNode = newNode(Token.LP);\n      if (functionNode.getLineno() != -1) {\n        paramNode.setLineno(functionNode.getLineno());\n      }\n      for (AstNode param : params) {\n        paramNode.addChildToBack(transform(param));\n      }\n      node.addChildToBack(paramNode);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n\n      node.addChildToBack(null); // Original comment said this is \"default case\". Good enough.",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..f66a39d4 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,6 +514,54 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+      Name name = functionNode.getFunctionName();\n+      if (name == null) {\n+        name = new Name(\"\");\n+      }\n+      boolean hasBlockBody = functionNode.getBody() instanceof Block;\n+      Node node = newNode(Token.FUNCTION);\n+\n+      node.addChildToBack(transform(name));\n+\n+      List<AstNode> params = functionNode.getParams();\n+      if (!hasBlockBody) {\n+        // If the body isn't a block, and the only statement is a return, we can\n+        // use the \"resultExpression\" as the final expression of the function.\n+        if (functionNode.getBody() instanceof ReturnStatement) {\n+          ReturnStatement ret = (ReturnStatement) functionNode.getBody();\n+          if (ret.getReturnValue() == null) {\n+            // Empty return, just transform {}.\n+            node.addChildToBack(\n+                newNode(Token.BLOCK, transformBlock(new Block())), // {}\n+                // null default, used if the function is terminated with\n+                // a semicolon.\n+                null);\n+            return node;\n+          }\n+          node.addChildToBack(\n+              newNode(\n+                  Token.RETURN,\n+                  transform(ret.getReturnValue())),\n+              null);\n+          return node;\n+        }\n+        params.addAll(0, functionNode.getFunctionParams());\n+      }\n+\n+      Node paramNode = newNode(Token.LP);\n+      if (functionNode.getLineno() != -1) {\n+        paramNode.setLineno(functionNode.getLineno());\n+      }\n+      for (AstNode param : params) {\n+        paramNode.addChildToBack(transform(param));\n+      }\n+      node.addChildToBack(paramNode);\n+\n+      Node bodyNode = transform(functionNode.getBody());\n+      parseDirectives(bodyNode);\n+      node.addChildToBack(bodyNode);\n+\n+      node.addChildToBack(null); // Original comment said this is \"default case\". Good enough.\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;",
    "result_reason": "error: variable name is already defined in method processFunctionNode(FunctionNode)",
    "test_result": "ERROR"
}