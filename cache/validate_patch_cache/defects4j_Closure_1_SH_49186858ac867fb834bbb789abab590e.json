{
    "patch": "    // Remove params that do not exist or have no effect for the function.\n    Node function = fnScope.getRootNode();\n    Preconditions.checkState(function.isFunction());\n    Node functionBody = function.getLastChild();\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      while (argList.hasChildren()) {\n        Node argNode = argList.getFirstChild();\n        String argName = argNode.getString();\n        Var var = fnScope.getVar(argName);\n        argList.removeChild(argNode); // assume that we will remove it\n        if (referenced.contains(var)) {\n          NodeUtil.visitPostOrder(functionBody, \n              new ParamReferenceMarker(var, argName, functionScope));\n          if (!var.isParamOrCatch()) {\n            compiler.reportCodeChange();\n          }\n          \n          // Add the existing params and reset the function arg list.\n          argList.addChildToBack(argNode);\n          for (Var v : fnScope.getVars()) {\n            if (v.isParam() && !v.isParamOrCatch()) {\n              Node adding = new Node(Token.NAME, v.getName());\n              argList.addChildToBack(adding);\n            }\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..8288bcaf 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,34 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    // Remove params that do not exist or have no effect for the function.\n+    Node function = fnScope.getRootNode();\n+    Preconditions.checkState(function.isFunction());\n+    Node functionBody = function.getLastChild();\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers = modifyCallSites\n+        && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+      while (argList.hasChildren()) {\n+        Node argNode = argList.getFirstChild();\n+        String argName = argNode.getString();\n+        Var var = fnScope.getVar(argName);\n+        argList.removeChild(argNode); // assume that we will remove it\n+        if (referenced.contains(var)) {\n+          NodeUtil.visitPostOrder(functionBody, \n+              new ParamReferenceMarker(var, argName, functionScope));\n+          if (!var.isParamOrCatch()) {\n+            compiler.reportCodeChange();\n+          }\n+          \n+          // Add the existing params and reset the function arg list.\n+          argList.addChildToBack(argNode);\n+          for (Var v : fnScope.getVars()) {\n+            if (v.isParam() && !v.isParamOrCatch()) {\n+              Node adding = new Node(Token.NAME, v.getName());\n+              argList.addChildToBack(adding);\n+            }\n+          }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}