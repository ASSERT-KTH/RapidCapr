{
    "patch": "          if (value.isGetterDef()) {\n            Node getterFunc = value.getFirstChild();\n            Node callParent = callNode.getParent();\n\n            if (isNestedFunction(getterFunc)) {\n              return false;\n            }\n\n            if (callParent.isCall()\n                && callParent.getFirstChild().isGetProp()\n                && callParent.getFirstChild().getLastChild().getString().startsWith(\"get\")\n                && !callParent.getParent().isAssign()) {\n              // Inlining a getter call site with loose function scoping,\n              // i.e. (function(){return {get a(){}}})().a\n              if (callParent.getGrandparent() == null) {\n                return false;\n              }\n              // a little extra safety to avoid adding too many edge cases\n              Node current = callParent.getGrandparent();\n              while (current != null\n                  && !current.isFunction()\n                  && !current.getParent().isFunction()) {\n                current = current.getParent();\n              }\n              if (current == null\n                  || (current.getParent().isFunction() && current.getParent().getParent() == getterFunc)) {\n                return false;\n              }\n            }\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..a923bc19 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,36 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+          if (value.isGetterDef()) {\n+            Node getterFunc = value.getFirstChild();\n+            Node callParent = callNode.getParent();\n+\n+            if (isNestedFunction(getterFunc)) {\n+              return false;\n+            }\n+\n+            if (callParent.isCall()\n+                && callParent.getFirstChild().isGetProp()\n+                && callParent.getFirstChild().getLastChild().getString().startsWith(\"get\")\n+                && !callParent.getParent().isAssign()) {\n+              // Inlining a getter call site with loose function scoping,\n+              // i.e. (function(){return {get a(){}}})().a\n+              if (callParent.getGrandparent() == null) {\n+                return false;\n+              }\n+              // a little extra safety to avoid adding too many edge cases\n+              Node current = callParent.getGrandparent();\n+              while (current != null\n+                  && !current.isFunction()\n+                  && !current.getParent().isFunction()) {\n+                current = current.getParent();\n+              }\n+              if (current == null\n+                  || (current.getParent().isFunction() && current.getParent().getParent() == getterFunc)) {\n+                return false;\n+              }\n+            }\n+          }\n         }\n       }\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}