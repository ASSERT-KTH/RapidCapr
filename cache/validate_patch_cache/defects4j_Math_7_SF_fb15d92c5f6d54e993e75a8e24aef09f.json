{
    "patch": "public int compare(EventState es0, EventState es1) {\n    return Double.compare(es0.getEventTime(), es1.getEventTime());\n}\n\npublic void doEvents(T interpolator,\n        final boolean forward) throws MaxCountExceededException, NoBracketingException {\n    final double h = interpolator.getCurrentStepSize();\n    final double[] currentState = interpolator.getInterpolatedState().clone();\n    final double[] tmp = currentState.clone();\n\n    final ArrayList<EventState> occuringEvents = new ArrayList<EventState>();\n    final TreeSet<EventState> queue = new TreeSet<EventState>(new Comparator<EventState>() {\n        public int compare(EventState es0, EventState es1) {\n            return Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n    });\n\n    for (final EventState state : eventsStates) {\n        if (state.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            occuringEvents.add(state);\n        } else if (state.tryAdvance(false)) {\n            // the event time lies in the future, and we know it happens before the next step\n            final double t = state.getTime();\n            if ((t <= (forward ? interpolator.getCurrentTime() + h : interpolator.getCurrentTime()))\n                    && (t >= (forward ? interpolator.getPreviousTime() : interpolator.getCurrentTime() - h))) {\n                // the event really occurs during the current step\n                occuringEvents.add(state);\n            } else {\n                // the event is scheduled further in the future\n                queue.add(state);\n            }\n        } else {\n            // the event cannot occur anymore\n            if (state.isUndefined()) {\n                throw new MaxCountExceededException(state.getMaxCheckInterval());\n            }\n        }\n    }\n\n    // try to handle events, in chronological order\n    try {\n        while (!occuringEvents.isEmpty()) {\n\n            // handle the chronologically first event\n            final Iterator<EventState> iterator = occuringEvents.iterator();\n            final EventState currentEvent = iterator.next();\n            iterator.remove();\n\n            // restrict the interpolator to the first part of the step, up to the event\n            final double eventT = currentEvent.getEventTime();\n            interpolator.setSoftPreviousTime(interpolator.getPreviousTime());\n            interpolator.setSoftCurrentTime(eventT);\n\n            // get state at event time\n            interpolator.setInterpolatedTime(eventT);\n            final double[] eventY = interpolator.getInterpolatedState().clone();\n\n            // advance all event states to current time\n            currentEvent.stepAccepted(eventT, eventY);\n            currentEvent.setConvergence(1.0);\n\n            // handle the first part of the step, up to the event\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, false);\n            }\n\n            // prepare handling of remaining part of the step\n            final double newPreviousT = interpolator.getInterpolatedTime();\n            interpolator.setSoftPreviousTime(eventT);\n            interpolator.setSoftCurrentTime(newPreviousT);\n\n            // handle remaining part of the step\n            if (forward) {\n                interpolator.setInterpolatedTime(interpolator.getInterpolatedTime() + h);\n                interpolator.computeInterpolatedState(true);\n                interpolator.setInterpolatedTime(linkedODE.computeDerivatives(interpolator.getInterpolatedTime(),\n                        interpolator.getInterpolatedState(), tmp));\n                interpolator.reinitializeDerivatives(tmp, currentState, forward);\n            } else {\n                // backward mode\n                interpolator.computeDerivatives(interpolator.getInterpolatedTime(), interpolator.getInterpolatedState(), tmp);\n                interpolator.setInterpolatedTime(interpolator.getInterpolatedTime() - h);\n                interpolator.computeInterpolatedState(true);\n                interpolator.reinitializeDerivatives(tmp, currentState, forward);\n            }\n\n            // check remaining events validity and handle the part of the step without events\n            occuringEvents.clear();\n            final Iterator<EventState> evIter = queue.iterator();\n            while (evIter.hasNext()) {\n\n                final EventState remainingEvent = evIter.next();\n\n                if (remainingEvent.evaluateStep(interpolator)) {\n                    // the event occurs\n                    evIter.remove();\n                    occuringEvents.add(remainingEvent);\n                } else if (!remainingEvent.tryAdvance(false)) {\n                    // the event cannot occur anymore\n                    evIter.remove();\n                }\n            }\n\n            // handle events\n            for (final EventState state : occuringEvents) {\n                // advance all event states to current time (it is the same time for all events)\n                state.stepAccepted(interpolator.getInterpolatedTime(), interpolator.getInterpolatedState().clone());\n                state.setConvergence(1.0);\n            }\n\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, true);\n            }\n\n        }\n    } catch (StopException se) {\n        // the exception was triggered by an event handler\n        throw se;\n    } catch (MaxCountExceededException mcee) {\n        // the exception was triggered by an event handler\n        throw mcee;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..5fe557214 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,130 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n+public int compare(EventState es0, EventState es1) {\n+    return Double.compare(es0.getEventTime(), es1.getEventTime());\n+}\n \n-            });\n+public void doEvents(T interpolator,\n+        final boolean forward) throws MaxCountExceededException, NoBracketingException {\n+    final double h = interpolator.getCurrentStepSize();\n+    final double[] currentState = interpolator.getInterpolatedState().clone();\n+    final double[] tmp = currentState.clone();\n \n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n-                }\n+    final ArrayList<EventState> occuringEvents = new ArrayList<EventState>();\n+    final TreeSet<EventState> queue = new TreeSet<EventState>(new Comparator<EventState>() {\n+        public int compare(EventState es0, EventState es1) {\n+            return Double.compare(es0.getEventTime(), es1.getEventTime());\n+        }\n+    });\n+\n+    for (final EventState state : eventsStates) {\n+        if (state.evaluateStep(interpolator)) {\n+            // the event occurs during the current step\n+            occuringEvents.add(state);\n+        } else if (state.tryAdvance(false)) {\n+            // the event time lies in the future, and we know it happens before the next step\n+            final double t = state.getTime();\n+            if ((t <= (forward ? interpolator.getCurrentTime() + h : interpolator.getCurrentTime()))\n+                    && (t >= (forward ? interpolator.getPreviousTime() : interpolator.getCurrentTime() - h))) {\n+                // the event really occurs during the current step\n+                occuringEvents.add(state);\n+            } else {\n+                // the event is scheduled further in the future\n+                queue.add(state);\n             }\n+        } else {\n+            // the event cannot occur anymore\n+            if (state.isUndefined()) {\n+                throw new MaxCountExceededException(state.getMaxCheckInterval());\n+            }\n+        }\n+    }\n+\n+    // try to handle events, in chronological order\n+    try {\n+        while (!occuringEvents.isEmpty()) {\n+\n+            // handle the chronologically first event\n+            final Iterator<EventState> iterator = occuringEvents.iterator();\n+            final EventState currentEvent = iterator.next();\n+            iterator.remove();\n+\n+            // restrict the interpolator to the first part of the step, up to the event\n+            final double eventT = currentEvent.getEventTime();\n+            interpolator.setSoftPreviousTime(interpolator.getPreviousTime());\n+            interpolator.setSoftCurrentTime(eventT);\n \n-            while (!occuringEvents.isEmpty()) {\n+            // get state at event time\n+            interpolator.setInterpolatedTime(eventT);\n+            final double[] eventY = interpolator.getInterpolatedState().clone();\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+            // advance all event states to current time\n+            currentEvent.stepAccepted(eventT, eventY);\n+            currentEvent.setConvergence(1.0);\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+            // handle the first part of the step, up to the event\n+            for (final StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, false);\n+            }\n+\n+            // prepare handling of remaining part of the step\n+            final double newPreviousT = interpolator.getInterpolatedTime();\n+            interpolator.setSoftPreviousTime(eventT);\n+            interpolator.setSoftCurrentTime(newPreviousT);\n+\n+            // handle remaining part of the step\n+            if (forward) {\n+                interpolator.setInterpolatedTime(interpolator.getInterpolatedTime() + h);\n+                interpolator.computeInterpolatedState(true);\n+                interpolator.setInterpolatedTime(linkedODE.computeDerivatives(interpolator.getInterpolatedTime(),\n+                        interpolator.getInterpolatedState(), tmp));\n+                interpolator.reinitializeDerivatives(tmp, currentState, forward);\n+            } else {\n+                // backward mode\n+                interpolator.computeDerivatives(interpolator.getInterpolatedTime(), interpolator.getInterpolatedState(), tmp);\n+                interpolator.setInterpolatedTime(interpolator.getInterpolatedTime() - h);\n+                interpolator.computeInterpolatedState(true);\n+                interpolator.reinitializeDerivatives(tmp, currentState, forward);\n+            }\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+            // check remaining events validity and handle the part of the step without events\n+            occuringEvents.clear();\n+            final Iterator<EventState> evIter = queue.iterator();\n+            while (evIter.hasNext()) {\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+                final EventState remainingEvent = evIter.next();\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                if (remainingEvent.evaluateStep(interpolator)) {\n+                    // the event occurs\n+                    evIter.remove();\n+                    occuringEvents.add(remainingEvent);\n+                } else if (!remainingEvent.tryAdvance(false)) {\n+                    // the event cannot occur anymore\n+                    evIter.remove();\n                 }\n+            }\n+\n+            // handle events\n+            for (final EventState state : occuringEvents) {\n+                // advance all event states to current time (it is the same time for all events)\n+                state.stepAccepted(interpolator.getInterpolatedTime(), interpolator.getInterpolatedState().clone());\n+                state.setConvergence(1.0);\n+            }\n+\n+            for (final StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, true);\n+            }\n+\n+        }\n+    } catch (StopException se) {\n+        // the exception was triggered by an event handler\n+        throw se;\n+    } catch (MaxCountExceededException mcee) {\n+        // the exception was triggered by an event handler\n+        throw mcee;\n+    }\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}