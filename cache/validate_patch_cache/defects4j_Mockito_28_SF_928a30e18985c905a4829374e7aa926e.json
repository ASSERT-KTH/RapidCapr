{
    "patch": "private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n    List<Field> fields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n    Map<Class<?>, List<Field>> typeToFieldsMap = new HashMap<>();\n    for (Field field : fields) {\n        typeToFieldsMap.computeIfAbsent(field.getType(), k -> new ArrayList<>()).add(field);\n    }\n    for (Class<?> type : typeToFieldsMap.keySet()) {\n        Object mockCandidate = null;\n        for (Object mock : mocks) {\n            if (type.isAssignableFrom(mock.getClass())) {\n                if (mockCandidate == null) {\n                    mockCandidate = mock;\n                } else {\n                    if (type.isAssignableFrom(mockCandidate.getClass())) {\n                        if (hasMoreThanOneMatch(mockCandidate, mock, typeToFieldsMap.get(type))) {\n                            throw new IllegalStateException(\"Multiple mock candidates found for field type \" + type);\n                        }\n                    } else if (!hasMoreThanOneMatch(mock, mockCandidate, typeToFieldsMap.get(type))) {\n                        mockCandidate = mock;\n                    } // else ignore mock\n                }\n            }\n        }\n        if (mockCandidate != null) {\n            for (Field field : typeToFieldsMap.get(type)) {\n                field.setAccessible(true);\n                try {\n                    field.set(fieldInstance, mockCandidate);\n                } catch (IllegalAccessException e) {\n                    throw new RuntimeException(e);\n                }\n            }\n        }\n    }\n}\n\nprivate List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n    List<Field> fields = new ArrayList<>();\n    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n        for (Field field : c.getDeclaredFields()) {\n            if (!Modifier.isStatic(field.getModifiers())) {\n                fields.add(field);\n            }\n        }\n    }\n    return fields;\n}\n\nprivate boolean hasMoreThanOneMatch(Object candidate1, Object candidate2, List<Field> fields) {\n    for (Field field : fields) {\n        try {\n            field.setAccessible(true);\n            Object value1 = field.get(candidate1);\n            Object value2 = field.get(candidate2);\n            if ((value1 == null && value2 == null) || (value1 != null && value1.equals(value2))) {\n                continue;\n            }\n            return true;\n        } catch (IllegalAccessException e) {\n            throw new RuntimeException(e);\n        }\n    }\n    return false;\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\nindex 213ebf351..d06a37d33 100644\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n@@ -88,11 +88,71 @@ public class DefaultInjectionEngine {\n         }\n     }\n \n-    private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n-        for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n-        }\n-    }\n+\n+private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n+    List<Field> fields = orderedInstanceFieldsFrom(awaitingInjectionClazz);\n+    Map<Class<?>, List<Field>> typeToFieldsMap = new HashMap<>();\n+    for (Field field : fields) {\n+        typeToFieldsMap.computeIfAbsent(field.getType(), k -> new ArrayList<>()).add(field);\n+    }\n+    for (Class<?> type : typeToFieldsMap.keySet()) {\n+        Object mockCandidate = null;\n+        for (Object mock : mocks) {\n+            if (type.isAssignableFrom(mock.getClass())) {\n+                if (mockCandidate == null) {\n+                    mockCandidate = mock;\n+                } else {\n+                    if (type.isAssignableFrom(mockCandidate.getClass())) {\n+                        if (hasMoreThanOneMatch(mockCandidate, mock, typeToFieldsMap.get(type))) {\n+                            throw new IllegalStateException(\"Multiple mock candidates found for field type \" + type);\n+                        }\n+                    } else if (!hasMoreThanOneMatch(mock, mockCandidate, typeToFieldsMap.get(type))) {\n+                        mockCandidate = mock;\n+                    } // else ignore mock\n+                }\n+            }\n+        }\n+        if (mockCandidate != null) {\n+            for (Field field : typeToFieldsMap.get(type)) {\n+                field.setAccessible(true);\n+                try {\n+                    field.set(fieldInstance, mockCandidate);\n+                } catch (IllegalAccessException e) {\n+                    throw new RuntimeException(e);\n+                }\n+            }\n+        }\n+    }\n+}\n+\n+private List<Field> orderedInstanceFieldsFrom(Class<?> clazz) {\n+    List<Field> fields = new ArrayList<>();\n+    for (Class<?> c = clazz; c != null; c = c.getSuperclass()) {\n+        for (Field field : c.getDeclaredFields()) {\n+            if (!Modifier.isStatic(field.getModifiers())) {\n+                fields.add(field);\n+            }\n+        }\n+    }\n+    return fields;\n+}\n+\n+private boolean hasMoreThanOneMatch(Object candidate1, Object candidate2, List<Field> fields) {\n+    for (Field field : fields) {\n+        try {\n+            field.setAccessible(true);\n+            Object value1 = field.get(candidate1);\n+            Object value2 = field.get(candidate2);\n+            if ((value1 == null && value2 == null) || (value1 != null && value1.equals(value2))) {\n+                continue;\n+            }\n+            return true;\n+        } catch (IllegalAccessException e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+    return false;\n+}\n \n     private Field[] orderedInstanceFieldsFrom(Class<?> awaitingInjectionClazz) {\n         Field[] declaredFields = awaitingInjectionClazz.getDeclaredFields();",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}