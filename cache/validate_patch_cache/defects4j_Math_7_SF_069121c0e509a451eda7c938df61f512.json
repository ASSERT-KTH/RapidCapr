{
    "patch": "public void doEvents(final double t, final double[] y, final double stepStart, final double stepSize, final RealFieldElement<T>[] fieldY, final RealFieldElement<T> stepStartField, final RealFieldElement<T> stepSizeField, final FieldEquationsMapper<T> mapper, final Collection<EventState> eventsStates, final Collection<EventState> occuringEvents, final boolean[] isLastStep, final FieldODEStateAndDerivative<T> interpolated, final FieldODEStateAndDerivative<T> state, final ODEStateInterpolator<T> interpolator, final Collection<FieldStepHandler<T>> stepHandlers) {\n    if (eventsStates.isEmpty()) {\n        return;\n    }\n\n    // clear the event detectors\n    for (final EventState state : eventsStates) {\n        state.clearOccurrence();\n    }\n\n    // forward and backward tentative state, only one of the 2 arrays is used in each step\n    @SuppressWarnings(\"unchecked\")\n    final\n    FieldODEStateAndDerivative<T>[] yUpAndDown = (FieldODEStateAndDerivative<T>[]) Array.newInstance(FieldODEStateAndDerivative.class, 2);\n    yUpAndDown[0] = state;\n    yUpAndDown[1] = state.copy();\n\n    // initialize the events states\n    for (final EventState state : eventsStates) {\n        state.reinitializeBegin(adjustedTolerances.getField());\n    }\n\n    // iterate over the sub-steps\n    RealFieldElement<T> previousT = stepStartField;\n    for (RealFieldElement<T> dt = previousT.add(maxCheck.step(adjustedTolerances.getSecondary())); dt.getReal() < stepStart + stepSize; dt = dt.add(maxCheck.step(adjustedTolerances.getSecondary()))) {\n        final RealFieldElement<T> stepEnd = (dt.getReal() < stepStart + stepSize) ? dt : stepStartField.add(stepSizeField);\n        final FieldODEStateAndDerivative<T> currentState = yUpAndDown[0];\n        final FieldODEStateAndDerivative<T> previousState = yUpAndDown[1];\n        previousState.copyFrom(currentState);\n        interpolator.storeTime(previousT.getReal());\n\n        // evaluate state at end of the sub-step\n        mapper.setInterpolatedState(stepEnd.subtract(stepStartField), currentState.getCompleteState());\n        for (final EventState state : eventsStates) {\n            state.evaluateStep(mapper);\n        }\n\n        // search for next events occurrence\n        occuringEvents.clear();\n        if (!filter(eventsStates, occuringEvents, previousState, currentState)) {\n            // we lost track of some event, we need to stop\n            System.arraycopy(previousState, 0, state, 0, state.length);\n            return;\n        }\n        defineStepSize(eventsStates, stepEnd, stepSizeField);\n\n        // if some event occurs, we use only the first part of the current sub-step\n        final RealFieldElement<T> nextSubStepStart;\n        final boolean needReset;\n        if (!occuringEvents.isEmpty()) {\n            // sub-step cut short by an event, we need to reset the ODE state\n            final EventState firstEvent = occuringEvents.iterator().next();\n            nextSubStepStart = firstEvent.getEventTime();\n            fillStep(start.getReal(), y, nextSubStepStart.getReal(), fieldY, mapper);\n            needReset = true;\n        } else {\n            // we use the whole sub-step\n            nextSubStepStart = stepEnd;\n            needReset = false;\n        }\n\n        // iterate over the remaining sub-sub-steps\n        boolean stop = false;\n        do {\n\n            // integrate over the current sub-sub-step\n            final RealFieldElement<T> currentT;\n            if ((nextSubStepStart.getReal() - previousT.getReal()) >= errorMin.step(adjustedTolerances.getSecondary())) {\n                final FieldODEStateAndDerivative<T> tmpODEState = stepWithErrorControl(field, mapper, currentState, nextSubStepStart, new RealFieldElement[] { errorMin, errorMax });\n                currentT = tmpODEState.getTime();\n                fillStep(start.getReal(), tmpODEState.getCompleteState(), nextSubStepStart.getReal(), fieldY, mapper);\n                if (stopOnEvent(tmpODEState, eventsStates, occuringEvents, currentState)) {\n                    // we need to stop before end of the sub-step, due to an event\n                    stop = true;\n                    System.arraycopy(tmpODEState, 0, currentState, 0, currentState.length);\n                    break;\n                }\n            } else {\n                currentT = nextSubStepStart;\n            }\n            fillStep(start.getReal(), currentState.getCompleteState(), currentT.getReal(), fieldY, mapper);\n\n            // check convergence\n            RealFieldElement<T> maxError = zero;\n            FieldODEStateAndDerivative<T> previousRestricted = previousState;\n            for (final EventState state : eventsStates) {\n                final int sign = state.getConvergence(direction);\n                if (sign != 0) {\n                    final RealFieldElement<T> eventT = state.getEventTime();\n                    final RealFieldElement<T> convergence = state.getMaximalConvergence();\n                    final FieldODEStateAndDerivative<T> restricted;\n                    if (sign < 0) {\n                        final FieldODEStateAndDerivative<T> tmp = stepWithErrorControl(field, mapper, previousState, eventT, new RealFieldElement[] { convergence, convergence.multiply(10) });\n                        restricted = tmp;\n                        maxError = max(abs(tmp.getState()[0].subtract(currentState.getState()[0])), maxError);\n                    } else {\n                        restricted = previousRestricted;\n                    }\n                    state.reinitializeConvergence(currentState.getTime(), restricted.getCompleteState(), sign, previousRestricted.getCompleteState());\n                    previousRestricted = restricted;\n                }\n            }\n            if (maxError.getReal() < 1.0) {\n                // we have convergence, current step is done\n                previousT  = currentState.getTime();\n                yUpAndDown[0] = currentState;\n                if (needReset) {\n                    // we reset the state back to the end of the last definite sub-step\n                    for (final EventState state : eventsStates) {\n                        state.stepAccepted(previousT.getReal(), y, fieldY);\n                    }\n                }\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, direction, eventsStates, currentState);\n                }\n                break;\n            }\n\n            // no complete convergence on this sub-sub-step, we try to shorten it\n            final RealFieldElement<T> scaled = maxError.divide(10).divide(adjustedTolerances.getSecondary()).power(1.0 / Math.min(order, 4));\n            final RealFieldElement<T> nextT = currentT.subtract(currentState.getTime().getField().getOne().max(scaled)).subtract(currentState.getTime().getField().getUlp().multiply(10));\n            if (nextT.subtract(previousT).getReal() <= 0) {\n                // sub-sub-step already below minimal step size, we cannot improve convergence\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(currentState.getTime().getReal(), y, fieldY);\n                }\n                previousT = currentState.getTime();\n                yUpAndDown[0] = currentState;\n                if (needReset) {\n                    // we reset the state back to the end of the last definite sub-step\n                    for (final EventState state : eventsStates) {\n                        state.stepAccepted(previousT.getReal(), y, fieldY);\n                    }\n                }\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, direction, eventsStates, currentState);\n                }\n                break;\n            }\n            fillStep(start.getReal(), currentState.getCompleteState(), nextT.getReal(), fieldY, mapper);\n\n            // check sanity of the scenario before trying to reduce the step\n            if (!filter(eventsStates, occuringEvents, previousState, currentState)) {\n                // we lost track of some event, we need to stop\n                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n                return;\n            }\n            if (occuringEvents.isEmpty()) {\n                // we cannot step backward before start, as this would mean we would have missed the events\n                final RealFieldElement<T> previousTMinusFourUlp = previousT.subtract(previousT.getField().getUlp().multiply(4));\n                if (previousTMinusFourUlp.subtract(stepStartField).getReal() <= 0) {\n                    throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION, previousTMinusFourUlp.getReal(), stepStartField.subtract(previousT.getField().getUlp().multiply(4)).getReal(), true);\n                }\n                final FieldODEStateAndDerivative<T> tmpState = stepWithErrorControl(field, mapper, previousState, previousTMinusFourUlp, new RealFieldElement[] { errorMin, errorMax });\n                fillStep(start.getReal(), tmpState.getCompleteState(), previousTMinusFourUlp.getReal(), fieldY, mapper);\n                if (!filter(eventsStates, occuringEvents, previousState, previousState)) {\n                    // we lost track of some event, we need to stop\n                    System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n                    return;\n                }\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(previousTMinusFourUlp.getReal(), y, fieldY);\n                }\n                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n                previousT = previousTMinusFourUlp;\n                yUpAndDown[0] = currentState;\n                if (needReset) {\n                    // we reset the state back to the end of the last definite sub-step\n                    for (final EventState state : eventsStates) {\n                        state.reinitializeBegin(adjustedTolerances.getField());\n                    }\n                }\n                break;\n            }\n            final RealFieldElement<T> splitTime = occuringEvents.iterator().next().getEventTime();\n            if (splitTime.subtract(previousT).getReal() <= 0) {\n                // we cannot converge because we missed an event\n                throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION, splitTime.subtract(previousT).getReal(), true);\n            }\n            if (splitTime.subtract(currentState.getTime()).getReal() < zero.getReal()) {\n                // event is already in the past\n                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n                previousT = previousT.max(splitTime);\n                yUpAndDown[0] = currentState;\n                if (needReset) {\n                    // we reset the state back to the end of the last definite sub-step\n                    for (final EventState state : eventsStates) {\n                        state.stepAccepted(previousT.getReal(), y, fieldY);\n                    }\n                }\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, direction, eventsStates, currentState);\n                }\n                break;\n            }\n            final FieldODEStateAndDerivative<T> tmp = stepWithErrorControl(field, mapper, previousState, splitTime, new RealFieldElement[] { errorMin, errorMax });\n            fillStep(start.getReal(), tmp.getCompleteState(), splitTime.getReal(), fieldY, mapper);\n            if (!filter(eventsStates, occuringEvents, previousState, tmp)) {\n                // we lost track of some event, we need to stop\n                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n                return;\n            }\n            System.arraycopy(tmp, 0, currentState, 0, currentState.length);\n            previousT = splitTime;\n            yUpAndDown[0] = currentState;\n            if (needReset) {\n                // we reset the state back to the end of the last definite sub-step\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(previousT.getReal(), y, fieldY);\n                }\n            }\n            needReset = true;\n            for (final StepHandler handler : stepHandlers) {\n                handler.handleStep(interpolator, direction, eventsStates, currentState);\n            }\n\n        } while (!stop);\n\n        if (stop) {\n            // we need to stop before end of the sub-step, due to an event\n            if (!filter(eventsStates, occuringEvents, previousState, currentState)) {\n                // we lost track of some event, we need to stop\n                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n                return;\n            }\n            System.arraycopy(currentState, 0, state, 0, state.length);\n            interpolator.storeTime(currentState.getTime().getReal());\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(currentState.getTime().getReal(), y, fieldY);\n            }\n            return;\n        }\n\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..11da32d4b 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,241 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n+public void doEvents(final double t, final double[] y, final double stepStart, final double stepSize, final RealFieldElement<T>[] fieldY, final RealFieldElement<T> stepStartField, final RealFieldElement<T> stepSizeField, final FieldEquationsMapper<T> mapper, final Collection<EventState> eventsStates, final Collection<EventState> occuringEvents, final boolean[] isLastStep, final FieldODEStateAndDerivative<T> interpolated, final FieldODEStateAndDerivative<T> state, final ODEStateInterpolator<T> interpolator, final Collection<FieldStepHandler<T>> stepHandlers) {\n+    if (eventsStates.isEmpty()) {\n+        return;\n+    }\n \n-            });\n+    // clear the event detectors\n+    for (final EventState state : eventsStates) {\n+        state.clearOccurrence();\n+    }\n \n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n-                }\n-            }\n+    // forward and backward tentative state, only one of the 2 arrays is used in each step\n+    @SuppressWarnings(\"unchecked\")\n+    final\n+    FieldODEStateAndDerivative<T>[] yUpAndDown = (FieldODEStateAndDerivative<T>[]) Array.newInstance(FieldODEStateAndDerivative.class, 2);\n+    yUpAndDown[0] = state;\n+    yUpAndDown[1] = state.copy();\n \n-            while (!occuringEvents.isEmpty()) {\n+    // initialize the events states\n+    for (final EventState state : eventsStates) {\n+        state.reinitializeBegin(adjustedTolerances.getField());\n+    }\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+    // iterate over the sub-steps\n+    RealFieldElement<T> previousT = stepStartField;\n+    for (RealFieldElement<T> dt = previousT.add(maxCheck.step(adjustedTolerances.getSecondary())); dt.getReal() < stepStart + stepSize; dt = dt.add(maxCheck.step(adjustedTolerances.getSecondary()))) {\n+        final RealFieldElement<T> stepEnd = (dt.getReal() < stepStart + stepSize) ? dt : stepStartField.add(stepSizeField);\n+        final FieldODEStateAndDerivative<T> currentState = yUpAndDown[0];\n+        final FieldODEStateAndDerivative<T> previousState = yUpAndDown[1];\n+        previousState.copyFrom(currentState);\n+        interpolator.storeTime(previousT.getReal());\n+\n+        // evaluate state at end of the sub-step\n+        mapper.setInterpolatedState(stepEnd.subtract(stepStartField), currentState.getCompleteState());\n+        for (final EventState state : eventsStates) {\n+            state.evaluateStep(mapper);\n+        }\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+        // search for next events occurrence\n+        occuringEvents.clear();\n+        if (!filter(eventsStates, occuringEvents, previousState, currentState)) {\n+            // we lost track of some event, we need to stop\n+            System.arraycopy(previousState, 0, state, 0, state.length);\n+            return;\n+        }\n+        defineStepSize(eventsStates, stepEnd, stepSizeField);\n+\n+        // if some event occurs, we use only the first part of the current sub-step\n+        final RealFieldElement<T> nextSubStepStart;\n+        final boolean needReset;\n+        if (!occuringEvents.isEmpty()) {\n+            // sub-step cut short by an event, we need to reset the ODE state\n+            final EventState firstEvent = occuringEvents.iterator().next();\n+            nextSubStepStart = firstEvent.getEventTime();\n+            fillStep(start.getReal(), y, nextSubStepStart.getReal(), fieldY, mapper);\n+            needReset = true;\n+        } else {\n+            // we use the whole sub-step\n+            nextSubStepStart = stepEnd;\n+            needReset = false;\n+        }\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+        // iterate over the remaining sub-sub-steps\n+        boolean stop = false;\n+        do {\n+\n+            // integrate over the current sub-sub-step\n+            final RealFieldElement<T> currentT;\n+            if ((nextSubStepStart.getReal() - previousT.getReal()) >= errorMin.step(adjustedTolerances.getSecondary())) {\n+                final FieldODEStateAndDerivative<T> tmpODEState = stepWithErrorControl(field, mapper, currentState, nextSubStepStart, new RealFieldElement[] { errorMin, errorMax });\n+                currentT = tmpODEState.getTime();\n+                fillStep(start.getReal(), tmpODEState.getCompleteState(), nextSubStepStart.getReal(), fieldY, mapper);\n+                if (stopOnEvent(tmpODEState, eventsStates, occuringEvents, currentState)) {\n+                    // we need to stop before end of the sub-step, due to an event\n+                    stop = true;\n+                    System.arraycopy(tmpODEState, 0, currentState, 0, currentState.length);\n+                    break;\n+                }\n+            } else {\n+                currentT = nextSubStepStart;\n+            }\n+            fillStep(start.getReal(), currentState.getCompleteState(), currentT.getReal(), fieldY, mapper);\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+            // check convergence\n+            RealFieldElement<T> maxError = zero;\n+            FieldODEStateAndDerivative<T> previousRestricted = previousState;\n+            for (final EventState state : eventsStates) {\n+                final int sign = state.getConvergence(direction);\n+                if (sign != 0) {\n+                    final RealFieldElement<T> eventT = state.getEventTime();\n+                    final RealFieldElement<T> convergence = state.getMaximalConvergence();\n+                    final FieldODEStateAndDerivative<T> restricted;\n+                    if (sign < 0) {\n+                        final FieldODEStateAndDerivative<T> tmp = stepWithErrorControl(field, mapper, previousState, eventT, new RealFieldElement[] { convergence, convergence.multiply(10) });\n+                        restricted = tmp;\n+                        maxError = max(abs(tmp.getState()[0].subtract(currentState.getState()[0])), maxError);\n+                    } else {\n+                        restricted = previousRestricted;\n+                    }\n+                    state.reinitializeConvergence(currentState.getTime(), restricted.getCompleteState(), sign, previousRestricted.getCompleteState());\n+                    previousRestricted = restricted;\n+                }\n+            }\n+            if (maxError.getReal() < 1.0) {\n+                // we have convergence, current step is done\n+                previousT  = currentState.getTime();\n+                yUpAndDown[0] = currentState;\n+                if (needReset) {\n+                    // we reset the state back to the end of the last definite sub-step\n+                    for (final EventState state : eventsStates) {\n+                        state.stepAccepted(previousT.getReal(), y, fieldY);\n+                    }\n+                }\n+                for (final StepHandler handler : stepHandlers) {\n+                    handler.handleStep(interpolator, direction, eventsStates, currentState);\n+                }\n+                break;\n+            }\n+\n+            // no complete convergence on this sub-sub-step, we try to shorten it\n+            final RealFieldElement<T> scaled = maxError.divide(10).divide(adjustedTolerances.getSecondary()).power(1.0 / Math.min(order, 4));\n+            final RealFieldElement<T> nextT = currentT.subtract(currentState.getTime().getField().getOne().max(scaled)).subtract(currentState.getTime().getField().getUlp().multiply(10));\n+            if (nextT.subtract(previousT).getReal() <= 0) {\n+                // sub-sub-step already below minimal step size, we cannot improve convergence\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(currentState.getTime().getReal(), y, fieldY);\n+                }\n+                previousT = currentState.getTime();\n+                yUpAndDown[0] = currentState;\n+                if (needReset) {\n+                    // we reset the state back to the end of the last definite sub-step\n+                    for (final EventState state : eventsStates) {\n+                        state.stepAccepted(previousT.getReal(), y, fieldY);\n+                    }\n+                }\n+                for (final StepHandler handler : stepHandlers) {\n+                    handler.handleStep(interpolator, direction, eventsStates, currentState);\n+                }\n+                break;\n+            }\n+            fillStep(start.getReal(), currentState.getCompleteState(), nextT.getReal(), fieldY, mapper);\n \n-                // handle the first part of the step, up to the event\n+            // check sanity of the scenario before trying to reduce the step\n+            if (!filter(eventsStates, occuringEvents, previousState, currentState)) {\n+                // we lost track of some event, we need to stop\n+                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n+                return;\n+            }\n+            if (occuringEvents.isEmpty()) {\n+                // we cannot step backward before start, as this would mean we would have missed the events\n+                final RealFieldElement<T> previousTMinusFourUlp = previousT.subtract(previousT.getField().getUlp().multiply(4));\n+                if (previousTMinusFourUlp.subtract(stepStartField).getReal() <= 0) {\n+                    throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION, previousTMinusFourUlp.getReal(), stepStartField.subtract(previousT.getField().getUlp().multiply(4)).getReal(), true);\n+                }\n+                final FieldODEStateAndDerivative<T> tmpState = stepWithErrorControl(field, mapper, previousState, previousTMinusFourUlp, new RealFieldElement[] { errorMin, errorMax });\n+                fillStep(start.getReal(), tmpState.getCompleteState(), previousTMinusFourUlp.getReal(), fieldY, mapper);\n+                if (!filter(eventsStates, occuringEvents, previousState, previousState)) {\n+                    // we lost track of some event, we need to stop\n+                    System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n+                    return;\n+                }\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(previousTMinusFourUlp.getReal(), y, fieldY);\n+                }\n+                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n+                previousT = previousTMinusFourUlp;\n+                yUpAndDown[0] = currentState;\n+                if (needReset) {\n+                    // we reset the state back to the end of the last definite sub-step\n+                    for (final EventState state : eventsStates) {\n+                        state.reinitializeBegin(adjustedTolerances.getField());\n+                    }\n+                }\n+                break;\n+            }\n+            final RealFieldElement<T> splitTime = occuringEvents.iterator().next().getEventTime();\n+            if (splitTime.subtract(previousT).getReal() <= 0) {\n+                // we cannot converge because we missed an event\n+                throw new NumberIsTooSmallException(LocalizedFormats.MINIMAL_STEPSIZE_REACHED_DURING_INTEGRATION, splitTime.subtract(previousT).getReal(), true);\n+            }\n+            if (splitTime.subtract(currentState.getTime()).getReal() < zero.getReal()) {\n+                // event is already in the past\n+                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n+                previousT = previousT.max(splitTime);\n+                yUpAndDown[0] = currentState;\n+                if (needReset) {\n+                    // we reset the state back to the end of the last definite sub-step\n+                    for (final EventState state : eventsStates) {\n+                        state.stepAccepted(previousT.getReal(), y, fieldY);\n+                    }\n+                }\n                 for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                    handler.handleStep(interpolator, direction, eventsStates, currentState);\n                 }\n+                break;\n+            }\n+            final FieldODEStateAndDerivative<T> tmp = stepWithErrorControl(field, mapper, previousState, splitTime, new RealFieldElement[] { errorMin, errorMax });\n+            fillStep(start.getReal(), tmp.getCompleteState(), splitTime.getReal(), fieldY, mapper);\n+            if (!filter(eventsStates, occuringEvents, previousState, tmp)) {\n+                // we lost track of some event, we need to stop\n+                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n+                return;\n+            }\n+            System.arraycopy(tmp, 0, currentState, 0, currentState.length);\n+            previousT = splitTime;\n+            yUpAndDown[0] = currentState;\n+            if (needReset) {\n+                // we reset the state back to the end of the last definite sub-step\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(previousT.getReal(), y, fieldY);\n+                }\n+            }\n+            needReset = true;\n+            for (final StepHandler handler : stepHandlers) {\n+                handler.handleStep(interpolator, direction, eventsStates, currentState);\n+            }\n+\n+        } while (!stop);\n+\n+        if (stop) {\n+            // we need to stop before end of the sub-step, due to an event\n+            if (!filter(eventsStates, occuringEvents, previousState, currentState)) {\n+                // we lost track of some event, we need to stop\n+                System.arraycopy(previousState, 0, currentState, 0, currentState.length);\n+                return;\n+            }\n+            System.arraycopy(currentState, 0, state, 0, state.length);\n+            interpolator.storeTime(currentState.getTime().getReal());\n+            for (final EventState state : eventsStates) {\n+                state.stepAccepted(currentState.getTime().getReal(), y, fieldY);\n+            }\n+            return;\n+        }\n+\n+    }\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}