{
    "patch": "    /**\n     * @return Whether the variable is only assigned a value once for its\n     *     lifetime.\n     */\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n\n      Set<BasicBlock> visited = new HashSet<>();\n      BasicBlock currentBlock = ref.getBasicBlock();\n      while (!visited.contains(currentBlock)) {\n        visited.add(currentBlock);\n        List<Node> nodes = currentBlock.getNodes();\n        boolean foundAssignment = false;\n        for (Node node : nodes) {\n          if (node instanceof AstNode) {\n            AstNode astNode = (AstNode) node;\n            if (astNode.getType() == Token.NAME) {\n              for (Reference r : getReferencesByName(astNode.getString())) {\n                if (r == ref) {\n                  continue;\n                }\n                if (r.isAssignment()) {\n                  BasicBlock bb = r.getBasicBlock();\n                  if (bb.isLoop || bb.isFunction) {\n                    // Multiple assignments in nested loops or functions \n                    // make it impossible to determine if the variable gets\n                    // assigned more than once.\n                    return false;\n                  }\n                  foundAssignment = true;\n                  ref = r;\n                  currentBlock = ref.getBasicBlock();\n                }\n              }\n            }\n          }\n        }\n        if (!foundAssignment) {\n          break;\n        }\n      }\n\n      // If we exited the loop and the current ref is different from the\n      // first ref, then the variable is assigned more than once in its lifetime.\n      return ref == getOneAndOnlyAssignment();\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..c00bb76b 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -371,49 +371,6 @@ class ReferenceCollectingCallback implements ScopedCallback,\n      * follow a variable declaration that itself does not initialize the\n      * variable.\n      */\n-    private boolean isInitializingAssignmentAt(int index) {\n-      if (index < references.size() && index > 0) {\n-        Reference maybeDecl = references.get(index - 1);\n-        if (maybeDecl.isVarDeclaration()) {\n-          Preconditions.checkState(!maybeDecl.isInitializingDeclaration());\n-          Reference maybeInit = references.get(index);\n-          if (maybeInit.isSimpleAssignmentToName()) {\n-            return true;\n-          }\n-        }\n-      }\n-      return false;\n-    }\n-\n-    /**\n-     * @return The reference that provides the value for the variable at the\n-     * time of the first read, if known, otherwise null.\n-     *\n-     * This is either the variable declaration (\"var a = ...\") or first\n-     * reference following the declaration if it is an assignment.\n-     */\n-    Reference getInitializingReference() {\n-      if (isInitializingDeclarationAt(0)) {\n-        return references.get(0);\n-      } else if (isInitializingAssignmentAt(1)) {\n-        return references.get(1);\n-      }\n-      return null;\n-    }\n-\n-    /**\n-     * Constants are allowed to be defined after their first use.\n-     */\n-    Reference getInitializingReferenceForConstants() {\n-      int size = references.size();\n-      for (int i = 0; i < size; i++) {\n-        if (isInitializingDeclarationAt(i) || isInitializingAssignmentAt(i)) {\n-          return references.get(i);\n-        }\n-      }\n-      return null;\n-    }\n-\n     /**\n      * @return Whether the variable is only assigned a value once for its\n      *     lifetime.\n@@ -424,17 +381,44 @@ class ReferenceCollectingCallback implements ScopedCallback,\n         return false;\n       }\n \n-      // Make sure this assignment is not in a loop.\n-      for (BasicBlock block = ref.getBasicBlock();\n-           block != null; block = block.getParent()) {\n-        if (block.isFunction) {\n+      Set<BasicBlock> visited = new HashSet<>();\n+      BasicBlock currentBlock = ref.getBasicBlock();\n+      while (!visited.contains(currentBlock)) {\n+        visited.add(currentBlock);\n+        List<Node> nodes = currentBlock.getNodes();\n+        boolean foundAssignment = false;\n+        for (Node node : nodes) {\n+          if (node instanceof AstNode) {\n+            AstNode astNode = (AstNode) node;\n+            if (astNode.getType() == Token.NAME) {\n+              for (Reference r : getReferencesByName(astNode.getString())) {\n+                if (r == ref) {\n+                  continue;\n+                }\n+                if (r.isAssignment()) {\n+                  BasicBlock bb = r.getBasicBlock();\n+                  if (bb.isLoop || bb.isFunction) {\n+                    // Multiple assignments in nested loops or functions \n+                    // make it impossible to determine if the variable gets\n+                    // assigned more than once.\n+                    return false;\n+                  }\n+                  foundAssignment = true;\n+                  ref = r;\n+                  currentBlock = ref.getBasicBlock();\n+                }\n+              }\n+            }\n+          }\n+        }\n+        if (!foundAssignment) {\n           break;\n-        } else if (block.isLoop) {\n-          return false;\n         }\n       }\n \n-      return true;\n+      // If we exited the loop and the current ref is different from the\n+      // first ref, then the variable is assigned more than once in its lifetime.\n+      return ref == getOneAndOnlyAssignment();\n     }\n \n     /**",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}