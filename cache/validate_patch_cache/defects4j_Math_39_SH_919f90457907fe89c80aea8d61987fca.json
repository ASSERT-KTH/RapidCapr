{
    "patch": "        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n        } else {\n          // local error is small enough: accept the step, trigger events and step handlers\n          interpolator.storeTime(stepStart + stepSize);\n          System.arraycopy(yTmp, 0, y, 0, y0.length);\n          System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n\n          // trigger step handler\n          if (stepHandler != null) {\n              stepHandler.handleStep(interpolator, isLastStep);\n          }\n\n          // stepsize control for next step\n          final double factor =\n              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          final double  scaledH    = stepSize * factor;\n          final double  nextT      = stepStart + scaledH;\n          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n          hNew = filterStep(scaledH, forward, nextIsLast);\n\n          final double  filteredNextT      = stepStart + hNew;\n          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n          if (filteredNextIsLast) {\n              hNew = t - stepStart;\n          }\n\n          // check end of stepSize convergence\n          final double  nextTConverge = stepStart + 0.5 * stepSize + 0.5 * hNew;\n          final boolean converged    = forward ? (nextTConverge >= t) : (nextTConverge <= t);\n          if (converged) {\n              hNew = t - stepStart;\n          }\n\n          // prepare next step\n          interpolator.storeTime(stepStart);\n\n          // switch sequence (but don't evaluate in the middle of the step)\n          if (fsal) {\n              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n          }\n\n          if (converged) {\n              isLastStep = true;\n          } else {\n              if (nextIsLast) {\n                  hNew = t - stepStart;\n                  isLastStep = true;\n              } else {\n                  isLastStep = false;\n              }\n              computeDerivatives(stepStart, y, yDotK[0]);\n              System.arraycopy(y, 0, yTmp, 0, y.length);\n          }\n\n        }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..44dd86116 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,67 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+        error = estimateError(yDotK, y, yTmp, stepSize);\n+        if (error >= 1.0) {\n+          // reject the step and attempt to reduce error by stepsize control\n+          final double factor =\n+              FastMath.min(maxGrowth,\n+                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+          hNew = filterStep(stepSize * factor, forward, false);\n+        } else {\n+          // local error is small enough: accept the step, trigger events and step handlers\n+          interpolator.storeTime(stepStart + stepSize);\n+          System.arraycopy(yTmp, 0, y, 0, y0.length);\n+          System.arraycopy(yDotK[stages - 1], 0, yDotTmp, 0, y0.length);\n+\n+          // trigger step handler\n+          if (stepHandler != null) {\n+              stepHandler.handleStep(interpolator, isLastStep);\n+          }\n+\n+          // stepsize control for next step\n+          final double factor =\n+              FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+          final double  scaledH    = stepSize * factor;\n+          final double  nextT      = stepStart + scaledH;\n+          final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n+          hNew = filterStep(scaledH, forward, nextIsLast);\n+\n+          final double  filteredNextT      = stepStart + hNew;\n+          final boolean filteredNextIsLast = forward ? (filteredNextT >= t) : (filteredNextT <= t);\n+          if (filteredNextIsLast) {\n+              hNew = t - stepStart;\n+          }\n+\n+          // check end of stepSize convergence\n+          final double  nextTConverge = stepStart + 0.5 * stepSize + 0.5 * hNew;\n+          final boolean converged    = forward ? (nextTConverge >= t) : (nextTConverge <= t);\n+          if (converged) {\n+              hNew = t - stepStart;\n+          }\n+\n+          // prepare next step\n+          interpolator.storeTime(stepStart);\n+\n+          // switch sequence (but don't evaluate in the middle of the step)\n+          if (fsal) {\n+              System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n+          }\n+\n+          if (converged) {\n+              isLastStep = true;\n+          } else {\n+              if (nextIsLast) {\n+                  hNew = t - stepStart;\n+                  isLastStep = true;\n+              } else {\n+                  isLastStep = false;\n+              }\n+              computeDerivatives(stepStart, y, yDotK[0]);\n+              System.arraycopy(y, 0, yTmp, 0, y.length);\n+          }\n+\n+        }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}