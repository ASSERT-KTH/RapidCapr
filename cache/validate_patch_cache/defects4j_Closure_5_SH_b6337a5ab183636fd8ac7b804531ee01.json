{
    "patch": "  public class MinimizeExitPoints\n      implements CompilerPass {\n    AbstractCompiler compiler;\n\n    public MinimizeExitPoints(AbstractCompiler compiler) {\n      this.compiler = compiler;\n    }\n\n    public void process(Node externs, Node js) {\n      NodeTraversal.traverse(compiler, js, new GatherFunctions());\n    }\n\n    private static final boolean MINIMIZE_EXIT_POINTS =\n        System.getProperty(\"minimize_exit_points\") != null;\n\n    private static class GatherFunctions extends NodeTraversal.AbstractPostOrderCallback {\n      Deque<Node> functionStack;\n\n      private GatherFunctions() {\n        this.functionStack = new ArrayDeque<>();\n      }\n\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isFunction()) {\n          // Only add function declarations to the stack. Function expressions cannot be inlined.\n          if (parent != null && parent.isVar() && parent.getFirstChild() == n) {\n            functionStack.addFirst(n);\n          }\n        }\n      }\n\n      @Override\n      public void visit(NodeTraversal t, Node n) {\n        if (functionStack.isEmpty()) {\n          return;\n        }\n\n        if (NodeUtil.isFunctionBlock(n)) {\n          Node func = functionStack.peekFirst();\n          if (canRewriteFunction(t, func)) {\n            new MinimizeExitPointsCallback(compiler, functionStack).rewriteFunction(func);\n          }\n        }\n\n        // Tail-call optimization doesn't work when a function contains a nested function\n        // that refers to - or worse, calls - itself by name. Therefore, we do not allow\n        // an inliner to process the nested functions of a non-tail-calling function until\n        // after the function has been rewritten.\n        if (NodeUtil.isFunction(n)) {\n          if (NodeUtil.getFunctionBody(n) != null && !NodeUtil.isCandidateForTco(n)) {\n            functionStack.addFirst(n);\n          }\n        }\n      }\n    }\n\n    static boolean canRewriteFunction(NodeTraversal t, Node fn) {\n      if (!fn.isFunction()) {\n        return false;\n      }\n\n      return NodeUtil.getDeclaredVars(fn.getParent()).length == 0\n          && NodeUtil.getEarlyExitStatements(fn).isEmpty();\n    }\n\n    static class MinimizeExitPointsCallback implements NodeTraversal.Callback {\n      final AbstractCompiler compiler;\n      final Deque<Node> functionStack;\n      ArrayDeque<Node> breakTargets;\n      ArrayDeque<Node> continueTargets;\n      Set<Node> localReturnNodes;\n\n      MinimizeExitPointsCallback(AbstractCompiler compiler, Deque<Node> functionStack) {\n        this.compiler = compiler;\n        this.functionStack = functionStack;\n      }\n\n      void rewriteFunction(Node fn) {\n        Preconditions.checkState(NodeUtil.isFunctionExpression(fn), fn);\n        if (fn.isArrowFunction()) {\n          // Cannot rewrite arrow functions as function expressions cannot be inserted inside them.\n          // Ideally, arrow functions with a single statement should be rewritten as a regular\n          // function expression and wrapped with a return statement representing the single statement.\n          // Currently it is not trivial to implement in general all cases. Hence, for now we just bail\n          // early here.\n          return;\n        }\n\n        Node body = NodeUtil.getFunctionBody(fn);\n        if (body.hasOneChild() && !NodeUtil.isLoopStructure(body.getFirstChild())) {\n          // Body has only one statement, which is not a loop. Nothing to inline, just return.\n          return;\n        }\n\n        localReturnNodes = new HashSet<>();\n        breakTargets = new ArrayDeque<>();\n        continueTargets = new ArrayDeque<>();\n        rewriteRecursiveDescent(body);\n\n        if (!localReturnNodes.isEmpty()) {\n          // The last statement in the main function is replaced with a series of statements that store\n          // the returned value in a variable. This is a workaround for a quirk in J2CL that does not allow\n          // return statements before finally blocks.\n          Node lastStatement = body.getLastChild();\n          Node varNode =\n              IR.var(\n                  NodeUtil.newQualifiedName(compiler, \"localReturnValue\"),\n                  NodeUtil.getBestJSType(compiler, lastStatement)).srcref(lastStatement);\n          body.addChildToFront(varNode);\n\n          for (Node returnNode : localReturnNodes) {\n            Node value = returnNode.removeFirstChild();\n            Node assignNode =\n                IR.assign(\n                        NodeUtil.newQualifiedName(compiler, \"localReturnValue\"), value)\n                    .srcref(returnNode);\n            body.addChildBefore(assignNode, returnNode);\n          }\n        }\n\n        Node inlined = IR.block();\n        inlined.addChildrenToFront(body.removeChildren());\n        NodeUtil.copyName(fn, inlined);\n        NodeUtil.deleteFunctionCode(fn);\n        fn.getParent().addChildAfter(inlined, fn);\n        compiler.reportChangeToEnclosingScope(inlined);\n      }\n\n      void rewriteRecursiveDescent(Node n) {\n        switch (n.getToken()) {\n          case FOR:\n          case WHILE:\n            // We do not attempt to inline inside loops because it increases the size of the code.\n            return;\n\n          case DO:\n            // We must save the AST state to ensure that any inlined returns inside the do block are\n            // also marked for rewrite after the while condition.\n            breakTargets.push(n);\n            continueTargets.push(n);\n            localReturnNodes = new HashSet<>();\n            break;\n\n          case BREAK:\n            if (!breakTargets.isEmpty() && n.hasChildren() && breakTargets.peekFirst() == n.getFirstChild()) {\n              breakTargets.pop();\n              Node newBreakTarget = IR.name(\"breakTarget\").srcref(n);\n              NodeUtil.copyName(n.getFirstChild(), newBreakTarget);\n              breakTargetReplaceHelper(n, newBreakTarget);\n              breakTargets.push(newBreakTarget);\n            }\n            return;\n\n          case CONTINUE:\n            if (!continueTargets.isEmpty() && n.hasChildren() && continueTargets.peekFirst() == n.getFirstChild()) {\n              continueTargets.pop();\n              Node newContinueTarget = IR.name(\"continueTarget\").srcref(n);\n              NodeUtil.copyName(n.getFirstChild(), newContinueTarget);\n              breakTargetReplaceHelper(n, newContinueTarget);\n              continueTargets.push(newContinueTarget);\n            }\n            return;\n\n          case RETURN:\n            if (localReturnNodes == null) {\n              return;\n            }\n            localReturnNodes.add(n);\n            break;\n\n          default:\n            break;\n        }\n\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n          rewriteRecursiveDescent(child);\n        }\n      }\n\n      void breakTargetReplaceHelper(Node n, Node newTarget) {\n        n.replaceChild(n.getFirstChild(), newTarget);\n        newTarget.addChildToFront(n.getFirstChild());\n        newTarget.copyInformationFrom(n);\n        n.setIsSyntheticBlock(true);\n        List<NodeUtil.Edge> crossLoopEdges = NodeUtil.getEnteringEdges(n);\n        NodeUtil.reconnectEdges(crossLoopEdges, n, newTarget.getLastChild());\n      }\n\n      @Override\n      public boolean shouldTraverse(NodeTraversal traversal, Node n, Node parent) {\n        if (n == null || parent == null) {\n          return true;\n        }\n        switch (n.getToken()) {\n          case LABEL:\n            if (continueTargets.isEmpty() || !continueTargets.peekFirst().hasChildren()) {\n              continueTargets.push(n.getFirstChild());\n            }\n            breakTargets.push(n);\n            break;\n\n          default:\n            break;\n        }\n        return true;\n      }\n\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n        switch (n.getToken()) {\n          case LABEL:\n            if (!continueTargets.isEmpty() && continueTargets.peekFirst() == n.getFirstChild()) {\n              continueTargets.pop();\n            }\n            if (!breakTargets.isEmpty() && breakTargets.peekFirst() == n) {\n              breakTargets.pop();\n            }\n            break;\n\n          default:\n            break;\n        }\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..74a6d6b4 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,232 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+  public class MinimizeExitPoints\n+      implements CompilerPass {\n+    AbstractCompiler compiler;\n+\n+    public MinimizeExitPoints(AbstractCompiler compiler) {\n+      this.compiler = compiler;\n+    }\n+\n+    public void process(Node externs, Node js) {\n+      NodeTraversal.traverse(compiler, js, new GatherFunctions());\n+    }\n+\n+    private static final boolean MINIMIZE_EXIT_POINTS =\n+        System.getProperty(\"minimize_exit_points\") != null;\n+\n+    private static class GatherFunctions extends NodeTraversal.AbstractPostOrderCallback {\n+      Deque<Node> functionStack;\n+\n+      private GatherFunctions() {\n+        this.functionStack = new ArrayDeque<>();\n+      }\n+\n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (n.isFunction()) {\n+          // Only add function declarations to the stack. Function expressions cannot be inlined.\n+          if (parent != null && parent.isVar() && parent.getFirstChild() == n) {\n+            functionStack.addFirst(n);\n+          }\n+        }\n+      }\n+\n+      @Override\n+      public void visit(NodeTraversal t, Node n) {\n+        if (functionStack.isEmpty()) {\n+          return;\n+        }\n+\n+        if (NodeUtil.isFunctionBlock(n)) {\n+          Node func = functionStack.peekFirst();\n+          if (canRewriteFunction(t, func)) {\n+            new MinimizeExitPointsCallback(compiler, functionStack).rewriteFunction(func);\n+          }\n+        }\n+\n+        // Tail-call optimization doesn't work when a function contains a nested function\n+        // that refers to - or worse, calls - itself by name. Therefore, we do not allow\n+        // an inliner to process the nested functions of a non-tail-calling function until\n+        // after the function has been rewritten.\n+        if (NodeUtil.isFunction(n)) {\n+          if (NodeUtil.getFunctionBody(n) != null && !NodeUtil.isCandidateForTco(n)) {\n+            functionStack.addFirst(n);\n+          }\n+        }\n+      }\n+    }\n+\n+    static boolean canRewriteFunction(NodeTraversal t, Node fn) {\n+      if (!fn.isFunction()) {\n+        return false;\n+      }\n+\n+      return NodeUtil.getDeclaredVars(fn.getParent()).length == 0\n+          && NodeUtil.getEarlyExitStatements(fn).isEmpty();\n+    }\n+\n+    static class MinimizeExitPointsCallback implements NodeTraversal.Callback {\n+      final AbstractCompiler compiler;\n+      final Deque<Node> functionStack;\n+      ArrayDeque<Node> breakTargets;\n+      ArrayDeque<Node> continueTargets;\n+      Set<Node> localReturnNodes;\n+\n+      MinimizeExitPointsCallback(AbstractCompiler compiler, Deque<Node> functionStack) {\n+        this.compiler = compiler;\n+        this.functionStack = functionStack;\n+      }\n+\n+      void rewriteFunction(Node fn) {\n+        Preconditions.checkState(NodeUtil.isFunctionExpression(fn), fn);\n+        if (fn.isArrowFunction()) {\n+          // Cannot rewrite arrow functions as function expressions cannot be inserted inside them.\n+          // Ideally, arrow functions with a single statement should be rewritten as a regular\n+          // function expression and wrapped with a return statement representing the single statement.\n+          // Currently it is not trivial to implement in general all cases. Hence, for now we just bail\n+          // early here.\n+          return;\n+        }\n+\n+        Node body = NodeUtil.getFunctionBody(fn);\n+        if (body.hasOneChild() && !NodeUtil.isLoopStructure(body.getFirstChild())) {\n+          // Body has only one statement, which is not a loop. Nothing to inline, just return.\n+          return;\n+        }\n+\n+        localReturnNodes = new HashSet<>();\n+        breakTargets = new ArrayDeque<>();\n+        continueTargets = new ArrayDeque<>();\n+        rewriteRecursiveDescent(body);\n+\n+        if (!localReturnNodes.isEmpty()) {\n+          // The last statement in the main function is replaced with a series of statements that store\n+          // the returned value in a variable. This is a workaround for a quirk in J2CL that does not allow\n+          // return statements before finally blocks.\n+          Node lastStatement = body.getLastChild();\n+          Node varNode =\n+              IR.var(\n+                  NodeUtil.newQualifiedName(compiler, \"localReturnValue\"),\n+                  NodeUtil.getBestJSType(compiler, lastStatement)).srcref(lastStatement);\n+          body.addChildToFront(varNode);\n+\n+          for (Node returnNode : localReturnNodes) {\n+            Node value = returnNode.removeFirstChild();\n+            Node assignNode =\n+                IR.assign(\n+                        NodeUtil.newQualifiedName(compiler, \"localReturnValue\"), value)\n+                    .srcref(returnNode);\n+            body.addChildBefore(assignNode, returnNode);\n+          }\n+        }\n+\n+        Node inlined = IR.block();\n+        inlined.addChildrenToFront(body.removeChildren());\n+        NodeUtil.copyName(fn, inlined);\n+        NodeUtil.deleteFunctionCode(fn);\n+        fn.getParent().addChildAfter(inlined, fn);\n+        compiler.reportChangeToEnclosingScope(inlined);\n+      }\n+\n+      void rewriteRecursiveDescent(Node n) {\n+        switch (n.getToken()) {\n+          case FOR:\n+          case WHILE:\n+            // We do not attempt to inline inside loops because it increases the size of the code.\n+            return;\n+\n+          case DO:\n+            // We must save the AST state to ensure that any inlined returns inside the do block are\n+            // also marked for rewrite after the while condition.\n+            breakTargets.push(n);\n+            continueTargets.push(n);\n+            localReturnNodes = new HashSet<>();\n+            break;\n+\n+          case BREAK:\n+            if (!breakTargets.isEmpty() && n.hasChildren() && breakTargets.peekFirst() == n.getFirstChild()) {\n+              breakTargets.pop();\n+              Node newBreakTarget = IR.name(\"breakTarget\").srcref(n);\n+              NodeUtil.copyName(n.getFirstChild(), newBreakTarget);\n+              breakTargetReplaceHelper(n, newBreakTarget);\n+              breakTargets.push(newBreakTarget);\n+            }\n+            return;\n+\n+          case CONTINUE:\n+            if (!continueTargets.isEmpty() && n.hasChildren() && continueTargets.peekFirst() == n.getFirstChild()) {\n+              continueTargets.pop();\n+              Node newContinueTarget = IR.name(\"continueTarget\").srcref(n);\n+              NodeUtil.copyName(n.getFirstChild(), newContinueTarget);\n+              breakTargetReplaceHelper(n, newContinueTarget);\n+              continueTargets.push(newContinueTarget);\n+            }\n+            return;\n+\n+          case RETURN:\n+            if (localReturnNodes == null) {\n+              return;\n+            }\n+            localReturnNodes.add(n);\n+            break;\n+\n+          default:\n+            break;\n+        }\n+\n+        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+          rewriteRecursiveDescent(child);\n+        }\n+      }\n+\n+      void breakTargetReplaceHelper(Node n, Node newTarget) {\n+        n.replaceChild(n.getFirstChild(), newTarget);\n+        newTarget.addChildToFront(n.getFirstChild());\n+        newTarget.copyInformationFrom(n);\n+        n.setIsSyntheticBlock(true);\n+        List<NodeUtil.Edge> crossLoopEdges = NodeUtil.getEnteringEdges(n);\n+        NodeUtil.reconnectEdges(crossLoopEdges, n, newTarget.getLastChild());\n+      }\n+\n+      @Override\n+      public boolean shouldTraverse(NodeTraversal traversal, Node n, Node parent) {\n+        if (n == null || parent == null) {\n+          return true;\n+        }\n+        switch (n.getToken()) {\n+          case LABEL:\n+            if (continueTargets.isEmpty() || !continueTargets.peekFirst().hasChildren()) {\n+              continueTargets.push(n.getFirstChild());\n+            }\n+            breakTargets.push(n);\n+            break;\n+\n+          default:\n+            break;\n+        }\n+        return true;\n+      }\n+\n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n+        switch (n.getToken()) {\n+          case LABEL:\n+            if (!continueTargets.isEmpty() && continueTargets.peekFirst() == n.getFirstChild()) {\n+              continueTargets.pop();\n+            }\n+            if (!breakTargets.isEmpty() && breakTargets.peekFirst() == n) {\n+              breakTargets.pop();\n+            }\n+            break;\n+\n+          default:\n+            break;\n+        }\n+      }\n+    }\n+  }\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}