{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final int n = m.getRowDimension();\n    final double epsilon = 1e-10;\n\n    if (n > 1000) {\n        return specializedSquareRoot(m, epsilon);\n    } else {\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n    }\n}\n\nprivate RealMatrix specializedSquareRoot(RealMatrix m, double epsilon) {\n    final int n = m.getRowDimension();\n    final RealMatrix x = m.copy();\n\n    // QR decomposition\n    for (int k = 0; k < n - 1; k++) {\n        RealVector v = x.getColumnVector(k);\n        v.setEntry(k, v.getEntry(k) + FastMath.copySign(v.getNorm(), v.getEntry(k)));\n        v = v.unitVector();\n        RealMatrix q = MatrixUtils.createRealIdentityMatrix(n)\n                       .subtract(v.outerProduct(v).scalarMultiply(2));\n\n        x.setSubMatrix(q.multiply(x.getSubMatrix(k, n - 1, k, n - 1)).getData(), k, k);\n        for (int j = k + 1; j < n; j++) {\n            x.setEntry(k, j, 0);\n        }\n    }\n\n    // check if matrix is positive definite\n    for (int i = 0; i < n; i++) {\n        if (x.getEntry(i, i) < epsilon) {\n            throw new IllegalArgumentException(\"Matrix must be positive definite\");\n        }\n    }\n\n    // compute square root of diagonal elements\n    for (int i = 0; i < n; i++) {\n        x.setEntry(i, i, FastMath.sqrt(x.getEntry(i, i)));\n    }\n\n    // back substitution to obtain final square root\n    for (int j = n - 1; j >= 0; j--) {\n        double diag = x.getEntry(j, j);\n        for (int i = 0; i <= j; i++) {\n            x.setEntry(i, j, x.getEntry(i, j) / diag);\n        }\n        for (int i = 0; i < j; i++) {\n            for (int l = 0; l <= j; l++) {\n                x.setEntry(i, j, x.getEntry(i, j) - x.getEntry(i, l) * x.getEntry(j, l));\n            }\n        }\n    }\n\n    return x;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..5c2854f96 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,61 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final int n = m.getRowDimension();\n+    final double epsilon = 1e-10;\n+\n+    if (n > 1000) {\n+        return specializedSquareRoot(m, epsilon);\n+    } else {\n+        final EigenDecomposition dec = new EigenDecomposition(m);\n+        return dec.getSquareRoot();\n     }\n }\n+\n+private RealMatrix specializedSquareRoot(RealMatrix m, double epsilon) {\n+    final int n = m.getRowDimension();\n+    final RealMatrix x = m.copy();\n+\n+    // QR decomposition\n+    for (int k = 0; k < n - 1; k++) {\n+        RealVector v = x.getColumnVector(k);\n+        v.setEntry(k, v.getEntry(k) + FastMath.copySign(v.getNorm(), v.getEntry(k)));\n+        v = v.unitVector();\n+        RealMatrix q = MatrixUtils.createRealIdentityMatrix(n)\n+                       .subtract(v.outerProduct(v).scalarMultiply(2));\n+\n+        x.setSubMatrix(q.multiply(x.getSubMatrix(k, n - 1, k, n - 1)).getData(), k, k);\n+        for (int j = k + 1; j < n; j++) {\n+            x.setEntry(k, j, 0);\n+        }\n+    }\n+\n+    // check if matrix is positive definite\n+    for (int i = 0; i < n; i++) {\n+        if (x.getEntry(i, i) < epsilon) {\n+            throw new IllegalArgumentException(\"Matrix must be positive definite\");\n+        }\n+    }\n+\n+    // compute square root of diagonal elements\n+    for (int i = 0; i < n; i++) {\n+        x.setEntry(i, i, FastMath.sqrt(x.getEntry(i, i)));\n+    }\n+\n+    // back substitution to obtain final square root\n+    for (int j = n - 1; j >= 0; j--) {\n+        double diag = x.getEntry(j, j);\n+        for (int i = 0; i <= j; i++) {\n+            x.setEntry(i, j, x.getEntry(i, j) / diag);\n+        }\n+        for (int i = 0; i < j; i++) {\n+            for (int l = 0; l <= j; l++) {\n+                x.setEntry(i, j, x.getEntry(i, j) - x.getEntry(i, l) * x.getEntry(j, l));\n+            }\n+        }\n+    }\n+\n+    return x;\n+}\n+}",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}