{
    "patch": "    if (!inputs.isEmpty()) {\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    for (JSModule m : getTransitiveDepsDeepestFirst(module)) {\n      inputs = m.getInputs();\n      if (!inputs.isEmpty()) {\n        return inputs.get(0).getAstRoot(this);\n      }\n    }\n\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n\n  private List<JSModule> getTransitiveDepsDeepestFirst(JSModule startingModule) {\n    List<JSModule> result = new ArrayList<>();\n    Set<String> visited = new HashSet<>();\n    Deque<JSModule> stack = new ArrayDeque<>();\n\n    stack.push(startingModule);\n\n    while (!stack.isEmpty()) {\n      JSModule module = stack.pop();\n      if (visited.contains(module.getName())) {\n        continue;\n      }\n      visited.add(module.getName());\n      result.add(module);\n\n      List<JSModule> directDependencies = getDirectDependencies(module);\n      List<JSModule> unvisitedDependencies = directDependencies.stream()\n          .filter(dependency -> !visited.contains(dependency.getName()))\n          .collect(Collectors.toList());\n\n      // Add the unvisited direct dependencies to the stack so that we visit them before visiting the transitive\n      // dependencies.\n      stack.addAll(unvisitedDependencies);\n\n      // Add the transitive dependencies to the front of the stack.\n      Collections.reverse(directDependencies);\n      stack.addAll(0, directDependencies);\n    }\n\n    return result;\n  }\n\n  private List<JSModule> getDirectDependencies(JSModule module) {\n    List<JSModule> result = new ArrayList<>();\n\n    for (String dependencyName : module.getDependencies()) {\n      JSModule dependency = moduleMap.get(dependencyName);\n      if (dependency != null) {\n        result.add(dependency);\n      }\n    }\n\n    return result;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..c5f8869b 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,63 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n-\n-    checkFirstModule(modules);\n+    if (!inputs.isEmpty()) {\n+      return inputs.get(0).getAstRoot(this);\n+    }\n \n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n+    for (JSModule m : getTransitiveDepsDeepestFirst(module)) {\n+      inputs = m.getInputs();\n+      if (!inputs.isEmpty()) {\n+        return inputs.get(0).getAstRoot(this);\n+      }\n     }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n \n-    initInputsByNameMap();\n+    throw new IllegalStateException(\"Root module has no inputs\");\n   }\n \n-  /**\n-   * Do any initialization that is dependent on the compiler options.\n-   */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+  private List<JSModule> getTransitiveDepsDeepestFirst(JSModule startingModule) {\n+    List<JSModule> result = new ArrayList<>();\n+    Set<String> visited = new HashSet<>();\n+    Deque<JSModule> stack = new ArrayDeque<>();\n+\n+    stack.push(startingModule);\n+\n+    while (!stack.isEmpty()) {\n+      JSModule module = stack.pop();\n+      if (visited.contains(module.getName())) {\n+        continue;\n+      }\n+      visited.add(module.getName());\n+      result.add(module);\n+\n+      List<JSModule> directDependencies = getDirectDependencies(module);\n+      List<JSModule> unvisitedDependencies = directDependencies.stream()\n+          .filter(dependency -> !visited.contains(dependency.getName()))\n+          .collect(Collectors.toList());\n+\n+      // Add the unvisited direct dependencies to the stack so that we visit them before visiting the transitive\n+      // dependencies.\n+      stack.addAll(unvisitedDependencies);\n+\n+      // Add the transitive dependencies to the front of the stack.\n+      Collections.reverse(directDependencies);\n+      stack.addAll(0, directDependencies);\n     }\n+\n+    return result;\n   }\n \n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n+  private List<JSModule> getDirectDependencies(JSModule module) {\n+    List<JSModule> result = new ArrayList<>();\n+\n+    for (String dependencyName : module.getDependencies()) {\n+      JSModule dependency = moduleMap.get(dependencyName);\n+      if (dependency != null) {\n+        result.add(dependency);\n+      }\n+    }\n+\n+    return result;\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}