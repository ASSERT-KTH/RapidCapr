{
    "patch": "public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n\n    final double d1 = v1.getX();\n    final double d2 = v1.getY();\n    final double d3 = v1.getZ();\n    final double d4 = v2.getX();\n    final double d5 = v2.getY();\n    final double d6 = v2.getZ();\n\n    final double d7 = d2 * d6 - d3 * d5;\n    final double d8 = d3 * d4 - d1 * d6;\n    final double d9 = d1 * d5 - d2 * d4;\n\n    final double d10 = Math.max(Math.abs(d1), Math.max(Math.abs(d2), Math.abs(d3)));\n    final double d11 = Math.max(Math.abs(d4), Math.max(Math.abs(d5), Math.abs(d6)));\n    final double d12 = d1 * d4 + d2 * d5 + d3 * d6;\n    final double d13 = d10 * d11 * 2.220446049250313E-16 * d12;\n    final double d14 = d12 + d13;\n    final double d15 = d7 * d7 + d8 * d8 + d9 * d9;\n    final double d16 = 1.0 / Math.sqrt(d15);\n    final double d17 = d16 * d13;\n\n    return new Vector3D(d7 + (d8 * d9 * d17), d8 + (d9 * d7 * d17), d9 + (d7 * d8 * d17));\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/geometry/Vector3D.java b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\nindex 3c741e9e2..b9e651f25 100644\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n@@ -454,25 +454,30 @@ public class Vector3D implements Serializable {\n    * @param v2 second vector\n    * @return the cross product v1 ^ v2 as a new Vector\n    */\n-  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n-\n-\n-      // rescale both vectors without losing precision,\n-      // to ensure their norm are the same order of magnitude\n-\n-      // we reduce cancellation errors by preconditioning,\n-      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n-      // v3 without loss of precision. See Kahan lecture\n-      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n-      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n-\n-      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n-\n-\n-      // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n-\n-  }\n+public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n+\n+    final double d1 = v1.getX();\n+    final double d2 = v1.getY();\n+    final double d3 = v1.getZ();\n+    final double d4 = v2.getX();\n+    final double d5 = v2.getY();\n+    final double d6 = v2.getZ();\n+\n+    final double d7 = d2 * d6 - d3 * d5;\n+    final double d8 = d3 * d4 - d1 * d6;\n+    final double d9 = d1 * d5 - d2 * d4;\n+\n+    final double d10 = Math.max(Math.abs(d1), Math.max(Math.abs(d2), Math.abs(d3)));\n+    final double d11 = Math.max(Math.abs(d4), Math.max(Math.abs(d5), Math.abs(d6)));\n+    final double d12 = d1 * d4 + d2 * d5 + d3 * d6;\n+    final double d13 = d10 * d11 * 2.220446049250313E-16 * d12;\n+    final double d14 = d12 + d13;\n+    final double d15 = d7 * d7 + d8 * d8 + d9 * d9;\n+    final double d16 = 1.0 / Math.sqrt(d15);\n+    final double d17 = d16 * d13;\n+\n+    return new Vector3D(d7 + (d8 * d9 * d17), d8 + (d9 * d7 * d17), d9 + (d7 * d8 * d17));\n+}\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:",
    "result_reason": "junit.framework.AssertionFailedError: expected:<1.0> but was:<-1.6804045384506618E24>",
    "test_result": "FAIL"
}