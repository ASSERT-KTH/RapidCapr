{
    "patch": "private void prelim(final double[] lowerBound, final double[] upperBound) {\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n\n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Set XBASE to the initial vector of variables, and set the initial\n    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, ZERO);\n        }\n        for (int i = 0; i < ndim; i++) {\n            bMatrix.setEntry(i, j, ZERO);\n        }\n    }\n\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, ZERO);\n    }\n\n    for (int k = 0; k < npt; k++) {\n        modelSecondDerivativesParameters.setEntry(k, ZERO);\n        for (int j = 0, max = npt - np; j < max; j++) {\n            zMatrix.setEntry(k, j, ZERO);\n        }\n    }\n\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = Double.NaN;\n\n    do { // Begin the initialization procedure\n        final int nfm = getEvaluations() + 1;\n        final int nfx = nfm - n;\n        final int nfmm = nfm - 1;\n        final int nfxm = nfx - 1;\n        double stepa = 0;\n        double stepb = 0;\n\n        // Evaluate the function at the next point\n        if (nfm <= 2 * n) {\n            if (nfm >= 1 && nfm <= n) {\n                // Initialization via interpolation in n directions.\n                stepa = this.initialTrustRegionRadius;\n                if (lowerDifference.getEntry(nfmm) == ZERO) {\n                    stepa = -stepa;\n                }\n                interpolationPoints.setEntry(nfm, nfmm, stepa);\n            } else if (nfm > n) {\n                // Initialization via interpolation in one direction.\n                final int jptm = nfm - n - 1;\n                final int iptm = jptm + n;\n                final double xiptm = interpolationPoints.getEntry(iptm, iptm);\n                final double xjptm = interpolationPoints.getEntry(jptm, jptm);\n                stepa = xiptm - xjptm;\n                stepb = this.initialTrustRegionRadius;\n                if (lowerDifference.getEntry(jptm) == ZERO || upperDifference.getEntry(jptm) == ZERO) {\n                    stepb = -stepb;\n                }\n                if (lowerDifference.getEntry(jptm) == ZERO && upperDifference.getEntry(jptm) == ZERO) {\n                    stepb = ZERO;\n                }\n                interpolationPoints.setEntry(nfm, jptm, stepb);\n                interpolationPoints.setEntry(nfm, iptm, stepa);\n            }\n        } else {\n            // Initialization via interpolation in two directions.\n            final int ilopt = trustRegionCenterInterpolationPointIndex;\n            final double oldFac = modelSecondDerivativesValues.getEntry((ilopt - np) * ilopt / 2);\n            final double[] glag = new double[n];\n            final double[] hcol = new double[npt];\n            for (int i = 0; i < npt; i++) {\n                hcol[i] = bMatrix.getEntry((ilopt - np) + i, nfxm);\n            }\n            for (int j = nfx; j < n; j++) {\n                double sum = 0;\n                for (int i = 0; i < npt; i++) {\n                    sum += interpolationPoints.getEntry(i, j) * hcol[i];\n                }\n                glag[j] = sum;\n                for (int i = 0; i < npt; i++) {\n                    fAtInterpolationPoints.setEntry(i, fAtInterpolationPoints.getEntry(i) + interpolationPoints.getEntry(i, j) * glag[j]);\n                }\n            }\n            final double[][] hcol2 = new double[npt][];\n            for (int i = 0; i < npt; i++) {\n                final double tmp = hcol[i];\n                final double[] hcolI = new double[i + 1];\n                for (int j = 0; j < i; j++) {\n                    hcolI[j] = hcol2[j][i];\n                    tmp += hcol[i] * hcolI[j];\n                }\n                hcolI[i] = tmp;\n                hcol2[i] = hcolI;\n            }\n            for (int i = 0; i < npt; i++) {\n                hcol[i] = hcol2[i][i];\n            }\n            double theta = hcol[nfxm];\n            final double[] glagComplete = new double[n];\n            for (int i = 0; i < n; i++) {\n                glagComplete[i] = glag[i];\n            }\n            for (int k = nfx; k < npt; k++) {\n                double sum = 0;\n                for (int j = 0; j < n; j++) {\n                    sum += interpolationPoints.getEntry(k, j) * originShift.getEntry(j);\n                }\n                final double temp = hcol[nfx + k];\n                theta += temp * temp / (modelSecondDerivativesValues.getEntry(k) - oldFac);\n                for (int i = 0; i < n; i++) {\n                    glagComplete[i] += temp * interpolationPoints.getEntry(k, i);\n                }\n                fAtInterpolationPoints.setEntry(k, fAtInterpolationPoints.getEntry(k) + theta);\n            }\n            // Rearrange the elements of GLAG and ZMAT so that the first NPT\n            // components of GLAG and the first NPT rows of ZMAT\n            // are the corresponding ones for the current interpolation points.\n            for (int i = 0; i < npt; i++) {\n                final int ipt1 = i + np;\n                final double z = zMatrix.getEntry(ipt1, nfxm);\n                zMatrix.setEntry(ipt1, nfxm, zMatrix.getEntry(ilopt, nfxm));\n                zMatrix.setEntry(ilopt, nfxm, z);\n                interpolationPoints.setEntry(ipt1, nfxm, interpolationPoints.getEntry(ilopt, nfxm));\n                interpolationPoints.setEntry(ilopt, nfxm, ZERO);\n                glag[i] = glagComplete[permutation.getEntry(ipt1)];\n            }\n\n            // Calculate the parameters of the least Frobenius norm interpolant to\n            // the current data, the gradient of this interpolant at the origin\n            // and the standard deviation of the errors in the interpolant.\n            double[] w = new double[npt];\n            for (int k = npt; k < 2 * n + 1; ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\nindex 592a2e894..5073fbd7d 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n@@ -1579,180 +1579,144 @@ public class BOBYQAOptimizer\n      * @param lowerBound Lower bounds.\n      * @param upperBound Upper bounds.\n      */\n-    private void prelim(double[] lowerBound,\n-                        double[] upperBound) {\n-        printMethod(); // XXX\n-\n-        final int n = currentBest.getDimension();\n-        final int npt = numberOfInterpolationPoints;\n-        final int ndim = bMatrix.getRowDimension();\n-\n-        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n-        final double recip = 1d / rhosq;\n-        final int np = n + 1;\n-\n-        // Set XBASE to the initial vector of variables, and set the initial\n-        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n-\n-        for (int j = 0; j < n; j++) {\n-            originShift.setEntry(j, currentBest.getEntry(j));\n-            for (int k = 0; k < npt; k++) {\n-                interpolationPoints.setEntry(k, j, ZERO);\n-            }\n-            for (int i = 0; i < ndim; i++) {\n-                bMatrix.setEntry(i, j, ZERO);\n-            }\n+private void prelim(final double[] lowerBound, final double[] upperBound) {\n+    final int n = currentBest.getDimension();\n+    final int npt = numberOfInterpolationPoints;\n+    final int ndim = bMatrix.getRowDimension();\n+\n+    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n+    final double recip = 1d / rhosq;\n+    final int np = n + 1;\n+\n+    // Set XBASE to the initial vector of variables, and set the initial\n+    // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n+    for (int j = 0; j < n; j++) {\n+        originShift.setEntry(j, currentBest.getEntry(j));\n+        for (int k = 0; k < npt; k++) {\n+            interpolationPoints.setEntry(k, j, ZERO);\n         }\n-        for (int i = 0, max = n * np / 2; i < max; i++) {\n-            modelSecondDerivativesValues.setEntry(i, ZERO);\n+        for (int i = 0; i < ndim; i++) {\n+            bMatrix.setEntry(i, j, ZERO);\n         }\n-        for (int k = 0; k < npt; k++) {\n-            modelSecondDerivativesParameters.setEntry(k, ZERO);\n-            for (int j = 0, max = npt - np; j < max; j++) {\n-                zMatrix.setEntry(k, j, ZERO);\n-            }\n+    }\n+\n+    for (int i = 0, max = n * np / 2; i < max; i++) {\n+        modelSecondDerivativesValues.setEntry(i, ZERO);\n+    }\n+\n+    for (int k = 0; k < npt; k++) {\n+        modelSecondDerivativesParameters.setEntry(k, ZERO);\n+        for (int j = 0, max = npt - np; j < max; j++) {\n+            zMatrix.setEntry(k, j, ZERO);\n         }\n+    }\n \n-        // Begin the initialization procedure. NF becomes one more than the number\n-        // of function values so far. The coordinates of the displacement of the\n-        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n-\n-        int ipt = 0;\n-        int jpt = 0;\n-        double fbeg = Double.NaN;\n-        do {\n-            final int nfm = getEvaluations();\n-            final int nfx = nfm - n;\n-            final int nfmm = nfm - 1;\n-            final int nfxm = nfx - 1;\n-            double stepa = 0;\n-            double stepb = 0;\n-            if (nfm <= 2 * n) {\n-                if (nfm >= 1 &&\n-                    nfm <= n) {\n-                    stepa = initialTrustRegionRadius;\n-                    if (upperDifference.getEntry(nfmm) == ZERO) {\n-                        stepa = -stepa;\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n-                } else if (nfm > n) {\n-                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n-                    stepb = -initialTrustRegionRadius;\n-                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                    if (upperDifference.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n+    int ipt = 0;\n+    int jpt = 0;\n+    double fbeg = Double.NaN;\n+\n+    do { // Begin the initialization procedure\n+        final int nfm = getEvaluations() + 1;\n+        final int nfx = nfm - n;\n+        final int nfmm = nfm - 1;\n+        final int nfxm = nfx - 1;\n+        double stepa = 0;\n+        double stepb = 0;\n+\n+        // Evaluate the function at the next point\n+        if (nfm <= 2 * n) {\n+            if (nfm >= 1 && nfm <= n) {\n+                // Initialization via interpolation in n directions.\n+                stepa = this.initialTrustRegionRadius;\n+                if (lowerDifference.getEntry(nfmm) == ZERO) {\n+                    stepa = -stepa;\n+                }\n+                interpolationPoints.setEntry(nfm, nfmm, stepa);\n+            } else if (nfm > n) {\n+                // Initialization via interpolation in one direction.\n+                final int jptm = nfm - n - 1;\n+                final int iptm = jptm + n;\n+                final double xiptm = interpolationPoints.getEntry(iptm, iptm);\n+                final double xjptm = interpolationPoints.getEntry(jptm, jptm);\n+                stepa = xiptm - xjptm;\n+                stepb = this.initialTrustRegionRadius;\n+                if (lowerDifference.getEntry(jptm) == ZERO || upperDifference.getEntry(jptm) == ZERO) {\n+                    stepb = -stepb;\n+                }\n+                if (lowerDifference.getEntry(jptm) == ZERO && upperDifference.getEntry(jptm) == ZERO) {\n+                    stepb = ZERO;\n+                }\n+                interpolationPoints.setEntry(nfm, jptm, stepb);\n+                interpolationPoints.setEntry(nfm, iptm, stepa);\n+            }\n+        } else {\n+            // Initialization via interpolation in two directions.\n+            final int ilopt = trustRegionCenterInterpolationPointIndex;\n+            final double oldFac = modelSecondDerivativesValues.getEntry((ilopt - np) * ilopt / 2);\n+            final double[] glag = new double[n];\n+            final double[] hcol = new double[npt];\n+            for (int i = 0; i < npt; i++) {\n+                hcol[i] = bMatrix.getEntry((ilopt - np) + i, nfxm);\n+            }\n+            for (int j = nfx; j < n; j++) {\n+                double sum = 0;\n+                for (int i = 0; i < npt; i++) {\n+                    sum += interpolationPoints.getEntry(i, j) * hcol[i];\n                 }\n-            } else {\n-                final int tmp1 = (nfm - np) / n;\n-                jpt = nfm - tmp1 * n - n;\n-                ipt = jpt + tmp1;\n-                if (ipt > n) {\n-                    final int tmp2 = jpt;\n-                    jpt = ipt - n;\n-                    ipt = tmp2;\n-                    throw new PathIsExploredException(); // XXX\n+                glag[j] = sum;\n+                for (int i = 0; i < npt; i++) {\n+                    fAtInterpolationPoints.setEntry(i, fAtInterpolationPoints.getEntry(i) + interpolationPoints.getEntry(i, j) * glag[j]);\n                 }\n-                final int iptMinus1 = ipt;\n-                final int jptMinus1 = jpt;\n-                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n-                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n             }\n-\n-            // Calculate the next value of F. The least function value so far and\n-            // its index are required.\n-\n-            for (int j = 0; j < n; j++) {\n-                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n-                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n-                                                 upperBound[j]));\n-                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n-                    currentBest.setEntry(j, lowerBound[j]);\n-                }\n-                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n-                    currentBest.setEntry(j, upperBound[j]);\n+            final double[][] hcol2 = new double[npt][];\n+            for (int i = 0; i < npt; i++) {\n+                final double tmp = hcol[i];\n+                final double[] hcolI = new double[i + 1];\n+                for (int j = 0; j < i; j++) {\n+                    hcolI[j] = hcol2[j][i];\n+                    tmp += hcol[i] * hcolI[j];\n                 }\n+                hcolI[i] = tmp;\n+                hcol2[i] = hcolI;\n             }\n-\n-            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n-            final double f = isMinimize ? objectiveValue : -objectiveValue;\n-            final int numEval = getEvaluations(); // nfm + 1\n-            fAtInterpolationPoints.setEntry(nfm, f);\n-\n-            if (numEval == 1) {\n-                fbeg = f;\n-                trustRegionCenterInterpolationPointIndex = 0;\n-            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n-                trustRegionCenterInterpolationPointIndex = nfm;\n+            for (int i = 0; i < npt; i++) {\n+                hcol[i] = hcol2[i][i];\n             }\n-\n-            // Set the nonzero initial elements of BMAT and the quadratic model in the\n-            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n-            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n-            // order that the function value at the first of them contributes to the\n-            // off-diagonal second derivative terms of the initial quadratic model.\n-\n-            if (numEval <= 2 * n + 1) {\n-                if (numEval >= 2 &&\n-                    numEval <= n + 1) {\n-                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n-                    if (npt < numEval + n) {\n-                        final double oneOverStepA = ONE / stepa;\n-                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n-                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n-                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n-                        throw new PathIsExploredException(); // XXX\n-                    }\n-                } else if (numEval >= n + 2) {\n-                    final int ih = nfx * (nfx + 1) / 2 - 1;\n-                    final double tmp = (f - fbeg) / stepb;\n-                    final double diff = stepb - stepa;\n-                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n-                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n-                    if (stepa * stepb < ZERO) {\n-                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n-                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n-                            fAtInterpolationPoints.setEntry(nfm - n, f);\n-                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n-                                trustRegionCenterInterpolationPointIndex = nfm - n;\n-                            }\n-                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n-                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n-                        }\n-                    }\n-                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n-                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n-                    bMatrix.setEntry(nfm - n, nfxm,\n-                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n-                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n-                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n-                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n-                    zMatrix.setEntry(nfm - n, nfxm,\n-                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n+            double theta = hcol[nfxm];\n+            final double[] glagComplete = new double[n];\n+            for (int i = 0; i < n; i++) {\n+                glagComplete[i] = glag[i];\n+            }\n+            for (int k = nfx; k < npt; k++) {\n+                double sum = 0;\n+                for (int j = 0; j < n; j++) {\n+                    sum += interpolationPoints.getEntry(k, j) * originShift.getEntry(j);\n                 }\n+                final double temp = hcol[nfx + k];\n+                theta += temp * temp / (modelSecondDerivativesValues.getEntry(k) - oldFac);\n+                for (int i = 0; i < n; i++) {\n+                    glagComplete[i] += temp * interpolationPoints.getEntry(k, i);\n+                }\n+                fAtInterpolationPoints.setEntry(k, fAtInterpolationPoints.getEntry(k) + theta);\n+            }\n+            // Rearrange the elements of GLAG and ZMAT so that the first NPT\n+            // components of GLAG and the first NPT rows of ZMAT\n+            // are the corresponding ones for the current interpolation points.\n+            for (int i = 0; i < npt; i++) {\n+                final int ipt1 = i + np;\n+                final double z = zMatrix.getEntry(ipt1, nfxm);\n+                zMatrix.setEntry(ipt1, nfxm, zMatrix.getEntry(ilopt, nfxm));\n+                zMatrix.setEntry(ilopt, nfxm, z);\n+                interpolationPoints.setEntry(ipt1, nfxm, interpolationPoints.getEntry(ilopt, nfxm));\n+                interpolationPoints.setEntry(ilopt, nfxm, ZERO);\n+                glag[i] = glagComplete[permutation.getEntry(ipt1)];\n+            }\n \n-                // Set the off-diagonal second derivatives of the Lagrange functions and\n-                // the initial quadratic model.\n-\n-            } else {\n-                zMatrix.setEntry(0, nfxm, recip);\n-                zMatrix.setEntry(nfm, nfxm, recip);\n-                zMatrix.setEntry(ipt, nfxm, -recip);\n-                zMatrix.setEntry(jpt, nfxm, -recip);\n-\n-                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n-                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n-                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-                throw new PathIsExploredException(); // XXX\n-            }\n-        } while (getEvaluations() < npt);\n-    } // prelim\n+            // Calculate the parameters of the least Frobenius norm interpolant to\n+            // the current data, the gradient of this interpolant at the origin\n+            // and the standard deviation of the errors in the interpolant.\n+            double[] w = new double[npt];\n+            for (int k = npt; k < 2 * n + 1; \n \n \n     // ----------------------------------------------------------------------------------------",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}