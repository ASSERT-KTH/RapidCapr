{
    "patch": "public void visit(NodeTraversal t, Node n, Node parent) {\n    if (n.isEmpty() || n.isComma()) {\n        return;\n    }\n\n    if (parent == null) {\n        return;\n    }\n\n    if (n.isExprResult()) {\n        if (n.getFirstChild().isAssign() || n.getFirstChild().isHook()) {\n            // We are removing an assignment or a hook; it's okay to leave it.\n            return;\n        }\n\n        // Do not try to remove blocks and expr results. We already handle\n        // these cases when we visit the child and the peephole passes will\n        // fix up the tree in more clever ways when these are removed.\n        if (n.getFirstChild().isBlock()) {\n            return;\n        }\n\n        if (parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT) {\n            if (n.getNext() == null && NodeUtil.hasSideEffects(n.getFirstChild())) {\n                t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, \"This code lacks a statement containing a side-effect.\"));\n                if (!NodeUtil.isStatement(n)) {\n                    problemNodes.add(n);\n                }\n            }\n            return;\n        }\n\n        if (parent.getType() == Token.COMMA ||\n            parent.getType() == Token.FOR || parent.getType() == Token.IF ||\n            parent.getType() == Token.CALL || parent.getType() == Token.NEW ||\n            parent.getType() == Token.HOOK || parent.getType() == Token.AND ||\n            parent.getType() == Token.OR) {\n            boolean parentIsForInOrOf = parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext());\n            boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n            if (!isResultUsed && n == parent.getLastChild() && !parentIsForInOrOf) {\n                Node grandparent = parent.getParent();\n                if (grandparent == null || (grandparent.getType() != Token.EXPR_RESULT && grandparent.getType() != Token.BLOCK)) {\n                    // Do not report warning for the final expression statement before a return statement\n                    if (grandparent != null && parent.getType() == Token.IF &&\n                        (grandparent.getType() == Token.RETURN || grandparent.getType() == Token.THROW)) {\n                        return;\n                    }\n\n                    String msg = \"This code lacks side-effects. Is there a bug?\";\n                    if (n.isString()) {\n                        msg = \"Is there a missing '+' on the previous line?\";\n                    } else if (n.isCall() || n.isNew() || n.isHook()) {\n                        msg = \"The return value of a call with side-effects is not being used.\";\n                    } else if (n.isOr() || n.isAnd()) {\n                        msg = \"The result of the logical operation is not being used.\";\n                    } else if (n.isGetProp()) {\n                        msg = \"The result of the get operation is not being used.\";\n                    } else if (n.isDelProp()) {\n                        msg = \"The result of the delete operation is not being used.\";\n                    }\n\n                    t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n                    if (!NodeUtil.isStatement(n)) {\n                        problemNodes.add(n);\n                    }\n                }\n            }\n        }\n        return;\n    }\n\n    if (parent.getType() == Token.CAST && NodeUtil.isLiteralValue(n)) {\n        return;\n    }\n\n    if (parent.getType() == Token.RETURN && (n == parent.getFirstChild() || n.isBoolean())) {\n        return;\n    }\n\n    if (parent.getType() == Token.EXPR_RESULT) {\n        return;\n    }\n\n    if (parent.getType() == Token.BLOCK) {\n        Node grandparent = parent.getParent();\n        if (grandparent != null && grandparent.getType() == Token.FUNCTION &&\n            n == grandparent.getLastChild() && !NodeUtil.isStatement(n)) {\n            return; // do not warn about non-statement expressions at end of function.\n        }\n        if (parent.isSyntheticBlock()) {\n            // a synthetic block created through script wrapping\n            return;\n        }\n        if (parent.getNext().getType() == Token.EXPR_RESULT && NodeUtil.isLiteralValue(n)) {\n            // avoid false positives with code like:\n            //   switch(foo) { case 1: case 2: return false; }\n            return;\n        }\n        if (parent.getNext().getType() == Token.GETPROP &&\n            NodeUtil.isNameString(parent.getNext().getFirstChild(), \"toString\") &&\n            NodeUtil.isThisObject(parent.getNext().getLastChild())) {\n            return;\n        }\n\n        if (!NodeUtil.mayHaveSideEffects(n)) {\n            String msg = \"This code lacks side-effects. Is there a bug?\";\n            if (n.isString()) {\n                msg = \"Is there a missing '+' on the previous line?\";\n            } else if (n.isCall() || n.isNew() || n.isHook()) {\n                msg = \"The return value of a call with side-effects is not being used.\";\n            } else if (n.isOr() || n.isAnd()) {\n                msg = \"The result of the logical operation is not being used.\";\n            } else if (n.isGetProp()) {\n                msg = \"The result of the get operation is not being used.\";\n            } else if (n.isDelProp()) {\n                msg = \"The result of the delete operation is not being used.\";\n            }\n\n            t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n            if (!NodeUtil.isStatement(n)) {\n                problemNodes.add(n);\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a0..ceb929ae 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -81,71 +81,131 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n   }\n \n   @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n-    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n-    // I've been unable to think of any cases where this indicates a bug,\n-    // and apparently some people like keeping these semicolons around,\n-    // so we'll allow it.\n-    if (n.isEmpty() ||\n-        n.isComma()) {\n-      return;\n+public void visit(NodeTraversal t, Node n, Node parent) {\n+    if (n.isEmpty() || n.isComma()) {\n+        return;\n     }\n \n     if (parent == null) {\n-      return;\n+        return;\n     }\n \n-    // Do not try to remove a block or an expr result. We already handle\n-    // these cases when we visit the child, and the peephole passes will\n-    // fix up the tree in more clever ways when these are removed.\n     if (n.isExprResult()) {\n-      return;\n+        if (n.getFirstChild().isAssign() || n.getFirstChild().isHook()) {\n+            // We are removing an assignment or a hook; it's okay to leave it.\n+            return;\n+        }\n+\n+        // Do not try to remove blocks and expr results. We already handle\n+        // these cases when we visit the child and the peephole passes will\n+        // fix up the tree in more clever ways when these are removed.\n+        if (n.getFirstChild().isBlock()) {\n+            return;\n+        }\n+\n+        if (parent.getType() == Token.BLOCK || parent.getType() == Token.SCRIPT) {\n+            if (n.getNext() == null && NodeUtil.hasSideEffects(n.getFirstChild())) {\n+                t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, \"This code lacks a statement containing a side-effect.\"));\n+                if (!NodeUtil.isStatement(n)) {\n+                    problemNodes.add(n);\n+                }\n+            }\n+            return;\n+        }\n+\n+        if (parent.getType() == Token.COMMA ||\n+            parent.getType() == Token.FOR || parent.getType() == Token.IF ||\n+            parent.getType() == Token.CALL || parent.getType() == Token.NEW ||\n+            parent.getType() == Token.HOOK || parent.getType() == Token.AND ||\n+            parent.getType() == Token.OR) {\n+            boolean parentIsForInOrOf = parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext());\n+            boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n+            if (!isResultUsed && n == parent.getLastChild() && !parentIsForInOrOf) {\n+                Node grandparent = parent.getParent();\n+                if (grandparent == null || (grandparent.getType() != Token.EXPR_RESULT && grandparent.getType() != Token.BLOCK)) {\n+                    // Do not report warning for the final expression statement before a return statement\n+                    if (grandparent != null && parent.getType() == Token.IF &&\n+                        (grandparent.getType() == Token.RETURN || grandparent.getType() == Token.THROW)) {\n+                        return;\n+                    }\n+\n+                    String msg = \"This code lacks side-effects. Is there a bug?\";\n+                    if (n.isString()) {\n+                        msg = \"Is there a missing '+' on the previous line?\";\n+                    } else if (n.isCall() || n.isNew() || n.isHook()) {\n+                        msg = \"The return value of a call with side-effects is not being used.\";\n+                    } else if (n.isOr() || n.isAnd()) {\n+                        msg = \"The result of the logical operation is not being used.\";\n+                    } else if (n.isGetProp()) {\n+                        msg = \"The result of the get operation is not being used.\";\n+                    } else if (n.isDelProp()) {\n+                        msg = \"The result of the delete operation is not being used.\";\n+                    }\n+\n+                    t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n+                    if (!NodeUtil.isStatement(n)) {\n+                        problemNodes.add(n);\n+                    }\n+                }\n+            }\n+        }\n+        return;\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-      return;\n+    if (parent.getType() == Token.CAST && NodeUtil.isLiteralValue(n)) {\n+        return;\n     }\n \n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (parent.getType() == Token.COMMA) {\n-      if (isResultUsed) {\n+    if (parent.getType() == Token.RETURN && (n == parent.getFirstChild() || n.isBoolean())) {\n         return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n+    }\n+\n+    if (parent.getType() == Token.EXPR_RESULT) {\n         return;\n-      }\n     }\n-    if (\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      String msg = \"This code lacks side-effects. Is there a bug?\";\n-      if (n.isString()) {\n-        msg = \"Is there a missing '+' on the previous line?\";\n-      } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n-      }\n \n-      t.getCompiler().report(\n-          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n-      // TODO(johnlenz): determine if it is necessary to\n-      // try to protect side-effect free statements as well.\n-      if (!NodeUtil.isStatement(n)) {\n-        problemNodes.add(n);\n-      }\n+    if (parent.getType() == Token.BLOCK) {\n+        Node grandparent = parent.getParent();\n+        if (grandparent != null && grandparent.getType() == Token.FUNCTION &&\n+            n == grandparent.getLastChild() && !NodeUtil.isStatement(n)) {\n+            return; // do not warn about non-statement expressions at end of function.\n+        }\n+        if (parent.isSyntheticBlock()) {\n+            // a synthetic block created through script wrapping\n+            return;\n+        }\n+        if (parent.getNext().getType() == Token.EXPR_RESULT && NodeUtil.isLiteralValue(n)) {\n+            // avoid false positives with code like:\n+            //   switch(foo) { case 1: case 2: return false; }\n+            return;\n+        }\n+        if (parent.getNext().getType() == Token.GETPROP &&\n+            NodeUtil.isNameString(parent.getNext().getFirstChild(), \"toString\") &&\n+            NodeUtil.isThisObject(parent.getNext().getLastChild())) {\n+            return;\n+        }\n+\n+        if (!NodeUtil.mayHaveSideEffects(n)) {\n+            String msg = \"This code lacks side-effects. Is there a bug?\";\n+            if (n.isString()) {\n+                msg = \"Is there a missing '+' on the previous line?\";\n+            } else if (n.isCall() || n.isNew() || n.isHook()) {\n+                msg = \"The return value of a call with side-effects is not being used.\";\n+            } else if (n.isOr() || n.isAnd()) {\n+                msg = \"The result of the logical operation is not being used.\";\n+            } else if (n.isGetProp()) {\n+                msg = \"The result of the get operation is not being used.\";\n+            } else if (n.isDelProp()) {\n+                msg = \"The result of the delete operation is not being used.\";\n+            }\n+\n+            t.getCompiler().report(t.makeError(n, level, USELESS_CODE_ERROR, msg));\n+            if (!NodeUtil.isStatement(n)) {\n+                problemNodes.add(n);\n+            }\n+        }\n     }\n-  }\n+}\n \n   /**\n    * Protect side-effect free nodes by making them parameters",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}