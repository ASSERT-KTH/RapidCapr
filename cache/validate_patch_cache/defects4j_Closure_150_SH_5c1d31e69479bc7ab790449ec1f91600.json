{
    "patch": "      attachLiteralTypes(n);\n\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          if (NodeUtil.isFunctionExpression(n)) {\n            break;\n          } else if (NodeUtil.isNameDeclaration(parent)) { // Force declaration.\n            defineDeclaredFunction(n, parent);\n          } else {\n            Node enclosing = NodeUtil.getEnclosingTypeStatement(n);\n            if (enclosing == null || !NodeUtil.isClassDeclaration(enclosing)) {\n              // If we're here, then (1) this is not a named function expression\n              // declaration, (2) it's not a class function declaration to be defined\n              // later, (3) we are not in a block scope, and (4) we are not assigning it\n              // to a name at the declaration point.\n              //\n              // Therefore, we treat it as a function expression.\n              break;\n            }\n            // Here we have a class function declaration that needs to be defined later,\n            // so we fall through to treat it as a normal name declaration.\n          }\n          // Fall through to name declaration.\n        case Token.NAME:\n          defineVar(n, parent);\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.LP:\n          if (parent == scope.getRootNode()) {\n            handleFunctionInputs(parent);\n          }\n          break;\n        case Token.VAR:\n          if (NodeUtil.isNameDeclaration(parent)) {\n            defineVar(n, parent);\n          } else {\n            // If the parent is not a DECLARATION node we probably want to skip.\n            // This is an attempt to avoid some false positives where we think\n            // an assignment to a variable ('var x = value;') is a name declaration.\n            // If the parent is an EXPR_RESULT, but the grandparent is not a VAR\n            // then also skip this, since this is probably a global assignment.\n            if (parent.getType() == Token.EXPR_RESULT &&\n                parent.hasOneChild() &&\n                NodeUtil.isVarDeclaration(parent.getFirstChild())) {\n              defineVar(n, parent.getFirstChild());\n            }\n          }\n          break;\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..8d594110 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1449,18 +1449,54 @@ final class TypedScopeCreator implements ScopeCreator {\n       }\n \n       attachLiteralTypes(n);\n+\n       switch (n.getType()) {\n         case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n+          if (NodeUtil.isFunctionExpression(n)) {\n+            break;\n+          } else if (NodeUtil.isNameDeclaration(parent)) { // Force declaration.\n+            defineDeclaredFunction(n, parent);\n+          } else {\n+            Node enclosing = NodeUtil.getEnclosingTypeStatement(n);\n+            if (enclosing == null || !NodeUtil.isClassDeclaration(enclosing)) {\n+              // If we're here, then (1) this is not a named function expression\n+              // declaration, (2) it's not a class function declaration to be defined\n+              // later, (3) we are not in a block scope, and (4) we are not assigning it\n+              // to a name at the declaration point.\n+              //\n+              // Therefore, we treat it as a function expression.\n+              break;\n+            }\n+            // Here we have a class function declaration that needs to be defined later,\n+            // so we fall through to treat it as a normal name declaration.\n           }\n-          defineDeclaredFunction(n, parent);\n+          // Fall through to name declaration.\n+        case Token.NAME:\n+          defineVar(n, parent);\n           break;\n         case Token.CATCH:\n           defineCatch(n, parent);\n           break;\n+        case Token.LP:\n+          if (parent == scope.getRootNode()) {\n+            handleFunctionInputs(parent);\n+          }\n+          break;\n         case Token.VAR:\n-          defineVar(n, parent);\n+          if (NodeUtil.isNameDeclaration(parent)) {\n+            defineVar(n, parent);\n+          } else {\n+            // If the parent is not a DECLARATION node we probably want to skip.\n+            // This is an attempt to avoid some false positives where we think\n+            // an assignment to a variable ('var x = value;') is a name declaration.\n+            // If the parent is an EXPR_RESULT, but the grandparent is not a VAR\n+            // then also skip this, since this is probably a global assignment.\n+            if (parent.getType() == Token.EXPR_RESULT &&\n+                parent.hasOneChild() &&\n+                NodeUtil.isVarDeclaration(parent.getFirstChild())) {\n+              defineVar(n, parent.getFirstChild());\n+            }\n+          }\n           break;\n       }\n     }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}