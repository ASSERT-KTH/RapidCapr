{
    "patch": "public class TransformDispatcher implements NodeVisitor {\n  private static final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n\n  private final String sourceName;\n  private final ErrorReporter errorReporter;\n\n  public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.errorReporter = errorReporter;\n  }\n\n  protected Node processGeneric(Node node) {\n    checkNotNull(node);\n    Node result = new Node(node.getType());\n    for (Node child : node.children()) {\n      result.addChildToBack(transform(child));\n    }\n    result.copyInformationFrom(node);\n    return result;\n  }\n\n  protected Node processScriptNode(ScriptNode scriptNode) {\n    Node root = processGeneric(scriptNode);\n    ensureStrictModeDirectiveIsOnProperNode(scriptNode, root);\n    return root;\n  }\n\n  private void ensureStrictModeDirectiveIsOnProperNode(Node scriptNode, Node root) {\n    if (!ALLOWED_DIRECTIVES.contains(getStrictModeFromPrologue(scriptNode))) {\n      String errorMessage = \"missing \\\"use strict\\\" declaration\";\n      int line = scriptNode.getLineno();\n      int column = root.getCharno();\n      errorReporter.error(errorMessage, sourceName, line, \"\", column);\n    }\n  }\n\n  private static String getStrictModeFromPrologue(Node scriptNode) {\n    for (Node child = scriptNode.getFirstChild(); child != null; child = child.getNext()) {\n      if (child.getType() != Token.EXPR_RESULT) {\n        break; // End of prologue.\n      }\n      AstNode n = child.getFirstChild();\n      if (n.getType() != Token.STRING) {\n        break; // End of prologue.\n      }\n      String pragma = n.getString();\n      if (ALLOWED_DIRECTIVES.contains(pragma)) {\n        return pragma;\n      }\n    }\n\n    return null;\n  }\n\n  protected Node transform(Node node) {\n    return node == null\n        ? null\n        : (Node) node.visit(this);\n  }\n\n  protected int transformTokenType(int type) {\n    return type;\n  }\n\n  @Override\n  public Node forceTransform(Node node) {\n    return transform(node);\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal nodeTraversal, Node n, Node parent) {}\n\n  @Override\n  public void leave(NodeTraversal nodeTraversal, Node n, Node parent) {}\n\n  protected boolean isDirective(Node n) {\n    if (n == null) {\n      return false;\n    }\n\n    if (n.getType() != Token.EXPR_RESULT) {\n      return false;\n    }\n\n    AstNode firstChild = n.getFirstChild();\n    return firstChild.isString() && ALLOWED_DIRECTIVES.contains(firstChild.getString());\n  }\n\n  protected Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  protected Node processBreakStatement(BreakStatement statementNode) {\n    Node node = new Node(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      AstNode labelName = statementNode.getBreakLabel();\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(transform(labelName));\n    }\n    return node;\n  }\n\n  protected Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = new Node(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\",\n          clauseNode.getCatchCondition().getCharno());\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  protected Node processConditionalExpression(ConditionalExpression exprNode) {\n    return new Node(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  protected Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = new Node(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      AstNode labelName = statementNode.getLabel();\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(transform(labelName));\n    }\n    return node;\n  }\n\n  protected Node processDoLoop(DoLoop loopNode) {\n    return new Node(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  protected Node processElementGet(ElementGet getNode) {\n    return new Node(\n        Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n  }\n\n  protected Node processEmptyExpression(EmptyExpression exprNode) {\n    return new Node(Token.EMPTY);\n  }\n\n  protected Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = new Node(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  protected Node processForInLoop(ForInLoop loopNode) {\n    Node left;\n    // If the left-hand side of the for..in is a destructuring pattern,\n    // declare a temporary variable as the loop variable and destructure\n    // the value each iteration.\n    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n      left = new Node(\n          Token.VAR,\n          createDestructuringLhs(\n              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n    } else {\n      left = transform(loopNode.getIterator());\n    }\n\n    return new Node(\n        Token.FOR,\n        new Node(Token.EMPTY),\n        new Node(Token.EMPTY),\n        new Node(\n            Token.BLOCK,\n            left,\n            new Node(\n                Token.FOR_IN,\n                transform(loopNode.getIteratedObject()),\n                new Node(Token.EMPTY),\n                transformBlock(loopNode.getBody()))));\n  }\n\n  protected Node processFunctionCall(FunctionCall callNode) {\n    return new Node(\n        Token.CALL,\n        transform(callNode.getTarget()),\n        transform(callNode.getArguments()));\n  }\n\n  protected Node processFunction(FunctionNode functionNode) {\n    Node function = new Node(Token.FUNCTION);\n\n    AstNode name = functionNode.getFunctionName();\n    if (name != null && !name.isBlank()) {\n      Node newName = transform(name);\n      newName.setType(Token.NAME);\n      function.addChildToBack(newName);\n    }\n\n    Node args = new Node(Token.PARAM_LIST);\n    for (Node param : functionNode.getParams()) {\n      // Skip empty params like the ones caused by (...).\n      if (!param.isBlank()) {\n        args.addChildToBack(transform(param));\n      }\n    }\n    function.addChildToBack(args);\n    function.addChildToBack(transformFunctionBody(functionNode));\n    return function;\n  }\n\n  protected Node processIfStatement(IfStatement ifNode) {\n    Node ifBlock = transformBlock(ifNode.getThenPart());\n    Node elseBlock = null;\n    if (ifNode.getElsePart() != null) {\n      elseBlock = transformBlock(ifNode.getElsePart());\n    }\n    return new Node(\n        Token.IF, transform(ifNode.getCondition()), ifBlock, elseBlock);\n  }\n\n  protected Node processKeywordLiteral(KeywordLiteral litNode) {\n    return new Node(transformTokenType(litNode.getType()));\n  }\n\n  protected Node processLabel(Label labelNode) {\n    labelNode.getFirstChild().setType(Token.LABEL_NAME);\n    return new Node(Token.LABEL, transform(labelNode.getFirstChild()));\n  }\n\n  protected Node processName(Name nameNode) {\n    Token tokenType = nameNode.getType();\n    return new Node(\n        tokenType,\n        Node.newString(tokenType, nameNode.getIdentifier()));\n  }\n\n  protected Node processNewExpression(NewExpression callNode) {\n    return new Node(Token.NEW, transform(callNode.getTarget()));\n  }\n\n  protected Node processNumber(NumberLiteral numberNode) {\n    return new Node(Token.NUMBER, numberNode.getNumber());\n  }\n\n  protected Node processObjectLiteral(ObjectLiteral litNode) {\n    Node obj = new Node(Token.OBJECTLIT);\n    for (ObjectProperty prop : litNode.getElements()) {\n      Node value = prop.isGetterOrSetter() ? transformFunction(prop) : transform(prop);\n      if (prop.isQuotedString()) {\n        obj.addChildToBack(\n            new Node(Token.STRINGLIT, prop.getPropertyName()) // The key.\n                .copyInformationFrom(prop.getLeft())); // Node location.\n      } else {\n        obj.addChildToBack(\n            Node.newString(\n                Token.STRING,\n                prop.getPropertyName())); // The key.\n      }\n      obj.addChildToBack(value);\n    }\n    return obj;\n  }\n\n  protected Node processParenthesizedExpression(ParenthesizedExpression parensNode) {\n    // A parenthesized expression is represented as an already transformed\n    // expression.\n    return parensNode.getExpression().getParent();\n  }\n\n  protected Node processRegExp(RegExpLiteral regexpNode) {\n    return new Node(Token.REGEXP, regexpNode.getValue());\n  }\n\n  protected Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = new Node(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      node.addChildToBack(transform(statementNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  protected Node processString(AstNode stringNode) {\n    return new Node(Token.STRING, stringNode.getString());\n  }\n\n  protected Node processSwitchCase(SwitchCase switchCaseNode) {\n    if (switchCaseNode.isDefault()) {\n      return new Node(Token.DEFAULT, transformBlock(switchCaseNode.getStatements()));\n    } else {\n      Node test = transform(switchCaseNode.getExpression());\n      if (switchCaseNode.getType() == Token.CASE) {\n        test.setType(Token.CASE);\n      }\n      return new Node(Token.CASE, test, transformBlock(switchCaseNode.getStatements()));\n    }\n  }\n\n  protected Node processSwitch(SwitchStatement switchNode) {\n    Node casesNode = new Node(Token.CASES);\n    casesNode.setLineno(switchNode.getLineno());\n\n    Node defaultCase = null;\n\n    for (SwitchCase switchCase : switchNode.getCases()) {\n      Node caseNode = transform(switchCase);\n      if (caseNode.getType() == Token.DEFAULT) {\n        defaultCase = caseNode.getFirstChild();\n      } else {\n        casesNode.addChildToBack(caseNode);\n      }\n    }\n\n    // If there's no default case, add an empty one so that the case\n    // statement works.\n    if (defaultCase == null) {\n      defaultCase = new Node(Token.BLOCK);\n    }\n    // Ensure the default case can't fall through.\n    defaultCase.addChildToFront(new Node(Token.BREAK));\n\n    return new Node(\n        Token.SWITCH, transform(switchNode.getExpression()), casesNode, defaultCase);\n  }\n\n  protected Node processThrowStatement(ThrowStatement statementNode) {\n    return new Node(Token.THROW, transform(statementNode.getExpression()));\n  }\n\n  protected Node processTryStatement(TryStatement tryNode) {\n    Node tryBlock = transformBlock(tryNode.getTryBlock());\n    Node catchBlock = null;\n    if (tryNode.getCatchBlock() != null) {\n      catchBlock = transform(tryNode.getCatchBlock());\n    }\n    Node finallyBlock = null;\n    if (tryNode.getFinallyBlock() != null) {\n      finallyBlock = transformBlock(tryNode.getFinallyBlock());\n    }\n    return new Node(Token.TRY, tryBlock, catchBlock, finallyBlock);\n  }\n\n  protected Node processUnaryExpression(UnaryExpression exprNode) {\n    int tokenType = transformTokenType(exprNode.getType());\n    return new Node(tokenType, transform(exprNode.getOperand()));\n  }\n\n  protected Node processVariableDeclaration(VariableDeclaration varDeclNode) {\n    Node node = new Node(Token.VAR);\n    for (VariableInitializer initializer : varDeclNode.getVariables()) {\n      node.addChildToBack(transform(initializer));\n    }\n    return node;\n  }\n\n  protected Node processVariableInitializer(VariableInitializer varInitNode) {\n    Node node;\n    AstNode target = varInitNode.getTarget();\n    if (NodeUtil.isDestructuringTarget(target)) {\n      node = new Node(Token.ASSIGN);\n      node.addChildToBack(\n          createDestructuringLhs(target, Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n      node.addChildToBack(transform(varInitNode.getInitializer()));\n    } else {\n      node = new Node(Token.ASSIGN, transform(target), transform(varInitNode.getInitializer()));\n    }\n    return node;\n  }\n\n  protected Node processWhileLoop(WhileLoop loopNode) {\n    return new Node(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n  }\n\n  protected Node transformBlock(Block block) {\n    if (block == null) {\n      return new Node(Token.EMPTY);\n    }\n    return new Node(Token.BLOCK, visitScopedBlock(block));\n  }\n\n  private List<Node> visitScopedBlock(Scope block) {\n    List<Node> result = new ArrayList<>();\n    for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {\n      Node transformed = transform(n);\n      if (transformed != null) {\n        result.add(transformed);\n      }\n    }\n    return result;\n  }\n\n  private Node createDestructuringLhs(AstNode pattern, int type, Node varName) {\n    Node n = new Node(type, varName);\n    for (AstNode child : pattern.children()) {\n      if (child.getType() == Token.ARRAY_PATTERN) {\n        n.addChildToBack(creat",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..96f7241f 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,410 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class TransformDispatcher implements NodeVisitor {\n+  private static final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private final String sourceName;\n+  private final ErrorReporter errorReporter;\n+\n+  public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  protected Node processGeneric(Node node) {\n+    checkNotNull(node);\n+    Node result = new Node(node.getType());\n+    for (Node child : node.children()) {\n+      result.addChildToBack(transform(child));\n     }\n+    result.copyInformationFrom(node);\n+    return result;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  protected Node processScriptNode(ScriptNode scriptNode) {\n+    Node root = processGeneric(scriptNode);\n+    ensureStrictModeDirectiveIsOnProperNode(scriptNode, root);\n+    return root;\n+  }\n+\n+  private void ensureStrictModeDirectiveIsOnProperNode(Node scriptNode, Node root) {\n+    if (!ALLOWED_DIRECTIVES.contains(getStrictModeFromPrologue(scriptNode))) {\n+      String errorMessage = \"missing \\\"use strict\\\" declaration\";\n+      int line = scriptNode.getLineno();\n+      int column = root.getCharno();\n+      errorReporter.error(errorMessage, sourceName, line, \"\", column);\n     }\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  private static String getStrictModeFromPrologue(Node scriptNode) {\n+    for (Node child = scriptNode.getFirstChild(); child != null; child = child.getNext()) {\n+      if (child.getType() != Token.EXPR_RESULT) {\n+        break; // End of prologue.\n+      }\n+      AstNode n = child.getFirstChild();\n+      if (n.getType() != Token.STRING) {\n+        break; // End of prologue.\n+      }\n+      String pragma = n.getString();\n+      if (ALLOWED_DIRECTIVES.contains(pragma)) {\n+        return pragma;\n       }\n-      return node;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    return null;\n+  }\n+\n+  protected Node transform(Node node) {\n+    return node == null\n+        ? null\n+        : (Node) node.visit(this);\n+  }\n+\n+  protected int transformTokenType(int type) {\n+    return type;\n+  }\n+\n+  @Override\n+  public Node forceTransform(Node node) {\n+    return transform(node);\n+  }\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n, Node parent) {\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal nodeTraversal, Node n, Node parent) {}\n+\n+  @Override\n+  public void leave(NodeTraversal nodeTraversal, Node n, Node parent) {}\n+\n+  protected boolean isDirective(Node n) {\n+    if (n == null) {\n+      return false;\n+    }\n+\n+    if (n.getType() != Token.EXPR_RESULT) {\n+      return false;\n+    }\n+\n+    AstNode firstChild = n.getFirstChild();\n+    return firstChild.isString() && ALLOWED_DIRECTIVES.contains(firstChild.getString());\n+  }\n+\n+  protected Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  protected Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = new Node(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      AstNode labelName = statementNode.getBreakLabel();\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(transform(labelName));\n+    }\n+    return node;\n+  }\n+\n+  protected Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = new Node(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\",\n+          clauseNode.getCatchCondition().getCharno());\n+    }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n+\n+  protected Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return new Node(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  protected Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = new Node(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      AstNode labelName = statementNode.getLabel();\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(transform(labelName));\n+    }\n+    return node;\n+  }\n+\n+  protected Node processDoLoop(DoLoop loopNode) {\n+    return new Node(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  protected Node processElementGet(ElementGet getNode) {\n+    return new Node(\n+        Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n+  }\n+\n+  protected Node processEmptyExpression(EmptyExpression exprNode) {\n+    return new Node(Token.EMPTY);\n+  }\n+\n+  protected Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = new Node(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  protected Node processForInLoop(ForInLoop loopNode) {\n+    Node left;\n+    // If the left-hand side of the for..in is a destructuring pattern,\n+    // declare a temporary variable as the loop variable and destructure\n+    // the value each iteration.\n+    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n+        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n+      left = new Node(\n+          Token.VAR,\n+          createDestructuringLhs(\n+              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n+    } else {\n+      left = transform(loopNode.getIterator());\n+    }\n+\n+    return new Node(\n+        Token.FOR,\n+        new Node(Token.EMPTY),\n+        new Node(Token.EMPTY),\n+        new Node(\n+            Token.BLOCK,\n+            left,\n+            new Node(\n+                Token.FOR_IN,\n+                transform(loopNode.getIteratedObject()),\n+                new Node(Token.EMPTY),\n+                transformBlock(loopNode.getBody()))));\n+  }\n+\n+  protected Node processFunctionCall(FunctionCall callNode) {\n+    return new Node(\n+        Token.CALL,\n+        transform(callNode.getTarget()),\n+        transform(callNode.getArguments()));\n+  }\n+\n+  protected Node processFunction(FunctionNode functionNode) {\n+    Node function = new Node(Token.FUNCTION);\n+\n+    AstNode name = functionNode.getFunctionName();\n+    if (name != null && !name.isBlank()) {\n+      Node newName = transform(name);\n+      newName.setType(Token.NAME);\n+      function.addChildToBack(newName);\n+    }\n+\n+    Node args = new Node(Token.PARAM_LIST);\n+    for (Node param : functionNode.getParams()) {\n+      // Skip empty params like the ones caused by (...).\n+      if (!param.isBlank()) {\n+        args.addChildToBack(transform(param));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n+    function.addChildToBack(args);\n+    function.addChildToBack(transformFunctionBody(functionNode));\n+    return function;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  protected Node processIfStatement(IfStatement ifNode) {\n+    Node ifBlock = transformBlock(ifNode.getThenPart());\n+    Node elseBlock = null;\n+    if (ifNode.getElsePart() != null) {\n+      elseBlock = transformBlock(ifNode.getElsePart());\n     }\n+    return new Node(\n+        Token.IF, transform(ifNode.getCondition()), ifBlock, elseBlock);\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  protected Node processKeywordLiteral(KeywordLiteral litNode) {\n+    return new Node(transformTokenType(litNode.getType()));\n+  }\n+\n+  protected Node processLabel(Label labelNode) {\n+    labelNode.getFirstChild().setType(Token.LABEL_NAME);\n+    return new Node(Token.LABEL, transform(labelNode.getFirstChild()));\n+  }\n+\n+  protected Node processName(Name nameNode) {\n+    Token tokenType = nameNode.getType();\n+    return new Node(\n+        tokenType,\n+        Node.newString(tokenType, nameNode.getIdentifier()));\n+  }\n+\n+  protected Node processNewExpression(NewExpression callNode) {\n+    return new Node(Token.NEW, transform(callNode.getTarget()));\n+  }\n+\n+  protected Node processNumber(NumberLiteral numberNode) {\n+    return new Node(Token.NUMBER, numberNode.getNumber());\n+  }\n+\n+  protected Node processObjectLiteral(ObjectLiteral litNode) {\n+    Node obj = new Node(Token.OBJECTLIT);\n+    for (ObjectProperty prop : litNode.getElements()) {\n+      Node value = prop.isGetterOrSetter() ? transformFunction(prop) : transform(prop);\n+      if (prop.isQuotedString()) {\n+        obj.addChildToBack(\n+            new Node(Token.STRINGLIT, prop.getPropertyName()) // The key.\n+                .copyInformationFrom(prop.getLeft())); // Node location.\n+      } else {\n+        obj.addChildToBack(\n+            Node.newString(\n+                Token.STRING,\n+                prop.getPropertyName())); // The key.\n       }\n-      return node;\n+      obj.addChildToBack(value);\n     }\n+    return obj;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  protected Node processParenthesizedExpression(ParenthesizedExpression parensNode) {\n+    // A parenthesized expression is represented as an already transformed\n+    // expression.\n+    return parensNode.getExpression().getParent();\n+  }\n+\n+  protected Node processRegExp(RegExpLiteral regexpNode) {\n+    return new Node(Token.REGEXP, regexpNode.getValue());\n+  }\n+\n+  protected Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = new Node(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(statementNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  protected Node processString(AstNode stringNode) {\n+    return new Node(Token.STRING, stringNode.getString());\n+  }\n+\n+  protected Node processSwitchCase(SwitchCase switchCaseNode) {\n+    if (switchCaseNode.isDefault()) {\n+      return new Node(Token.DEFAULT, transformBlock(switchCaseNode.getStatements()));\n+    } else {\n+      Node test = transform(switchCaseNode.getExpression());\n+      if (switchCaseNode.getType() == Token.CASE) {\n+        test.setType(Token.CASE);\n+      }\n+      return new Node(Token.CASE, test, transformBlock(switchCaseNode.getStatements()));\n     }\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  protected Node processSwitch(SwitchStatement switchNode) {\n+    Node casesNode = new Node(Token.CASES);\n+    casesNode.setLineno(switchNode.getLineno());\n+\n+    Node defaultCase = null;\n+\n+    for (SwitchCase switchCase : switchNode.getCases()) {\n+      Node caseNode = transform(switchCase);\n+      if (caseNode.getType() == Token.DEFAULT) {\n+        defaultCase = caseNode.getFirstChild();\n+      } else {\n+        casesNode.addChildToBack(caseNode);\n+      }\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    // If there's no default case, add an empty one so that the case\n+    // statement works.\n+    if (defaultCase == null) {\n+      defaultCase = new Node(Token.BLOCK);\n     }\n+    // Ensure the default case can't fall through.\n+    defaultCase.addChildToFront(new Node(Token.BREAK));\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    return new Node(\n+        Token.SWITCH, transform(switchNode.getExpression()), casesNode, defaultCase);\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  protected Node processThrowStatement(ThrowStatement statementNode) {\n+    return new Node(Token.THROW, transform(statementNode.getExpression()));\n+  }\n+\n+  protected Node processTryStatement(TryStatement tryNode) {\n+    Node tryBlock = transformBlock(tryNode.getTryBlock());\n+    Node catchBlock = null;\n+    if (tryNode.getCatchBlock() != null) {\n+      catchBlock = transform(tryNode.getCatchBlock());\n     }\n+    Node finallyBlock = null;\n+    if (tryNode.getFinallyBlock() != null) {\n+      finallyBlock = transformBlock(tryNode.getFinallyBlock());\n+    }\n+    return new Node(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+  }\n+\n+  protected Node processUnaryExpression(UnaryExpression exprNode) {\n+    int tokenType = transformTokenType(exprNode.getType());\n+    return new Node(tokenType, transform(exprNode.getOperand()));\n+  }\n+\n+  protected Node processVariableDeclaration(VariableDeclaration varDeclNode) {\n+    Node node = new Node(Token.VAR);\n+    for (VariableInitializer initializer : varDeclNode.getVariables()) {\n+      node.addChildToBack(transform(initializer));\n+    }\n+    return node;\n+  }\n+\n+  protected Node processVariableInitializer(VariableInitializer varInitNode) {\n+    Node node;\n+    AstNode target = varInitNode.getTarget();\n+    if (NodeUtil.isDestructuringTarget(target)) {\n+      node = new Node(Token.ASSIGN);\n+      node.addChildToBack(\n+          createDestructuringLhs(target, Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n+      node.addChildToBack(transform(varInitNode.getInitializer()));\n+    } else {\n+      node = new Node(Token.ASSIGN, transform(target), transform(varInitNode.getInitializer()));\n+    }\n+    return node;\n+  }\n+\n+  protected Node processWhileLoop(WhileLoop loopNode) {\n+    return new Node(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n+  }\n+\n+  protected Node transformBlock(Block block) {\n+    if (block == null) {\n+      return new Node(Token.EMPTY);\n+    }\n+    return new Node(Token.BLOCK, visitScopedBlock(block));\n+  }\n+\n+  private List<Node> visitScopedBlock(Scope block) {\n+    List<Node> result = new ArrayList<>();\n+    for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {\n+      Node transformed = transform(n);\n+      if (transformed != null) {\n+        result.add(transformed);\n+      }\n+    }\n+    return result;\n+  }\n+\n+  private Node createDestructuringLhs(AstNode pattern, int type, Node varName) {\n+    Node n = new Node(type, varName);\n+    for (AstNode child : pattern.children()) {\n+      if (child.getType() == Token.ARRAY_PATTERN) {\n+        n.addChildToBack(creat\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}