{
    "patch": "public Period normalizedStandard(PeriodType type) {\n    type = DateTimeUtils.getPeriodType(type);\n\n    //Use the divide and conquer algorithm for the normalization process\n    return divideAndConquerNormalize(new Period(this), type);\n}\n\nprivate Period divideAndConquerNormalize(Period period, PeriodType type) {\n    //Base case: If we can resolve the period without dividing, do it\n    if (period.isPrecise()) {\n        return period.normalizedStandard(type);\n    }\n\n    //Recursive case: Divide and conquer\n    //Find the period component with the smallest unit distance from the next unit\n    //If all components are zero, return the input period\n    int[] values = period.getValues();\n    int[] indices = findMinDistanceComponent(values);\n    if (indices[0] == -1) {\n        return period.normalizedStandard(type);\n    }\n\n    //Normalize the largest unit period, then the second largest, etc.\n    for (int i = 0; i < indices.length; i++) {\n        int j = indices[i];\n        int sign = values[j] < 0 ? -1 : 1;\n\n        //Normalize the current unit of time by \"borrowing\" from the larger units\n        period = period.withFieldAdded(DurationFieldType.getFieldType(j), sign);\n        period = divideAndConquerNormalize(period, type);\n        period = period.withFieldAdded(DurationFieldType.getFieldType(j), -sign);\n\n        //If period is precise now or we're at the smallest unit, break out\n        if (period.isPrecise() || j == 0) {\n            break;\n        }\n    }\n\n    return period.normalizedStandard(type);\n}\n\nprivate int[] findMinDistanceComponent(int[] values) {\n    int minDistance = Integer.MAX_VALUE;\n    int[] indices = new int[]{-1, -1};\n\n    for (int i = 0; i < values.length; i++) {\n        int value = values[i];\n        if (value != 0 && value != Integer.MIN_VALUE) {\n            DurationFieldType fieldType = DurationFieldType.getFieldType(i);\n            DurationField field = fieldType.getField(ISOChronology.getInstanceUTC());\n\n            int nextUnitStart = (value < 0) ? field.getRangeMinimum() : field.getRangeMaximum() + 1;\n            int nextUnitDistance = Math.abs(nextUnitStart - value) % field.getDurationField().getUnitMillis();\n\n            if (nextUnitDistance < minDistance) {\n                minDistance = nextUnitDistance;\n                indices[0] = i;\n            } else if (nextUnitDistance == minDistance) {\n                indices[1] = i;\n            }\n        }\n    }\n\n    return indices;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/Period.java b/src/main/java/org/joda/time/Period.java\nindex f4047933..d89c7d57 100644\n--- a/src/main/java/org/joda/time/Period.java\n+++ b/src/main/java/org/joda/time/Period.java\n@@ -1613,28 +1613,70 @@ public final class Period\n      *  years or months but the specified period type does not support them\n      * @since 1.5\n      */\n-    public Period normalizedStandard(PeriodType type) {\n-        type = DateTimeUtils.getPeriodType(type);\n-        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n-        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n-        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n-        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n-        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n-        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n-        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n-        int years = getYears();\n-        int months = getMonths();\n-        if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n+public Period normalizedStandard(PeriodType type) {\n+    type = DateTimeUtils.getPeriodType(type);\n+\n+    //Use the divide and conquer algorithm for the normalization process\n+    return divideAndConquerNormalize(new Period(this), type);\n+}\n+\n+private Period divideAndConquerNormalize(Period period, PeriodType type) {\n+    //Base case: If we can resolve the period without dividing, do it\n+    if (period.isPrecise()) {\n+        return period.normalizedStandard(type);\n+    }\n+\n+    //Recursive case: Divide and conquer\n+    //Find the period component with the smallest unit distance from the next unit\n+    //If all components are zero, return the input period\n+    int[] values = period.getValues();\n+    int[] indices = findMinDistanceComponent(values);\n+    if (indices[0] == -1) {\n+        return period.normalizedStandard(type);\n+    }\n+\n+    //Normalize the largest unit period, then the second largest, etc.\n+    for (int i = 0; i < indices.length; i++) {\n+        int j = indices[i];\n+        int sign = values[j] < 0 ? -1 : 1;\n+\n+        //Normalize the current unit of time by \"borrowing\" from the larger units\n+        period = period.withFieldAdded(DurationFieldType.getFieldType(j), sign);\n+        period = divideAndConquerNormalize(period, type);\n+        period = period.withFieldAdded(DurationFieldType.getFieldType(j), -sign);\n+\n+        //If period is precise now or we're at the smallest unit, break out\n+        if (period.isPrecise() || j == 0) {\n+            break;\n+        }\n+    }\n+\n+    return period.normalizedStandard(type);\n+}\n+\n+private int[] findMinDistanceComponent(int[] values) {\n+    int minDistance = Integer.MAX_VALUE;\n+    int[] indices = new int[]{-1, -1};\n+\n+    for (int i = 0; i < values.length; i++) {\n+        int value = values[i];\n+        if (value != 0 && value != Integer.MIN_VALUE) {\n+            DurationFieldType fieldType = DurationFieldType.getFieldType(i);\n+            DurationField field = fieldType.getField(ISOChronology.getInstanceUTC());\n+\n+            int nextUnitStart = (value < 0) ? field.getRangeMinimum() : field.getRangeMaximum() + 1;\n+            int nextUnitDistance = Math.abs(nextUnitStart - value) % field.getDurationField().getUnitMillis();\n+\n+            if (nextUnitDistance < minDistance) {\n+                minDistance = nextUnitDistance;\n+                indices[0] = i;\n+            } else if (nextUnitDistance == minDistance) {\n+                indices[1] = i;\n             }\n         }\n-        return result;\n     }\n \n+    return indices;\n+}\n+\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}