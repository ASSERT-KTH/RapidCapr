{
    "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n            throws MaxIterationsExceededException, FunctionEvaluationException {\n\n        clearResult();\n        verifySequence(min, initial, max);\n\n        // Evaluate function at endpoints and initial point\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        double yInitial = f.value(initial);\n\n        // Check if endpoints or initial point are the root\n        if (Math.abs(yMin) <= functionValueAccuracy) {\n            setResult(min, 0);\n            return result;\n        }\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        // Check if root is bracketed\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                    NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        double x = initial;\n        double y = yInitial;\n        double xMin = min;\n        double yMinOld = yMin;\n        double xMax = max;\n        double yMaxOld = yMax;\n        double delta = 0;\n        double oldDelta = Double.MAX_VALUE;\n\n        // Full Brent algorithm to find the root\n        for (int i = 0; i < maximalIterationCount; i++) {\n            if (yInitial * y < 0) {\n                xMax = xMin;\n                yMaxOld = yMinOld;\n                delta = x - xMin;\n                xMin = x;\n                yMinOld = yInitial;\n                oldDelta = delta;\n            } else {\n                xMin = xMax;\n                yMinOld = yMaxOld;\n                delta = x - xMax;\n                xMax = x;\n                yMaxOld = yInitial;\n                oldDelta = delta;\n            }\n\n            double xMid = (xMin + xMax) / 2;\n\n            double toleranceActual = relativeAccuracy * Math.abs(x) + absoluteAccuracy;\n            if (Math.abs(delta) <= (toleranceActual / 2) || y == 0) {\n                setResult(x, y);\n                return result;\n            }\n\n            if (Math.abs(oldDelta) < toleranceActual && Math.abs(y) > Math.abs(yMinOld)\n                    && Math.abs(y) > Math.abs(yMaxOld)) {\n                setResult(x, y);\n                return result;\n            }\n\n            if ((Math.abs(yMaxOld) < Math.abs(y) && Math.abs(yMaxOld) < Math.abs(yMinOld))\n                    || (Math.abs(yMinOld) < Math.abs(y) && Math.abs(yMinOld) < Math.abs(yMaxOld))) {\n                // Interpolation failed, reset midpoint\n                delta = oldDelta;\n                xMid = xMin + 0.5 * delta;\n            }\n            double yMid = f.value(xMid);\n            if (Math.abs(yMid) <= functionValueAccuracy) {\n                setResult(xMid, yMid);\n                return result;\n            }\n\n            if (yMid * y < 0) {\n                xMax = x;\n                yMaxOld = y;\n                yMax = yMid;\n            } else if (yMid * yMaxOld > 0) {\n                xMax = xMid;\n                yMax = yMid;\n            } else {\n                xMin = x;\n                yMinOld = y;\n                yMin = yMid;\n            }\n\n            double previousX = x;\n            x = (Math.abs(yMin) < Math.abs(yMax)) ? xMin : xMax;\n            y = (Math.abs(yMin) < Math.abs(yMax)) ? yMin : yMax;\n\n            if (Math.abs(previousX - x) <= Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy)) {\n                setResult(x, y);\n                return result;\n            }\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..0d9ce3f02 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,52 +95,115 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n+public double solve(final UnivariateRealFunction f,\n+                    final double min, final double max, final double initial)\n+            throws MaxIterationsExceededException, FunctionEvaluationException {\n \n         clearResult();\n         verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n+        // Evaluate function at endpoints and initial point\n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n         double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n-        }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n+        // Check if endpoints or initial point are the root\n         if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n-\n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+            setResult(initial, 0);\n+            return result;\n         }\n \n+        // Check if root is bracketed\n         if (yMin * yMax > 0) {\n             throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+                    NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n         }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        double x = initial;\n+        double y = yInitial;\n+        double xMin = min;\n+        double yMinOld = yMin;\n+        double xMax = max;\n+        double yMaxOld = yMax;\n+        double delta = 0;\n+        double oldDelta = Double.MAX_VALUE;\n+\n+        // Full Brent algorithm to find the root\n+        for (int i = 0; i < maximalIterationCount; i++) {\n+            if (yInitial * y < 0) {\n+                xMax = xMin;\n+                yMaxOld = yMinOld;\n+                delta = x - xMin;\n+                xMin = x;\n+                yMinOld = yInitial;\n+                oldDelta = delta;\n+            } else {\n+                xMin = xMax;\n+                yMinOld = yMaxOld;\n+                delta = x - xMax;\n+                xMax = x;\n+                yMaxOld = yInitial;\n+                oldDelta = delta;\n+            }\n+\n+            double xMid = (xMin + xMax) / 2;\n+\n+            double toleranceActual = relativeAccuracy * Math.abs(x) + absoluteAccuracy;\n+            if (Math.abs(delta) <= (toleranceActual / 2) || y == 0) {\n+                setResult(x, y);\n+                return result;\n+            }\n \n+            if (Math.abs(oldDelta) < toleranceActual && Math.abs(y) > Math.abs(yMinOld)\n+                    && Math.abs(y) > Math.abs(yMaxOld)) {\n+                setResult(x, y);\n+                return result;\n+            }\n+\n+            if ((Math.abs(yMaxOld) < Math.abs(y) && Math.abs(yMaxOld) < Math.abs(yMinOld))\n+                    || (Math.abs(yMinOld) < Math.abs(y) && Math.abs(yMinOld) < Math.abs(yMaxOld))) {\n+                // Interpolation failed, reset midpoint\n+                delta = oldDelta;\n+                xMid = xMin + 0.5 * delta;\n+            }\n+            double yMid = f.value(xMid);\n+            if (Math.abs(yMid) <= functionValueAccuracy) {\n+                setResult(xMid, yMid);\n+                return result;\n+            }\n+\n+            if (yMid * y < 0) {\n+                xMax = x;\n+                yMaxOld = y;\n+                yMax = yMid;\n+            } else if (yMid * yMaxOld > 0) {\n+                xMax = xMid;\n+                yMax = yMid;\n+            } else {\n+                xMin = x;\n+                yMinOld = y;\n+                yMin = yMid;\n+            }\n+\n+            double previousX = x;\n+            x = (Math.abs(yMin) < Math.abs(yMax)) ? xMin : xMax;\n+            y = (Math.abs(yMin) < Math.abs(yMax)) ? yMin : yMax;\n+\n+            if (Math.abs(previousX - x) <= Math.max(relativeAccuracy * Math.abs(x), absoluteAccuracy)) {\n+                setResult(x, y);\n+                return result;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n     }\n \n     /**",
    "result_reason": "error: no suitable method found for setResult(double,double)",
    "test_result": "ERROR"
}