{
    "patch": "    scope = traverse(constructor, scope);\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n      constructorType = constructorType.restrictByNotNullOrUndefined();\n      if (constructorType.isUnknownType()) {\n        type = getNativeType(UNKNOWN_TYPE);\n      } else if (constructorType.isFunctionType()) {\n        FunctionType ct = constructorType.toMaybeFunctionType();\n        if (ct != null && ct.isConstructor()) {\n          JSType returnType = ct.getReturnType();\n          if (returnType != null && !returnType.isEmptyType()) {\n            type = returnType;\n          } else {\n            type = ct.getInstanceType();\n          }\n        }\n      }\n    }\n    n.setJSType(type);\n    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n      scope = traverse(arg, scope);\n    }\n\n    if (type != null) {\n      if (n.hasOneChild()) {\n        Node onlyChild = n.getFirstChild();\n        // fix: if we have an object type instantiate a new scope and bind objects to their types\n        if (type.isObject()) {\n          type.getOwnPropertyNames().forEach((propertyName) -> {\n            Node propertyNode = new Node(Token.GETPROP,\n                new Node(Token.STRING, propertyName),\n                new Node(Token.NAME, \"undefined\"));\n\n            propertyNode.setJSType(type.getPropertyType(propertyName));\n            scope = redeclareVar(propertyNode, scope);\n          });\n        } else {\n          Node interfaceRoot = findInterfaceRoot(type);\n          if (interfaceRoot != null) {\n            // fix: bind all interface properties to their types\n            Node extendsClause = new Node(Token.IMPLEMENTS);\n            extendsClause.addChildToFront(\n                new Node(Token.EXTENDS, interfaceRoot.getQualifiedName()));\n            Node classNode = IR.classNode(\"X\").copyTypeFrom(n).useSourceInfoFrom(n);\n            classNode.addChildToFront(new Node(Token.CLASS_MEMBERS));\n            classNode.getFirstChild().addChildToBack(extendsClause);\n            Node objectCreation = new Node(Token.NEW, classNode);\n\n            for (String propertyName : getAllPropertyNames(interfaceRoot.getJSType())) {\n              Node propertyNode = new Node(Token.GETPROP,\n                  new Node(Token.STRING, propertyName),\n                  objectCreation.cloneTree());\n\n              propertyNode.setJSType(type.getPropertyType(propertyName));\n              scope = redeclareVar(propertyNode, scope);\n            }\n          }\n        }\n      }\n    }\n    return scope;\n  }\n  \n  /**\n   * Returns all property names for a given object type, including inherited ones.\n   */\n  private Set<String> getAllPropertyNames(ObjectType objectType) {\n    if (objectType == null) {\n      return Collections.emptySet();\n    }\n    Set<String> propertyNames = new HashSet<>(objectType.getOwnPropertyNames());\n    for (ObjectType parent : objectType.getExtendedInterfaces()) {\n      propertyNames.addAll(getAllPropertyNames(parent));\n    }\n    return propertyNames;\n  }\n\n  /**\n   * Searches up the tree for an interface node for the given type.\n   */\n  private Node findInterfaceRoot(JSType type) {\n    ObjectType objectType = type.toMaybeObjectType();\n    if (objectType != null) {\n      for (ObjectType parentInterface : objectType.getExtendedInterfaces()) {\n        Node parentNode = parentInterface.getReferenceNameNode();\n        if (parentNode != null) {\n          JSDocInfo parentJSDoc = parentNode.getJSDocInfo();\n          if (parentJSDoc != null && parentJSDoc.isInterface()) {\n            return parentNode;\n          }\n        }\n        Node grandParentNode = findInterfaceRoot(parentInterface.getJSType());\n        if (grandParentNode != null) {\n          return grandParentNode;\n        }\n      }\n    }\n    return null;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 7e218d88..97296911 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1032,9 +1032,6 @@ class TypeInference\n     }\n   }\n \n-  private FlowScope traverseNew(Node n, FlowScope scope) {\n-\n-    Node constructor = n.getFirstChild();\n     scope = traverse(constructor, scope);\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n@@ -1042,16 +1039,15 @@ class TypeInference\n       constructorType = constructorType.restrictByNotNullOrUndefined();\n       if (constructorType.isUnknownType()) {\n         type = getNativeType(UNKNOWN_TYPE);\n-      } else {\n+      } else if (constructorType.isFunctionType()) {\n         FunctionType ct = constructorType.toMaybeFunctionType();\n-        if (ct == null && constructorType instanceof FunctionType) {\n-          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n-          // return null. But NoObjectType implements the FunctionType\n-          // interface, precisely because it can validly construct objects.\n-          ct = (FunctionType) constructorType;\n-        }\n         if (ct != null && ct.isConstructor()) {\n-          type = ct.getInstanceType();\n+          JSType returnType = ct.getReturnType();\n+          if (returnType != null && !returnType.isEmptyType()) {\n+            type = returnType;\n+          } else {\n+            type = ct.getInstanceType();\n+          }\n         }\n       }\n     }\n@@ -1059,8 +1055,82 @@ class TypeInference\n     for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n       scope = traverse(arg, scope);\n     }\n+\n+    if (type != null) {\n+      if (n.hasOneChild()) {\n+        Node onlyChild = n.getFirstChild();\n+        // fix: if we have an object type instantiate a new scope and bind objects to their types\n+        if (type.isObject()) {\n+          type.getOwnPropertyNames().forEach((propertyName) -> {\n+            Node propertyNode = new Node(Token.GETPROP,\n+                new Node(Token.STRING, propertyName),\n+                new Node(Token.NAME, \"undefined\"));\n+\n+            propertyNode.setJSType(type.getPropertyType(propertyName));\n+            scope = redeclareVar(propertyNode, scope);\n+          });\n+        } else {\n+          Node interfaceRoot = findInterfaceRoot(type);\n+          if (interfaceRoot != null) {\n+            // fix: bind all interface properties to their types\n+            Node extendsClause = new Node(Token.IMPLEMENTS);\n+            extendsClause.addChildToFront(\n+                new Node(Token.EXTENDS, interfaceRoot.getQualifiedName()));\n+            Node classNode = IR.classNode(\"X\").copyTypeFrom(n).useSourceInfoFrom(n);\n+            classNode.addChildToFront(new Node(Token.CLASS_MEMBERS));\n+            classNode.getFirstChild().addChildToBack(extendsClause);\n+            Node objectCreation = new Node(Token.NEW, classNode);\n+\n+            for (String propertyName : getAllPropertyNames(interfaceRoot.getJSType())) {\n+              Node propertyNode = new Node(Token.GETPROP,\n+                  new Node(Token.STRING, propertyName),\n+                  objectCreation.cloneTree());\n+\n+              propertyNode.setJSType(type.getPropertyType(propertyName));\n+              scope = redeclareVar(propertyNode, scope);\n+            }\n+          }\n+        }\n+      }\n+    }\n     return scope;\n   }\n+  \n+  /**\n+   * Returns all property names for a given object type, including inherited ones.\n+   */\n+  private Set<String> getAllPropertyNames(ObjectType objectType) {\n+    if (objectType == null) {\n+      return Collections.emptySet();\n+    }\n+    Set<String> propertyNames = new HashSet<>(objectType.getOwnPropertyNames());\n+    for (ObjectType parent : objectType.getExtendedInterfaces()) {\n+      propertyNames.addAll(getAllPropertyNames(parent));\n+    }\n+    return propertyNames;\n+  }\n+\n+  /**\n+   * Searches up the tree for an interface node for the given type.\n+   */\n+  private Node findInterfaceRoot(JSType type) {\n+    ObjectType objectType = type.toMaybeObjectType();\n+    if (objectType != null) {\n+      for (ObjectType parentInterface : objectType.getExtendedInterfaces()) {\n+        Node parentNode = parentInterface.getReferenceNameNode();\n+        if (parentNode != null) {\n+          JSDocInfo parentJSDoc = parentNode.getJSDocInfo();\n+          if (parentJSDoc != null && parentJSDoc.isInterface()) {\n+            return parentNode;\n+          }\n+        }\n+        Node grandParentNode = findInterfaceRoot(parentInterface.getJSType());\n+        if (grandParentNode != null) {\n+          return grandParentNode;\n+        }\n+      }\n+    }\n+    return null;\n \n   private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {\n     return traverseShortCircuitingBinOp(n, scope, true);",
    "result_reason": "error: <identifier> expected",
    "test_result": "ERROR"
}