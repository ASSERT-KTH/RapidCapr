{
    "patch": "public double solve(final UnivariateRealFunction f, double min, double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    // Evaluate the function at the endpoints\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, 0);\n        return result;\n    }\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, 0);\n        return result;\n    }\n\n    // ensure that min is smaller than max\n    if (min > max) {\n        final double tmp = min;\n        min = max;\n        max = tmp;\n        final double tmp2 = yMin;\n        yMin = yMax;\n        yMax = tmp2;\n    }\n\n    if (yMin * yMax >= 0) {\n        throw new IllegalArgumentException(\"Interval [\" + min + \", \" + max + \"] does not bracket a root\");\n    }\n\n    // full Brent algorithm starting with provided initial guess\n    double x = initial;\n    double y = f.value(x);\n    double z = Double.NaN;\n    double oldvar = 0.0;\n    double dold = 0.0;\n    double lb = Double.NaN;\n    double ub = Double.NaN;\n    double fb = Double.NaN;\n    int numIterations = 0;\n    while (true) {\n        double fmin = f.value(min);\n        double fmax = f.value(max);\n        double fm = f.value(x);\n\n        // check if max and min bracket the root\n        if (fm * fmax > 0) {\n            max = x;\n        } else {\n            min = x;\n        }\n\n        // check if the root has been found based on the function value\n        if (Math.abs(fm) <= functionValueAccuracy) {\n            setResult(x, numIterations);\n            return result;\n        }\n\n        // check if we have reached the maximum allowed iterations\n        if (++numIterations >= maximalIterationCount) {\n            throw new MaxIterationsExceededException(maximalIterationCount);\n        }\n\n        // improve root estimate by building an interpolating quadratic\n        final double xl_old = x;\n        final double dx = (lb + ub) / 2.;\n        final double clampedStep = (dx == 0) ? tolerance * 4 : dx;\n        if ((!Double.isNaN(oldvar)) && (!Double.isNaN(z)) && (!Double.isNaN(fb)) && Math.abs(clampedStep * y) <= Math.abs(z - x)) {\n            double q = fm / fb;\n            double r = fm / y;\n            double p = q * (2.0 * x - z);\n            double etemp = oldvar;\n            oldvar = dold;\n            // if we are not too close to an extremum \n            if (Math.abs(p) < Math.abs(etemp * q - r) && p > epsilon * Math.abs(etemp * q - r)) {\n                dold = p / (q - r);\n                // the approximate location x + dold is accepted\n                final double newPoint = x + dold;\n                if (newPoint < x) {\n                    lb = newPoint;\n                    ub = x;\n                } else {\n                    lb = x;\n                    ub = newPoint;\n                }\n                if (Math.abs(ub - lb) < functionValueAccuracy) {\n                    if (fm < 0) {\n                        setResult(min, numIterations);\n                    } else {\n                        setResult(max, numIterations);\n                    }\n                    return result;\n                }\n            } else {\n                // Now we are too close to an extremum.\n                etemp = oldvar;\n                oldvar = dold;\n                dold = clampedStep * etemp;\n                if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n                    dold = dx > 0 ? tolerance : -tolerance;\n                    if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n                        throw new PrecisionException(tolerance);\n                    }\n                }\n            }\n        } else {\n            // This is a straight bisection step\n            dold = clampedStep;\n            oldvar = dx;\n            lb = Math.min(x, dx);\n            ub = Math.max(x, dx);\n            if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n                dold = dx > 0 ? tolerance : -tolerance;\n                if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n                    throw new PrecisionException(tolerance);\n                }\n            }\n        }\n        // postpone updating q and z until the next iteration\n        if (Math.abs(fm) < Math.abs(fb)) {\n            // swap roles of x and y so that x (the better guess) becomes the \"previous guess\"\n            z = y;\n            y = fm;\n            fb = fm;\n        } else {\n            z = fm;\n            fb = fm;\n        }\n\n        // approximation of the root has not converged yet\n        x = x + dold;\n    }\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..b5dad61f9 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,50 +95,143 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n+public double solve(final UnivariateRealFunction f, double min, double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+    clearResult();\n+    verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n-        }\n+    // Evaluate the function at the endpoints\n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n+    if (Math.abs(yMin) <= functionValueAccuracy) {\n+        setResult(min, 0);\n+        return result;\n+    }\n+    if (Math.abs(yMax) <= functionValueAccuracy) {\n+        setResult(max, 0);\n+        return result;\n+    }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+    // ensure that min is smaller than max\n+    if (min > max) {\n+        final double tmp = min;\n+        min = max;\n+        max = tmp;\n+        final double tmp2 = yMin;\n+        yMin = yMax;\n+        yMax = tmp2;\n+    }\n+\n+    if (yMin * yMax >= 0) {\n+        throw new IllegalArgumentException(\"Interval [\" + min + \", \" + max + \"] does not bracket a root\");\n+    }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n+    // full Brent algorithm starting with provided initial guess\n+    double x = initial;\n+    double y = f.value(x);\n+    double z = Double.NaN;\n+    double oldvar = 0.0;\n+    double dold = 0.0;\n+    double lb = Double.NaN;\n+    double ub = Double.NaN;\n+    double fb = Double.NaN;\n+    int numIterations = 0;\n+    while (true) {\n+        double fmin = f.value(min);\n+        double fmax = f.value(max);\n+        double fm = f.value(x);\n+\n+        // check if max and min bracket the root\n+        if (fm * fmax > 0) {\n+            max = x;\n+        } else {\n+            min = x;\n         }\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+        // check if the root has been found based on the function value\n+        if (Math.abs(fm) <= functionValueAccuracy) {\n+            setResult(x, numIterations);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        // check if we have reached the maximum allowed iterations\n+        if (++numIterations >= maximalIterationCount) {\n+            throw new MaxIterationsExceededException(maximalIterationCount);\n         }\n \n+        // improve root estimate by building an interpolating quadratic\n+        final double xl_old = x;\n+        final double dx = (lb + ub) / 2.;\n+        final double clampedStep = (dx == 0) ? tolerance * 4 : dx;\n+        if ((!Double.isNaN(oldvar)) && (!Double.isNaN(z)) && (!Double.isNaN(fb)) && Math.abs(clampedStep * y) <= Math.abs(z - x)) {\n+            double q = fm / fb;\n+            double r = fm / y;\n+            double p = q * (2.0 * x - z);\n+            double etemp = oldvar;\n+            oldvar = dold;\n+            // if we are not too close to an extremum \n+            if (Math.abs(p) < Math.abs(etemp * q - r) && p > epsilon * Math.abs(etemp * q - r)) {\n+                dold = p / (q - r);\n+                // the approximate location x + dold is accepted\n+                final double newPoint = x + dold;\n+                if (newPoint < x) {\n+                    lb = newPoint;\n+                    ub = x;\n+                } else {\n+                    lb = x;\n+                    ub = newPoint;\n+                }\n+                if (Math.abs(ub - lb) < functionValueAccuracy) {\n+                    if (fm < 0) {\n+                        setResult(min, numIterations);\n+                    } else {\n+                        setResult(max, numIterations);\n+                    }\n+                    return result;\n+                }\n+            } else {\n+                // Now we are too close to an extremum.\n+                etemp = oldvar;\n+                oldvar = dold;\n+                dold = clampedStep * etemp;\n+                if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n+                    dold = dx > 0 ? tolerance : -tolerance;\n+                    if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n+                        throw new PrecisionException(tolerance);\n+                    }\n+                }\n+            }\n+        } else {\n+            // This is a straight bisection step\n+            dold = clampedStep;\n+            oldvar = dx;\n+            lb = Math.min(x, dx);\n+            ub = Math.max(x, dx);\n+            if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n+                dold = dx > 0 ? tolerance : -tolerance;\n+                if (newNumbrsIsMoreAccurate(x + dold, x, ub, lb)) {\n+                    throw new PrecisionException(tolerance);\n+                }\n+            }\n+        }\n+        // postpone updating q and z until the next iteration\n+        if (Math.abs(fm) < Math.abs(fb)) {\n+            // swap roles of x and y so that x (the better guess) becomes the \"previous guess\"\n+            z = y;\n+            y = fm;\n+            fb = fm;\n+        } else {\n+            z = fm;\n+            fb = fm;\n+        }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n-\n+        // approximation of the root has not converged yet\n+        x = x + dold;\n     }\n \n+}\n+\n     /**\n      * Find a zero in the given interval.\n      * <p>",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}