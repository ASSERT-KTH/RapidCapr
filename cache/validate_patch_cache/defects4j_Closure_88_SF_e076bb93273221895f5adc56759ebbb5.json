{
    "patch": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n        if (NodeUtil.isLhs(n, n.getParent())) {\n            // The expression to which the assignment is made is evaluated before\n            // the RHS is evaluated (normal left to right evaluation) but the KILL\n            // occurs after the RHS is evaluated.\n            return VariableLiveness.KILL;\n        } else if (NodeUtil.isAssignmentOp(n.getParent())\n                && NodeUtil.isLhs(n.getParent().getFirstChild(), n)) {\n            // This is an assignment whose RHS we're analyzing. We must check if\n            // the variable being analyzed appears anywhere else in the expression\n            // (e.g. x = y + z could be x = y + x + 1). If it does, the variable\n            // is not killed by this assignment.\n            VarChecker varChecker = new VarChecker(variable);\n            Node expression = n.getNext();\n            // If we're on an assign op, we need to check the RHS of the assign op\n            if (NodeUtil.isAssignOp(n.getParent())) {\n                expression = n.getParent().getLastChild();\n            }\n            expression.visit(varChecker);\n            if (varChecker.foundVar()) {\n                return VariableLiveness.READ;\n            } else {\n                return VariableLiveness.KILL;\n            }\n        } else {\n            return VariableLiveness.READ;\n        }\n    }\n\n    // Expressions are evaluated left-right, depth first.\n    for (Node child = n.getFirstChild();\n         child != null; child = child.getNext()) {\n        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n            VariableLiveness state = isVariableReadBeforeKill(child, variable);\n            if (state != VariableLiveness.MAYBE_LIVE) {\n                return state;\n            }\n        }\n    }\n    return VariableLiveness.MAYBE_LIVE;\n}\n\nprivate static class VarChecker extends NodeVisitor {\n    private final String variable;\n    private boolean found = false;\n\n    VarChecker(String variable) {\n        this.variable = variable;\n    }\n\n    boolean foundVar() {\n        return found;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n.isName() && variable.equals(n.getString())) {\n            found = true;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\nindex ef33e4c0..b7d0fd65 100644\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n@@ -320,29 +320,66 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    * reference of that variable is a read. It returns KILL, if the first\n    * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n    */\n-  private VariableLiveness isVariableReadBeforeKill(\n-      Node n, String variable) {\n+private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n     if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n-      if (NodeUtil.isLhs(n, n.getParent())) {\n-        // The expression to which the assignment is made is evaluated before\n-        // the RHS is evaluated (normal left to right evaluation) but the KILL\n-        // occurs after the RHS is evaluated.\n-        return VariableLiveness.KILL;\n-      } else {\n-        return VariableLiveness.READ;\n-      }\n+        if (NodeUtil.isLhs(n, n.getParent())) {\n+            // The expression to which the assignment is made is evaluated before\n+            // the RHS is evaluated (normal left to right evaluation) but the KILL\n+            // occurs after the RHS is evaluated.\n+            return VariableLiveness.KILL;\n+        } else if (NodeUtil.isAssignmentOp(n.getParent())\n+                && NodeUtil.isLhs(n.getParent().getFirstChild(), n)) {\n+            // This is an assignment whose RHS we're analyzing. We must check if\n+            // the variable being analyzed appears anywhere else in the expression\n+            // (e.g. x = y + z could be x = y + x + 1). If it does, the variable\n+            // is not killed by this assignment.\n+            VarChecker varChecker = new VarChecker(variable);\n+            Node expression = n.getNext();\n+            // If we're on an assign op, we need to check the RHS of the assign op\n+            if (NodeUtil.isAssignOp(n.getParent())) {\n+                expression = n.getParent().getLastChild();\n+            }\n+            expression.visit(varChecker);\n+            if (varChecker.foundVar()) {\n+                return VariableLiveness.READ;\n+            } else {\n+                return VariableLiveness.KILL;\n+            }\n+        } else {\n+            return VariableLiveness.READ;\n+        }\n     }\n \n     // Expressions are evaluated left-right, depth first.\n     for (Node child = n.getFirstChild();\n-        child != null; child = child.getNext()) {\n-      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n-        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n-        if (state != VariableLiveness.MAYBE_LIVE) {\n-          return state;\n+         child != null; child = child.getNext()) {\n+        if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n+            VariableLiveness state = isVariableReadBeforeKill(child, variable);\n+            if (state != VariableLiveness.MAYBE_LIVE) {\n+                return state;\n+            }\n         }\n-      }\n     }\n     return VariableLiveness.MAYBE_LIVE;\n-  }\n+}\n+\n+private static class VarChecker extends NodeVisitor {\n+    private final String variable;\n+    private boolean found = false;\n+\n+    VarChecker(String variable) {\n+        this.variable = variable;\n+    }\n+\n+    boolean foundVar() {\n+        return found;\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (n.isName() && variable.equals(n.getString())) {\n+            found = true;\n+        }\n+    }\n+}\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}