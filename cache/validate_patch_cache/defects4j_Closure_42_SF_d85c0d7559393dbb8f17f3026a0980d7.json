{
    "patch": "import com.google.javascript.jscomp.*;\nimport com.google.javascript.rhino.*;\nimport java.util.*;\n\npublic class IRFactory implements NodeTraversal.Callback, CompilerPass {\n  private AbstractCompiler compiler;\n  private ErrorReporter errorReporter;\n\n  public IRFactory(AbstractCompiler compiler) {\n    this.compiler = compiler;\n    this.errorReporter = new ErrorReporter(compiler);\n  }\n\n  @Override\n  public void process(Node externs, Node root) {\n    NodeTraversal.traverse(compiler, root, this);\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    Node replacement = null;\n    switch (n.getToken()) {\n      case ARRAYLIT:\n        replacement = processArrayLiteral(n);\n        break;\n      case ASSIGN:\n        replacement = processAssign(n);\n        break;\n      case BLOCK:\n        replacement = processBlock(n);\n        break;\n      case BREAK:\n        replacement = processBreakStatement(n);\n        break;\n      case CALL:\n        replacement = processCall(n);\n        break;\n      case CATCH:\n        replacement = processCatchClause(n);\n        break;\n      case CLASS:\n        replacement = processClass(n);\n        break;\n      case COMMA:\n        replacement = processCommaExpression(n);\n        break;\n      case CONDITIONAL:\n        replacement = processConditionalExpression(n);\n        break;\n      case CONST:\n        n.setToken(Token.LET);\n        replacement = n;\n        break;\n      case CONTINUE:\n        replacement = processContinueStatement(n);\n        break;\n      case DEBUGGER:\n        replacement = newNode(Token.EMPTY);\n        break;\n      case DO:\n        replacement = processDoLoop(n);\n        break;\n      case EMPTY:\n        replacement = processEmptyExpression(n);\n        break;\n      case EXPORT:\n        replacement =\n            processExport(n.getFirstChild(), n.getSecondChild(), n.getLineno(), n.getCharno());\n        if (replacement == null) {\n          n.detach();\n          return;\n        }\n        break;\n      case FOR:\n        replacement = processFor(n);\n        break;\n      case FOR_IN:\n        replacement = processForInLoop(n);\n        break;\n      case FUNCTION:\n        replacement = processFunction(n, parent);\n        break;\n      case GETPROP:\n        replacement = processGetProp(n);\n        break;\n      case IF:\n        replacement = processIf(n);\n        break;\n      case IMPORT:\n        errorReporter.error(\n            \"Import statements are not supported\", compiler.getInputName(n), n.getLineno(), \"\", 0);\n        n.detach();\n        return;\n      case LABEL:\n        replacement = processLabel(n);\n        break;\n      case LET:\n        // Let nodes are handled as if they are var nodes.\n        n.setToken(Token.VAR);\n        replacement = n;\n        break;\n      case NAME:\n        if (n.getString().equals(\"undefined\")) {\n          replacement = newNode(Token.VOID, Node.newNumber(0));\n        }\n        break;\n      case NEW:\n        replacement = processNew(n);\n        break;\n      case OBJECTLIT:\n        replacement = processObjectLiteral(n);\n        break;\n      case RETURN:\n        replacement = processReturn(n);\n        break;\n      case SCRIPT:\n        replacement = processScript(n);\n        break;\n      case SWITCH:\n        replacement = processSwitch(n);\n        break;\n      case TEMPLATELIT:\n        replacement = processTemplateLiteral(n);\n        break;\n      case THROW:\n        replacement = processThrow(n);\n        break;\n      case TRY:\n        replacement = processTry(n);\n        break;\n      case VAR:\n        replacement = processVar(n);\n        break;\n      case WHILE:\n        replacement = processWhile(n);\n        break;\n      case WITH:\n        errorReporter.error(\n            \"With statements are not supported\", compiler.getInputName(n), n.getLineno(), \"\", 0);\n        n.detach();\n        return;\n      default:\n        if (n.isExprResult()) {\n          replacement = processExpressionStatement(n);\n        }\n        break;\n    }\n\n    if (replacement != null) {\n      parent.replaceChild(n, replacement);\n      t.reportCodeChange();\n    }\n  }\n\n  private Node newNode(int type, Node... children) {\n    Node n = new Node(type);\n    for (Node child : children) {\n      if (child != null) {\n        n.addChildToBack(child);\n      }\n    }\n    return n;\n  }\n\n  private Node transform(AstNode node) {\n    if (node == null) {\n      return null;\n    } else if (node instanceof Name) {\n      return Node.newString(Token.NAME, ((Name) node).getIdentifier());\n    } else if (node instanceof NumberLiteral) {\n      return Node.newNumber(((NumberLiteral) node).getNumber());\n    } else if (node instanceof StringLiteral) {\n      return Node.newString(((StringLiteral) node).getValue());\n    } else if (node instanceof RegExpLiteral) {\n      return Node.newRegExp(((RegExpLiteral) node).getValue());\n    } else if (node instanceof ObjectLiteral) {\n      return transformObjectLiteral((ObjectLiteral) node);\n    } else if (node instanceof ArrayLiteral) {\n      return transformArrayLiteral((ArrayLiteral) node);\n    } else if (node instanceof FunctionNode) {\n      return transformFunction((FunctionNode) node);\n    } else if (node instanceof ObjectProperty) {\n      return transformObjectProperty((ObjectProperty) node);\n    } else if (node instanceof PropertyGet) {\n      return transformPropertyGet((PropertyGet) node);\n    } else if (node instanceof PropertySet) {\n      return transformPropertySet((PropertySet) node);\n    } else if (node instanceof InfixExpression) {\n      return transformInfixExpression((InfixExpression) node);\n    } else if (node instanceof PrefixExpression) {\n      return transformPrefixExpression((PrefixExpression) node);\n    } else if (node instanceof PostfixExpression) {\n      return transformPostfixExpression((PostfixExpression) node);\n    } else if (node instanceof KeywordLiteral) {\n      if (((KeywordLiteral) node).getType() == Token.NULL) {\n        return newNode(Token.NULL);\n      } else {\n        return newNode(Token.FALSE);\n      }\n    } else if (node instanceof EmptyExpression) {\n      return newNode(Token.EMPTY);\n    } else if (node instanceof ParenthesizedExpression) {\n      return transform(((ParenthesizedExpression) node).getExpression());\n    } else {\n      throw new UnsupportedOperationException(\"Invalid AstNode: \" + node);\n    }\n  }\n\n  private Node transformArrayLiteral(ArrayLiteral node) {\n    List<AstNode> elements = node.getElements();\n    Node[] children = new Node[elements.size()];\n    for (int i = 0; i < elements.size(); i++) {\n      children[i] = transform(elements.get(i));\n    }\n    return newNode(Token.ARRAYLIT, children);\n  }\n\n  private Node transformInfixExpression(InfixExpression node) {\n    Token type;\n    switch (node.getOperator()) {\n      case Token.ADD:\n        type = Token.ADD;\n        break;\n      case Token.AND:\n        type = Token.AND;\n        break;\n      case Token.BITOR:\n        type = Token.BITOR;\n        break;\n      case Token.BITXOR:\n        type = Token.BITXOR;\n        break;\n      case Token.BITAND:\n        type = Token.BITAND;\n        break;\n      case Token.DIV:\n        type = Token.DIV;\n        break;\n      case Token.EQ:\n        type = Token.EQ;\n        break;\n      case Token.GE:\n        type = Token.GE;\n        break;\n      case Token.GT:\n        type = Token.GT;\n        break;\n      case Token.IN:\n        type = Token.IN;\n        break;\n      case Token.INSTANCEOF:\n        type = Token.INSTANCEOF;\n        break;\n      case Token.LE:\n        type = Token.LE;\n        break;\n      case Token.LSH:\n        type = Token.LSH;\n        break;\n      case Token.LT:\n        type = Token.LT;\n        break;\n      case Token.MOD:\n        type = Token.MOD;\n        break;\n      case Token.MUL:\n        type = Token.MUL;\n        break;\n      case Token.NE:\n        type = Token.NE;\n        break;\n      case Token.OR:\n        type = Token.OR;\n        break;\n      case Token.RSH:\n        type = Token.RSH;\n        break;\n      case Token.SUB:\n        type = Token.SUB;\n        break;\n      case Token.URSH:\n        type = Token.URSH;\n        break;\n      case Token.EXPONENT:\n        type = Token.EXPONENT;\n        break;\n      default:\n        throw new UnsupportedOperationException(\"Invalid operator: \" + node.getOperator());\n    }\n    return newNode(type, transform(node.getLeft()), transform(node.getRight()));\n  }\n\n  private Node transformPrefixExpression(PrefixExpression node) {\n    Token type;\n    switch (node.getOperator()) {\n      case Token.BITNOT:\n        type = Token.BITNOT;\n        break;\n      case Token.DELPROP:\n        // We remove delete expressions before calling this method.\n        return null;\n      case Token.NEG:\n        type = Token.NEG;\n        break;\n      case Token.NOT:\n        type = Token.NOT;\n        break;\n      case Token.POS:\n        type = Token.POS;\n        break;\n      case Token.TYPEOF:\n        type = Token.TYPEOF;\n        break;\n      case Token.VOID:\n        type = Token.VOID;\n        break;\n      default:\n        throw new UnsupportedOperationException(\"Invalid operator: \" + node.getOperator());\n    }\n    return newNode(type, transform(node.getOperand()));\n  }\n\n  private Node transformPostfixExpression(PostfixExpression node) {\n    Token type;\n    switch (node.getOperator()) {\n      case Token.INC:\n        type = Token.INC;\n        break;\n      case Token.DEC:\n        type = Token.DEC;\n        break;\n      default:\n        throw new UnsupportedOperationException(\"Invalid operator: \" + node.getOperator());\n    }\n    return newNode(type, transform(node.getOperand()));\n  }\n\n  private Node transformFunction(FunctionNode node) {\n    Node name = null;\n    if (node.getFunctionName() != null) {\n      name = Node.newString(Token.NAME, node.getFunctionName().getIdentifier());\n    }\n    Node params = transformFunctionParams(node.getParams());\n    Node body = transform(node.getBody());\n    return newNode(Token.FUNCTION, name, params, body);\n  }\n\n  private Node transformFunctionParams(List<AstNode> params) {\n    Node[] children = new Node[params.size()];\n    for (int i = 0; i < params.size(); i++) {\n      children[i] = Node.newString(Token.NAME, ((Name) params.get(i)).getIdentifier());\n    }\n    return newNode(Token.PARAM_LIST, children);\n  }\n\n  private Node transformObjectLiteral(ObjectLiteral node) {\n    List<ObjectProperty> properties = node.getElements();\n    Node[] children = new Node[properties.size()];\n    for (int i = 0; i < properties.size(); i++) {\n      children[i] = transform(properties.get(i));\n    }\n    return newNode(Token.OBJECTLIT, children);\n  }\n\n  private Node transformObjectProperty(ObjectProperty node) {\n    Node key = transform(node.getLeft());\n    Node value = transform(node.getRight());\n    return newNode(Token.OBJECTLIT, newNode(Token.STRING_KEY, key), value);\n  }\n\n  private Node transformPropertyGet(PropertyGet node) {\n    Node target = transform(node.getTarget());\n    String propertyName = node.getProperty().getIdentifier();\n    Node property = Node.newString(Token.STRING, propertyName);\n    return newNode(Token.GETPROP, target, property);\n  }\n\n  private Node transformPropertySet(PropertySet node) {\n    Node target = transform(node.getTarget());\n    String propertyName = node.getProperty().getIdentifier();\n    Node property = Node.newString(Token.STRING, propertyName);\n    Node value = transform(node.getRight());\n    return newNode(Token.SETPROP, target, property, value);\n  }\n\n  private Node transformCallArgs(List<AstNode> args) {\n    Node[] children = new Node[args.size()];\n    for (int i = 0; i < args.size(); i++) {\n      children[i] = transform(args.get(i));\n    }\n    return newNode(Token.ARGUMENT_LIST, children);\n  }\n\n  private Node transformScript(Node node) {\n    Node newNode;\n    if (node.hasChildren()) {\n      newNode = processBlock(node);\n    } else {\n      newNode = Node.newString(Token.EMPTY, \"\");\n    }\n    addClosureVariables(newNode);\n    return newNode;\n  }\n\n  private Node transformIfStatement(IfStatement node) {\n    Node condition = transform(node.getCondition());\n    Node trueBranch = transform(node.getThenPart());\n    Node falseBranch = null;\n    if (node.getElsePart() != null) {\n      falseBranch = transform(node.getElsePart());\n    }\n    return newNode(Token.IF, condition, trueBranch, falseBranch);\n  }\n\n  private Node transformWhileLoop(WhileLoop node) {\n    Node condition = transform(node.getCondition());\n    Node body = transform(node.getBody());\n    return newNode(Token.WHILE, condition, body);\n  }\n\n  private Node transformDoLoop(DoLoop node) {\n    Node body = transform(node.getBody());\n    Node condition = transform(node.getCondition());\n    return newNode(Token.DO, body, condition);\n  }\n\n  private Node transformForLoop(ForLoop node) {\n    Node init = transform(node.getInitializer());\n    Node condition = transform(node.getCondition());\n    Node increment = transform(node.getIncrement());\n    Node body = transform(node.getBody());\n    return newNode(Toke",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..b77c6709 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,443 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.javascript.jscomp.*;\n+import com.google.javascript.rhino.*;\n+import java.util.*;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+public class IRFactory implements NodeTraversal.Callback, CompilerPass {\n+  private AbstractCompiler compiler;\n+  private ErrorReporter errorReporter;\n+\n+  public IRFactory(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+    this.errorReporter = new ErrorReporter(compiler);\n+  }\n+\n+  @Override\n+  public void process(Node externs, Node root) {\n+    NodeTraversal.traverse(compiler, root, this);\n+  }\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    Node replacement = null;\n+    switch (n.getToken()) {\n+      case ARRAYLIT:\n+        replacement = processArrayLiteral(n);\n+        break;\n+      case ASSIGN:\n+        replacement = processAssign(n);\n+        break;\n+      case BLOCK:\n+        replacement = processBlock(n);\n+        break;\n+      case BREAK:\n+        replacement = processBreakStatement(n);\n+        break;\n+      case CALL:\n+        replacement = processCall(n);\n+        break;\n+      case CATCH:\n+        replacement = processCatchClause(n);\n+        break;\n+      case CLASS:\n+        replacement = processClass(n);\n+        break;\n+      case COMMA:\n+        replacement = processCommaExpression(n);\n+        break;\n+      case CONDITIONAL:\n+        replacement = processConditionalExpression(n);\n+        break;\n+      case CONST:\n+        n.setToken(Token.LET);\n+        replacement = n;\n+        break;\n+      case CONTINUE:\n+        replacement = processContinueStatement(n);\n+        break;\n+      case DEBUGGER:\n+        replacement = newNode(Token.EMPTY);\n+        break;\n+      case DO:\n+        replacement = processDoLoop(n);\n+        break;\n+      case EMPTY:\n+        replacement = processEmptyExpression(n);\n+        break;\n+      case EXPORT:\n+        replacement =\n+            processExport(n.getFirstChild(), n.getSecondChild(), n.getLineno(), n.getCharno());\n+        if (replacement == null) {\n+          n.detach();\n+          return;\n+        }\n+        break;\n+      case FOR:\n+        replacement = processFor(n);\n+        break;\n+      case FOR_IN:\n+        replacement = processForInLoop(n);\n+        break;\n+      case FUNCTION:\n+        replacement = processFunction(n, parent);\n+        break;\n+      case GETPROP:\n+        replacement = processGetProp(n);\n+        break;\n+      case IF:\n+        replacement = processIf(n);\n+        break;\n+      case IMPORT:\n+        errorReporter.error(\n+            \"Import statements are not supported\", compiler.getInputName(n), n.getLineno(), \"\", 0);\n+        n.detach();\n+        return;\n+      case LABEL:\n+        replacement = processLabel(n);\n+        break;\n+      case LET:\n+        // Let nodes are handled as if they are var nodes.\n+        n.setToken(Token.VAR);\n+        replacement = n;\n+        break;\n+      case NAME:\n+        if (n.getString().equals(\"undefined\")) {\n+          replacement = newNode(Token.VOID, Node.newNumber(0));\n+        }\n+        break;\n+      case NEW:\n+        replacement = processNew(n);\n+        break;\n+      case OBJECTLIT:\n+        replacement = processObjectLiteral(n);\n+        break;\n+      case RETURN:\n+        replacement = processReturn(n);\n+        break;\n+      case SCRIPT:\n+        replacement = processScript(n);\n+        break;\n+      case SWITCH:\n+        replacement = processSwitch(n);\n+        break;\n+      case TEMPLATELIT:\n+        replacement = processTemplateLiteral(n);\n+        break;\n+      case THROW:\n+        replacement = processThrow(n);\n+        break;\n+      case TRY:\n+        replacement = processTry(n);\n+        break;\n+      case VAR:\n+        replacement = processVar(n);\n+        break;\n+      case WHILE:\n+        replacement = processWhile(n);\n+        break;\n+      case WITH:\n+        errorReporter.error(\n+            \"With statements are not supported\", compiler.getInputName(n), n.getLineno(), \"\", 0);\n+        n.detach();\n+        return;\n+      default:\n+        if (n.isExprResult()) {\n+          replacement = processExpressionStatement(n);\n+        }\n+        break;\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    if (replacement != null) {\n+      parent.replaceChild(n, replacement);\n+      t.reportCodeChange();\n     }\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  private Node newNode(int type, Node... children) {\n+    Node n = new Node(type);\n+    for (Node child : children) {\n+      if (child != null) {\n+        n.addChildToBack(child);\n       }\n-      return node;\n     }\n+    return n;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  private Node transform(AstNode node) {\n+    if (node == null) {\n+      return null;\n+    } else if (node instanceof Name) {\n+      return Node.newString(Token.NAME, ((Name) node).getIdentifier());\n+    } else if (node instanceof NumberLiteral) {\n+      return Node.newNumber(((NumberLiteral) node).getNumber());\n+    } else if (node instanceof StringLiteral) {\n+      return Node.newString(((StringLiteral) node).getValue());\n+    } else if (node instanceof RegExpLiteral) {\n+      return Node.newRegExp(((RegExpLiteral) node).getValue());\n+    } else if (node instanceof ObjectLiteral) {\n+      return transformObjectLiteral((ObjectLiteral) node);\n+    } else if (node instanceof ArrayLiteral) {\n+      return transformArrayLiteral((ArrayLiteral) node);\n+    } else if (node instanceof FunctionNode) {\n+      return transformFunction((FunctionNode) node);\n+    } else if (node instanceof ObjectProperty) {\n+      return transformObjectProperty((ObjectProperty) node);\n+    } else if (node instanceof PropertyGet) {\n+      return transformPropertyGet((PropertyGet) node);\n+    } else if (node instanceof PropertySet) {\n+      return transformPropertySet((PropertySet) node);\n+    } else if (node instanceof InfixExpression) {\n+      return transformInfixExpression((InfixExpression) node);\n+    } else if (node instanceof PrefixExpression) {\n+      return transformPrefixExpression((PrefixExpression) node);\n+    } else if (node instanceof PostfixExpression) {\n+      return transformPostfixExpression((PostfixExpression) node);\n+    } else if (node instanceof KeywordLiteral) {\n+      if (((KeywordLiteral) node).getType() == Token.NULL) {\n+        return newNode(Token.NULL);\n+      } else {\n+        return newNode(Token.FALSE);\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    } else if (node instanceof EmptyExpression) {\n+      return newNode(Token.EMPTY);\n+    } else if (node instanceof ParenthesizedExpression) {\n+      return transform(((ParenthesizedExpression) node).getExpression());\n+    } else {\n+      throw new UnsupportedOperationException(\"Invalid AstNode: \" + node);\n     }\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  private Node transformArrayLiteral(ArrayLiteral node) {\n+    List<AstNode> elements = node.getElements();\n+    Node[] children = new Node[elements.size()];\n+    for (int i = 0; i < elements.size(); i++) {\n+      children[i] = transform(elements.get(i));\n     }\n+    return newNode(Token.ARRAYLIT, children);\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  private Node transformInfixExpression(InfixExpression node) {\n+    Token type;\n+    switch (node.getOperator()) {\n+      case Token.ADD:\n+        type = Token.ADD;\n+        break;\n+      case Token.AND:\n+        type = Token.AND;\n+        break;\n+      case Token.BITOR:\n+        type = Token.BITOR;\n+        break;\n+      case Token.BITXOR:\n+        type = Token.BITXOR;\n+        break;\n+      case Token.BITAND:\n+        type = Token.BITAND;\n+        break;\n+      case Token.DIV:\n+        type = Token.DIV;\n+        break;\n+      case Token.EQ:\n+        type = Token.EQ;\n+        break;\n+      case Token.GE:\n+        type = Token.GE;\n+        break;\n+      case Token.GT:\n+        type = Token.GT;\n+        break;\n+      case Token.IN:\n+        type = Token.IN;\n+        break;\n+      case Token.INSTANCEOF:\n+        type = Token.INSTANCEOF;\n+        break;\n+      case Token.LE:\n+        type = Token.LE;\n+        break;\n+      case Token.LSH:\n+        type = Token.LSH;\n+        break;\n+      case Token.LT:\n+        type = Token.LT;\n+        break;\n+      case Token.MOD:\n+        type = Token.MOD;\n+        break;\n+      case Token.MUL:\n+        type = Token.MUL;\n+        break;\n+      case Token.NE:\n+        type = Token.NE;\n+        break;\n+      case Token.OR:\n+        type = Token.OR;\n+        break;\n+      case Token.RSH:\n+        type = Token.RSH;\n+        break;\n+      case Token.SUB:\n+        type = Token.SUB;\n+        break;\n+      case Token.URSH:\n+        type = Token.URSH;\n+        break;\n+      case Token.EXPONENT:\n+        type = Token.EXPONENT;\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(\"Invalid operator: \" + node.getOperator());\n     }\n+    return newNode(type, transform(node.getLeft()), transform(node.getRight()));\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  private Node transformPrefixExpression(PrefixExpression node) {\n+    Token type;\n+    switch (node.getOperator()) {\n+      case Token.BITNOT:\n+        type = Token.BITNOT;\n+        break;\n+      case Token.DELPROP:\n+        // We remove delete expressions before calling this method.\n+        return null;\n+      case Token.NEG:\n+        type = Token.NEG;\n+        break;\n+      case Token.NOT:\n+        type = Token.NOT;\n+        break;\n+      case Token.POS:\n+        type = Token.POS;\n+        break;\n+      case Token.TYPEOF:\n+        type = Token.TYPEOF;\n+        break;\n+      case Token.VOID:\n+        type = Token.VOID;\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(\"Invalid operator: \" + node.getOperator());\n     }\n+    return newNode(type, transform(node.getOperand()));\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  private Node transformPostfixExpression(PostfixExpression node) {\n+    Token type;\n+    switch (node.getOperator()) {\n+      case Token.INC:\n+        type = Token.INC;\n+        break;\n+      case Token.DEC:\n+        type = Token.DEC;\n+        break;\n+      default:\n+        throw new UnsupportedOperationException(\"Invalid operator: \" + node.getOperator());\n     }\n+    return newNode(type, transform(node.getOperand()));\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  private Node transformFunction(FunctionNode node) {\n+    Node name = null;\n+    if (node.getFunctionName() != null) {\n+      name = Node.newString(Token.NAME, node.getFunctionName().getIdentifier());\n     }\n+    Node params = transformFunctionParams(node.getParams());\n+    Node body = transform(node.getBody());\n+    return newNode(Token.FUNCTION, name, params, body);\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  private Node transformFunctionParams(List<AstNode> params) {\n+    Node[] children = new Node[params.size()];\n+    for (int i = 0; i < params.size(); i++) {\n+      children[i] = Node.newString(Token.NAME, ((Name) params.get(i)).getIdentifier());\n     }\n+    return newNode(Token.PARAM_LIST, children);\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  private Node transformObjectLiteral(ObjectLiteral node) {\n+    List<ObjectProperty> properties = node.getElements();\n+    Node[] children = new Node[properties.size()];\n+    for (int i = 0; i < properties.size(); i++) {\n+      children[i] = transform(properties.get(i));\n+    }\n+    return newNode(Token.OBJECTLIT, children);\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  private Node transformObjectProperty(ObjectProperty node) {\n+    Node key = transform(node.getLeft());\n+    Node value = transform(node.getRight());\n+    return newNode(Token.OBJECTLIT, newNode(Token.STRING_KEY, key), value);\n+  }\n+\n+  private Node transformPropertyGet(PropertyGet node) {\n+    Node target = transform(node.getTarget());\n+    String propertyName = node.getProperty().getIdentifier();\n+    Node property = Node.newString(Token.STRING, propertyName);\n+    return newNode(Token.GETPROP, target, property);\n+  }\n+\n+  private Node transformPropertySet(PropertySet node) {\n+    Node target = transform(node.getTarget());\n+    String propertyName = node.getProperty().getIdentifier();\n+    Node property = Node.newString(Token.STRING, propertyName);\n+    Node value = transform(node.getRight());\n+    return newNode(Token.SETPROP, target, property, value);\n+  }\n+\n+  private Node transformCallArgs(List<AstNode> args) {\n+    Node[] children = new Node[args.size()];\n+    for (int i = 0; i < args.size(); i++) {\n+      children[i] = transform(args.get(i));\n     }\n+    return newNode(Token.ARGUMENT_LIST, children);\n+  }\n+\n+  private Node transformScript(Node node) {\n+    Node newNode;\n+    if (node.hasChildren()) {\n+      newNode = processBlock(node);\n+    } else {\n+      newNode = Node.newString(Token.EMPTY, \"\");\n+    }\n+    addClosureVariables(newNode);\n+    return newNode;\n+  }\n+\n+  private Node transformIfStatement(IfStatement node) {\n+    Node condition = transform(node.getCondition());\n+    Node trueBranch = transform(node.getThenPart());\n+    Node falseBranch = null;\n+    if (node.getElsePart() != null) {\n+      falseBranch = transform(node.getElsePart());\n+    }\n+    return newNode(Token.IF, condition, trueBranch, falseBranch);\n+  }\n+\n+  private Node transformWhileLoop(WhileLoop node) {\n+    Node condition = transform(node.getCondition());\n+    Node body = transform(node.getBody());\n+    return newNode(Token.WHILE, condition, body);\n+  }\n+\n+  private Node transformDoLoop(DoLoop node) {\n+    Node body = transform(node.getBody());\n+    Node condition = transform(node.getCondition());\n+    return newNode(Token.DO, body, condition);\n+  }\n+\n+  private Node transformForLoop(ForLoop node) {\n+    Node init = transform(node.getInitializer());\n+    Node condition = transform(node.getCondition());\n+    Node increment = transform(node.getIncrement());\n+    Node body = transform(node.getBody());\n+    return newNode(Toke\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}