{
    "patch": "  private Node tryFoldShift(Node n, Node left, Node right) {\n    if (left.getType() == Token.NUMBER &&\n        right.getType() == Token.NUMBER) {\n\n      double result;\n      double lval = left.getDouble();\n      double rval = right.getDouble();\n      boolean isURSh = n.getType() == Token.URSH;\n\n      // check ranges. Shift amounts must be between 0 and 31, inclusive.\n      if (rval < 0 || rval >= 32) {\n        error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n        return n;\n      }\n      int lvalInt = (int) lval;\n      int rvalInt = (int) rval;\n      // If the left operand is not an integer or it is too big, throw an error.\n      if (lvalInt != lval) {\n        error(FRACTIONAL_BITWISE_OPERAND, left);\n        return n;\n      }\n      if (isURSh && lvalInt < 0) {\n        // Since there is no \">>>=\" operator in JavaScript, the parser\n        // changes all unsigned right shifts into signed right shifts\n        // if the number being shifted appears to be a signed integer.\n        error(SIGNED_RIGHT_SHIFT, n);\n        return n;\n      }\n      if (lvalInt < MIN_SAFE_INTEGER || lvalInt > MAX_SAFE_INTEGER) {\n        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n        return n;\n      }\n      // Do smis first for performance.\n      if (left.isInt() && right.isInt() && left.isNumber() && right.isNumber()) {\n        int leftVal = left.getInt();\n        if (n.getType() == Token.LSH) {\n          result = leftVal << rvalInt;\n        } else if (n.getType() == Token.RSH) {\n          result = leftVal >> rvalInt;\n        } else if (n.getType() == Token.URSH) {\n          result = leftVal >>> rvalInt;\n        } else {\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n        }\n        Node foldedNode = simplifyNumber(result);\n        if (foldedNode != null) {\n          return foldedNode;\n        }\n        return Node.newNumber(result);\n      } else {\n        long leftVal = left.getLong();\n        if (n.getType() == Token.LSH) {\n          // Use Integer.rotateLeft() instead of << to preserve the sign bit.\n          result = Integer.rotateLeft((int)leftVal, rvalInt);\n        } else if (n.getType() == Token.RSH) {\n          // Use Integer.rotateRight() instead of >> to preserve the sign bit.\n          result = Integer.rotateRight((int) leftVal, rvalInt);\n        } else if (n.getType() == Token.URSH) {\n          result = Ints.toUnsignedLong((int) leftVal) >>> rvalInt;\n        } else {\n          throw new AssertionError(\"Unknown shift operator: \" +\n              Node.tokenToName(n.getType()));\n        }\n        Node foldedNode = simplifyNumber(result);\n        if (foldedNode != null) {\n          return foldedNode;\n        }\n        return Node.newNumber(result);\n      }\n    }\n\n    return n;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex d6c194a3..5621a589 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -656,57 +656,69 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n       double result;\n       double lval = left.getDouble();\n       double rval = right.getDouble();\n+      boolean isURSh = n.getType() == Token.URSH;\n \n-      // check ranges.  We do not do anything that would clip the double to\n-      // a 32-bit range, since the user likely does not intend that.\n-      if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n-        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n-        return n;\n-      }\n-\n-      // only the lower 5 bits are used when shifting, so don't do anything\n-      // if the shift amount is outside [0,32)\n-      if (!(rval >= 0 && rval < 32)) {\n+      // check ranges. Shift amounts must be between 0 and 31, inclusive.\n+      if (rval < 0 || rval >= 32) {\n         error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n         return n;\n       }\n-\n-      // Convert the numbers to ints\n       int lvalInt = (int) lval;\n+      int rvalInt = (int) rval;\n+      // If the left operand is not an integer or it is too big, throw an error.\n       if (lvalInt != lval) {\n         error(FRACTIONAL_BITWISE_OPERAND, left);\n         return n;\n       }\n-\n-      int rvalInt = (int) rval;\n-      if (rvalInt != rval) {\n-        error(FRACTIONAL_BITWISE_OPERAND, right);\n+      if (isURSh && lvalInt < 0) {\n+        // Since there is no \">>>=\" operator in JavaScript, the parser\n+        // changes all unsigned right shifts into signed right shifts\n+        // if the number being shifted appears to be a signed integer.\n+        error(SIGNED_RIGHT_SHIFT, n);\n         return n;\n       }\n-\n-      switch (n.getType()) {\n-        case Token.LSH:\n-          result = lvalInt << rvalInt;\n-          break;\n-        case Token.RSH:\n-          result = lvalInt >> rvalInt;\n-          break;\n-        case Token.URSH:\n-          // JavaScript handles zero shifts on signed numbers differently than\n-          // Java as an Java int can not represent the unsigned 32-bit number\n-          // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n-          break;\n-        default:\n+      if (lvalInt < MIN_SAFE_INTEGER || lvalInt > MAX_SAFE_INTEGER) {\n+        error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+        return n;\n+      }\n+      // Do smis first for performance.\n+      if (left.isInt() && right.isInt() && left.isNumber() && right.isNumber()) {\n+        int leftVal = left.getInt();\n+        if (n.getType() == Token.LSH) {\n+          result = leftVal << rvalInt;\n+        } else if (n.getType() == Token.RSH) {\n+          result = leftVal >> rvalInt;\n+        } else if (n.getType() == Token.URSH) {\n+          result = leftVal >>> rvalInt;\n+        } else {\n+          throw new AssertionError(\"Unknown shift operator: \" +\n+              Node.tokenToName(n.getType()));\n+        }\n+        Node foldedNode = simplifyNumber(result);\n+        if (foldedNode != null) {\n+          return foldedNode;\n+        }\n+        return Node.newNumber(result);\n+      } else {\n+        long leftVal = left.getLong();\n+        if (n.getType() == Token.LSH) {\n+          // Use Integer.rotateLeft() instead of << to preserve the sign bit.\n+          result = Integer.rotateLeft((int)leftVal, rvalInt);\n+        } else if (n.getType() == Token.RSH) {\n+          // Use Integer.rotateRight() instead of >> to preserve the sign bit.\n+          result = Integer.rotateRight((int) leftVal, rvalInt);\n+        } else if (n.getType() == Token.URSH) {\n+          result = Ints.toUnsignedLong((int) leftVal) >>> rvalInt;\n+        } else {\n           throw new AssertionError(\"Unknown shift operator: \" +\n               Node.tokenToName(n.getType()));\n+        }\n+        Node foldedNode = simplifyNumber(result);\n+        if (foldedNode != null) {\n+          return foldedNode;\n+        }\n+        return Node.newNumber(result);\n       }\n-\n-      Node newNumber = Node.newNumber(result);\n-      n.getParent().replaceChild(n, newNumber);\n-      reportCodeChange();\n-\n-      return newNumber;\n     }\n \n     return n;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}