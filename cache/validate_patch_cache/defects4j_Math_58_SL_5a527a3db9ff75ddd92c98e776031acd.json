{
    "patch": "        final ParametricUnivariateSolver solver = new BracketingNthOrderBrentSolver();\n        final UnivariateFunction[] functions = new UnivariateFunction[] {\n                        new Gaussian.Parametric(), new Gaussian.Parametric(),\n                        new Gaussian.Parametric(), new Gaussian.Parametric()};\n        final double[] optimalValues = new double[4];\n\n        for (int i = 0; i < functions.length; i++) {\n            final AbstractCurveFitter.TheoreticalValuesFunction model\n                = new AbstractCurveFitter.TheoreticalValuesFunction(functions[i], getObservations());\n            optimalValues[i] = solver.solve(Integer.MAX_VALUE, model, getObservations()[i].getX(),\n                                             getObservations()[i].getX() + 1, AllowedSolution.ANY_SIDE).getPoint();\n        }\n\n        return optimalValues;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\nindex ae7ac3994..32339fb8a 100644\n--- a/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n+++ b/src/main/java/org/apache/commons/math/optimization/fitting/GaussianFitter.java\n@@ -118,7 +118,20 @@ public class GaussianFitter extends CurveFitter {\n      */\n     public double[] fit() {\n         final double[] guess = (new ParameterGuesser(getObservations())).guess();\n-        return fit(new Gaussian.Parametric(), guess);\n+        final ParametricUnivariateSolver solver = new BracketingNthOrderBrentSolver();\n+        final UnivariateFunction[] functions = new UnivariateFunction[] {\n+                        new Gaussian.Parametric(), new Gaussian.Parametric(),\n+                        new Gaussian.Parametric(), new Gaussian.Parametric()};\n+        final double[] optimalValues = new double[4];\n+\n+        for (int i = 0; i < functions.length; i++) {\n+            final AbstractCurveFitter.TheoreticalValuesFunction model\n+                = new AbstractCurveFitter.TheoreticalValuesFunction(functions[i], getObservations());\n+            optimalValues[i] = solver.solve(Integer.MAX_VALUE, model, getObservations()[i].getX(),\n+                                             getObservations()[i].getX() + 1, AllowedSolution.ANY_SIDE).getPoint();\n+        }\n+\n+        return optimalValues;\n     }\n \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}