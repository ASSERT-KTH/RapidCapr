{
    "patch": "class IRFactory implements NodeTransformer, IRFactory.TransformDispatcher {\n\n  private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\n          \"use strict\", \"use asm\");\n\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n\n  IRFactory(String sourceName, ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.errorReporter = errorReporter;\n  }\n\n  // Implementing TransformDispatcher\n\n  @Override\n  public Node process(Node n) throws RuntimeException {\n    if (!isDirective(n)) {\n      return dispatch(n);\n    } else {\n      return transformDirective(n);\n    }\n  }\n\n  @Override\n  public Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  @Override\n  public Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  public Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  public Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  @Override\n  public Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  @Override\n  public Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  public Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  public Node processForInLoop(ForInLoop loopNode) {\n    Node left;\n    // If the left-hand side of the for..in is a destructuring pattern,\n    // declare a temporary variable as the loop variable and destructure\n    // the value each iteration.\n    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n      left = newNode(\n          Token.VAR,\n          createDestructuringLhs(\n              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n    } else {\n      left = transform(loopNode.getIterator());\n    }\n\n    return newNode(\n        Token.FOR,\n        newNode(Token.EMPTY),\n        newNode(Token.EMPTY),\n        newNode(\n            Token.BLOCK,\n            left,\n            newNode(\n                Token.FOR_IN,\n                transform(loopNode.getIteratedObject()),\n                newNode(Token.EMPTY),\n                transformBlock(loopNode.getBody()))));\n  }\n\n  @Override\n  public Node processForLoop(ForLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getInitializer()),\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processFunctionCall(FunctionCall callNode) {\n    return newNode(\n        Token.CALL,\n        transform(callNode.getTarget()),\n        transformExprList(callNode.getArguments()));\n  }\n\n  @Override\n  public Node processFunctionNode(FunctionNode functionNode) {\n    if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n      return newNode(Token.FUNCTION, createName(functionNode.getName()), transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n    } else if (functionNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {\n      return newNode(Token.FUNCTION, createName(functionNode.getName()), transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n    } else if (functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION) {\n      return newNode(Token.FUNCTION, transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n    } else {\n      throw new RuntimeException(\"Invalid function type \" + functionNode.getFunctionType());\n    }\n  }\n\n  @Override\n  public Node processIfStatement(IfStatement statementNode) {\n    return newNode(\n        Token.IF,\n        transform(statementNode.getCondition()),\n        transformBlock(statementNode.getThenPart()),\n        transformBlock(statementNode.getElsePart()));\n  }\n\n  @Override\n  public Node processInfixExpression(InfixExpression exprNode) {\n    int type = transformTokenType(exprNode.getType());\n    if (type == Token.AND || type == Token.OR) {\n      Node lhs = transform(exprNode.getLeft());\n      Node rhs = transform(exprNode.getRight());\n      Node node = newNode(type, lhs, rhs.detachFromParent());\n      node.putProp(Node.SYMBOL_VAR, lhs.getSymbol());\n      return node;\n    } else {\n      return newNode(\n          type,\n          transform(exprNode.getLeft()),\n          transform(exprNode.getRight()));\n    }\n  }\n\n  @Override\n  public Node processLabeledStatement(LabeledStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()), createName(statementNode.getLabelName()));\n    node.addChildToBack(transform(statementNode.getStatement()));\n    return node;\n  }\n\n  @Override\n  public Node processName(Name nameNode) {\n    return Node.newString(nameNode.getString());\n  }\n\n  @Override\n  public Node processNewExpression(NewExpression callNode) {\n    return newNode(\n        Token.NEW,\n        transform(callNode.getTarget()),\n        transformExprList(callNode.getArguments()));\n  }\n\n  @Override\n  public Node processNumber(NumberLiteral numberNode) {\n    return newNode(Token.NUMBER, numberNode.getNumber());\n  }\n\n  @Override\n  public Node processObjectLiteral(ObjectLiteral node) {\n    Node objlit = newNode(Token.OBJECTLIT);\n    for (Node child : node.children()) {\n      int type = child.getType();\n      if (type == Token.GET || type == Token.SET) {\n        objlit.addChildToBack(\n            newNode(\n                type,\n                createName(child.getString()),\n                transformFunctionParams(child.getNext().getFirstChild()),\n                transformBlock(child.getNext().getLastChild().getFirstChild())));\n      } else {\n        objlit.addChildToBack(newNode(Token.STRING_KEY, Node.newString(child.getString()), transform(child.getLastChild())));\n      }\n    }\n    return objlit;\n  }\n\n  @Override\n  public Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n    AstNode expr = exprNode.getExpression();\n    if (expr instanceof FunctionNode) {\n      FunctionNode functionNode = (FunctionNode) expr;\n      if (functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION) {\n        // When we encounter an arrow function, we need to transform it as an IIFE.\n        // We create a new block to isolate the arrow function's scope, execute the\n        // arrow function, and immediately return its result.\n        List<AstNode> args = Collections.emptyList();\n        Node transformedFn =\n            newNode(Token.FUNCTION, createName(\"*function*\"), transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n        Node caller = newNode(\n            Token.NEW,\n            newNode(Token.THIS),\n            newNode(Token.ARRAYLIT));\n        Node assign = newNode(\n            Token.ASSIGN,\n            newNode(Token.GETPROP, caller, Node.newString(Token.NAME, \"callee\")),\n            transformedFn);\n        Node call = newNode(\n            Token.CALL,\n            newNode(Token.GETPROP, caller, Node.newString(Token.NAME, \"call\")),\n            caller.cloneNode(),\n            transformExprList(args));\n        Node ret = newNode(Token.RETURN, call);\n        return newNode(Token.BLOCK, newNode(Token.EXPR_VOID, assign), ret);\n      }\n    }\n    return transform(expr);\n  }\n\n  @Override\n  public Node processPropertyGet(PropertyGet node) {\n    Node result = newNode(Token.GETPROP, transform(node.getTarget()));\n    result.addChildToBack(Node.newString(Token.NAME, node.getProperty().getIdentifier()));\n    return result;\n  }\n\n  @Override\n  public Node processRegExpLiteral(RegExpLiteral regexp) {\n    return newNode(Token.REGEXP, regexp.getValue(), regexp.getFlags());\n  }\n\n  @Override\n  public Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = newNode(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      node.addChildToBack(transform(statementNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processString(StringLiteral stringNode) {\n    return newNode(Token.STRING, stringNode.getValue());\n  }\n\n  @Override\n  public Node processSwitchCase(SwitchCase caseNode) {\n    Node node;\n    if (caseNode.getExpression() == null) {\n      node = newNode(Token.DEFAULT);\n    } else {\n      node = newNode(Token.CASE, transform(caseNode.getExpression()));\n    }\n    node.addChildToBack(transformSwitch(caseNode.getStatements()));\n    return node;\n  }\n\n  @Override\n  public Node processSwitchStatement(SwitchStatement statementNode) {\n    return newNode(\n        Token.SWITCH,\n        transform(statementNode.getExpression()),\n        transformSwitch(statementNode.getCases()));\n  }\n\n  @Override\n  public Node processThrowStatement(ThrowStatement statementNode) {\n    return newNode(Token.THROW, transform(statementNode.getExpression()));\n  }\n\n  @Override\n  public Node processTryStatement(TryStatement statementNode) {\n    Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n    if (statementNode.getCatchBlock() != null) {\n      node.addChildToBack(transform(statementNode.getCatchBlock()));\n    }\n    if (statementNode.getFinallyBlock() != null) {\n      node.addChildToBack(transform(statementNode.getFinallyBlock()));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processUnaryExpression(UnaryExpression exprNode) {\n    return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n  }\n\n  @Override\n  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n    return newNode(\n        transformTokenType(declarationNode.getType()),\n        transformVariables(declarationNode.getVariables()));\n  }\n\n  @Override\n  public Node processVariableInitializer(VariableInitializer initializerNode) {\n    Node node = transform(initializerNode.getTarget());\n    if (initializerNode.getInitializer() != null) {\n      Node val = transform(initializerNode.getInitializer());\n      node.addChildToBack(val);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processWhileLoop(WhileLoop loopNode) {\n    return newNode(\n        Token.WHILE,\n        transform(loopNode.getCondition()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processWithStatement(WithStatement statementNode) {\n    return newNode(\n        Token.WITH,\n        transform(statementNode.getExpression()),\n        transformBlock(statementNode.getStatement()));\n  }\n\n  // Helper functions\n\n  private Node createDestructuringLhs(Node pattern, int type, Node varName) {\n    Node n = newNode(type, varName);\n    for (Node child : pattern.children()) {\n      switch (child.getType()) {\n        case Token.ARRAY_PATTERN:\n          n.addChildToBack(createDestructuringLhs(child, Token.ARRAY_PATTERN, null));\n          break;\n        case Token.OBJECT_PATTERN:\n          n.addChildToBack(createDestructuringLhs(child, Token.OBJECT_PATTERN, null));\n          break;\n        case Token.NAME:\n          if (varName != null) {\n            n.addChildToBack(varName.cloneTree());\n          } else {\n            n.addChildToBack(child.cloneTree());\n          }\n          break;\n        default:\n          throw new UnsupportedOperationException(\n              \"Invalid child of destructuring pattern: \" + child);\n      }\n    }\n    return n;\n  }\n\n  private Node createName(String name) {\n    return Node.newString(Token.NAME, name);\n  }\n\n  private ImmutableSet<String> createParameterSet(FunctionNode functionNode) {\n    ImmutableSet.Builder<String> builder = ImmutableSet.builder();\n    for (Node param : transformFunctionParams(functionNode.getParams()).children()) {\n      builder.add(param.getString());\n    }\n    return builder.build();\n  }\n\n  private Node createThis() {\n    return newNode(Token.THIS);\n  }\n\n  private boolean isDirective(Node n) {\n    if (!(n instanceof ExpressionStatement)) {\n      return false;\n    }\n\n    AstNode expr = ((ExpressionStatement) n).getExpression();\n    if (!(expr instanceof StringLiteral)) {\n    ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..53553843 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,427 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class IRFactory implements NodeTransformer, IRFactory.TransformDispatcher {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\n+          \"use strict\", \"use asm\");\n+\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+\n+  IRFactory(String sourceName, ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  // Implementing TransformDispatcher\n+\n+  @Override\n+  public Node process(Node n) throws RuntimeException {\n+    if (!isDirective(n)) {\n+      return dispatch(n);\n+    } else {\n+      return transformDirective(n);\n     }\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  @Override\n+  public Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  @Override\n+  public Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  @Override\n+  public Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  @Override\n+  public Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  public Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+  @Override\n+  public Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  public Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  public Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processForInLoop(ForInLoop loopNode) {\n+    Node left;\n+    // If the left-hand side of the for..in is a destructuring pattern,\n+    // declare a temporary variable as the loop variable and destructure\n+    // the value each iteration.\n+    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n+        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n+      left = newNode(\n+          Token.VAR,\n+          createDestructuringLhs(\n+              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n+    } else {\n+      left = transform(loopNode.getIterator());\n+    }\n+\n+    return newNode(\n+        Token.FOR,\n+        newNode(Token.EMPTY),\n+        newNode(Token.EMPTY),\n+        newNode(\n+            Token.BLOCK,\n+            left,\n+            newNode(\n+                Token.FOR_IN,\n+                transform(loopNode.getIteratedObject()),\n+                newNode(Token.EMPTY),\n+                transformBlock(loopNode.getBody()))));\n+  }\n+\n+  @Override\n+  public Node processForLoop(ForLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getInitializer()),\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processFunctionCall(FunctionCall callNode) {\n+    return newNode(\n+        Token.CALL,\n+        transform(callNode.getTarget()),\n+        transformExprList(callNode.getArguments()));\n+  }\n+\n+  @Override\n+  public Node processFunctionNode(FunctionNode functionNode) {\n+    if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n+      return newNode(Token.FUNCTION, createName(functionNode.getName()), transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n+    } else if (functionNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {\n+      return newNode(Token.FUNCTION, createName(functionNode.getName()), transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n+    } else if (functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION) {\n+      return newNode(Token.FUNCTION, transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n+    } else {\n+      throw new RuntimeException(\"Invalid function type \" + functionNode.getFunctionType());\n+    }\n+  }\n+\n+  @Override\n+  public Node processIfStatement(IfStatement statementNode) {\n+    return newNode(\n+        Token.IF,\n+        transform(statementNode.getCondition()),\n+        transformBlock(statementNode.getThenPart()),\n+        transformBlock(statementNode.getElsePart()));\n+  }\n+\n+  @Override\n+  public Node processInfixExpression(InfixExpression exprNode) {\n+    int type = transformTokenType(exprNode.getType());\n+    if (type == Token.AND || type == Token.OR) {\n+      Node lhs = transform(exprNode.getLeft());\n+      Node rhs = transform(exprNode.getRight());\n+      Node node = newNode(type, lhs, rhs.detachFromParent());\n+      node.putProp(Node.SYMBOL_VAR, lhs.getSymbol());\n+      return node;\n+    } else {\n       return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+          type,\n+          transform(exprNode.getLeft()),\n+          transform(exprNode.getRight()));\n     }\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  @Override\n+  public Node processLabeledStatement(LabeledStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()), createName(statementNode.getLabelName()));\n+    node.addChildToBack(transform(statementNode.getStatement()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processName(Name nameNode) {\n+    return Node.newString(nameNode.getString());\n+  }\n+\n+  @Override\n+  public Node processNewExpression(NewExpression callNode) {\n+    return newNode(\n+        Token.NEW,\n+        transform(callNode.getTarget()),\n+        transformExprList(callNode.getArguments()));\n+  }\n+\n+  @Override\n+  public Node processNumber(NumberLiteral numberNode) {\n+    return newNode(Token.NUMBER, numberNode.getNumber());\n+  }\n+\n+  @Override\n+  public Node processObjectLiteral(ObjectLiteral node) {\n+    Node objlit = newNode(Token.OBJECTLIT);\n+    for (Node child : node.children()) {\n+      int type = child.getType();\n+      if (type == Token.GET || type == Token.SET) {\n+        objlit.addChildToBack(\n+            newNode(\n+                type,\n+                createName(child.getString()),\n+                transformFunctionParams(child.getNext().getFirstChild()),\n+                transformBlock(child.getNext().getLastChild().getFirstChild())));\n+      } else {\n+        objlit.addChildToBack(newNode(Token.STRING_KEY, Node.newString(child.getString()), transform(child.getLastChild())));\n       }\n-      return node;\n     }\n+    return objlit;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  @Override\n+  public Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n+    AstNode expr = exprNode.getExpression();\n+    if (expr instanceof FunctionNode) {\n+      FunctionNode functionNode = (FunctionNode) expr;\n+      if (functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION) {\n+        // When we encounter an arrow function, we need to transform it as an IIFE.\n+        // We create a new block to isolate the arrow function's scope, execute the\n+        // arrow function, and immediately return its result.\n+        List<AstNode> args = Collections.emptyList();\n+        Node transformedFn =\n+            newNode(Token.FUNCTION, createName(\"*function*\"), transformFunctionParams(functionNode.getParams()), transformBlock(functionNode.getBody()));\n+        Node caller = newNode(\n+            Token.NEW,\n+            newNode(Token.THIS),\n+            newNode(Token.ARRAYLIT));\n+        Node assign = newNode(\n+            Token.ASSIGN,\n+            newNode(Token.GETPROP, caller, Node.newString(Token.NAME, \"callee\")),\n+            transformedFn);\n+        Node call = newNode(\n+            Token.CALL,\n+            newNode(Token.GETPROP, caller, Node.newString(Token.NAME, \"call\")),\n+            caller.cloneNode(),\n+            transformExprList(args));\n+        Node ret = newNode(Token.RETURN, call);\n+        return newNode(Token.BLOCK, newNode(Token.EXPR_VOID, assign), ret);\n+      }\n     }\n+    return transform(expr);\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  public Node processPropertyGet(PropertyGet node) {\n+    Node result = newNode(Token.GETPROP, transform(node.getTarget()));\n+    result.addChildToBack(Node.newString(Token.NAME, node.getProperty().getIdentifier()));\n+    return result;\n+  }\n+\n+  @Override\n+  public Node processRegExpLiteral(RegExpLiteral regexp) {\n+    return newNode(Token.REGEXP, regexp.getValue(), regexp.getFlags());\n+  }\n+\n+  @Override\n+  public Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(statementNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node processString(StringLiteral stringNode) {\n+    return newNode(Token.STRING, stringNode.getValue());\n+  }\n+\n+  @Override\n+  public Node processSwitchCase(SwitchCase caseNode) {\n+    Node node;\n+    if (caseNode.getExpression() == null) {\n+      node = newNode(Token.DEFAULT);\n+    } else {\n+      node = newNode(Token.CASE, transform(caseNode.getExpression()));\n     }\n+    node.addChildToBack(transformSwitch(caseNode.getStatements()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  public Node processSwitchStatement(SwitchStatement statementNode) {\n+    return newNode(\n+        Token.SWITCH,\n+        transform(statementNode.getExpression()),\n+        transformSwitch(statementNode.getCases()));\n+  }\n+\n+  @Override\n+  public Node processThrowStatement(ThrowStatement statementNode) {\n+    return newNode(Token.THROW, transform(statementNode.getExpression()));\n+  }\n+\n+  @Override\n+  public Node processTryStatement(TryStatement statementNode) {\n+    Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+    if (statementNode.getCatchBlock() != null) {\n+      node.addChildToBack(transform(statementNode.getCatchBlock()));\n+    }\n+    if (statementNode.getFinallyBlock() != null) {\n+      node.addChildToBack(transform(statementNode.getFinallyBlock()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  public Node processUnaryExpression(UnaryExpression exprNode) {\n+    return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n+    return newNode(\n+        transformTokenType(declarationNode.getType()),\n+        transformVariables(declarationNode.getVariables()));\n+  }\n+\n+  @Override\n+  public Node processVariableInitializer(VariableInitializer initializerNode) {\n+    Node node = transform(initializerNode.getTarget());\n+    if (initializerNode.getInitializer() != null) {\n+      Node val = transform(initializerNode.getInitializer());\n+      node.addChildToBack(val);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processWhileLoop(WhileLoop loopNode) {\n+    return newNode(\n+        Token.WHILE,\n+        transform(loopNode.getCondition()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processWithStatement(WithStatement statementNode) {\n+    return newNode(\n+        Token.WITH,\n+        transform(statementNode.getExpression()),\n+        transformBlock(statementNode.getStatement()));\n+  }\n+\n+  // Helper functions\n+\n+  private Node createDestructuringLhs(Node pattern, int type, Node varName) {\n+    Node n = newNode(type, varName);\n+    for (Node child : pattern.children()) {\n+      switch (child.getType()) {\n+        case Token.ARRAY_PATTERN:\n+          n.addChildToBack(createDestructuringLhs(child, Token.ARRAY_PATTERN, null));\n+          break;\n+        case Token.OBJECT_PATTERN:\n+          n.addChildToBack(createDestructuringLhs(child, Token.OBJECT_PATTERN, null));\n+          break;\n+        case Token.NAME:\n+          if (varName != null) {\n+            n.addChildToBack(varName.cloneTree());\n+          } else {\n+            n.addChildToBack(child.cloneTree());\n+          }\n+          break;\n+        default:\n+          throw new UnsupportedOperationException(\n+              \"Invalid child of destructuring pattern: \" + child);\n+      }\n+    }\n+    return n;\n+  }\n+\n+  private Node createName(String name) {\n+    return Node.newString(Token.NAME, name);\n+  }\n+\n+  private ImmutableSet<String> createParameterSet(FunctionNode functionNode) {\n+    ImmutableSet.Builder<String> builder = ImmutableSet.builder();\n+    for (Node param : transformFunctionParams(functionNode.getParams()).children()) {\n+      builder.add(param.getString());\n     }\n+    return builder.build();\n+  }\n+\n+  private Node createThis() {\n+    return newNode(Token.THIS);\n+  }\n+\n+  private boolean isDirective(Node n) {\n+    if (!(n instanceof ExpressionStatement)) {\n+      return false;\n+    }\n+\n+    AstNode expr = ((ExpressionStatement) n).getExpression();\n+    if (!(expr instanceof StringLiteral)) {\n+    \n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}