{
    "patch": "            if (hasInfiniteBounds) {\n                // If there is at least one finite bound, none can be infinite,\n                // because mixed cases are not supported by the current code.\n                final boolean hasLowerInfiniteBound = Double.isInfinite(lB[0]);\n                final boolean hasUpperInfiniteBound = Double.isInfinite(uB[0]);\n                for (int i = 1; i < lB.length; i++) {\n                    if (Double.isInfinite(lB[i]) != hasLowerInfiniteBound ||\n                        Double.isInfinite(uB[i]) != hasUpperInfiniteBound) {\n                        throw new NumberIsTooLargeException();\n                    }\n                }\n                // Convert API to internal handling of boundaries.\n                boundaries = new double[2][];\n                boundaries[0] = new double[hasLowerInfiniteBound ? 0 : lB.length];\n                boundaries[1] = new double[hasUpperInfiniteBound ? 0 : uB.length];\n                for (int i = 0, l = boundaries[0].length; i < l; i++) {\n                    boundaries[0][i] = lB[i];\n                    boundaries[1][i] = uB[i];\n                }\n                // Abort early if the normalization will overflow (cf. \"encode\" method).\n                if (encode(boundaries[0]) == null ||\n                    encode(boundaries[1]) == null) {\n                    throw new MathIllegalStateException();\n                }\n            }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 51d1c6428..cbc0d9cd2 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -537,6 +537,31 @@ public class CMAESOptimizer\n                 boundaries[1] = uB;\n \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            if (hasInfiniteBounds) {\n+                // If there is at least one finite bound, none can be infinite,\n+                // because mixed cases are not supported by the current code.\n+                final boolean hasLowerInfiniteBound = Double.isInfinite(lB[0]);\n+                final boolean hasUpperInfiniteBound = Double.isInfinite(uB[0]);\n+                for (int i = 1; i < lB.length; i++) {\n+                    if (Double.isInfinite(lB[i]) != hasLowerInfiniteBound ||\n+                        Double.isInfinite(uB[i]) != hasUpperInfiniteBound) {\n+                        throw new NumberIsTooLargeException();\n+                    }\n+                }\n+                // Convert API to internal handling of boundaries.\n+                boundaries = new double[2][];\n+                boundaries[0] = new double[hasLowerInfiniteBound ? 0 : lB.length];\n+                boundaries[1] = new double[hasUpperInfiniteBound ? 0 : uB.length];\n+                for (int i = 0, l = boundaries[0].length; i < l; i++) {\n+                    boundaries[0][i] = lB[i];\n+                    boundaries[1][i] = uB[i];\n+                }\n+                // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                if (encode(boundaries[0]) == null ||\n+                    encode(boundaries[1]) == null) {\n+                    throw new MathIllegalStateException();\n+                }\n+            }\n             }\n         } else {\n             // Convert API to internal handling of boundaries.",
    "result_reason": "error: no suitable constructor found for NumberIsTooLargeException()",
    "test_result": "ERROR"
}