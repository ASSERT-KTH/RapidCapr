{
    "patch": "// Don't traverse functions that are getting lent to a prototype.\nif (NodeUtil.isPrototypeProperty(parent)) {\n  return false;\n}\nNode grandparent = parent.getParent();\nif (grandparent == null) {\n  return true;\n}\nif (grandparent.getType() == Token.CALL &&\n    (grandparent.getFirstChild().getType() == Token.GETPROP ||\n     // .call and .apply are essentially bound methods and thus inherit\n     // this regardless of the calling context.\n     grandparent.getFirstChild().getType() == Token.GETELEM)) {\n  Node getProp = grandparent.getFirstChild();\n  if (getProp.getChildCount() == 2 &&\n      getProp.getLastChild().getString().equals(\"apply\")) {\n    // Normally, apply binds 'this' to the first argument of apply, or\n    // 'undefined' if it is passed an empty list. However, in the common case\n    // of passing the arguments object and a known argument list, we can infer\n    // the intended 'this' value in a way that's very useful for this use case.\n    //\n    // Externs typically define Function.prototype.apply as follows:\n    //\n    // Function.prototype.apply = function(self, args) {\n    //   ...\n    //   return f.apply(self, argsArray);\n    // };\n    //\n    // Therefore, the grandparent of the function should have the form:\n    //\n    // receiver.fn.apply(receiver, argumentArray);\n    //\n    // where we want to grab `receiver` as the `this` value. Note that\n    // in many cases the caller will actually use `.call` instead, but the\n    // handling for that case is identical.\n    Node potentialReceiver = grandparent.getSecondChild();\n    Node potentialArgArray = grandparent.getLastChild();\n    if (NodeUtil.isImmutableValue(potentialArgArray)) {\n      if (potentialArgArray.isArrayLit()) {\n        if (potentialArgArray.getChildCount() > 0 &&\n            NodeUtil.isImmutableValue(potentialArgArray.getFirstChild())) {\n          // Hoist LHS if there is one so it gets checked properly for\n          // whether it's a prototype mutation.\n          Node lhs = grandparent.getFirstChild().getFirstChild();\n          return isLvalueRoot(lhs);\n        }\n        return false;\n      } else {\n        List<Node> argNodes = potentialArgArray.children();\n        List<String> argStrings = new ArrayList<>(argNodes.size());\n        for (Node argNode : argNodes) {\n          if (!argNode.isString()) {\n            return false;\n          }\n          // Deduplicate property names by recording which ones we saw in a HashSet.\n          if (!argStrings.add(getPropStringValue(argNode))) {\n            return false;\n          }\n        }\n        // Handle the case where we know the argument list and the receiver.\n        if (potentialReceiver.isGetProp()) {\n          Node receiver = potentialReceiver.getFirstChild();\n          if (receiver.isName()) {\n            return !isThis((ScriptNode) root, receiver.getString());\n          }\n          // A quirk of some legacy code is that sometimes global\n          // constructors defined with the 'function C() {}.apply(obj, args);'\n          // idiom will pass a string literal instead of an identifier for\n          // the constructor's name, most likely because the obfuscator\n          // scrambled the latter.\n          if (receiver.isString()) {\n            // We don't need to check for direct references to 'this' because\n            // the STRING node coerces to a string primitive, not to the global\n            // object.\n            return !LooseEquality.isEqualString(\"this\", receiver.getString());\n          }\n        }\n        return false;\n      }\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..fa53a9fd 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,88 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+// Don't traverse functions that are getting lent to a prototype.\n+if (NodeUtil.isPrototypeProperty(parent)) {\n+  return false;\n+}\n+Node grandparent = parent.getParent();\n+if (grandparent == null) {\n+  return true;\n+}\n+if (grandparent.getType() == Token.CALL &&\n+    (grandparent.getFirstChild().getType() == Token.GETPROP ||\n+     // .call and .apply are essentially bound methods and thus inherit\n+     // this regardless of the calling context.\n+     grandparent.getFirstChild().getType() == Token.GETELEM)) {\n+  Node getProp = grandparent.getFirstChild();\n+  if (getProp.getChildCount() == 2 &&\n+      getProp.getLastChild().getString().equals(\"apply\")) {\n+    // Normally, apply binds 'this' to the first argument of apply, or\n+    // 'undefined' if it is passed an empty list. However, in the common case\n+    // of passing the arguments object and a known argument list, we can infer\n+    // the intended 'this' value in a way that's very useful for this use case.\n+    //\n+    // Externs typically define Function.prototype.apply as follows:\n+    //\n+    // Function.prototype.apply = function(self, args) {\n+    //   ...\n+    //   return f.apply(self, argsArray);\n+    // };\n+    //\n+    // Therefore, the grandparent of the function should have the form:\n+    //\n+    // receiver.fn.apply(receiver, argumentArray);\n+    //\n+    // where we want to grab `receiver` as the `this` value. Note that\n+    // in many cases the caller will actually use `.call` instead, but the\n+    // handling for that case is identical.\n+    Node potentialReceiver = grandparent.getSecondChild();\n+    Node potentialArgArray = grandparent.getLastChild();\n+    if (NodeUtil.isImmutableValue(potentialArgArray)) {\n+      if (potentialArgArray.isArrayLit()) {\n+        if (potentialArgArray.getChildCount() > 0 &&\n+            NodeUtil.isImmutableValue(potentialArgArray.getFirstChild())) {\n+          // Hoist LHS if there is one so it gets checked properly for\n+          // whether it's a prototype mutation.\n+          Node lhs = grandparent.getFirstChild().getFirstChild();\n+          return isLvalueRoot(lhs);\n+        }\n+        return false;\n+      } else {\n+        List<Node> argNodes = potentialArgArray.children();\n+        List<String> argStrings = new ArrayList<>(argNodes.size());\n+        for (Node argNode : argNodes) {\n+          if (!argNode.isString()) {\n+            return false;\n+          }\n+          // Deduplicate property names by recording which ones we saw in a HashSet.\n+          if (!argStrings.add(getPropStringValue(argNode))) {\n+            return false;\n+          }\n+        }\n+        // Handle the case where we know the argument list and the receiver.\n+        if (potentialReceiver.isGetProp()) {\n+          Node receiver = potentialReceiver.getFirstChild();\n+          if (receiver.isName()) {\n+            return !isThis((ScriptNode) root, receiver.getString());\n+          }\n+          // A quirk of some legacy code is that sometimes global\n+          // constructors defined with the 'function C() {}.apply(obj, args);'\n+          // idiom will pass a string literal instead of an identifier for\n+          // the constructor's name, most likely because the obfuscator\n+          // scrambled the latter.\n+          if (receiver.isString()) {\n+            // We don't need to check for direct references to 'this' because\n+            // the STRING node coerces to a string primitive, not to the global\n+            // object.\n+            return !LooseEquality.isEqualString(\"this\", receiver.getString());\n+          }\n+        }\n+        return false;\n+      }\n+    }\n+  }\n+}\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}