{
    "patch": "  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        if (node.getBooleanProp(Node.IS_NAMESPACE)) {\n          scope.inferSlotType(node.getFirstChild().getString(), type);\n        } else {\n          scope.inferSlotType(node.getString(), type);\n        }\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n\n        Node recv = node.getFirstChild();\n        while (recv.getType() == Token.GETPROP) {\n          qualifiedName = recv.getQualifiedName() + \".\" + qualifiedName;\n          recv = recv.getFirstChild();\n        }\n\n        if (recv.isThis()) {\n          scope.inferQualifiedThis(qualifiedName, origType, type);\n        } else {\n          scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        }\n\n        break;\n\n      // \"this\" references aren't currently modeled in the CFG.\n      //   however, we can infer their types from the function signature.\n      //   the actual reference to \"this\" still causes a runtime type error.\n      case Token.THIS:\n        scope.inferSlotType(\"this\", type);\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n            node.toStringTree());\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..feb144f0 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -157,7 +157,11 @@ public abstract class ChainableReverseAbstractInterpreter\n   protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n     switch (node.getType()) {\n       case Token.NAME:\n-        scope.inferSlotType(node.getString(), type);\n+        if (node.getBooleanProp(Node.IS_NAMESPACE)) {\n+          scope.inferSlotType(node.getFirstChild().getString(), type);\n+        } else {\n+          scope.inferSlotType(node.getString(), type);\n+        }\n         break;\n \n       case Token.GETPROP:\n@@ -166,10 +170,27 @@ public abstract class ChainableReverseAbstractInterpreter\n \n         JSType origType = node.getJSType();\n         origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n-        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+\n+        Node recv = node.getFirstChild();\n+        while (recv.getType() == Token.GETPROP) {\n+          qualifiedName = recv.getQualifiedName() + \".\" + qualifiedName;\n+          recv = recv.getFirstChild();\n+        }\n+\n+        if (recv.isThis()) {\n+          scope.inferQualifiedThis(qualifiedName, origType, type);\n+        } else {\n+          scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+        }\n+\n         break;\n \n-        // \"this\" references aren't currently modeled in the CFG.\n+      // \"this\" references aren't currently modeled in the CFG.\n+      //   however, we can infer their types from the function signature.\n+      //   the actual reference to \"this\" still causes a runtime type error.\n+      case Token.THIS:\n+        scope.inferSlotType(\"this\", type);\n+        break;\n \n       default:\n         throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}