{
    "patch": "    static boolean canCollapseExceptionHandlers(Node fn) {\n      if (fn == null || !fn.isFunction()) {\n        return false;\n      }\n\n      if (!fn.getBooleanProp(Node.FUNCTION_PROP_TAKES_ARGUMENTS)) {\n        return false;\n      }\n\n      Node body = NodeUtil.getFunctionBody(fn);\n      if (body == null || !MinimizeExitPointsCallback.hasEarlyReturnOrLabel(body)) {\n        return false;\n      }\n\n      List<Node> mutations = new ArrayList<>();\n      int numExceptionHandlers = 0;\n      \n      for (Node child = body.getFirstChild(); child != null; child = child.getNext()) {\n        if (child.isTry()) {\n          numExceptionHandlers++;\n\n          Node tryBlock = child.getFirstChild();\n          Node catchBlock = tryBlock.getNext();\n          Node finallyBlock = catchBlock.getNext();\n\n          if (finallyBlock != null && catchBlock.getNumberOfChildren() > 0) {\n            // Can't collapse if there's a finally block and a catch block.\n            return false;\n          }\n\n          Node newBody = null;\n          if (finallyBlock != null) {\n            newBody = finallyBlock.removeChildren();\n          }\n\n          if (catchBlock.getNumberOfChildren() > 0) {\n            for (Node exceptionType : catchBlock.children()) {\n              Node exceptionName = exceptionType.getFirstChild();\n              Node origNode = exceptionName.getLastChild();\n              Node initializer = exceptionName.getFirstChild();\n              if (initializer == null) {\n                initializer = IR.name(\"undefined\");\n              } else if (!initializer.isName()) {\n                initializer = IR.name(\"unknown\");\n              }\n              // the origNode's grandparent may be null, so we can't use\n              // removeChildNoDetach. Hence use t.replaceWith\n              t.replaceWith(origNode, initializer.cloneTree());\n              Node newDecl = IR.var(exceptionName.cloneNode(), IR.name(MAKE_REPLACEMENTS_METHOD));\n              newDecl.putBooleanProp(Node.MODULE_EXPORT, false);\n              newDecl.useSourceInfoFromForTree(fn);\n              mutations.add(IR.exprResult(newDecl).useSourceInfoFromForTree(fn));\n            }\n          }\n\n          if (newBody == null && catchBlock.getNumberOfChildren() == 0) {\n            continue;\n          }              \n          \n          if (newBody == null) {\n            newBody = IR.block();\n          }\n          tryBlock.replaceWith(newBody);\n          newBody.addChildToFront(tryBlock);\n          if (catchBlock.getNumberOfChildren() > 0) {\n            // if there was a catch block, add it back\n            newBody.addChildToBack(catchBlock.detachChildren());\n          }\n        }\n      }\n\n      if (numExceptionHandlers == 0) {\n          return false;\n      }\n\n      Node newBody = null;\n\n      if (mutations.size() > 0) {\n        Node declsContainer = IR.block(mutations);\n        declsContainer.useSourceInfoFromForTree(fn);\n        NodeUtil.addFeatureToScript(fn, Feature.MODULES);\n        ModuleImportProcessor.wrapModule(\n            t.getInputId(), fn, declsContainer, true, false, compiler);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..9591d9ea 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,89 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+    static boolean canCollapseExceptionHandlers(Node fn) {\n+      if (fn == null || !fn.isFunction()) {\n+        return false;\n+      }\n+\n+      if (!fn.getBooleanProp(Node.FUNCTION_PROP_TAKES_ARGUMENTS)) {\n+        return false;\n+      }\n+\n+      Node body = NodeUtil.getFunctionBody(fn);\n+      if (body == null || !MinimizeExitPointsCallback.hasEarlyReturnOrLabel(body)) {\n+        return false;\n+      }\n+\n+      List<Node> mutations = new ArrayList<>();\n+      int numExceptionHandlers = 0;\n+      \n+      for (Node child = body.getFirstChild(); child != null; child = child.getNext()) {\n+        if (child.isTry()) {\n+          numExceptionHandlers++;\n+\n+          Node tryBlock = child.getFirstChild();\n+          Node catchBlock = tryBlock.getNext();\n+          Node finallyBlock = catchBlock.getNext();\n+\n+          if (finallyBlock != null && catchBlock.getNumberOfChildren() > 0) {\n+            // Can't collapse if there's a finally block and a catch block.\n+            return false;\n+          }\n+\n+          Node newBody = null;\n+          if (finallyBlock != null) {\n+            newBody = finallyBlock.removeChildren();\n+          }\n+\n+          if (catchBlock.getNumberOfChildren() > 0) {\n+            for (Node exceptionType : catchBlock.children()) {\n+              Node exceptionName = exceptionType.getFirstChild();\n+              Node origNode = exceptionName.getLastChild();\n+              Node initializer = exceptionName.getFirstChild();\n+              if (initializer == null) {\n+                initializer = IR.name(\"undefined\");\n+              } else if (!initializer.isName()) {\n+                initializer = IR.name(\"unknown\");\n+              }\n+              // the origNode's grandparent may be null, so we can't use\n+              // removeChildNoDetach. Hence use t.replaceWith\n+              t.replaceWith(origNode, initializer.cloneTree());\n+              Node newDecl = IR.var(exceptionName.cloneNode(), IR.name(MAKE_REPLACEMENTS_METHOD));\n+              newDecl.putBooleanProp(Node.MODULE_EXPORT, false);\n+              newDecl.useSourceInfoFromForTree(fn);\n+              mutations.add(IR.exprResult(newDecl).useSourceInfoFromForTree(fn));\n+            }\n+          }\n+\n+          if (newBody == null && catchBlock.getNumberOfChildren() == 0) {\n+            continue;\n+          }              \n+          \n+          if (newBody == null) {\n+            newBody = IR.block();\n+          }\n+          tryBlock.replaceWith(newBody);\n+          newBody.addChildToFront(tryBlock);\n+          if (catchBlock.getNumberOfChildren() > 0) {\n+            // if there was a catch block, add it back\n+            newBody.addChildToBack(catchBlock.detachChildren());\n+          }\n+        }\n+      }\n+\n+      if (numExceptionHandlers == 0) {\n+          return false;\n+      }\n+\n+      Node newBody = null;\n+\n+      if (mutations.size() > 0) {\n+        Node declsContainer = IR.block(mutations);\n+        declsContainer.useSourceInfoFromForTree(fn);\n+        NodeUtil.addFeatureToScript(fn, Feature.MODULES);\n+        ModuleImportProcessor.wrapModule(\n+            t.getInputId(), fn, declsContainer, true, false, compiler);\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}