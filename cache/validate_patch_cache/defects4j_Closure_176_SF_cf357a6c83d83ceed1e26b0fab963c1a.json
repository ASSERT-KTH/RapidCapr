{
    "patch": "void maybeSetDeclaredType(\n    Scope scope, Node n, FlowScope fnEnter, JSType declaredType, JSDocInfo info,\n    Node parent) {\n  // Use the declared type to refine a declared function's return type only if\n  // it was explicitly specified with @type.\n  if (declaredType != null && (info == null || info.hasType())) {\n    if (n.isFunction()) {\n      fnEnter = fnEnter.inferSlotType(\"return\", declaredType, true);\n    } else {\n      n.setJSType(declaredType);\n    }\n  }\n\n  JSType actualJSType = getJSType(n);\n  boolean isFunction = n.isFunction();\n\n  // Infer formal parameter types from the function node only if it's\n  // a simple function declaration and we didn't get one from the JSDoc.\n  // Infer formal parameter types from the context (e.g., function call,\n  // prototype method def) if they weren't filled in from elsewhere.\n  if (isFunction && info != null && info.getParameterCount() > 0) {\n    fillInParameterTypesFromJSDoc(fnEnter, n, info, parent);\n  } else {\n    switch (parent.getToken()) {\n      case Token.FUNCTION: {\n        Node grandparent = parent.getParent();\n        if (grandparent.isAssign() &&\n            grandparent.getFirstChild().isObjectLit()) {\n          // Don't add or refine param types in object literals\n        } else if (!isFunction) {\n          fillInParameterTypes(fnEnter, n);\n        }\n        break;\n      }\n\n      case Token.SCRIPT:\n        Preconditions.checkState(scope.isGlobal());\n        fillInParameterTypes(fnEnter, n);\n        break;\n\n      case Token.CATCH:\n        fillCatchParamType(fnEnter, n);\n        break;\n\n      case Token.METHOD_DEF:\n      case Token.GETTER_DEF:\n      case Token.SETTER_DEF:\n        fillClassMethodTypes(fnEnter, n);\n        break;\n\n      case Token.NEW:\n        JSType t = getJSType(parent.getFirstChild());\n        if (t != null && t.isFunctionType()) {\n          fillInParameterTypesFromCallNode(fnEnter, parent);\n        }\n        break;\n\n      case Token.CALL:\n      case Token.OPTCHAIN_CALL:\n        fillInParameterTypesFromCallNode(fnEnter, parent);\n        break;\n\n      case Token.ASSIGN: {\n        Node lhs = parent.getFirstChild();\n        if (lhs.isArrayPattern() || lhs.isObjectPattern()) {\n          fillInParameterTypes(fnEnter, n);\n        }\n        break;\n      }\n\n      default:\n        Node firstArgument = null;\n        if (NodeUtil.isInvocationTarget(parent)) {\n          firstArgument = parent.getNext();\n        } else if (parent.isDestructuringLhs()) {\n          fillDestructuringParamTypes(fnEnter, n);\n        } else if (parent.isComputedProp() || parent.isOptChain()) {\n          firstArgument = parent.getNext();\n        }\n        if (firstArgument != null) {\n          getTypeTransformations(firstArgument).setExpectedType(\n              getJSType(n), null /* declaration */, fnEnter);\n        }\n        break;\n    }\n  }\n\n  if (actualJSType != null) {\n    // Infer return types from function body.\n    Node actualJsDocNode = getActualJsDocNode(n);\n    JSDocInfo returnJsDocInfo =\n        actualJsDocNode != null ? actualJsDocNode.getJSDocInfo() : null;\n    JSType returnType = null;\n    if (returnJsDocInfo != null) {\n      returnType = returnJsDocInfo.getReturnType();\n    }\n    if (returnType == null &&\n        NodeUtil.getEnclosingType(n, Token.SCRIPT) == null) {\n      returnType = unknownType;\n    }\n\n    inferReturnType(fnEnter, actualJSType, returnType);\n  }\n\n  if (info != null && info.isDefine()) {\n    inferDefineType(fnEnter, n, info);\n  }\n\n  JSType inferredType;\n  if (isFunction) {\n    inferredType = fnEnter.inferSlotType(\"return\", null, false);\n  } else {\n    inferredType = lookupType(n);\n    if (inferredType != null) {\n      inferredType = inferredType.specialize(fnEnter);\n    } else {\n      inferredType = fnEnter.getTypeIfRefined(n);\n      if (inferredType == null) {\n        inferredType = fnEnter.getInferredTypeOf(n);\n        if (inferredType == null) {\n          inferredType = unknownType;\n        }\n      }\n    }\n  }\n\n  if (info != null) {\n    checkNotNullableArguments(n, info, inferredType, fnEnter);\n    checkTypesArePresent(n, info, inferredType, fnEnter);\n    checkEnumAlias(n, info, inferredType, fnEnter);\n    checkConstAlias(n, info, inferredType, fnEnter);\n  }\n\n  if (isFunction && info != null && info.hasThisType()) {\n    ObjectType rcvrType = ObjectType.cast(info.getThisType().evaluate(scope, getTypeRegistry()));\n    if (rcvrType != null && rcvrType.isFunctionPrototypeType()) {\n      // It's not very useful to refine this to just \"Function\"\n      // if all we have is \"function(this:NonFunctionType)\",\n      // so skip this refinement in that case.\n      JSType fnType = fnEnter.getTypeOfThis();\n      if (fnType != null && !fnType.isEquivalentTo(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE))) {\n        JSType refinedRcvrType =\n            rcvrType.instantiateGenerics(Collections.singletonList(fnType));\n        fnEnter = fnEnter.inferSlotType(\"this\", refinedRcvrType, true);\n      }\n    } else {\n      fnEnter = fnEnter.inferSlotType(\"this\", rcvrType, true);\n    }\n  }\n\n  if (isFunction) {\n    fnEnter.unspecialize();\n    if (!fnEnter.isComplete()) {\n      // Functions are treated like implicit blocks in the\n      // type inference system, so we might reach the end of\n      // the control flow before \"return\" has been seen.\n      fnEnter.finishGraph();\n      fnEnter = fnEnter.createChildFlowState();\n      fnEnter.inferSlotType(\"return\", unknownType, true);\n    }\n    Node wrapper = IR.function(IR.name(\"\"), IR.paramList(), n.getLastChild());\n    wrapper.setJSType(inferredType);\n    wrapper.getFirstChild().setInputId(n.getInputId());\n    wrapper.copyInformationFrom(n);\n    wrapper.setOriginalName(n.getOriginalName());\n    n.replaceWith(wrapper);\n    scope = scope.getClosestHoistScope();\n    if (scope.isDeclared(\"arguments\", false)) {\n      scope.getVar(\"arguments\").setType(\n          getNativeType(JSTypeNative.ARGUMENTS_TYPE));\n    }\n    if (parent.isClassMembers()) {\n      provider.getCollector().addCandidateClassMethod(\n          new CandidateClassMethod(\n              parent, scope, fnEnter.getThisType(), fnEnter,\n              registry, parent.getParent()));\n    }\n  } else {\n    n.setJSType(inferredType);\n  }\n\n  if (NodeUtil.isLValue(n)) {\n    JSType targetType = getJSType(getBestLValue(n));\n    if (actualJSType != null) {\n      targetType = targetType.specialize(fnEnter);\n      if (!actualJSType.isSubtypeOf(targetType)) {\n        warnings.add(JSError.make(n, typeMismatch(actualJSType, targetType)));\n      }\n    }\n    getTypeTransformations(n).setTargetType(targetType, null /* declaration */);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..2f10165f 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,109 +521,198 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n+void maybeSetDeclaredType(\n+    Scope scope, Node n, FlowScope fnEnter, JSType declaredType, JSDocInfo info,\n+    Node parent) {\n+  // Use the declared type to refine a declared function's return type only if\n+  // it was explicitly specified with @type.\n+  if (declaredType != null && (info == null || info.hasType())) {\n+    if (n.isFunction()) {\n+      fnEnter = fnEnter.inferSlotType(\"return\", declaredType, true);\n+    } else {\n+      n.setJSType(declaredType);\n+    }\n+  }\n \n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n+  JSType actualJSType = getJSType(n);\n+  boolean isFunction = n.isFunction();\n+\n+  // Infer formal parameter types from the function node only if it's\n+  // a simple function declaration and we didn't get one from the JSDoc.\n+  // Infer formal parameter types from the context (e.g., function call,\n+  // prototype method def) if they weren't filled in from elsewhere.\n+  if (isFunction && info != null && info.getParameterCount() > 0) {\n+    fillInParameterTypesFromJSDoc(fnEnter, n, info, parent);\n+  } else {\n+    switch (parent.getToken()) {\n+      case Token.FUNCTION: {\n+        Node grandparent = parent.getParent();\n+        if (grandparent.isAssign() &&\n+            grandparent.getFirstChild().isObjectLit()) {\n+          // Don't add or refine param types in object literals\n+        } else if (!isFunction) {\n+          fillInParameterTypes(fnEnter, n);\n+        }\n+        break;\n+      }\n \n+      case Token.SCRIPT:\n+        Preconditions.checkState(scope.isGlobal());\n+        fillInParameterTypes(fnEnter, n);\n+        break;\n \n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n+      case Token.CATCH:\n+        fillCatchParamType(fnEnter, n);\n+        break;\n \n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n+      case Token.METHOD_DEF:\n+      case Token.GETTER_DEF:\n+      case Token.SETTER_DEF:\n+        fillClassMethodTypes(fnEnter, n);\n+        break;\n+\n+      case Token.NEW:\n+        JSType t = getJSType(parent.getFirstChild());\n+        if (t != null && t.isFunctionType()) {\n+          fillInParameterTypesFromCallNode(fnEnter, parent);\n         }\n         break;\n-      case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n+\n+      case Token.CALL:\n+      case Token.OPTCHAIN_CALL:\n+        fillInParameterTypesFromCallNode(fnEnter, parent);\n+        break;\n+\n+      case Token.ASSIGN: {\n+        Node lhs = parent.getFirstChild();\n+        if (lhs.isArrayPattern() || lhs.isObjectPattern()) {\n+          fillInParameterTypes(fnEnter, n);\n         }\n+        break;\n+      }\n \n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n+      default:\n+        Node firstArgument = null;\n+        if (NodeUtil.isInvocationTarget(parent)) {\n+          firstArgument = parent.getNext();\n+        } else if (parent.isDestructuringLhs()) {\n+          fillDestructuringParamTypes(fnEnter, n);\n+        } else if (parent.isComputedProp() || parent.isOptChain()) {\n+          firstArgument = parent.getNext();\n+        }\n+        if (firstArgument != null) {\n+          getTypeTransformations(firstArgument).setExpectedType(\n+              getJSType(n), null /* declaration */, fnEnter);\n+        }\n         break;\n     }\n   }\n \n-  /**\n-   * Defines a property if the property has not been defined yet.\n-   */\n-  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n-    String propName = getprop.getLastChild().getString();\n-    Node obj = getprop.getFirstChild();\n-    JSType nodeType = getJSType(obj);\n-    ObjectType objectType = ObjectType.cast(\n-        nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n-        getJSType(syntacticScope.getRootNode()).isConstructor();\n-\n-    if (objectType == null) {\n-      registry.registerPropertyOnType(propName, nodeType);\n+  if (actualJSType != null) {\n+    // Infer return types from function body.\n+    Node actualJsDocNode = getActualJsDocNode(n);\n+    JSDocInfo returnJsDocInfo =\n+        actualJsDocNode != null ? actualJsDocNode.getJSDocInfo() : null;\n+    JSType returnType = null;\n+    if (returnJsDocInfo != null) {\n+      returnType = returnJsDocInfo.getReturnType();\n+    }\n+    if (returnType == null &&\n+        NodeUtil.getEnclosingType(n, Token.SCRIPT) == null) {\n+      returnType = unknownType;\n+    }\n+\n+    inferReturnType(fnEnter, actualJSType, returnType);\n+  }\n+\n+  if (info != null && info.isDefine()) {\n+    inferDefineType(fnEnter, n, info);\n+  }\n+\n+  JSType inferredType;\n+  if (isFunction) {\n+    inferredType = fnEnter.inferSlotType(\"return\", null, false);\n+  } else {\n+    inferredType = lookupType(n);\n+    if (inferredType != null) {\n+      inferredType = inferredType.specialize(fnEnter);\n     } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n-        boolean staticPropCreation = false;\n-        Node maybeAssignStm = getprop.getParent().getParent();\n-        if (syntacticScope.isGlobal() &&\n-            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n-          String propCreationFilename = maybeAssignStm.getSourceFileName();\n-          Node ctor = objectType.getOwnerFunction().getSource();\n-          if (ctor != null &&\n-              ctor.getSourceFileName().equals(propCreationFilename)) {\n-            staticPropCreation = true;\n-          }\n-        }\n-        if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n+      inferredType = fnEnter.getTypeIfRefined(n);\n+      if (inferredType == null) {\n+        inferredType = fnEnter.getInferredTypeOf(n);\n+        if (inferredType == null) {\n+          inferredType = unknownType;\n         }\n       }\n+    }\n+  }\n+\n+  if (info != null) {\n+    checkNotNullableArguments(n, info, inferredType, fnEnter);\n+    checkTypesArePresent(n, info, inferredType, fnEnter);\n+    checkEnumAlias(n, info, inferredType, fnEnter);\n+    checkConstAlias(n, info, inferredType, fnEnter);\n+  }\n+\n+  if (isFunction && info != null && info.hasThisType()) {\n+    ObjectType rcvrType = ObjectType.cast(info.getThisType().evaluate(scope, getTypeRegistry()));\n+    if (rcvrType != null && rcvrType.isFunctionPrototypeType()) {\n+      // It's not very useful to refine this to just \"Function\"\n+      // if all we have is \"function(this:NonFunctionType)\",\n+      // so skip this refinement in that case.\n+      JSType fnType = fnEnter.getTypeOfThis();\n+      if (fnType != null && !fnType.isEquivalentTo(getNativeType(JSTypeNative.FUNCTION_INSTANCE_TYPE))) {\n+        JSType refinedRcvrType =\n+            rcvrType.instantiateGenerics(Collections.singletonList(fnType));\n+        fnEnter = fnEnter.inferSlotType(\"this\", refinedRcvrType, true);\n+      }\n+    } else {\n+      fnEnter = fnEnter.inferSlotType(\"this\", rcvrType, true);\n+    }\n+  }\n+\n+  if (isFunction) {\n+    fnEnter.unspecialize();\n+    if (!fnEnter.isComplete()) {\n+      // Functions are treated like implicit blocks in the\n+      // type inference system, so we might reach the end of\n+      // the control flow before \"return\" has been seen.\n+      fnEnter.finishGraph();\n+      fnEnter = fnEnter.createChildFlowState();\n+      fnEnter.inferSlotType(\"return\", unknownType, true);\n+    }\n+    Node wrapper = IR.function(IR.name(\"\"), IR.paramList(), n.getLastChild());\n+    wrapper.setJSType(inferredType);\n+    wrapper.getFirstChild().setInputId(n.getInputId());\n+    wrapper.copyInformationFrom(n);\n+    wrapper.setOriginalName(n.getOriginalName());\n+    n.replaceWith(wrapper);\n+    scope = scope.getClosestHoistScope();\n+    if (scope.isDeclared(\"arguments\", false)) {\n+      scope.getVar(\"arguments\").setType(\n+          getNativeType(JSTypeNative.ARGUMENTS_TYPE));\n+    }\n+    if (parent.isClassMembers()) {\n+      provider.getCollector().addCandidateClassMethod(\n+          new CandidateClassMethod(\n+              parent, scope, fnEnter.getThisType(), fnEnter,\n+              registry, parent.getParent()));\n+    }\n+  } else {\n+    n.setJSType(inferredType);\n+  }\n+\n+  if (NodeUtil.isLValue(n)) {\n+    JSType targetType = getJSType(getBestLValue(n));\n+    if (actualJSType != null) {\n+      targetType = targetType.specialize(fnEnter);\n+      if (!actualJSType.isSubtypeOf(targetType)) {\n+        warnings.add(JSError.make(n, typeMismatch(actualJSType, targetType)));\n+      }\n+    }\n+    getTypeTransformations(n).setTargetType(targetType, null /* declaration */);\n+  }\n+}\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}