{
    "patch": "public void collect(JSModule module, Scope scope, Node n) {\n  Node parent = n.getParent();\n\n  String name;\n  boolean isSet = false;\n  Name.Type type = Name.Type.OTHER;\n  boolean isPropAssign = false;\n\n  switch (n.getType()) {\n    case Token.GETTER_DEF:\n    case Token.SETTER_DEF:\n    case Token.STRING_KEY:\n      // This may be a key in an object literal declaration.\n      name = null;\n      if (parent != null && parent.isObjectLit()) {\n        name = getNameForObjLitKey(n);\n      }\n      if (name == null) {\n        return;\n      }\n      isSet = true;\n      switch (n.getType()) {\n        case Token.STRING_KEY:\n          type = getValueType(n.getFirstChild());\n          break;\n        case Token.GETTER_DEF:\n          type = Name.Type.GET;\n          break;\n        case Token.SETTER_DEF:\n          type = Name.Type.SET;\n          break;\n        default:\n          throw new IllegalStateException(\"unexpected:\" + n);\n      }\n      break;\n    case Token.NAME:\n      // This may be a variable get or set.\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.VAR:\n            isSet = true;\n            Node rvalue = n.getFirstChild();\n            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n            break;\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n            }\n            break;\n          case Token.GETPROP:\n            return;\n          case Token.FUNCTION:\n            Node grand = parent.getParent();\n            if (grand == null || NodeUtil.isFunctionExpression(parent)) {\n              return;\n            }\n            isSet = true;\n            type = Name.Type.FUNCTION;\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getString();\n      Scope closestScope = scope.getClosestHoistScope();\n      boolean found = false;\n      while (!found && closestScope != null) {\n        Var var = closestScope.getVar(name);\n        if (var != null) {\n          // Ensure the type of the variable is known before we add a reference to it.\n          if (var.isTypeInferred() || var.getType() != null) {\n            found = true;\n            break;\n          }\n        }\n        closestScope = closestScope.getParent();\n      }\n      if (!found) {\n        return;\n      }\n      break;\n    case Token.GETPROP:\n      // This may be a namespaced name get or set.\n      if (parent != null) {\n        switch (parent.getType()) {\n          case Token.ASSIGN:\n            if (parent.getFirstChild() == n) {\n              isSet = true;\n              type = getValueType(n.getNext());\n              isPropAssign = true;\n            }\n            break;\n          case Token.INC:\n          case Token.DEC:\n            isSet = true;\n            type = Name.Type.OTHER;\n            break;\n          case Token.GETPROP:\n            return;\n          default:\n            if (NodeUtil.isAssignmentOp(parent) &&\n                    parent.getFirstChild() == n) {\n              isSet = true;\n              type = Name.Type.OTHER;\n            }\n        }\n      }\n      name = n.getQualifiedName();\n      if (name == null) {\n        return;\n      }\n      break;\n    default:\n      return;\n  }\n\n  // We are only interested in global names.\n  if (!isGlobalNameReference(name, scope)) {\n    return;\n  }\n\n  if (isSet) {\n    if (isGlobalScope(scope)) {\n      handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n    } else {\n      handleSetFromLocal(module, scope, n, parent, name);\n    }\n  } else {\n    handleGet(module, scope, n, parent, name);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/GlobalNamespace.java b/src/com/google/javascript/jscomp/GlobalNamespace.java\nindex 639318df..f3c8a152 100644\n--- a/src/com/google/javascript/jscomp/GlobalNamespace.java\n+++ b/src/com/google/javascript/jscomp/GlobalNamespace.java\n@@ -303,131 +303,147 @@ class GlobalNamespace\n       return true;\n     }\n \n-    public void collect(JSModule module, Scope scope, Node n) {\n-      Node parent = n.getParent();\n-\n-      String name;\n-      boolean isSet = false;\n-      Name.Type type = Name.Type.OTHER;\n-      boolean isPropAssign = false;\n-\n+public void collect(JSModule module, Scope scope, Node n) {\n+  Node parent = n.getParent();\n+\n+  String name;\n+  boolean isSet = false;\n+  Name.Type type = Name.Type.OTHER;\n+  boolean isPropAssign = false;\n+\n+  switch (n.getType()) {\n+    case Token.GETTER_DEF:\n+    case Token.SETTER_DEF:\n+    case Token.STRING_KEY:\n+      // This may be a key in an object literal declaration.\n+      name = null;\n+      if (parent != null && parent.isObjectLit()) {\n+        name = getNameForObjLitKey(n);\n+      }\n+      if (name == null) {\n+        return;\n+      }\n+      isSet = true;\n       switch (n.getType()) {\n+        case Token.STRING_KEY:\n+          type = getValueType(n.getFirstChild());\n+          break;\n         case Token.GETTER_DEF:\n+          type = Name.Type.GET;\n+          break;\n         case Token.SETTER_DEF:\n-        case Token.STRING_KEY:\n-          // This may be a key in an object literal declaration.\n-          name = null;\n-          if (parent != null && parent.isObjectLit()) {\n-            name = getNameForObjLitKey(n);\n-          }\n-          if (name == null) {\n-            return;\n-          }\n-          isSet = true;\n-          switch (n.getType()) {\n-            case Token.STRING_KEY:\n-              type = getValueType(n.getFirstChild());\n-              break;\n-            case Token.GETTER_DEF:\n-              type = Name.Type.GET;\n-              break;\n-            case Token.SETTER_DEF:\n-              type = Name.Type.SET;\n-              break;\n-            default:\n-              throw new IllegalStateException(\"unexpected:\" + n);\n-          }\n+          type = Name.Type.SET;\n           break;\n-        case Token.NAME:\n-          // This may be a variable get or set.\n-          if (parent != null) {\n-            switch (parent.getType()) {\n-              case Token.VAR:\n-                isSet = true;\n-                Node rvalue = n.getFirstChild();\n-                type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n-                break;\n-              case Token.ASSIGN:\n-                if (parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = getValueType(n.getNext());\n-                }\n-                break;\n-              case Token.GETPROP:\n-                return;\n-              case Token.FUNCTION:\n-                Node gramps = parent.getParent();\n-                if (gramps == null || NodeUtil.isFunctionExpression(parent)) {\n-                  return;\n-                }\n-                isSet = true;\n-                type = Name.Type.FUNCTION;\n-                break;\n-              case Token.INC:\n-              case Token.DEC:\n-                isSet = true;\n-                type = Name.Type.OTHER;\n-                break;\n-              default:\n-                if (NodeUtil.isAssignmentOp(parent) &&\n-                    parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = Name.Type.OTHER;\n-                }\n+        default:\n+          throw new IllegalStateException(\"unexpected:\" + n);\n+      }\n+      break;\n+    case Token.NAME:\n+      // This may be a variable get or set.\n+      if (parent != null) {\n+        switch (parent.getType()) {\n+          case Token.VAR:\n+            isSet = true;\n+            Node rvalue = n.getFirstChild();\n+            type = rvalue == null ? Name.Type.OTHER : getValueType(rvalue);\n+            break;\n+          case Token.ASSIGN:\n+            if (parent.getFirstChild() == n) {\n+              isSet = true;\n+              type = getValueType(n.getNext());\n             }\n-          }\n-          name = n.getString();\n-          break;\n-        case Token.GETPROP:\n-          // This may be a namespaced name get or set.\n-          if (parent != null) {\n-            switch (parent.getType()) {\n-              case Token.ASSIGN:\n-                if (parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = getValueType(n.getNext());\n-                  isPropAssign = true;\n-                }\n-                break;\n-              case Token.INC:\n-              case Token.DEC:\n-                isSet = true;\n-                type = Name.Type.OTHER;\n-                break;\n-              case Token.GETPROP:\n-                return;\n-              default:\n-                if (NodeUtil.isAssignmentOp(parent) &&\n+            break;\n+          case Token.GETPROP:\n+            return;\n+          case Token.FUNCTION:\n+            Node grand = parent.getParent();\n+            if (grand == null || NodeUtil.isFunctionExpression(parent)) {\n+              return;\n+            }\n+            isSet = true;\n+            type = Name.Type.FUNCTION;\n+            break;\n+          case Token.INC:\n+          case Token.DEC:\n+            isSet = true;\n+            type = Name.Type.OTHER;\n+            break;\n+          default:\n+            if (NodeUtil.isAssignmentOp(parent) &&\n                     parent.getFirstChild() == n) {\n-                  isSet = true;\n-                  type = Name.Type.OTHER;\n-                }\n+              isSet = true;\n+              type = Name.Type.OTHER;\n             }\n+        }\n+      }\n+      name = n.getString();\n+      Scope closestScope = scope.getClosestHoistScope();\n+      boolean found = false;\n+      while (!found && closestScope != null) {\n+        Var var = closestScope.getVar(name);\n+        if (var != null) {\n+          // Ensure the type of the variable is known before we add a reference to it.\n+          if (var.isTypeInferred() || var.getType() != null) {\n+            found = true;\n+            break;\n           }\n-          name = n.getQualifiedName();\n-          if (name == null) {\n-            return;\n-          }\n-          break;\n-        default:\n-          return;\n+        }\n+        closestScope = closestScope.getParent();\n       }\n-\n-      // We are only interested in global names.\n-      if (!isGlobalNameReference(name, scope)) {\n+      if (!found) {\n         return;\n       }\n-\n-      if (isSet) {\n-        if (isGlobalScope(scope)) {\n-          handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n-        } else {\n-          handleSetFromLocal(module, scope, n, parent, name);\n+      break;\n+    case Token.GETPROP:\n+      // This may be a namespaced name get or set.\n+      if (parent != null) {\n+        switch (parent.getType()) {\n+          case Token.ASSIGN:\n+            if (parent.getFirstChild() == n) {\n+              isSet = true;\n+              type = getValueType(n.getNext());\n+              isPropAssign = true;\n+            }\n+            break;\n+          case Token.INC:\n+          case Token.DEC:\n+            isSet = true;\n+            type = Name.Type.OTHER;\n+            break;\n+          case Token.GETPROP:\n+            return;\n+          default:\n+            if (NodeUtil.isAssignmentOp(parent) &&\n+                    parent.getFirstChild() == n) {\n+              isSet = true;\n+              type = Name.Type.OTHER;\n+            }\n         }\n-      } else {\n-        handleGet(module, scope, n, parent, name);\n       }\n+      name = n.getQualifiedName();\n+      if (name == null) {\n+        return;\n+      }\n+      break;\n+    default:\n+      return;\n+  }\n+\n+  // We are only interested in global names.\n+  if (!isGlobalNameReference(name, scope)) {\n+    return;\n+  }\n+\n+  if (isSet) {\n+    if (isGlobalScope(scope)) {\n+      handleSetFromGlobal(module, scope, n, parent, name, isPropAssign, type);\n+    } else {\n+      handleSetFromLocal(module, scope, n, parent, name);\n     }\n+  } else {\n+    handleGet(module, scope, n, parent, name);\n+  }\n+}\n \n     /**\n      * Gets the fully qualified name corresponding to an object literal key,",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}