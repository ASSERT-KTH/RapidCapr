{
    "patch": "class TransformDispatcher implements TypeSafeDispatcher<Node> {\n    protected Compiler compiler;\n    protected ErrorReporter errorReporter;\n    protected ScriptNode currentScriptOrFn;\n    protected Set<String> allowedFunctionNames;\n\n    TransformDispatcher(Compiler compiler) {\n        this.compiler = compiler;\n        this.errorReporter = compiler.getErrorReporter();\n    }\n\n    void setCurrentScriptOrFn(ScriptNode scriptOrFn) {\n        currentScriptOrFn = scriptOrFn;\n    }\n\n    void setAllowedFunctionNames(Set<String> allowedNames) {\n        allowedFunctionNames = allowedNames;\n    }\n\n    @Override\n    public Node visit(AstNode node) {\n        throw new IllegalArgumentException(node.toString());\n    }\n\n    @Override\n    public Node visitArrayComprehension(ArrayComprehension node) {\n        return TransformArrayComp.transformArrayComp(node, this);\n    }\n\n    @Override\n    public Node visitArrayLiteral(ArrayLiteral node) {\n        Node arrayLiteral = newNode(Token.ARRAYLIT);\n        List<AstNode> elements = node.getElements();\n        for (int i = 0; i < elements.size(); i++) {\n            Node child;\n            AstNode element = elements.get(i);\n            if (element.getType() == Token.COMMA) {\n                child = newNode(Token.EMPTY);\n                child.setLineno(element.getLineno());\n            } else if (element.getType() == Token.INITIALIZER) {\n                child = transformFromAssignable(element);\n            } else {\n                child = transform(element);\n            }\n            arrayLiteral.addChildToBack(child);\n        }\n        arrayLiteral.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n        arrayLiteral.putProp(Node.ORIGINAL_NAME, node.getOriginalName());\n        return arrayLiteral;\n    }\n\n    @Override\n    public Node visitAssignment(Assignment node) {\n        Node left = transform(node.getLeft());\n        Node right = transform(node.getRight());\n        left.addChildToBack(stripParens(right));\n        return left;\n    }\n\n    @Override\n    public Node visitBinaryOperation(BinaryOperator node) {\n        if (node instanceof InfixExpression) {\n            return transformInfixExpression((InfixExpression) node);\n        }\n        return transform(node.getLeft(), node.getRight(), node.getType());\n    }\n\n    @Override\n    public Node visitBlock(Block node) {\n        return processBlock(node); // call to abstract method\n    }\n\n    @Override\n    public Node visitBreakStatement(BreakStatement node) {\n        Node result = newNode(Token.BREAK);\n        result.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n        if (node.getBreakLabel() != null) {\n            result.addChildToBack(transform(node.getBreakLabel()));\n        }\n        return result;\n    }\n\n    @Override\n    public Node visitCatchClause(CatchClause node) {\n        return processCatchClause(node); // call to abstract method\n    }\n\n    @Override\n    public Node visitConditionalExpression(ConditionalExpression node) {\n        return processConditionalExpression(node); // call to abstract method\n    }\n\n    @Override\n    public Node visitContinueStatement(ContinueStatement node) {\n        Node result = newNode(Token.CONTINUE);\n        result.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n        if (node.getLabel() != null) {\n            result.addChildToBack(transform(node.getLabel()));\n        }\n        return result;\n    }\n\n    @Override\n    public Node visitDoLoop(DoLoop node) {\n        return processDoLoop(node); // call to abstract method\n    }\n\n    @Override\n    public Node visitElementGet(ElementGet node) {\n        return processElementGet(node); // call to abstract method\n    }\n\n    @Override\n    public Node visitEmptyExpression(EmptyExpression node) {\n        Node result = newNode(Token.EMPTY);\n        result.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n        return result;\n    }\n\n    @Override\n    public Node visitExpressionStatement(ExpressionStatement node) {\n        return processExpressionStatement(node); // call to abstract method\n    }\n\n    @Override\n    public Node visitForInLoop(ForInLoop node) {\n        return transformForInLoop(node);\n    }\n\n    private Node transformForInLoop(ForInLoop node) {\n        Node result = newNode(Token.FOR);\n\n        Node left = transform(node.getIterator());\n        if (!left.hasChildren()) {\n            // This can only happen if there is a syntax error in the\n            // for loop declaration.\n            throw new RuntimeException(\"invalid left-hand side of for-in/for-of\");\n        }\n\n        result.setLineno(node.getLineno());\n        result.addChildToBack(left);\n\n        Node right = transform(node.getIteratedObject());\n        right = new Node(Token.PARENTHETIC, right);\n        result.addChildToBack(right);\n\n        Node body = transform(node.getBody());\n        result.addChildToBack(body);\n\n        result.putProp(Node.FOR_POSITION, node.getForPosition());\n        result.putProp(Node.IN_POSITION, node.getInPosition());\n        return result;\n    }\n\n    @Override\n    publi",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..3eb6b77c 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -385,182 +385,163 @@ public class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher implements TypeSafeDispatcher<Node> {\n+    protected Compiler compiler;\n+    protected ErrorReporter errorReporter;\n+    protected ScriptNode currentScriptOrFn;\n+    protected Set<String> allowedFunctionNames;\n+\n+    TransformDispatcher(Compiler compiler) {\n+        this.compiler = compiler;\n+        this.errorReporter = compiler.getErrorReporter();\n+    }\n+\n+    void setCurrentScriptOrFn(ScriptNode scriptOrFn) {\n+        currentScriptOrFn = scriptOrFn;\n+    }\n \n-      int nType = n.getType();\n-      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n-          n.getFirstChild().getType() == Token.STRING &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    void setAllowedFunctionNames(Set<String> allowedNames) {\n+        allowedFunctionNames = allowedNames;\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node visit(AstNode node) {\n+        throw new IllegalArgumentException(node.toString());\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node visitArrayComprehension(ArrayComprehension node) {\n+        return TransformArrayComp.transformArrayComp(node, this);\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    public Node visitArrayLiteral(ArrayLiteral node) {\n+        Node arrayLiteral = newNode(Token.ARRAYLIT);\n+        List<AstNode> elements = node.getElements();\n+        for (int i = 0; i < elements.size(); i++) {\n+            Node child;\n+            AstNode element = elements.get(i);\n+            if (element.getType() == Token.COMMA) {\n+                child = newNode(Token.EMPTY);\n+                child.setLineno(element.getLineno());\n+            } else if (element.getType() == Token.INITIALIZER) {\n+                child = transformFromAssignable(element);\n+            } else {\n+                child = transform(element);\n+            }\n+            arrayLiteral.addChildToBack(child);\n+        }\n+        arrayLiteral.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n+        arrayLiteral.putProp(Node.ORIGINAL_NAME, node.getOriginalName());\n+        return arrayLiteral;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public Node visitAssignment(Assignment node) {\n+        Node left = transform(node.getLeft());\n+        Node right = transform(node.getRight());\n+        left.addChildToBack(stripParens(right));\n+        return left;\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node visitBinaryOperation(BinaryOperator node) {\n+        if (node instanceof InfixExpression) {\n+            return transformInfixExpression((InfixExpression) node);\n+        }\n+        return transform(node.getLeft(), node.getRight(), node.getType());\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node visitBlock(Block node) {\n+        return processBlock(node); // call to abstract method\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node visitBreakStatement(BreakStatement node) {\n+        Node result = newNode(Token.BREAK);\n+        result.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n+        if (node.getBreakLabel() != null) {\n+            result.addChildToBack(transform(node.getBreakLabel()));\n+        }\n+        return result;\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node visitCatchClause(CatchClause node) {\n+        return processCatchClause(node); // call to abstract method\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node visitConditionalExpression(ConditionalExpression node) {\n+        return processConditionalExpression(node); // call to abstract method\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    public Node visitContinueStatement(ContinueStatement node) {\n+        Node result = newNode(Token.CONTINUE);\n+        result.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n+        if (node.getLabel() != null) {\n+            result.addChildToBack(transform(node.getLabel()));\n+        }\n+        return result;\n     }\n \n     @Override\n-    Node processForLoop(ForLoop loopNode) {\n-      Node node = newNode(\n-          Token.FOR,\n-          transform(loopNode.getInitializer()),\n-          transform(loopNode.getCondition()),\n-          transform(loopNode.getIncrement()));\n-      node.addChildToBack(transformBlock(loopNode.getBody()));\n-      return node;\n+    public Node visitDoLoop(DoLoop node) {\n+        return processDoLoop(node); // call to abstract method\n     }\n \n     @Override\n-    Node processFunctionCall(FunctionCall callNode) {\n-      Node node = newNode(transformTokenType(callNode.getType()),\n-                           transform(callNode.getTarget()));\n-      for (AstNode child : callNode.getArguments()) {\n-        node.addChildToBack(transform(child));\n-      }\n+    public Node visitElementGet(ElementGet node) {\n+        return processElementGet(node); // call to abstract method\n+    }\n \n-      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n-      node.setLineno(callNode.getLineno());\n-      node.setCharno(position2charno(leftParamPos));\n-      return node;\n+    @Override\n+    public Node visitEmptyExpression(EmptyExpression node) {\n+        Node result = newNode(Token.EMPTY);\n+        result.putProp(Node.SYNTAX_ERROR_LINENO, node.getLineno());\n+        return result;\n     }\n \n     @Override\n-    Node processFunctionNode(FunctionNode functionNode) {\n-      Name name = functionNode.getFunctionName();\n-      Boolean isUnnamedFunction = false;\n-      if (name == null) {\n-        name = new Name();\n-        name.setIdentifier(\"\");\n-        isUnnamedFunction = true;\n-      }\n-      Node node = newNode(Token.FUNCTION);\n-      Node newName = transform(name);\n-      if (isUnnamedFunction) {\n-        // Old Rhino tagged the empty name node with the line number of the\n-        // declaration.\n-        newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() +\n-            functionNode.getLp();\n-        newName.setCharno(position2charno(lpColumn));\n-      }\n+    public Node visitExpressionStatement(ExpressionStatement node) {\n+        return processExpressionStatement(node); // call to abstract method\n+    }\n \n-      node.addChildToBack(newName);\n-      Node lp = newNode(Token.LP);\n-      // The left paren's complicated because it's not represented by an\n-      // AstNode, so there's nothing that has the actual line number that it\n-      // appeared on.  We know the paren has to appear on the same line as the\n-      // function name (or else a semicolon will be inserted.)  If there's no\n-      // function name, assume the paren was on the same line as the function.\n-      // TODO(bowdidge): Mark line number of paren correctly.\n-      Name fnName = functionNode.getFunctionName();\n-      if (fnName != null) {\n-        lp.setLineno(fnName.getLineno());\n-      } else {\n-        lp.setLineno(functionNode.getLineno());\n-      }\n-      int lparenCharno = functionNode.getLp() +\n-          functionNode.getAbsolutePosition();\n+    @Override\n+    public Node visitForInLoop(ForInLoop node) {\n+        return transformForInLoop(node);\n+    }\n \n-      lp.setCharno(position2charno(lparenCharno));\n-      for (AstNode param : functionNode.getParams()) {\n-        lp.addChildToBack(transform(param));\n-      }\n-      node.addChildToBack(lp);\n+    private Node transformForInLoop(ForInLoop node) {\n+        Node result = newNode(Token.FOR);\n+\n+        Node left = transform(node.getIterator());\n+        if (!left.hasChildren()) {\n+            // This can only happen if there is a syntax error in the\n+            // for loop declaration.\n+            throw new RuntimeException(\"invalid left-hand side of for-in/for-of\");\n+        }\n \n-      Node bodyNode = transform(functionNode.getBody());\n-      parseDirectives(bodyNode);\n-      node.addChildToBack(bodyNode);\n-     return node;\n+        result.setLineno(node.getLineno());\n+        result.addChildToBack(left);\n+\n+        Node right = transform(node.getIteratedObject());\n+        right = new Node(Token.PARENTHETIC, right);\n+        result.addChildToBack(right);\n+\n+        Node body = transform(node.getBody());\n+        result.addChildToBack(body);\n+\n+        result.putProp(Node.FOR_POSITION, node.getForPosition());\n+        result.putProp(Node.IN_POSITION, node.getInPosition());\n+        return result;\n     }\n \n+    @Override\n+    publi\n+\n     @Override\n     Node processIfStatement(IfStatement statementNode) {\n       Node node = newNode(Token.IF);",
    "result_reason": "error: <identifier> expected",
    "test_result": "ERROR"
}