{
    "patch": "public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n    final int len = a.length;\n    if (len != b.length) {\n        throw new DimensionMismatchException(len, b.length);\n    }\n    if (len <= 1) { // treat size <= 1 as a special case\n        return len == 0 ? 0d : a[0] * b[0];\n    }\n\n    final double[] prodHigh = new double[len];\n    double prodLowSum = 0d;\n    for (int i = 0; i < len; i++) {\n        final double ai = a[i];\n        final double ca = SPLIT_FACTOR * ai;\n        final double aHigh = ca - (ca - ai);\n        final double aLow = ai - aHigh;\n        final double bi = b[i];\n        final double cb = SPLIT_FACTOR * bi;\n        final double bHigh = cb - (cb - bi);\n        final double bLow = bi - bHigh;\n        prodHigh[i] = ai * bi;\n        final double prodLow = aLow * bLow - ((prodHigh[i] - aHigh * bHigh) - aLow * bHigh - aHigh * bLow);\n        prodLowSum += prodLow;\n    }\n\n    double sHighCur = prodHigh[0] + prodHigh[1];\n    double sPrime = sHighCur - prodHigh[1];\n    double sLowSum = (prodHigh[1] - (sHighCur - sPrime)) + prodHigh[0] - sPrime;\n\n    for (int i = 2; i < len; i++) {\n        final double prodHighCur = prodHigh[i - 1];\n        final double prodHighNext = prodHigh[i];\n        sHighCur = sHighCur + prodHighNext;\n        sPrime = sHighCur - prodHighNext;\n        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n    }\n\n    double result = sHighCur + (prodLowSum + sLowSum);\n\n    if (Double.isNaN(result)) {\n        // either we have split infinite numbers or some coefficients were NaNs,\n        // just rely on the naive implementation and let IEEE754 handle this\n        result = 0d;\n        for (int i = 0; i < len; i++) {\n            result += a[i] * b[i];\n        }\n    }\n    return result;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/MathArrays.java b/src/main/java/org/apache/commons/math3/util/MathArrays.java\nindex 325fd9430..40eb736c4 100644\n--- a/src/main/java/org/apache/commons/math3/util/MathArrays.java\n+++ b/src/main/java/org/apache/commons/math3/util/MathArrays.java\n@@ -811,65 +811,55 @@ public class MathArrays {\n      * @return <code>&Sigma;<sub>i</sub> a<sub>i</sub> b<sub>i</sub></code>.\n      * @throws DimensionMismatchException if arrays dimensions don't match\n      */\n-    public static double linearCombination(final double[] a, final double[] b)\n-        throws DimensionMismatchException {\n-        final int len = a.length;\n-        if (len != b.length) {\n-            throw new DimensionMismatchException(len, b.length);\n-        }\n-\n-            // Revert to scalar multiplication.\n-\n-        final double[] prodHigh = new double[len];\n-        double prodLowSum = 0;\n-\n-        for (int i = 0; i < len; i++) {\n-            final double ai = a[i];\n-            final double ca = SPLIT_FACTOR * ai;\n-            final double aHigh = ca - (ca - ai);\n-            final double aLow = ai - aHigh;\n-\n-            final double bi = b[i];\n-            final double cb = SPLIT_FACTOR * bi;\n-            final double bHigh = cb - (cb - bi);\n-            final double bLow = bi - bHigh;\n-            prodHigh[i] = ai * bi;\n-            final double prodLow = aLow * bLow - (((prodHigh[i] -\n-                                                    aHigh * bHigh) -\n-                                                   aLow * bHigh) -\n-                                                  aHigh * bLow);\n-            prodLowSum += prodLow;\n-        }\n+public static double linearCombination(final double[] a, final double[] b) throws DimensionMismatchException {\n+    final int len = a.length;\n+    if (len != b.length) {\n+        throw new DimensionMismatchException(len, b.length);\n+    }\n+    if (len <= 1) { // treat size <= 1 as a special case\n+        return len == 0 ? 0d : a[0] * b[0];\n+    }\n \n+    final double[] prodHigh = new double[len];\n+    double prodLowSum = 0d;\n+    for (int i = 0; i < len; i++) {\n+        final double ai = a[i];\n+        final double ca = SPLIT_FACTOR * ai;\n+        final double aHigh = ca - (ca - ai);\n+        final double aLow = ai - aHigh;\n+        final double bi = b[i];\n+        final double cb = SPLIT_FACTOR * bi;\n+        final double bHigh = cb - (cb - bi);\n+        final double bLow = bi - bHigh;\n+        prodHigh[i] = ai * bi;\n+        final double prodLow = aLow * bLow - ((prodHigh[i] - aHigh * bHigh) - aLow * bHigh - aHigh * bLow);\n+        prodLowSum += prodLow;\n+    }\n \n-        final double prodHighCur = prodHigh[0];\n-        double prodHighNext = prodHigh[1];\n-        double sHighPrev = prodHighCur + prodHighNext;\n-        double sPrime = sHighPrev - prodHighNext;\n-        double sLowSum = (prodHighNext - (sHighPrev - sPrime)) + (prodHighCur - sPrime);\n+    double sHighCur = prodHigh[0] + prodHigh[1];\n+    double sPrime = sHighCur - prodHigh[1];\n+    double sLowSum = (prodHigh[1] - (sHighCur - sPrime)) + prodHigh[0] - sPrime;\n \n-        final int lenMinusOne = len - 1;\n-        for (int i = 1; i < lenMinusOne; i++) {\n-            prodHighNext = prodHigh[i + 1];\n-            final double sHighCur = sHighPrev + prodHighNext;\n-            sPrime = sHighCur - prodHighNext;\n-            sLowSum += (prodHighNext - (sHighCur - sPrime)) + (sHighPrev - sPrime);\n-            sHighPrev = sHighCur;\n-        }\n+    for (int i = 2; i < len; i++) {\n+        final double prodHighCur = prodHigh[i - 1];\n+        final double prodHighNext = prodHigh[i];\n+        sHighCur = sHighCur + prodHighNext;\n+        sPrime = sHighCur - prodHighNext;\n+        sLowSum += (prodHighNext - (sHighCur - sPrime)) + (prodHighCur - sPrime);\n+    }\n \n-        double result = sHighPrev + (prodLowSum + sLowSum);\n+    double result = sHighCur + (prodLowSum + sLowSum);\n \n-        if (Double.isNaN(result)) {\n-            // either we have split infinite numbers or some coefficients were NaNs,\n-            // just rely on the naive implementation and let IEEE754 handle this\n-            result = 0;\n-            for (int i = 0; i < len; ++i) {\n-                result += a[i] * b[i];\n-            }\n+    if (Double.isNaN(result)) {\n+        // either we have split infinite numbers or some coefficients were NaNs,\n+        // just rely on the naive implementation and let IEEE754 handle this\n+        result = 0d;\n+        for (int i = 0; i < len; i++) {\n+            result += a[i] * b[i];\n         }\n-\n-        return result;\n     }\n+    return result;\n+}\n \n     /**\n      * Compute a linear combination accurately.",
    "result_reason": "junit.framework.AssertionFailedError: expected:<-1.8551294182586249> but was:<-1.3404489300209106E16>",
    "test_result": "FAIL"
}