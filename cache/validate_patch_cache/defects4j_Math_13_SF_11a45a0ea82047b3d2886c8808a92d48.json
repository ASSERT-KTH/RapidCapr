{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final int n = m.getRowDimension();\n    final int maxIter = 100;\n    final double eps = Precision.EPSILON;\n    RealMatrix s = m.copy();\n    RealMatrix t = MatrixUtils.createRealMatrix(n, n);\n    for (int iter = 0; iter < maxIter; iter++) {\n        t.copySubMatrix(squareRootIteration(s, n));\n        RealMatrix tt = t.multiply(t);\n        double diff = 0.0;\n        for (int i = 0; i < n; i++) {\n            for (int j = i; j < n; j++) {\n                double delta = tt.getEntry(i, j) - s.getEntry(i, j);\n                diff += delta * delta;\n                s.setEntry(i, j, tt.getEntry(i, j));\n            }\n        }\n        if (diff < eps) {\n            break;\n        }\n    }\n    EigenDecomposition dec = new EigenDecomposition(s);\n    RealMatrix v = dec.getV();\n    RealMatrix d = MatrixUtils.createRealDiagonalMatrix(sqrtArray(dec.getRealEigenvalues()));\n    return v.multiply(d).multiply(v.transpose());\n}\n\nprivate double[] sqrtArray(double[] arr) {\n    final int n = arr.length;\n    double[] sqrtArr = new double[n];\n    for (int i = 0; i < n; i++) {\n        sqrtArr[i] = Math.sqrt(Math.abs(arr[i])) * Math.signum(arr[i]);\n    }\n    return sqrtArr;\n}\n\nprivate double[][] squareRootIteration(RealMatrix s, int n) {\n    double[][] t = new double[n][n];\n    for (int j = 0; j < n; j++) {\n        for (int i = j; i < n; i++) {\n            double x = s.getEntry(i, j);\n            for (int k = 0; k < j; k++) {\n                x -= t[k][j] * t[k][i];\n            }\n            if (i == j) {\n                t[j][i] = Math.sqrt(Math.abs(x)) * Math.signum(x);\n            } else if (Math.abs(t[j][j]) > 0.0) {\n                t[j][i] = x / t[j][j];\n            }\n        }\n    }\n    return t;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..769b53767 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,57 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final int n = m.getRowDimension();\n+    final int maxIter = 100;\n+    final double eps = Precision.EPSILON;\n+    RealMatrix s = m.copy();\n+    RealMatrix t = MatrixUtils.createRealMatrix(n, n);\n+    for (int iter = 0; iter < maxIter; iter++) {\n+        t.copySubMatrix(squareRootIteration(s, n));\n+        RealMatrix tt = t.multiply(t);\n+        double diff = 0.0;\n+        for (int i = 0; i < n; i++) {\n+            for (int j = i; j < n; j++) {\n+                double delta = tt.getEntry(i, j) - s.getEntry(i, j);\n+                diff += delta * delta;\n+                s.setEntry(i, j, tt.getEntry(i, j));\n+            }\n+        }\n+        if (diff < eps) {\n+            break;\n+        }\n     }\n+    EigenDecomposition dec = new EigenDecomposition(s);\n+    RealMatrix v = dec.getV();\n+    RealMatrix d = MatrixUtils.createRealDiagonalMatrix(sqrtArray(dec.getRealEigenvalues()));\n+    return v.multiply(d).multiply(v.transpose());\n+}\n+\n+private double[] sqrtArray(double[] arr) {\n+    final int n = arr.length;\n+    double[] sqrtArr = new double[n];\n+    for (int i = 0; i < n; i++) {\n+        sqrtArr[i] = Math.sqrt(Math.abs(arr[i])) * Math.signum(arr[i]);\n+    }\n+    return sqrtArr;\n+}\n+\n+private double[][] squareRootIteration(RealMatrix s, int n) {\n+    double[][] t = new double[n][n];\n+    for (int j = 0; j < n; j++) {\n+        for (int i = j; i < n; i++) {\n+            double x = s.getEntry(i, j);\n+            for (int k = 0; k < j; k++) {\n+                x -= t[k][j] * t[k][i];\n+            }\n+            if (i == j) {\n+                t[j][i] = Math.sqrt(Math.abs(x)) * Math.signum(x);\n+            } else if (Math.abs(t[j][j]) > 0.0) {\n+                t[j][i] = x / t[j][j];\n+            }\n+        }\n+    }\n+    return t;\n+}\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}