{
    "patch": "          // Avoid inlining properties that are deleted as it has\n          // different semantics from deleting a variable.\n          if (parent.getParent().isDelProp()) {\n            return false;\n          }\n\n          // Short-circuit cases where a property is referenced that\n          // isn't defined on the object literal.\n          if (parent.isGetProp()) {\n            String propertyName = parent.getLastChild().getString();\n            if (!validProperties.contains(propertyName)) {\n              if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n                validProperties.add(propertyName);\n              } else {\n                return false;\n              }\n            }\n          }\n\n          // Only rewrite VAR declarations or simple assignment statements\n          if (!isVarOrAssignExprLhs(name)) {\n            return false;\n          }\n\n          Node val = ref.getAssignedValue();\n          if (val == null) {\n            // A var with no assignment.\n            continue;\n          }\n\n          // We're looking for object literal assignments only.\n          if (!val.isObjectLit()) {\n            return false;\n          }\n\n          // Disallow self-referential assignments.\n          // Also excludes unorderable self-referential assignments.\n          for (Node child = val.getFirstChild(); child != null;\n              child = child.getNext()) {\n            if (child.isGetterDef() || child.isSetterDef()) {\n              // ES5 get/set not supported\n              return false;\n            }\n\n            validProperties.add(child.getString());\n\n            Node childVal = child.getFirstChild();\n            for (Reference t : refs) {\n              Node refNode = t.getParent();\n              while (!NodeUtil.isStatementBlock(refNode)) {\n                if (refNode == childVal) {\n                  // There's a self-referential assignment\n                  return false;\n                }\n                refNode = refNode.getParent();\n              }\n            }\n          }\n\n          // We have found an acceptable object literal assignment. As\n          // long as there are no other assignments that mess things up,\n          // we can inline.\n          ret = true;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..06338956 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,69 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+          // Avoid inlining properties that are deleted as it has\n+          // different semantics from deleting a variable.\n+          if (parent.getParent().isDelProp()) {\n+            return false;\n+          }\n+\n+          // Short-circuit cases where a property is referenced that\n+          // isn't defined on the object literal.\n+          if (parent.isGetProp()) {\n+            String propertyName = parent.getLastChild().getString();\n+            if (!validProperties.contains(propertyName)) {\n+              if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n+                validProperties.add(propertyName);\n+              } else {\n+                return false;\n+              }\n+            }\n+          }\n+\n+          // Only rewrite VAR declarations or simple assignment statements\n+          if (!isVarOrAssignExprLhs(name)) {\n+            return false;\n+          }\n+\n+          Node val = ref.getAssignedValue();\n+          if (val == null) {\n+            // A var with no assignment.\n+            continue;\n+          }\n+\n+          // We're looking for object literal assignments only.\n+          if (!val.isObjectLit()) {\n+            return false;\n+          }\n+\n+          // Disallow self-referential assignments.\n+          // Also excludes unorderable self-referential assignments.\n+          for (Node child = val.getFirstChild(); child != null;\n+              child = child.getNext()) {\n+            if (child.isGetterDef() || child.isSetterDef()) {\n+              // ES5 get/set not supported\n+              return false;\n+            }\n+\n+            validProperties.add(child.getString());\n+\n+            Node childVal = child.getFirstChild();\n+            for (Reference t : refs) {\n+              Node refNode = t.getParent();\n+              while (!NodeUtil.isStatementBlock(refNode)) {\n+                if (refNode == childVal) {\n+                  // There's a self-referential assignment\n+                  return false;\n+                }\n+                refNode = refNode.getParent();\n+              }\n+            }\n+          }\n+\n+          // We have found an acceptable object literal assignment. As\n+          // long as there are no other assignments that mess things up,\n+          // we can inline.\n+          ret = true;\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "junit.framework.AssertionFailedError:",
    "test_result": "FAIL"
}