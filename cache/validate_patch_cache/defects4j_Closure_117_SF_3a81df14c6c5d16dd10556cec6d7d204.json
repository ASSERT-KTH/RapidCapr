{
    "patch": "          while (objectType != null &&\n                 !objectType.hasOwnProperty(propName)) {\n            objectType = objectType.getImplicitPrototype();\n          }\n        }\n\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null &&\n            (objectType.getConstructor() != null ||\n             objectType.isFunctionPrototypeType())) {\n          return objectType.toString() + \".\" + propName;\n        }\n      }\n    }\n\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType dereferenced = type.dereference();\n      if (dereferenced != null) {\n        type = dereferenced;\n      }\n    }\n    if (type.isFunctionPrototypeType() ||\n        (type.toObjectType() != null &&\n         type.toObjectType().getConstructor() != null)) {\n      return type.toString();\n    }\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName;\n    } else if (type.isFunctionType()) {\n      // Don't show complex function names.\n      // Exceptions are functions that are exposed by a property on\n      // an object, because many of these are EventEmitter-style\n      // or other special cases where the name of the method matters.\n      // Show the first word of of the property name, followed by\n      // ellipses. This logic is not perfect.\n      String propName = n.getLastChild().getString();\n      int dotIndex = propName.indexOf('.');\n      if (dotIndex != -1) {\n        propName = propName.substring(0, dotIndex);\n      }\n      if (propName.length() > 12) {\n        propName = propName.substring(0, 9) + \"...\";\n      }\n      return propName;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java\nindex bcd024ac..f5197414 100644\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -721,24 +721,8 @@ class TypeValidator {\n    * @param dereference If true, the type of the node will be dereferenced\n    *     to an Object type, if possible.\n    */\n-  String getReadableJSTypeName(Node n, boolean dereference) {\n-\n-    // The best type name is the actual type name.\n-\n-    // If we're analyzing a GETPROP, the property may be inherited by the\n-    // prototype chain. So climb the prototype chain and find out where\n-    // the property was originally defined.\n-    if (n.isGetProp()) {\n-      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n-      if (objectType != null) {\n-        String propName = n.getLastChild().getString();\n-        if (objectType.getConstructor() != null &&\n-            objectType.getConstructor().isInterface()) {\n-          objectType = FunctionType.getTopDefiningInterface(\n-              objectType, propName);\n-        } else {\n-          // classes\n-          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n+          while (objectType != null &&\n+                 !objectType.hasOwnProperty(propName)) {\n             objectType = objectType.getImplicitPrototype();\n           }\n         }\n@@ -770,11 +754,20 @@ class TypeValidator {\n       return qualifiedName;\n     } else if (type.isFunctionType()) {\n       // Don't show complex function names.\n-      return \"function\";\n-    } else {\n-      return type.toString();\n-    }\n-  }\n+      // Exceptions are functions that are exposed by a property on\n+      // an object, because many of these are EventEmitter-style\n+      // or other special cases where the name of the method matters.\n+      // Show the first word of of the property name, followed by\n+      // ellipses. This logic is not perfect.\n+      String propName = n.getLastChild().getString();\n+      int dotIndex = propName.indexOf('.');\n+      if (dotIndex != -1) {\n+        propName = propName.substring(0, dotIndex);\n+      }\n+      if (propName.length() > 12) {\n+        propName = propName.substring(0, 9) + \"...\";\n+      }\n+      return propName;\n \n   /**\n    * This method gets the JSType from the Node argument and verifies that it is",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}