{
    "patch": "public static double regularizedGamma(double a, double x) {\n    final double[] SER = {1.0, 0.5772156649015329, -0.6558780715202538,\n                          -0.420026350340952e-1, 0.1665386113822915,\n                          -0.421977345555443e-1, -0.9621971527877e-2,\n                          0.7218943246663e-2, -0.11651675918591e-2,\n                          -0.2152416741149e-3, 0.1280502823882e-3,\n                          -0.201348547807e-4, -0.12504934821e-5,\n                          0.1133027232e-5, -0.2056338417e-6,\n                          0.6116095e-8, 0.50020075e-9, -0.11812746e-9,\n                          0.1043427e-10, 0.77823e-12, -0.36968e-12,\n                          0.51e-14, -0.206e-13, -0.54e-14, 0.14e-14};\n    final double[] COF = {-0.42278433509846713, 0.3224670334241132,\n                          0.49938097606020456, 0.6764044243898726,\n                          0.8514905403875244, 1.0278764968239325,\n                          1.2074143576970068, 1.3913673076562208,\n                          1.5807835010067569, 1.776591741973393,\n                          1.979710138673016, 2.191122726256696,\n                          2.411807694107068, 2.642745873060304,\n                          2.884928066657072, 3.1393427229500199,\n                          3.407881768518268, 3.6915310663478173,\n                          3.9912837207805367, 4.30814695995021,\n                          4.64314164337467, 4.997281561392026,\n                          5.371686745196163, 5.767519610234304,\n                          6.186034066196577, 6.628538752730845,\n                          7.096358995732725, 7.591949208141281,\n                          8.116862021097383, 8.672862006980508,\n                          9.2629998398465, 9.890448869753575,\n                          10.558436025934287, 11.27135244112299,\n                          12.03367086546154, 12.850010012764512,\n                          13.726120690012868, 14.668865435695518,\n                          15.685298978538631, 16.7835772236982,\n                          17.972962532037002, 19.26481878668761,\n                          20.67183091733619, 22.20861970792312,\n                          23.89225576788472, 25.743157056812135,\n                          27.78759782134274, 30.061557660882498,\n                          32.611093148788805, 35.49250708164123,\n                          38.78434429552791, 42.59638333648872,\n                          47.148547661804674, 52.829592404792146,\n                          60.81155200176818, 72.88388727922516,\n                          90.00504924262014, 120.85800329596489,\n                          179.99999999999926, 299.9999999999988};\n\n    if (a <= 0.0) {\n        throw new IllegalArgumentException(\"a must be > 0\");\n    }\n    if (x < 0.0) {\n        throw new IllegalArgumentException(\"x must be >= 0\");\n    }\n    if (x == 0.0) {\n        return 0.0;\n    }\n\n    double ax = a * Math.log(x) - x - logGamma(a);\n    if (ax < -MAX_LOG_VALUE) {\n        return 0.0;\n    }\n\n    ax = Math.exp(ax);\n\n    // Continued fraction computation\n    double y = 1.0 - a;\n    double z = x + y + 1.0;\n    double c = 0.0;\n    double pkm2 = 1.0;\n    double qkm2 = x;\n    double pkm1 = x + 1.0;\n    double qkm1 = z * x;\n    double ans = pkm1 / qkm1;\n    double tmp;\n    int i = 1;\n    do {\n        c += 1.0;\n        y += 1.0;\n        z += 2.0;\n        tmp = c * y * pkm1 - b * pkm2;\n        pkm2 = pkm1;\n        pkm1 = tmp;\n        tmp = qkm1;\n        qkm1 = z * qkm1 - b * qkm2;\n        qkm2 = tmp;\n        if (qkm1 != 0) {\n            ans = pkm1 / qkm1;\n        }\n\n        // Renormalize to prevent overflow and underflow\n        if (Math.abs(pkm1) > SCALE_FACTOR) {\n            pkm2 *= INV_SCALE_FACTOR;\n            pkm1 *= INV_SCALE_FACTOR;\n            qkm2 *= INV_SCALE_FACTOR;\n            qkm1 *= INV_SCALE_FACTOR;\n        }\n        i++;\n    } while (i < MAX_ITERATIONS && Math.abs(ans * qkm1 - pkm1) > EPSILON * ans);\n\n    return ax * ans;\n}\n\nprivate static double logGamma(double x) {\n    double tmp = (x - 0.5) * Math.log(x + GAMMA_X) - x - GAMMA_HALF_LOG_TWO_PI;\n    double ser = 1.0 + COF[0] / x;\n    for (int i = 1; i < COF.length; i++) {\n        ser += COF[i] / (x + i);\n    }\n    return tmp + Math.log(ser * SQT_TWO_PI / x);\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..b07583e96 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,111 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGamma(double a, double x) {\n+    final double[] SER = {1.0, 0.5772156649015329, -0.6558780715202538,\n+                          -0.420026350340952e-1, 0.1665386113822915,\n+                          -0.421977345555443e-1, -0.9621971527877e-2,\n+                          0.7218943246663e-2, -0.11651675918591e-2,\n+                          -0.2152416741149e-3, 0.1280502823882e-3,\n+                          -0.201348547807e-4, -0.12504934821e-5,\n+                          0.1133027232e-5, -0.2056338417e-6,\n+                          0.6116095e-8, 0.50020075e-9, -0.11812746e-9,\n+                          0.1043427e-10, 0.77823e-12, -0.36968e-12,\n+                          0.51e-14, -0.206e-13, -0.54e-14, 0.14e-14};\n+    final double[] COF = {-0.42278433509846713, 0.3224670334241132,\n+                          0.49938097606020456, 0.6764044243898726,\n+                          0.8514905403875244, 1.0278764968239325,\n+                          1.2074143576970068, 1.3913673076562208,\n+                          1.5807835010067569, 1.776591741973393,\n+                          1.979710138673016, 2.191122726256696,\n+                          2.411807694107068, 2.642745873060304,\n+                          2.884928066657072, 3.1393427229500199,\n+                          3.407881768518268, 3.6915310663478173,\n+                          3.9912837207805367, 4.30814695995021,\n+                          4.64314164337467, 4.997281561392026,\n+                          5.371686745196163, 5.767519610234304,\n+                          6.186034066196577, 6.628538752730845,\n+                          7.096358995732725, 7.591949208141281,\n+                          8.116862021097383, 8.672862006980508,\n+                          9.2629998398465, 9.890448869753575,\n+                          10.558436025934287, 11.27135244112299,\n+                          12.03367086546154, 12.850010012764512,\n+                          13.726120690012868, 14.668865435695518,\n+                          15.685298978538631, 16.7835772236982,\n+                          17.972962532037002, 19.26481878668761,\n+                          20.67183091733619, 22.20861970792312,\n+                          23.89225576788472, 25.743157056812135,\n+                          27.78759782134274, 30.061557660882498,\n+                          32.611093148788805, 35.49250708164123,\n+                          38.78434429552791, 42.59638333648872,\n+                          47.148547661804674, 52.829592404792146,\n+                          60.81155200176818, 72.88388727922516,\n+                          90.00504924262014, 120.85800329596489,\n+                          179.99999999999926, 299.9999999999988};\n+\n+    if (a <= 0.0) {\n+        throw new IllegalArgumentException(\"a must be > 0\");\n+    }\n+    if (x < 0.0) {\n+        throw new IllegalArgumentException(\"x must be >= 0\");\n+    }\n+    if (x == 0.0) {\n+        return 0.0;\n+    }\n+\n+    double ax = a * Math.log(x) - x - logGamma(a);\n+    if (ax < -MAX_LOG_VALUE) {\n+        return 0.0;\n+    }\n+\n+    ax = Math.exp(ax);\n+\n+    // Continued fraction computation\n+    double y = 1.0 - a;\n+    double z = x + y + 1.0;\n+    double c = 0.0;\n+    double pkm2 = 1.0;\n+    double qkm2 = x;\n+    double pkm1 = x + 1.0;\n+    double qkm1 = z * x;\n+    double ans = pkm1 / qkm1;\n+    double tmp;\n+    int i = 1;\n+    do {\n+        c += 1.0;\n+        y += 1.0;\n+        z += 2.0;\n+        tmp = c * y * pkm1 - b * pkm2;\n+        pkm2 = pkm1;\n+        pkm1 = tmp;\n+        tmp = qkm1;\n+        qkm1 = z * qkm1 - b * qkm2;\n+        qkm2 = tmp;\n+        if (qkm1 != 0) {\n+            ans = pkm1 / qkm1;\n+        }\n+\n+        // Renormalize to prevent overflow and underflow\n+        if (Math.abs(pkm1) > SCALE_FACTOR) {\n+            pkm2 *= INV_SCALE_FACTOR;\n+            pkm1 *= INV_SCALE_FACTOR;\n+            qkm2 *= INV_SCALE_FACTOR;\n+            qkm1 *= INV_SCALE_FACTOR;\n+        }\n+        i++;\n+    } while (i < MAX_ITERATIONS && Math.abs(ans * qkm1 - pkm1) > EPSILON * ans);\n+\n+    return ax * ans;\n+}\n+\n+private static double logGamma(double x) {\n+    double tmp = (x - 0.5) * Math.log(x + GAMMA_X) - x - GAMMA_HALF_LOG_TWO_PI;\n+    double ser = 1.0 + COF[0] / x;\n+    for (int i = 1; i < COF.length; i++) {\n+        ser += COF[i] / (x + i);\n+    }\n+    return tmp + Math.log(ser * SQT_TWO_PI / x);\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}