{
    "patch": "protected double doSolve() throws TooManyEvaluationsException {\n    double min = getMin();\n    double max = getMax();\n    double startValue = getStartValue();\n\n    verifySequence(min, startValue, max);\n    double targetY;\n    double xA;\n    double yA;\n    double absYA;\n    double xB;\n    double yB;\n    double absYB;\n    int agingA;\n    int agingB;\n    int signChangeIndex;\n\n    double[] x = new double[maximalOrder + 1];\n    double[] y = new double[maximalOrder + 1];\n\n    x[0] = min;\n    x[1] = startValue;\n    x[2] = max;\n\n    y[0] = computeObjectiveValue(x[0]);\n    y[1] = computeObjectiveValue(x[1]);\n    y[2] = computeObjectiveValue(x[2]);\n\n    signChangeIndex = 1;\n    absYA = FastMath.abs(y[1]);\n    absYB = FastMath.abs(y[2]);\n    xA = x[signChangeIndex - 1];\n    yA = y[signChangeIndex - 1];\n    agingA = 0;\n    xB = x[signChangeIndex];\n    yB = y[signChangeIndex];\n    agingB = 0;\n\n    for (int i = 3; i <= maximalEvaluations; ++i) {\n        // check convergence of bracketing interval\n        double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n        if (FastMath.abs(xB - xA) <= xTol || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n            switch (allowed) {\n                case ANY_SIDE:\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE:\n                    return xA;\n                case RIGHT_SIDE:\n                    return xB;\n                case BELOW_SIDE:\n                    return yA <= 0 ? xA : xB;\n                case ABOVE_SIDE:\n                    return yA < 0 ? xB : xA;\n                default:\n                    // this should never happen\n                    throw new MathInternalError();\n            }\n        }\n        unsetResult();\n        // target for the next evaluation point\n        if (agingA >= MAXIMAL_AGING) {\n            targetY = -REDUCTION_FACTOR * yB;\n        } else if (agingB >= MAXIMAL_AGING) {\n            targetY = -REDUCTION_FACTOR * yA;\n        } else {\n            targetY = 0;\n        }\n        // guess next point\n        double nextX;\n        int start = 0;\n        int end = signChangeIndex + 1;\n        while (true) {\n            nextX = guessX(targetY, x, y, start, end);\n            if (nextX < min || nextX > max) {\n                if (signChangeIndex == 1) {\n                    nextX = xA + 0.5 * (xB - xA);\n                } else {\n                    double dx = xB - xA;\n                    start = signChangeIndex - 1;\n                    end = signChangeIndex;\n                    int mid = start + (end - start) / 2;\n                    if (dx > 0.0) {\n                        double x1 = xA + 0.25 * dx;\n                        double x2 = xB - 0.25 * dx;\n                        double x3 = x[mid];\n                        double y3 = y[mid];\n                        if (x2 < x3) {\n                            double tmp = x1;\n                            x1 = x2;\n                            x2 = tmp;\n                        }\n                        if (x1 < x3) {\n                            double tmp = x1;\n                            x1 = x3;\n                            x3 = tmp;\n                            tmp = x2;\n                            x2 = x3;\n                            x3 = tmp;\n                            double y2 = computeObjectiveValue(x2);\n                            if (y2 * y3 <= 0) {\n                                xA = x1;\n                                xB = x2;\n                                agingB = agingA + 1;\n                                yA = y[signChangeIndex - 1];\n                                yB = y2;\n                                absYA = FastMath.abs(yA);\n                                absYB = FastMath.abs(yB);\n                                break;\n                            } else {\n                                xA = x2;\n                                xB = x1;\n                                agingB = agingA + 1;\n                                yA = y2;\n                                yB = y[signChangeIndex - 1];\n                                absYA = FastMath.abs(yA);\n                                absYB = FastMath.abs(yB);\n                                break;\n                            }\n                        } else {\n                            double y1 = computeObjectiveValue(x1);\n                            if (y1 * y3 <= 0) {\n                                xA = x1;\n                                xB = x2;\n                                agingB = agingA + 1;\n                                yA = y[start];\n                                yB = y2;\n                                absYA = FastMath.abs(yA);\n                                absYB = FastMath.abs(yB);\n                                break;\n                            } else {\n                                xA = x2;\n                                xB = x1;\n                                agingB = agingA + 1;\n                                yA = y2;\n                                yB = y[start];\n                                absYA = FastMath.abs(yA);\n                                absYB = FastMath.abs(yB);\n                                break;\n                            }\n                        }\n                    } else {\n                        xA = x[mid];\n                        xB = x[mid + 1];\n                        yA = y[mid];\n                        yB = y[mid + 1];\n                        absYA = FastMath.abs(yA);\n                        absYB = FastMath.abs(yB);\n                        agingA = 0;\n                        agingB = 0;\n                        start = mid;\n                        end = mid + 2;\n                        break;\n                    }\n                }\n            } else {\n                break;\n            }\n        }\n        double nextY = computeObjectiveValue(nextX);\n        if (FastMath.abs(nextY) <= getFunctionValueAccuracy()) {\n            return nextX;\n        }\n        // update bracketing interval\n        if (nextY * yA < 0) {\n            xB = nextX;\n            yB = nextY;\n            absYB = FastMath.abs(yB);\n            ++agingA;\n            agingB = 0;\n        } else {\n            xA = nextX;\n            yA = nextY;\n            absYA = FastMath.abs(yA);\n            agingA = 0;\n            ++agingB;\n        }\n        // update tightest bracketing interval\n        if (absYA < absYB) {\n            signChangeIndex = i % maximalOrder;\n        } else {\n            signChangeIndex = 1 + i % maximalOrder;\n        }\n        int j = signChangeIndex;\n        if (nextY * y[signChangeIndex - 1] > 0) {\n            // we switch to a different inner interval\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, maximalOrder - signChangeIndex);\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, maximalOrder - signChangeIndex);\n            j = signChangeIndex - 1;\n            --signChangeIndex;\n            x[j] = xA;\n            y[j] = yA;\n        } else if (nextY * y[signChangeIndex] > 0) {\n            // we switch to a different inner interval\n            System.arraycopy(x, signChangeIndex + 1, x, signChangeIndex, maximalOrder - signChangeIndex - 1);\n            System.arraycopy(y, signChangeIndex + 1, y, signChangeIndex, maximalOrder - signChangeIndex - 1);\n            x[maximalOrder] = xB;\n            y[maximalOrder] = yB;\n        } else {\n            // we stay in the same interval, we drop the point which is farthes",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..a5a8171f9 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,209 +140,205 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n-            return x[1];\n-        }\n-\n-        // evaluate first  endpoint\n-        y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n-            return x[0];\n-        }\n-\n-        int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n-\n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n-\n-        } else {\n-\n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n-            }\n-\n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n-            } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n-            }\n-\n-        }\n-\n-        // prepare a work array for inverse polynomial interpolation\n-        final double[] tmpX = new double[x.length];\n-\n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n-        while (true) {\n-\n-            // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n-                switch (allowed) {\n-                case ANY_SIDE :\n+protected double doSolve() throws TooManyEvaluationsException {\n+    double min = getMin();\n+    double max = getMax();\n+    double startValue = getStartValue();\n+\n+    verifySequence(min, startValue, max);\n+    double targetY;\n+    double xA;\n+    double yA;\n+    double absYA;\n+    double xB;\n+    double yB;\n+    double absYB;\n+    int agingA;\n+    int agingB;\n+    int signChangeIndex;\n+\n+    double[] x = new double[maximalOrder + 1];\n+    double[] y = new double[maximalOrder + 1];\n+\n+    x[0] = min;\n+    x[1] = startValue;\n+    x[2] = max;\n+\n+    y[0] = computeObjectiveValue(x[0]);\n+    y[1] = computeObjectiveValue(x[1]);\n+    y[2] = computeObjectiveValue(x[2]);\n+\n+    signChangeIndex = 1;\n+    absYA = FastMath.abs(y[1]);\n+    absYB = FastMath.abs(y[2]);\n+    xA = x[signChangeIndex - 1];\n+    yA = y[signChangeIndex - 1];\n+    agingA = 0;\n+    xB = x[signChangeIndex];\n+    yB = y[signChangeIndex];\n+    agingB = 0;\n+\n+    for (int i = 3; i <= maximalEvaluations; ++i) {\n+        // check convergence of bracketing interval\n+        double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n+        if (FastMath.abs(xB - xA) <= xTol || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n+            switch (allowed) {\n+                case ANY_SIDE:\n                     return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n+                case LEFT_SIDE:\n                     return xA;\n-                case RIGHT_SIDE :\n+                case RIGHT_SIDE:\n                     return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n+                case BELOW_SIDE:\n+                    return yA <= 0 ? xA : xB;\n+                case ABOVE_SIDE:\n+                    return yA < 0 ? xB : xA;\n+                default:\n                     // this should never happen\n-                    throw new MathInternalError(null);\n-                }\n+                    throw new MathInternalError();\n             }\n-\n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n-            } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n-            }\n-\n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n+        }\n+        unsetResult();\n+        // target for the next evaluation point\n+        if (agingA >= MAXIMAL_AGING) {\n+            targetY = -REDUCTION_FACTOR * yB;\n+        } else if (agingB >= MAXIMAL_AGING) {\n+            targetY = -REDUCTION_FACTOR * yA;\n+        } else {\n+            targetY = 0;\n+        }\n+        // guess next point\n+        double nextX;\n+        int start = 0;\n+        int end = signChangeIndex + 1;\n+        while (true) {\n+            nextX = guessX(targetY, x, y, start, end);\n+            if (nextX < min || nextX > max) {\n+                if (signChangeIndex == 1) {\n+                    nextX = xA + 0.5 * (xB - xA);\n+                } else {\n+                    double dx = xB - xA;\n+                    start = signChangeIndex - 1;\n+                    end = signChangeIndex;\n+                    int mid = start + (end - start) / 2;\n+                    if (dx > 0.0) {\n+                        double x1 = xA + 0.25 * dx;\n+                        double x2 = xB - 0.25 * dx;\n+                        double x3 = x[mid];\n+                        double y3 = y[mid];\n+                        if (x2 < x3) {\n+                            double tmp = x1;\n+                            x1 = x2;\n+                            x2 = tmp;\n+                        }\n+                        if (x1 < x3) {\n+                            double tmp = x1;\n+                            x1 = x3;\n+                            x3 = tmp;\n+                            tmp = x2;\n+                            x2 = x3;\n+                            x3 = tmp;\n+                            double y2 = computeObjectiveValue(x2);\n+                            if (y2 * y3 <= 0) {\n+                                xA = x1;\n+                                xB = x2;\n+                                agingB = agingA + 1;\n+                                yA = y[signChangeIndex - 1];\n+                                yB = y2;\n+                                absYA = FastMath.abs(yA);\n+                                absYB = FastMath.abs(yB);\n+                                break;\n+                            } else {\n+                                xA = x2;\n+                                xB = x1;\n+                                agingB = agingA + 1;\n+                                yA = y2;\n+                                yB = y[signChangeIndex - 1];\n+                                absYA = FastMath.abs(yA);\n+                                absYB = FastMath.abs(yB);\n+                                break;\n+                            }\n+                        } else {\n+                            double y1 = computeObjectiveValue(x1);\n+                            if (y1 * y3 <= 0) {\n+                                xA = x1;\n+                                xB = x2;\n+                                agingB = agingA + 1;\n+                                yA = y[start];\n+                                yB = y2;\n+                                absYA = FastMath.abs(yA);\n+                                absYB = FastMath.abs(yB);\n+                                break;\n+                            } else {\n+                                xA = x2;\n+                                xB = x1;\n+                                agingB = agingA + 1;\n+                                yA = y2;\n+                                yB = y[start];\n+                                absYA = FastMath.abs(yA);\n+                                absYB = FastMath.abs(yB);\n+                                break;\n+                            }\n+                        }\n                     } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n+                        xA = x[mid];\n+                        xB = x[mid + 1];\n+                        yA = y[mid];\n+                        yB = y[mid + 1];\n+                        absYA = FastMath.abs(yA);\n+                        absYB = FastMath.abs(yB);\n+                        agingA = 0;\n+                        agingB = 0;\n+                        start = mid;\n+                        end = mid + 2;\n+                        break;\n                     }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n-                }\n-\n-            } while (Double.isNaN(nextX) && (end - start > 1));\n-\n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n-            }\n-\n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n-            }\n-\n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n-\n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n                 }\n-\n-            }\n-\n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n             } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n+                break;\n             }\n-\n         }\n-\n-    }\n+        double nextY = computeObjectiveValue(nextX);\n+        if (FastMath.abs(nextY) <= getFunctionValueAccuracy()) {\n+            return nextX;\n+        }\n+        // update bracketing interval\n+        if (nextY * yA < 0) {\n+            xB = nextX;\n+            yB = nextY;\n+            absYB = FastMath.abs(yB);\n+            ++agingA;\n+            agingB = 0;\n+        } else {\n+            xA = nextX;\n+            yA = nextY;\n+            absYA = FastMath.abs(yA);\n+            agingA = 0;\n+            ++agingB;\n+        }\n+        // update tightest bracketing interval\n+        if (absYA < absYB) {\n+            signChangeIndex = i % maximalOrder;\n+        } else {\n+            signChangeIndex = 1 + i % maximalOrder;\n+        }\n+        int j = signChangeIndex;\n+        if (nextY * y[signChangeIndex - 1] > 0) {\n+            // we switch to a different inner interval\n+            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, maximalOrder - signChangeIndex);\n+            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, maximalOrder - signChangeIndex);\n+            j = signChangeIndex - 1;\n+            --signChangeIndex;\n+            x[j] = xA;\n+            y[j] = yA;\n+        } else if (nextY * y[signChangeIndex] > 0) {\n+            // we switch to a different inner interval\n+            System.arraycopy(x, signChangeIndex + 1, x, signChangeIndex, maximalOrder - signChangeIndex - 1);\n+            System.arraycopy(y, signChangeIndex + 1, y, signChangeIndex, maximalOrder - signChangeIndex - 1);\n+            x[maximalOrder] = xB;\n+            y[maximalOrder] = yB;\n+        } else {\n+            // we stay in the same interval, we drop the point which is farthes\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}