{
    "patch": "    switch (node.getToken()) {\n      case NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case GETPROP:\n        if (node.getFirstChild().isThis()) {\n          scope.inferSlotType(node.getLastChild().getString(), type);\n        } else {\n          String qualifiedName = node.getQualifiedName();\n          Preconditions.checkNotNull(qualifiedName);\n\n          JSType origType = node.getJSType();\n          origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n          scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\n            \"Node cannot be refined.\\n\" + node.toStringTree());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..ccc9ba2e 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,28 +154,27 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n-    switch (node.getType()) {\n-      case Token.NAME:\n+    switch (node.getToken()) {\n+      case NAME:\n         scope.inferSlotType(node.getString(), type);\n         break;\n \n-      case Token.GETPROP:\n-        String qualifiedName = node.getQualifiedName();\n-        Preconditions.checkNotNull(qualifiedName);\n+      case GETPROP:\n+        if (node.getFirstChild().isThis()) {\n+          scope.inferSlotType(node.getLastChild().getString(), type);\n+        } else {\n+          String qualifiedName = node.getQualifiedName();\n+          Preconditions.checkNotNull(qualifiedName);\n \n-        JSType origType = node.getJSType();\n-        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n-        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+          JSType origType = node.getJSType();\n+          origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n+          scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+        }\n         break;\n \n-        // \"this\" references aren't currently modeled in the CFG.\n-\n       default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n-    }\n-  }\n+        throw new IllegalArgumentException(\n+            \"Node cannot be refined.\\n\" + node.toStringTree());\n \n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}