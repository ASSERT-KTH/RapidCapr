{
    "patch": "if (ref == null) {\n  return false;\n}\nboolean seenAssign = false;\nfor (Reference otherRef : references) {\n  if (otherRef == ref) {\n    seenAssign = true;\n    continue;\n  }\n  if (!seenAssign) {\n    continue;\n  }\n\n  // We don't care about properties of var that aren't\n  // addressed directly by the user code.\n  if (otherRef.getParent() == ref.getParent() &&\n      otherRef.isDeclaration() &&\n      otherRef.getNameNode().getLastChild() == ref.getNameNode().getLastChild()) {\n    continue;\n  }\n\n  // Ignore this assignment if it is to a different object,\n  // or not a direct child of the current one.\n  BasicBlock otherBlock = otherRef.getBasicBlock();\n  if (otherBlock.getParent() != ref.getBasicBlock().getParent() ||\n      otherBlock.getIndex() != ref.getBasicBlock().getIndex()) {\n    continue;\n  }\n\n  Function otherFunction = otherRef.isProperty() ?\n      otherRef.getPropertyParentFunction() : otherRef.getFunction();\n  if (otherFunction == null || otherFunction.getBaseVar() == null) {\n    return false;\n  }\n\n  String otherName = otherFunction.getBaseVar().getName();\n  if (otherName == null || !otherName.equals(refName)) {\n    return false;\n  }\n}\nreturn true;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..a45f6c09 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,47 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+if (ref == null) {\n+  return false;\n+}\n+boolean seenAssign = false;\n+for (Reference otherRef : references) {\n+  if (otherRef == ref) {\n+    seenAssign = true;\n+    continue;\n+  }\n+  if (!seenAssign) {\n+    continue;\n+  }\n+\n+  // We don't care about properties of var that aren't\n+  // addressed directly by the user code.\n+  if (otherRef.getParent() == ref.getParent() &&\n+      otherRef.isDeclaration() &&\n+      otherRef.getNameNode().getLastChild() == ref.getNameNode().getLastChild()) {\n+    continue;\n+  }\n+\n+  // Ignore this assignment if it is to a different object,\n+  // or not a direct child of the current one.\n+  BasicBlock otherBlock = otherRef.getBasicBlock();\n+  if (otherBlock.getParent() != ref.getBasicBlock().getParent() ||\n+      otherBlock.getIndex() != ref.getBasicBlock().getIndex()) {\n+    continue;\n+  }\n+\n+  Function otherFunction = otherRef.isProperty() ?\n+      otherRef.getPropertyParentFunction() : otherRef.getFunction();\n+  if (otherFunction == null || otherFunction.getBaseVar() == null) {\n+    return false;\n+  }\n+\n+  String otherName = otherFunction.getBaseVar().getName();\n+  if (otherName == null || !otherName.equals(refName)) {\n+    return false;\n+  }\n+}\n+return true;\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}