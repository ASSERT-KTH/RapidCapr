{
    "patch": "  private void inferDeclaration(\n      SyntacticScopeCreator.Scope syntacticScope,\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    Preconditions.checkNotNull(resultType);\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        boolean isVarDeclaration = left.hasChildren();\n\n        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n\n        if (isVarTypeBetter) {\n          redeclareSimpleVar(scope, left, resultType);\n        }\n        left.setJSType(isVarDeclaration || leftType == null ?\n            resultType : null);\n\n        if (var != null && var.isTypeInferred()) {\n          JSType oldType = var.getType();\n          var.setType(oldType == null ?\n              resultType : oldType.getLeastSupertype(resultType));\n        }\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType,\n              resultType);\n        }\n\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n    }\n  }\n\n  /**\n   * Defines a property if the property has not been defined yet.\n   */\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor = obj.isThis() &&\n        getJSType(syntacticScope.getRootNode()).isConstructor();\n\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n        boolean staticPropCreation = false;\n        Node maybeAssignStm = getprop.getParent().getParent();\n        if (syntacticScope.isGlobal() &&\n            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n          String propCreationFilename = maybeAssignStm.getSourceFileName();\n          Node ctor = objectType.getOwnerFunction().getSource();\n          if (ctor != null &&\n              ctor.getSourceFileName().equals(propCreationFilename)) {\n            staticPropCreation = true;\n          }\n        }\n        if (!propCreationInConstructor && !staticPropCreation) {\n          return;\n        }\n      }\n\n      ensurePropertyDefinedHelper(objectType, propName, rightType);\n    }\n  }\n\n  private void ensurePropertyDefinedHelper(ObjectType objectType, String propName, JSType rightType) {\n    Property prop = objectType.getOwnSlot(propName);\n    if (prop == null || prop.isTypeInferred()) {\n      if (prop == null) {\n        inGlobalScopeButNotDeclared(propName, objectType);\n      } else {\n        // Check for type conflicts\n        JSType oldType = prop.getType();\n        JSType newType = oldType.getLeastSupertype(rightType);\n        if (newType != null && !newType.equals(oldType)) {\n          prop.setType(newType);\n        }\n      }\n    }\n  }\n\n  private void inGlobalScopeButNotDeclared(String varName, ObjectType type) {\n    if (!syntacticScope.isGlobal()) {\n      registry.registerUndeclaredPropertyOnType(varName, type);\n      return;\n    }\n    // Give up on checking for warnings once the AST becomes too large. Full\n    // type-checking is still run at the end of compilation, but continuing to\n    // check here will slow down local development.\n    if (syntacticScope.getRootNode().getSourceFileName().equals(lastFileChecked)\n        && NodeUtil.getTreeSize(syntacticScope.getRootNode()) > MAX_TREE_SIZE) {\n      return;\n    }\n    lastFileChecked = syntacticScope.getRootNode().getSourceFileName();\n    Var var = syntacticScope.getVar(varName);\n    if (var == null || var.isTypeInferred()) {\n      registry.registerUndeclaredPropertyOnType(varName, type);\n      return;\n    }\n\n    typeMismatchWarning(syntacticScope.getRootNode(), var, \"declared\", \"undeclared\", var.getType(), type);\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..8ee58fd2 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,6 +521,8 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n+  private void inferDeclaration(\n+      SyntacticScopeCreator.Scope syntacticScope,\n       FlowScope scope, Node left, JSType leftType, JSType resultType) {\n     Preconditions.checkNotNull(resultType);\n     switch (left.getType()) {\n@@ -529,34 +531,7 @@ class TypeInference\n         Var var = syntacticScope.getVar(varName);\n         boolean isVarDeclaration = left.hasChildren();\n \n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n         boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n-\n \n         if (isVarTypeBetter) {\n           redeclareSimpleVar(scope, left, resultType);\n@@ -600,15 +575,6 @@ class TypeInference\n       registry.registerPropertyOnType(propName, nodeType);\n     } else {\n       if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n         boolean staticPropCreation = false;\n         Node maybeAssignStm = getprop.getParent().getParent();\n         if (syntacticScope.isGlobal() &&\n@@ -621,9 +587,51 @@ class TypeInference\n           }\n         }\n         if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n+          return;\n+        }\n+      }\n+\n+      ensurePropertyDefinedHelper(objectType, propName, rightType);\n+    }\n+  }\n+\n+  private void ensurePropertyDefinedHelper(ObjectType objectType, String propName, JSType rightType) {\n+    Property prop = objectType.getOwnSlot(propName);\n+    if (prop == null || prop.isTypeInferred()) {\n+      if (prop == null) {\n+        inGlobalScopeButNotDeclared(propName, objectType);\n+      } else {\n+        // Check for type conflicts\n+        JSType oldType = prop.getType();\n+        JSType newType = oldType.getLeastSupertype(rightType);\n+        if (newType != null && !newType.equals(oldType)) {\n+          prop.setType(newType);\n         }\n       }\n+    }\n+  }\n+\n+  private void inGlobalScopeButNotDeclared(String varName, ObjectType type) {\n+    if (!syntacticScope.isGlobal()) {\n+      registry.registerUndeclaredPropertyOnType(varName, type);\n+      return;\n+    }\n+    // Give up on checking for warnings once the AST becomes too large. Full\n+    // type-checking is still run at the end of compilation, but continuing to\n+    // check here will slow down local development.\n+    if (syntacticScope.getRootNode().getSourceFileName().equals(lastFileChecked)\n+        && NodeUtil.getTreeSize(syntacticScope.getRootNode()) > MAX_TREE_SIZE) {\n+      return;\n+    }\n+    lastFileChecked = syntacticScope.getRootNode().getSourceFileName();\n+    Var var = syntacticScope.getVar(varName);\n+    if (var == null || var.isTypeInferred()) {\n+      registry.registerUndeclaredPropertyOnType(varName, type);\n+      return;\n+    }\n+\n+    typeMismatchWarning(syntacticScope.getRootNode(), var, \"declared\", \"undeclared\", var.getType(), type);\n+  }\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}