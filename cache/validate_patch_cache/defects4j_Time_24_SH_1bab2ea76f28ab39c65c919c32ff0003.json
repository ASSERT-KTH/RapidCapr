{
    "patch": "import org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.IllegalFieldValueException;\n\n// ...\n\n    public long computeMillis(boolean resetFields, String text) {\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        sort(savedFields, count);\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (FieldUtils.compareReverse(first, months) >= 0 && FieldUtils.compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n                DateTimeField field = savedFields[i].iField;\n                int next = i + 1;\n                if (next < count && savedFields[next].iField == field) {\n                    // have two fields of same type next to each other\n                    // choose the lowest magnitude one.\n                    field = savedFields[next].iField.getRangeDurationField();\n                    int idx = i;\n                    long min = savedFields[i].getMillis();\n                    do {\n                        i = next;\n                        next += 1;\n                        if (next >= count) {\n                            break;\n                        }\n                    } while (savedFields[next].iField == field);\n                    // found a higher magnitude field, go back one\n                    if (savedFields[i].getMillis() != min) {\n                        i -= 1;\n                    }\n                    // Remove duplicate fields from the saved and cloned list\n                    System.arraycopy(savedFields, i + 1, savedFields, i, count - i - 1);\n                    count -= 1;\n                    System.arraycopy(iSavedFields, i + 1, iSavedFields, i, count - i);\n                    iSavedFields[count] = null;\n                    i -= 1;\n                }\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\": \");\n            }\n            throw e;\n        }\n        \n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n        \n        return millis;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..3f1190ad 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,87 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.IllegalFieldValueException;\n+\n+// ...\n+\n+    public long computeMillis(boolean resetFields, String text) {\n+        SavedField[] savedFields = iSavedFields;\n+        int count = iSavedFieldsCount;\n+        if (iSavedFieldsShared) {\n+            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+            iSavedFieldsShared = false;\n+        }\n+        sort(savedFields, count);\n+        if (count > 0) {\n+            // alter base year for parsing if first field is month or day\n+            DurationField months = DurationFieldType.months().getField(iChrono);\n+            DurationField days = DurationFieldType.days().getField(iChrono);\n+            DurationField first = savedFields[0].iField.getDurationField();\n+            if (FieldUtils.compareReverse(first, months) >= 0 && FieldUtils.compareReverse(first, days) <= 0) {\n+                saveField(DateTimeFieldType.year(), iDefaultYear);\n+                return computeMillis(resetFields, text);\n+            }\n+        }\n+\n+        long millis = iMillis;\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                millis = savedFields[i].set(millis, resetFields);\n+                DateTimeField field = savedFields[i].iField;\n+                int next = i + 1;\n+                if (next < count && savedFields[next].iField == field) {\n+                    // have two fields of same type next to each other\n+                    // choose the lowest magnitude one.\n+                    field = savedFields[next].iField.getRangeDurationField();\n+                    int idx = i;\n+                    long min = savedFields[i].getMillis();\n+                    do {\n+                        i = next;\n+                        next += 1;\n+                        if (next >= count) {\n+                            break;\n+                        }\n+                    } while (savedFields[next].iField == field);\n+                    // found a higher magnitude field, go back one\n+                    if (savedFields[i].getMillis() != min) {\n+                        i -= 1;\n+                    }\n+                    // Remove duplicate fields from the saved and cloned list\n+                    System.arraycopy(savedFields, i + 1, savedFields, i, count - i - 1);\n+                    count -= 1;\n+                    System.arraycopy(iSavedFields, i + 1, iSavedFields, i, count - i);\n+                    iSavedFields[count] = null;\n+                    i -= 1;\n+                }\n+            }\n+        } catch (IllegalFieldValueException e) {\n+            if (text != null) {\n+                e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\": \");\n+            }\n+            throw e;\n+        }\n+        \n+        if (iZone == null) {\n+            millis -= iOffset;\n+        } else {\n+            int offset = iZone.getOffsetFromLocal(millis);\n+            millis -= offset;\n+            if (offset != iZone.getOffset(millis)) {\n+                String message =\n+                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n+                if (text != null) {\n+                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n+                }\n+                throw new IllegalArgumentException(message);\n+            }\n+        }\n+        \n+        return millis;\n+    }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}