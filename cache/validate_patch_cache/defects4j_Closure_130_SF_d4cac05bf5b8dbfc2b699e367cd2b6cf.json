{
    "patch": "private boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n    Name originalName = ref.getName();\n    String originalPropName = ref.propertyName;\n\n    // Multiple variables declared with the same name and property is disallowed.\n    if (originalName.getDeclaration() != null && originalName.getDeclaration() != ref) {\n        return false;\n    }\n\n    if (!originalName.canCollapse()) {\n        return false;\n    }\n\n    boolean inlinable = false;\n    String debugName = null;\n    if (ref.getTwin() == null) {\n        Name newName = originalName.copyNamespace();\n        debugName = originalName.getFullName();\n        originalName.getParent().addOrReplaceChild(newName);\n        ref.getScope().declare(newName, originalPropName, ref);\n        inlinable = true;\n    } else if (ref.getTwin().type == Type.OBJECTLIT) {\n        // We only inline to object literals if all refs of the original property go to the same object literal.\n        ObjectLiteralTwin twin = (ObjectLiteralTwin) ref.getTwin();\n\n        if (twin.getOwnProperties().size() == 1 && newNameIsAllowed(twin)) {\n            Name newName = makeTemporaryName(ref);\n            ObjectLiteral originalLit = (ObjectLiteral) originalName.getParent();\n            ObjectLiteral newLit = twin.getObjectLiteral().copy(originalLit.getParent(), originalLit.getNext());\n\n            debugName = originalName.getFullName();\n            originalLit.getParent().addChildAfter(newLit, originalLit);\n            ref.getScope().declare(newName, originalPropName, ref);\n\n            newName.addRef(new Ref(newLit, newName, null, Type.ALIASING_GET));\n            newName.addRef(new Ref(null, newName, newLit, Type.OBJECTLIT));\n\n            inlinable = true;\n        }\n    }\n\n    if (inlinable) {\n        if (originalName.removeRef(ref)) {\n            removeUnreachableNames(originalName, namespace);\n        }\n\n        Node value;\n        if (ref.type == Type.GETPROP) {\n            value = ref.node.getFirstChild().detach();\n        } else {\n            value = ref.node.detachFromParent();\n        }\n\n        Node newAccess = newName(ref, true);\n        Node assign = IR.assign(newAccess, value).srcrefTree(ref.node);\n\n        if (ref.getTwin() == null) {\n            NodeUtil.addFeatureToScript(ref.getScope().getRootNode(), Feature.MEMBER_DECLARATIONS);\n            NodeUtil.addFeatureToScript(ref.getScope().getRootNode(), Feature.LET_DECLARATIONS);\n        }\n\n        Node expr = ref.node.isExprResult() ? ref.node : IR.exprResult(assign).srcrefTree(ref.node);\n        ref.node.getParent().replaceChild(ref.node, expr);\n\n        removeUnreachableNames(value, namespace);\n\n        if (debugName != null) {\n            logger.info(\"INLINED ALIAS \" + debugName + \" -> \" + newAccess.getQualifiedName());\n        }\n\n        return true;\n    }\n\n    return false;\n}\n\nprivate boolean newNameIsAllowed(ObjectLiteralTwin twin) {\n    // The new property name must be a valid identifier that is not a reserved keyword.\n    String propName = twin.getCloneName();\n    if (!TokenStream.isJSIdentifier(propName) || TokenStream.isKeyword(propName, false)) {\n        return false;\n    }\n\n    // Check if all refs to the original property map to the same object literal.\n    ObjectLiteral originalLit = (ObjectLiteral) twin.getDeclaration().getParent();\n    for (Ref ref : twin.getRefs()) {\n        if (ref != twin.getDeclaration() && ref.type == Type.ALIASING_GET) {\n            Node node = ref.node.getFirstChild();\n            String propName2 = node == null ? null : node.getString();\n\n            if (propName2 == null ||\n                    ref.getScope() != twin.getDeclaration().getScope() ||\n                    originalLit != ((ObjectLiteral) ref.node.getParent())) {\n                return false;\n            }\n            if (!propName.equals(propName2)) {\n                return false;\n            }\n        }\n    }\n    return true;\n}\n\nprivate Name makeTemporaryName(Ref ref) {\n    String newName = TEMP_NAME_PREFIX + idSupplier.get();\n    Scope scope = ref.node.getStaticScope();\n\n    if (!scope.isDeclared(newName, false)) {\n        return new Name(newName, null, null, ref.node.isFromExterns(), true);\n    }\n\n    return makeTemporaryName(ref);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..a0580d8d 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -158,43 +158,119 @@ class CollapseProperties implements CompilerPass {\n    *    inlineable.\n    * @see InlineVariables\n    */\n-  private void inlineAliases(GlobalNamespace namespace) {\n-    // Invariant: All the names in the worklist meet condition (a).\n-    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n-    while (!workList.isEmpty()) {\n-      Name name = workList.pop();\n-\n-      // Don't attempt to inline a getter or setter property as a variable.\n-      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n-        continue;\n-      }\n+private boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n+    Name originalName = ref.getName();\n+    String originalPropName = ref.propertyName;\n+\n+    // Multiple variables declared with the same name and property is disallowed.\n+    if (originalName.getDeclaration() != null && originalName.getDeclaration() != ref) {\n+        return false;\n+    }\n+\n+    if (!originalName.canCollapse()) {\n+        return false;\n+    }\n+\n+    boolean inlinable = false;\n+    String debugName = null;\n+    if (ref.getTwin() == null) {\n+        Name newName = originalName.copyNamespace();\n+        debugName = originalName.getFullName();\n+        originalName.getParent().addOrReplaceChild(newName);\n+        ref.getScope().declare(newName, originalPropName, ref);\n+        inlinable = true;\n+    } else if (ref.getTwin().type == Type.OBJECTLIT) {\n+        // We only inline to object literals if all refs of the original property go to the same object literal.\n+        ObjectLiteralTwin twin = (ObjectLiteralTwin) ref.getTwin();\n+\n+        if (twin.getOwnProperties().size() == 1 && newNameIsAllowed(twin)) {\n+            Name newName = makeTemporaryName(ref);\n+            ObjectLiteral originalLit = (ObjectLiteral) originalName.getParent();\n+            ObjectLiteral newLit = twin.getObjectLiteral().copy(originalLit.getParent(), originalLit.getNext());\n+\n+            debugName = originalName.getFullName();\n+            originalLit.getParent().addChildAfter(newLit, originalLit);\n+            ref.getScope().declare(newName, originalPropName, ref);\n+\n+            newName.addRef(new Ref(newLit, newName, null, Type.ALIASING_GET));\n+            newName.addRef(new Ref(null, newName, newLit, Type.OBJECTLIT));\n+\n+            inlinable = true;\n+        }\n+    }\n+\n+    if (inlinable) {\n+        if (originalName.removeRef(ref)) {\n+            removeUnreachableNames(originalName, namespace);\n+        }\n+\n+        Node value;\n+        if (ref.type == Type.GETPROP) {\n+            value = ref.node.getFirstChild().detach();\n+        } else {\n+            value = ref.node.detachFromParent();\n+        }\n+\n+        Node newAccess = newName(ref, true);\n+        Node assign = IR.assign(newAccess, value).srcrefTree(ref.node);\n+\n+        if (ref.getTwin() == null) {\n+            NodeUtil.addFeatureToScript(ref.getScope().getRootNode(), Feature.MEMBER_DECLARATIONS);\n+            NodeUtil.addFeatureToScript(ref.getScope().getRootNode(), Feature.LET_DECLARATIONS);\n+        }\n+\n+        Node expr = ref.node.isExprResult() ? ref.node : IR.exprResult(assign).srcrefTree(ref.node);\n+        ref.node.getParent().replaceChild(ref.node, expr);\n+\n+        removeUnreachableNames(value, namespace);\n+\n+        if (debugName != null) {\n+            logger.info(\"INLINED ALIAS \" + debugName + \" -> \" + newAccess.getQualifiedName());\n+        }\n+\n+        return true;\n+    }\n+\n+    return false;\n+}\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+private boolean newNameIsAllowed(ObjectLiteralTwin twin) {\n+    // The new property name must be a valid identifier that is not a reserved keyword.\n+    String propName = twin.getCloneName();\n+    if (!TokenStream.isJSIdentifier(propName) || TokenStream.isKeyword(propName, false)) {\n+        return false;\n+    }\n+\n+    // Check if all refs to the original property map to the same object literal.\n+    ObjectLiteral originalLit = (ObjectLiteral) twin.getDeclaration().getParent();\n+    for (Ref ref : twin.getRefs()) {\n+        if (ref != twin.getDeclaration() && ref.type == Type.ALIASING_GET) {\n+            Node node = ref.node.getFirstChild();\n+            String propName2 = node == null ? null : node.getString();\n+\n+            if (propName2 == null ||\n+                    ref.getScope() != twin.getDeclaration().getScope() ||\n+                    originalLit != ((ObjectLiteral) ref.node.getParent())) {\n+                return false;\n+            }\n+            if (!propName.equals(propName2)) {\n+                return false;\n             }\n-          }\n         }\n-      }\n+    }\n+    return true;\n+}\n \n-      // Check if {@code name} has any aliases left after the\n-      // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n-           name.type == Name.Type.FUNCTION) &&\n-          name.aliasingGets == 0 && name.props != null) {\n-        // All of {@code name}'s children meet condition (a), so they can be\n-        // added to the worklist.\n-        workList.addAll(name.props);\n-      }\n+private Name makeTemporaryName(Ref ref) {\n+    String newName = TEMP_NAME_PREFIX + idSupplier.get();\n+    Scope scope = ref.node.getStaticScope();\n+\n+    if (!scope.isDeclared(newName, false)) {\n+        return new Name(newName, null, null, ref.node.isFromExterns(), true);\n     }\n-  }\n+\n+    return makeTemporaryName(ref);\n+}\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n     // Ensure that the alias is assigned to a local variable at that",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}