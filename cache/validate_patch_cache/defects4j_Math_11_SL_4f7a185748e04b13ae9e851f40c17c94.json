{
    "patch": "public class MultivariateNormalDistribution extends AbstractMultivariateRealDistribution {\n    /** Covariance matrix. */\n    private final RealMatrix covarianceMatrix;\n    /** Inverse of the covariance matrix. */\n    private final RealMatrix covarianceMatrixInverse;\n    /** The determinant of the covariance matrix. */\n    private final double covarianceMatrixDeterminant;\n    /** The constant factor of the density function. */\n    private final double denominator;\n\n    /**\n     * Creates a multivariate normal distribution with the given mean vector and\n     * covariance matrix.\n     *\n     * @param means Mean vector.\n     * @param covariance Covariance matrix.\n     * @throws org.apache.commons.math3.exception.NotPositiveDefiniteMatrixException\n     * if the covariance matrix is not symmetric positive definite.\n     * @see <a href=\"http://en.wikipedia.org/wiki/Positive-definite_matrix\">Positive-definite matrix</a>\n     */\n    public MultivariateNormalDistribution(final double[] means, final double[][] covariance)\n        throws NotPositiveDefiniteMatrixException {\n        this(new Well19937c(), means, covariance, 1E-9);\n    }\n\n    /**\n     * Creates a multivariate normal distribution with the given mean vector and\n     * covariance matrix using the given generator for the\n     * {@link #nextVector() nextVector} method (if needed).\n     *\n     * @param rng random number generator to use for sampling Gaussian\n     *             distributed entries if needed.\n     * @param means Mean vector.\n     * @param covariance Covariance matrix.\n     * @throws NotPositiveDefiniteMatrixException if the covariance matrix is not symmetric positive definite.\n     * @since 3.1\n     * @see <a href=\"http://en.wikipedia.org/wiki/Positive-definite_matrix\">Positive-definite matrix</a>\n     */\n    public MultivariateNormalDistribution(final RandomGenerator rng, final double[] means,\n                                           final double[][] covariance) throws NotPositiveDefiniteMatrixException {\n        this(rng, means, covariance, 1E-9);\n    }\n\n    /**\n     * Creates a multivariate normal distribution with the given mean vector and\n     * covariance matrix using the given generator for the\n     * {@link #nextVector() nextVector} method (if needed).\n     *\n     * @param rng random number generator to use for sampling Gaussian\n     *             distributed entries if needed.\n     * @param means Mean vector.\n     * @param cov Covariance matrix.\n     * @param small Small eigenvalue cutoff for matrix regularization.\n     * @throws org.apache.commons.math3.exception.NotPositiveDefiniteMatrixException\n     * if the covariance matrix is not symmetric positive definite.\n     * @see <a href=\"http://en.wikipedia.org/wiki/Positive-definite_matrix\">Positive-definite matrix</a>\n     */\n    public MultivariateNormalDistribution(final RandomGenerator rng, final double[] means, final double[][] cov, final double small)\n        throws NotPositiveDefiniteMatrixException {\n        super(means.length);\n        validateCovarianceMatrix(cov);\n        final int dim = getDimension();\n        covarianceMatrix = MatrixUtils.createRealMatrix(cov);\n        final LUDecomposition decomposition = new LUDecomposition(covarianceMatrix);\n        covarianceMatrixDeterminant = decomposition.getDeterminant();\n        covarianceMatrixInverse = decomposition.getSolver().getInverse();\n        denominator = Math.sqrt(Math.pow(2 * Math.PI, dim) * covarianceMatrixDeterminant);\n        setRandomGenerator(rng);\n    }\n\n    /**\n     * Check if provided matrix is symmetric positive definite.\n     *\n     * @param m Symmetric matrix.\n     * @throws NotPositiveDefiniteMatrixException if the matrix is not symmetric positive definite.\n     */\n    private static void validateCovarianceMatrix(final double[][] m) throws NotPositiveDefiniteMatrixException {\n        if (!MatrixUtils.isSymmetric(m, Math.ulp(1d))) {\n            throw new NotPositiveDefiniteMatrixException(LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n        }\n        final EigenDecomposition decomposition = new EigenDecomposition(new Array2DRowRealMatrix(m), Double.MIN_VALUE);\n        if (!decomposition.getRealEigenvaluesStream().allMatch(x -> x > 0)) {\n            throw new NotPositiveDefiniteMatrixException(m.length);\n        }\n    }\n\n    /**\n     * Returns the density of the distribution at the specified point {@code x}.\n     *\n     * @param vals Point at which to compute the density.\n     * @return the density at {@code x}.\n     * @throws DimensionMismatchException if the dimension of {@code x} does not match the distribution's dimension.\n     */\n    public double density(final double[] vals) throws DimensionMismatchException {\n        final int dim = getDimension();\n        if (vals.length != dim) {\n            throw new DimensionMismatchException(vals.length, dim);\n        }\n\n        return 1.0 / (FastMath.pow(2 * FastMath.PI, dim / 2.0) * FastMath.sqrt(covarianceMatrixDeterminant)) *\n            getExponentTerm(vals);\n    }\n\n\n    /**\n     * Access the covariance matrix.\n     *\n     * @return covariance matrix\n     */\n    public RealMatrix getCovariances() {\n        return covarianceMatrix.copy();\n    }\n\n    /**\n     * Access the mean vector.\n     *\n     * @return mean vector\n     */\n    public double[] getMeans() {\n        return getMean();\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The implementation uses the formulas:<br>\n     * <code>\n     *   B = getMatrixSquareRoot(covarianceMatrix) <br>\n     *   y = B z + location\n     *  </code>\n     *\n     * @return a random point sampled according to the distribution.\n     */\n    @Override\n    public double[] sample() {\n        final int dim = getDimension();\n        final double[] norm = new double[dim];\n        for (int i = 0; i < dim; i++) {\n            norm[i] = getRandomGenerator().nextGaussian();\n        }\n        final RealMatrix L = getMatrixSquareRoot(covarianceMatrix);\n        final double[] deviate = L.operate(norm);\n        return MathArrays.ebeAdd(deviate, getMean());\n    }\n\n    /**\n     * {@inheritDoc}\n     *\n     * The covariance matrix is the matrix whose upper-triangular portion of its\n     * Cholesky decomposition is given as model parameters. This means that\n     * {@code covarianceMatrix} has the same entries below the diagonal as\n     * its Cholesky decomposition; the entries above the diagonal are ignored.\n     */\n    @Override\n    protected void fillDensity(double[] res) {\n        final double[] v = new double[getDimension()];\n        double wanted = 1;\n        for (int i = 0; i < v.length; i++) {\n            v[i] = Math.sqrt(chiSquare.nextGamma(0.5*degreesOfFreedom[i], 0.5));\n            wanted *= v[i];\n        }\n        double[] tmpRes = new double[1];\n\n        // gaussians:\n        for (int i = 0; i < mean.length; i++) {\n            final int idx = i;\n            UnivariateFunction integrand = argument -> {\n                v[idx] = argument;\n                double density = density(v);\n                return density*density;\n            };\n            try {\n                tmpRes[0] = new SimpsonIntegrator(1e-5, 1e-7, 10).integrate(Integer.MAX_VALUE, integrand, 0, Double.POSITIVE_INFINITY);\n                res[0] += tmpRes[0];\n            } catch (TooManyEvaluationsException e) {\n                res[0] += tmpRes[0];\n            }\n        }\n        res[0] *= wanted;\n    }\n\n    /**\n     * Returns the exponent of the density term for the specified point.\n     *\n     * @param values Point at which to compute the exponent.\n     * @return the exponent of the density term for the specified point.\n     * @throws DimensionMismatchException if the length of {@code values} is not the same as the distribution's dimension.\n     */\n    private double getExponentTerm(final double[] values) throws DimensionMismatchException {\n        final double[] deviation = MathArrays.ebeSubtract(values, getMean());\n        final double[] preMultiplied = covarianceMatrixInverse.preMultiply(deviation);\n        return MathArrays.dot(deviation, preMultiplied) / -2d;\n    }\n\n    /**\n     * @param m Symmetric positive definite matrix.\n     * @return matrix square root of a given matrix.\n     * @throws NotPositiveDefiniteMatrixException if the matrix is not symmetric positive definite.\n     */\n    private static RealMatrix getMatrixSquareRoot(final RealMatrix m)\n        throws NotPositiveDefiniteMatrixException {\n        final EigenDecomposition decomposition = new EigenDecomposition(m, Double.MIN_VALUE);\n        final RealMatrix sqrt = decomposition.getSquareRoot();\n        final RealMatrix sqrtInverse = new LUDecomposition(sqrt).getSolver().getInverse();\n        return sqrt.multiply(sqrtInverse);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\nindex 15706811b..5e8cfefb9 100644\n--- a/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n+++ b/src/main/java/org/apache/commons/math3/distribution/MultivariateNormalDistribution.java\n@@ -180,7 +180,213 @@ public class MultivariateNormalDistribution\n             throw new DimensionMismatchException(vals.length, dim);\n         }\n \n-        return FastMath.pow(2 * FastMath.PI, -dim / 2) *\n+public class MultivariateNormalDistribution extends AbstractMultivariateRealDistribution {\n+    /** Covariance matrix. */\n+    private final RealMatrix covarianceMatrix;\n+    /** Inverse of the covariance matrix. */\n+    private final RealMatrix covarianceMatrixInverse;\n+    /** The determinant of the covariance matrix. */\n+    private final double covarianceMatrixDeterminant;\n+    /** The constant factor of the density function. */\n+    private final double denominator;\n+\n+    /**\n+     * Creates a multivariate normal distribution with the given mean vector and\n+     * covariance matrix.\n+     *\n+     * @param means Mean vector.\n+     * @param covariance Covariance matrix.\n+     * @throws org.apache.commons.math3.exception.NotPositiveDefiniteMatrixException\n+     * if the covariance matrix is not symmetric positive definite.\n+     * @see <a href=\"http://en.wikipedia.org/wiki/Positive-definite_matrix\">Positive-definite matrix</a>\n+     */\n+    public MultivariateNormalDistribution(final double[] means, final double[][] covariance)\n+        throws NotPositiveDefiniteMatrixException {\n+        this(new Well19937c(), means, covariance, 1E-9);\n+    }\n+\n+    /**\n+     * Creates a multivariate normal distribution with the given mean vector and\n+     * covariance matrix using the given generator for the\n+     * {@link #nextVector() nextVector} method (if needed).\n+     *\n+     * @param rng random number generator to use for sampling Gaussian\n+     *             distributed entries if needed.\n+     * @param means Mean vector.\n+     * @param covariance Covariance matrix.\n+     * @throws NotPositiveDefiniteMatrixException if the covariance matrix is not symmetric positive definite.\n+     * @since 3.1\n+     * @see <a href=\"http://en.wikipedia.org/wiki/Positive-definite_matrix\">Positive-definite matrix</a>\n+     */\n+    public MultivariateNormalDistribution(final RandomGenerator rng, final double[] means,\n+                                           final double[][] covariance) throws NotPositiveDefiniteMatrixException {\n+        this(rng, means, covariance, 1E-9);\n+    }\n+\n+    /**\n+     * Creates a multivariate normal distribution with the given mean vector and\n+     * covariance matrix using the given generator for the\n+     * {@link #nextVector() nextVector} method (if needed).\n+     *\n+     * @param rng random number generator to use for sampling Gaussian\n+     *             distributed entries if needed.\n+     * @param means Mean vector.\n+     * @param cov Covariance matrix.\n+     * @param small Small eigenvalue cutoff for matrix regularization.\n+     * @throws org.apache.commons.math3.exception.NotPositiveDefiniteMatrixException\n+     * if the covariance matrix is not symmetric positive definite.\n+     * @see <a href=\"http://en.wikipedia.org/wiki/Positive-definite_matrix\">Positive-definite matrix</a>\n+     */\n+    public MultivariateNormalDistribution(final RandomGenerator rng, final double[] means, final double[][] cov, final double small)\n+        throws NotPositiveDefiniteMatrixException {\n+        super(means.length);\n+        validateCovarianceMatrix(cov);\n+        final int dim = getDimension();\n+        covarianceMatrix = MatrixUtils.createRealMatrix(cov);\n+        final LUDecomposition decomposition = new LUDecomposition(covarianceMatrix);\n+        covarianceMatrixDeterminant = decomposition.getDeterminant();\n+        covarianceMatrixInverse = decomposition.getSolver().getInverse();\n+        denominator = Math.sqrt(Math.pow(2 * Math.PI, dim) * covarianceMatrixDeterminant);\n+        setRandomGenerator(rng);\n+    }\n+\n+    /**\n+     * Check if provided matrix is symmetric positive definite.\n+     *\n+     * @param m Symmetric matrix.\n+     * @throws NotPositiveDefiniteMatrixException if the matrix is not symmetric positive definite.\n+     */\n+    private static void validateCovarianceMatrix(final double[][] m) throws NotPositiveDefiniteMatrixException {\n+        if (!MatrixUtils.isSymmetric(m, Math.ulp(1d))) {\n+            throw new NotPositiveDefiniteMatrixException(LocalizedFormats.NOT_SYMMETRIC_MATRIX);\n+        }\n+        final EigenDecomposition decomposition = new EigenDecomposition(new Array2DRowRealMatrix(m), Double.MIN_VALUE);\n+        if (!decomposition.getRealEigenvaluesStream().allMatch(x -> x > 0)) {\n+            throw new NotPositiveDefiniteMatrixException(m.length);\n+        }\n+    }\n+\n+    /**\n+     * Returns the density of the distribution at the specified point {@code x}.\n+     *\n+     * @param vals Point at which to compute the density.\n+     * @return the density at {@code x}.\n+     * @throws DimensionMismatchException if the dimension of {@code x} does not match the distribution's dimension.\n+     */\n+    public double density(final double[] vals) throws DimensionMismatchException {\n+        final int dim = getDimension();\n+        if (vals.length != dim) {\n+            throw new DimensionMismatchException(vals.length, dim);\n+        }\n+\n+        return 1.0 / (FastMath.pow(2 * FastMath.PI, dim / 2.0) * FastMath.sqrt(covarianceMatrixDeterminant)) *\n+            getExponentTerm(vals);\n+    }\n+\n+\n+    /**\n+     * Access the covariance matrix.\n+     *\n+     * @return covariance matrix\n+     */\n+    public RealMatrix getCovariances() {\n+        return covarianceMatrix.copy();\n+    }\n+\n+    /**\n+     * Access the mean vector.\n+     *\n+     * @return mean vector\n+     */\n+    public double[] getMeans() {\n+        return getMean();\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The implementation uses the formulas:<br>\n+     * <code>\n+     *   B = getMatrixSquareRoot(covarianceMatrix) <br>\n+     *   y = B z + location\n+     *  </code>\n+     *\n+     * @return a random point sampled according to the distribution.\n+     */\n+    @Override\n+    public double[] sample() {\n+        final int dim = getDimension();\n+        final double[] norm = new double[dim];\n+        for (int i = 0; i < dim; i++) {\n+            norm[i] = getRandomGenerator().nextGaussian();\n+        }\n+        final RealMatrix L = getMatrixSquareRoot(covarianceMatrix);\n+        final double[] deviate = L.operate(norm);\n+        return MathArrays.ebeAdd(deviate, getMean());\n+    }\n+\n+    /**\n+     * {@inheritDoc}\n+     *\n+     * The covariance matrix is the matrix whose upper-triangular portion of its\n+     * Cholesky decomposition is given as model parameters. This means that\n+     * {@code covarianceMatrix} has the same entries below the diagonal as\n+     * its Cholesky decomposition; the entries above the diagonal are ignored.\n+     */\n+    @Override\n+    protected void fillDensity(double[] res) {\n+        final double[] v = new double[getDimension()];\n+        double wanted = 1;\n+        for (int i = 0; i < v.length; i++) {\n+            v[i] = Math.sqrt(chiSquare.nextGamma(0.5*degreesOfFreedom[i], 0.5));\n+            wanted *= v[i];\n+        }\n+        double[] tmpRes = new double[1];\n+\n+        // gaussians:\n+        for (int i = 0; i < mean.length; i++) {\n+            final int idx = i;\n+            UnivariateFunction integrand = argument -> {\n+                v[idx] = argument;\n+                double density = density(v);\n+                return density*density;\n+            };\n+            try {\n+                tmpRes[0] = new SimpsonIntegrator(1e-5, 1e-7, 10).integrate(Integer.MAX_VALUE, integrand, 0, Double.POSITIVE_INFINITY);\n+                res[0] += tmpRes[0];\n+            } catch (TooManyEvaluationsException e) {\n+                res[0] += tmpRes[0];\n+            }\n+        }\n+        res[0] *= wanted;\n+    }\n+\n+    /**\n+     * Returns the exponent of the density term for the specified point.\n+     *\n+     * @param values Point at which to compute the exponent.\n+     * @return the exponent of the density term for the specified point.\n+     * @throws DimensionMismatchException if the length of {@code values} is not the same as the distribution's dimension.\n+     */\n+    private double getExponentTerm(final double[] values) throws DimensionMismatchException {\n+        final double[] deviation = MathArrays.ebeSubtract(values, getMean());\n+        final double[] preMultiplied = covarianceMatrixInverse.preMultiply(deviation);\n+        return MathArrays.dot(deviation, preMultiplied) / -2d;\n+    }\n+\n+    /**\n+     * @param m Symmetric positive definite matrix.\n+     * @return matrix square root of a given matrix.\n+     * @throws NotPositiveDefiniteMatrixException if the matrix is not symmetric positive definite.\n+     */\n+    private static RealMatrix getMatrixSquareRoot(final RealMatrix m)\n+        throws NotPositiveDefiniteMatrixException {\n+        final EigenDecomposition decomposition = new EigenDecomposition(m, Double.MIN_VALUE);\n+        final RealMatrix sqrt = decomposition.getSquareRoot();\n+        final RealMatrix sqrtInverse = new LUDecomposition(sqrt).getSolver().getInverse();\n+        return sqrt.multiply(sqrtInverse);\n+    }\n+}\n             FastMath.pow(covarianceMatrixDeterminant, -0.5) *\n             getExponentTerm(vals);\n     }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}