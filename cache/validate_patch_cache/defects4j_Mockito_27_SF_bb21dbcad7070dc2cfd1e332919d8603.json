{
    "patch": "import org.mockito.internal.creation.bytebuddy.MocksCreationSettings;\nimport org.mockito.internal.invocation.realmethod.CombinedMatcher;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.internal.util.Supplier;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.MockHandler;\nimport org.mockito.listeners.MockCreationListener;\nimport org.mockito.mock.MockCreationSettings;\nimport org.mockito.mock.MockName;\nimport org.mockito.mock.SerializableMode;\nimport org.mockito.plugins.MockMaker;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.Stubber;\nimport org.mockito.stubbing.VoidAnswer1;\n\nimport java.util.Collection;\nimport java.util.LinkedList;\nimport java.util.List;\nimport java.util.Set;\nimport java.util.concurrent.Callable;\nimport java.util.function.Consumer;\nimport java.util.function.Function;\n\nimport static org.mockito.Mockito.withSettings;\nimport static org.mockito.internal.configuration.plugins.Plugins.getMockMaker;\n\npublic final class AdditionalMockitoMethods {\n\n    private AdditionalMockitoMethods() {\n    }\n\n    public static <T> T resetMock(T mock) {\n        ((InternalMockHandler) MockUtil.getMockHandler(mock)).resetMock();\n        return mock;\n    }\n\n    public static <T> T deepStubMock(T mock) {\n        getMockSettings(mock).serializable();\n        MocksCreationSettings<T> settings = new MocksCreationSettings<>(getMockSettings(mock), MockUtil.getType(mock),  mock.getClass().getInterfaces(), true, true, true, true, true);\n        MockMaker mockMaker = getMockMaker();\n        MockCreationListener listener = getMockManager().getMockCreationListener();\n        MockName name = getMockSettings(mock).getName();\n        Set<Class<?>> extraInterfaces = getMockSettings(mock).getExtraInterfaces();\n        Collection<MockHandler<T>> mockHandlers = mockMaker.createMock(MockHandler.class, settings);\n        List<MockHandler<T>> mockHandlersList = new LinkedList<>(mockHandlers);\n        T proxy = callbackHandlerToMock(mockHandlersList, name, extraInterfaces, mockMaker);\n        onMockCreation(proxy, listener);\n        for (int i=0; i<mockHandlersList.size(); i++) {\n            Consumer<MockHandler<?>> mockHandlerAcceptor = getMockManager().getMockHandlerAcceptor();\n            if (mockHandlerAcceptor != null) {\n                mockHandlerAcceptor.accept(mockHandlersList.get(i));\n            }\n            ((Factory) proxy).setCallback(i, new MethodInterceptorFilter(mockHandlersList.get(i), (MockSettingsImpl) settings.getMockSettings()));\n        }\n\n        return proxy;\n    }\n\n    private static <T> T callbackHandlerToMock(List<MockHandler<T>> mockHandlers, MockName name, Set<Class<?>> extraInterfaces, MockMaker mockMaker) {\n        if (extraInterfaces == null) {\n            extraInterfaces = MockUtil.getExtraInterfaces(mockHandlers);\n        }\n        return mockMaker.createMock(MockCreationSettings.withCallback(mockHandlers, name, extraInterfaces));\n    }\n\n    private static <T> MockCreationSettings<T> getMockSettings(T mock) {\n        if (MockUtil.isMock(mock)) {\n            return (MockCreationSettings<T>) MockUtil.getMockSettings(mock);\n        }\n        return (MockCreationSettings<T>) withSettings().build();\n    }\n\n    private static void onMockCreation(Object mock, MockCreationListener listener) {\n        if (listener == null)\n            return;\n        try {\n            Invocation invocation = listener.onMockCreated((Mock) mock, MockUtil.getType(mock));\n            if (invocation != null) {\n                ((Factory) mock).setCallback(0, new ReturnValueWrapper(invocation.callRealMethod()));\n            }\n        } catch (RuntimeException e) {\n            throw e;\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        }\n    }\n\n    private static MockManager getMockManager() {\n        return mockitoSession().getMockManager();\n    }\n\n    private static MockitoSession mockitoSession() {\n        return MockitoCore.instance().mockitoSession();\n    }\n\n    public static <T> void addAnswer(Answer<T> answer) {\n        ((InternalMockHandler) getMockManager().getMockHandler()).addAnswer(answer);\n    }\n\n    public static <T> void addVoidAnswer(VoidAnswer1<T> answer) {\n        ((InternalMockHandler) getMockManager().getMockHandler()).addVoidAnswer(answer);\n    }\n\n    public static <T> void setDefaultAnswer(Answer<T> answer) {\n        getMockSettings(null).defaultAnswers(answer);\n    }\n\n    public static Stubber doAnswer(Answer answer) {\n        return getMockManager().doAnswer(answer);\n    }\n\n    public static void clearInvocations(Object ... mocks) {\n        getMockManager().clearInvocations(mocks);\n    }\n\n    public static void clearInvocations(List mocks) {\n        getMockManager().clearInvocations(mocks);\n    }\n\n    public static void clearInvocations(Object mock) {\n        getMockManager().clearInvocations(mock);\n    }\n\n    public static void resetInvocations() {\n        getMockManager().resetCalls();\n    }\n\n    public static List<Invocation> getInvocationContainerStorage() {\n        return ((InternalMockHandler) getMockManager().getMockHandler()).getInvocationContainerStorage();\n    }\n\n    public static void addMatchers(List<CombinedMatcher> matchers) {\n        ((InternalMockHandler) getMockManager().getMockHandler()).addMatchers(matchers);\n    }\n\n    public static Invocation getLastInvocation() {\n        return ((InternalMockHandler) getMockManager().getMockHandler()).getLastInvocation();\n    }\n\n    private static class InternalMockHandler<T> implements MockHandler<T> {\n        private final MockHandler<T> delegate;\n        private final List<Answer> answers = new LinkedList<>();\n        private final List<VoidAnswer1> voidAnswers = new LinkedList<>();\n        private final List<CombinedMatcher> matchers = new LinkedList<>();\n        private final List<Invocation> invocationContainerStorage = new LinkedList<>();\n\n        public InternalMockHandler(MockHandler<T> delegate) {\n            this.delegate = delegate;\n        }\n\n        @Override\n        public T handle(Invocation invocation) throws Throwable {\n            invocationContainerStorage.add(invocation);\n            return delegate.handle(invocation);\n        }\n\n        public void addAnswer(Answer answer) {\n            answers.add(answer);\n        }\n\n        public void addVoidAnswer(VoidAnswer1 voidAnswer) {\n            voidAnswers.add(voidAnswer);\n        }\n\n        public void addMatchers(List<CombinedMatcher> matchers) {\n            this.matchers.addAll(matchers);\n        }\n\n        public void resetMock() {\n            answers.clear();\n            voidAnswers.clear();\n            matchers.clear();\n            invocationContainerStorage.clear();\n        }\n\n        public List<Invocation> getInvocationContainerStorage() {\n            return invocationContainerStorage;\n        }\n\n        public Invocation getLastInvocation() {\n            return invocationContainerStorage.get(invocationContainerStorage.size() - 1);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..6083379bf 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,191 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.internal.creation.bytebuddy.MocksCreationSettings;\n+import org.mockito.internal.invocation.realmethod.CombinedMatcher;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.internal.util.Supplier;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandler;\n+import org.mockito.listeners.MockCreationListener;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockName;\n+import org.mockito.mock.SerializableMode;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.Stubber;\n+import org.mockito.stubbing.VoidAnswer1;\n+\n+import java.util.Collection;\n+import java.util.LinkedList;\n+import java.util.List;\n+import java.util.Set;\n+import java.util.concurrent.Callable;\n+import java.util.function.Consumer;\n+import java.util.function.Function;\n+\n+import static org.mockito.Mockito.withSettings;\n+import static org.mockito.internal.configuration.plugins.Plugins.getMockMaker;\n+\n+public final class AdditionalMockitoMethods {\n+\n+    private AdditionalMockitoMethods() {\n+    }\n+\n+    public static <T> T resetMock(T mock) {\n+        ((InternalMockHandler) MockUtil.getMockHandler(mock)).resetMock();\n+        return mock;\n+    }\n+\n+    public static <T> T deepStubMock(T mock) {\n+        getMockSettings(mock).serializable();\n+        MocksCreationSettings<T> settings = new MocksCreationSettings<>(getMockSettings(mock), MockUtil.getType(mock),  mock.getClass().getInterfaces(), true, true, true, true, true);\n+        MockMaker mockMaker = getMockMaker();\n+        MockCreationListener listener = getMockManager().getMockCreationListener();\n+        MockName name = getMockSettings(mock).getName();\n+        Set<Class<?>> extraInterfaces = getMockSettings(mock).getExtraInterfaces();\n+        Collection<MockHandler<T>> mockHandlers = mockMaker.createMock(MockHandler.class, settings);\n+        List<MockHandler<T>> mockHandlersList = new LinkedList<>(mockHandlers);\n+        T proxy = callbackHandlerToMock(mockHandlersList, name, extraInterfaces, mockMaker);\n+        onMockCreation(proxy, listener);\n+        for (int i=0; i<mockHandlersList.size(); i++) {\n+            Consumer<MockHandler<?>> mockHandlerAcceptor = getMockManager().getMockHandlerAcceptor();\n+            if (mockHandlerAcceptor != null) {\n+                mockHandlerAcceptor.accept(mockHandlersList.get(i));\n+            }\n+            ((Factory) proxy).setCallback(i, new MethodInterceptorFilter(mockHandlersList.get(i), (MockSettingsImpl) settings.getMockSettings()));\n+        }\n+\n+        return proxy;\n+    }\n+\n+    private static <T> T callbackHandlerToMock(List<MockHandler<T>> mockHandlers, MockName name, Set<Class<?>> extraInterfaces, MockMaker mockMaker) {\n+        if (extraInterfaces == null) {\n+            extraInterfaces = MockUtil.getExtraInterfaces(mockHandlers);\n+        }\n+        return mockMaker.createMock(MockCreationSettings.withCallback(mockHandlers, name, extraInterfaces));\n+    }\n+\n+    private static <T> MockCreationSettings<T> getMockSettings(T mock) {\n+        if (MockUtil.isMock(mock)) {\n+            return (MockCreationSettings<T>) MockUtil.getMockSettings(mock);\n+        }\n+        return (MockCreationSettings<T>) withSettings().build();\n+    }\n+\n+    private static void onMockCreation(Object mock, MockCreationListener listener) {\n+        if (listener == null)\n+            return;\n+        try {\n+            Invocation invocation = listener.onMockCreated((Mock) mock, MockUtil.getType(mock));\n+            if (invocation != null) {\n+                ((Factory) mock).setCallback(0, new ReturnValueWrapper(invocation.callRealMethod()));\n+            }\n+        } catch (RuntimeException e) {\n+            throw e;\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        }\n+    }\n+\n+    private static MockManager getMockManager() {\n+        return mockitoSession().getMockManager();\n+    }\n+\n+    private static MockitoSession mockitoSession() {\n+        return MockitoCore.instance().mockitoSession();\n+    }\n+\n+    public static <T> void addAnswer(Answer<T> answer) {\n+        ((InternalMockHandler) getMockManager().getMockHandler()).addAnswer(answer);\n+    }\n+\n+    public static <T> void addVoidAnswer(VoidAnswer1<T> answer) {\n+        ((InternalMockHandler) getMockManager().getMockHandler()).addVoidAnswer(answer);\n+    }\n+\n+    public static <T> void setDefaultAnswer(Answer<T> answer) {\n+        getMockSettings(null).defaultAnswers(answer);\n+    }\n+\n+    public static Stubber doAnswer(Answer answer) {\n+        return getMockManager().doAnswer(answer);\n+    }\n+\n+    public static void clearInvocations(Object ... mocks) {\n+        getMockManager().clearInvocations(mocks);\n+    }\n+\n+    public static void clearInvocations(List mocks) {\n+        getMockManager().clearInvocations(mocks);\n+    }\n+\n+    public static void clearInvocations(Object mock) {\n+        getMockManager().clearInvocations(mock);\n+    }\n+\n+    public static void resetInvocations() {\n+        getMockManager().resetCalls();\n+    }\n+\n+    public static List<Invocation> getInvocationContainerStorage() {\n+        return ((InternalMockHandler) getMockManager().getMockHandler()).getInvocationContainerStorage();\n+    }\n+\n+    public static void addMatchers(List<CombinedMatcher> matchers) {\n+        ((InternalMockHandler) getMockManager().getMockHandler()).addMatchers(matchers);\n+    }\n+\n+    public static Invocation getLastInvocation() {\n+        return ((InternalMockHandler) getMockManager().getMockHandler()).getLastInvocation();\n+    }\n+\n+    private static class InternalMockHandler<T> implements MockHandler<T> {\n+        private final MockHandler<T> delegate;\n+        private final List<Answer> answers = new LinkedList<>();\n+        private final List<VoidAnswer1> voidAnswers = new LinkedList<>();\n+        private final List<CombinedMatcher> matchers = new LinkedList<>();\n+        private final List<Invocation> invocationContainerStorage = new LinkedList<>();\n+\n+        public InternalMockHandler(MockHandler<T> delegate) {\n+            this.delegate = delegate;\n+        }\n+\n+        @Override\n+        public T handle(Invocation invocation) throws Throwable {\n+            invocationContainerStorage.add(invocation);\n+            return delegate.handle(invocation);\n+        }\n+\n+        public void addAnswer(Answer answer) {\n+            answers.add(answer);\n+        }\n+\n+        public void addVoidAnswer(VoidAnswer1 voidAnswer) {\n+            voidAnswers.add(voidAnswer);\n+        }\n+\n+        public void addMatchers(List<CombinedMatcher> matchers) {\n+            this.matchers.addAll(matchers);\n+        }\n+\n+        public void resetMock() {\n+            answers.clear();\n+            voidAnswers.clear();\n+            matchers.clear();\n+            invocationContainerStorage.clear();\n+        }\n+\n+        public List<Invocation> getInvocationContainerStorage() {\n+            return invocationContainerStorage;\n+        }\n+\n+        public Invocation getLastInvocation() {\n+            return invocationContainerStorage.get(invocationContainerStorage.size() - 1);\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}