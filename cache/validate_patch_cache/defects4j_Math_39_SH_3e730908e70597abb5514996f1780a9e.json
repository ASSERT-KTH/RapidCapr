{
    "patch": "        stepSize = hNew;\n        \n        // next stages\n        for (int k = 1; k < stages; ++k) {\n\n          for (int j = 0; j < y0.length; ++j) {\n            double sum = a[k-1][0] * yDotK[0][j];\n            for (int l = 1; l < k; ++l) {\n              sum += a[k-1][l] * yDotK[l][j];\n            }\n            yTmp[j] = y[j] + stepSize * sum;\n          }\n\n          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n\n        }\n\n        // estimate the state at the end of the step\n        for (int j = 0; j < y0.length; ++j) {\n          double sum    = b[0] * yDotK[0][j];\n          for (int l = 1; l < stages; ++l) {\n            sum    += b[l] * yDotK[l][j];\n          }\n          yTmp[j] = y[j] + stepSize * sum;\n        }\n\n        // estimate the error at the end of the step\n        error = estimateError(yDotK, y, yTmp, stepSize);\n        if (error >= 1.0) {\n          // reject the step and attempt to reduce error by stepsize control\n          final double factor =\n              FastMath.min(maxGrowth,\n                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n          hNew = filterStep(stepSize * factor, forward, false);\n\n        }\n\n      }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..af8f7b1a3 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,44 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+        stepSize = hNew;\n+        \n+        // next stages\n+        for (int k = 1; k < stages; ++k) {\n+\n+          for (int j = 0; j < y0.length; ++j) {\n+            double sum = a[k-1][0] * yDotK[0][j];\n+            for (int l = 1; l < k; ++l) {\n+              sum += a[k-1][l] * yDotK[l][j];\n+            }\n+            yTmp[j] = y[j] + stepSize * sum;\n+          }\n+\n+          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+\n+        }\n+\n+        // estimate the state at the end of the step\n+        for (int j = 0; j < y0.length; ++j) {\n+          double sum    = b[0] * yDotK[0][j];\n+          for (int l = 1; l < stages; ++l) {\n+            sum    += b[l] * yDotK[l][j];\n+          }\n+          yTmp[j] = y[j] + stepSize * sum;\n+        }\n+\n+        // estimate the error at the end of the step\n+        error = estimateError(yDotK, y, yTmp, stepSize);\n+        if (error >= 1.0) {\n+          // reject the step and attempt to reduce error by stepsize control\n+          final double factor =\n+              FastMath.min(maxGrowth,\n+                           FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+          hNew = filterStep(stepSize * factor, forward, false);\n+\n+        }\n+\n+      }\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: while expected",
    "test_result": "ERROR"
}