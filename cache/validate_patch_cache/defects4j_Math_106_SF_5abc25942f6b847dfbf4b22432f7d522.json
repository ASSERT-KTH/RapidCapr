{
    "patch": "The following function includes a fix for the bug:\n\n```\npublic Fraction parse(String source, ParsePosition pos) {\n    // try to parse improper fraction\n    Fraction ret = super.parse(source, pos);\n    if (ret != null) {\n        return ret;\n    }\n\n    int initialIndex = pos.getIndex();\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse whole\n    Number whole = getWholeFormat().parse(source, pos);\n    if (whole == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse numerator\n    Number num = getNumeratorFormat().parse(source, pos);\n    if (num == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // check if numerator is negative\n    int sign = 1;\n    if (num.intValue() < 0) {\n        sign = -1;\n        num = new Integer(-num.intValue());\n    }\n\n    // parse '/'\n    int startIndex = pos.getIndex();\n    char c = parseNextCharacter(source, pos);\n    switch (c) {\n    case 0:\n        // no '/'\n        // return num as a fraction\n        return new Fraction(sign * num.intValue(), 1);\n    case '/':\n        // found '/', continue parsing denominator\n        break;\n    default:\n        // invalid '/'\n        // set index back to initial, error index should be the last\n        // character examined.\n        pos.setIndex(initialIndex);\n        pos.setErrorIndex(startIndex);\n        return null;\n    }\n\n    // parse whitespace\n    parseAndIgnoreWhitespace(source, pos);\n\n    // parse denominator\n    Number den = getDenominatorFormat().parse(source, pos);\n    if (den == null) {\n        // invalid integer number\n        // set index back to initial, error index should already be set\n        // character examined.\n        pos.setIndex(initialIndex);\n        return null;\n    }\n\n    // check if denominator is negative\n    if (den.intValue() < 0) {\n        sign *= -1;\n        den = new Integer(-den.intValue());\n    }\n\n    int w = whole.intValue();\n    int n = num.intValue();\n    int d = den.intValue();\n    return new Fraction((Math.abs(w) * d + n) * sign, d);\n}\n```\n\nThe new code fixes the bug by checking if the numerator or denominator is negative and adjusting the sign accordingly. It also removes the test for invalid minus signs, since that is now handled by the sign check.",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\nindex df2713da8..eb8506ad3 100644\n--- a/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n+++ b/src/java/org/apache/commons/math/fraction/ProperFractionFormat.java\n@@ -127,83 +127,98 @@ public class ProperFractionFormat extends FractionFormat {\n      * @param pos input/ouput parsing parameter.\n      * @return the parsed {@link Fraction} object.\n      */\n-    public Fraction parse(String source, ParsePosition pos) {\n-        // try to parse improper fraction\n-        Fraction ret = super.parse(source, pos);\n-        if (ret != null) {\n-            return ret;\n-        }\n-        \n-        int initialIndex = pos.getIndex();\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse whole\n-        Number whole = getWholeFormat().parse(source, pos);\n-        if (whole == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-        \n-        // parse numerator\n-        Number num = getNumeratorFormat().parse(source, pos);\n-        if (num == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-        \n-            // minus signs should be leading, invalid expression\n-\n-        // parse '/'\n-        int startIndex = pos.getIndex();\n-        char c = parseNextCharacter(source, pos);\n-        switch (c) {\n-        case 0 :\n-            // no '/'\n-            // return num as a fraction\n-            return new Fraction(num.intValue(), 1);\n-        case '/' :\n-            // found '/', continue parsing denominator\n-            break;\n-        default :\n-            // invalid '/'\n-            // set index back to initial, error index should be the last\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            pos.setErrorIndex(startIndex);\n-            return null;\n-        }\n-\n-        // parse whitespace\n-        parseAndIgnoreWhitespace(source, pos);\n-\n-        // parse denominator\n-        Number den = getDenominatorFormat().parse(source, pos);\n-        if (den == null) {\n-            // invalid integer number\n-            // set index back to initial, error index should already be set\n-            // character examined.\n-            pos.setIndex(initialIndex);\n-            return null;\n-        }\n-        \n-            // minus signs must be leading, invalid\n-\n-        int w = whole.intValue();\n-        int n = num.intValue();\n-        int d = den.intValue();\n-        return new Fraction(((Math.abs(w) * d) + n) * MathUtils.sign(w), d);\n-    }\n+The following function includes a fix for the bug:\n+\n+```\n+public Fraction parse(String source, ParsePosition pos) {\n+    // try to parse improper fraction\n+    Fraction ret = super.parse(source, pos);\n+    if (ret != null) {\n+        return ret;\n+    }\n+\n+    int initialIndex = pos.getIndex();\n+\n+    // parse whitespace\n+    parseAndIgnoreWhitespace(source, pos);\n+\n+    // parse whole\n+    Number whole = getWholeFormat().parse(source, pos);\n+    if (whole == null) {\n+        // invalid integer number\n+        // set index back to initial, error index should already be set\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        return null;\n+    }\n+\n+    // parse whitespace\n+    parseAndIgnoreWhitespace(source, pos);\n+\n+    // parse numerator\n+    Number num = getNumeratorFormat().parse(source, pos);\n+    if (num == null) {\n+        // invalid integer number\n+        // set index back to initial, error index should already be set\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        return null;\n+    }\n+\n+    // check if numerator is negative\n+    int sign = 1;\n+    if (num.intValue() < 0) {\n+        sign = -1;\n+        num = new Integer(-num.intValue());\n+    }\n+\n+    // parse '/'\n+    int startIndex = pos.getIndex();\n+    char c = parseNextCharacter(source, pos);\n+    switch (c) {\n+    case 0:\n+        // no '/'\n+        // return num as a fraction\n+        return new Fraction(sign * num.intValue(), 1);\n+    case '/':\n+        // found '/', continue parsing denominator\n+        break;\n+    default:\n+        // invalid '/'\n+        // set index back to initial, error index should be the last\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        pos.setErrorIndex(startIndex);\n+        return null;\n+    }\n+\n+    // parse whitespace\n+    parseAndIgnoreWhitespace(source, pos);\n+\n+    // parse denominator\n+    Number den = getDenominatorFormat().parse(source, pos);\n+    if (den == null) {\n+        // invalid integer number\n+        // set index back to initial, error index should already be set\n+        // character examined.\n+        pos.setIndex(initialIndex);\n+        return null;\n+    }\n+\n+    // check if denominator is negative\n+    if (den.intValue() < 0) {\n+        sign *= -1;\n+        den = new Integer(-den.intValue());\n+    }\n+\n+    int w = whole.intValue();\n+    int n = num.intValue();\n+    int d = den.intValue();\n+    return new Fraction((Math.abs(w) * d + n) * sign, d);\n+}\n+```\n+\n+The new code fixes the bug by checking if the numerator or denominator is negative and adjusting the sign accordingly. It also removes the test for invalid minus signs, since that is now handled by the sign check.\n     \n     /**\n      * Modify the whole format.",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}