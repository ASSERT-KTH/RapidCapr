{
    "patch": "    case REGULA_FALSI:\n        // Detect early that algorithm is stuck, instead of waiting\n        // for the maximum number of iterations to be exceeded.\n\n        // If the current interval width is smaller than the absolute accuracy,\n        // we're as close to the root as we can be with this algorithm\n        final double currentInterval = FastMath.abs(x1 - x0);\n        if (currentInterval < atol) {\n            return x1;\n        }\n\n        final boolean closeToLeft = FastMath.abs(f0) < FastMath.abs(f1);\n        // If all further approximation are due to small interval width\n        if (FastMath.abs(f0 - f1) < ftol) {\n            if (currentInterval < rtol * (closeToLeft ? x0 : x1)) {\n                // Current interval is small and close to zero, return the best\n                // root found so far\n                return closeToLeft ? x0 : x1;\n            }\n            // Too many steps without sufficient convergence, failure\n            throw new ConvergenceException(LocalizedFormats.CONVERGENCE_FAILED,\n                    getMaximalIterationCount());\n        }\n\n        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n        final double fx = computeObjectiveValue(x);\n        if (fx == 0.0) {\n            return x;\n        }\n\n        if (fx * f1 < 0.0) {\n            x0 = x1;\n            f0 = f1;\n        }\n        f1 = fx;\n        x1 = x;\n\n        break;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex 8a667dad3..e882110a7 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -186,6 +186,44 @@ public abstract class BaseSecantSolver\n                 case REGULA_FALSI:\n                     // Detect early that algorithm is stuck, instead of waiting\n                     // for the maximum number of iterations to be exceeded.\n+    case REGULA_FALSI:\n+        // Detect early that algorithm is stuck, instead of waiting\n+        // for the maximum number of iterations to be exceeded.\n+\n+        // If the current interval width is smaller than the absolute accuracy,\n+        // we're as close to the root as we can be with this algorithm\n+        final double currentInterval = FastMath.abs(x1 - x0);\n+        if (currentInterval < atol) {\n+            return x1;\n+        }\n+\n+        final boolean closeToLeft = FastMath.abs(f0) < FastMath.abs(f1);\n+        // If all further approximation are due to small interval width\n+        if (FastMath.abs(f0 - f1) < ftol) {\n+            if (currentInterval < rtol * (closeToLeft ? x0 : x1)) {\n+                // Current interval is small and close to zero, return the best\n+                // root found so far\n+                return closeToLeft ? x0 : x1;\n+            }\n+            // Too many steps without sufficient convergence, failure\n+            throw new ConvergenceException(LocalizedFormats.CONVERGENCE_FAILED,\n+                    getMaximalIterationCount());\n+        }\n+\n+        final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n+        final double fx = computeObjectiveValue(x);\n+        if (fx == 0.0) {\n+            return x;\n+        }\n+\n+        if (fx * f1 < 0.0) {\n+            x0 = x1;\n+            f0 = f1;\n+        }\n+        f1 = fx;\n+        x1 = x;\n+\n+        break;\n                     break;\n                 default:\n                     // Should never happen.",
    "result_reason": "error: duplicate case label",
    "test_result": "ERROR"
}