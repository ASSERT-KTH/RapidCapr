{
    "patch": "void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n  Preconditions.checkArgument(inferred || type != null);\n  \n  // Only allow declarations of NAMEs and qualfied names.\n  boolean shouldDeclareOnGlobalThis = false;\n  if (n.getType() == Token.NAME) {\n    Preconditions.checkArgument(\n      parent.getType() == Token.FUNCTION ||\n      parent.getType() == Token.VAR ||\n      parent.getType() == Token.LP ||\n      parent.getType() == Token.CATCH);\n    shouldDeclareOnGlobalThis =\n        scope.isGlobal()\n        && (parent.getType() == Token.VAR\n            || parent.getType() == Token.FUNCTION);\n  } else {\n    Preconditions.checkArgument(\n        n.getType() == Token.GETPROP\n        && (parent.getType() == Token.ASSIGN\n            || parent.getType() == Token.EXPR_RESULT));\n  }\n  String variableName = n.getQualifiedName();\n  Preconditions.checkArgument(!variableName.isEmpty());\n  \n  // If n is a property, then we should really declare it in the\n  // scope where the root object appears. This helps out people\n  // who declare \"global\" names in an anonymous namespace.\n  Scope scopeToDeclareIn = scope;\n\n  if (n.getType() == Token.NAME) {\n    if (inferred && scopeToDeclareIn.isDeclared(variableName, false)) {\n      // If this variable has already been declared as something other\n      // than a variable, and the current declaration is inferred,\n      // then the current declaration is invalid.\n      Var oldVar = scopeToDeclareIn.getVar(variableName);\n      Node oldNode = oldVar.getNameNode();\n      String oldType = UNICODE_ARROW;\n      if (oldNode.getParent().getType() == Token.FUNCTION) {\n        FunctionType oldFnType = checkNotNull(\n            oldVar.getType().toMaybeFunctionType());\n        oldType = oldFnType.toString();\n      }\n      validator.expectTypeMismatch(\n          sourceName,\n          n,\n          oldNode,\n          variableName,\n          oldType,\n          type.toString());\n      type = typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n    }\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n      // If the variable has already been declared with var, let, or\n      // const, then check whether the current variable declaration\n      // modifies the type of the variable.\n      // Otherwise, just declare the variable as usual.\n      Var oldVar = scopeToDeclareIn.getVar(variableName);\n      if (!inferred && oldVar.getNode() != null) {\n        JSType oldType = getTypeIfRefined(oldVar);\n        validator.expectTypeMismatch(\n            sourceName,\n            n,\n            oldVar.getNameNode(),\n            variableName,\n            oldType.toString(),\n            type.toString());\n      }\n    } else {\n      if (!inferred) {\n        setDeferredType(n, type);\n      }\n      CompilerInput input = compiler.getInput(sourceName);\n      scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n      if (shouldDeclareOnGlobalThis) {\n        ObjectType globalThis =\n            typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n        boolean isExtern = input.isExtern();\n        if (inferred) {\n          globalThis.defineInferredProperty(variableName,\n              type == null ?\n                  getNativeType(JSTypeNative.NO_TYPE) :\n                  type,\n              isExtern);\n        } else {\n          globalThis.defineDeclaredProperty(variableName, type, isExtern);\n        }\n      }\n      // If we're in the global scope, also declare var.prototype\n      // in the scope chain.\n      if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n        FunctionType fnType = (FunctionType) type;\n        if (fnType.isConstructor() || fnType.isInterface()) {\n          FunctionType superClassCtor = fnType.getSuperClassConstructor();\n          scopeToDeclareIn.declare(variableName + \".prototype\", n,\n              fnType.getPrototype(), compiler.getInput(sourceName),\n              /* declared iff there's an explicit supertype */\n              superClassCtor == null\n              || superClassCtor.getInstanceType().equals(\n                  getNativeType(OBJECT_TYPE)));\n        }\n      }\n    }\n  } else { // n.getType() == Token.GETPROP\n    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n      Var var = scopeToDeclareIn.getVar(variableName);\n      ObjectType objectType = ObjectType.cast(\n          getNativeType(JSTypeNative.OBJECT_TYPE));\n      ObjectType parentObjectType =\n          ObjectType.cast(getTypeIfRefined(var));\n      ObjectType objectTypeToDeclare =\n          ObjectType.join(objectType, parentObjectType);\n      ObjectTypeChecker objectTypeChecker =\n          new ObjectTypeChecker(typeRegistry, validator);\n      Node parentObject = n.getFirstChild();\n      if (!inferred\n          && objectTypeChecker.areObjectTypesEqual(\n              getTypeIfRefined(parent), objectTypeToDeclare)) {\n        objectTypeToDeclare =\n            parentObjectType.getGreatestSubtypeIfUnion();\n      }\n      setDeferredType(n, objectTypeToDeclare);\n      String propName = n.getLastChild().getString();\n      TypedVar newProp = null;\n      boolean isDeclared = scopeToDeclareIn.isDeclared(propName, false);\n      boolean isKnown = isDeclared || parent.getObjectType() == null;\n      Property prop = null;\n      if (isKnown) {\n        prop = objectTypeToDeclare.getProperty(propName);\n      }\n      boolean isConstVar = false;\n      if (prop != null && prop.getValueType() != null) {\n        if (isDeclared) {\n          if (parentObjectType.hasOwnProperty(propName)\n              && var.getParentNode() == scopeToDeclareIn.getRootNode()) {\n            isConstVar = true;\n          }\n          if (!var.getType().isSubtypeOf(prop.getValueType())) {\n            JSType typeBeforeCast = var.getType();\n            var.setType(prop.getValueType());\n            validator.expectTypeMismatch(\n                sourceName,\n                n,\n                var.getNameNode(),\n                propName,\n                typeBeforeCast.toString(),\n                prop.getValueType().toString());\n          }\n          newProp = scopeToDeclareIn.getVar(propName);\n        } else {\n          prop = null;\n        }\n      }\n      if (newProp == null) {\n        newProp = scopeToDeclareIn.declare(propName, n, null,\n            compiler.getInput(sourceName), inferred);\n      }\n      if (isDeclared) {\n        if (isConstVar) {\n          // Mark const vars so that subsequent assignments\n          // generate a warning.\n          newProp.setJSDocInfo(\n              JSDocInfo.builder().addSuppression(\"const\").build());\n        }\n        setDeferredType(newProp.getNameNode(), var.getType());\n      }\n      if (prop != null) {\n        // The object is a known type, so we don't need to update the\n        // actual type of the declared property.\n        var.setType(prop.getValueType());\n      } else {\n        // The object type must be updated to reflect this new property.\n        parentObjectType.defineDeclaredProperty(propName,\n            objectTypeToDeclare.getPropertyType(propName), false);\n      }\n    } else {\n      ObjectType objectType =\n          ObjectType.cast(getNativeType(JSTypeNative.OBJECT_TYPE));\n      ObjectType objectTypeToDeclare =\n          ObjectType.join(objectType, parent.getObjectType());\n      ObjectTypeChecker objectTypeChecker =\n          new ObjectTypeChecker(typeRegistry, validator);\n      Node parentObject = n.getFirstChild();\n      setDeferredType(n, objectTypeToDeclare);\n      String propName = n.getLastChild().getString();\n      if (!inferred) {\n        TypedVar newProp = scopeToDeclareIn.declare(\n            propName, n, null, compiler.getInput(sourceName), inferred);\n        if (parent.getObjectType() != null) {\n          Property property = parent.getObjectType().getProperty(propName);\n          if (property != null) {\n            // The parent object has a known type, so we don't need\n            // to update the actual type of the declared property.\n            newProp.setType(property.getValueType());\n          } else if (objectTypeChecker.mayHaveProp(\n              parentObject, propName, objectType)) {\n            // The property may exist on the object, so we declare it\n            // as UNKNOWN and let type inference refine the type.\n            newProp.setType(typeRegistry.getNativeType(\n                JSTypeNative.UNKNOWN_TYPE));\n          }\n          // If the parent object's type is unknown, we just declare\n          // the property as UNKNOWN.\n        } else {\n          newProp.setType(typeRegistry.getNativeType(\n              JSTypeNative.UNKNOWN_TYPE));\n        }\n      }\n      if (parentObject.getParent().getType() != Token.NEW) {\n        // We don't check prototype assignments to constructors.\n        // Prototype assignments typically occur inside the constructor.\n        // We don't declare properties in the prototype object, but\n        // rather in the constructor's \"types\" object.\n        ObjectType intersectionType = null;\n        Node n0 = parent.getObjectType().getConstructor();\n        FunctionType fnt = n0 == null ? null : n0.getType().toMaybeFunctionType();\n        FunctionType superCtorFnType = null;\n        if (fnt != null) {\n          superCtorFnType = fnt.getSuperClassConstructor();\n          if (superCtorFnType != null) {\n            ObjectType superCtorInstance =\n                superCtorFnType.getInstanceType();\n            intersectionType =\n                ObjectType.join(superCtorInstance, objectTypeToDeclare);\n          }\n        }\n\n        if (intersectionType == null) {\n          intersectionType = objectTypeToDeclare;\n        }\n      }\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4bd6bfb4..04a75bc4 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -869,80 +869,239 @@ final class TypedScopeCreator implements ScopeCreator {\n      * @param type the variable's type. It may be {@code null} if\n      *     {@code inferred} is {@code true}.\n      */\n-    void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n-      Preconditions.checkArgument(inferred || type != null);\n-\n-      // Only allow declarations of NAMEs and qualfied names.\n-      boolean shouldDeclareOnGlobalThis = false;\n-      if (n.getType() == Token.NAME) {\n-        Preconditions.checkArgument(\n-            parent.getType() == Token.FUNCTION ||\n-            parent.getType() == Token.VAR ||\n-            parent.getType() == Token.LP ||\n-            parent.getType() == Token.CATCH);\n-        shouldDeclareOnGlobalThis = scope.isGlobal() &&\n-            (parent.getType() == Token.VAR ||\n-             parent.getType() == Token.FUNCTION);\n-      } else {\n-        Preconditions.checkArgument(\n-            n.getType() == Token.GETPROP &&\n-            (parent.getType() == Token.ASSIGN ||\n-             parent.getType() == Token.EXPR_RESULT));\n+void defineSlot(Node n, Node parent, JSType type, boolean inferred) {\n+  Preconditions.checkArgument(inferred || type != null);\n+  \n+  // Only allow declarations of NAMEs and qualfied names.\n+  boolean shouldDeclareOnGlobalThis = false;\n+  if (n.getType() == Token.NAME) {\n+    Preconditions.checkArgument(\n+      parent.getType() == Token.FUNCTION ||\n+      parent.getType() == Token.VAR ||\n+      parent.getType() == Token.LP ||\n+      parent.getType() == Token.CATCH);\n+    shouldDeclareOnGlobalThis =\n+        scope.isGlobal()\n+        && (parent.getType() == Token.VAR\n+            || parent.getType() == Token.FUNCTION);\n+  } else {\n+    Preconditions.checkArgument(\n+        n.getType() == Token.GETPROP\n+        && (parent.getType() == Token.ASSIGN\n+            || parent.getType() == Token.EXPR_RESULT));\n+  }\n+  String variableName = n.getQualifiedName();\n+  Preconditions.checkArgument(!variableName.isEmpty());\n+  \n+  // If n is a property, then we should really declare it in the\n+  // scope where the root object appears. This helps out people\n+  // who declare \"global\" names in an anonymous namespace.\n+  Scope scopeToDeclareIn = scope;\n+\n+  if (n.getType() == Token.NAME) {\n+    if (inferred && scopeToDeclareIn.isDeclared(variableName, false)) {\n+      // If this variable has already been declared as something other\n+      // than a variable, and the current declaration is inferred,\n+      // then the current declaration is invalid.\n+      Var oldVar = scopeToDeclareIn.getVar(variableName);\n+      Node oldNode = oldVar.getNameNode();\n+      String oldType = UNICODE_ARROW;\n+      if (oldNode.getParent().getType() == Token.FUNCTION) {\n+        FunctionType oldFnType = checkNotNull(\n+            oldVar.getType().toMaybeFunctionType());\n+        oldType = oldFnType.toString();\n+      }\n+      validator.expectTypeMismatch(\n+          sourceName,\n+          n,\n+          oldNode,\n+          variableName,\n+          oldType,\n+          type.toString());\n+      type = typeRegistry.getNativeType(JSTypeNative.UNKNOWN_TYPE);\n+    }\n+    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n+      // If the variable has already been declared with var, let, or\n+      // const, then check whether the current variable declaration\n+      // modifies the type of the variable.\n+      // Otherwise, just declare the variable as usual.\n+      Var oldVar = scopeToDeclareIn.getVar(variableName);\n+      if (!inferred && oldVar.getNode() != null) {\n+        JSType oldType = getTypeIfRefined(oldVar);\n+        validator.expectTypeMismatch(\n+            sourceName,\n+            n,\n+            oldVar.getNameNode(),\n+            variableName,\n+            oldType.toString(),\n+            type.toString());\n+      }\n+    } else {\n+      if (!inferred) {\n+        setDeferredType(n, type);\n+      }\n+      CompilerInput input = compiler.getInput(sourceName);\n+      scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n+      if (shouldDeclareOnGlobalThis) {\n+        ObjectType globalThis =\n+            typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n+        boolean isExtern = input.isExtern();\n+        if (inferred) {\n+          globalThis.defineInferredProperty(variableName,\n+              type == null ?\n+                  getNativeType(JSTypeNative.NO_TYPE) :\n+                  type,\n+              isExtern);\n+        } else {\n+          globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+        }\n       }\n-      String variableName = n.getQualifiedName();\n-      Preconditions.checkArgument(!variableName.isEmpty());\n-\n-      // If n is a property, then we should really declare it in the\n-      // scope where the root object appears. This helps out people\n-      // who declare \"global\" names in an anonymous namespace.\n-      Scope scopeToDeclareIn = scope;\n-\n-        // don't try to declare in the global scope if there's\n-        // already a symbol there with this name.\n-\n-      // declared in closest scope?\n-      if (scopeToDeclareIn.isDeclared(variableName, false)) {\n-        Var oldVar = scopeToDeclareIn.getVar(variableName);\n-        validator.expectUndeclaredVariable(\n-            sourceName, n, parent, oldVar, variableName, type);\n+      // If we're in the global scope, also declare var.prototype\n+      // in the scope chain.\n+      if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n+        FunctionType fnType = (FunctionType) type;\n+        if (fnType.isConstructor() || fnType.isInterface()) {\n+          FunctionType superClassCtor = fnType.getSuperClassConstructor();\n+          scopeToDeclareIn.declare(variableName + \".prototype\", n,\n+              fnType.getPrototype(), compiler.getInput(sourceName),\n+              /* declared iff there's an explicit supertype */\n+              superClassCtor == null\n+              || superClassCtor.getInstanceType().equals(\n+                  getNativeType(OBJECT_TYPE)));\n+        }\n+      }\n+    }\n+  } else { // n.getType() == Token.GETPROP\n+    if (scopeToDeclareIn.isDeclared(variableName, false)) {\n+      Var var = scopeToDeclareIn.getVar(variableName);\n+      ObjectType objectType = ObjectType.cast(\n+          getNativeType(JSTypeNative.OBJECT_TYPE));\n+      ObjectType parentObjectType =\n+          ObjectType.cast(getTypeIfRefined(var));\n+      ObjectType objectTypeToDeclare =\n+          ObjectType.join(objectType, parentObjectType);\n+      ObjectTypeChecker objectTypeChecker =\n+          new ObjectTypeChecker(typeRegistry, validator);\n+      Node parentObject = n.getFirstChild();\n+      if (!inferred\n+          && objectTypeChecker.areObjectTypesEqual(\n+              getTypeIfRefined(parent), objectTypeToDeclare)) {\n+        objectTypeToDeclare =\n+            parentObjectType.getGreatestSubtypeIfUnion();\n+      }\n+      setDeferredType(n, objectTypeToDeclare);\n+      String propName = n.getLastChild().getString();\n+      TypedVar newProp = null;\n+      boolean isDeclared = scopeToDeclareIn.isDeclared(propName, false);\n+      boolean isKnown = isDeclared || parent.getObjectType() == null;\n+      Property prop = null;\n+      if (isKnown) {\n+        prop = objectTypeToDeclare.getProperty(propName);\n+      }\n+      boolean isConstVar = false;\n+      if (prop != null && prop.getValueType() != null) {\n+        if (isDeclared) {\n+          if (parentObjectType.hasOwnProperty(propName)\n+              && var.getParentNode() == scopeToDeclareIn.getRootNode()) {\n+            isConstVar = true;\n+          }\n+          if (!var.getType().isSubtypeOf(prop.getValueType())) {\n+            JSType typeBeforeCast = var.getType();\n+            var.setType(prop.getValueType());\n+            validator.expectTypeMismatch(\n+                sourceName,\n+                n,\n+                var.getNameNode(),\n+                propName,\n+                typeBeforeCast.toString(),\n+                prop.getValueType().toString());\n+          }\n+          newProp = scopeToDeclareIn.getVar(propName);\n+        } else {\n+          prop = null;\n+        }\n+      }\n+      if (newProp == null) {\n+        newProp = scopeToDeclareIn.declare(propName, n, null,\n+            compiler.getInput(sourceName), inferred);\n+      }\n+      if (isDeclared) {\n+        if (isConstVar) {\n+          // Mark const vars so that subsequent assignments\n+          // generate a warning.\n+          newProp.setJSDocInfo(\n+              JSDocInfo.builder().addSuppression(\"const\").build());\n+        }\n+        setDeferredType(newProp.getNameNode(), var.getType());\n+      }\n+      if (prop != null) {\n+        // The object is a known type, so we don't need to update the\n+        // actual type of the declared property.\n+        var.setType(prop.getValueType());\n       } else {\n-        if (!inferred) {\n-          setDeferredType(n, type);\n+        // The object type must be updated to reflect this new property.\n+        parentObjectType.defineDeclaredProperty(propName,\n+            objectTypeToDeclare.getPropertyType(propName), false);\n+      }\n+    } else {\n+      ObjectType objectType =\n+          ObjectType.cast(getNativeType(JSTypeNative.OBJECT_TYPE));\n+      ObjectType objectTypeToDeclare =\n+          ObjectType.join(objectType, parent.getObjectType());\n+      ObjectTypeChecker objectTypeChecker =\n+          new ObjectTypeChecker(typeRegistry, validator);\n+      Node parentObject = n.getFirstChild();\n+      setDeferredType(n, objectTypeToDeclare);\n+      String propName = n.getLastChild().getString();\n+      if (!inferred) {\n+        TypedVar newProp = scopeToDeclareIn.declare(\n+            propName, n, null, compiler.getInput(sourceName), inferred);\n+        if (parent.getObjectType() != null) {\n+          Property property = parent.getObjectType().getProperty(propName);\n+          if (property != null) {\n+            // The parent object has a known type, so we don't need\n+            // to update the actual type of the declared property.\n+            newProp.setType(property.getValueType());\n+          } else if (objectTypeChecker.mayHaveProp(\n+              parentObject, propName, objectType)) {\n+            // The property may exist on the object, so we declare it\n+            // as UNKNOWN and let type inference refine the type.\n+            newProp.setType(typeRegistry.getNativeType(\n+                JSTypeNative.UNKNOWN_TYPE));\n+          }\n+          // If the parent object's type is unknown, we just declare\n+          // the property as UNKNOWN.\n+        } else {\n+          newProp.setType(typeRegistry.getNativeType(\n+              JSTypeNative.UNKNOWN_TYPE));\n         }\n-        CompilerInput input = compiler.getInput(sourceName);\n-        scopeToDeclareIn.declare(variableName, n, type, input, inferred);\n-\n-        if (shouldDeclareOnGlobalThis) {\n-          ObjectType globalThis =\n-              typeRegistry.getNativeObjectType(JSTypeNative.GLOBAL_THIS);\n-          boolean isExtern = input.isExtern();\n-          if (inferred) {\n-            globalThis.defineInferredProperty(variableName,\n-                type == null ?\n-                    getNativeType(JSTypeNative.NO_TYPE) :\n-                    type,\n-                isExtern);\n-          } else {\n-            globalThis.defineDeclaredProperty(variableName, type, isExtern);\n+      }\n+      if (parentObject.getParent().getType() != Token.NEW) {\n+        // We don't check prototype assignments to constructors.\n+        // Prototype assignments typically occur inside the constructor.\n+        // We don't declare properties in the prototype object, but\n+        // rather in the constructor's \"types\" object.\n+        ObjectType intersectionType = null;\n+        Node n0 = parent.getObjectType().getConstructor();\n+        FunctionType fnt = n0 == null ? null : n0.getType().toMaybeFunctionType();\n+        FunctionType superCtorFnType = null;\n+        if (fnt != null) {\n+          superCtorFnType = fnt.getSuperClassConstructor();\n+          if (superCtorFnType != null) {\n+            ObjectType superCtorInstance =\n+                superCtorFnType.getInstanceType();\n+            intersectionType =\n+                ObjectType.join(superCtorInstance, objectTypeToDeclare);\n           }\n         }\n \n-        // If we're in the global scope, also declare var.prototype\n-        // in the scope chain.\n-        if (scopeToDeclareIn.isGlobal() && type instanceof FunctionType) {\n-          FunctionType fnType = (FunctionType) type;\n-          if (fnType.isConstructor() || fnType.isInterface()) {\n-            FunctionType superClassCtor = fnType.getSuperClassConstructor();\n-            scopeToDeclareIn.declare(variableName + \".prototype\", n,\n-                fnType.getPrototype(), compiler.getInput(sourceName),\n-                /* declared iff there's an explicit supertype */\n-                superClassCtor == null ||\n-                superClassCtor.getInstanceType().equals(\n-                    getNativeType(OBJECT_TYPE)));\n-          }\n+        if (intersectionType == null) {\n+          intersectionType = objectTypeToDeclare;\n         }\n       }\n     }\n+  }\n+}\n \n     /**\n      * Check if the given node is a property of a name in the global scope.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}