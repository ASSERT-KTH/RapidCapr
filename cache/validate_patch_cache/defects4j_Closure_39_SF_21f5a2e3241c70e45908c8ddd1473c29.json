{
    "patch": "    return !isRegexpType();\n  }\n\n  /**\n   * Solves the infinite recursion problem when dealing with recursive object types.\n   * If the object is a recursive type, we print \"{...}\" instead of going into infinite recursion.\n   * If the object is a non-recursive complex type, we print \"[...]\" before going into recursive fields.\n   * @param object the object to print\n   * @param visited objects that have already been visited while printing the current object\n   * @return the string representation of the object\n   */\n  private static String handleRecursiveTypes(Object object, Set<Object> visited) {\n    if (object instanceof ObjectType) {\n      ObjectType objectType = (ObjectType) object;\n      if (visited.contains(object)) {\n        // Object has already been seen; print \"{...}\"\n        return \"{...}\";\n      } else if (objectType.equals(objectType.getImplicitPrototype())) {\n        // Object is a recursive type; print \"{...}\"\n        return \"{...}\";\n      } else {\n        // Object is not a recursive type; add it to the visited set and print it\n        visited.add(object);\n        String result = objectType.toStringHelper(false, visited);\n        visited.remove(object);\n        return result;\n      }\n    } else if (object instanceof Object[]) {\n      Object[] array = (Object[]) object;\n      if (visited.contains(object)) {\n        // Array has already been seen; print \"{...}\"\n        return \"{...}\";\n      } else {\n        // Array has not been seen; add it to the visited set and print it\n        visited.add(object);\n        StringBuilder sb = new StringBuilder();\n        sb.append(\"[\");\n        for (int i = 0; i < array.length; i++) {\n          if (i > 0) {\n            sb.append(\", \");\n          }\n          sb.append(handleRecursiveTypes(array[i], visited));\n        }\n        sb.append(\"]\");\n        visited.remove(object);\n        return sb.toString();\n      }\n    } else {\n      // Simple types are printed as is\n      return object.toString();\n    }\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations, Set<Object> visited) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        if (i > 0) {\n          sb.append(\", \");\n        }\n\n        sb.append(property);\n        sb.append(\": \");\n\n        Object propertyType = getPropertyType(property);\n        if (propertyType instanceof ObjectType || propertyType instanceof Object[]) {\n          if (visited.contains(propertyType)) {\n            // Property has already been seen; print \"{...}\"\n            sb.append(\"{...}\");\n          } else {\n            // Property has not been seen; add it to the visited set and print it\n            visited.add(propertyType);\n            if (propertyType instanceof ObjectType) {\n              ObjectType objectType = (ObjectType) propertyType;\n              if (objectType.equals(this)) {\n                // Print \"{...}\" if the object is recursively defined\n                sb.append(\"{...}\");\n              } else {\n                // Print the object enclosed in \"[...]\"\n                sb.append(\"[\");\n                sb.append(handleRecursiveTypes(objectType, visited));\n                sb.append(\"]\");\n              }\n            } else {\n              // Property type is an array; print the elements enclosed in \"[...]\"\n              sb.append(\"[\");\n              Object[] array = (Object[]) propertyType;\n              for (int j = 0; j < array.length; j++) {\n                if (j > 0) {\n                  sb.append(\", \");\n                }\n                sb.append(handleRecursiveTypes(array[j], visited));\n              }\n              sb.append(\"]\");\n            }\n            visited.remove(propertyType);\n          }\n        } else {\n          // Property type is a simple type; print it as is\n          sb.append(propertyType.toString());\n        }\n\n        ++i;\n        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex dffe3a54..0f99cd08 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -345,12 +345,61 @@ class PrototypeObjectType extends ObjectType {\n   }\n \n   @Override\n-  public boolean canBeCalled() {\n-    return isRegexpType();\n+    return !isRegexpType();\n+  }\n+\n+  /**\n+   * Solves the infinite recursion problem when dealing with recursive object types.\n+   * If the object is a recursive type, we print \"{...}\" instead of going into infinite recursion.\n+   * If the object is a non-recursive complex type, we print \"[...]\" before going into recursive fields.\n+   * @param object the object to print\n+   * @param visited objects that have already been visited while printing the current object\n+   * @return the string representation of the object\n+   */\n+  private static String handleRecursiveTypes(Object object, Set<Object> visited) {\n+    if (object instanceof ObjectType) {\n+      ObjectType objectType = (ObjectType) object;\n+      if (visited.contains(object)) {\n+        // Object has already been seen; print \"{...}\"\n+        return \"{...}\";\n+      } else if (objectType.equals(objectType.getImplicitPrototype())) {\n+        // Object is a recursive type; print \"{...}\"\n+        return \"{...}\";\n+      } else {\n+        // Object is not a recursive type; add it to the visited set and print it\n+        visited.add(object);\n+        String result = objectType.toStringHelper(false, visited);\n+        visited.remove(object);\n+        return result;\n+      }\n+    } else if (object instanceof Object[]) {\n+      Object[] array = (Object[]) object;\n+      if (visited.contains(object)) {\n+        // Array has already been seen; print \"{...}\"\n+        return \"{...}\";\n+      } else {\n+        // Array has not been seen; add it to the visited set and print it\n+        visited.add(object);\n+        StringBuilder sb = new StringBuilder();\n+        sb.append(\"[\");\n+        for (int i = 0; i < array.length; i++) {\n+          if (i > 0) {\n+            sb.append(\", \");\n+          }\n+          sb.append(handleRecursiveTypes(array[i], visited));\n+        }\n+        sb.append(\"]\");\n+        visited.remove(object);\n+        return sb.toString();\n+      }\n+    } else {\n+      // Simple types are printed as is\n+      return object.toString();\n+    }\n   }\n \n   @Override\n-  String toStringHelper(boolean forAnnotations) {\n+  String toStringHelper(boolean forAnnotations, Set<Object> visited) {\n     if (hasReferenceName()) {\n       return getReferenceName();\n     } else if (prettyPrint) {\n@@ -377,23 +426,47 @@ class PrototypeObjectType extends ObjectType {\n \n         sb.append(property);\n         sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n \n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n-          sb.append(\", ...\");\n-          break;\n+        Object propertyType = getPropertyType(property);\n+        if (propertyType instanceof ObjectType || propertyType instanceof Object[]) {\n+          if (visited.contains(propertyType)) {\n+            // Property has already been seen; print \"{...}\"\n+            sb.append(\"{...}\");\n+          } else {\n+            // Property has not been seen; add it to the visited set and print it\n+            visited.add(propertyType);\n+            if (propertyType instanceof ObjectType) {\n+              ObjectType objectType = (ObjectType) propertyType;\n+              if (objectType.equals(this)) {\n+                // Print \"{...}\" if the object is recursively defined\n+                sb.append(\"{...}\");\n+              } else {\n+                // Print the object enclosed in \"[...]\"\n+                sb.append(\"[\");\n+                sb.append(handleRecursiveTypes(objectType, visited));\n+                sb.append(\"]\");\n+              }\n+            } else {\n+              // Property type is an array; print the elements enclosed in \"[...]\"\n+              sb.append(\"[\");\n+              Object[] array = (Object[]) propertyType;\n+              for (int j = 0; j < array.length; j++) {\n+                if (j > 0) {\n+                  sb.append(\", \");\n+                }\n+                sb.append(handleRecursiveTypes(array[j], visited));\n+              }\n+              sb.append(\"]\");\n+            }\n+            visited.remove(propertyType);\n+          }\n+        } else {\n+          // Property type is a simple type; print it as is\n+          sb.append(propertyType.toString());\n         }\n-      }\n \n-      sb.append(\"}\");\n-\n-      prettyPrint = true;\n-      return sb.toString();\n-    } else {\n-      return \"{...}\";\n-    }\n-  }\n+        ++i;\n+        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n \n   void setPrettyPrint(boolean prettyPrint) {\n     this.prettyPrint = prettyPrint;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}