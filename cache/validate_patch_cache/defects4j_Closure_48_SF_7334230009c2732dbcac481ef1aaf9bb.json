{
    "patch": "    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n        Node ownerNode = n.getFirstChild();\n        String ownerName = null;\n        if (ownerNode.isGetProp()) {\n          if (n.isQualifiedName()) {\n            ownerName = n.getQualifiedName();\n          } else {\n            // In the rare case this fires (technically a user error), fall back\n            // to the owner node. Do not fall back to the node itself.\n            ownerName = ownerNode.getQualifiedName();\n          }\n        } else if (ownerNode.isName()) {\n          ownerName = ownerNode.getString();\n          JSType jsType = JSType.toMaybeObjectType(getDeclaredType(t.getSourceName(), info, ownerNode, ownerNode.getFirstChild()));\n          if (jsType != null) {\n            defineSlot(ownerNode, ownerNode.getParent(), jsType.getPrototype(), true);\n          }\n        } else {\n          return;\n        }\n\n        String propName = n.getLastChild().getString();\n        Preconditions.checkArgument(ownerName != null);\n\n        // If we're looking at an object literal key that's being type checked via\n        // a call to a constructor function, ignore the object literal key. We will\n        // look at the corresponding constructor property which will have the appropriate\n        // type information. This way we avoid needing type information on the object literal\n        // itself. Consider:\n        //\n        // /** @constructor */\n        // function A() {}\n        // /** @type {number} */\n        // A.prototype.foo;\n        // var x = new A;\n        // x.foo = 'asdf';  // Warns here, not on `A.prototype.foo`.\n        if (parent.isAssign() && n == parent.getFirstChild()) {\n          Node rhs = parent.getLastChild();\n          if (rhs != null && rhs.isNew()) {\n            info = rhs.getJSType().getJSDocInfo();\n            if (info != null && info.hasType()) {\n              return;\n            }\n          }\n        }\n\n        Node context = ownerNode;\n        ObjectType ownerType = null;\n        boolean inferred = false;\n        while (context != null && context.isGetProp()) {\n          String contextName = context.getQualifiedName();\n          ObjectType newType = getObjectSlot(contextName);\n          if (newType == null) {\n            newType = ObjectType.cast(getDeclaredType(t.getSourceName(), info, context, null));\n          }\n\n          if (newType == null) {\n            inferred = true;\n            break;\n          } else {\n            if (ownerName.equals(contextName)) {\n              ownerType = newType;\n            }\n            context = context.getFirstChild();\n          }\n        }\n\n        if (inferred) {\n          if (parent.isExprResult()) {\n            stubDeclarations.add(new StubDeclaration(\n                n,\n                t.getInput() != null && t.getInput().isExtern(),\n                ownerName));\n          }\n        } else {\n          if (ownerType == null) {\n            inferred = true;\n          } else {\n            Boolean privateOverride = codingConvention.isPropertyTypeDeclaredInOwnerPrototype(propName, ownerType.getDisplayName());\n            if (privateOverride == Boolean.FALSE) {\n              ObjectType proto = ownerType.getImplicitPrototype();\n              if (proto.isFunctionPrototypeType()) {\n                // Assume that any properties we add to the Function prototype object\n                // will be exposed as static properties on functions that use this prototype.\n                ownerType = FunctionTypeBuilder.functionPrototypeToOrdinaryObject(ownerType);\n              }\n            } else if (privateOverride == null) {\n              // The convention was not definitive. Ignore the override and treat the\n              // property as any other.\n              privateOverride = true;\n            }\n            if (ownerType.hasOwnProperty(propName)) {\n              if (privateOverride) {\n                t.report(n, PROPERTY_DECLARATION_IN_NON_GLOBAL_SCOPE, propName);\n              }\n            } else if (ownerType.isPropertyInherited(propName)) {\n              if (privateOverride) {\n                // If the property is inherited and private, it's still an error.\n                t.report(n, INHERITED_PROPERTY_IN_EXTERNS, propName);\n              }\n            } else {\n              ownerType.defineDeclaredProperty(propName, getDeclaredType(t.getSourceName(), info, n, rhsValue), n);\n            }\n            if (!privateOverride && (t.getInput() != null && t.getInput().isExtern() ^ ownerType.isNativeObjectType())) {\n              t.report(n, EXTERNS_VALIDATION_PROPERTIES);\n            }\n          }\n          defineSlot(n, parent, getDeclaredType(t.getSourceName(), info, n, rhsValue), inferred);\n        }\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 3fb48137..c31c0536 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1413,152 +1413,116 @@ final class TypedScopeCreator implements ScopeCreator {\n      * @param rhsValue The node that {@code n} is being initialized to,\n      *     or {@code null} if this is a stub declaration.\n      */\n-    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info,\n-        Node n, Node parent, Node rhsValue) {\n-      Node ownerNode = n.getFirstChild();\n-      String ownerName = ownerNode.getQualifiedName();\n-      String qName = n.getQualifiedName();\n-      String propName = n.getLastChild().getString();\n-      Preconditions.checkArgument(qName != null && ownerName != null);\n-\n-      // Precedence of type information on GETPROPs:\n-      // 1) @type annnotation / @enum annotation\n-      // 2) ASSIGN to FUNCTION literal\n-      // 3) @param/@return annotation (with no function literal)\n-      // 4) ASSIGN to something marked @const\n-      // 5) ASSIGN to anything else\n-      //\n-      // 1, 3, and 4 are declarations, 5 is inferred, and 2 is a declaration iff\n-      // the function has jsdoc or has not been declared before.\n-      //\n-      // FUNCTION literals are special because TypedScopeCreator is very smart\n-      // about getting as much type information as possible for them.\n-\n-      // Determining type for #1 + #2 + #3 + #4\n-      JSType valueType = getDeclaredType(t.getSourceName(), info, n, rhsValue);\n-      if (valueType == null && rhsValue != null) {\n-        // Determining type for #5\n-        valueType = rhsValue.getJSType();\n-      }\n-      // Function prototypes are special.\n-      // It's a common JS idiom to do:\n-      // F.prototype = { ... };\n-      // So if F does not have an explicitly declared super type,\n-      // allow F.prototype to be redefined arbitrarily.\n-      if (\"prototype\".equals(propName)) {\n-        Var qVar = scope.getVar(qName);\n-        if (qVar != null) {\n-          // If the programmer has declared that F inherits from Super,\n-          // and they assign F.prototype to an object literal,\n-          // then they are responsible for making sure that the object literal's\n-          // implicit prototype is set up appropriately. We just obey\n-          // the @extends tag.\n-          ObjectType qVarType = ObjectType.cast(qVar.getType());\n-          if (qVarType != null &&\n-              rhsValue != null &&\n-              rhsValue.isObjectLit()) {\n-            typeRegistry.resetImplicitPrototype(\n-                rhsValue.getJSType(), qVarType.getImplicitPrototype());\n-          } else if (!qVar.isTypeInferred()) {\n-            // If the programmer has declared that F inherits from Super,\n-            // and they assign F.prototype to some arbitrary expression,\n-            // there's not much we can do. We just ignore the expression,\n-            // and hope they've annotated their code in a way to tell us\n-            // what props are going to be on that prototype.\n-            return;\n+    void maybeDeclareQualifiedName(NodeTraversal t, JSDocInfo info, Node n, Node parent, Node rhsValue) {\n+        Node ownerNode = n.getFirstChild();\n+        String ownerName = null;\n+        if (ownerNode.isGetProp()) {\n+          if (n.isQualifiedName()) {\n+            ownerName = n.getQualifiedName();\n+          } else {\n+            // In the rare case this fires (technically a user error), fall back\n+            // to the owner node. Do not fall back to the node itself.\n+            ownerName = ownerNode.getQualifiedName();\n           }\n-          if (qVar.getScope() == scope) {\n-            scope.undeclare(qVar);\n+        } else if (ownerNode.isName()) {\n+          ownerName = ownerNode.getString();\n+          JSType jsType = JSType.toMaybeObjectType(getDeclaredType(t.getSourceName(), info, ownerNode, ownerNode.getFirstChild()));\n+          if (jsType != null) {\n+            defineSlot(ownerNode, ownerNode.getParent(), jsType.getPrototype(), true);\n           }\n+        } else {\n+          return;\n         }\n-      }\n \n-      if (valueType == null) {\n-        if (parent.isExprResult()) {\n-          stubDeclarations.add(new StubDeclaration(\n-              n,\n-              t.getInput() != null && t.getInput().isExtern(),\n-              ownerName));\n+        String propName = n.getLastChild().getString();\n+        Preconditions.checkArgument(ownerName != null);\n+\n+        // If we're looking at an object literal key that's being type checked via\n+        // a call to a constructor function, ignore the object literal key. We will\n+        // look at the corresponding constructor property which will have the appropriate\n+        // type information. This way we avoid needing type information on the object literal\n+        // itself. Consider:\n+        //\n+        // /** @constructor */\n+        // function A() {}\n+        // /** @type {number} */\n+        // A.prototype.foo;\n+        // var x = new A;\n+        // x.foo = 'asdf';  // Warns here, not on `A.prototype.foo`.\n+        if (parent.isAssign() && n == parent.getFirstChild()) {\n+          Node rhs = parent.getLastChild();\n+          if (rhs != null && rhs.isNew()) {\n+            info = rhs.getJSType().getJSDocInfo();\n+            if (info != null && info.hasType()) {\n+              return;\n+            }\n+          }\n         }\n \n-        return;\n-      }\n-\n-      // NOTE(nicksantos): Determining whether a property is declared or not\n-      // is really really obnoxious.\n-      //\n-      // The problem is that there are two (equally valid) coding styles:\n-      //\n-      // (function() {\n-      //   /* The authoritative definition of goog.bar. */\n-      //   goog.bar = function() {};\n-      // })();\n-      //\n-      // function f() {\n-      //   goog.bar();\n-      //   /* Reset goog.bar to a no-op. */\n-      //   goog.bar = function() {};\n-      // }\n-      //\n-      // In a dynamic language with first-class functions, it's very difficult\n-      // to know which one the user intended without looking at lots of\n-      // contextual information (the second example demonstrates a small case\n-      // of this, but there are some really pathological cases as well).\n-      //\n-      // The current algorithm checks if either the declaration has\n-      // jsdoc type information, or @const with a known type,\n-      // or a function literal with a name we haven't seen before.\n-      boolean inferred = true;\n-      if (info != null) {\n-        // Determining declaration for #1 + #3 + #4\n-        inferred = !(info.hasType()\n-            || info.hasEnumParameterType()\n-            || (info.isConstant() && valueType != null\n-                && !valueType.isUnknownType())\n-            || FunctionTypeBuilder.isFunctionTypeDeclaration(info));\n-      }\n-\n-      if (inferred) {\n-        // Determining declaration for #2\n-        inferred = !(rhsValue != null &&\n-            rhsValue.isFunction() &&\n-            (info != null || !scope.isDeclared(qName, false)));\n-      }\n+        Node context = ownerNode;\n+        ObjectType ownerType = null;\n+        boolean inferred = false;\n+        while (context != null && context.isGetProp()) {\n+          String contextName = context.getQualifiedName();\n+          ObjectType newType = getObjectSlot(contextName);\n+          if (newType == null) {\n+            newType = ObjectType.cast(getDeclaredType(t.getSourceName(), info, context, null));\n+          }\n \n-      if (!inferred) {\n-        ObjectType ownerType = getObjectSlot(ownerName);\n-        if (ownerType != null) {\n-          // Only declare this as an official property if it has not been\n-          // declared yet.\n-          boolean isExtern = t.getInput() != null && t.getInput().isExtern();\n-          if ((!ownerType.hasOwnProperty(propName) ||\n-               ownerType.isPropertyTypeInferred(propName)) &&\n-              ((isExtern && !ownerType.isNativeObjectType()) ||\n-               !ownerType.isInstanceType())) {\n-            // If the property is undeclared or inferred, declare it now.\n-            ownerType.defineDeclaredProperty(propName, valueType, n);\n+          if (newType == null) {\n+            inferred = true;\n+            break;\n+          } else {\n+            if (ownerName.equals(contextName)) {\n+              ownerType = newType;\n+            }\n+            context = context.getFirstChild();\n           }\n         }\n \n-        // If the property is already declared, the error will be\n-        // caught when we try to declare it in the current scope.\n-        defineSlot(n, parent, valueType, inferred);\n-      } else if (rhsValue != null && rhsValue.isTrue()) {\n-        // We declare these for delegate proxy method properties.\n-        FunctionType ownerType =\n-            JSType.toMaybeFunctionType(getObjectSlot(ownerName));\n-        if (ownerType != null) {\n-          JSType ownerTypeOfThis = ownerType.getTypeOfThis();\n-          String delegateName = codingConvention.getDelegateSuperclassName();\n-          JSType delegateType = delegateName == null ?\n-              null : typeRegistry.getType(delegateName);\n-          if (delegateType != null &&\n-              ownerTypeOfThis.isSubtype(delegateType)) {\n-            defineSlot(n, parent, getNativeType(BOOLEAN_TYPE), true);\n+        if (inferred) {\n+          if (parent.isExprResult()) {\n+            stubDeclarations.add(new StubDeclaration(\n+                n,\n+                t.getInput() != null && t.getInput().isExtern(),\n+                ownerName));\n+          }\n+        } else {\n+          if (ownerType == null) {\n+            inferred = true;\n+          } else {\n+            Boolean privateOverride = codingConvention.isPropertyTypeDeclaredInOwnerPrototype(propName, ownerType.getDisplayName());\n+            if (privateOverride == Boolean.FALSE) {\n+              ObjectType proto = ownerType.getImplicitPrototype();\n+              if (proto.isFunctionPrototypeType()) {\n+                // Assume that any properties we add to the Function prototype object\n+                // will be exposed as static properties on functions that use this prototype.\n+                ownerType = FunctionTypeBuilder.functionPrototypeToOrdinaryObject(ownerType);\n+              }\n+            } else if (privateOverride == null) {\n+              // The convention was not definitive. Ignore the override and treat the\n+              // property as any other.\n+              privateOverride = true;\n+            }\n+            if (ownerType.hasOwnProperty(propName)) {\n+              if (privateOverride) {\n+                t.report(n, PROPERTY_DECLARATION_IN_NON_GLOBAL_SCOPE, propName);\n+              }\n+            } else if (ownerType.isPropertyInherited(propName)) {\n+              if (privateOverride) {\n+                // If the property is inherited and private, it's still an error.\n+                t.report(n, INHERITED_PROPERTY_IN_EXTERNS, propName);\n+              }\n+            } else {\n+              ownerType.defineDeclaredProperty(propName, getDeclaredType(t.getSourceName(), info, n, rhsValue), n);\n+            }\n+            if (!privateOverride && (t.getInput() != null && t.getInput().isExtern() ^ ownerType.isNativeObjectType())) {\n+              t.report(n, EXTERNS_VALIDATION_PROPERTIES);\n+            }\n           }\n+          defineSlot(n, parent, getDeclaredType(t.getSourceName(), info, n, rhsValue), inferred);\n         }\n       }\n-    }\n \n     /**\n      * Find the ObjectType associated with the given slot.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}