{
    "patch": "public static double regularizedGamma(double a, double x) {\n    final double gamma = Gamma.gamma(a);\n    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n        return Double.NaN;\n    }\n    if (x < 0) {\n        return Double.NaN;\n    }\n    if (x == 0) {\n        return 0.0;\n    }\n    if (a <= 0) {\n        if (a < 0 && x >= 0) {\n            return Double.NaN;\n        }\n        if (x > 0) {\n            return 1.0;\n        }\n        return Double.NaN;\n    }\n    if (x >= a + 1) {\n        // use regularizedGamma1pm1(a, x)\n        final double gamma1pm1 = Gamma.regularizedGamma1pm1(a, x);\n        if (gamma1pm1 < Precision.EPSILON) {\n            return 1.0;\n        } else {\n            final double ret = gamma1pm1 / a;\n            return ret;\n        }\n    }\n    // remainder of the method contains code for x < a + 1\n    final double maxGam = Double.MAX_VALUE / x;\n    final int n = (int) Math.max(0, Math.floor(a));\n    final double prod = n == 0 ? 1.0 : 1.0 / Gamma.gamma(n);\n    double sum = prod * FastMath.pow(x, n);\n    if (Double.isInfinite(sum)) {\n        return Double.NaN;\n    }\n\n    for (int i = 1; i <= n; i ++) {\n        prod *= (a - i) / x;\n        sum += prod;\n        if (Double.isInfinite(prod) || Double.isInfinite(sum)) {\n            return Double.NaN;\n        }\n    }\n    final double term = prod * (a - n) / x;\n    final double epsilon = Precision.EPSILON * term / sum;\n    if (epsilon > 0.1) {\n        final double halfEps = 0.5 * epsilon;\n        final double term1 = prod * (a - n - halfEps) / x;\n        final double term2 = prod * (a - n + halfEps) / x;\n        if (term1 == 0.0 || term2 == 0.0) {\n            return Double.NaN;\n        }\n        if (Double.isInfinite(term1) || Double.isInfinite(term2)) {\n            return Double.NaN;\n        }\n        final double sum1 = sum + term1;\n        if (Double.isInfinite(sum1)) {\n            return Double.NaN;\n        }\n        final double sum2 = sum + term2;\n        if (Double.isInfinite(sum2)) {\n            return Double.NaN;\n        }\n        final double delta = (sum1 - sum2) / (2.0 * sum);\n        if (delta < epsilon) {\n            return sum1 / gamma;\n        } else {\n            return regularizedGamma(a, x + n) - sum2 / gamma;\n        }\n    } else {\n        return sum / gamma;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..624a799cb 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,82 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGamma(double a, double x) {\n+    final double gamma = Gamma.gamma(a);\n+    if (Double.isNaN(gamma) || Double.isInfinite(gamma)) {\n+        return Double.NaN;\n+    }\n+    if (x < 0) {\n+        return Double.NaN;\n+    }\n+    if (x == 0) {\n+        return 0.0;\n+    }\n+    if (a <= 0) {\n+        if (a < 0 && x >= 0) {\n+            return Double.NaN;\n+        }\n+        if (x > 0) {\n+            return 1.0;\n+        }\n+        return Double.NaN;\n+    }\n+    if (x >= a + 1) {\n+        // use regularizedGamma1pm1(a, x)\n+        final double gamma1pm1 = Gamma.regularizedGamma1pm1(a, x);\n+        if (gamma1pm1 < Precision.EPSILON) {\n+            return 1.0;\n+        } else {\n+            final double ret = gamma1pm1 / a;\n+            return ret;\n+        }\n+    }\n+    // remainder of the method contains code for x < a + 1\n+    final double maxGam = Double.MAX_VALUE / x;\n+    final int n = (int) Math.max(0, Math.floor(a));\n+    final double prod = n == 0 ? 1.0 : 1.0 / Gamma.gamma(n);\n+    double sum = prod * FastMath.pow(x, n);\n+    if (Double.isInfinite(sum)) {\n+        return Double.NaN;\n+    }\n+\n+    for (int i = 1; i <= n; i ++) {\n+        prod *= (a - i) / x;\n+        sum += prod;\n+        if (Double.isInfinite(prod) || Double.isInfinite(sum)) {\n+            return Double.NaN;\n+        }\n+    }\n+    final double term = prod * (a - n) / x;\n+    final double epsilon = Precision.EPSILON * term / sum;\n+    if (epsilon > 0.1) {\n+        final double halfEps = 0.5 * epsilon;\n+        final double term1 = prod * (a - n - halfEps) / x;\n+        final double term2 = prod * (a - n + halfEps) / x;\n+        if (term1 == 0.0 || term2 == 0.0) {\n+            return Double.NaN;\n+        }\n+        if (Double.isInfinite(term1) || Double.isInfinite(term2)) {\n+            return Double.NaN;\n+        }\n+        final double sum1 = sum + term1;\n+        if (Double.isInfinite(sum1)) {\n+            return Double.NaN;\n+        }\n+        final double sum2 = sum + term2;\n+        if (Double.isInfinite(sum2)) {\n+            return Double.NaN;\n+        }\n+        final double delta = (sum1 - sum2) / (2.0 * sum);\n+        if (delta < epsilon) {\n+            return sum1 / gamma;\n+        } else {\n+            return regularizedGamma(a, x + n) - sum2 / gamma;\n+        }\n+    } else {\n+        return sum / gamma;\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}