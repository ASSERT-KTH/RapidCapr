{
    "patch": "        // check if initial guess brackets the root\n        if (yMin * yMax > 0) {\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n        }\n\n        double x0 = min;\n        double x1 = initial;\n        double x2 = max;\n\n        double f0 = yMin;\n        double f1 = yInitial;\n        double f2 = yMax;\n\n        // implement the Brent algorithm\n        int iter = 0;\n        double delta = 0;\n        double tolerance = Math.max(relativeAccuracy * Math.abs(x1) , absoluteAccuracy);\n        double r = Double.NaN;\n        while (true) {\n            // calculate the interval bounding the root\n            if (f1 * f2 > 0.0) {\n                // f1 and f2 have the same sign, so x2 likely isn't important\n                x2 = x0;\n                f2 = f0;\n                delta = x1 - x0;\n                r = f1 / f0;\n            } else if (f0 * f1 > 0.0) {\n                // f0 and f1 have the same sign, so x0 likely isn't important\n                x0 = x1;\n                f0 = f1;\n                delta = x2 - x1;\n                r = f2 / f1;\n            } else {\n                // our work here is done, as we have found a root\n                setResult(x1, iter);\n                return result;\n            }\n\n            // calculate the new root candidate\n            if (Math.abs(f0) > Math.abs(f1)) {\n                // swap endpoints for bisection step\n                double tmp = x0;\n                x0 = x2;\n                x2 = tmp;\n\n                tmp = f0;\n                f0 = f2;\n                f2 = tmp;\n\n                // update delta\n                delta = x1 - x0;\n            }\n\n            // check for convergence\n            if (Math.abs(delta) < tolerance || Math.abs(f1) < functionValueAccuracy) {\n                setResult(x1, iter);\n                return result;\n            }\n\n            // perform a bisection step or interpolate\n            double x3 = 0.5 * (x0 + x1);\n            double dx = x1 - x3;\n            if (r * (f1 / f2) > dx / delta) {\n                // attempt to use interpolation\n                double tmp = (x1 - x0) * f1 / (f0 - f1) - dx / delta * (f2 - f1);\n                if (2.0 * Math.abs(tmp) < Math.min(3.0 * Math.abs(f1) * (x1 - x0), tolerance)) {\n                    setResult(x1, iter);\n                    return result;\n                }\n                // decide whether to use bisection or interpolation\n                if (tmp > 0.0) {\n                    x0 = x1;\n                    f0 = f1;\n                    x1 = x3;\n                    f1 = f.value(x1);\n                } else {\n                    x2 = x1;\n                    f2 = f1;\n                    x1 = x3;\n                    f1 = f.value(x1);\n                }\n            } else {\n                // if interpolation didn't work, fall back to bisection\n                x0 = x1;\n                f0 = f1;\n                x1 = x3;\n                f1 = f.value(x1);\n            }\n\n            iter++;\n            if (iter > maximalIterationCount) {\n                throw new MaxIterationsExceededException(maximalIterationCount);\n            }\n        }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..8d87c71a3 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,100 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        // check if initial guess brackets the root\n+        if (yMin * yMax > 0) {\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n+        }\n+\n+        double x0 = min;\n+        double x1 = initial;\n+        double x2 = max;\n+\n+        double f0 = yMin;\n+        double f1 = yInitial;\n+        double f2 = yMax;\n+\n+        // implement the Brent algorithm\n+        int iter = 0;\n+        double delta = 0;\n+        double tolerance = Math.max(relativeAccuracy * Math.abs(x1) , absoluteAccuracy);\n+        double r = Double.NaN;\n+        while (true) {\n+            // calculate the interval bounding the root\n+            if (f1 * f2 > 0.0) {\n+                // f1 and f2 have the same sign, so x2 likely isn't important\n+                x2 = x0;\n+                f2 = f0;\n+                delta = x1 - x0;\n+                r = f1 / f0;\n+            } else if (f0 * f1 > 0.0) {\n+                // f0 and f1 have the same sign, so x0 likely isn't important\n+                x0 = x1;\n+                f0 = f1;\n+                delta = x2 - x1;\n+                r = f2 / f1;\n+            } else {\n+                // our work here is done, as we have found a root\n+                setResult(x1, iter);\n+                return result;\n+            }\n+\n+            // calculate the new root candidate\n+            if (Math.abs(f0) > Math.abs(f1)) {\n+                // swap endpoints for bisection step\n+                double tmp = x0;\n+                x0 = x2;\n+                x2 = tmp;\n+\n+                tmp = f0;\n+                f0 = f2;\n+                f2 = tmp;\n+\n+                // update delta\n+                delta = x1 - x0;\n+            }\n+\n+            // check for convergence\n+            if (Math.abs(delta) < tolerance || Math.abs(f1) < functionValueAccuracy) {\n+                setResult(x1, iter);\n+                return result;\n+            }\n+\n+            // perform a bisection step or interpolate\n+            double x3 = 0.5 * (x0 + x1);\n+            double dx = x1 - x3;\n+            if (r * (f1 / f2) > dx / delta) {\n+                // attempt to use interpolation\n+                double tmp = (x1 - x0) * f1 / (f0 - f1) - dx / delta * (f2 - f1);\n+                if (2.0 * Math.abs(tmp) < Math.min(3.0 * Math.abs(f1) * (x1 - x0), tolerance)) {\n+                    setResult(x1, iter);\n+                    return result;\n+                }\n+                // decide whether to use bisection or interpolation\n+                if (tmp > 0.0) {\n+                    x0 = x1;\n+                    f0 = f1;\n+                    x1 = x3;\n+                    f1 = f.value(x1);\n+                } else {\n+                    x2 = x1;\n+                    f2 = f1;\n+                    x1 = x3;\n+                    f1 = f.value(x1);\n+                }\n+            } else {\n+                // if interpolation didn't work, fall back to bisection\n+                x0 = x1;\n+                f0 = f1;\n+                x1 = x3;\n+                f1 = f.value(x1);\n+            }\n+\n+            iter++;\n+            if (iter > maximalIterationCount) {\n+                throw new MaxIterationsExceededException(maximalIterationCount);\n+            }\n+        }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: unreachable statement",
    "test_result": "ERROR"
}