{
    "patch": "/**\n * A visitor making deep copies of subtrees, useful for implementing test harnesses and such.\n */\nclass CopyingTransformVisitor implements NodeVisitor {\n  private final IRFactory irFactory;\n  private final TypeSafeMutator mutator;\n\n  CopyingTransformVisitor(IRFactory irFactory) {\n    this.irFactory = irFactory;\n    this.mutator = new TransformDispatcher(irFactory);\n  }\n\n  @Override\n  public void visit(AstNode node) {\n    copy(node);\n  }\n\n  Node copy(AstNode node) {\n    if (node == null) {\n      return null; // Change this to return Constants.NULL_NODE to make attached node lists fail.\n    }\n\n    Node newNode = mutator.mutate(node);\n    if (newNode == null) {\n      newNode = irFactory.cloneNode(node);\n    }\n\n    // The following block exists only to protect a case where we might accidentally clear\n    // a merged node to undefined if we stop considering undefined as a bad constant. Any\n    // other cases may be expanded with the appropriate logger or check, e.g.:\n    // } else if (newNode == null) {\n    //   logger.log(Level.SEVERE, \"ERROR: Failed casting \" + node + \" into a node while copying it.\");\n    //   newNode = irFactory.createName(\"\");\n    // }\n    if (newNode == null) {\n      // TODO: Remove this block if it continues unused.\n      throw new RuntimeException(\"Failed casting node \\\"\" + node + \"\\\" into a node while copying.\");\n      // Actually, empty-string nodes usually mean PARAM_LIST of no args, but I'm unsure if\n      // there's a better way to check for that. Could use a getNumChildren() call, but it\n      // doesn't seem very semantic.\n      // return irFactory.createName(\"\");\n    }\n\n    if (newNode.getType() == Token.TRY) {\n      // Handle JSCompiler-350, which expects try statements to have a SEMI at the end.\n      newNode.putProp(Node.ENDS_WITH_COMMA, false);\n    }\n\n    if (newNode.getType() == Token.CALL || NodeUtil.isFunctionExpression(newNode)) {\n      // We need to clear the known RETURN value if we call a function (but not if we call a var).\n      newNode.putProp(Node.FUNCTION_PROPERTY_FIX, Boolean.TRUE);\n    }\n\n    return newNode;\n  }\n}\n\npublic class TransformDispatcher implements TypeSafeMutator {\n  private final IRFactory irFactory;\n\n  TransformDispatcher(IRFactory irFactory) {\n    this.irFactory = irFactory;\n  }\n\n    @Override\n  public Node mutate(Node node) {\n  switch (node.getToken()) {\n      case ERROR:\n        break;\n      case FUNCTION:\n        return processFunction((FunctionNode) node);\n      case NAME:\n        String name = ((Name) node).getIdentifier();\n        if (name.equals(JSTypeNative.ANY_TYPE.toString())) {\n          return newNode(Token.ANY_TYPE);\n        } else if (name.equals(JSTypeNative.NO_TYPE.toString())) {\n          return newNode(Token.NO_TYPE);\n        }\n        break;\n      case ARRAYLIT:\n        return processArrayLiteral(node);\n      case OBJECTLIT:\n        return processObjectLiteral(node);\n      case THIS:\n        return processThis(node);\n      case REGEXP:\n        return processRegExp(node);\n      case NUMBER:\n        return null;\n      case STRING:\n        return null;\n      case TEMPLATELIT:\n        return processTemplateLiteral((TemplateLiteral) node);\n      case BLOCK:\n        return processBlock((Block) node);\n      case FUNCTIONNODE:\n        return processFunction((FunctionNode) node);\n      case RETURN:\n        return processReturn((ReturnStatement) node);\n      case VAR:\n        return processVar(node);\n      case LET:\n      case CONST:\n        return processLetConst(node);\n      case CAST:\n        return processCast(node);\n      case NEW:\n        return processNew(node);\n      case CALL:\n        return processCall(node);\n      case TAGGED_TEMPLATELIT:\n        return processTaggedTemplateLiteral((TaggedTemplateLit) node);\n      case MEMBER_GETTER_DEF:\n        return processMemberGetterSetterDef(node);\n      case MEMBER_SETTER_DEF:\n        return processMemberGetterSetterDef(node);\n      case CLASS:\n        return processClass(node);\n      case EXPORT_DECL:\n        return processExportDecl(node);\n      case DEFAULT:\n        return processDefault(node);\n      case EXPORT:\n        return processExport(node);\n      case IMPORT:\n        return processImport(node);\n      case EXPORT_SPECS:\n        return processExportSpecs(node);\n      case TEMPLATELIT_SUB:\n        return processTemplateLiteralSub(node);\n      case ARRAY_PATTERN:\n        return processArrayPattern(node);\n      case OBJECT_PATTERN:\n        return processObjectPattern(node);\n      case PARAM_LIST:\n        return processFunctionArgs(node);\n      case DESTRUCTURING_PARAMS:\n        return processDestructuringParams(node);\n      case HOOK:\n        return processConditionalExpression(node);\n      case OR:\n        return processLogical(node, Token.OR);\n      case AND:\n        return processLogical(node, Token.AND);\n      case COALESCE:\n        return processLogical(node, Token.COALESCE);\n      case ASSIGN_ADD:\n        return processAssignOp(node, Token.ADD);\n      case ASSIGN_SUB:\n        return processAssignOp(node, Token.SUB);\n      case ASSIGN_MUL:\n        return processAssignOp(node, Token.MUL);\n      case ASSIGN_DIV:\n        return processAssignOp(node, Token.DIV);\n      case ASSIGN_MOD:\n        return processAssignOp(node, Token.MOD);\n      case ASSIGN_BITOR:\n        return processAssignOp(node, Token.BITOR);\n      case ASSIGN_BITXOR:\n        return processAssignOp(node, Token.BITXOR);\n      case ASSIGN_BITAND:\n        return processAssignOp(node, Token.BITAND);\n      case ASSIGN_LSH:\n        return processAssignOp(node, Token.LSH);\n      case ASSIGN_RSH:\n        return processAssignOp(node, Token.RSH);\n      case ASSIGN_URSH:\n        return processAssignOp(node, Token.URSH);\n      case ASSIGN:\n        return processAssign(node);\n      case ARRAY_ACCESSOR:\n        return processElementGet((ElementGet) node);\n      case CATCH:\n        return processCatchClause((CatchClause) node);\n      case WITH:\n        return processWith((With) node);\n      case IF:\n        return processIf((IfStatement) node);\n      case FOR:\n        return processFor((ForLoop) node);\n      case FOR_IN:\n      case FOR_OF:\n        return processForInLoop((ForInLoop) node);\n      case WHILE:\n        return processWhile((WhileLoop) node);\n      case DO:\n        return processDoLoop((DoLoop) node);\n      case SWITCH:\n        return processSwitch((SwitchStatement) node);\n      case CASE:\n        return processSwitchCase((SwitchCase) node);\n      case LABEL:\n        return processLabel((Label) node);\n      case BREAK:\n        return processBreakStatement((BreakStatement) node);\n      case CONTINUE:\n        return processContinueStatement((ContinueStatement) node);\n      case THROW:\n        return processThrow((ThrowStatement) node);\n      case TRY:\n        return processTry((TryStatement) node);\n      case SCRIPT:\n        return processScriptNode((ScriptNode) node);\n      case DEBUGGER:\n        return processDebugger(node);\n      case DEFAULT_XML_NAMESPACE:\n        return processDefaultXmlNameSpace(node);\n      case TEMPLATELIT_STRING:\n      case IMPORT_META:\n      case MEMBER_FUNCTION_DEF:\n      case MEMBER_VARIABLE_DEF:\n      case SETPROP:\n      case GETPROP:\n      case INC:\n      case DEC:\n      case NOT:\n      case POS:\n      case NEG:\n      case BITNOT:\n      case TYPEOF:\n      case VOID:\n      case DELPROP:\n      case NEWSTRING:\n      case IMPORT_ASSERTS:\n      case EXPR_VOID:\n      case MUL:\n      case DIV:\n      case MOD:\n      case ADD:\n      case SUB:\n      case BITOR:\n      case BITXOR:\n      case BITAND:\n      case LSH:\n      case RSH:\n      case URSH:\n      case EQ:\n      case NE:\n      case SHEQ:\n      case SHNE:\n      case LT:\n      case LE:\n      case GT:\n      case GE:\n      case INSTANCEOF:\n      case IN:\n        return processBinaryOperator(node);\n      case AWAIT:\n        return processUnaryOperator(node);\n      case YIELD:\n        return processYield(node);\n      case OBJECTLIT_PROP:\n        return processObjectProperty(node);\n      case METHOD_DEF:\n        return processMethodDef(node);\n      case REGEXP_LITERAL:\n        return processRegExpLiteral(node);\n      case ARRAY_COMP:\n        return processArrayComprehension((ArrayComprehension) node);\n      case FOR_IN_LIST:\n        // Will only be seen in an expanded for-in loop.\n        break;\n\n        // Used in error reporting.\n      case BLOCK_COMMENT:\n      case LINE_COMMENT:\n      case FUNCTION_PROP:\n      case LABEL_NAME:\n      case LET_BLOCK:\n      case LP:\n      case RP:\n      case LC:\n      case RC:\n      case ELISION:\n      case FIRST_RESERVED:\n      case LAST_RESERVED:\n      case FIRST_ASSIGN:\n      case LAST_ASSIGN:\n      case FIRST_BITWISE_OPERATOR:\n      case LAST_BITWISE_OPERATOR:\n      case FIRST_CONDITIONAL_OPERATOR:\n      case LAST_CONDITIONAL_OPERATOR:\n      case FIRST_LOGICAL_OPERATOR:\n      case LAST_LOGICAL_OPERATOR:\n      case FIRST_ARITHMETIC_OPERATOR:\n      case LAST_ARITHMETIC_OPERATOR:\n      case FIRST_COMPARISON_OPERATOR:\n      case LAST_COMPARISON_OPERATOR:\n      case LET_NAME:\n      case TYPEOFNAME:\n      case VOIDNAME:\n      case WITHNAME:\n      default:\n        throw new RuntimeException(\"Unhandled token: \" + node);\n    }\n    return node;\n }\n\n  // Process Methods for each node type\n  private Node processConditionalExpression(Node n) {\n    return newNode(\n        Token.HOOK,\n        transform(n.getFirstChild()),\n        transform(n.getSecondChild()),\n        transform(n.getLastChild()));\n  }\n\n  private Node processLogical(Node n, int logicalType) {\n    return newNode(\n        logicalType, transform(n.getFirstChild()), transform(n.getLastChild()));\n  }\n\n  private Node processAssignOp(Node n, int binaryType) {\n    Node lhs = transform(n.getFirstChild());\n\n    // lhs may contain GETs and/or calls, so split it apart like transform.\n    // This is important when lhs is e.g. an object literal method or has a destructuring parameter.\n    checkThatGetAndCallArePure(lhs);\n\n    Node rhs = transform(n.getLastChild());\n    lhs.setImmutable();\n    return new Node(\n        Token.ASSIGN,\n        lhs,\n        newNode(binaryType, lhs.detach(), rhs).setJSType(n.getJSType()).srcref(n));\n  }\n\n  private Node processAssign(Node n) {\n    Node lhs = transform(n.getFirstChild());\n\n    // lhs may contain GETs and/or calls, so split it apart like transform.\n    // This is important when lhs is e.g. an object literal method or has a destructuring parameter.\n    checkThatGetAndCallArePure(lhs);\n\n    Node rhs = transform(n.getLastChild());\n    lhs.setImmutable();\n    return new Node(Token.ASSIGN, lhs, rhs).setJSType(n.getJSType()).srcref(n);\n  }\n\n  private Node processElementGet(ElementGet n) {\n    return newNode(Token.GETELEM, transform(n.getTarget()), transform(n.getElement()));\n  }\n\n  private Node processCatchClause(CatchClause c) {\n    AstNode catchVar = c.getVarName();\n    Node catchNode =\n        newNode(Token.CATCH, transform(catchVar)).setJSType(catchVar.getJSType()).srcref(c);\n    if (c.getCatchCondition() != null) {\n//***    errorReporter.error(\"Catch clauses are not supported\", \n//          sourceName,\n//          c.getCatchCondition().getLineno(), \"\", 0);\n    }\n    catchNode.addChildToBack(transformBlock(c.getBody()));\n    return catchNode;\n  }\n\n  private Node processForInLoop(ForInLoop n) {\n    Node left = transform(n.getIterator());\n    if (left.getType() == Token.VAR || left.getType() == Token.LET || left.getType() == Token.CONST) {\n      left.getFirstChild().setType(Token.NAME);\n    } else {\n      left.setType(Token.NAME);\n    }\n\n    Node result = null;\n    if (n.isForEach()) {\n      result = new Node(Token.FOR_OF, left, transform(n.getIteratedObject()));\n    } else {\n      result = new Node(Token.FOR_IN, left, transform(n.getIteratedObject()));\n    }\n\n    result.addChildToBack(transformBlock(n.getBody()));\n    return result;\n  }\n\n  private void checkThatGetAndCallArePure(Node n) {\n    if (n.isGetProp() || n.isGetElem() || n.isCall()) {\n      Preconditions.checkState(NodeUtil.isImmutableValue(n), \"Get and call nodes must be immutable\");\n    }\n\n    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n      checkThatGetAndCallArePure(c);\n    }\n  }\n\n  @Override\n  public boolean hasTrivialPostcondition(Node node) {\n    return false;\n  }\n\n  // Drop-in replacement for newNode to add JSDoc information.\n  private Node newNode(Token type, Node... children) {\n    Node n = irFactory.createNode(type, children);\n    n.setJSDocInfo(findJSDocInfo(nodeAnnotations, n));\n    return n;\n  }\n\n  private Node newNode(Token type) {\n    Node n = irFactory.createNode(type);\n    n.setJSDocInfo(findJSDocInfo(nodeAnnotations, n));\n    return n;\n  }\n\n  private Node processDebugger(Node n) {\n    return newNode(Token.DEBUGGER);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..e4f622f5 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,413 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+/**\n+ * A visitor making deep copies of subtrees, useful for implementing test harnesses and such.\n+ */\n+class CopyingTransformVisitor implements NodeVisitor {\n+  private final IRFactory irFactory;\n+  private final TypeSafeMutator mutator;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  CopyingTransformVisitor(IRFactory irFactory) {\n+    this.irFactory = irFactory;\n+    this.mutator = new TransformDispatcher(irFactory);\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  @Override\n+  public void visit(AstNode node) {\n+    copy(node);\n+  }\n+\n+  Node copy(AstNode node) {\n+    if (node == null) {\n+      return null; // Change this to return Constants.NULL_NODE to make attached node lists fail.\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    Node newNode = mutator.mutate(node);\n+    if (newNode == null) {\n+      newNode = irFactory.cloneNode(node);\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    // The following block exists only to protect a case where we might accidentally clear\n+    // a merged node to undefined if we stop considering undefined as a bad constant. Any\n+    // other cases may be expanded with the appropriate logger or check, e.g.:\n+    // } else if (newNode == null) {\n+    //   logger.log(Level.SEVERE, \"ERROR: Failed casting \" + node + \" into a node while copying it.\");\n+    //   newNode = irFactory.createName(\"\");\n+    // }\n+    if (newNode == null) {\n+      // TODO: Remove this block if it continues unused.\n+      throw new RuntimeException(\"Failed casting node \\\"\" + node + \"\\\" into a node while copying.\");\n+      // Actually, empty-string nodes usually mean PARAM_LIST of no args, but I'm unsure if\n+      // there's a better way to check for that. Could use a getNumChildren() call, but it\n+      // doesn't seem very semantic.\n+      // return irFactory.createName(\"\");\n     }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    if (newNode.getType() == Token.TRY) {\n+      // Handle JSCompiler-350, which expects try statements to have a SEMI at the end.\n+      newNode.putProp(Node.ENDS_WITH_COMMA, false);\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    if (newNode.getType() == Token.CALL || NodeUtil.isFunctionExpression(newNode)) {\n+      // We need to clear the known RETURN value if we call a function (but not if we call a var).\n+      newNode.putProp(Node.FUNCTION_PROPERTY_FIX, Boolean.TRUE);\n     }\n \n+    return newNode;\n+  }\n+}\n+\n+public class TransformDispatcher implements TypeSafeMutator {\n+  private final IRFactory irFactory;\n+\n+  TransformDispatcher(IRFactory irFactory) {\n+    this.irFactory = irFactory;\n+  }\n+\n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  public Node mutate(Node node) {\n+  switch (node.getToken()) {\n+      case ERROR:\n+        break;\n+      case FUNCTION:\n+        return processFunction((FunctionNode) node);\n+      case NAME:\n+        String name = ((Name) node).getIdentifier();\n+        if (name.equals(JSTypeNative.ANY_TYPE.toString())) {\n+          return newNode(Token.ANY_TYPE);\n+        } else if (name.equals(JSTypeNative.NO_TYPE.toString())) {\n+          return newNode(Token.NO_TYPE);\n+        }\n+        break;\n+      case ARRAYLIT:\n+        return processArrayLiteral(node);\n+      case OBJECTLIT:\n+        return processObjectLiteral(node);\n+      case THIS:\n+        return processThis(node);\n+      case REGEXP:\n+        return processRegExp(node);\n+      case NUMBER:\n+        return null;\n+      case STRING:\n+        return null;\n+      case TEMPLATELIT:\n+        return processTemplateLiteral((TemplateLiteral) node);\n+      case BLOCK:\n+        return processBlock((Block) node);\n+      case FUNCTIONNODE:\n+        return processFunction((FunctionNode) node);\n+      case RETURN:\n+        return processReturn((ReturnStatement) node);\n+      case VAR:\n+        return processVar(node);\n+      case LET:\n+      case CONST:\n+        return processLetConst(node);\n+      case CAST:\n+        return processCast(node);\n+      case NEW:\n+        return processNew(node);\n+      case CALL:\n+        return processCall(node);\n+      case TAGGED_TEMPLATELIT:\n+        return processTaggedTemplateLiteral((TaggedTemplateLit) node);\n+      case MEMBER_GETTER_DEF:\n+        return processMemberGetterSetterDef(node);\n+      case MEMBER_SETTER_DEF:\n+        return processMemberGetterSetterDef(node);\n+      case CLASS:\n+        return processClass(node);\n+      case EXPORT_DECL:\n+        return processExportDecl(node);\n+      case DEFAULT:\n+        return processDefault(node);\n+      case EXPORT:\n+        return processExport(node);\n+      case IMPORT:\n+        return processImport(node);\n+      case EXPORT_SPECS:\n+        return processExportSpecs(node);\n+      case TEMPLATELIT_SUB:\n+        return processTemplateLiteralSub(node);\n+      case ARRAY_PATTERN:\n+        return processArrayPattern(node);\n+      case OBJECT_PATTERN:\n+        return processObjectPattern(node);\n+      case PARAM_LIST:\n+        return processFunctionArgs(node);\n+      case DESTRUCTURING_PARAMS:\n+        return processDestructuringParams(node);\n+      case HOOK:\n+        return processConditionalExpression(node);\n+      case OR:\n+        return processLogical(node, Token.OR);\n+      case AND:\n+        return processLogical(node, Token.AND);\n+      case COALESCE:\n+        return processLogical(node, Token.COALESCE);\n+      case ASSIGN_ADD:\n+        return processAssignOp(node, Token.ADD);\n+      case ASSIGN_SUB:\n+        return processAssignOp(node, Token.SUB);\n+      case ASSIGN_MUL:\n+        return processAssignOp(node, Token.MUL);\n+      case ASSIGN_DIV:\n+        return processAssignOp(node, Token.DIV);\n+      case ASSIGN_MOD:\n+        return processAssignOp(node, Token.MOD);\n+      case ASSIGN_BITOR:\n+        return processAssignOp(node, Token.BITOR);\n+      case ASSIGN_BITXOR:\n+        return processAssignOp(node, Token.BITXOR);\n+      case ASSIGN_BITAND:\n+        return processAssignOp(node, Token.BITAND);\n+      case ASSIGN_LSH:\n+        return processAssignOp(node, Token.LSH);\n+      case ASSIGN_RSH:\n+        return processAssignOp(node, Token.RSH);\n+      case ASSIGN_URSH:\n+        return processAssignOp(node, Token.URSH);\n+      case ASSIGN:\n+        return processAssign(node);\n+      case ARRAY_ACCESSOR:\n+        return processElementGet((ElementGet) node);\n+      case CATCH:\n+        return processCatchClause((CatchClause) node);\n+      case WITH:\n+        return processWith((With) node);\n+      case IF:\n+        return processIf((IfStatement) node);\n+      case FOR:\n+        return processFor((ForLoop) node);\n+      case FOR_IN:\n+      case FOR_OF:\n+        return processForInLoop((ForInLoop) node);\n+      case WHILE:\n+        return processWhile((WhileLoop) node);\n+      case DO:\n+        return processDoLoop((DoLoop) node);\n+      case SWITCH:\n+        return processSwitch((SwitchStatement) node);\n+      case CASE:\n+        return processSwitchCase((SwitchCase) node);\n+      case LABEL:\n+        return processLabel((Label) node);\n+      case BREAK:\n+        return processBreakStatement((BreakStatement) node);\n+      case CONTINUE:\n+        return processContinueStatement((ContinueStatement) node);\n+      case THROW:\n+        return processThrow((ThrowStatement) node);\n+      case TRY:\n+        return processTry((TryStatement) node);\n+      case SCRIPT:\n+        return processScriptNode((ScriptNode) node);\n+      case DEBUGGER:\n+        return processDebugger(node);\n+      case DEFAULT_XML_NAMESPACE:\n+        return processDefaultXmlNameSpace(node);\n+      case TEMPLATELIT_STRING:\n+      case IMPORT_META:\n+      case MEMBER_FUNCTION_DEF:\n+      case MEMBER_VARIABLE_DEF:\n+      case SETPROP:\n+      case GETPROP:\n+      case INC:\n+      case DEC:\n+      case NOT:\n+      case POS:\n+      case NEG:\n+      case BITNOT:\n+      case TYPEOF:\n+      case VOID:\n+      case DELPROP:\n+      case NEWSTRING:\n+      case IMPORT_ASSERTS:\n+      case EXPR_VOID:\n+      case MUL:\n+      case DIV:\n+      case MOD:\n+      case ADD:\n+      case SUB:\n+      case BITOR:\n+      case BITXOR:\n+      case BITAND:\n+      case LSH:\n+      case RSH:\n+      case URSH:\n+      case EQ:\n+      case NE:\n+      case SHEQ:\n+      case SHNE:\n+      case LT:\n+      case LE:\n+      case GT:\n+      case GE:\n+      case INSTANCEOF:\n+      case IN:\n+        return processBinaryOperator(node);\n+      case AWAIT:\n+        return processUnaryOperator(node);\n+      case YIELD:\n+        return processYield(node);\n+      case OBJECTLIT_PROP:\n+        return processObjectProperty(node);\n+      case METHOD_DEF:\n+        return processMethodDef(node);\n+      case REGEXP_LITERAL:\n+        return processRegExpLiteral(node);\n+      case ARRAY_COMP:\n+        return processArrayComprehension((ArrayComprehension) node);\n+      case FOR_IN_LIST:\n+        // Will only be seen in an expanded for-in loop.\n+        break;\n+\n+        // Used in error reporting.\n+      case BLOCK_COMMENT:\n+      case LINE_COMMENT:\n+      case FUNCTION_PROP:\n+      case LABEL_NAME:\n+      case LET_BLOCK:\n+      case LP:\n+      case RP:\n+      case LC:\n+      case RC:\n+      case ELISION:\n+      case FIRST_RESERVED:\n+      case LAST_RESERVED:\n+      case FIRST_ASSIGN:\n+      case LAST_ASSIGN:\n+      case FIRST_BITWISE_OPERATOR:\n+      case LAST_BITWISE_OPERATOR:\n+      case FIRST_CONDITIONAL_OPERATOR:\n+      case LAST_CONDITIONAL_OPERATOR:\n+      case FIRST_LOGICAL_OPERATOR:\n+      case LAST_LOGICAL_OPERATOR:\n+      case FIRST_ARITHMETIC_OPERATOR:\n+      case LAST_ARITHMETIC_OPERATOR:\n+      case FIRST_COMPARISON_OPERATOR:\n+      case LAST_COMPARISON_OPERATOR:\n+      case LET_NAME:\n+      case TYPEOFNAME:\n+      case VOIDNAME:\n+      case WITHNAME:\n+      default:\n+        throw new RuntimeException(\"Unhandled token: \" + node);\n+    }\n+    return node;\n+ }\n+\n+  // Process Methods for each node type\n+  private Node processConditionalExpression(Node n) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(n.getFirstChild()),\n+        transform(n.getSecondChild()),\n+        transform(n.getLastChild()));\n+  }\n+\n+  private Node processLogical(Node n, int logicalType) {\n+    return newNode(\n+        logicalType, transform(n.getFirstChild()), transform(n.getLastChild()));\n+  }\n+\n+  private Node processAssignOp(Node n, int binaryType) {\n+    Node lhs = transform(n.getFirstChild());\n+\n+    // lhs may contain GETs and/or calls, so split it apart like transform.\n+    // This is important when lhs is e.g. an object literal method or has a destructuring parameter.\n+    checkThatGetAndCallArePure(lhs);\n+\n+    Node rhs = transform(n.getLastChild());\n+    lhs.setImmutable();\n+    return new Node(\n+        Token.ASSIGN,\n+        lhs,\n+        newNode(binaryType, lhs.detach(), rhs).setJSType(n.getJSType()).srcref(n));\n+  }\n+\n+  private Node processAssign(Node n) {\n+    Node lhs = transform(n.getFirstChild());\n+\n+    // lhs may contain GETs and/or calls, so split it apart like transform.\n+    // This is important when lhs is e.g. an object literal method or has a destructuring parameter.\n+    checkThatGetAndCallArePure(lhs);\n+\n+    Node rhs = transform(n.getLastChild());\n+    lhs.setImmutable();\n+    return new Node(Token.ASSIGN, lhs, rhs).setJSType(n.getJSType()).srcref(n);\n+  }\n+\n+  private Node processElementGet(ElementGet n) {\n+    return newNode(Token.GETELEM, transform(n.getTarget()), transform(n.getElement()));\n+  }\n+\n+  private Node processCatchClause(CatchClause c) {\n+    AstNode catchVar = c.getVarName();\n+    Node catchNode =\n+        newNode(Token.CATCH, transform(catchVar)).setJSType(catchVar.getJSType()).srcref(c);\n+    if (c.getCatchCondition() != null) {\n+//***    errorReporter.error(\"Catch clauses are not supported\", \n+//          sourceName,\n+//          c.getCatchCondition().getLineno(), \"\", 0);\n+    }\n+    catchNode.addChildToBack(transformBlock(c.getBody()));\n+    return catchNode;\n+  }\n+\n+  private Node processForInLoop(ForInLoop n) {\n+    Node left = transform(n.getIterator());\n+    if (left.getType() == Token.VAR || left.getType() == Token.LET || left.getType() == Token.CONST) {\n+      left.getFirstChild().setType(Token.NAME);\n+    } else {\n+      left.setType(Token.NAME);\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    Node result = null;\n+    if (n.isForEach()) {\n+      result = new Node(Token.FOR_OF, left, transform(n.getIteratedObject()));\n+    } else {\n+      result = new Node(Token.FOR_IN, left, transform(n.getIteratedObject()));\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    result.addChildToBack(transformBlock(n.getBody()));\n+    return result;\n+  }\n+\n+  private void checkThatGetAndCallArePure(Node n) {\n+    if (n.isGetProp() || n.isGetElem() || n.isCall()) {\n+      Preconditions.checkState(NodeUtil.isImmutableValue(n), \"Get and call nodes must be immutable\");\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+      checkThatGetAndCallArePure(c);\n     }\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  public boolean hasTrivialPostcondition(Node node) {\n+    return false;\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+  // Drop-in replacement for newNode to add JSDoc information.\n+  private Node newNode(Token type, Node... children) {\n+    Node n = irFactory.createNode(type, children);\n+    n.setJSDocInfo(findJSDocInfo(nodeAnnotations, n));\n+    return n;\n+  }\n+\n+  private Node newNode(Token type) {\n+    Node n = irFactory.createNode(type);\n+    n.setJSDocInfo(findJSDocInfo(nodeAnnotations, n));\n+    return n;\n+  }\n+\n+  private Node processDebugger(Node n) {\n+    return newNode(Token.DEBUGGER);\n+  }\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: class IRFactory.TransformDispatcher is already defined in class IRFactory",
    "test_result": "ERROR"
}