{
    "patch": "  private static final ImmutableSet<JSType.Nullability> NOT_NULL_OR_UNDEF =\n      ImmutableSet.of(JSType.Nullability.NOT_NULL, JSType.Nullability.UNDEFINED);\n\n  private void inferPropertiesFromConstraint(\n      ObjectType type, ObjectType constraint) {\n    if (constraint == null || !constraint.isRecordType()) {\n      return;\n    }\n    for (String prop : constraint.getOwnPropertyNames()) {\n      JSType propType = constraint.getPropertyType(prop);\n      TypeWithLocation twl = constraint.getOwnPropertyDefSite(prop);\n      JSType actualType = twl == null || twl.getJSType() == null\n          ? propType.instantiateGenerics(type.getTemplateTypeMap())\n          : twl.getJSType().instantiateGenerics(type.getTemplateTypeMap());\n      if (!type.hasProperty(prop) ||\n          (!type.isPropertyTypeDeclared(prop) &&\n           NOT_NULL_OR_UNDEF.contains(type.getPropNullability(prop)))) {\n        JSType inferredType = actualType.isUnknownType()\n            ? type.getPropType(prop)\n            : actualType.getLeastSupertype(type.getPropType(prop));\n        type.defineInferredProperty(prop, inferredType, twl == null ? null : twl.getSourcePosition());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e10920..751ff159 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1118,21 +1118,27 @@ class TypeInference\n \n     ObjectType constraintObj =\n         ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n-        }\n-      }\n+  private static final ImmutableSet<JSType.Nullability> NOT_NULL_OR_UNDEF =\n+      ImmutableSet.of(JSType.Nullability.NOT_NULL, JSType.Nullability.UNDEFINED);\n+\n+  private void inferPropertiesFromConstraint(\n+      ObjectType type, ObjectType constraint) {\n+    if (constraint == null || !constraint.isRecordType()) {\n+      return;\n+    }\n+    for (String prop : constraint.getOwnPropertyNames()) {\n+      JSType propType = constraint.getPropertyType(prop);\n+      TypeWithLocation twl = constraint.getOwnPropertyDefSite(prop);\n+      JSType actualType = twl == null || twl.getJSType() == null\n+          ? propType.instantiateGenerics(type.getTemplateTypeMap())\n+          : twl.getJSType().instantiateGenerics(type.getTemplateTypeMap());\n+      if (!type.hasProperty(prop) ||\n+          (!type.isPropertyTypeDeclared(prop) &&\n+           NOT_NULL_OR_UNDEF.contains(type.getPropNullability(prop)))) {\n+        JSType inferredType = actualType.isUnknownType()\n+            ? type.getPropType(prop)\n+            : actualType.getLeastSupertype(type.getPropType(prop));\n+        type.defineInferredProperty(prop, inferredType, twl == null ? null : twl.getSourcePosition());\n     }\n   }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}