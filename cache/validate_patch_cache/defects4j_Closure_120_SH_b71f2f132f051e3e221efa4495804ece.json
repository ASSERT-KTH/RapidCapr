{
    "patch": "boolean isAssignedOnceInLifetime() {\n    List<BasicBlock> visitedBlocks = new ArrayList<>();\n    Set<BasicBlock> assignmentBlocks = new HashSet<>();\n\n    Reference ref = getOneAndOnlyAssignment();\n    if (ref == null) {\n        return false;\n    }\n\n    // Add the block of the first assignment to the set of visited blocks.\n    BasicBlock firstBlock = ref.getBasicBlock();\n    visitedBlocks.add(firstBlock);\n\n    queue.addAll(getCfg().getOutEdges(firstBlock));\n    while (!queue.isEmpty()) {\n        DiGraphEdge<BasicBlock, Branch> edge = queue.poll();\n        BasicBlock nextBlock = edge.getEnd();\n        if (!visitedBlocks.add(nextBlock)) {\n            continue;\n        }\n\n        if (nextBlock.isFunction()) {\n            // We've reached the end of the function without detecting\n            // another assignment. The variable is assigned once in its\n            // lifetime.\n            return true;\n        }\n\n        List<Statement> statements = nextBlock.getStatements();\n        int n = statements.size();\n        Statement lastStatement = statements.get(n - 1);\n\n        if (lastStatement instanceof Write) {\n            Reference ref2 = ((Write) lastStatement).getTarget();\n            if (ref2 == ref) {\n                // We've found another assignment to the same variable.\n                // However, if this assignment is in a block that has already\n                // been visited (i.e., a back edge), then the variable is not\n                // assigned once in its lifetime.\n                if (assignmentBlocks.add(nextBlock)) {\n                    return false;\n                }\n            }\n        }\n\n        queue.addAll(getCfg().getOutEdges(nextBlock));\n    }\n\n    return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..795733da 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,56 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+boolean isAssignedOnceInLifetime() {\n+    List<BasicBlock> visitedBlocks = new ArrayList<>();\n+    Set<BasicBlock> assignmentBlocks = new HashSet<>();\n+\n+    Reference ref = getOneAndOnlyAssignment();\n+    if (ref == null) {\n+        return false;\n+    }\n+\n+    // Add the block of the first assignment to the set of visited blocks.\n+    BasicBlock firstBlock = ref.getBasicBlock();\n+    visitedBlocks.add(firstBlock);\n+\n+    queue.addAll(getCfg().getOutEdges(firstBlock));\n+    while (!queue.isEmpty()) {\n+        DiGraphEdge<BasicBlock, Branch> edge = queue.poll();\n+        BasicBlock nextBlock = edge.getEnd();\n+        if (!visitedBlocks.add(nextBlock)) {\n+            continue;\n+        }\n+\n+        if (nextBlock.isFunction()) {\n+            // We've reached the end of the function without detecting\n+            // another assignment. The variable is assigned once in its\n+            // lifetime.\n+            return true;\n+        }\n+\n+        List<Statement> statements = nextBlock.getStatements();\n+        int n = statements.size();\n+        Statement lastStatement = statements.get(n - 1);\n+\n+        if (lastStatement instanceof Write) {\n+            Reference ref2 = ((Write) lastStatement).getTarget();\n+            if (ref2 == ref) {\n+                // We've found another assignment to the same variable.\n+                // However, if this assignment is in a block that has already\n+                // been visited (i.e., a back edge), then the variable is not\n+                // assigned once in its lifetime.\n+                if (assignmentBlocks.add(nextBlock)) {\n+                    return false;\n+                }\n+            }\n+        }\n+\n+        queue.addAll(getCfg().getOutEdges(nextBlock));\n+    }\n+\n+    return false;\n+}\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}