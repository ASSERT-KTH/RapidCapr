{
    "patch": "    if (!NodeUtil.isAssignmentOp(parent)) {\n        parent = null;\n    }\n\n    if (parent != null && NodeUtil.isAssignmentOp(n)) {\n        Node grandParent = parent.getParent();\n        boolean isForInInitializer = grandParent != null && grandParent.isVanillaFor() && grandParent.getFirstChild() == parent;\n        boolean isObjectLiteralOrArrayLiteralInitializer = grandParent != null && (grandParent.isObjectLit()\n                || grandParent.isArrayLit());\n        boolean isArrayAccessResult = NodeUtil.mayBeArrayMethod(n.getParent().getParent());\n\n        if (isArrayAccessResult || isObjectLiteralOrArrayLiteralInitializer || isForInInitializer) {\n            return n;\n        }\n    }\n\n    if (right.getType() != Token.NUMBER || !left.isArrayLit()) {\n        // Sometimes people like to use complex expressions to index into\n        // arrays, or strings to index into array methods or the left operand of this expression is not an array literal.\n        return n;\n    }\n\n    double index = right.getDouble();\n    int intIndex = (int) index;\n    if (intIndex != index || intIndex < 0 || intIndex >= left.getChildCount()) {\n        error(JSErrorType.JSC_INDEX_OUT_OF_BOUNDS_ERROR, right);\n        return n;\n    }\n\n    Node elem = left.getChildAt(intIndex).detach();\n    if (elem == null) {\n        elem = Node.newUndefinedNode(left);\n    }\n\n    n.replaceWith(elem);\n    reportCodeChange();\n    return elem;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 0b2636f4..a6565c12 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1280,6 +1280,43 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     // If GETPROP/GETELEM is used as assignment target the array literal is\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n+    if (!NodeUtil.isAssignmentOp(parent)) {\n+        parent = null;\n+    }\n+\n+    if (parent != null && NodeUtil.isAssignmentOp(n)) {\n+        Node grandParent = parent.getParent();\n+        boolean isForInInitializer = grandParent != null && grandParent.isVanillaFor() && grandParent.getFirstChild() == parent;\n+        boolean isObjectLiteralOrArrayLiteralInitializer = grandParent != null && (grandParent.isObjectLit()\n+                || grandParent.isArrayLit());\n+        boolean isArrayAccessResult = NodeUtil.mayBeArrayMethod(n.getParent().getParent());\n+\n+        if (isArrayAccessResult || isObjectLiteralOrArrayLiteralInitializer || isForInInitializer) {\n+            return n;\n+        }\n+    }\n+\n+    if (right.getType() != Token.NUMBER || !left.isArrayLit()) {\n+        // Sometimes people like to use complex expressions to index into\n+        // arrays, or strings to index into array methods or the left operand of this expression is not an array literal.\n+        return n;\n+    }\n+\n+    double index = right.getDouble();\n+    int intIndex = (int) index;\n+    if (intIndex != index || intIndex < 0 || intIndex >= left.getChildCount()) {\n+        error(JSErrorType.JSC_INDEX_OUT_OF_BOUNDS_ERROR, right);\n+        return n;\n+    }\n+\n+    Node elem = left.getChildAt(intIndex).detach();\n+    if (elem == null) {\n+        elem = Node.newUndefinedNode(left);\n+    }\n+\n+    n.replaceWith(elem);\n+    reportCodeChange();\n+    return elem;\n \n     if (right.getType() != Token.NUMBER) {\n       // Sometimes people like to use complex expressions to index into",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}