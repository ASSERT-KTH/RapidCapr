{
    "patch": "public class IRFactory extends Parser {\n    private final ErrorReporter errorReporter;\n\n    public IRFactory(ErrorReporter errorReporter) {\n        this.errorReporter = errorReporter;\n    }\n\n    abstract class TransformDispatcher implements NodeTransformer<Node> {\n        @Override\n        public Node transform(Node node) {\n            switch (node.getType()) {\n                case Token.BLOCK:\n                    return processBlock((Block) node);\n                case Token.BREAK:\n                    return processBreakStatement((BreakStatement) node);\n                case Token.CATCH:\n                    return processCatchClause((CatchClause) node);\n                case Token.HOOK:\n                    return processConditionalExpression((ConditionalExpression) node);\n                case Token.CONTINUE:\n                    return processContinueStatement((ContinueStatement) node);\n                case Token.DO:\n                    return processDoLoop((DoLoop) node);\n                case Token.GETELEM:\n                    return processElementGet((ElementGet) node);\n                case Token.EMPTY:\n                    return processEmptyExpression((EmptyExpression) node);\n                case Token.FOR:\n                    return processForInLoop((ForInLoop) node);\n                case Token.FOR_IN:\n                    return processForIn((ForInLoop) node);\n                case Token.IF:\n                    return processIf((IfStatement) node);\n                case Token.LABEL:\n                    return processLabeledStatement((LabeledStatement) node);\n                case Token.WHILE:\n                    return processLoop((Loop) node);\n                case Token.NEW:\n                    return processNewExpression((NewExpression) node);\n                case Token.DOT:\n                case Token.NAME:\n                case Token.FUNCTION:\n                case Token.ARRAYLIT:\n                case Token.OBJECTLIT:\n                case Token.NUMBER:\n                case Token.STRING:\n                case Token.REGEXP:\n                case Token.NULL:\n                case Token.THIS:\n                case Token.TRUE:\n                case Token.FALSE:\n                case Token.TRY:\n                case Token.VAR:\n                case Token.LET:\n                case Token.CONST:\n                case Token.WITH:\n                case Token.SWITCH:\n                case Token.CASE:\n                case Token.DEFAULT:\n                case Token.THROW:\n                case Token.RETURN:\n                case Token.INSTANCEOF:\n                case Token.TYPEOF:\n                case Token.DELETE:\n                case Token.VOID:\n                case Token.NOT:\n                case Token.BITNOT:\n                case Token.POS:\n                case Token.NEG:\n                case Token.HOOKCALL:\n                case Token.ADD:\n                case Token.SUB:\n                case Token.MUL:\n                case Token.DIV:\n                case Token.MOD:\n                case Token.SHEQ:\n                case Token.SHNE:\n                case Token.BITOR:\n                case Token.BITXOR:\n                case Token.BITAND:\n                case Token.LSH:\n                case Token.RSH:\n                case Token.URSH:\n                case Token.LT:\n                case Token.LE:\n                case Token.GT:\n                case Token.GE:\n                case Token.COMMA:\n                case Token.OR:\n                case Token.AND:\n                case Token.INC:\n                case Token.DEC:\n                case Token.ASSIGN:\n                case Token.ASSIGN_BITOR:\n                case Token.ASSIGN_BITXOR:\n                case Token.ASSIGN_BITAND:\n                case Token.ASSIGN_LSH:\n                case Token.ASSIGN_RSH:\n                case Token.ASSIGN_URSH:\n                case Token.ASSIGN_ADD:\n                case Token.ASSIGN_SUB:\n                case Token.ASSIGN_MUL:\n                case Token.ASSIGN_DIV:\n                case Token.ASSIGN_MOD:\n                    return node;\n                case Token.EXPR_RESULT:\n                    return processExpressionStatement((ExpressionStatement) node);\n                default:\n                    errorReporter.fatalError(\"Unsupported node type: \" + node.getType(),\n                            sourceURI,\n                            node.getLineno(),\n                            node.getCharno());\n                    return new Node(Token.EMPTY);\n            }\n        }\n\n        abstract Node processBlock(Block blockNode);\n\n        abstract Node processBreakStatement(BreakStatement statementNode);\n\n        abstract Node processCatchClause(CatchClause clauseNode);\n\n        abstract Node processConditionalExpression(ConditionalExpression exprNode);\n\n        abstract Node processContinueStatement(ContinueStatement statementNode);\n\n        abstract Node processDoLoop(DoLoop loopNode);\n\n        abstract Node processElementGet(ElementGet getNode);\n\n        abstract Node processEmptyExpression(EmptyExpression exprNode);\n\n        abstract Node processExpressionStatement(ExpressionStatement statementNode);\n\n        abstract Node processForInLoop(ForInLoop loopNode);\n\n        abstract Node processIf(IfStatement ifNode);\n\n        abstract Node processLabeledStatement(LabeledStatement statementNode);\n\n        abstract Node processLoop(Loop loopNode);\n\n        abstract Node processNewExpression(NewExpression newExprNode);\n\n        abstract Node processForIn(ForInLoop loopNode);\n    }\n\n    class Transform extends TransformDispatcher {\n        private final String sourceURI;\n\n        Transform(String sourceURI) {\n            this.sourceURI = sourceURI;\n        }\n\n        @Override\n        Node processBlock(Block blockNode) {\n            Node root = newNode(Token.BLOCK);\n            for (Node kid : blockNode)\n                root.addChildToBack(transform(kid));\n            return root;\n        }\n\n        @Override\n        Node processBreakStatement(BreakStatement statementNode) {\n            Node node = newNode(Token.BREAK);\n            if (statementNode.getBreakLabel() != null) {\n                Node labelName = transform(statementNode.getBreakLabel());\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        Node processCatchClause(CatchClause clauseNode) {\n            AstNode catchVar = clauseNode.getVarName();\n            Node node = newNode(Token.CATCH, transform(catchVar));\n            if (clauseNode.getCatchCondition() != null) {\n                errorReporter.error(\n                        \"Catch clauses are not supported\",\n                        sourceURI,\n                        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n            }\n            node.addChildToBack(transformBlock(clauseNode.getBody()));\n            return node;\n        }\n\n        @Override\n        Node processConditionalExpression(ConditionalExpression exprNode) {\n            return newNode(\n                    Token.HOOK,\n                    transform(exprNode.getTestExpression()),\n                    transform(exprNode.getTrueExpression()),\n                    transform(exprNode.getFalseExpression()));\n        }\n\n        @Override\n        Node processContinueStatement(ContinueStatement statementNode) {\n            Node node = newNode(Token.CONTINUE);\n            if (statementNode.getLabel() != null) {\n                Node labelName = transform(statementNode.getLabel());\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        Node processDoLoop(DoLoop loopNode) {\n            return newNode(\n                    Token.DO,\n                    transformBlock(loopNode.getBody()),\n                    transform(loopNode.getCondition()));\n        }\n\n        @Override\n        Node processElementGet(ElementGet getNode) {\n            return newNode(\n                    Token.GETELEM,\n                    transform(getNode.getTarget()),\n                    transform(getNode.getElement()));\n        }\n\n        @Override\n        Node processEmptyExpression(EmptyExpression exprNode) {\n            Node node = newNode(Token.EMPTY);\n            return node;\n        }\n\n        @Override\n        Node processExpressionStatement(ExpressionStatement statementNode) {\n            Node node = newNode(Token.EXPR_RESULT);\n            node.addChildToBack(transform(statementNode.getExpression()));\n            return node;\n        }\n\n        @Override\n        Node processForInLoop(ForInLoop loopNode) {\n            AstNode iterator = loopNode.getIterator();\n            Node iteratedObject = transform(loopNode.getIteratedObject());\n            Node body = transformBlock(loopNode.getBody());\n            Node newNode;\n            if (iterator instanceof Name || iterator instanceof KeywordLiteral) {\n                newNode = newNode(Token.FOR);\n                newNode.addChildToBack(transform(iterator));\n                newNode.addChildToBack(iteratedObject);\n                newNode.addChildToBack(body);\n            } else {\n                // Error: Invalid left-hand side in for-in loop\n                errorReporter.error(\n                        \"Invalid left-hand side in for-in loop\",\n                        sourceURI,\n                        iterator.getLineno(), \"\", 0);\n                newNode = new Node(Token.EMPTY);\n            }\n            return newNode;\n        }\n\n        @Override\n        Node processIf(IfStatement ifNode) {\n            Node node =\n                    newNode(\n                            Token.IF,\n                            transform(ifNode.getCondition()),\n                            transformBlock(ifNode.getThenPart()));\n            if (ifNode.getElsePart() != null) {\n                node.addChildToBack(transformBlock(ifNode.getElsePart()));\n            }\n            return node;\n        }\n\n        @Override\n        Node processLabeledStatement(LabeledStatement statementNode) {\n            return newNode(\n                    Token.LABEL,\n                    transform(statementNode.getLabel()),\n                    transform(statementNode.getStatement()));\n        }\n\n        @Override\n        Node processLoop(Loop loopNode) {\n            int nodeType;\n            AstNode cond = null;\n            // transform headers other than For and For...in:\n            if (loopNode instanceof ForInLoop) {\n                return processForIn((ForInLoop) loopNode);\n            }\n            if (loopNode instanceof WhileLoop) {\n                nodeType = Token.WHILE;\n                cond = ((WhileLoop) loopNode).getCondition();\n            } else {\n                // Loop\n                nodeType = Token.FOR;\n                ForLoop forLoop = (ForLoop) loopNode;\n                if (forLoop.getInitializer() != null) {\n                    nodeType = Token.FOR_IN;\n                    cond = forLoop.getInitializer();\n                    nodeType = Token.FOR;\n                }\n                if (forLoop.getCondition() != null) {\n                    cond = forLoop.getCondition();\n                }\n            }\n\n            Node node = newNode(nodeType);\n            if (cond != null) {\n                node.addChildToBack(transform(cond));\n            } else {\n                node.addChildToBack(newNode(Token.EMPTY));\n            }\n            Node body = transformBlock(loopNode.getBody());\n            node.addChildToBack(body);\n\n            if (nodeType == Token.FOR) {\n                ForLoop forLoop = (ForLoop) loopNode;\n                Node init = transform(forLoop.getInitializer());\n                Node incr = transform(forLoop.getIncrement());\n                if (init != null) {\n                    node.addChildToFront(init);\n                }\n                if (incr != null) {\n                    node.addChildToBack(incr);\n                }\n            }\n            return node;\n        }\n\n        @Override\n        Node processNewExpression(NewExpression newExprNode) {\n            Node node = newNode(Token.NEW);\n            node.addChildToBack(transform(newExprNode.getTarget()));\n            if (newExprNode.getArguments() != null) {\n                for (AstNode arg : newExprNode.getArguments().getChildren()) {\n                    node.addChildToBack(transform(arg));\n                }\n            }\n            return node;\n        }\n\n        @Override\n        Node processForIn(ForInLoop loopNode) {\n            AstNode iterator = loopNode.getIterator();\n            Node iteratedObject = transform(loopNode.getIteratedObject());\n            Node body = transformBlock(loopNode.getBody());\n            Node newNode = newNode(Token.FOR_IN);\n            newNode.addChildToBack(transform(iterator));\n            newNode.addChildToBack(iteratedObject);\n            newNode.addChildToBack(body);\n            return newNode;\n        }\n    }\n\n    @Override\n    protected Node parse() throws IOException {\n        return new Transform(sourceURI).transform(parser.parse());\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..01dac25e 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,363 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory extends Parser {\n+    private final ErrorReporter errorReporter;\n+\n+    public IRFactory(ErrorReporter errorReporter) {\n+        this.errorReporter = errorReporter;\n+    }\n+\n+    abstract class TransformDispatcher implements NodeTransformer<Node> {\n+        @Override\n+        public Node transform(Node node) {\n+            switch (node.getType()) {\n+                case Token.BLOCK:\n+                    return processBlock((Block) node);\n+                case Token.BREAK:\n+                    return processBreakStatement((BreakStatement) node);\n+                case Token.CATCH:\n+                    return processCatchClause((CatchClause) node);\n+                case Token.HOOK:\n+                    return processConditionalExpression((ConditionalExpression) node);\n+                case Token.CONTINUE:\n+                    return processContinueStatement((ContinueStatement) node);\n+                case Token.DO:\n+                    return processDoLoop((DoLoop) node);\n+                case Token.GETELEM:\n+                    return processElementGet((ElementGet) node);\n+                case Token.EMPTY:\n+                    return processEmptyExpression((EmptyExpression) node);\n+                case Token.FOR:\n+                    return processForInLoop((ForInLoop) node);\n+                case Token.FOR_IN:\n+                    return processForIn((ForInLoop) node);\n+                case Token.IF:\n+                    return processIf((IfStatement) node);\n+                case Token.LABEL:\n+                    return processLabeledStatement((LabeledStatement) node);\n+                case Token.WHILE:\n+                    return processLoop((Loop) node);\n+                case Token.NEW:\n+                    return processNewExpression((NewExpression) node);\n+                case Token.DOT:\n+                case Token.NAME:\n+                case Token.FUNCTION:\n+                case Token.ARRAYLIT:\n+                case Token.OBJECTLIT:\n+                case Token.NUMBER:\n+                case Token.STRING:\n+                case Token.REGEXP:\n+                case Token.NULL:\n+                case Token.THIS:\n+                case Token.TRUE:\n+                case Token.FALSE:\n+                case Token.TRY:\n+                case Token.VAR:\n+                case Token.LET:\n+                case Token.CONST:\n+                case Token.WITH:\n+                case Token.SWITCH:\n+                case Token.CASE:\n+                case Token.DEFAULT:\n+                case Token.THROW:\n+                case Token.RETURN:\n+                case Token.INSTANCEOF:\n+                case Token.TYPEOF:\n+                case Token.DELETE:\n+                case Token.VOID:\n+                case Token.NOT:\n+                case Token.BITNOT:\n+                case Token.POS:\n+                case Token.NEG:\n+                case Token.HOOKCALL:\n+                case Token.ADD:\n+                case Token.SUB:\n+                case Token.MUL:\n+                case Token.DIV:\n+                case Token.MOD:\n+                case Token.SHEQ:\n+                case Token.SHNE:\n+                case Token.BITOR:\n+                case Token.BITXOR:\n+                case Token.BITAND:\n+                case Token.LSH:\n+                case Token.RSH:\n+                case Token.URSH:\n+                case Token.LT:\n+                case Token.LE:\n+                case Token.GT:\n+                case Token.GE:\n+                case Token.COMMA:\n+                case Token.OR:\n+                case Token.AND:\n+                case Token.INC:\n+                case Token.DEC:\n+                case Token.ASSIGN:\n+                case Token.ASSIGN_BITOR:\n+                case Token.ASSIGN_BITXOR:\n+                case Token.ASSIGN_BITAND:\n+                case Token.ASSIGN_LSH:\n+                case Token.ASSIGN_RSH:\n+                case Token.ASSIGN_URSH:\n+                case Token.ASSIGN_ADD:\n+                case Token.ASSIGN_SUB:\n+                case Token.ASSIGN_MUL:\n+                case Token.ASSIGN_DIV:\n+                case Token.ASSIGN_MOD:\n+                    return node;\n+                case Token.EXPR_RESULT:\n+                    return processExpressionStatement((ExpressionStatement) node);\n+                default:\n+                    errorReporter.fatalError(\"Unsupported node type: \" + node.getType(),\n+                            sourceURI,\n+                            node.getLineno(),\n+                            node.getCharno());\n+                    return new Node(Token.EMPTY);\n+            }\n+        }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+        abstract Node processBlock(Block blockNode);\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+        abstract Node processBreakStatement(BreakStatement statementNode);\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+        abstract Node processCatchClause(CatchClause clauseNode);\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n+        abstract Node processConditionalExpression(ConditionalExpression exprNode);\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+        abstract Node processContinueStatement(ContinueStatement statementNode);\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+        abstract Node processDoLoop(DoLoop loopNode);\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+        abstract Node processElementGet(ElementGet getNode);\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n+        abstract Node processEmptyExpression(EmptyExpression exprNode);\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+        abstract Node processExpressionStatement(ExpressionStatement statementNode);\n+\n+        abstract Node processForInLoop(ForInLoop loopNode);\n+\n+        abstract Node processIf(IfStatement ifNode);\n+\n+        abstract Node processLabeledStatement(LabeledStatement statementNode);\n+\n+        abstract Node processLoop(Loop loopNode);\n+\n+        abstract Node processNewExpression(NewExpression newExprNode);\n+\n+        abstract Node processForIn(ForInLoop loopNode);\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    class Transform extends TransformDispatcher {\n+        private final String sourceURI;\n+\n+        Transform(String sourceURI) {\n+            this.sourceURI = sourceURI;\n+        }\n+\n+        @Override\n+        Node processBlock(Block blockNode) {\n+            Node root = newNode(Token.BLOCK);\n+            for (Node kid : blockNode)\n+                root.addChildToBack(transform(kid));\n+            return root;\n+        }\n+\n+        @Override\n+        Node processBreakStatement(BreakStatement statementNode) {\n+            Node node = newNode(Token.BREAK);\n+            if (statementNode.getBreakLabel() != null) {\n+                Node labelName = transform(statementNode.getBreakLabel());\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        Node processCatchClause(CatchClause clauseNode) {\n+            AstNode catchVar = clauseNode.getVarName();\n+            Node node = newNode(Token.CATCH, transform(catchVar));\n+            if (clauseNode.getCatchCondition() != null) {\n+                errorReporter.error(\n+                        \"Catch clauses are not supported\",\n+                        sourceURI,\n+                        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+            }\n+            node.addChildToBack(transformBlock(clauseNode.getBody()));\n+            return node;\n+        }\n+\n+        @Override\n+        Node processConditionalExpression(ConditionalExpression exprNode) {\n+            return newNode(\n+                    Token.HOOK,\n+                    transform(exprNode.getTestExpression()),\n+                    transform(exprNode.getTrueExpression()),\n+                    transform(exprNode.getFalseExpression()));\n+        }\n+\n+        @Override\n+        Node processContinueStatement(ContinueStatement statementNode) {\n+            Node node = newNode(Token.CONTINUE);\n+            if (statementNode.getLabel() != null) {\n+                Node labelName = transform(statementNode.getLabel());\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        Node processDoLoop(DoLoop loopNode) {\n+            return newNode(\n+                    Token.DO,\n+                    transformBlock(loopNode.getBody()),\n+                    transform(loopNode.getCondition()));\n+        }\n+\n+        @Override\n+        Node processElementGet(ElementGet getNode) {\n+            return newNode(\n+                    Token.GETELEM,\n+                    transform(getNode.getTarget()),\n+                    transform(getNode.getElement()));\n+        }\n+\n+        @Override\n+        Node processEmptyExpression(EmptyExpression exprNode) {\n+            Node node = newNode(Token.EMPTY);\n+            return node;\n+        }\n+\n+        @Override\n+        Node processExpressionStatement(ExpressionStatement statementNode) {\n+            Node node = newNode(Token.EXPR_RESULT);\n+            node.addChildToBack(transform(statementNode.getExpression()));\n+            return node;\n+        }\n+\n+        @Override\n+        Node processForInLoop(ForInLoop loopNode) {\n+            AstNode iterator = loopNode.getIterator();\n+            Node iteratedObject = transform(loopNode.getIteratedObject());\n+            Node body = transformBlock(loopNode.getBody());\n+            Node newNode;\n+            if (iterator instanceof Name || iterator instanceof KeywordLiteral) {\n+                newNode = newNode(Token.FOR);\n+                newNode.addChildToBack(transform(iterator));\n+                newNode.addChildToBack(iteratedObject);\n+                newNode.addChildToBack(body);\n+            } else {\n+                // Error: Invalid left-hand side in for-in loop\n+                errorReporter.error(\n+                        \"Invalid left-hand side in for-in loop\",\n+                        sourceURI,\n+                        iterator.getLineno(), \"\", 0);\n+                newNode = new Node(Token.EMPTY);\n+            }\n+            return newNode;\n+        }\n+\n+        @Override\n+        Node processIf(IfStatement ifNode) {\n+            Node node =\n+                    newNode(\n+                            Token.IF,\n+                            transform(ifNode.getCondition()),\n+                            transformBlock(ifNode.getThenPart()));\n+            if (ifNode.getElsePart() != null) {\n+                node.addChildToBack(transformBlock(ifNode.getElsePart()));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        Node processLabeledStatement(LabeledStatement statementNode) {\n+            return newNode(\n+                    Token.LABEL,\n+                    transform(statementNode.getLabel()),\n+                    transform(statementNode.getStatement()));\n+        }\n+\n+        @Override\n+        Node processLoop(Loop loopNode) {\n+            int nodeType;\n+            AstNode cond = null;\n+            // transform headers other than For and For...in:\n+            if (loopNode instanceof ForInLoop) {\n+                return processForIn((ForInLoop) loopNode);\n+            }\n+            if (loopNode instanceof WhileLoop) {\n+                nodeType = Token.WHILE;\n+                cond = ((WhileLoop) loopNode).getCondition();\n+            } else {\n+                // Loop\n+                nodeType = Token.FOR;\n+                ForLoop forLoop = (ForLoop) loopNode;\n+                if (forLoop.getInitializer() != null) {\n+                    nodeType = Token.FOR_IN;\n+                    cond = forLoop.getInitializer();\n+                    nodeType = Token.FOR;\n+                }\n+                if (forLoop.getCondition() != null) {\n+                    cond = forLoop.getCondition();\n+                }\n+            }\n+\n+            Node node = newNode(nodeType);\n+            if (cond != null) {\n+                node.addChildToBack(transform(cond));\n+            } else {\n+                node.addChildToBack(newNode(Token.EMPTY));\n+            }\n+            Node body = transformBlock(loopNode.getBody());\n+            node.addChildToBack(body);\n+\n+            if (nodeType == Token.FOR) {\n+                ForLoop forLoop = (ForLoop) loopNode;\n+                Node init = transform(forLoop.getInitializer());\n+                Node incr = transform(forLoop.getIncrement());\n+                if (init != null) {\n+                    node.addChildToFront(init);\n+                }\n+                if (incr != null) {\n+                    node.addChildToBack(incr);\n+                }\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        Node processNewExpression(NewExpression newExprNode) {\n+            Node node = newNode(Token.NEW);\n+            node.addChildToBack(transform(newExprNode.getTarget()));\n+            if (newExprNode.getArguments() != null) {\n+                for (AstNode arg : newExprNode.getArguments().getChildren()) {\n+                    node.addChildToBack(transform(arg));\n+                }\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        Node processForIn(ForInLoop loopNode) {\n+            AstNode iterator = loopNode.getIterator();\n+            Node iteratedObject = transform(loopNode.getIteratedObject());\n+            Node body = transformBlock(loopNode.getBody());\n+            Node newNode = newNode(Token.FOR_IN);\n+            newNode.addChildToBack(transform(iterator));\n+            newNode.addChildToBack(iteratedObject);\n+            newNode.addChildToBack(body);\n+            return newNode;\n+        }\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-\n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    protected Node parse() throws IOException {\n+        return new Transform(sourceURI).transform(parser.parse());\n     }\n+}\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: class IRFactory is already defined in package com.google.javascript.jscomp.parsing",
    "test_result": "ERROR"
}