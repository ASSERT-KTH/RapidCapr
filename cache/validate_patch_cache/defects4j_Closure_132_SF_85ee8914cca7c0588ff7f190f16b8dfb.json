{
    "patch": "private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n    Node cond = n.getFirstChild();\n\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      // if (true) { ... } => { ... }\n      // if (false) { ... } => undefined\n      boolean value = NodeUtil.getBooleanValue(cond);\n      Node replacement = value ? n.removeFirstChild() : IR.undefined();\n      parent.replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, Token.OR)) {\n            Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n            parent.replaceChild(n, NodeUtil.newExpr(or));\n            reportCodeChange();\n            return or;\n          }\n        } else {\n          // if(x)foo(); -> x&&foo();\n          if (isLowerPrecedenceInExpression(cond, Token.AND)) {\n            Node and = IR.and(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n            parent.replaceChild(n, NodeUtil.newExpr(and));\n            reportCodeChange();\n            return and;\n          }\n        }\n\n        return n;\n      } else if (thenBranch.hasOneChild() && thenBranch.getFirstChild().isIf()) {\n        Node innerIf = thenBranch.getFirstChild();\n        Node innerCond = innerIf.getFirstChild();\n        Node innerThenBranch = innerCond.getNext();\n        Node innerElseBranch = innerThenBranch.getNext();\n\n        if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, Token.AND) && isLowerPrecedenceInExpression(innerCond, Token.AND))) {\n          // if (a) { if (b) { c(); } } => if (a && b) { c(); }\n          // if (a) { if (!b) { c(); } } => if (a && !b) { undefined; } else { c(); }\n          n.detachChildren();\n          n.addChildToBack(IR.and(cond.detachFromParent(), innerCond.detachFromParent()));\n          n.addChildrenToBack(innerThenBranch.detachFromParent());\n          if (innerCond.isNot()) {\n            // if (a) { if (!b) { c(); } } => if (a && !b) { undefined; } else { c(); }\n            n.addChildToBack(\n                n.isStatement() ? IR.block().srcref(innerElseBranch) : IR.undefined().srcref(innerElseBranch));\n            innerElseBranch.detachChildren();\n          }\n          reportCodeChange();\n          return n;\n        }\n      }\n\n      return n;\n    }\n\n    tryRemoveRepeatedStatements(n);\n\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      // if (!x) { foo(); } else { bar(); } => if (x) { bar(); } else { foo(); }\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n    }\n\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      // if (x) { return foo(); } else { return bar(); } => return x ? foo() : bar();\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n      Node replacement = IR.returnNode(hookNode).srcref(n);\n      parent.replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n            // if (x) { a = 1; } else { a = 2; } => a = x ? 1 : 2;\n            Node assignName = thenOp.removeFirstChild();\n            Node thenExpr = thenOp.removeFirstChild();\n            Node elseExpr = elseOp.getLastChild().detachFromParent();\n            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n            Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n            Node replacement = NodeUtil.newExpr(assign);\n            parent.replaceChild(n, replacement);\n            reportCodeChange();\n            return replacement;\n          }\n        }\n      }\n\n      // if (x) { foo(); } else { bar(); } => x ? foo() : bar();\n      Node thenOp = getBlockExpression(thenBranch).removeFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).removeFirstChild();\n      Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n      Node replacement = NodeUtil.newExpr(hookNode);\n      parent.replaceChild(n, replacement);\n      reportCodeChange();\n      return replacement;\n    }\n\n    boolean thenBranchIsVar = isVarBlock(thenBranch);\n    boolean elseBranchIsVar = isVarBlock(elseBranch);\n\n    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n      // if (x) { var y = 1; } else { y = 2; } => var y = x ? 1 : 2;\n      Node var = getBlockVar(thenBranch);\n      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n      Node name1 = var.getFirstChild();\n      Node maybeName2 = elseAssign.getFirstChild();\n      if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n        Node thenExpr = name1.removeChildren();\n        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node replacement = IR.var(name1.detachFromParent(), hookNode).srcref(n);\n        parent.replaceChild(n, replacement);\n        reportCodeChange();\n        return replacement;\n      }\n    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n      // if (x) { y = 1; } else { var y = 2; } => var y = x ? 1 : 2;\n      Node var = getBlockVar(elseBranch);\n      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n      Node maybeName1 = thenAssign.getFirstChild();\n      Node name2 = var.getFirstChild();\n      if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n        Node elseExpr = name2.removeChildren();\n        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n        Node replacement = IR.var(name2.detachFromParent(), hookNode).srcref(n);\n        parent.replaceChild(n, replacement);\n        reportCodeChange();\n        return replacement;\n      }\n    }\n\n    return n;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..557da59c 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -633,17 +633,19 @@ class PeepholeSubstituteAlternateSyntax\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n-  private Node tryMinimizeIf(Node n) {\n+private Node tryMinimizeIf(Node n) {\n \n     Node parent = n.getParent();\n-\n     Node cond = n.getFirstChild();\n \n-    /* If the condition is a literal, we'll let other\n-     * optimizations try to remove useless code.\n-     */\n     if (NodeUtil.isLiteralValue(cond, true)) {\n-      return n;\n+      // if (true) { ... } => { ... }\n+      // if (false) { ... } => undefined\n+      boolean value = NodeUtil.getBooleanValue(cond);\n+      Node replacement = value ? n.removeFirstChild() : IR.undefined();\n+      parent.replaceChild(n, replacement);\n+      reportCodeChange();\n+      return replacement;\n     }\n \n     Node thenBranch = cond.getNext();\n@@ -661,83 +663,53 @@ class PeepholeSubstituteAlternateSyntax\n \n         if (cond.isNot()) {\n           // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n-            return n;\n+          if (isLowerPrecedenceInExpression(cond, Token.OR)) {\n+            Node or = IR.or(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n+            parent.replaceChild(n, NodeUtil.newExpr(or));\n+            reportCodeChange();\n+            return or;\n+          }\n+        } else {\n+          // if(x)foo(); -> x&&foo();\n+          if (isLowerPrecedenceInExpression(cond, Token.AND)) {\n+            Node and = IR.and(cond.removeFirstChild(), expr.removeFirstChild()).srcref(n);\n+            parent.replaceChild(n, NodeUtil.newExpr(and));\n+            reportCodeChange();\n+            return and;\n           }\n-\n-          Node or = IR.or(\n-              cond.removeFirstChild(),\n-              expr.removeFirstChild()).srcref(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          reportCodeChange();\n-\n-          return newExpr;\n-        }\n-\n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses is worth the change even if\n-          // there is no immediate code size win. However, two extra pair of\n-          // {}, we would have to think twice. (unless we know for sure the\n-          // we can further optimize its parent.\n-          return n;\n         }\n \n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n-        reportCodeChange();\n-\n-        return newExpr;\n-      } else {\n-\n-        // Try to combine two IF-ELSE\n-        if (NodeUtil.isStatementBlock(thenBranch) &&\n-            thenBranch.hasOneChild()) {\n-          Node innerIf = thenBranch.getFirstChild();\n-\n-          if (innerIf.isIf()) {\n-            Node innerCond = innerIf.getFirstChild();\n-            Node innerThenBranch = innerCond.getNext();\n-            Node innerElseBranch = innerThenBranch.getNext();\n-\n-            if (innerElseBranch == null &&\n-                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n-              n.detachChildren();\n-              n.addChildToBack(\n-                  IR.and(\n-                      cond,\n-                      innerCond.detachFromParent())\n-                      .srcref(cond));\n-              n.addChildrenToBack(innerThenBranch.detachFromParent());\n-              reportCodeChange();\n-              // Not worth trying to fold the current IF-ELSE into && because\n-              // the inner IF-ELSE wasn't able to be folded into && anyways.\n-              return n;\n-            }\n+        return n;\n+      } else if (thenBranch.hasOneChild() && thenBranch.getFirstChild().isIf()) {\n+        Node innerIf = thenBranch.getFirstChild();\n+        Node innerCond = innerIf.getFirstChild();\n+        Node innerThenBranch = innerCond.getNext();\n+        Node innerElseBranch = innerThenBranch.getNext();\n+\n+        if (innerElseBranch == null && !(isLowerPrecedenceInExpression(cond, Token.AND) && isLowerPrecedenceInExpression(innerCond, Token.AND))) {\n+          // if (a) { if (b) { c(); } } => if (a && b) { c(); }\n+          // if (a) { if (!b) { c(); } } => if (a && !b) { undefined; } else { c(); }\n+          n.detachChildren();\n+          n.addChildToBack(IR.and(cond.detachFromParent(), innerCond.detachFromParent()));\n+          n.addChildrenToBack(innerThenBranch.detachFromParent());\n+          if (innerCond.isNot()) {\n+            // if (a) { if (!b) { c(); } } => if (a && !b) { undefined; } else { c(); }\n+            n.addChildToBack(\n+                n.isStatement() ? IR.block().srcref(innerElseBranch) : IR.undefined().srcref(innerElseBranch));\n+            innerElseBranch.detachChildren();\n           }\n+          reportCodeChange();\n+          return n;\n         }\n       }\n \n       return n;\n     }\n \n-    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n-     * peephole optimization. This should probably get moved to another pass.\n-     */\n     tryRemoveRepeatedStatements(n);\n \n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n     if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n+      // if (!x) { foo(); } else { bar(); } => if (x) { bar(); } else { foo(); }\n       n.replaceChild(cond, cond.removeFirstChild());\n       n.removeChild(thenBranch);\n       n.addChildToBack(thenBranch);\n@@ -745,23 +717,15 @@ class PeepholeSubstituteAlternateSyntax\n       return n;\n     }\n \n-    // if(x)return 1;else return 2; -> return x?1:2;\n     if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n+      // if (x) { return foo(); } else { return bar(); } => return x ? foo() : bar();\n       Node thenExpr = getBlockReturnExpression(thenBranch);\n       Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n-                                .srcref(n));\n-      parent.replaceChild(n, returnNode);\n+      Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+      Node replacement = IR.returnNode(hookNode).srcref(n);\n+      parent.replaceChild(n, replacement);\n       reportCodeChange();\n-      return returnNode;\n+      return replacement;\n     }\n \n     boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n@@ -771,101 +735,70 @@ class PeepholeSubstituteAlternateSyntax\n       Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n       Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n       if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n         if (NodeUtil.isAssignmentOp(thenOp)) {\n           Node lhs = thenOp.getFirstChild();\n-          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n+          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) && !mayEffectMutableState(lhs)) {\n+            // if (x) { a = 1; } else { a = 2; } => a = x ? 1 : 2;\n             Node assignName = thenOp.removeFirstChild();\n             Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n+            Node elseExpr = elseOp.getLastChild().detachFromParent();\n             Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n+            Node assign = new Node(thenOp.getType(), assignName, hookNode).srcref(thenOp);\n+            Node replacement = NodeUtil.newExpr(assign);\n+            parent.replaceChild(n, replacement);\n             reportCodeChange();\n-\n-            return expr;\n+            return replacement;\n           }\n         }\n       }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n+\n+      // if (x) { foo(); } else { bar(); } => x ? foo() : bar();\n+      Node thenOp = getBlockExpression(thenBranch).removeFirstChild();\n+      Node elseOp = getBlockExpression(elseBranch).removeFirstChild();\n+      Node hookNode = IR.hook(cond, thenOp, elseOp).srcref(n);\n+      Node replacement = NodeUtil.newExpr(hookNode);\n+      parent.replaceChild(n, replacement);\n       reportCodeChange();\n-      return expr;\n+      return replacement;\n     }\n \n     boolean thenBranchIsVar = isVarBlock(thenBranch);\n     boolean elseBranchIsVar = isVarBlock(elseBranch);\n \n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n+    if (thenBranchIsVar && elseBranchIsExpressionBlock && getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n+      // if (x) { var y = 1; } else { y = 2; } => var y = x ? 1 : 2;\n       Node var = getBlockVar(thenBranch);\n       Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n       Node name1 = var.getFirstChild();\n       Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n+      if (name1.hasChildren() && maybeName2.isName() && name1.getString().equals(maybeName2.getString())) {\n         Node thenExpr = name1.removeChildren();\n         Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node replacement = IR.var(name1.detachFromParent(), hookNode).srcref(n);\n+        parent.replaceChild(n, replacement);\n         reportCodeChange();\n-        return var;\n+        return replacement;\n       }\n-\n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n+    } else if (elseBranchIsVar && thenBranchIsExpressionBlock && getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n+      // if (x) { y = 1; } else { var y = 2; } => var y = x ? 1 : 2;\n       Node var = getBlockVar(elseBranch);\n       Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n       Node maybeName1 = thenAssign.getFirstChild();\n       Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n+      if (name2.hasChildren() && maybeName1.isName() && maybeName1.getString().equals(name2.getString())) {\n         Node thenExpr = thenAssign.getLastChild().detachFromParent();\n         Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n+        Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+        Node replacement = IR.var(name2.detachFromParent(), hookNode).srcref(n);\n+        parent.replaceChild(n, replacement);\n         reportCodeChange();\n-\n-        return var;\n+        return replacement;\n       }\n     }\n \n     return n;\n-  }\n+}\n \n   /**\n    * Try to remove duplicate statements from IF blocks. For example:",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}