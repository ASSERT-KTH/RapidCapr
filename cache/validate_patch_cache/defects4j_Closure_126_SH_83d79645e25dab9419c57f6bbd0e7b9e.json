{
    "patch": "      if (NodeUtil.hasFinally(n)) {\n        Node finallyBlock = n.getLastChild();\n        Node nextNode = finallyBlock.getNext();\n        if (nextNode != null) {\n          if (nextNode.isBlock() && nextNode.getFirstChild() != null) {\n            tryMinimizeExits(nextNode.getFirstChild(), exitType, labelName);\n          } else {\n            tryMinimizeExits(nextNode, exitType, labelName);\n          }\n        }\n        /* Don't try to minimize the exits of finally blocks, as this\n         * can cause problems if it changes the completion type of the finally\n         * block. See ECMA 262 Sections 8.9 & 12.14\n         */\n      } else {\n        NodeUtil.visitPreOrder(n.getNext(), new Node.Util.NodeVisitor() {\n          @Override\n          public void visit(Node nextNode) {\n            if (nextNode.isBlock() && nextNode.getFirstChild() != null) {\n              tryMinimizeExits(nextNode.getFirstChild(), exitType, labelName);\n            } else {\n              tryMinimizeExits(nextNode, exitType, labelName);\n            }\n          }\n        });",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/MinimizeExitPoints.java b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\nindex 4146f177..df80b1f5 100644\n--- a/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n+++ b/src/com/google/javascript/jscomp/MinimizeExitPoints.java\n@@ -140,8 +140,29 @@ class MinimizeExitPoints\n        */\n       if (NodeUtil.hasFinally(n)) {\n         Node finallyBlock = n.getLastChild();\n-        tryMinimizeExits(finallyBlock, exitType, labelName);\n-      }\n+        Node nextNode = finallyBlock.getNext();\n+        if (nextNode != null) {\n+          if (nextNode.isBlock() && nextNode.getFirstChild() != null) {\n+            tryMinimizeExits(nextNode.getFirstChild(), exitType, labelName);\n+          } else {\n+            tryMinimizeExits(nextNode, exitType, labelName);\n+          }\n+        }\n+        /* Don't try to minimize the exits of finally blocks, as this\n+         * can cause problems if it changes the completion type of the finally\n+         * block. See ECMA 262 Sections 8.9 & 12.14\n+         */\n+      } else {\n+        NodeUtil.visitPreOrder(n.getNext(), new Node.Util.NodeVisitor() {\n+          @Override\n+          public void visit(Node nextNode) {\n+            if (nextNode.isBlock() && nextNode.getFirstChild() != null) {\n+              tryMinimizeExits(nextNode.getFirstChild(), exitType, labelName);\n+            } else {\n+              tryMinimizeExits(nextNode, exitType, labelName);\n+            }\n+          }\n+        });\n     }\n \n     // Just a 'label'.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}