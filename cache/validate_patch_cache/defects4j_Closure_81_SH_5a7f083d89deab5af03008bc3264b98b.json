{
    "patch": "Boolean isUnnamedFunction = false;\nName name = functionNode.getFunctionName();\nif (name == null) {\n  ITable symtab = NodeUtil.getEnclosingScope(functionNode);\n  int functionIndex = NodeUtil.getFunctionIndex(functionNode);\n  StringBuilder sb = new StringBuilder();\n  sb.append(symtab.getScope().replace('.', '_'));\n  sb.append(\"_\");\n\n  if (functionNode.getLineno() != -1 && functionIndex != -1) {\n    sb.append(functionNode.getLineno());\n    sb.append(\"_\");\n    sb.append(functionIndex);\n  } else {\n    // If we have no line number and no index, create a name based on the\n    // parent function name.\n    sb.append(\"_\");\n    sb.append(NodeUtil.getEnclosingFunctionName(functionNode).getIdentifier());\n    sb.append(\"_anonymous_\");\n  }\n\n  name = new Name();\n  name.setIdentifier(sb.toString());\n  name.setParent(functionNode);\n  isUnnamedFunction = true;\n}\n\nNode node = newNode(Token.FUNCTION);\nNode newName = transform(name);\nif (isUnnamedFunction) {\n  newName.putProp(Node.ORIGINALNAME_PROP, \"\");\n  newName.setLineno(functionNode.getLineno());\n  newName.setCharno(position2charno(functionNode.getDefiningToken().getAbsolutePosition()));\n}\n\nnode.addChildToBack(newName);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..f0e03c99 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,6 +514,42 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+Boolean isUnnamedFunction = false;\n+Name name = functionNode.getFunctionName();\n+if (name == null) {\n+  ITable symtab = NodeUtil.getEnclosingScope(functionNode);\n+  int functionIndex = NodeUtil.getFunctionIndex(functionNode);\n+  StringBuilder sb = new StringBuilder();\n+  sb.append(symtab.getScope().replace('.', '_'));\n+  sb.append(\"_\");\n+\n+  if (functionNode.getLineno() != -1 && functionIndex != -1) {\n+    sb.append(functionNode.getLineno());\n+    sb.append(\"_\");\n+    sb.append(functionIndex);\n+  } else {\n+    // If we have no line number and no index, create a name based on the\n+    // parent function name.\n+    sb.append(\"_\");\n+    sb.append(NodeUtil.getEnclosingFunctionName(functionNode).getIdentifier());\n+    sb.append(\"_anonymous_\");\n+  }\n+\n+  name = new Name();\n+  name.setIdentifier(sb.toString());\n+  name.setParent(functionNode);\n+  isUnnamedFunction = true;\n+}\n+\n+Node node = newNode(Token.FUNCTION);\n+Node newName = transform(name);\n+if (isUnnamedFunction) {\n+  newName.putProp(Node.ORIGINALNAME_PROP, \"\");\n+  newName.setLineno(functionNode.getLineno());\n+  newName.setCharno(position2charno(functionNode.getDefiningToken().getAbsolutePosition()));\n+}\n+\n+node.addChildToBack(newName);\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;",
    "result_reason": "error: variable isUnnamedFunction is already defined in method processFunctionNode(FunctionNode)",
    "test_result": "ERROR"
}