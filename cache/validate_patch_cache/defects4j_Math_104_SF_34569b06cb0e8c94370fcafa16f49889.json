{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.Precision;\n\npublic class GammaRegularized {\n\n    public static double regularizedGamma(double a, double x) {\n\n        if (Double.isNaN(a) || Double.isNaN(x)) {\n            return Double.NaN;\n        }\n        if (Double.isInfinite(a) || Double.isInfinite(x) || (a <= 0.0)) {\n            return Double.NaN;\n        }\n\n        if (x < 0.0) {\n            return Double.NaN;\n        }\n\n        if (x == 0.0) {\n            return 0.0;\n        }\n\n        if (x >= (a + 1.0)) {\n            return 1.0 - regularizedGammaComplement(a, x);\n        }\n\n        double p0 = 0.0;\n        double q0 = 1.0;\n        double p1 = 1.0;\n        double q1 = 1.0;\n        double p2 = x;\n        double q2 = a;\n        double ans = p1 / q1;\n\n        double error;\n\n        do {\n            error = Math.abs((ans - p0 / q0) / ans);\n            p0 = p1;\n            p1 = p2;\n            q0 = q1;\n            q1 = q2;\n\n            p2 = x * p1 + a * p0;\n            q2 = x * q1 + a * q0;\n\n            if (q2 != 0) {\n\n                double next = p2 / q2;\n\n                if (Precision.equals(ans, next, 1.0e-15)) {\n                    break;\n                }\n\n                ans = next;\n            }\n\n        } while (error > 1.0e-15);\n\n        return ans;\n    }\n\n    public static double regularizedGammaComplement(final double a, final double x) {\n        final double ret;\n        if (Double.isNaN(a) || Double.isNaN(x) || x < 0 || a <= 0) {\n            ret = Double.NaN;\n        } else if (FastMath.floor(a) == a) { // degenerate case : Bernstein polynomial is a polynomial of one variable\n            ret = Gamma.regularizedGammaQ((int) a, x);\n        } else if (x == 0) {\n            ret = 1d;\n        } else if (x < a + 1) {\n            // compute series\n            double n = 0;\n            double an = 1 / (a + n);\n            double sum = an;\n            while (FastMath.abs(an/sum) > Precision.EPSILON) {\n                n++;\n                an *= x / (a + n);\n                sum += an;\n            }\n            ret = FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * sum / a;\n        } else {\n            // compute continued fraction\n            final double b = x + 1 - a;\n            double c = 1 / Precision.EPSILON;\n            double d = 1 / b;\n            double h = d;\n            double an = 0;\n            double del = 0;\n            while (FastMath.abs(d - an) > (Precision.EPSILON * FastMath.abs(d))) {\n                an++;\n                double delta = an * (a - an);\n                b += 2;\n                d = delta * d + b;\n                if (d < Precision.EPSILON) {\n                    d = Precision.EPSILON;\n                }\n                c = b + delta / c;\n                if (c < Precision.EPSILON) {\n                    c = Precision.EPSILON;\n                }\n                d = 1 / d;\n                del = d * c * del;\n                h *= del;\n                if (Double.isInfinite(h)) {\n                    throw new ArithmeticException(\"Gamma overflow\");\n                }\n            }\n            ret = 1 - FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * h;\n        }\n        return ret;\n    }\n\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..d2df37b56 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,122 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.Precision;\n+\n+public class GammaRegularized {\n+\n+    public static double regularizedGamma(double a, double x) {\n+\n+        if (Double.isNaN(a) || Double.isNaN(x)) {\n+            return Double.NaN;\n+        }\n+        if (Double.isInfinite(a) || Double.isInfinite(x) || (a <= 0.0)) {\n+            return Double.NaN;\n+        }\n+\n+        if (x < 0.0) {\n+            return Double.NaN;\n+        }\n+\n+        if (x == 0.0) {\n+            return 0.0;\n+        }\n+\n+        if (x >= (a + 1.0)) {\n+            return 1.0 - regularizedGammaComplement(a, x);\n+        }\n+\n+        double p0 = 0.0;\n+        double q0 = 1.0;\n+        double p1 = 1.0;\n+        double q1 = 1.0;\n+        double p2 = x;\n+        double q2 = a;\n+        double ans = p1 / q1;\n+\n+        double error;\n+\n+        do {\n+            error = Math.abs((ans - p0 / q0) / ans);\n+            p0 = p1;\n+            p1 = p2;\n+            q0 = q1;\n+            q1 = q2;\n+\n+            p2 = x * p1 + a * p0;\n+            q2 = x * q1 + a * q0;\n+\n+            if (q2 != 0) {\n+\n+                double next = p2 / q2;\n+\n+                if (Precision.equals(ans, next, 1.0e-15)) {\n+                    break;\n+                }\n+\n+                ans = next;\n+            }\n+\n+        } while (error > 1.0e-15);\n+\n+        return ans;\n+    }\n+\n+    public static double regularizedGammaComplement(final double a, final double x) {\n+        final double ret;\n+        if (Double.isNaN(a) || Double.isNaN(x) || x < 0 || a <= 0) {\n+            ret = Double.NaN;\n+        } else if (FastMath.floor(a) == a) { // degenerate case : Bernstein polynomial is a polynomial of one variable\n+            ret = Gamma.regularizedGammaQ((int) a, x);\n+        } else if (x == 0) {\n+            ret = 1d;\n+        } else if (x < a + 1) {\n+            // compute series\n+            double n = 0;\n+            double an = 1 / (a + n);\n+            double sum = an;\n+            while (FastMath.abs(an/sum) > Precision.EPSILON) {\n+                n++;\n+                an *= x / (a + n);\n+                sum += an;\n+            }\n+            ret = FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * sum / a;\n+        } else {\n+            // compute continued fraction\n+            final double b = x + 1 - a;\n+            double c = 1 / Precision.EPSILON;\n+            double d = 1 / b;\n+            double h = d;\n+            double an = 0;\n+            double del = 0;\n+            while (FastMath.abs(d - an) > (Precision.EPSILON * FastMath.abs(d))) {\n+                an++;\n+                double delta = an * (a - an);\n+                b += 2;\n+                d = delta * d + b;\n+                if (d < Precision.EPSILON) {\n+                    d = Precision.EPSILON;\n+                }\n+                c = b + delta / c;\n+                if (c < Precision.EPSILON) {\n+                    c = Precision.EPSILON;\n+                }\n+                d = 1 / d;\n+                del = d * c * del;\n+                h *= del;\n+                if (Double.isInfinite(h)) {\n+                    throw new ArithmeticException(\"Gamma overflow\");\n+                }\n+            }\n+            ret = 1 - FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a)) * h;\n+        }\n+        return ret;\n+    }\n+\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}