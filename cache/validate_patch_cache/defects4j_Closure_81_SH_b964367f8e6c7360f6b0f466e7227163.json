{
    "patch": "        Node labelName = newNode(Token.LABEL_NAME, createName(statementNode.getBreakLabel()));\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processCatchClause(CatchClause clauseNode) {\n      AstNode catchVar = clauseNode.getVarName();\n      Node node = newNode(Token.CATCH, transform(catchVar));\n      if (clauseNode.getCatchCondition() != null) {\n        errorReporter.error(\n            \"Catch clauses are not supported\",\n            sourceName,\n            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n      }\n      node.addChildToBack(transformBlock(clauseNode.getBody()));\n      return node;\n    }\n\n    @Override\n    Node processConditionalExpression(ConditionalExpression exprNode) {\n      return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression())\n      );\n    }\n\n    @Override\n    Node processContinueStatement(ContinueStatement statementNode) {\n      Node node = newNode(Token.CONTINUE);\n      if (statementNode.getLabel() != null) {\n        Node labelName = newNode(Token.LABEL_NAME, createName(statementNode.getLabel()));\n        node.addChildToBack(labelName);\n      }\n      return node;\n    }\n\n    @Override\n    Node processDoLoop(DoLoop loopNode) {\n      return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition())\n      );\n    }\n\n    @Override\n    Node processElementGet(ElementGet getNode) {\n      return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement())\n      );\n    }\n\n    @Override\n    Node processEmptyExpression(EmptyExpression exprNode) {\n      Node node = newNode(Token.EMPTY);\n      return node;\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statementNode) {\n      Node node = newNode(transformTokenType(statementNode.getType()));\n      node.addChildToBack(transform(statementNode.getExpression()));\n      return node;\n    }\n\n    @Override\n    Node processForInLoop(ForInLoop loopNode) {\n      return newNode(\n        Token.FOR,\n        transform(loopNode.getIterator()),\n        transform(loopNode.getIteratedObject()),\n        transformBlock(loopNode.getBody())\n      );\n    }\n\n    @Override\n    Node processForLoop(ForLoop loopNode) {\n      Node node = newNode(\n        Token.FOR,\n        transform(loopNode.getInitializer()),\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement())\n      );\n      node.addChildToBack(transformBlock(loopNode.getBody()));\n      return node;\n    }\n\n    @Override\n    Node processFunctionCall(FunctionCall callNode) {\n      Node node = newNode(\n        transformTokenType(callNode.getType()),\n        transform(callNode.getTarget())\n      );\n      for (AstNode child : callNode.getArguments()) {\n        node.addChildToBack(transform(child));\n      }\n\n      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n      node.setLineno(callNode.getLineno());\n      node.setCharno(position2charno(leftParamPos));\n      return node;\n    }\n\n    @Override\n    Node processFunctionNode(FunctionNode functionNode) {\n      Name name = functionNode.getFunctionName();\n      Boolean isUnnamedFunction = false;\n      if (name == null) {\n        name = createName(\"\");\n        isUnnamedFunction = true;\n      }\n      Node node = newNode(Token.FUNCTION);\n      Node newName = transform(name);\n      if (isUnnamedFunction) {\n        newName.setLineno(functionNode.getLineno());\n        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n        newName.setCharno(position2charno(lpColumn));\n      }\n\n      node.addChildToBack(newName);\n      Node lp = newNode(Token.LP);\n      Name fnName = functionNode.getFunctionName();\n      if (fnName != null) {\n        lp.setLineno(fnName.getLineno());\n      } else {\n        lp.setLineno(functionNode.getLineno());\n      }\n      int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n\n      lp.setCharno(position2charno(lparenCharno));\n      for (AstNode param : functionNode.getParams()) {\n        lp.addChildToBack(transform(param));\n      }\n      node.addChildToBack(lp);\n\n      Node bodyNode = transform(functionNode.getBody());\n      parseDirectives(bodyNode);\n      node.addChildToBack(bodyNode);\n      return node;\n    }\n\n    private String createName(String label) {\n      return label == null ? \"\" : label;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..fc2d53ab 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -514,6 +514,155 @@ public class IRFactory {\n       Name name = functionNode.getFunctionName();\n       Boolean isUnnamedFunction = false;\n       if (name == null) {\n+        Node labelName = newNode(Token.LABEL_NAME, createName(statementNode.getBreakLabel()));\n+        node.addChildToBack(labelName);\n+      }\n+      return node;\n+    }\n+\n+    @Override\n+    Node processCatchClause(CatchClause clauseNode) {\n+      AstNode catchVar = clauseNode.getVarName();\n+      Node node = newNode(Token.CATCH, transform(catchVar));\n+      if (clauseNode.getCatchCondition() != null) {\n+        errorReporter.error(\n+            \"Catch clauses are not supported\",\n+            sourceName,\n+            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+      }\n+      node.addChildToBack(transformBlock(clauseNode.getBody()));\n+      return node;\n+    }\n+\n+    @Override\n+    Node processConditionalExpression(ConditionalExpression exprNode) {\n+      return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression())\n+      );\n+    }\n+\n+    @Override\n+    Node processContinueStatement(ContinueStatement statementNode) {\n+      Node node = newNode(Token.CONTINUE);\n+      if (statementNode.getLabel() != null) {\n+        Node labelName = newNode(Token.LABEL_NAME, createName(statementNode.getLabel()));\n+        node.addChildToBack(labelName);\n+      }\n+      return node;\n+    }\n+\n+    @Override\n+    Node processDoLoop(DoLoop loopNode) {\n+      return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition())\n+      );\n+    }\n+\n+    @Override\n+    Node processElementGet(ElementGet getNode) {\n+      return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement())\n+      );\n+    }\n+\n+    @Override\n+    Node processEmptyExpression(EmptyExpression exprNode) {\n+      Node node = newNode(Token.EMPTY);\n+      return node;\n+    }\n+\n+    @Override\n+    Node processExpressionStatement(ExpressionStatement statementNode) {\n+      Node node = newNode(transformTokenType(statementNode.getType()));\n+      node.addChildToBack(transform(statementNode.getExpression()));\n+      return node;\n+    }\n+\n+    @Override\n+    Node processForInLoop(ForInLoop loopNode) {\n+      return newNode(\n+        Token.FOR,\n+        transform(loopNode.getIterator()),\n+        transform(loopNode.getIteratedObject()),\n+        transformBlock(loopNode.getBody())\n+      );\n+    }\n+\n+    @Override\n+    Node processForLoop(ForLoop loopNode) {\n+      Node node = newNode(\n+        Token.FOR,\n+        transform(loopNode.getInitializer()),\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement())\n+      );\n+      node.addChildToBack(transformBlock(loopNode.getBody()));\n+      return node;\n+    }\n+\n+    @Override\n+    Node processFunctionCall(FunctionCall callNode) {\n+      Node node = newNode(\n+        transformTokenType(callNode.getType()),\n+        transform(callNode.getTarget())\n+      );\n+      for (AstNode child : callNode.getArguments()) {\n+        node.addChildToBack(transform(child));\n+      }\n+\n+      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n+      node.setLineno(callNode.getLineno());\n+      node.setCharno(position2charno(leftParamPos));\n+      return node;\n+    }\n+\n+    @Override\n+    Node processFunctionNode(FunctionNode functionNode) {\n+      Name name = functionNode.getFunctionName();\n+      Boolean isUnnamedFunction = false;\n+      if (name == null) {\n+        name = createName(\"\");\n+        isUnnamedFunction = true;\n+      }\n+      Node node = newNode(Token.FUNCTION);\n+      Node newName = transform(name);\n+      if (isUnnamedFunction) {\n+        newName.setLineno(functionNode.getLineno());\n+        int lpColumn = functionNode.getAbsolutePosition() + functionNode.getLp();\n+        newName.setCharno(position2charno(lpColumn));\n+      }\n+\n+      node.addChildToBack(newName);\n+      Node lp = newNode(Token.LP);\n+      Name fnName = functionNode.getFunctionName();\n+      if (fnName != null) {\n+        lp.setLineno(fnName.getLineno());\n+      } else {\n+        lp.setLineno(functionNode.getLineno());\n+      }\n+      int lparenCharno = functionNode.getLp() + functionNode.getAbsolutePosition();\n+\n+      lp.setCharno(position2charno(lparenCharno));\n+      for (AstNode param : functionNode.getParams()) {\n+        lp.addChildToBack(transform(param));\n+      }\n+      node.addChildToBack(lp);\n+\n+      Node bodyNode = transform(functionNode.getBody());\n+      parseDirectives(bodyNode);\n+      node.addChildToBack(bodyNode);\n+      return node;\n+    }\n+\n+    private String createName(String label) {\n+      return label == null ? \"\" : label;\n         name = new Name();\n         name.setIdentifier(\"\");\n         isUnnamedFunction = true;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}