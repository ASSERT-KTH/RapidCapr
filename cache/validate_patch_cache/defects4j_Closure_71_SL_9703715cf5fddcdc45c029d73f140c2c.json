{
    "patch": "  private boolean isPropertyOverride(Node getProp, Node parent, Scope scope) {\n    if (!NodeUtil.isAssignmentOp(parent) || parent.getFirstChild() != getProp) {\n      // Not an assignment, can't be an override.\n      return false;\n    }\n\n    Node lhs = getProp.getFirstChild();\n    if (!lhs.isGetProp()) {\n      // Assignment to something that's not a property access. Can't be an override.\n      return false;\n    }\n\n    String propName = lhs.getLastChild().getString();\n\n    ObjectType objectType =\n        ObjectType.cast(dereference(lhs.getFirstChild().getJSType()));\n    if (objectType == null) {\n      // Can't find the object type, can't be an override.\n      return false;\n    }\n\n    // Find the lowest property defined on a class with visibility information.\n    JSDocInfo docInfo = null;\n    for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propName);\n      if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n\n    if (objectType == null) {\n      // Can't find the property; can't be an override.\n      return false;\n    }\n\n    boolean sameInput =\n        scope.getRootNode().getInputId().equals(docInfo.getSourceName());\n    Visibility visibility = docInfo.getVisibility();\n    JSType ownerType = normalizeClassType(objectType);\n\n    // Check an ASSIGN statement that's trying to override a property on a superclass.\n    JSDocInfo overridingInfo = parent.getJSDocInfo();\n    Visibility overridingVisibility = overridingInfo == null\n        ? Visibility.INHERITED\n        : overridingInfo.getVisibility();\n\n    // Check that (a) the property *can* be overridden, and\n    // (b) that the visibility of the override is the same as the visibility of the\n    //     original property.\n    if (visibility == Visibility.PRIVATE && !sameInput) {\n      return false;\n    }\n    if (overridingVisibility == Visibility.INHERITED) {\n      return false;\n    }\n    if (overridingVisibility != visibility) {\n      return false;\n    }\n\n    return true;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckAccessControls.java b/src/com/google/javascript/jscomp/CheckAccessControls.java\nindex b23fd7af..29b8d1d4 100644\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n@@ -413,7 +413,67 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+  private boolean isPropertyOverride(Node getProp, Node parent, Scope scope) {\n+    if (!NodeUtil.isAssignmentOp(parent) || parent.getFirstChild() != getProp) {\n+      // Not an assignment, can't be an override.\n+      return false;\n+    }\n+\n+    Node lhs = getProp.getFirstChild();\n+    if (!lhs.isGetProp()) {\n+      // Assignment to something that's not a property access. Can't be an override.\n+      return false;\n+    }\n+\n+    String propName = lhs.getLastChild().getString();\n+\n+    ObjectType objectType =\n+        ObjectType.cast(dereference(lhs.getFirstChild().getJSType()));\n+    if (objectType == null) {\n+      // Can't find the object type, can't be an override.\n+      return false;\n+    }\n+\n+    // Find the lowest property defined on a class with visibility information.\n+    JSDocInfo docInfo = null;\n+    for (; objectType != null; objectType = objectType.getImplicitPrototype()) {\n+      docInfo = objectType.getOwnPropertyJSDocInfo(propName);\n+      if (docInfo != null && docInfo.getVisibility() != Visibility.INHERITED) {\n+        break;\n+      }\n+    }\n+\n+    if (objectType == null) {\n+      // Can't find the property; can't be an override.\n+      return false;\n+    }\n+\n+    boolean sameInput =\n+        scope.getRootNode().getInputId().equals(docInfo.getSourceName());\n+    Visibility visibility = docInfo.getVisibility();\n+    JSType ownerType = normalizeClassType(objectType);\n+\n+    // Check an ASSIGN statement that's trying to override a property on a superclass.\n+    JSDocInfo overridingInfo = parent.getJSDocInfo();\n+    Visibility overridingVisibility = overridingInfo == null\n+        ? Visibility.INHERITED\n+        : overridingInfo.getVisibility();\n+\n+    // Check that (a) the property *can* be overridden, and\n+    // (b) that the visibility of the override is the same as the visibility of the\n+    //     original property.\n+    if (visibility == Visibility.PRIVATE && !sameInput) {\n+      return false;\n+    }\n+    if (overridingVisibility == Visibility.INHERITED) {\n+      return false;\n+    }\n+    if (overridingVisibility != visibility) {\n+      return false;\n+    }\n+\n+    return true;\n+  }\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}