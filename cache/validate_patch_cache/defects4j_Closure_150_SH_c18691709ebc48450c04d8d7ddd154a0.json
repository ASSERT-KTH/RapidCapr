{
    "patch": "      if (parent == null || n == null) return;\n\n      Node root = scope.isDeclared(TraversalUtils.getScopeRootNode(n)) ?\n          TraversalUtils.getEnclosingBlockScopeRoot(n) :\n          TraversalUtils.getScopeRootNode(n);\n\n      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          if (NodeUtil.isFunctionExpression(n)) {\n            addFunctionExpressionToScope(n, parent);\n          } else if (parent.isFunction()) {\n            handleNamedFunctionDeclaration(n, parent);\n          } else if (parent.isExprResult()) {\n            handleExpressionContainingFunctionDeclaration(n, parent);\n          } else if (root.isScript()) {\n            defineGlobalFunction(n, root);\n          } else {\n            // Function declarations not allowed as statements in others\n            // scopes.\n            // Enterprise customers sometimes wrap function declarations in\n            // conditionals to get conditional function definitions, e.g.\n            // if (DEBUG) {function f() {}} functions.  The bailout here is\n            // conservative: conditional function declarations won't get type\n            // checking.\n            compiler.report(JSError.make(n, CONSIDER_REMOVING_FUNCTION_DECLARATION));\n          }\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVars(n, parent);\n          break;\n        case Token.LP:\n          if (parent == scope.getRootNode()) {\n            handleFunctionInputs(n);\n          }\n          break;\n        default:\n          break;\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..1dcc1dea 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1448,19 +1448,46 @@ final class TypedScopeCreator implements ScopeCreator {\n         return;\n       }\n \n+      if (parent == null || n == null) return;\n+\n+      Node root = scope.isDeclared(TraversalUtils.getScopeRootNode(n)) ?\n+          TraversalUtils.getEnclosingBlockScopeRoot(n) :\n+          TraversalUtils.getScopeRootNode(n);\n+\n       attachLiteralTypes(n);\n       switch (n.getType()) {\n         case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n+          if (NodeUtil.isFunctionExpression(n)) {\n+            addFunctionExpressionToScope(n, parent);\n+          } else if (parent.isFunction()) {\n+            handleNamedFunctionDeclaration(n, parent);\n+          } else if (parent.isExprResult()) {\n+            handleExpressionContainingFunctionDeclaration(n, parent);\n+          } else if (root.isScript()) {\n+            defineGlobalFunction(n, root);\n+          } else {\n+            // Function declarations not allowed as statements in others\n+            // scopes.\n+            // Enterprise customers sometimes wrap function declarations in\n+            // conditionals to get conditional function definitions, e.g.\n+            // if (DEBUG) {function f() {}} functions.  The bailout here is\n+            // conservative: conditional function declarations won't get type\n+            // checking.\n+            compiler.report(JSError.make(n, CONSIDER_REMOVING_FUNCTION_DECLARATION));\n           }\n-          defineDeclaredFunction(n, parent);\n           break;\n         case Token.CATCH:\n           defineCatch(n, parent);\n           break;\n         case Token.VAR:\n-          defineVar(n, parent);\n+          defineVars(n, parent);\n+          break;\n+        case Token.LP:\n+          if (parent == scope.getRootNode()) {\n+            handleFunctionInputs(n);\n+          }\n+          break;\n+        default:\n           break;\n       }\n     }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}