{
    "patch": "          if (parent.getLastChild().getString().equals(\"constructor\") &&\n              (NodeUtil.isClassExpression(name.getParent().getParent()) ||\n                  NodeUtil.isInFunction(name.getParent().getParent()))) {\n            // If this is a class or a function that has a \"constructor\"\n            // method, don't use \"this\" to refer to the object.\n            return false;\n          }\n\n          // A call target may be using the object as a 'this' value.\n          if (gramps.isCall()\n              && gramps.getFirstChild() == parent) {\n            return false;\n          }\n\n          // Deleting a property has different semantics from deleting\n          // a variable, so deleted properties should not be inlined.\n          if (NodeUtil.isLhsByDestructuring(parent)) {\n            return false;\n          }\n\n          // NOTE(nicksantos): This pass's object-splitting algorithm has\n          // a blind spot. It assumes that if a property isn't defined on an\n          // object, then the value is undefined. This is not true, because\n          // Object.prototype can have arbitrary properties on it.\n          //\n          // We short-circuit this problem by bailing out if we see a reference\n          // to a property that isn't defined on the object literal. This\n          // isn't a perfect algorithm, but it should catch most cases.\n          String propName = parent.getLastChild().getString();\n          if (!validProperties.contains(propName)) {\n            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n              validProperties.add(propName);\n            } else {\n              return false;\n            }\n          }\n          continue;\n        }\n\n        // Only rewrite VAR declarations or simple assignment statements\n        if (!isVarOrAssignExprLhs(name)) {\n          return false;\n        }\n\n        Node val = ref.getAssignedValue();\n        if (val == null) {\n          // A var with no assignment.\n          continue;\n        }\n\n        // We're looking for object literal assignments only.\n        if (!val.isObjectLit()) {\n          return false;\n        }\n\n        // Make sure that the value is not self-referential. I.e.,\n        // disallow things like x = {b: x.a}.\n        //\n        // ES5 getters/setters aren't handled by this pass.\n        for (Node child = val.getFirstChild(); child != null;\n             child = child.getNext()) {\n          if (child.isGetterDef() ||\n              child.isSetterDef()) {\n            // ES5 get/set not supported.\n            return false;\n          }\n\n          String propertyName = child.getString();\n          validProperties.add(propertyName);\n\n          Node childValue = child.getFirstChild();\n          if (childValue == null) {\n            // {a} is equivalent to {a: a}, but the former doesn't\n            // preclude replacing references in other properties.\n            continue;\n          }\n\n          // Check if childValue is the parent of any of the passed in\n          // references, as that is how self-referential assignments\n          // will happen.\n          for (Reference t : refs) {\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childValue) {\n                // There's a self-referential assignment\n                return false;\n              }\n              refNode = refNode.getParent();\n            }\n          }\n\n          if (!NodeUtil.mayHaveSideEffects(childValue, compiler)) {\n            JSType jsType = childValue.getJSType();\n            if (jsType != null && jsType.isConstructor()) {\n              // We must ensure that we're dealing with an object literal.\n              maybeAddNominalType(jsType, val);\n              if (constructorReferences.isEmpty()) {\n                constructorReferences =\n                    getReferencesByName(val, \"constructor\");\n              }\n\n              // Constructors of derived classes must not reference \"this\",\n              // because inlining constructor properties would obscure the\n              // fact that `this` is not initialized yet.\n              while (childValue.isGetProp()) {\n                childValue = childValue.getFirstChild();\n              }\n              if (childValue.isThis()) {\n                return false;\n              }\n            }\n          } else {\n            // The initial implementation of this code (before supporting\n            // constructors with maybeAddNominalType()) considered an\n            // object literal with side-effectful properties unsafe even\n            // if everything else seemed fine. This restrictiveness would\n            // need to be reimplemented in the face of inheritance.\n            maybeAddNominalType(null, val);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..6caae95a 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,124 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+          if (parent.getLastChild().getString().equals(\"constructor\") &&\n+              (NodeUtil.isClassExpression(name.getParent().getParent()) ||\n+                  NodeUtil.isInFunction(name.getParent().getParent()))) {\n+            // If this is a class or a function that has a \"constructor\"\n+            // method, don't use \"this\" to refer to the object.\n+            return false;\n+          }\n+\n+          // A call target may be using the object as a 'this' value.\n+          if (gramps.isCall()\n+              && gramps.getFirstChild() == parent) {\n+            return false;\n+          }\n+\n+          // Deleting a property has different semantics from deleting\n+          // a variable, so deleted properties should not be inlined.\n+          if (NodeUtil.isLhsByDestructuring(parent)) {\n+            return false;\n+          }\n+\n+          // NOTE(nicksantos): This pass's object-splitting algorithm has\n+          // a blind spot. It assumes that if a property isn't defined on an\n+          // object, then the value is undefined. This is not true, because\n+          // Object.prototype can have arbitrary properties on it.\n+          //\n+          // We short-circuit this problem by bailing out if we see a reference\n+          // to a property that isn't defined on the object literal. This\n+          // isn't a perfect algorithm, but it should catch most cases.\n+          String propName = parent.getLastChild().getString();\n+          if (!validProperties.contains(propName)) {\n+            if (NodeUtil.isVarOrSimpleAssignLhs(parent, gramps)) {\n+              validProperties.add(propName);\n+            } else {\n+              return false;\n+            }\n+          }\n+          continue;\n+        }\n+\n+        // Only rewrite VAR declarations or simple assignment statements\n+        if (!isVarOrAssignExprLhs(name)) {\n+          return false;\n+        }\n+\n+        Node val = ref.getAssignedValue();\n+        if (val == null) {\n+          // A var with no assignment.\n+          continue;\n+        }\n+\n+        // We're looking for object literal assignments only.\n+        if (!val.isObjectLit()) {\n+          return false;\n+        }\n+\n+        // Make sure that the value is not self-referential. I.e.,\n+        // disallow things like x = {b: x.a}.\n+        //\n+        // ES5 getters/setters aren't handled by this pass.\n+        for (Node child = val.getFirstChild(); child != null;\n+             child = child.getNext()) {\n+          if (child.isGetterDef() ||\n+              child.isSetterDef()) {\n+            // ES5 get/set not supported.\n+            return false;\n+          }\n+\n+          String propertyName = child.getString();\n+          validProperties.add(propertyName);\n+\n+          Node childValue = child.getFirstChild();\n+          if (childValue == null) {\n+            // {a} is equivalent to {a: a}, but the former doesn't\n+            // preclude replacing references in other properties.\n+            continue;\n+          }\n+\n+          // Check if childValue is the parent of any of the passed in\n+          // references, as that is how self-referential assignments\n+          // will happen.\n+          for (Reference t : refs) {\n+            Node refNode = t.getParent();\n+            while (!NodeUtil.isStatementBlock(refNode)) {\n+              if (refNode == childValue) {\n+                // There's a self-referential assignment\n+                return false;\n+              }\n+              refNode = refNode.getParent();\n+            }\n+          }\n+\n+          if (!NodeUtil.mayHaveSideEffects(childValue, compiler)) {\n+            JSType jsType = childValue.getJSType();\n+            if (jsType != null && jsType.isConstructor()) {\n+              // We must ensure that we're dealing with an object literal.\n+              maybeAddNominalType(jsType, val);\n+              if (constructorReferences.isEmpty()) {\n+                constructorReferences =\n+                    getReferencesByName(val, \"constructor\");\n+              }\n+\n+              // Constructors of derived classes must not reference \"this\",\n+              // because inlining constructor properties would obscure the\n+              // fact that `this` is not initialized yet.\n+              while (childValue.isGetProp()) {\n+                childValue = childValue.getFirstChild();\n+              }\n+              if (childValue.isThis()) {\n+                return false;\n+              }\n+            }\n+          } else {\n+            // The initial implementation of this code (before supporting\n+            // constructors with maybeAddNominalType()) considered an\n+            // object literal with side-effectful properties unsafe even\n+            // if everything else seemed fine. This restrictiveness would\n+            // need to be reimplemented in the face of inheritance.\n+            maybeAddNominalType(null, val);\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}