{
    "patch": "    private void annotateCalls(Node n) {\n        Preconditions.checkState(n.isCall());\n\n        // Keep track of of the \"this\" context of a call.  A call without an\n        // explicit \"this\" is a free call.\n        Node first = n.getFirstChild();\n\n        if (NodeUtil.isGet(first) && NodeUtil.isNormalGet(first)) {\n            // Keep track of the context in which eval is called. It is important\n            // to distinguish between \"(0, eval)()\" and \"eval()\".\n            if (first.getFirstChild().getString().equals(\"eval\")) {\n                first.getFirstChild().putBooleanProp(Node.DIRECT_EVAL, true);\n            }\n        } else {\n            // Annotate calls to known functions with special behavior.\n            switch (first.getToken()) {\n                case EXPONENT:\n                    // Add parens to POWER calls that are replace by the runtime with\n                    // a helper function.\n                    Node last = n.getLastChild();\n                    if (last.isNumber()) {\n                        last.setString(\"(\" + last.getString() + \")\");\n                    }\n                    break;\n\n                case STRING_KEY:\n                    // Check for a goog.abstractMethod call whose context should be null.\n                    if (first.matchesQualifiedName(\"goog.abstractMethod\")) {\n                        first.putBooleanProp(Node.FREE_CALL, true);\n                    }\n                    break;\n\n                default:\n                    // Track global names to see if they are free calls.\n                    if (first.isQualifiedName() && first.isNamespace() && !first.isVar()) {\n                        Var var = getScope().getVar(first.getQualifiedName());\n                        if (var != null && var.isGlobal()) {\n                            n.putBooleanProp(Node.FREE_CALL, true);\n                        }\n                    }\n                    break;\n            }\n        }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PrepareAst.java b/src/com/google/javascript/jscomp/PrepareAst.java\nindex d993bee7..4701dd1e 100644\n--- a/src/com/google/javascript/jscomp/PrepareAst.java\n+++ b/src/com/google/javascript/jscomp/PrepareAst.java\n@@ -163,6 +163,50 @@ class PrepareAst implements CompilerPass {\n       Node first = n.getFirstChild();\n \n       // ignore cast nodes.\n+    private void annotateCalls(Node n) {\n+        Preconditions.checkState(n.isCall());\n+\n+        // Keep track of of the \"this\" context of a call.  A call without an\n+        // explicit \"this\" is a free call.\n+        Node first = n.getFirstChild();\n+\n+        if (NodeUtil.isGet(first) && NodeUtil.isNormalGet(first)) {\n+            // Keep track of the context in which eval is called. It is important\n+            // to distinguish between \"(0, eval)()\" and \"eval()\".\n+            if (first.getFirstChild().getString().equals(\"eval\")) {\n+                first.getFirstChild().putBooleanProp(Node.DIRECT_EVAL, true);\n+            }\n+        } else {\n+            // Annotate calls to known functions with special behavior.\n+            switch (first.getToken()) {\n+                case EXPONENT:\n+                    // Add parens to POWER calls that are replace by the runtime with\n+                    // a helper function.\n+                    Node last = n.getLastChild();\n+                    if (last.isNumber()) {\n+                        last.setString(\"(\" + last.getString() + \")\");\n+                    }\n+                    break;\n+\n+                case STRING_KEY:\n+                    // Check for a goog.abstractMethod call whose context should be null.\n+                    if (first.matchesQualifiedName(\"goog.abstractMethod\")) {\n+                        first.putBooleanProp(Node.FREE_CALL, true);\n+                    }\n+                    break;\n+\n+                default:\n+                    // Track global names to see if they are free calls.\n+                    if (first.isQualifiedName() && first.isNamespace() && !first.isVar()) {\n+                        Var var = getScope().getVar(first.getQualifiedName());\n+                        if (var != null && var.isGlobal()) {\n+                            n.putBooleanProp(Node.FREE_CALL, true);\n+                        }\n+                    }\n+                    break;\n+            }\n+        }\n+    }\n \n       if (!NodeUtil.isGet(first)) {\n         n.putBooleanProp(Node.FREE_CALL, true);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}