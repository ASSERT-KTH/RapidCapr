{
    "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n  int nodeType = node.getType();\n  if (nodeType == Token.NAME) {\n    scope.inferSlotType(node.getString(), type);\n  } else if (nodeType == Token.GETPROP) {\n    String qualifiedName = node.getQualifiedName();\n    if (qualifiedName == null) {\n      throw new IllegalArgumentException(\"qualifiedName cannot be null\");\n    }\n    JSType origType = node.getJSType();\n    if (origType == null) {\n      origType = getNativeType(UNKNOWN_TYPE);\n    }\n    scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n  } else if (nodeType != Token.THIS) {\n    throw new IllegalArgumentException(\"Unexpected node type in declareNameInScope: \" + nodeType);\n  }\n  // Ignore references to 'this' node\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..9faa589d 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,28 +154,25 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n-    switch (node.getType()) {\n-      case Token.NAME:\n-        scope.inferSlotType(node.getString(), type);\n-        break;\n-\n-      case Token.GETPROP:\n-        String qualifiedName = node.getQualifiedName();\n-        Preconditions.checkNotNull(qualifiedName);\n-\n-        JSType origType = node.getJSType();\n-        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n-        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n-        break;\n-\n-        // \"this\" references aren't currently modeled in the CFG.\n-\n-      default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n-    }\n+protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+  int nodeType = node.getType();\n+  if (nodeType == Token.NAME) {\n+    scope.inferSlotType(node.getString(), type);\n+  } else if (nodeType == Token.GETPROP) {\n+    String qualifiedName = node.getQualifiedName();\n+    if (qualifiedName == null) {\n+      throw new IllegalArgumentException(\"qualifiedName cannot be null\");\n+    }\n+    JSType origType = node.getJSType();\n+    if (origType == null) {\n+      origType = getNativeType(UNKNOWN_TYPE);\n+    }\n+    scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+  } else if (nodeType != Token.THIS) {\n+    throw new IllegalArgumentException(\"Unexpected node type in declareNameInScope: \" + nodeType);\n   }\n+  // Ignore references to 'this' node\n+}\n \n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)",
    "result_reason": "all tests passed",
    "test_result": "PASS"
}