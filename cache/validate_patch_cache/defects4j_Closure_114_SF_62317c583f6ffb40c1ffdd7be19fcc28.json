{
    "patch": "private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n  Node lhs = n.getFirstChild();\n  Node rhs = lhs.getNext();\n  NameInformation ns = createNameInformation(t, lhs);\n  if (ns != null) {\n    // Record the dependencies based on the context of the assignment\n    if (isPartOfForLoop(lhs)) {\n      // If the left-hand side is part of a for loop, record the dependencies against the loop node,\n      // which represents a new scope.\n      recordDepScope(lhs.getGrandparent(), ns);\n    } else if (isVar(lhs)) {\n      // If the left-hand side is part of a var declaration, record the dependencies against the var node.\n      // Since vars are hoisted to the top of the function scope, we want to make sure they are associated\n      // with the correct scope.\n      recordDepScope(lhs.getParent(), ns);\n    } else if (isExprResult(lhs) && (rhs == null || !rhs.isCall() || isPartOfCallChain(rhs))) {\n      // If the assignment appears as an expression statement, record the dependencies against the statement\n      // parent. In other words, if the assignment is the entire expression, it's the context that uses the RHS.\n      // However, if the RHS is a function call that's part of a larger call chain (i.e., there are other functions\n      // called on the result of this function), we want to associate the RHS with the call chain context.\n      recordDepScope(lhs.getParent(), ns);\n    } else if (isPartOfObjectDeclaration(lhs)) {\n      // If we're in an object declaration, the assigned variable is only visible within the object scope. Record\n      // the dependencies against the object node.\n      Node objectNode = lhs.getAncestor(AbstractCompiler.OBJECTLIT);\n      recordDepScope(objectNode, ns);\n    } else if (isPartOfFunctionDeclaration(lhs)) {\n      // If the assignment is part of a function declaration, record dependencies against the function node.\n      // This ensures that the variable is only visible within the function scope.\n      Node functionNode = null;\n      if (NodeUtil.isFunctionExpression(lhs.getParent())) {\n        // If the function expression is part of a larger expression, record the dependencies against that\n        // expression instead so that it's associated with the context that uses it.\n        functionNode = lhs.getParent();\n      } else {\n        functionNode = lhs.getAncestor(AbstractCompiler.FUNCTION_NODE);\n      }\n      recordDepScope(functionNode, ns);\n    } else if (rhs != null && rhs.isCall()) {\n      // If the RHS is a function call, record its dependencies against the call expression.\n      recordDepScope(rhs, ns);\n    } else {\n      // Otherwise, record the dependencies against the statement block parent.\n      recordDepScope(n.getAncestor(AbstractCompiler.STATEMENT_BLOCK_NODE), ns);\n    }\n  }\n}\n\nprivate boolean isVar(Node n) {\n  return n.getParent().isVar();\n}\n\nprivate boolean isExprResult(Node n) {\n  return n.getParent().isExprResult();\n}\n\nprivate boolean isPartOfForLoop(Node n) {\n  return n.getAncestor(AbstractCompiler.FOR_NODE) != null;\n}\n\nprivate boolean isPartOfObjectDeclaration(Node n) {\n  return n.getGrandparent().isObjectLit();\n}\n\nprivate boolean isPartOfFunctionDeclaration(Node n) {\n  return NodeUtil.isFunctionDeclaration(n) || NodeUtil.isFunctionExpression(n) || (n.isAssign() && n.getParent().isFunction());\n}\n\nprivate boolean isPartOfCallChain(Node n) {\n  return (n.getParent().isCall() && n.getParent().getNext() != null && n.getParent().getNext().isCall());\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 0fc5ae8f..51ed47c2 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -555,37 +555,77 @@ final class NameAnalyzer implements CompilerPass {\n       }\n     }\n \n-    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n-      Node nameNode = n.getFirstChild();\n-      Node parent = n.getParent();\n-      NameInformation ns = createNameInformation(t, nameNode);\n-      if (ns != null) {\n-        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n-          // Patch for assignments that appear in the init,\n-          // condition or iteration part of a FOR loop.  Without\n-          // this change, all 3 of those parts try to claim the for\n-          // loop as their dependency scope.  The last assignment in\n-          // those three fields wins, which can result in incorrect\n-          // reference edges between referenced and assigned variables.\n-          //\n-          // TODO(user) revisit the dependency scope calculation\n-          // logic.\n-          if (parent.getFirstChild().getNext() != n) {\n-            recordDepScope(recordNode, ns);\n-          } else {\n-            recordDepScope(nameNode, ns);\n-          }\n-        } else {\n-          // The rhs of the assignment is the caller, so it's used by the\n-          // context. Don't associate it w/ the lhs.\n-          // FYI: this fixes only the specific case where the assignment is the\n-          // caller expression, but it could be nested deeper in the caller and\n-          // we would still get a bug.\n-          // See testAssignWithCall2 for an example of this.\n-          recordDepScope(recordNode, ns);\n-        }\n+private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n+  Node lhs = n.getFirstChild();\n+  Node rhs = lhs.getNext();\n+  NameInformation ns = createNameInformation(t, lhs);\n+  if (ns != null) {\n+    // Record the dependencies based on the context of the assignment\n+    if (isPartOfForLoop(lhs)) {\n+      // If the left-hand side is part of a for loop, record the dependencies against the loop node,\n+      // which represents a new scope.\n+      recordDepScope(lhs.getGrandparent(), ns);\n+    } else if (isVar(lhs)) {\n+      // If the left-hand side is part of a var declaration, record the dependencies against the var node.\n+      // Since vars are hoisted to the top of the function scope, we want to make sure they are associated\n+      // with the correct scope.\n+      recordDepScope(lhs.getParent(), ns);\n+    } else if (isExprResult(lhs) && (rhs == null || !rhs.isCall() || isPartOfCallChain(rhs))) {\n+      // If the assignment appears as an expression statement, record the dependencies against the statement\n+      // parent. In other words, if the assignment is the entire expression, it's the context that uses the RHS.\n+      // However, if the RHS is a function call that's part of a larger call chain (i.e., there are other functions\n+      // called on the result of this function), we want to associate the RHS with the call chain context.\n+      recordDepScope(lhs.getParent(), ns);\n+    } else if (isPartOfObjectDeclaration(lhs)) {\n+      // If we're in an object declaration, the assigned variable is only visible within the object scope. Record\n+      // the dependencies against the object node.\n+      Node objectNode = lhs.getAncestor(AbstractCompiler.OBJECTLIT);\n+      recordDepScope(objectNode, ns);\n+    } else if (isPartOfFunctionDeclaration(lhs)) {\n+      // If the assignment is part of a function declaration, record dependencies against the function node.\n+      // This ensures that the variable is only visible within the function scope.\n+      Node functionNode = null;\n+      if (NodeUtil.isFunctionExpression(lhs.getParent())) {\n+        // If the function expression is part of a larger expression, record the dependencies against that\n+        // expression instead so that it's associated with the context that uses it.\n+        functionNode = lhs.getParent();\n+      } else {\n+        functionNode = lhs.getAncestor(AbstractCompiler.FUNCTION_NODE);\n       }\n+      recordDepScope(functionNode, ns);\n+    } else if (rhs != null && rhs.isCall()) {\n+      // If the RHS is a function call, record its dependencies against the call expression.\n+      recordDepScope(rhs, ns);\n+    } else {\n+      // Otherwise, record the dependencies against the statement block parent.\n+      recordDepScope(n.getAncestor(AbstractCompiler.STATEMENT_BLOCK_NODE), ns);\n     }\n+  }\n+}\n+\n+private boolean isVar(Node n) {\n+  return n.getParent().isVar();\n+}\n+\n+private boolean isExprResult(Node n) {\n+  return n.getParent().isExprResult();\n+}\n+\n+private boolean isPartOfForLoop(Node n) {\n+  return n.getAncestor(AbstractCompiler.FOR_NODE) != null;\n+}\n+\n+private boolean isPartOfObjectDeclaration(Node n) {\n+  return n.getGrandparent().isObjectLit();\n+}\n+\n+private boolean isPartOfFunctionDeclaration(Node n) {\n+  return NodeUtil.isFunctionDeclaration(n) || NodeUtil.isFunctionExpression(n) || (n.isAssign() && n.getParent().isFunction());\n+}\n+\n+private boolean isPartOfCallChain(Node n) {\n+  return (n.getParent().isCall() && n.getParent().getNext() != null && n.getParent().getNext().isCall());\n+}\n \n     /**\n      * Defines a dependency scope.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}