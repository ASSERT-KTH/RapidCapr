{
    "patch": "import com.google.javascript.jscomp.*;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.jstype.*;\n\npublic class ExampleBugFix implements NodeTraversal.Callback {\n  private final AbstractCompiler compiler;\n\n  // Initialize the error messages.\n  static final DiagnosticType NOT_CALLABLE =\n      DiagnosticType.warning(\n          \"JSC_NOT_FUNCTION_TYPE\", \"cannot call type {0}\");\n\n  static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE =\n      DiagnosticType.warning(\n          \"JSC_CONSTRUCTOR_NOT_CALLABLE\",\n          \"cannot directly instantiate non-native constructor that returns \" +\n          \"void or has an inferred return type unless defined in an extern\");\n\n  static final DiagnosticType INVALID_THIS_TYPE =\n      DiagnosticType.warning(\n          \"JSC_INVALID_THIS_TYPE\",\n          \"method called on incompatible this type. expected {0}\");\n\n  public ExampleBugFix(AbstractCompiler compiler) {\n    this.compiler = compiler;\n  }\n\n  static JSType getJSType(Node n) {\n    // Retrieve the JSType of a Node\n    JSTypeExpression typeExpr = n.getJSType();\n    if (typeExpr != null) {\n      return typeExpr.evaluate();\n    } else {\n      return JSType.UNDEFINED;\n    }\n  }\n\n  static boolean hasJSDocInfo(Node n) {\n    return n.getJSDocInfo() != null || n.isFromExterns();\n  }\n\n  /**\n   * Determines whether the node parent of the node n in the AST being traversed\n   * has a GETPROP or GETELEM as its parent and the assignment to it is a call to\n   * the node n being visited.\n   *\n   * @param thisType The JS type for the \"this\" value in the function type.\n   * @param n The node being visited.\n   * @return True if the call expression is a call with a GETPROP/GETELEM parent.\n   */\n  private static boolean isCallWithGet(JSType thisType, Node n) {\n    Node parent = n.getParent();\n    if (parent == null || !NodeUtil.isGet(parent)) {\n      return false;\n    }\n    Node gramps = parent.getParent();\n\n    // Make certain gramps is a CALL node, and that parent's first child is the\n    // same as n.\n    if (gramps == null || !gramps.isCall() || (parent.getFirstChild() != n)) {\n      return false;\n    }\n\n    if (thisType != null) {\n      // Check that the \"this\" type in the function type matches the GET that\n      // contains this call.\n      JSType instanceType = parent.isGetProp() ?\n          getJSType(parent.getFirstChild()) :\n          getJSType(parent.getSecondChild());\n      if (!thisType.isSubtype(instanceType)) {\n        return false;\n      }\n    }\n\n    return true;\n  }\n\n  private void visitCall(NodeTraversal t, Node n) {\n    Node child = n.getFirstChild();\n    JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n\n    if (!childType.canBeCalled()) {\n      report(t, n, NOT_CALLABLE, childType.toString());\n      ensureTyped(t, n);\n      return;\n    }\n\n    // A couple of types can be called as if they were functions.\n    // If it is a function type, then validate parameters.\n    if (childType instanceof FunctionType) {\n      FunctionType functionType = (FunctionType) childType;\n\n      boolean isExtern = false;\n      JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n      if (functionJSDocInfo != null) {\n        String sourceName = functionJSDocInfo.getSourceFileName();\n        CompilerInput functionSource = compiler.getInput(new InputId(sourceName));\n        isExtern = functionSource.isExtern();\n      }\n\n      // Non-native constructors should not be called directly\n      // unless they specify a return type and are defined\n      // in an extern.\n      if (functionType.isConstructor() &&\n          !functionType.isNativeObjectType() &&\n          (functionType.getReturnType().isUnknownType() ||\n           functionType.getReturnType().isVoidType() ||\n           !isExtern)) {\n        report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n      }\n\n      // Functions with explicit 'this' types must be called in a GETPROP\n      // or GETELEM.\n      if (functionType.getThisType() != null && !isCallWithGet(functionType.getThisType(), n)) {\n        report(t, n, INVALID_THIS_TYPE, functionType.getThisType().toString());\n      }\n\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());\n    } else {\n      ensureTyped(t, n);\n    }\n\n    // TODO: Add something to check for calls of RegExp objects, which is not\n    // supported by IE.  Either say something about the return type or warn\n    // about the non-portability of the call or both.\n  }\n\n  /** Traverse the whole AST. */\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getToken()) {\n      case FUNCTION:\n        visitFunction(t, n);\n        break;\n      case CALL:\n        visitCall(t, n);\n        break;\n      // TODO: Add more cases here for other AST nodes to be visited.\n      default:\n        ensureTyped(t, n);\n        break;\n    }\n  }\n\n  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String str) {\n    t.report(n, diagnosticType, str);\n  }\n\n  /**\n   * Ensure that a node is \"typed\". If it doesn't have a type on it already,\n   * then add an unknown type.\n   */\n  private void ensureTyped(NodeTraversal t, Node n) {\n    if (getJSType(n).equals(JSType.UNKNOWN)) {\n      t.getCompiler().reportChangeToEnclosingScope(n);\n      n.setJSType(JSType.UNKNOWN);\n    }\n  }\n\n  /**\n   * Ensure that a node is of a particular type. If it doesn't have a type on\n   * it already, then add the specified type; otherwise, check that the new type\n   * is compatible with the old type.\n   */\n  private void ensureTyped(NodeTraversal t, Node n, JSType newType) {\n   JSType currentType = getJSType(n);\n\n   if (currentType.equals(JSType.UNKNOWN)) {\n     t.getCompiler().reportChangeToEnclosingScope(n);\n     n.setJSType(newType);\n   } else if (!newType.isUnknownType() && !currentType.isSubtype(newType)) {\n     t.report(n, DiagnosticType.warning(\"JSC_TYPE_MISMATCH\",\n         \"expected type: {1}, but got: {0}\", currentType.toString(),\n         newType.toString()));\n   }\n }\n\n  /** Processes a function definition. */\n  private void visitFunction(NodeTraversal t, Node n) {\n    // Function declarations are automatically scoped, so we do not need\n    // to traverse them here.\n    if (n.isFunctionDeclaration()) {\n      ensureTyped(t, n);\n      return;\n    }\n\n    Node name = n.getFirstChild();\n    JSType functionJSType = getJSType(n);\n    JSType returnType = functionJSType != null ?\n        ((FunctionType) functionJSType).getReturnType() :\n        JSType.UNKNOWN;\n\n    // Assign an anonymous function to a variable to more easily test for recursion.\n    // e.g. var f = function() { f(); };\n    if (name.isEmpty()) {\n      Node parent = n.getParent();\n      Node assign = parent.getFirstChild();\n      Node var = assign.getFirstChild();\n      Node fn = assign.getLastChild();\n      if (fn.isFunction()) {\n        ensureTyped(t, n, new FunctionTypeBuilder(compiler).infer(fn).buildFunction());\n        JSType varType = getJSType(var).getGreatestSubtype(getJSType(fn));\n        ensureTyped(t, var, varType);\n      }\n      return;\n    }\n\n    // If the function has a JSDoc annotation prescribing a type, use that type\n    // and infer a type for the function node, if missing or weaker.\n    if (hasJSDocInfo(n)) {\n      JSTypeExpression declaredType = name.getTypedefTypePropagate();\n      if (declaredType != null) {\n        JSType declType = declaredType.evaluate();\n        if (functionJSType == null) {\n          functionJSType = declType;\n          returnType = ((FunctionType) functionJSType).getReturnType();\n          ensureTyped(t, n, functionJSType);\n        } else {\n          JSType inferredType =\n              new FunctionTypeBuilder(compiler).infer(n).buildFunction();\n          if (inferredType.isSubtype(declType)) {\n            ensureTyped(t, n, declType);\n          } else {\n            ensureTyped(t, n, inferredType);\n            t.report(n, DiagnosticType.warning(\n                \"JSC_INFERRED_RETURN_TYPE_MISMATCH\",\n                \"could not infer return type for {0} from declared type\\n\" +\n                \"found   : {1}\\n\" +\n                \"required: {2}\",\n                name.getQualifiedName(),\n                inferredType.toString(),\n                declType.toString()));\n          }\n        }\n      }\n    }\n\n    // Add formal parameter types to the function's declared JSType.\n    visitParameterList(t, n, (FunctionType) functionJSType);\n    ensureTyped(t, n, functionJSType);\n  }\n\n  /** Processes the parameter list of a function. */\n  private void visitParameterList(NodeTraversal t, Node n, FunctionType functionType) {\n    Node parameters = n.getSecondChild();\n    if (parameters == null) {\n      return;\n    }\n    for (Node param : parameters.children()) {\n      String paramName = getParameterName(param);\n      JSTypeExpression paramTypeAnn = param.getJSType();\n      JSType paramInferredType =\n          functionType.getParameterType(paramName);\n      JSType newParamType =\n          JSType.join((paramTypeAnn != null ? paramTypeAnn.evaluate() : JSType.UNKNOWN),\n              paramInferredType);\n      ensureTyped(t, param, newParamType);\n    }\n  }\n\n  /** Returns the name of a parameter. */\n  private String getParameterName(Node param) {\n    String name = null;\n    Node maybeName = param.getFirstChild();\n    if (maybeName.isName()) {\n      name = maybeName.getString();\n    } else {\n      name = \"\";\n      for (Node child : maybeName.children()) {\n        if (!child.isString()) {\n          name = null;\n          break;\n        } else {\n          if (name == null) {\n            name = \"\";\n          } else {\n            name += \".\";\n          }\n          name += child.getString();\n        }\n      }\n      if (name == null) {\n        name = \"\";\n      }\n    }\n    return name;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..e3227bae 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1541,6 +1541,83 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n    * scope chain to use in name lookups as well as error reporting.\n    * @param n The node being visited.\n    */\n+import com.google.javascript.jscomp.*;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.*;\n+\n+public class ExampleBugFix implements NodeTraversal.Callback {\n+  private final AbstractCompiler compiler;\n+\n+  // Initialize the error messages.\n+  static final DiagnosticType NOT_CALLABLE =\n+      DiagnosticType.warning(\n+          \"JSC_NOT_FUNCTION_TYPE\", \"cannot call type {0}\");\n+\n+  static final DiagnosticType CONSTRUCTOR_NOT_CALLABLE =\n+      DiagnosticType.warning(\n+          \"JSC_CONSTRUCTOR_NOT_CALLABLE\",\n+          \"cannot directly instantiate non-native constructor that returns \" +\n+          \"void or has an inferred return type unless defined in an extern\");\n+\n+  static final DiagnosticType INVALID_THIS_TYPE =\n+      DiagnosticType.warning(\n+          \"JSC_INVALID_THIS_TYPE\",\n+          \"method called on incompatible this type. expected {0}\");\n+\n+  public ExampleBugFix(AbstractCompiler compiler) {\n+    this.compiler = compiler;\n+  }\n+\n+  static JSType getJSType(Node n) {\n+    // Retrieve the JSType of a Node\n+    JSTypeExpression typeExpr = n.getJSType();\n+    if (typeExpr != null) {\n+      return typeExpr.evaluate();\n+    } else {\n+      return JSType.UNDEFINED;\n+    }\n+  }\n+\n+  static boolean hasJSDocInfo(Node n) {\n+    return n.getJSDocInfo() != null || n.isFromExterns();\n+  }\n+\n+  /**\n+   * Determines whether the node parent of the node n in the AST being traversed\n+   * has a GETPROP or GETELEM as its parent and the assignment to it is a call to\n+   * the node n being visited.\n+   *\n+   * @param thisType The JS type for the \"this\" value in the function type.\n+   * @param n The node being visited.\n+   * @return True if the call expression is a call with a GETPROP/GETELEM parent.\n+   */\n+  private static boolean isCallWithGet(JSType thisType, Node n) {\n+    Node parent = n.getParent();\n+    if (parent == null || !NodeUtil.isGet(parent)) {\n+      return false;\n+    }\n+    Node gramps = parent.getParent();\n+\n+    // Make certain gramps is a CALL node, and that parent's first child is the\n+    // same as n.\n+    if (gramps == null || !gramps.isCall() || (parent.getFirstChild() != n)) {\n+      return false;\n+    }\n+\n+    if (thisType != null) {\n+      // Check that the \"this\" type in the function type matches the GET that\n+      // contains this call.\n+      JSType instanceType = parent.isGetProp() ?\n+          getJSType(parent.getFirstChild()) :\n+          getJSType(parent.getSecondChild());\n+      if (!thisType.isSubtype(instanceType)) {\n+        return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n   private void visitCall(NodeTraversal t, Node n) {\n     Node child = n.getFirstChild();\n     JSType childType = getJSType(child).restrictByNotNullOrUndefined();\n@@ -1558,9 +1635,9 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       boolean isExtern = false;\n       JSDocInfo functionJSDocInfo = functionType.getJSDocInfo();\n-      if(functionJSDocInfo != null) {\n-        String sourceName = functionJSDocInfo.getSourceName();\n-        CompilerInput functionSource = compiler.getInput(sourceName);\n+      if (functionJSDocInfo != null) {\n+        String sourceName = functionJSDocInfo.getSourceFileName();\n+        CompilerInput functionSource = compiler.getInput(new InputId(sourceName));\n         isExtern = functionSource.isExtern();\n       }\n \n@@ -1575,8 +1652,11 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n         report(t, n, CONSTRUCTOR_NOT_CALLABLE, childType.toString());\n       }\n \n-      // Functions with explcit 'this' types must be called in a GETPROP\n+      // Functions with explicit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+      if (functionType.getThisType() != null && !isCallWithGet(functionType.getThisType(), n)) {\n+        report(t, n, INVALID_THIS_TYPE, functionType.getThisType().toString());\n+      }\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());\n@@ -1589,6 +1669,168 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     // about the non-portability of the call or both.\n   }\n \n+  /** Traverse the whole AST. */\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    switch (n.getToken()) {\n+      case FUNCTION:\n+        visitFunction(t, n);\n+        break;\n+      case CALL:\n+        visitCall(t, n);\n+        break;\n+      // TODO: Add more cases here for other AST nodes to be visited.\n+      default:\n+        ensureTyped(t, n);\n+        break;\n+    }\n+  }\n+\n+  private void report(NodeTraversal t, Node n, DiagnosticType diagnosticType, String str) {\n+    t.report(n, diagnosticType, str);\n+  }\n+\n+  /**\n+   * Ensure that a node is \"typed\". If it doesn't have a type on it already,\n+   * then add an unknown type.\n+   */\n+  private void ensureTyped(NodeTraversal t, Node n) {\n+    if (getJSType(n).equals(JSType.UNKNOWN)) {\n+      t.getCompiler().reportChangeToEnclosingScope(n);\n+      n.setJSType(JSType.UNKNOWN);\n+    }\n+  }\n+\n+  /**\n+   * Ensure that a node is of a particular type. If it doesn't have a type on\n+   * it already, then add the specified type; otherwise, check that the new type\n+   * is compatible with the old type.\n+   */\n+  private void ensureTyped(NodeTraversal t, Node n, JSType newType) {\n+   JSType currentType = getJSType(n);\n+\n+   if (currentType.equals(JSType.UNKNOWN)) {\n+     t.getCompiler().reportChangeToEnclosingScope(n);\n+     n.setJSType(newType);\n+   } else if (!newType.isUnknownType() && !currentType.isSubtype(newType)) {\n+     t.report(n, DiagnosticType.warning(\"JSC_TYPE_MISMATCH\",\n+         \"expected type: {1}, but got: {0}\", currentType.toString(),\n+         newType.toString()));\n+   }\n+ }\n+\n+  /** Processes a function definition. */\n+  private void visitFunction(NodeTraversal t, Node n) {\n+    // Function declarations are automatically scoped, so we do not need\n+    // to traverse them here.\n+    if (n.isFunctionDeclaration()) {\n+      ensureTyped(t, n);\n+      return;\n+    }\n+\n+    Node name = n.getFirstChild();\n+    JSType functionJSType = getJSType(n);\n+    JSType returnType = functionJSType != null ?\n+        ((FunctionType) functionJSType).getReturnType() :\n+        JSType.UNKNOWN;\n+\n+    // Assign an anonymous function to a variable to more easily test for recursion.\n+    // e.g. var f = function() { f(); };\n+    if (name.isEmpty()) {\n+      Node parent = n.getParent();\n+      Node assign = parent.getFirstChild();\n+      Node var = assign.getFirstChild();\n+      Node fn = assign.getLastChild();\n+      if (fn.isFunction()) {\n+        ensureTyped(t, n, new FunctionTypeBuilder(compiler).infer(fn).buildFunction());\n+        JSType varType = getJSType(var).getGreatestSubtype(getJSType(fn));\n+        ensureTyped(t, var, varType);\n+      }\n+      return;\n+    }\n+\n+    // If the function has a JSDoc annotation prescribing a type, use that type\n+    // and infer a type for the function node, if missing or weaker.\n+    if (hasJSDocInfo(n)) {\n+      JSTypeExpression declaredType = name.getTypedefTypePropagate();\n+      if (declaredType != null) {\n+        JSType declType = declaredType.evaluate();\n+        if (functionJSType == null) {\n+          functionJSType = declType;\n+          returnType = ((FunctionType) functionJSType).getReturnType();\n+          ensureTyped(t, n, functionJSType);\n+        } else {\n+          JSType inferredType =\n+              new FunctionTypeBuilder(compiler).infer(n).buildFunction();\n+          if (inferredType.isSubtype(declType)) {\n+            ensureTyped(t, n, declType);\n+          } else {\n+            ensureTyped(t, n, inferredType);\n+            t.report(n, DiagnosticType.warning(\n+                \"JSC_INFERRED_RETURN_TYPE_MISMATCH\",\n+                \"could not infer return type for {0} from declared type\\n\" +\n+                \"found   : {1}\\n\" +\n+                \"required: {2}\",\n+                name.getQualifiedName(),\n+                inferredType.toString(),\n+                declType.toString()));\n+          }\n+        }\n+      }\n+    }\n+\n+    // Add formal parameter types to the function's declared JSType.\n+    visitParameterList(t, n, (FunctionType) functionJSType);\n+    ensureTyped(t, n, functionJSType);\n+  }\n+\n+  /** Processes the parameter list of a function. */\n+  private void visitParameterList(NodeTraversal t, Node n, FunctionType functionType) {\n+    Node parameters = n.getSecondChild();\n+    if (parameters == null) {\n+      return;\n+    }\n+    for (Node param : parameters.children()) {\n+      String paramName = getParameterName(param);\n+      JSTypeExpression paramTypeAnn = param.getJSType();\n+      JSType paramInferredType =\n+          functionType.getParameterType(paramName);\n+      JSType newParamType =\n+          JSType.join((paramTypeAnn != null ? paramTypeAnn.evaluate() : JSType.UNKNOWN),\n+              paramInferredType);\n+      ensureTyped(t, param, newParamType);\n+    }\n+  }\n+\n+  /** Returns the name of a parameter. */\n+  private String getParameterName(Node param) {\n+    String name = null;\n+    Node maybeName = param.getFirstChild();\n+    if (maybeName.isName()) {\n+      name = maybeName.getString();\n+    } else {\n+      name = \"\";\n+      for (Node child : maybeName.children()) {\n+        if (!child.isString()) {\n+          name = null;\n+          break;\n+        } else {\n+          if (name == null) {\n+            name = \"\";\n+          } else {\n+            name += \".\";\n+          }\n+          name += child.getString();\n+        }\n+      }\n+      if (name == null) {\n+        name = \"\";\n+      }\n+    }\n+    return name;\n+  }\n+}\n+\n   /**\n    * Visits the parameters of a CALL or a NEW node.\n    */",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}