{
    "patch": "import org.mockito.MockSettings;\nimport org.mockito.internal.creation.MethodInterceptorFilter;\nimport org.mockito.internal.handler.MockHandler;\nimport org.mockito.internal.handler.MockHandlerInterface;\nimport org.mockito.internal.util.ObjectMethodsGuru;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.invocation.MockHandlerFactory;\nimport org.mockito.mock.MockCreationSettings;\nimport org.mockito.mock.MockSettingsImpl;\nimport org.mockito.plugins.MockMaker;\nimport org.mockito.plugins.OpcodeBasedMockMaker;\n\nimport java.lang.reflect.InvocationTargetException;\nimport java.lang.reflect.Method;\nimport java.lang.reflect.Modifier;\nimport java.lang.reflect.Proxy;\nimport java.util.HashSet;\nimport java.util.LinkedHashSet;\nimport java.util.Set;\n\npublic class ResetMockDemo {\n\n    public static <T> void resetMock(T mock) {\n        Set<Class<?>> classes = new LinkedHashSet<>();\n        Class<?> clazz = mock.getClass();\n        while (clazz != null && clazz != Object.class) {\n            classes.add(clazz);\n            for (Class<?> intf : clazz.getInterfaces()) {\n                recursivelyAddInterface(classes, intf);\n            }\n            clazz = clazz.getSuperclass();\n        }\n\n        for (Class<?> cls : classes) {\n            if (Proxy.isProxyClass(cls)) {\n                InvocationHandler h = Proxy.getInvocationHandler(mock);\n                if (h instanceof MethodInterceptorFilter) {\n                    MethodInterceptorFilter filter = (MethodInterceptorFilter) h;\n                    MockHandlerInterface oldHandler = filter.getMockHandler();\n                    MockHandlerInterface newHandler = new MockHandler(oldHandler);\n                    MockSettings mockSettings = new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS).spiedInstance(newHandler.getMock());\n\n                    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newHandler, (MockSettingsImpl) mockSettings);\n                    try {\n                        Field field = filter.getClass().getSuperclass().getDeclaredField(\"callback\");\n                        field.setAccessible(true);\n                        field.set(filter, newFilter);\n                    } catch (NoSuchFieldException | IllegalAccessException e) {\n                        throw new RuntimeException(e);\n                    }\n                }\n            }\n        }\n    }\n\n    private static void recursivelyAddInterface(Set<Class<?>> interfaces, Class<?> intf) {\n        interfaces.add(intf);\n        for (Class<?> subIntf : intf.getInterfaces()) {\n            recursivelyAddInterface(interfaces, subIntf);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..ad00d4a79 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,70 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.MockSettings;\n+import org.mockito.internal.creation.MethodInterceptorFilter;\n+import org.mockito.internal.handler.MockHandler;\n+import org.mockito.internal.handler.MockHandlerInterface;\n+import org.mockito.internal.util.ObjectMethodsGuru;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.invocation.MockHandlerFactory;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.mock.MockSettingsImpl;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.plugins.OpcodeBasedMockMaker;\n+\n+import java.lang.reflect.InvocationTargetException;\n+import java.lang.reflect.Method;\n+import java.lang.reflect.Modifier;\n+import java.lang.reflect.Proxy;\n+import java.util.HashSet;\n+import java.util.LinkedHashSet;\n+import java.util.Set;\n+\n+public class ResetMockDemo {\n+\n+    public static <T> void resetMock(T mock) {\n+        Set<Class<?>> classes = new LinkedHashSet<>();\n+        Class<?> clazz = mock.getClass();\n+        while (clazz != null && clazz != Object.class) {\n+            classes.add(clazz);\n+            for (Class<?> intf : clazz.getInterfaces()) {\n+                recursivelyAddInterface(classes, intf);\n+            }\n+            clazz = clazz.getSuperclass();\n+        }\n+\n+        for (Class<?> cls : classes) {\n+            if (Proxy.isProxyClass(cls)) {\n+                InvocationHandler h = Proxy.getInvocationHandler(mock);\n+                if (h instanceof MethodInterceptorFilter) {\n+                    MethodInterceptorFilter filter = (MethodInterceptorFilter) h;\n+                    MockHandlerInterface oldHandler = filter.getMockHandler();\n+                    MockHandlerInterface newHandler = new MockHandler(oldHandler);\n+                    MockSettings mockSettings = new MockSettingsImpl().defaultAnswer(RETURNS_DEFAULTS).spiedInstance(newHandler.getMock());\n+\n+                    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newHandler, (MockSettingsImpl) mockSettings);\n+                    try {\n+                        Field field = filter.getClass().getSuperclass().getDeclaredField(\"callback\");\n+                        field.setAccessible(true);\n+                        field.set(filter, newFilter);\n+                    } catch (NoSuchFieldException | IllegalAccessException e) {\n+                        throw new RuntimeException(e);\n+                    }\n+                }\n+            }\n+        }\n+    }\n+\n+    private static void recursivelyAddInterface(Set<Class<?>> interfaces, Class<?> intf) {\n+        interfaces.add(intf);\n+        for (Class<?> subIntf : intf.getInterfaces()) {\n+            recursivelyAddInterface(interfaces, subIntf);\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}