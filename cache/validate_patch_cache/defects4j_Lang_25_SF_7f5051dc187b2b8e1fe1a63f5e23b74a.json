{
    "patch": "import java.nio.charset.Charset;\nimport java.nio.charset.StandardCharsets;\nimport java.util.Arrays;\n\npublic class StringEncoder {\n\n    public static String encode(String text, Charset charset) {\n        byte[] encodedByteArray = text.getBytes(charset);\n        StringBuilder sb = new StringBuilder();\n\n        for (byte b : encodedByteArray) {\n            sb.append(String.format(\"\\\\x%x\", b));\n        }\n\n        return sb.toString();\n    }\n\n    public static String decode(String encodedText, Charset charset) {\n        StringBuilder sb = new StringBuilder();\n\n        String[] encodedBytes = encodedText.split(\"\\\\\\\\x\");\n\n        if (encodedBytes.length > 0) {\n            byte[] byteArray = new byte[encodedBytes.length - 1];\n\n            for (int i = 1; i < encodedBytes.length; i++) {\n                byteArray[i - 1] = (byte) Integer.parseInt(encodedBytes[i], 16);\n            }\n\n            sb.append(new String(byteArray, charset));\n        }\n\n        return sb.toString();\n    }\n\n    public static void main(String[] args) {\n        String originalText = \"Hello, world!\";\n        Charset charset = StandardCharsets.ISO_8859_1;\n\n        String encodedText = encode(originalText, charset);\n        String decodedText = decode(encodedText, charset);\n\n        boolean success = originalText.equals(decodedText);\n\n        if (!success) {\n            System.out.printf(\"Error! originalText=[%s], decodedText=[%s], encodedText=[%s]%n\", originalText, decodedText, encodedText);\n        }\n\n        String[] testStrings = new String[] {\"\\u00e4\\u00f6\\u00fc\\u00df\", \"Hello, world!\", \"\\u2620\\ud83d\\ude08\"};\n        Charset[] testCharsets = new Charset[] {StandardCharsets.ISO_8859_1, StandardCharsets.UTF_8};\n\n        Arrays.stream(testStrings).forEach(s -> {\n            Arrays.stream(testCharsets).forEach(c -> {\n                String encoded = encode(s, c);\n                String decoded = decode(encoded, c);\n\n                boolean success2 = s.equals(decoded);\n\n                if (!success2) {\n                    System.out.printf(\"Error! s=[%s], decoded=[%s], encoded=[%s], charset=[%s]%n\", s, decoded, encoded, c.name());\n                }\n            });\n        });\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\nindex 8caca580..acbee7a3 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n@@ -27,7 +27,71 @@ package org.apache.commons.lang3.text.translate;\n  */\n public class EntityArrays {\n \n-    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\n+import java.nio.charset.Charset;\n+import java.nio.charset.StandardCharsets;\n+import java.util.Arrays;\n+\n+public class StringEncoder {\n+\n+    public static String encode(String text, Charset charset) {\n+        byte[] encodedByteArray = text.getBytes(charset);\n+        StringBuilder sb = new StringBuilder();\n+\n+        for (byte b : encodedByteArray) {\n+            sb.append(String.format(\"\\\\x%x\", b));\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    public static String decode(String encodedText, Charset charset) {\n+        StringBuilder sb = new StringBuilder();\n+\n+        String[] encodedBytes = encodedText.split(\"\\\\\\\\x\");\n+\n+        if (encodedBytes.length > 0) {\n+            byte[] byteArray = new byte[encodedBytes.length - 1];\n+\n+            for (int i = 1; i < encodedBytes.length; i++) {\n+                byteArray[i - 1] = (byte) Integer.parseInt(encodedBytes[i], 16);\n+            }\n+\n+            sb.append(new String(byteArray, charset));\n+        }\n+\n+        return sb.toString();\n+    }\n+\n+    public static void main(String[] args) {\n+        String originalText = \"Hello, world!\";\n+        Charset charset = StandardCharsets.ISO_8859_1;\n+\n+        String encodedText = encode(originalText, charset);\n+        String decodedText = decode(encodedText, charset);\n+\n+        boolean success = originalText.equals(decodedText);\n+\n+        if (!success) {\n+            System.out.printf(\"Error! originalText=[%s], decodedText=[%s], encodedText=[%s]%n\", originalText, decodedText, encodedText);\n+        }\n+\n+        String[] testStrings = new String[] {\"\\u00e4\\u00f6\\u00fc\\u00df\", \"Hello, world!\", \"\\u2620\\ud83d\\ude08\"};\n+        Charset[] testCharsets = new Charset[] {StandardCharsets.ISO_8859_1, StandardCharsets.UTF_8};\n+\n+        Arrays.stream(testStrings).forEach(s -> {\n+            Arrays.stream(testCharsets).forEach(c -> {\n+                String encoded = encode(s, c);\n+                String decoded = decode(encoded, c);\n+\n+                boolean success2 = s.equals(decoded);\n+\n+                if (!success2) {\n+                    System.out.printf(\"Error! s=[%s], decoded=[%s], encoded=[%s], charset=[%s]%n\", s, decoded, encoded, c.name());\n+                }\n+            });\n+        });\n+    }\n+}\n     private static final String[][] ISO8859_1_ESCAPE = {\n         {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n         {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark",
    "result_reason": "error: operand expected (error token is \"=\")",
    "test_result": "ERROR"
}