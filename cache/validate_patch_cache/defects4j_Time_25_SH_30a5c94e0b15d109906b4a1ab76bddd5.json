{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    if ((offsetLocal - offsetAdjusted) < 0) {\n        // if we just return offsetAdjusted then the time is pushed\n        // back before the transition, whereas it should be\n        // on or after the transition\n        long nextLocal = nextTransition(instantAdjusted);\n        long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n        if (nextLocal != nextAdjusted) {\n            // Moscow has a special case. If we are in the \"impossible\" hour\n            // then return the original (winter) offset.\n            int offsetBefore = getOffset(nextLocal - 1);\n            int offsetAfter = getOffset(nextLocal);\n            if (offsetBefore > offsetAfter) {\n                if (offsetAdjusted == offsetBefore && offsetLocal == offsetAfter) {\n                    long nextGap = nextGap(nextLocal);\n                    if (instantLocal + offsetLocal < nextGap) {\n                        // We are before the second transition.\n                        return offsetBefore;\n                    } else if (instantLocal + offsetLocal == nextGap && nextGap == nextTransition(nextGap - 1)) {\n                        // We are in the \"monthly\" overlap period.\n                        return offsetAfter;\n                    } else {\n                        // We are after the second transition.\n                        return offsetAfter;  // changed from offset adjusted\n                    }\n                } else if (offsetAdjusted == offsetAfter && offsetLocal == offsetBefore) {\n                    long nextGap = nextGap(nextLocal);\n                    if (instantLocal + offsetLocal >= nextGap) {\n                        // We are after the first transition.\n                        return offsetAfter;\n                    } else if (instantLocal + offsetLocal == (nextGap - 1) && nextGap - 1 == previousTransition(nextGap - 1)) {\n                        // We are in the \"monthly\" overlap period.\n                        return offsetBefore;\n                    } else {\n                        // We are before the first transition.\n                        return offsetBefore; // changed from offsetAdjusted\n                    }\n                }\n            }\n            \n            // if the gap is shorter than the time that has moved, only move back\n            long nextLocalDiff = nextLocal - instantAdjusted;\n            long nextAdjustDiff = instantLocal - offsetAdjusted - nextAdjusted;\n            if ((nextAdjusted > offsetLocal) && (nextLocalDiff * 2 > nextAdjustDiff)) {\n                return offsetLocal;\n            }\n            \n            // handle off-by-one error when crossing time zone boundary\n            int newOffset = getOffset(nextLocal);\n            if (offsetLocal < newOffset) {\n                return offsetLocal;\n            } else {\n                return newOffset;\n            }\n        } else {\n            if (offsetAdjusted != -3) {\n                return offsetAdjusted;\n            }\n            return fixOffsetForSpecialCaseZone(nextLocal, instantLocal, offsetLocal, offsetAdjusted);\n        }\n    } else {\n        long prevLocal = previousTransition(instantAdjusted);\n        long prevAdjusted = previousTransition(instantLocal - offsetLocal);\n        if (prevLocal != prevAdjusted) {\n            long prevLocalDiff = instantAdjusted - prevLocal;\n            long prevAdjustDiff = prevAdjusted + offsetLocal - instantLocal;\n            if ((offsetLocal > offsetAdjusted) && (prevLocalDiff * 2 <= prevAdjustDiff)) {\n                return offsetLocal;\n            }\n            int newOffset = getOffset(prevLocal);\n            if (offsetLocal > newOffset) {\n                return offsetLocal;\n            } else {\n                return newOffset;\n            }\n        } else {\n            if (offsetAdjusted != -3) {\n                return offsetAdjusted;\n            }\n            return fixOffsetForSpecialCaseZone(prevLocal, instantLocal, offsetLocal, offsetAdjusted);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..3060f507 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,89 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    if ((offsetLocal - offsetAdjusted) < 0) {\n+        // if we just return offsetAdjusted then the time is pushed\n+        // back before the transition, whereas it should be\n+        // on or after the transition\n+        long nextLocal = nextTransition(instantAdjusted);\n+        long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n+        if (nextLocal != nextAdjusted) {\n+            // Moscow has a special case. If we are in the \"impossible\" hour\n+            // then return the original (winter) offset.\n+            int offsetBefore = getOffset(nextLocal - 1);\n+            int offsetAfter = getOffset(nextLocal);\n+            if (offsetBefore > offsetAfter) {\n+                if (offsetAdjusted == offsetBefore && offsetLocal == offsetAfter) {\n+                    long nextGap = nextGap(nextLocal);\n+                    if (instantLocal + offsetLocal < nextGap) {\n+                        // We are before the second transition.\n+                        return offsetBefore;\n+                    } else if (instantLocal + offsetLocal == nextGap && nextGap == nextTransition(nextGap - 1)) {\n+                        // We are in the \"monthly\" overlap period.\n+                        return offsetAfter;\n+                    } else {\n+                        // We are after the second transition.\n+                        return offsetAfter;  // changed from offset adjusted\n+                    }\n+                } else if (offsetAdjusted == offsetAfter && offsetLocal == offsetBefore) {\n+                    long nextGap = nextGap(nextLocal);\n+                    if (instantLocal + offsetLocal >= nextGap) {\n+                        // We are after the first transition.\n+                        return offsetAfter;\n+                    } else if (instantLocal + offsetLocal == (nextGap - 1) && nextGap - 1 == previousTransition(nextGap - 1)) {\n+                        // We are in the \"monthly\" overlap period.\n+                        return offsetBefore;\n+                    } else {\n+                        // We are before the first transition.\n+                        return offsetBefore; // changed from offsetAdjusted\n+                    }\n+                }\n+            }\n+            \n+            // if the gap is shorter than the time that has moved, only move back\n+            long nextLocalDiff = nextLocal - instantAdjusted;\n+            long nextAdjustDiff = instantLocal - offsetAdjusted - nextAdjusted;\n+            if ((nextAdjusted > offsetLocal) && (nextLocalDiff * 2 > nextAdjustDiff)) {\n+                return offsetLocal;\n+            }\n+            \n+            // handle off-by-one error when crossing time zone boundary\n+            int newOffset = getOffset(nextLocal);\n+            if (offsetLocal < newOffset) {\n+                return offsetLocal;\n+            } else {\n+                return newOffset;\n+            }\n+        } else {\n+            if (offsetAdjusted != -3) {\n+                return offsetAdjusted;\n+            }\n+            return fixOffsetForSpecialCaseZone(nextLocal, instantLocal, offsetLocal, offsetAdjusted);\n+        }\n+    } else {\n+        long prevLocal = previousTransition(instantAdjusted);\n+        long prevAdjusted = previousTransition(instantLocal - offsetLocal);\n+        if (prevLocal != prevAdjusted) {\n+            long prevLocalDiff = instantAdjusted - prevLocal;\n+            long prevAdjustDiff = prevAdjusted + offsetLocal - instantLocal;\n+            if ((offsetLocal > offsetAdjusted) && (prevLocalDiff * 2 <= prevAdjustDiff)) {\n+                return offsetLocal;\n+            }\n+            int newOffset = getOffset(prevLocal);\n+            if (offsetLocal > newOffset) {\n+                return offsetLocal;\n+            } else {\n+                return newOffset;\n+            }\n+        } else {\n+            if (offsetAdjusted != -3) {\n+                return offsetAdjusted;\n+            }\n+            return fixOffsetForSpecialCaseZone(prevLocal, instantLocal, offsetLocal, offsetAdjusted);\n+        }\n+    }\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}