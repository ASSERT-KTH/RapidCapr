{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    // we need to ensure that time is always after the DST gap\n    // this happens naturally for positive offsets, but not for negative\n    if ((offsetLocal - offsetAdjusted) < 0) {\n       // if we just return offsetAdjusted then the time is pushed\n       // back before the transition, whereas it should be\n       // on or after the transition\n       long nextLocal = nextTransition(instantAdjusted);\n       long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n       if (nextLocal != nextAdjusted) {\n           // We need to handle the case where the next transition is right at instantLocal\n           // Otherwise we may end up with the wrong offset (one hour too large)\n           long nextLocalPrev = previousTransition(instantLocal - offsetLocal);\n           if (nextLocalPrev == instantLocal - offsetLocal) {\n               return offsetLocal;\n           }\n           int beforeDiff = offsetLocal - getOffset(nextLocal - 1);\n           int afterDiff = getOffset(nextAdjusted) - offsetAdjusted;\n           if (beforeDiff < afterDiff) {\n               return offsetLocal;\n           }\n           if (beforeDiff > afterDiff) {\n               return offsetAdjusted;\n           }\n       } else {\n           if ((nextLocal + offsetLocal) == (nextAdjusted + offsetAdjusted)) {\n               // Ambiguous local time around transition\n               return offsetLocal;\n           }\n           long prevLocal = previousTransition(instantAdjusted);\n           long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n           if (prevLocal != prevAdjusted) {\n               return offsetAdjusted;\n           }\n           return offsetLocal;\n       }\n   } else if ((offsetLocal - offsetAdjusted) > 0) {\n       // Positive offset change implies a gap in spring\n       // which clocks in local time move forward\n       long next = nextTransition(instantAdjusted);\n       if (next <= instantLocal) {\n           next = nextTransition(next);\n       }\n       return getOffset(next);\n   } else {\n       long prevLocal = previousTransition(instantAdjusted);\n       long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n       if (prevLocal != prevAdjusted) {\n            return offsetLocal;\n        }\n   }\n}\nreturn offsetAdjusted;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..4fbd8677 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,59 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    // we need to ensure that time is always after the DST gap\n+    // this happens naturally for positive offsets, but not for negative\n+    if ((offsetLocal - offsetAdjusted) < 0) {\n+       // if we just return offsetAdjusted then the time is pushed\n+       // back before the transition, whereas it should be\n+       // on or after the transition\n+       long nextLocal = nextTransition(instantAdjusted);\n+       long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n+       if (nextLocal != nextAdjusted) {\n+           // We need to handle the case where the next transition is right at instantLocal\n+           // Otherwise we may end up with the wrong offset (one hour too large)\n+           long nextLocalPrev = previousTransition(instantLocal - offsetLocal);\n+           if (nextLocalPrev == instantLocal - offsetLocal) {\n+               return offsetLocal;\n+           }\n+           int beforeDiff = offsetLocal - getOffset(nextLocal - 1);\n+           int afterDiff = getOffset(nextAdjusted) - offsetAdjusted;\n+           if (beforeDiff < afterDiff) {\n+               return offsetLocal;\n+           }\n+           if (beforeDiff > afterDiff) {\n+               return offsetAdjusted;\n+           }\n+       } else {\n+           if ((nextLocal + offsetLocal) == (nextAdjusted + offsetAdjusted)) {\n+               // Ambiguous local time around transition\n+               return offsetLocal;\n+           }\n+           long prevLocal = previousTransition(instantAdjusted);\n+           long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n+           if (prevLocal != prevAdjusted) {\n+               return offsetAdjusted;\n+           }\n+           return offsetLocal;\n+       }\n+   } else if ((offsetLocal - offsetAdjusted) > 0) {\n+       // Positive offset change implies a gap in spring\n+       // which clocks in local time move forward\n+       long next = nextTransition(instantAdjusted);\n+       if (next <= instantLocal) {\n+           next = nextTransition(next);\n+       }\n+       return getOffset(next);\n+   } else {\n+       long prevLocal = previousTransition(instantAdjusted);\n+       long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n+       if (prevLocal != prevAdjusted) {\n+            return offsetLocal;\n+        }\n+   }\n+}\n+return offsetAdjusted;\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.AssertionFailedError: expected:<false> but was:<true>",
    "test_result": "FAIL"
}