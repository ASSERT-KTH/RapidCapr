{
    "patch": "import com.google.javascript.jscomp.*;\nimport com.google.javascript.rhino.Node;\n\nclass MyCustomPass extends AbstractPostOrderCallback implements HotSwapCompilerPass {\n    private final Compiler compiler;\n    private ScopeCreator scopeCreator;\n    private Scope scope;\n    private Scope functionScope;\n\n    public MyCustomPass(Compiler compiler) {\n        this.compiler = compiler;\n    }\n\n    @Override\n    public void process(Node externs, Node root) {\n        scopeCreator = new SyntacticScopeCreator(compiler);\n        NodeTraversal.traverse(compiler, root, this);\n    }\n\n    @Override\n    public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n        scopeCreator = new SyntacticScopeCreator(compiler);\n        NodeTraversal.traverse(compiler, scriptRoot, this);\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n        if (n == t.getScopeRoot()) {\n            resetContext();\n            functionScope = new Scope(scopeCreator, Scope.Type.FUNCTION);\n            scope = new Scope(scopeCreator, Scope.Type.BLOCK, functionScope);\n        }\n\n        if (n.isScript()) {\n            resetContext();\n            return;\n        }\n\n        attachLiteralTypes(n);\n\n        switch (n.getToken()) {\n            case FUNCTION:\n                if (parent == null || parent.getToken() != Token.EXPR_RESULT) {\n                    defineDeclaredFunction(n, parent);\n                } else {\n                    defineFunctionExpression(n, parent);\n                }\n                break;\n\n            case CATCH:\n                defineCatch(n, parent);\n                break;\n\n            case VAR:\n            case LET:\n            case CONST:\n                defineVar(n, parent);\n                break;\n\n            case LP:\n                if (parent.getToken() == Token.EXPR_RESULT && parent.getFirstChild().isFunction()) {\n                    handleFunctionInputs(n);\n                }\n                break;\n\n            default:\n                break;\n        }\n\n        if (n == t.getScopeRoot()) {\n            scope = null;\n            functionScope = null;\n        }\n    }\n\n    private void defineDeclaredFunction(Node function, Node parent) {\n        String name = null;\n        Node fnNameNode = function.getFirstChild();\n        if (fnNameNode != null) {\n            name = fnNameNode.getString();\n        }\n\n        Node functionBlock = function.getLastChild();\n\n        if (name != null) {\n            if (parent != null && parent.isCatch()) {\n                declareVarInScope(name, parent);\n            } else if (scope.getVar(name) != null) {\n                compiler.report(JSError.make(function, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, name));\n            } else {\n                scope.declare(name, function, null);\n            }\n        }\n\n        Scope oldFunctionScope = functionScope;\n        if (fnNameNode != null) {\n            functionScope = new Scope(scopeCreator, Scope.Type.FUNCTION, functionScope);\n            if (name != null) {\n                oldFunctionScope.declare(name, function, null);\n            }\n        } else {\n            functionScope = new Scope(scopeCreator, Scope.Type.FUNCTION, functionScope);\n        }\n\n        if (name != null) {\n            defineSlot(name, null, false, functionBlock, null);\n        }\n\n        visitFunctionParamList(function);\n\n        if (NodeUtil.isFunctionDeclaration(function)) {\n            Node enclosingBlock = NodeUtil.getEnclosingStatement(function);\n            if (enclosingBlock.getType() == Token.SCRIPT || enclosingBlock.getType() == Token.BLOCK) {\n                NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.FUNCTION_DECLARATIONS);\n            }\n            function.detach();\n            enclosingBlock.addChildToFront(function);\n            compiler.reportCodeChange();\n        }\n\n        NodeTraversal.traverse(compiler, functionBlock, this);\n\n        functionScope = oldFunctionScope;\n    }\n\n    private void visitFunctionParamList(Node function) {\n        Node paramList = function.getChildAtIndex(1);\n        int i = 0;\n        for (Node param = paramList.getFirstChild(); param != null; param = param.getNext(), i++) {\n            String paramName = param.getString();\n            if (paramName.isEmpty()) {\n                paramName = \"<noname\" + Integer.toString(i) + \">\";\n            }\n            defineSlot(paramName, null, false, param, null);\n        }\n    }\n\n    private void handleFunctionInputs(Node lp) {\n        checkState(lp.isParamList());\n        checkState(lp.getParent().isFunction());\n        List<Node> inputs = new ArrayList<>();\n        for (Node input : lp.children()) {\n            inputs.add(input);\n        }\n        lp.removeChildren();\n        boolean lastWasRest = false;\n        for (Node input : inputs) {\n            if (!lastWasRest && input.getToken() == Token.NAME) {\n                defineSlot(input.getString(), null, false, lp, null);\n            } else if (lastWasRest) {\n                compiler.report(JSError.make(input, RhinoErrorReporter.BAD_FUNCTION_ARG_REST_NOT_LAST));\n            }\n            lp.addChildToBack(input);\n            lastWasRest = input.isRest();\n        }\n    }\n\n    private void defineCatch(Node catchNode, Node parent) {\n        String name = catchNode.getFirstChild().getString();\n        if (scope.getVar(name) != null) {\n            compiler.report(JSError.make(catchNode, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, name));\n        } else {\n            if (parent != null && parent.isCatch()) {\n                declareVarInScope(name, parent);\n            } else {\n                scope.declare(name, catchNode, null);\n            }\n        }\n        Node catchBlock = catchNode.getLastChild();\n        visitBlock(catchBlock);\n    }\n\n    private void defineFunctionExpression(Node function, Node parent) {\n        Node fnNameNode = function.getFirstChild();\n        if (fnNameNode != null) {\n            defineSlot(fnNameNode.getString(), null, false, parent, null);\n        }\n        Node exprResult = parent;\n        function.detach();\n        parent.replaceChild(function, IR.number(0));\n        compiler.reportCodeChange();\n        NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.FUNCTION_DECLARATIONS);\n        visitFunctionParamList(function);\n        NodeTraversal.traverse(compiler, function.getLastChild(), this);\n        function.addChildToBack(new Node(Token.RETURN));\n        exprResult.replaceChild(IR.exprResult(function), IR.returnNode(function.removeFirstChild()));\n        compiler.reportCodeChange();\n    }\n\n    private void defineVar(Node varNode, Node parent) {\n        for (Node child : varNode.children()) {\n            String name = child.getString();\n            if (scope.getVar(name) != null) {\n                compiler.report(JSError.make(varNode, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, name));\n            } else {\n                if (parent != null && parent.isCatch()) {\n                    declareVarInScope(name, parent);\n                } else {\n                    scope.declare(name, varNode, null);\n                }\n            }\n        }\n    }\n\n    private void declareVarInScope(String name, Node scopeRoot) {\n        for (Scope s = scope; s != null; s = s.getParent()) {\n            if (s.getRootNode() == scopeRoot) {\n                s.declare(name, null, null);\n                return;\n            }\n        }\n        scope.declare(name, null, null); // This won't happen, but better to notify the user correctly.\n    }\n\n    private void defineSlot(String name, TypeI type, boolean inferred, Node node, InitializationKind initKind) {\n        Var v = scope.getVar(name);\n        if (v == null) {\n            // We may not have type information yet, so rely on the scope to create a typed var\n            // when we learn more information later.\n            v = scope.declare(name, node, null);\n        } else if (v.getScope() != functionScope) {\n            // If the var is already in a scope above the function scope and we are not in a nested\n            // function, don't change the var (since doing so would make the var local to the\n            // function).\n            checkState(NodeUtil.getEnclosingFunction(node) != null);\n        }\n        if (type != null) {\n            v.setType(type);\n        }\n        if (initKind != null) {\n            checkState(node.isName() || node.isGetProp());\n            v.setInitializationKind(initKind, node);\n        }\n        v.setInferredType(type == null || inferred);\n    }\n\n    private void attachLiteralTypes(Node n) {\n        switch (n.getToken()) {\n            case TRUE:\n            case FALSE:\n                n.setJSType(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n                break;\n            case NUMBER:\n                n.setJSType(getNativeType(JSTypeNative.NUMBER_TYPE));\n                break;\n            case STRING:\n                n.setJSType(getNativeType(JSTypeNative.STRING_TYPE));\n                break;\n            case NULL:\n                n.setJSType(getNativeType(JSTypeNative.NULL_TYPE));\n                break;\n            default:\n                break;\n        }\n    }\n\n    private JSType getNativeType(JSTypeNative typeId) {\n        return compiler.getTypeRegistry().getNativeType(typeId);\n    }\n\n    private void resetContext() {\n        scope = null;\n        functionScope = null;\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..a19cec89 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1440,31 +1440,272 @@ final class TypedScopeCreator implements ScopeCreator {\n      * @param n The node being visited.\n      * @param parent The parent of n\n      */\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n == scope.getRootNode()) return;\n+import com.google.javascript.jscomp.*;\n+import com.google.javascript.rhino.Node;\n \n-      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n-        handleFunctionInputs(parent);\n-        return;\n-      }\n+class MyCustomPass extends AbstractPostOrderCallback implements HotSwapCompilerPass {\n+    private final Compiler compiler;\n+    private ScopeCreator scopeCreator;\n+    private Scope scope;\n+    private Scope functionScope;\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n+    public MyCustomPass(Compiler compiler) {\n+        this.compiler = compiler;\n+    }\n+\n+    @Override\n+    public void process(Node externs, Node root) {\n+        scopeCreator = new SyntacticScopeCreator(compiler);\n+        NodeTraversal.traverse(compiler, root, this);\n+    }\n+\n+    @Override\n+    public void hotSwapScript(Node scriptRoot, Node originalRoot) {\n+        scopeCreator = new SyntacticScopeCreator(compiler);\n+        NodeTraversal.traverse(compiler, scriptRoot, this);\n+    }\n+\n+    @Override\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (n == t.getScopeRoot()) {\n+            resetContext();\n+            functionScope = new Scope(scopeCreator, Scope.Type.FUNCTION);\n+            scope = new Scope(scopeCreator, Scope.Type.BLOCK, functionScope);\n+        }\n+\n+        if (n.isScript()) {\n+            resetContext();\n             return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+        }\n+\n+        attachLiteralTypes(n);\n+\n+        switch (n.getToken()) {\n+            case FUNCTION:\n+                if (parent == null || parent.getToken() != Token.EXPR_RESULT) {\n+                    defineDeclaredFunction(n, parent);\n+                } else {\n+                    defineFunctionExpression(n, parent);\n+                }\n+                break;\n+\n+            case CATCH:\n+                defineCatch(n, parent);\n+                break;\n+\n+            case VAR:\n+            case LET:\n+            case CONST:\n+                defineVar(n, parent);\n+                break;\n+\n+            case LP:\n+                if (parent.getToken() == Token.EXPR_RESULT && parent.getFirstChild().isFunction()) {\n+                    handleFunctionInputs(n);\n+                }\n+                break;\n+\n+            default:\n+                break;\n+        }\n+\n+        if (n == t.getScopeRoot()) {\n+            scope = null;\n+            functionScope = null;\n+        }\n+    }\n+\n+    private void defineDeclaredFunction(Node function, Node parent) {\n+        String name = null;\n+        Node fnNameNode = function.getFirstChild();\n+        if (fnNameNode != null) {\n+            name = fnNameNode.getString();\n+        }\n+\n+        Node functionBlock = function.getLastChild();\n+\n+        if (name != null) {\n+            if (parent != null && parent.isCatch()) {\n+                declareVarInScope(name, parent);\n+            } else if (scope.getVar(name) != null) {\n+                compiler.report(JSError.make(function, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, name));\n+            } else {\n+                scope.declare(name, function, null);\n+            }\n+        }\n+\n+        Scope oldFunctionScope = functionScope;\n+        if (fnNameNode != null) {\n+            functionScope = new Scope(scopeCreator, Scope.Type.FUNCTION, functionScope);\n+            if (name != null) {\n+                oldFunctionScope.declare(name, function, null);\n+            }\n+        } else {\n+            functionScope = new Scope(scopeCreator, Scope.Type.FUNCTION, functionScope);\n+        }\n+\n+        if (name != null) {\n+            defineSlot(name, null, false, functionBlock, null);\n+        }\n+\n+        visitFunctionParamList(function);\n+\n+        if (NodeUtil.isFunctionDeclaration(function)) {\n+            Node enclosingBlock = NodeUtil.getEnclosingStatement(function);\n+            if (enclosingBlock.getType() == Token.SCRIPT || enclosingBlock.getType() == Token.BLOCK) {\n+                NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.FUNCTION_DECLARATIONS);\n+            }\n+            function.detach();\n+            enclosingBlock.addChildToFront(function);\n+            compiler.reportCodeChange();\n+        }\n+\n+        NodeTraversal.traverse(compiler, functionBlock, this);\n+\n+        functionScope = oldFunctionScope;\n+    }\n+\n+    private void visitFunctionParamList(Node function) {\n+        Node paramList = function.getChildAtIndex(1);\n+        int i = 0;\n+        for (Node param = paramList.getFirstChild(); param != null; param = param.getNext(), i++) {\n+            String paramName = param.getString();\n+            if (paramName.isEmpty()) {\n+                paramName = \"<noname\" + Integer.toString(i) + \">\";\n+            }\n+            defineSlot(paramName, null, false, param, null);\n+        }\n+    }\n+\n+    private void handleFunctionInputs(Node lp) {\n+        checkState(lp.isParamList());\n+        checkState(lp.getParent().isFunction());\n+        List<Node> inputs = new ArrayList<>();\n+        for (Node input : lp.children()) {\n+            inputs.add(input);\n+        }\n+        lp.removeChildren();\n+        boolean lastWasRest = false;\n+        for (Node input : inputs) {\n+            if (!lastWasRest && input.getToken() == Token.NAME) {\n+                defineSlot(input.getString(), null, false, lp, null);\n+            } else if (lastWasRest) {\n+                compiler.report(JSError.make(input, RhinoErrorReporter.BAD_FUNCTION_ARG_REST_NOT_LAST));\n+            }\n+            lp.addChildToBack(input);\n+            lastWasRest = input.isRest();\n+        }\n+    }\n+\n+    private void defineCatch(Node catchNode, Node parent) {\n+        String name = catchNode.getFirstChild().getString();\n+        if (scope.getVar(name) != null) {\n+            compiler.report(JSError.make(catchNode, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, name));\n+        } else {\n+            if (parent != null && parent.isCatch()) {\n+                declareVarInScope(name, parent);\n+            } else {\n+                scope.declare(name, catchNode, null);\n+            }\n+        }\n+        Node catchBlock = catchNode.getLastChild();\n+        visitBlock(catchBlock);\n+    }\n+\n+    private void defineFunctionExpression(Node function, Node parent) {\n+        Node fnNameNode = function.getFirstChild();\n+        if (fnNameNode != null) {\n+            defineSlot(fnNameNode.getString(), null, false, parent, null);\n+        }\n+        Node exprResult = parent;\n+        function.detach();\n+        parent.replaceChild(function, IR.number(0));\n+        compiler.reportCodeChange();\n+        NodeUtil.addFeatureToScript(t.getCurrentScript(), Feature.FUNCTION_DECLARATIONS);\n+        visitFunctionParamList(function);\n+        NodeTraversal.traverse(compiler, function.getLastChild(), this);\n+        function.addChildToBack(new Node(Token.RETURN));\n+        exprResult.replaceChild(IR.exprResult(function), IR.returnNode(function.removeFirstChild()));\n+        compiler.reportCodeChange();\n     }\n \n+    private void defineVar(Node varNode, Node parent) {\n+        for (Node child : varNode.children()) {\n+            String name = child.getString();\n+            if (scope.getVar(name) != null) {\n+                compiler.report(JSError.make(varNode, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, name));\n+            } else {\n+                if (parent != null && parent.isCatch()) {\n+                    declareVarInScope(name, parent);\n+                } else {\n+                    scope.declare(name, varNode, null);\n+                }\n+            }\n+        }\n+    }\n+\n+    private void declareVarInScope(String name, Node scopeRoot) {\n+        for (Scope s = scope; s != null; s = s.getParent()) {\n+            if (s.getRootNode() == scopeRoot) {\n+                s.declare(name, null, null);\n+                return;\n+            }\n+        }\n+        scope.declare(name, null, null); // This won't happen, but better to notify the user correctly.\n+    }\n+\n+    private void defineSlot(String name, TypeI type, boolean inferred, Node node, InitializationKind initKind) {\n+        Var v = scope.getVar(name);\n+        if (v == null) {\n+            // We may not have type information yet, so rely on the scope to create a typed var\n+            // when we learn more information later.\n+            v = scope.declare(name, node, null);\n+        } else if (v.getScope() != functionScope) {\n+            // If the var is already in a scope above the function scope and we are not in a nested\n+            // function, don't change the var (since doing so would make the var local to the\n+            // function).\n+            checkState(NodeUtil.getEnclosingFunction(node) != null);\n+        }\n+        if (type != null) {\n+            v.setType(type);\n+        }\n+        if (initKind != null) {\n+            checkState(node.isName() || node.isGetProp());\n+            v.setInitializationKind(initKind, node);\n+        }\n+        v.setInferredType(type == null || inferred);\n+    }\n+\n+    private void attachLiteralTypes(Node n) {\n+        switch (n.getToken()) {\n+            case TRUE:\n+            case FALSE:\n+                n.setJSType(getNativeType(JSTypeNative.BOOLEAN_TYPE));\n+                break;\n+            case NUMBER:\n+                n.setJSType(getNativeType(JSTypeNative.NUMBER_TYPE));\n+                break;\n+            case STRING:\n+                n.setJSType(getNativeType(JSTypeNative.STRING_TYPE));\n+                break;\n+            case NULL:\n+                n.setJSType(getNativeType(JSTypeNative.NULL_TYPE));\n+                break;\n+            default:\n+                break;\n+        }\n+    }\n+\n+    private JSType getNativeType(JSTypeNative typeId) {\n+        return compiler.getTypeRegistry().getNativeType(typeId);\n+    }\n+\n+    private void resetContext() {\n+        scope = null;\n+        functionScope = null;\n+    }\n+}\n+\n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {\n       // Handle bleeding functions.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}