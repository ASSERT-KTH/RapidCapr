{
    "patch": "        // Check if min and max bracket the root\n        double yMin = f.value(min);\n        double yMax = f.value(max);\n        if (yMin * yMax >= 0) {\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n        }\n\n        double x0 = initial;\n        double y0 = f.value(x0);\n        double yPrev = y0;\n\n        double x1 = Double.NaN;\n        double y1 = Double.NaN;\n\n        double x2 = Double.NaN;\n        double y2 = Double.NaN;\n\n        double delta = 0.0;\n        double tmp = 0.0;\n        double previousDelta = Double.NaN;\n        double fMinTest = 0.0;\n        double fMaxTest = 0.0;\n        while (++iterationCount <= maximalIterationCount) {\n            if (y0 * yMin >= 0) {\n                // switch min with x0\n                tmp = min;\n                min = x0;\n                x0 = tmp;\n\n                tmp = yMin;\n                yMin = y0;\n                y0 = tmp;\n            }\n\n            if (y0 * yMax >= 0) {\n                // switch max with x0\n                tmp = max;\n                max = x0;\n                x0 = tmp;\n\n                tmp = yMax;\n                yMax = y0;\n                y0 = tmp;\n            }\n\n            // Test convergence and apply bisection if not converged.\n            delta = (xMax - xMin) / 2.0;\n            if (Math.abs(delta) <= absoluteAccuracy ||\n                (relativeAccuracy * Math.abs(x0)) <= absoluteAccuracy) {\n                setResult(x0, 0);\n                return result;\n            }\n\n            if (iterationCount == 1 || Math.abs(previousDelta) <= absoluteAccuracy ||\n                Math.abs(y0) <= functionValueAccuracy) {\n                // If delta is small enough, force bisection\n                delta = xTolerance;\n                if (xMin == x0 || xMax == x0) {\n                    // Extremely small range\n                    delta = relativeAccuracy * (xMax - xMin);\n                }\n            }\n\n            previousDelta = delta;\n\n            x1 = x0;\n            y1 = y0;\n            fMinTest = (yMin == y0) ? fMaxTest : yMin;\n            x2 = xMax;\n            y2 = yMax;\n            double extrapolationAllowed = true;\n\n            if (!(yMin * y0 < 0)) {\n                // min is not a root\n                xMin = x0;\n                yMin = y0;\n            } else if (!(yMax * y0 < 0)) {\n                // max is not a root\n                xMax = x0;\n                yMax = y0;\n            } else {\n                // neither min nor max are roots: check if midpoint is a root\n                y2 = y1;\n            }\n\n            if (extrapolationAllowed) {\n                tmp = y1 / (y1 - y2);\n                x0 = x1 + tmp * (x2 - x1);\n            } else {\n                // Default case when extrapolation is too risky\n                x0 = delta * 0.5 + xMin;\n            }\n\n            y0 = f.value(x0);\n\n            // Update intervals\n            if (y0 * yMin < 0) {\n                xMax = x1;\n                yMax = y1;\n            } else if (y0 * yMax < 0) {\n                xMin = x1;\n                yMin = y1;\n            } else if (y0 == 0.0) {\n                setResult(x0, 0);\n                return result;\n            } else if (y1 == 0.0 || y2 == 0.0) {\n                // If already one endpoint is a root\n                if (y1 == 0.0) {\n                    setResult(x1, 0);\n                } else {\n                    setResult(x2, 0);\n                }\n                return result;\n            } else {\n                // Default\n                x0 = delta * 0.5 + xMin;\n                y0 = f.value(x0);\n                xMin = x0;\n                yMin = y0;\n                xMax = x2;\n                yMax = y2;\n            }\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..a52725105 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,131 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        // Check if min and max bracket the root\n+        double yMin = f.value(min);\n+        double yMax = f.value(max);\n+        if (yMin * yMax >= 0) {\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n+        }\n+\n+        double x0 = initial;\n+        double y0 = f.value(x0);\n+        double yPrev = y0;\n+\n+        double x1 = Double.NaN;\n+        double y1 = Double.NaN;\n+\n+        double x2 = Double.NaN;\n+        double y2 = Double.NaN;\n+\n+        double delta = 0.0;\n+        double tmp = 0.0;\n+        double previousDelta = Double.NaN;\n+        double fMinTest = 0.0;\n+        double fMaxTest = 0.0;\n+        while (++iterationCount <= maximalIterationCount) {\n+            if (y0 * yMin >= 0) {\n+                // switch min with x0\n+                tmp = min;\n+                min = x0;\n+                x0 = tmp;\n+\n+                tmp = yMin;\n+                yMin = y0;\n+                y0 = tmp;\n+            }\n+\n+            if (y0 * yMax >= 0) {\n+                // switch max with x0\n+                tmp = max;\n+                max = x0;\n+                x0 = tmp;\n+\n+                tmp = yMax;\n+                yMax = y0;\n+                y0 = tmp;\n+            }\n+\n+            // Test convergence and apply bisection if not converged.\n+            delta = (xMax - xMin) / 2.0;\n+            if (Math.abs(delta) <= absoluteAccuracy ||\n+                (relativeAccuracy * Math.abs(x0)) <= absoluteAccuracy) {\n+                setResult(x0, 0);\n+                return result;\n+            }\n+\n+            if (iterationCount == 1 || Math.abs(previousDelta) <= absoluteAccuracy ||\n+                Math.abs(y0) <= functionValueAccuracy) {\n+                // If delta is small enough, force bisection\n+                delta = xTolerance;\n+                if (xMin == x0 || xMax == x0) {\n+                    // Extremely small range\n+                    delta = relativeAccuracy * (xMax - xMin);\n+                }\n+            }\n+\n+            previousDelta = delta;\n+\n+            x1 = x0;\n+            y1 = y0;\n+            fMinTest = (yMin == y0) ? fMaxTest : yMin;\n+            x2 = xMax;\n+            y2 = yMax;\n+            double extrapolationAllowed = true;\n+\n+            if (!(yMin * y0 < 0)) {\n+                // min is not a root\n+                xMin = x0;\n+                yMin = y0;\n+            } else if (!(yMax * y0 < 0)) {\n+                // max is not a root\n+                xMax = x0;\n+                yMax = y0;\n+            } else {\n+                // neither min nor max are roots: check if midpoint is a root\n+                y2 = y1;\n+            }\n+\n+            if (extrapolationAllowed) {\n+                tmp = y1 / (y1 - y2);\n+                x0 = x1 + tmp * (x2 - x1);\n+            } else {\n+                // Default case when extrapolation is too risky\n+                x0 = delta * 0.5 + xMin;\n+            }\n+\n+            y0 = f.value(x0);\n+\n+            // Update intervals\n+            if (y0 * yMin < 0) {\n+                xMax = x1;\n+                yMax = y1;\n+            } else if (y0 * yMax < 0) {\n+                xMin = x1;\n+                yMin = y1;\n+            } else if (y0 == 0.0) {\n+                setResult(x0, 0);\n+                return result;\n+            } else if (y1 == 0.0 || y2 == 0.0) {\n+                // If already one endpoint is a root\n+                if (y1 == 0.0) {\n+                    setResult(x1, 0);\n+                } else {\n+                    setResult(x2, 0);\n+                }\n+                return result;\n+            } else {\n+                // Default\n+                x0 = delta * 0.5 + xMin;\n+                y0 = f.value(x0);\n+                xMin = x0;\n+                yMin = y0;\n+                xMax = x2;\n+                yMax = y2;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: variable yMin is already defined in method solve(UnivariateRealFunction,double,double,double)",
    "test_result": "ERROR"
}