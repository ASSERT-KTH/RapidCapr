{
    "patch": "public class EventState implements Serializable, Comparable<EventState> {\n    private static final long serialVersionUID = 20130106L;\n    private final EventHandler handler;\n    private final double maxCheckInterval;\n    private final double convergence;\n    private final int maxIterationCount;\n    private final int maxEvaluations;\n    private final double threshold;\n    private final double threshold2;\n    private boolean inverse;\n    private boolean forward;\n    private boolean pendingEvent;\n    private boolean increasing;\n    private double referenceValue;\n    private boolean caughtUp;\n    private int count;\n    private int remainingEvaluations;\n    private int remainingIterations;\n    private double g0;\n    private double g1;\n    private double g;\n    private FactoredODE factoredODE;\n    private SecondaryEquations secondaryEquations;\n    private final Collection<SwitchingFunction> functions;\n    private final Collection<EventState> relatedEvents;\n    private final Collection<EventState> triggeringEvents;\n    private final Collection<StatefulODE> initiallyDisabled;\n    private final String name;\n    private final boolean merge;\n    private final int index;\n\n    public EventState(final EventHandler handler, final double maxCheckInterval,\n                      final double convergence, final int maxIterationCount, final int maxEvaluations,\n                      final double threshold, final double threshold2, final boolean forward,\n                      final Collection<StatefulODE> ode, final Collection<SwitchingFunction> functions,\n                      final Collection<EventState> relatedEvents, final String name, final boolean merge, final int index) {\n        this.handler = handler;\n        this.maxCheckInterval = maxCheckInterval;\n        this.convergence = convergence;\n        this.maxIterationCount = maxIterationCount;\n        this.maxEvaluations = maxEvaluations;\n        this.threshold = threshold;\n        this.threshold2 = threshold2;\n        this.functions = functions;\n        this.relatedEvents = relatedEvents;\n        this.triggeringEvents  = new HashSet<EventState>();\n        this.initiallyDisabled = new HashSet<StatefulODE>();\n        this.name = name;\n        this.merge = merge;\n        this.index = index;\n        this.forward = forward;\n        pendingEvent = true;\n        increasing = true;\n        referenceValue = Double.NaN;\n        caughtUp = false;\n        count = 0;\n        remainingEvaluations = maxEvaluations;\n        remainingIterations = maxIterationCount;\n\n        for (final StatefulODE e : ode) {\n            if (e instanceof MainStateJacobianProvider) {\n                factoredODE = ((MainStateJacobianProvider) e).getMainSetDimension() < e.getDimension() ?\n                        new FactoredODE((MainStateJacobianProvider) e) : null;\n                secondaryEquations = ((MainStateJacobianProvider) e).getSecondaryEquations();\n                break;\n            }\n        }\n        if (factoredODE == null) {\n            throw new MathIllegalArgumentException(LocalizedFormats.NO_MAIN_STATE_JACOBIAN, ode.iterator().next().getClass().getName());\n        }\n    }\n\n    public double getEventTime() {\n        return g0 / (g0 - g1);\n    }\n\n    public boolean isPendingEvent() {\n        if (pendingEvent) {\n            // the event is pending if direction has been determined\n            // and several tries have not failed to locate a bracketing interval\n            return (increasing || !Double.isNaN(referenceValue))\n                    && count < maxCheckInterval / convergence;\n        } else {\n            // once the event time is known, the event is no longer pending\n            return false;\n        }\n    }\n\n    public boolean evaluateStep(final FirstOrderIntegrator integrator) throws MathIllegalArgumentException {\n        if (remainingEvaluations <= 0) {\n            throw new EventsException(EventsException.MAX_COUNT_EXCEEDED, getName());\n        }\n        try {\n            g0 = 0;\n            for (final SwitchingFunction function : functions) {\n                g0 = Math.max(g0, increasing ? function.g(t0, y0) : -function.g(t0, y0));\n            }\n            if (Double.isNaN(referenceValue)) {\n                referenceValue = g0;\n            }\n            if (g0 < threshold) {\n                // immediately below threshold, assuming convergence is slow and rate is limited\n                g = Double.POSITIVE_INFINITY;\n            } else {\n                // search for g switching from positive to negative\n                final EventHandler.CaptureType[] types = new EventHandler.CaptureType[functions.size()];\n                final double[] y = factoredODE.computeReferenceState(getInterpolatedState(), merge);\n                double ta = t0;\n                double ga = g0 - threshold - 1;\n                double tb = Double.NaN;\n                double gb = Double.NaN;\n                IncreasingStateWrapper increasingWrapper = null;\n                if (increasing) {\n                    increasingWrapper = new IncreasingStateWrapper(this, ta, y);\n                }\n                final int order = integrator instanceof AdaptiveStepsizeIntegrator ?\n                        ((AdaptiveStepsizeIntegrator) integrator).getMaxOrder() :\n                        NONSTIFF_TESTING_ORDER;\n                for (int i = 0; i < maxIterationCount && Double.isNaN(g); ++i) {\n                    // step up to ta + h under local error control\n                    if (increasing ? !forward : forward) {\n                        ta = restrictStepToInterval(ta - maxCheckInterval, ta - convergence,\n                                increasingWrapper, integrator, order, threshold, types);\n                    } else {\n                        ta = restrictStepToInterval(ta + convergence, ta + maxCheckInterval,\n                                increasingWrapper, integrator, order, threshold, types);\n                    }\n                    interpolator.setSoftPreviousTime(t0);\n                    interpolator.setSoftCurrentTime(ta);\n                    interpolator.reset();\n                    for (final StatefulODE e : initiallyDisabled) {\n                        e.resetInitialState(interpolator.getInterpolatedState());\n                        e.setInterpolatedTime(interpolator.getInterpolatedTime());\n                    }\n                    // evaluate functions at ta\n                    boolean inside = true;\n                    gb = 0;\n                    tb = ta;\n                    for (final SwitchingFunction function : functions) {\n                        final double gaPrev = ga;\n                        ga = increasing ? function.g(ta, y) : -function.g(ta, y);\n                        gb = Math.max(gb, ga);\n                        if (gaPrev < threshold && ga > threshold) {\n                            // function switched from negative to positive\n                            inside = false;\n                            if ((increasing ? forward : !forward) && (i > 0 || count > 0 || !Double.isNaN(referenceValue))) {\n                                // there is a bracket ahead, or a reference value, compute it\n                                final BracketedStepHandler handler = new BracketedStepHandler(this, referenceValue, ta, ga,\n                                        threshold, threshold2, maxCheckInterval, convergence);\n                                final boolean needReliable = inside;\n                                if (!findRoot(new BracketingNthOrderBrentSolver(threshold, threshold2, 5), handler, ta - convergence, ta + maxCheckInterval, needReliable)) {\n                                    // no brackets were found from ta-convergence to ta+maxCheckInterval\n                                    throw new NonMonotonicSequenceException(ta - convergence, ta + maxCheckInterval, ga, gaPrev);\n                                }\n                                return true;\n                            } else {\n                                // no reference value, no bracket ahead, no problem\n                                g1 = ga;\n                                increasing = false;\n                                pendingEvent = false;\n                            }\n                            break;\n                        }\n                    }\n                    if (inside) {\n                        // all functions are below the threshold, no roots\n                        return false;\n                    }\n                }\n                if (Double.isNaN(g)) {\n                    throw new EventException(this, EventException.MAX_ITERATIONS_EXCEEDED);\n                }\n                if (g > 0) {\n                    return false;\n                }\n            }\n            return true;\n        } finally {\n            --remainingEvaluations;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..264a9aeff 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,188 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n-\n-            });\n-\n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n-                }\n+public class EventState implements Serializable, Comparable<EventState> {\n+    private static final long serialVersionUID = 20130106L;\n+    private final EventHandler handler;\n+    private final double maxCheckInterval;\n+    private final double convergence;\n+    private final int maxIterationCount;\n+    private final int maxEvaluations;\n+    private final double threshold;\n+    private final double threshold2;\n+    private boolean inverse;\n+    private boolean forward;\n+    private boolean pendingEvent;\n+    private boolean increasing;\n+    private double referenceValue;\n+    private boolean caughtUp;\n+    private int count;\n+    private int remainingEvaluations;\n+    private int remainingIterations;\n+    private double g0;\n+    private double g1;\n+    private double g;\n+    private FactoredODE factoredODE;\n+    private SecondaryEquations secondaryEquations;\n+    private final Collection<SwitchingFunction> functions;\n+    private final Collection<EventState> relatedEvents;\n+    private final Collection<EventState> triggeringEvents;\n+    private final Collection<StatefulODE> initiallyDisabled;\n+    private final String name;\n+    private final boolean merge;\n+    private final int index;\n+\n+    public EventState(final EventHandler handler, final double maxCheckInterval,\n+                      final double convergence, final int maxIterationCount, final int maxEvaluations,\n+                      final double threshold, final double threshold2, final boolean forward,\n+                      final Collection<StatefulODE> ode, final Collection<SwitchingFunction> functions,\n+                      final Collection<EventState> relatedEvents, final String name, final boolean merge, final int index) {\n+        this.handler = handler;\n+        this.maxCheckInterval = maxCheckInterval;\n+        this.convergence = convergence;\n+        this.maxIterationCount = maxIterationCount;\n+        this.maxEvaluations = maxEvaluations;\n+        this.threshold = threshold;\n+        this.threshold2 = threshold2;\n+        this.functions = functions;\n+        this.relatedEvents = relatedEvents;\n+        this.triggeringEvents  = new HashSet<EventState>();\n+        this.initiallyDisabled = new HashSet<StatefulODE>();\n+        this.name = name;\n+        this.merge = merge;\n+        this.index = index;\n+        this.forward = forward;\n+        pendingEvent = true;\n+        increasing = true;\n+        referenceValue = Double.NaN;\n+        caughtUp = false;\n+        count = 0;\n+        remainingEvaluations = maxEvaluations;\n+        remainingIterations = maxIterationCount;\n+\n+        for (final StatefulODE e : ode) {\n+            if (e instanceof MainStateJacobianProvider) {\n+                factoredODE = ((MainStateJacobianProvider) e).getMainSetDimension() < e.getDimension() ?\n+                        new FactoredODE((MainStateJacobianProvider) e) : null;\n+                secondaryEquations = ((MainStateJacobianProvider) e).getSecondaryEquations();\n+                break;\n             }\n+        }\n+        if (factoredODE == null) {\n+            throw new MathIllegalArgumentException(LocalizedFormats.NO_MAIN_STATE_JACOBIAN, ode.iterator().next().getClass().getName());\n+        }\n+    }\n \n-            while (!occuringEvents.isEmpty()) {\n-\n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n-\n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n-\n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+    public double getEventTime() {\n+        return g0 / (g0 - g1);\n+    }\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+    public boolean isPendingEvent() {\n+        if (pendingEvent) {\n+            // the event is pending if direction has been determined\n+            // and several tries have not failed to locate a bracketing interval\n+            return (increasing || !Double.isNaN(referenceValue))\n+                    && count < maxCheckInterval / convergence;\n+        } else {\n+            // once the event time is known, the event is no longer pending\n+            return false;\n+        }\n+    }\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+    public boolean evaluateStep(final FirstOrderIntegrator integrator) throws MathIllegalArgumentException {\n+        if (remainingEvaluations <= 0) {\n+            throw new EventsException(EventsException.MAX_COUNT_EXCEEDED, getName());\n+        }\n+        try {\n+            g0 = 0;\n+            for (final SwitchingFunction function : functions) {\n+                g0 = Math.max(g0, increasing ? function.g(t0, y0) : -function.g(t0, y0));\n+            }\n+            if (Double.isNaN(referenceValue)) {\n+                referenceValue = g0;\n+            }\n+            if (g0 < threshold) {\n+                // immediately below threshold, assuming convergence is slow and rate is limited\n+                g = Double.POSITIVE_INFINITY;\n+            } else {\n+                // search for g switching from positive to negative\n+                final EventHandler.CaptureType[] types = new EventHandler.CaptureType[functions.size()];\n+                final double[] y = factoredODE.computeReferenceState(getInterpolatedState(), merge);\n+                double ta = t0;\n+                double ga = g0 - threshold - 1;\n+                double tb = Double.NaN;\n+                double gb = Double.NaN;\n+                IncreasingStateWrapper increasingWrapper = null;\n+                if (increasing) {\n+                    increasingWrapper = new IncreasingStateWrapper(this, ta, y);\n                 }\n+                final int order = integrator instanceof AdaptiveStepsizeIntegrator ?\n+                        ((AdaptiveStepsizeIntegrator) integrator).getMaxOrder() :\n+                        NONSTIFF_TESTING_ORDER;\n+                for (int i = 0; i < maxIterationCount && Double.isNaN(g); ++i) {\n+                    // step up to ta + h under local error control\n+                    if (increasing ? !forward : forward) {\n+                        ta = restrictStepToInterval(ta - maxCheckInterval, ta - convergence,\n+                                increasingWrapper, integrator, order, threshold, types);\n+                    } else {\n+                        ta = restrictStepToInterval(ta + convergence, ta + maxCheckInterval,\n+                                increasingWrapper, integrator, order, threshold, types);\n+                    }\n+                    interpolator.setSoftPreviousTime(t0);\n+                    interpolator.setSoftCurrentTime(ta);\n+                    interpolator.reset();\n+                    for (final StatefulODE e : initiallyDisabled) {\n+                        e.resetInitialState(interpolator.getInterpolatedState());\n+                        e.setInterpolatedTime(interpolator.getInterpolatedTime());\n+                    }\n+                    // evaluate functions at ta\n+                    boolean inside = true;\n+                    gb = 0;\n+                    tb = ta;\n+                    for (final SwitchingFunction function : functions) {\n+                        final double gaPrev = ga;\n+                        ga = increasing ? function.g(ta, y) : -function.g(ta, y);\n+                        gb = Math.max(gb, ga);\n+                        if (gaPrev < threshold && ga > threshold) {\n+                            // function switched from negative to positive\n+                            inside = false;\n+                            if ((increasing ? forward : !forward) && (i > 0 || count > 0 || !Double.isNaN(referenceValue))) {\n+                                // there is a bracket ahead, or a reference value, compute it\n+                                final BracketedStepHandler handler = new BracketedStepHandler(this, referenceValue, ta, ga,\n+                                        threshold, threshold2, maxCheckInterval, convergence);\n+                                final boolean needReliable = inside;\n+                                if (!findRoot(new BracketingNthOrderBrentSolver(threshold, threshold2, 5), handler, ta - convergence, ta + maxCheckInterval, needReliable)) {\n+                                    // no brackets were found from ta-convergence to ta+maxCheckInterval\n+                                    throw new NonMonotonicSequenceException(ta - convergence, ta + maxCheckInterval, ga, gaPrev);\n+                                }\n+                                return true;\n+                            } else {\n+                                // no reference value, no bracket ahead, no problem\n+                                g1 = ga;\n+                                increasing = false;\n+                                pendingEvent = false;\n+                            }\n+                            break;\n+                        }\n+                    }\n+                    if (inside) {\n+                        // all functions are below the threshold, no roots\n+                        return false;\n+                    }\n+                }\n+                if (Double.isNaN(g)) {\n+                    throw new EventException(this, EventException.MAX_ITERATIONS_EXCEEDED);\n+                }\n+                if (g > 0) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        } finally {\n+            --remainingEvaluations;\n+        }\n+    }\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}