{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.NodeTraversal.Callback;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.StaticScope;\n\npublic class MyCallback implements Callback {\n\n  private AbstractCompiler compiler;\n  private Node rootNode;\n\n  public MyCallback(AbstractCompiler compiler, Node rootNode) {\n    this.compiler = compiler;\n    this.rootNode = rootNode;\n  }\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n    // We want to traverse all the nodes.\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    StaticScope scope = n.getScope();\n    if (scope != null && n.isFunction() && n != rootNode.getFirstChild()) {\n      SymbolTable symbolTable = new SymbolTable(compiler);\n      symbolTable.visitScope(scope);\n      if (symbolTable.shouldOptimizeAway(n)) {\n        parent.removeChild(n);\n        compiler.reportCodeChange();\n        return;\n      }\n    }\n    SideEffectFinder finder = new SideEffectFinder();\n    if (finder.apply(n)) {\n      Node call = NodeUtil.getEnclosingStatement(n);\n      if (call == null) {\n        return;\n      }\n      if (NodeUtil.isExpressionNode(call)) {\n        call = IR.exprResult(call);\n      }\n\n      Node parentra  = call.getParent();\n      parentra.replaceChild(call, NodeUtil.newUndefinedNode(call));\n      compiler.reportCodeChange();\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex a8e92fcc..ec643c75 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -99,6 +99,56 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n           return true;\n         }\n \n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.NodeTraversal.Callback;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.StaticScope;\n+\n+public class MyCallback implements Callback {\n+\n+  private AbstractCompiler compiler;\n+  private Node rootNode;\n+\n+  public MyCallback(AbstractCompiler compiler, Node rootNode) {\n+    this.compiler = compiler;\n+    this.rootNode = rootNode;\n+  }\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal nodeTraversal, Node node, Node parent) {\n+    // We want to traverse all the nodes.\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    StaticScope scope = n.getScope();\n+    if (scope != null && n.isFunction() && n != rootNode.getFirstChild()) {\n+      SymbolTable symbolTable = new SymbolTable(compiler);\n+      symbolTable.visitScope(scope);\n+      if (symbolTable.shouldOptimizeAway(n)) {\n+        parent.removeChild(n);\n+        compiler.reportCodeChange();\n+        return;\n+      }\n+    }\n+    SideEffectFinder finder = new SideEffectFinder();\n+    if (finder.apply(n)) {\n+      Node call = NodeUtil.getEnclosingStatement(n);\n+      if (call == null) {\n+        return;\n+      }\n+      if (NodeUtil.isExpressionNode(call)) {\n+        call = IR.exprResult(call);\n+      }\n+\n+      Node parentra  = call.getParent();\n+      parentra.replaceChild(call, NodeUtil.newUndefinedNode(call));\n+      compiler.reportCodeChange();\n+    }\n+  }\n+}\n \n         for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n           if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}