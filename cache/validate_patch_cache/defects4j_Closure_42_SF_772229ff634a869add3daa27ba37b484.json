{
    "patch": "public class IRFactory implements NodeTransformer<CompilerEnvirons> {\n\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n\n  IRFactory(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n        n.getFirstChild().isString() &&\n        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  /**\n   * Determines if this is a statement node for which the result is unused for the purpose\n   * of dead code detection.\n   */\n  private boolean isDeadCode(Node n) {\n    Token type = n.getToken();\n    return type == Token.EMPTY || type == Token.EXPR_RESULT || type == Token.BREAK ||\n        type == Token.CONTINUE;\n  }\n\n  private Node newNode(Token type, Node child1, Node child2, Node child3) {\n    Node n = new Node(type);\n    n.addChildToBack(child1);\n    if (child2 != null) {\n      n.addChildToBack(child2);\n      if (child3 != null) {\n        n.addChildToBack(child3);\n      }\n    }\n    return n;\n  }\n\n  private Node newNode(Token type, Node child) {\n    return newNode(type, child, null, null);\n  }\n\n  private Node newNode(Token type, Node child1, Node child2) {\n    return newNode(type, child1, child2, null);\n  }\n\n  private Node newNode(Token type) {\n    return newNode(type, null, null, null);\n  }\n\n  private Node newNode(Token type, String stringValue) {\n    Node node = newNode(type, (Node) null);\n    node.setString(stringValue);\n    return node;\n  }\n\n  @Override\n  public Node transform(Node node, CompilerEnvirons compilerEnvirons) {\n    NodeTraversal.traverse(compilerEnvirons.getParsePassConfig(), node, new DirectiveFinder());\n\n    Node root = IR.root();\n    NodeTraversal.traverse(compilerEnvirons.getPassConfig(), node, new GlobalNames(root));\n    node.detach();\n    root.addChildrenToFront(node);\n\n    NodeTraversal.traverse(compilerEnvirons.getPassConfig(), root, new PruneDeadCode());\n\n    return root;\n  }\n\n  /**\n   * A no-op transformer for use when you just want to apply any @link{Callback}s to an AST.\n   */\n  public static class NullCompiler extends Compiler {\n    private static final AbstractCompiler nullErrorReporter =\n        new AbstractCompiler() {\n          @Override\n          public void println(String str) {}\n\n          @Override\n          public void print(String str) {}\n        };\n\n    public NullCompiler(ErrorReporter errorReporter) {\n      super(nullErrorReporter);\n      setLifeCycleStage(LifeCycleStage.NORMALIZE);\n    }\n  }\n\n  private class DirectiveFinder extends AbstractPostOrderCallback {\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (isDirective(n)) {\n        t.reportCodeChange();\n      }\n    }\n  }\n\n  private class GlobalNames extends AbstractPostOrderCallback {\n    private final Node root;\n\n    private GlobalNames(Node root) {\n      this.root = root;\n    }\n\n    private Node getOrCreateDeclaration(String fullName, Node root) {\n      for (String part : fullName.split(\"\\\\.\")) {\n        boolean isNameDeclaration = (part == fullName);\n        if (root.hasChildren()) {\n          for (Node child = root.getFirstChild(); child != null; child = child.getNext()) {\n            if (child.matchesQualifiedName(part)) {\n              root = child;\n              break;\n            }\n          }\n        }\n        if (root == null || !root.matchesQualifiedName(part)) {\n          Node node = new Node(isNameDeclaration ? Token.NAME : Token.OBJECTLIT);\n          node.setString(part);\n          root = root.addChildToBack(node);\n        }\n      }\n      return root;\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (n.isName()) {\n        String fullName = n.getQualifiedName();\n        // Declare the deepest name in the tree for the variable.\n        String simpleName = fullName.substring(fullName.lastIndexOf('.') + 1);\n        Node declaration = getOrCreateDeclaration(fullName, root);\n        if (declaration.getParent().isVar()) {\n          // No need to wrap the NAME node in a declaration if the parent is a VAR.\n          declaration = declaration.getParent();\n        } else {\n          // Create a VAR statement or an assignments at the start of the script or function.\n          String varName = \"jscomp_scoped_\" + simpleName.replace(\"$\", \"_\");\n          Node name = new Node(Token.NAME, varName).srcref(n);\n          Node initialization = new Node(Token.ASSIGN, name, n.cloneNode()).srcref(n);\n          declaration = declaration.getParent();\n          Node statement = null;\n          if (declaration.getParent().isScript()) {\n            statement = new Node(Token.VAR, initialization);\n            declaration.getParent().addChildrenToFront(statement); // Add to front to retain ordering.\n          } else if (declaration.getParent().isFunction()) {\n            Node parameterList = declaration.getParent().getSecondChild();\n            Node grandparent = declaration.getParent().getParent();\n            int index = grandparent.getChildIndex(declaration.getParent()) + 1;\n            statement = new Node(Token.EXPR_RESULT, initialization).srcref(n);\n            grandparent.addChildAfter(statement, declaration.getParent());\n          }\n          if (statement != null) {\n            // NOTE: This \"hidden\" data is used to recover the original variable name before\n            // obfuscation later.\n            statement\n                .getLastChild()\n                .getFirstChild()\n                .putProp(Node.ORIGINALNAME_PROP, n.getString());\n            t.reportCodeChange();\n          }\n        }\n\n        // Replace the name in the parse tree with a GETPROP for the variable.\n        Node replacement = new Node(Token.GETPROP, declaration.cloneTree(), simpleName).srcref(n);\n        parent.replaceChild(n, replacement);\n        t.reportCodeChange();\n      }\n    }\n  }\n\n  private class PruneDeadCode extends NodeTraversal.AbstractScopedCallback {\n    private final LinkedHashSet<Node> reachable = new LinkedHashSet<>();\n    private boolean inNewScope;\n    private boolean inDeadBranch;\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n      inNewScope = true;\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      inNewScope = false;\n    }\n\n    private void removeUnreachable(NodeTraversal t, Node n, Node parent) {\n      if (inDeadBranch) {\n        if (!isDeadCode(n) && !NodeUtil.isControlStructure(n)) {\n          parent.removeChild(n);\n          t.reportCodeChange();\n        }\n      } else {\n        if (!reachable.contains(n)) {\n          parent.removeChild(n);\n          t.reportCodeChange();\n        }\n      }\n    }\n\n    private void processConditional(NodeTraversal t, Node n, Node parent) {\n      Node first = n.getFirstChild();\n      Node second = first.getNext();\n      Node third = second.getNext();\n      boolean firstFalsy = NodeUtil.isFalsy(first);\n      boolean secondFalsy = NodeUtil.isFalsy(second);\n      boolean thirdFalsy = NodeUtil.isFalsy(third);\n\n      if (firstFalsy && secondFalsy && thirdFalsy) {\n        parent.replaceChild(n, first.cloneNode());\n        t.reportCodeChange();\n      } else if (secondFalsy && !thirdFalsy) {  // (cond && x) || y\n        parent.replaceChild(n, newNode(Token.OR, first.cloneNode(), third.cloneNode()));\n        t.reportCodeChange();\n        removeUnreachable(t, second, n);\n      } else if (thirdFalsy && second.getParent() == n) {  // (cond || x) && y\n        parent.replaceChild(n, newNode(Token.AND, first.cloneNode(), second.cloneNode()));\n        t.reportCodeChange();\n        removeUnreachable(t, third, n);\n      } else if (firstFalsy) {  // (x || y) => x; y;\n        removeUnreachable(t, first, n);\n        parent.replaceChild(n, second.detachFromParent());\n        t.reportCodeChange();\n      } else if (secondFalsy) {  // (x && y) => x, y;\n        removeUnreachable(t, second, n);\n        parent.replaceChild(n, first.detachFromParent());\n        t.reportCodeChange();\n      }\n    }\n\n    @Override\n    public void visit(NodeTraversal t, Node n, Node parent) {\n      if (NodeUtil.mayHaveSideEffects(n)) {\n        if (n.isName() && parent.isVar()) {\n          // Make sure vars with side-effects don't prevent the removal of other vars.\n          reachable.add(n);\n        } else {\n          reachable.add(n);\n          inDeadBranch = false;\n        }\n      }\n      if (isDeadCode(n)) {\n        if (inDeadBranch) {\n          parent.removeChild(n);\n          t.reportCodeChange();\n        } else if (!isDirective(n)) {\n          removeUnreachable(t, n, parent);\n        }\n      } else if (NodeUtil.isStatementBlock(n)) {\n        inDeadBranch = false;\n      } else if (NodeUtil.isControlStructure(n)) {\n        inDeadBranch = inDeadBranch ||\n            (n.isIf() && NodeUtil.isLiteralValue(n.getFirstChild(), false)) ||\n            (n.isHook() && !NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n      } else if (n.isReturn()) {\n        inDeadBranch = true;\n      } else if (n.isLabel()) {\n        reachable.add(n);\n        // Any break or continue statement whose target is a label that is inside the label being\n        // processed is considered reachable. The target label must be processed before its labels.\n        for (Node label = n.getFirstChild(); label != null; label = label.getNext()) {\n          reachable.add(label);\n          for (Node target = label.getFirstChild(); target != null; target = target.getNext()) {\n            Node it = n;\n            while ((it = it.getParent()) != null) {\n              if (it == target) {\n                reachable.add(target);\n              }\n            }\n          }\n        }\n      } else if (n.isBreak() || n.isContinue()) {\n        // Only mark a break/continue statement if it is going somewhere inside a nested label.\n        // Otherwise ignore it (it's dead code). Must be processed after labels, for child lookup.\n        String name = n.getString();\n        for (Node label = n.getParent(); label != null; label = label.getParent()) {\n          if (label.isLabel() && (name == null || label.getFirstChild().getString().equals(name))) {\n            reachable.add(n);\n            break;\n          }\n        }\n      } else if (n.isSwitch()) {\n        boolean hasDefault = false;\n        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n          if (NodeUtil.isDefaultCase(child)) {\n            hasDefault = true;\n          }\n          if (hasDefault) {\n            reachable.add(child);\n            for (Node grandchild = child.getFirstChild(); grandchild != null; grandchild = grandchild.getNext()) {\n              reachable.add(grandchild);\n            }\n          }\n        }\n      } else if (n.isHook()) {\n        processConditional(t, n, parent);\n      } else if (n.isAnd() || n.isOr()) {\n        Node left = n.getFirstChild();\n        Node right = n.getLastChild();\n        boolean leftFalsy = NodeUtil.isFalsy(left);\n        boolean rightFalsy = NodeUtil.isFalsy(right);\n\n        if (leftFalsy && rightFalsy) {\n          parent.replaceChild(n, left.cloneNode());\n          t.reportCodeChange();\n        } else if (leftFalsy) {\n          parent.replaceChild(n, right.cloneNode());\n          t.reportCodeChange();\n          removeUnreachable(t, left, n);\n        } else if (rightFalsy) {\n          parent.replaceChild(n, left.cloneNode());\n          t.reportCodeChange();\n          removeUnreachable(t, right, n);\n        }\n      }\n    }\n  }\n\n  @Override\n  public Node process(Node externs, Node root) {\n    checkState(externs != null);\n    NodeTraversal.traverseRoots(\n        externs,\n        root,\n        new HotSwapCompilerPass() {\n          @Override\n          public void process(Node externs, Node current) {\n            TransformDispatcher td = new TransformDispatcher();\n            NodeTraversal.traverse(\n                compiler,\n                current,\n                td,\n                new ScopedAliases(compiler, ImmutableList.of(td)));\n          }\n        });\n    return root;\n  }\n\n  /**\n   * A {@link NodeTraversal.Callback} that captures <code>var</code> statements that have no\n   * initializer and renames them to unique identifiers.\n   */\n  private static class ScopedAliases extends AbstractPostOrderCallback implements ScopedCallback {\n    private final Map<String, Integer> scopes = Maps.newHashMap();\n    private final Map<String, Map<String, Integer>> scopeVars = Maps.newHashMap();\n    private final List<Transform> transforms = Lists.newLinkedList();\n    private final Compiler compiler;\n\n    ScopedAliases(Compiler compiler, List<Transform> transforms) {\n      this.compiler = compiler;\n      this.transforms.addAll(transforms);\n    }\n\n    /**\n     * Flattens an entire scope tree, putting every NAME node into a single map.\n     */\n    private void flattenScope(Node scopeRoot, Map<String, Integer> scopeVars) {\n      for (Node n = scopeRoot.getFirstChild(); n != null; n = n.getNext()) {\n        if (n.isBlock()) {\n          flattenScope(n, scopeVars);\n        } else if (n.isName()) {\n          String name = n.getString();\n          if (!scopeVars.containsKey(name)) {\n            scopeVars.put(name, scopeVars.size());\n          }\n          if (n.getParent().isVar() && n.hasChildren()) {\n            flattenScope(n.getFirstChild(), scopeVars);\n          }\n        }\n      }\n    }\n\n    @Override\n    public void enterScope(NodeTraversal t) {\n      scopes.put(t.getScope().toString(), scopes.size());\n      scopeVars.put(t.getScope().toString(), Maps.<String, Integer>newHashMap());\n    }\n\n    @Override\n    public void exitScope(NodeTraversal t) {\n      Map<String, Integer> vars = scopeVars.get(t.getScope().toString());\n      // Do not rename vars if they can't be collapsed.\n      if (vars.isEmpty() ||\n          vars.size() == 1 && vars.containsKey(\"arguments\") ||\n          vars.size() == 2 && vars.containsKey(\"this\") && vars.containsKey(\"arguments\")) {\n        return;\n    ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..de4ed420 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,397 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory implements NodeTransformer<CompilerEnvirons> {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+\n+  IRFactory(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n+\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+        n.getFirstChild().isString() &&\n+        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  /**\n+   * Determines if this is a statement node for which the result is unused for the purpose\n+   * of dead code detection.\n+   */\n+  private boolean isDeadCode(Node n) {\n+    Token type = n.getToken();\n+    return type == Token.EMPTY || type == Token.EXPR_RESULT || type == Token.BREAK ||\n+        type == Token.CONTINUE;\n+  }\n+\n+  private Node newNode(Token type, Node child1, Node child2, Node child3) {\n+    Node n = new Node(type);\n+    n.addChildToBack(child1);\n+    if (child2 != null) {\n+      n.addChildToBack(child2);\n+      if (child3 != null) {\n+        n.addChildToBack(child3);\n+      }\n     }\n+    return n;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  private Node newNode(Token type, Node child) {\n+    return newNode(type, child, null, null);\n+  }\n+\n+  private Node newNode(Token type, Node child1, Node child2) {\n+    return newNode(type, child1, child2, null);\n+  }\n+\n+  private Node newNode(Token type) {\n+    return newNode(type, null, null, null);\n+  }\n+\n+  private Node newNode(Token type, String stringValue) {\n+    Node node = newNode(type, (Node) null);\n+    node.setString(stringValue);\n+    return node;\n+  }\n+\n+  @Override\n+  public Node transform(Node node, CompilerEnvirons compilerEnvirons) {\n+    NodeTraversal.traverse(compilerEnvirons.getParsePassConfig(), node, new DirectiveFinder());\n+\n+    Node root = IR.root();\n+    NodeTraversal.traverse(compilerEnvirons.getPassConfig(), node, new GlobalNames(root));\n+    node.detach();\n+    root.addChildrenToFront(node);\n+\n+    NodeTraversal.traverse(compilerEnvirons.getPassConfig(), root, new PruneDeadCode());\n+\n+    return root;\n+  }\n+\n+  /**\n+   * A no-op transformer for use when you just want to apply any @link{Callback}s to an AST.\n+   */\n+  public static class NullCompiler extends Compiler {\n+    private static final AbstractCompiler nullErrorReporter =\n+        new AbstractCompiler() {\n+          @Override\n+          public void println(String str) {}\n+\n+          @Override\n+          public void print(String str) {}\n+        };\n+\n+    public NullCompiler(ErrorReporter errorReporter) {\n+      super(nullErrorReporter);\n+      setLifeCycleStage(LifeCycleStage.NORMALIZE);\n     }\n+  }\n \n+  private class DirectiveFinder extends AbstractPostOrderCallback {\n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (isDirective(n)) {\n+        t.reportCodeChange();\n       }\n-      return node;\n+    }\n+  }\n+\n+  private class GlobalNames extends AbstractPostOrderCallback {\n+    private final Node root;\n+\n+    private GlobalNames(Node root) {\n+      this.root = root;\n+    }\n+\n+    private Node getOrCreateDeclaration(String fullName, Node root) {\n+      for (String part : fullName.split(\"\\\\.\")) {\n+        boolean isNameDeclaration = (part == fullName);\n+        if (root.hasChildren()) {\n+          for (Node child = root.getFirstChild(); child != null; child = child.getNext()) {\n+            if (child.matchesQualifiedName(part)) {\n+              root = child;\n+              break;\n+            }\n+          }\n+        }\n+        if (root == null || !root.matchesQualifiedName(part)) {\n+          Node node = new Node(isNameDeclaration ? Token.NAME : Token.OBJECTLIT);\n+          node.setString(part);\n+          root = root.addChildToBack(node);\n+        }\n+      }\n+      return root;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (n.isName()) {\n+        String fullName = n.getQualifiedName();\n+        // Declare the deepest name in the tree for the variable.\n+        String simpleName = fullName.substring(fullName.lastIndexOf('.') + 1);\n+        Node declaration = getOrCreateDeclaration(fullName, root);\n+        if (declaration.getParent().isVar()) {\n+          // No need to wrap the NAME node in a declaration if the parent is a VAR.\n+          declaration = declaration.getParent();\n+        } else {\n+          // Create a VAR statement or an assignments at the start of the script or function.\n+          String varName = \"jscomp_scoped_\" + simpleName.replace(\"$\", \"_\");\n+          Node name = new Node(Token.NAME, varName).srcref(n);\n+          Node initialization = new Node(Token.ASSIGN, name, n.cloneNode()).srcref(n);\n+          declaration = declaration.getParent();\n+          Node statement = null;\n+          if (declaration.getParent().isScript()) {\n+            statement = new Node(Token.VAR, initialization);\n+            declaration.getParent().addChildrenToFront(statement); // Add to front to retain ordering.\n+          } else if (declaration.getParent().isFunction()) {\n+            Node parameterList = declaration.getParent().getSecondChild();\n+            Node grandparent = declaration.getParent().getParent();\n+            int index = grandparent.getChildIndex(declaration.getParent()) + 1;\n+            statement = new Node(Token.EXPR_RESULT, initialization).srcref(n);\n+            grandparent.addChildAfter(statement, declaration.getParent());\n+          }\n+          if (statement != null) {\n+            // NOTE: This \"hidden\" data is used to recover the original variable name before\n+            // obfuscation later.\n+            statement\n+                .getLastChild()\n+                .getFirstChild()\n+                .putProp(Node.ORIGINALNAME_PROP, n.getString());\n+            t.reportCodeChange();\n+          }\n+        }\n+\n+        // Replace the name in the parse tree with a GETPROP for the variable.\n+        Node replacement = new Node(Token.GETPROP, declaration.cloneTree(), simpleName).srcref(n);\n+        parent.replaceChild(n, replacement);\n+        t.reportCodeChange();\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n+  }\n+\n+  private class PruneDeadCode extends NodeTraversal.AbstractScopedCallback {\n+    private final LinkedHashSet<Node> reachable = new LinkedHashSet<>();\n+    private boolean inNewScope;\n+    private boolean inDeadBranch;\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public void enterScope(NodeTraversal t) {\n+      inNewScope = true;\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public void exitScope(NodeTraversal t) {\n+      inNewScope = false;\n+    }\n+\n+    private void removeUnreachable(NodeTraversal t, Node n, Node parent) {\n+      if (inDeadBranch) {\n+        if (!isDeadCode(n) && !NodeUtil.isControlStructure(n)) {\n+          parent.removeChild(n);\n+          t.reportCodeChange();\n+        }\n+      } else {\n+        if (!reachable.contains(n)) {\n+          parent.removeChild(n);\n+          t.reportCodeChange();\n+        }\n       }\n-      return node;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    private void processConditional(NodeTraversal t, Node n, Node parent) {\n+      Node first = n.getFirstChild();\n+      Node second = first.getNext();\n+      Node third = second.getNext();\n+      boolean firstFalsy = NodeUtil.isFalsy(first);\n+      boolean secondFalsy = NodeUtil.isFalsy(second);\n+      boolean thirdFalsy = NodeUtil.isFalsy(third);\n+\n+      if (firstFalsy && secondFalsy && thirdFalsy) {\n+        parent.replaceChild(n, first.cloneNode());\n+        t.reportCodeChange();\n+      } else if (secondFalsy && !thirdFalsy) {  // (cond && x) || y\n+        parent.replaceChild(n, newNode(Token.OR, first.cloneNode(), third.cloneNode()));\n+        t.reportCodeChange();\n+        removeUnreachable(t, second, n);\n+      } else if (thirdFalsy && second.getParent() == n) {  // (cond || x) && y\n+        parent.replaceChild(n, newNode(Token.AND, first.cloneNode(), second.cloneNode()));\n+        t.reportCodeChange();\n+        removeUnreachable(t, third, n);\n+      } else if (firstFalsy) {  // (x || y) => x; y;\n+        removeUnreachable(t, first, n);\n+        parent.replaceChild(n, second.detachFromParent());\n+        t.reportCodeChange();\n+      } else if (secondFalsy) {  // (x && y) => x, y;\n+        removeUnreachable(t, second, n);\n+        parent.replaceChild(n, first.detachFromParent());\n+        t.reportCodeChange();\n+      }\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public void visit(NodeTraversal t, Node n, Node parent) {\n+      if (NodeUtil.mayHaveSideEffects(n)) {\n+        if (n.isName() && parent.isVar()) {\n+          // Make sure vars with side-effects don't prevent the removal of other vars.\n+          reachable.add(n);\n+        } else {\n+          reachable.add(n);\n+          inDeadBranch = false;\n+        }\n+      }\n+      if (isDeadCode(n)) {\n+        if (inDeadBranch) {\n+          parent.removeChild(n);\n+          t.reportCodeChange();\n+        } else if (!isDirective(n)) {\n+          removeUnreachable(t, n, parent);\n+        }\n+      } else if (NodeUtil.isStatementBlock(n)) {\n+        inDeadBranch = false;\n+      } else if (NodeUtil.isControlStructure(n)) {\n+        inDeadBranch = inDeadBranch ||\n+            (n.isIf() && NodeUtil.isLiteralValue(n.getFirstChild(), false)) ||\n+            (n.isHook() && !NodeUtil.mayHaveSideEffects(n.getFirstChild()));\n+      } else if (n.isReturn()) {\n+        inDeadBranch = true;\n+      } else if (n.isLabel()) {\n+        reachable.add(n);\n+        // Any break or continue statement whose target is a label that is inside the label being\n+        // processed is considered reachable. The target label must be processed before its labels.\n+        for (Node label = n.getFirstChild(); label != null; label = label.getNext()) {\n+          reachable.add(label);\n+          for (Node target = label.getFirstChild(); target != null; target = target.getNext()) {\n+            Node it = n;\n+            while ((it = it.getParent()) != null) {\n+              if (it == target) {\n+                reachable.add(target);\n+              }\n+            }\n+          }\n+        }\n+      } else if (n.isBreak() || n.isContinue()) {\n+        // Only mark a break/continue statement if it is going somewhere inside a nested label.\n+        // Otherwise ignore it (it's dead code). Must be processed after labels, for child lookup.\n+        String name = n.getString();\n+        for (Node label = n.getParent(); label != null; label = label.getParent()) {\n+          if (label.isLabel() && (name == null || label.getFirstChild().getString().equals(name))) {\n+            reachable.add(n);\n+            break;\n+          }\n+        }\n+      } else if (n.isSwitch()) {\n+        boolean hasDefault = false;\n+        for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+          if (NodeUtil.isDefaultCase(child)) {\n+            hasDefault = true;\n+          }\n+          if (hasDefault) {\n+            reachable.add(child);\n+            for (Node grandchild = child.getFirstChild(); grandchild != null; grandchild = grandchild.getNext()) {\n+              reachable.add(grandchild);\n+            }\n+          }\n+        }\n+      } else if (n.isHook()) {\n+        processConditional(t, n, parent);\n+      } else if (n.isAnd() || n.isOr()) {\n+        Node left = n.getFirstChild();\n+        Node right = n.getLastChild();\n+        boolean leftFalsy = NodeUtil.isFalsy(left);\n+        boolean rightFalsy = NodeUtil.isFalsy(right);\n+\n+        if (leftFalsy && rightFalsy) {\n+          parent.replaceChild(n, left.cloneNode());\n+          t.reportCodeChange();\n+        } else if (leftFalsy) {\n+          parent.replaceChild(n, right.cloneNode());\n+          t.reportCodeChange();\n+          removeUnreachable(t, left, n);\n+        } else if (rightFalsy) {\n+          parent.replaceChild(n, left.cloneNode());\n+          t.reportCodeChange();\n+          removeUnreachable(t, right, n);\n+        }\n+      }\n     }\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node process(Node externs, Node root) {\n+    checkState(externs != null);\n+    NodeTraversal.traverseRoots(\n+        externs,\n+        root,\n+        new HotSwapCompilerPass() {\n+          @Override\n+          public void process(Node externs, Node current) {\n+            TransformDispatcher td = new TransformDispatcher();\n+            NodeTraversal.traverse(\n+                compiler,\n+                current,\n+                td,\n+                new ScopedAliases(compiler, ImmutableList.of(td)));\n+          }\n+        });\n+    return root;\n+  }\n+\n+  /**\n+   * A {@link NodeTraversal.Callback} that captures <code>var</code> statements that have no\n+   * initializer and renames them to unique identifiers.\n+   */\n+  private static class ScopedAliases extends AbstractPostOrderCallback implements ScopedCallback {\n+    private final Map<String, Integer> scopes = Maps.newHashMap();\n+    private final Map<String, Map<String, Integer>> scopeVars = Maps.newHashMap();\n+    private final List<Transform> transforms = Lists.newLinkedList();\n+    private final Compiler compiler;\n+\n+    ScopedAliases(Compiler compiler, List<Transform> transforms) {\n+      this.compiler = compiler;\n+      this.transforms.addAll(transforms);\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    /**\n+     * Flattens an entire scope tree, putting every NAME node into a single map.\n+     */\n+    private void flattenScope(Node scopeRoot, Map<String, Integer> scopeVars) {\n+      for (Node n = scopeRoot.getFirstChild(); n != null; n = n.getNext()) {\n+        if (n.isBlock()) {\n+          flattenScope(n, scopeVars);\n+        } else if (n.isName()) {\n+          String name = n.getString();\n+          if (!scopeVars.containsKey(name)) {\n+            scopeVars.put(name, scopeVars.size());\n+          }\n+          if (n.getParent().isVar() && n.hasChildren()) {\n+            flattenScope(n.getFirstChild(), scopeVars);\n+          }\n+        }\n+      }\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-\n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    public void enterScope(NodeTraversal t) {\n+      scopes.put(t.getScope().toString(), scopes.size());\n+      scopeVars.put(t.getScope().toString(), Maps.<String, Integer>newHashMap());\n     }\n \n+    @Override\n+    public void exitScope(NodeTraversal t) {\n+      Map<String, Integer> vars = scopeVars.get(t.getScope().toString());\n+      // Do not rename vars if they can't be collapsed.\n+      if (vars.isEmpty() ||\n+          vars.size() == 1 && vars.containsKey(\"arguments\") ||\n+          vars.size() == 2 && vars.containsKey(\"this\") && vars.containsKey(\"arguments\")) {\n+        return;\n+    \n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}