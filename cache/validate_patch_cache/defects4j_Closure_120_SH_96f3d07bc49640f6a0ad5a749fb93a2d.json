{
    "patch": "```\n    @SuppressWarnings(\"unchecked\")\n    boolean isAssignedOnceInLifetime() {\n      Reference ref = getOneAndOnlyAssignment();\n      if (ref == null) {\n        return false;\n      }\n  \n      Set<BasicBlock> seen = new HashSet<>();\n      while (ref != null) {\n        if (seen.contains(ref.getBasicBlock())) {\n          // We've already seen this block, so we're in a loop.\n          return false;\n        }\n  \n        seen.add(ref.getBasicBlock());\n        List<Reference> refs = ref.getBasicBlock().getReferences();\n        int index = refs.indexOf(ref);\n        if (index == -1) {\n          throw new IllegalStateException(\"Could not find reference within block: \" + ref);\n        } else if (index == refs.size() - 1) {\n          // This is the last reference in the block, move to the next block.\n          ControlFlowGraph<Node> cfg = ref.getBasicBlock().getCfg();\n          List<BasicBlock> succs = cfg.getSuccessors(ref.getBasicBlock());\n          if (succs.isEmpty()) {\n            throw new IllegalStateException(\"Block has no successors: \" + ref.getBasicBlock());\n          }\n          if (succs.size() == 1) {\n            // This is a simple block.\n            ref = succs.get(0).getFirstReference();\n          } else {\n            BasicBlock next = cfg.getOutEdges(ref.getBasicBlock())\n                .stream()\n                .filter(e -> e.getValue() instanceof ConditionEdge)\n                .map(DiGraphEdge::getDestination)\n                .findFirst().orElse(null);\n            if (next == null) {\n              throw new IllegalStateException(\"Could not find next block: \" + ref.getBasicBlock());\n            }\n            ref = next.getFirstReference();\n          }\n        } else if (refs.get(index + 1).isDeclaration()) {\n          // This is a declaration.\n          return false;\n        } else {\n          // This is an assignment.\n          if (refs.get(index + 1) == null) {\n            return false;\n          } else if (refs.get(index + 1).isStatement()) {\n            return false;\n          } else if (refs.get(index + 1).isGetProp()) {\n            // This is a property access (e.g. `o.prop`), not a real assignment.\n            return false;\n          }\n  \n          ref = refs.get(index + 1).getNextReference();\n        }\n      }\n  \n      return true;\n    }\n```",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..48f49a9c 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,68 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+```\n+    @SuppressWarnings(\"unchecked\")\n+    boolean isAssignedOnceInLifetime() {\n+      Reference ref = getOneAndOnlyAssignment();\n+      if (ref == null) {\n+        return false;\n+      }\n+  \n+      Set<BasicBlock> seen = new HashSet<>();\n+      while (ref != null) {\n+        if (seen.contains(ref.getBasicBlock())) {\n+          // We've already seen this block, so we're in a loop.\n+          return false;\n+        }\n+  \n+        seen.add(ref.getBasicBlock());\n+        List<Reference> refs = ref.getBasicBlock().getReferences();\n+        int index = refs.indexOf(ref);\n+        if (index == -1) {\n+          throw new IllegalStateException(\"Could not find reference within block: \" + ref);\n+        } else if (index == refs.size() - 1) {\n+          // This is the last reference in the block, move to the next block.\n+          ControlFlowGraph<Node> cfg = ref.getBasicBlock().getCfg();\n+          List<BasicBlock> succs = cfg.getSuccessors(ref.getBasicBlock());\n+          if (succs.isEmpty()) {\n+            throw new IllegalStateException(\"Block has no successors: \" + ref.getBasicBlock());\n+          }\n+          if (succs.size() == 1) {\n+            // This is a simple block.\n+            ref = succs.get(0).getFirstReference();\n+          } else {\n+            BasicBlock next = cfg.getOutEdges(ref.getBasicBlock())\n+                .stream()\n+                .filter(e -> e.getValue() instanceof ConditionEdge)\n+                .map(DiGraphEdge::getDestination)\n+                .findFirst().orElse(null);\n+            if (next == null) {\n+              throw new IllegalStateException(\"Could not find next block: \" + ref.getBasicBlock());\n+            }\n+            ref = next.getFirstReference();\n+          }\n+        } else if (refs.get(index + 1).isDeclaration()) {\n+          // This is a declaration.\n+          return false;\n+        } else {\n+          // This is an assignment.\n+          if (refs.get(index + 1) == null) {\n+            return false;\n+          } else if (refs.get(index + 1).isStatement()) {\n+            return false;\n+          } else if (refs.get(index + 1).isGetProp()) {\n+            // This is a property access (e.g. `o.prop`), not a real assignment.\n+            return false;\n+          }\n+  \n+          ref = refs.get(index + 1).getNextReference();\n+        }\n+      }\n+  \n+      return true;\n+    }\n+```\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: illegal character: \\96",
    "test_result": "ERROR"
}