{
    "patch": "import org.apache.commons.math.analysis.UnivariateFunction;\nimport org.apache.commons.math.exception.*;\nimport org.apache.commons.math.util.FastMath;\nimport org.apache.commons.math.util.MathUtils;\nimport org.apache.commons.math.util.Precision;\n\npublic class BrentSolverFixed extends AbstractUnivariateSolver {\n\n    /**\n     * The default absolute accuracy.\n     */\n    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n\n    /**\n     * The default relative accuracy.\n     */\n    private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n\n    /**\n     * The default function value accuracy.\n     */\n    private static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n\n    /**\n     * The maximum order of polynomial functions allowed.\n     */\n    private static final int MAXIMAL_ORDER = 5;\n\n    /**\n     * The upper limit for the number of iterations.\n     */\n    private static final int ITERATION_LIMIT = 100;\n\n    /**\n     * The array of coefficients for the reversed polynomial.\n     */\n    private final double[] coefficients;\n\n    /**\n     * The maximum number of iterations allowed.\n     */\n    private final int maxIterations;\n\n    /**\n     * Construct a solver with default accuracy settings.\n     */\n    public BrentSolverFixed() {\n        this(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_FUNCTION_VALUE_ACCURACY, ITERATION_LIMIT);\n    }\n\n    /**\n     * Construct a solver.\n     *\n     * @param relativeAccuracy maximum relative error\n     * @param absoluteAccuracy maximum absolute error\n     * @param functionValueAccuracy maximum function value error\n     * @param maxIterations maximum number of iterations\n     */\n    public BrentSolverFixed(final double relativeAccuracy,\n                            final double absoluteAccuracy,\n                            final double functionValueAccuracy,\n                            final int maxIterations) {\n        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n        MathUtils.checkPositive(maxIterations, \"maximum iteration count\");\n        this.coefficients = new double[maxIterations + 1];\n        this.maxIterations = maxIterations;\n    }\n\n    /** {@inheritDoc} */\n    @Override\n    protected final double doSolve() throws TooManyEvaluationsException, NumberIsTooSmallException {\n        // Get initial solution\n        double x0 = getMin();\n        double x1 = getStartValue();\n        double x2 = getMax();\n        double y0 = computeObjectiveValue(x0);\n        double y1 = computeObjectiveValue(x1);\n        double y2 = computeObjectiveValue(x2);\n\n        // Check if either of the endpoints is the root\n        if (y0 == 0) {\n            return x0;\n        }\n        if (y1 == 0) {\n            return x1;\n        }\n        if (y2 == 0) {\n            return x2;\n        }\n        verifySequence(x0, x1, x2);\n\n        // Check if we need to use bisection\n        if (y0 * y1 > 0 && y1 * y2 > 0) {\n            throw new NoBracketingException(x0, x2, y0, y2);\n        }\n        if (y0 > 0 ^ y2 > 0 && y1 == 0) {\n            x0 = x1;\n            y0 = y1;\n        } else if (y1 > 0 ^ y0 > 0 && y2 == 0) {\n            x2 = x1;\n            y2 = y1;\n        } else if (y1 * y2 > 0) {\n            // Switching order of the arguments improves convergence\n            double t = x0;\n            x0 = x2;\n            x2 = t;\n            t = y0;\n            y0 = y2;\n            y2 = t;\n        }\n\n        double rtol = getRelativeAccuracy();\n        double atol = getAbsoluteAccuracy();\n        double ftol = getFunctionValueAccuracy();\n        double f = y2;\n        double d = 0;\n        double e = 0;\n        double s = 0;\n        double p = 0;\n        double q = 0;\n        int iter = 0;\n        while (iter++ < maxIterations) {\n            double prevD = d;\n            double prevF = f;\n            double prevS = s;\n            double prevE = e;\n            double a = x0;\n            double b = x2;\n            double c = x2;\n            if (y0 * y2 <= 0) {\n                c = x1;\n                f = y1;\n                d = e = x2 - x1;\n                p = (b - x1) * f - (c - x1) * y0;\n                q = (b - x1) * y0 - (c - x1) * f;\n            } else {\n                f = y2;\n                d = e = x1 - x2;\n                p = (b - x2) * f - (c - x2) * y2;\n                q = (b - x2) * y2 - (c - x2) * f;\n            }\n            if (p > 0) {\n                q = -q;\n            } else {\n                p = -p;\n            }\n            double minTol = rtol * FastMath.abs(s) + atol;\n            double sig = q > 0 ? 1 : -1;\n            double r = q == 0 ? Double.POSITIVE_INFINITY : p / q;\n            double tmpS = s;\n            s = FastMath.max(\n                FastMath.max(s + r * sig, c - x1),\n                a - x1\n            );\n            e = q >= p && 2 * r <= prevD ? prevE : d;\n            d = r <= 0 || q >= p && 2 * r < prevD ? s - c : e;\n            if (d * sig >= 0) {\n                a = x2;\n                f = y2;\n                d = e = x1 - x2;\n                p = (b - x2) * f - (c - x2) * y2;\n                q = (b - x2) * y2 - (c - x2) * f;\n            } else {\n                f = y1;\n                p = (b - x1) * f - (c - x1) * y0;\n                q = (b - x1) * y0 - (c - x1) * f;\n            }\n            if (p > 0) {\n                q = -q;\n            } else {\n                p = -p;\n            }\n            sig = q > 0 ? 1 : -1;\n            r = q == 0 ? Double.POSITIVE_INFINITY : p / q;\n            prevS = tmpS;\n            tmpS = s;\n            s = FastMath.max(\n                FastMath.max(s + r * sig, c - x1),\n                a - x1\n            );\n            prevE = e;\n            e = q >= p && 2 * r <= prevD ? prevE : d;\n            d = r <= 0 || q >= p && 2 * r < prevD ? s - c : e;\n            double nextTol = rtol * FastMath.abs(s) + atol;\n            if (nextTol <= minTol || FastMath.abs(s - prevS) <= ftol) {\n                double minValue = FastMath.min(y0, FastMath.min(y1, y2));\n                double maxValue = FastMath.max(y0, FastMath.max(y1, y2));\n                double middleValue = y0 + y1 + y2 - minValue - maxValue;\n                return middleValue >= 0 ?\n                    BrentUtils.ensureBracketing(x0, x1, x2, minValue, middleValue, eps) :\n                    BrentUtils.ensureBracketing(x0, x1, x2, middleValue, maxValue, eps);\n            }\n            double nextX = x1 + s;\n            double nextY;\n            try {\n                nextY = computeObjectiveValue(nextX);\n            } catch (TooManyEvaluationsException ex) {\n                // Prepare and throw the exception\n                final TooManyEvaluationsException qmte;\n                qmte = new TooManyEvaluationsException(\n                        getMaxEvaluations(),\n                        ex.getMaxEvaluations());\n                qmte.addSuppressed(ex);\n                thro",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..7a98f582b 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,209 +140,210 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n-            return x[1];\n-        }\n-\n-        // evaluate first  endpoint\n-        y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n-            return x[0];\n-        }\n-\n-        int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n-\n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n-\n-        } else {\n+import org.apache.commons.math.analysis.UnivariateFunction;\n+import org.apache.commons.math.exception.*;\n+import org.apache.commons.math.util.FastMath;\n+import org.apache.commons.math.util.MathUtils;\n+import org.apache.commons.math.util.Precision;\n \n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n-            }\n+public class BrentSolverFixed extends AbstractUnivariateSolver {\n \n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n-            } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n-            }\n+    /**\n+     * The default absolute accuracy.\n+     */\n+    private static final double DEFAULT_ABSOLUTE_ACCURACY = 1e-6;\n \n-        }\n+    /**\n+     * The default relative accuracy.\n+     */\n+    private static final double DEFAULT_RELATIVE_ACCURACY = 1e-14;\n \n-        // prepare a work array for inverse polynomial interpolation\n-        final double[] tmpX = new double[x.length];\n-\n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n-        while (true) {\n-\n-            // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n-                switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n-                }\n-            }\n+    /**\n+     * The default function value accuracy.\n+     */\n+    private static final double DEFAULT_FUNCTION_VALUE_ACCURACY = 1e-15;\n \n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n-            } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n-            }\n+    /**\n+     * The maximum order of polynomial functions allowed.\n+     */\n+    private static final int MAXIMAL_ORDER = 5;\n \n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n-                    }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n-                }\n-\n-            } while (Double.isNaN(nextX) && (end - start > 1));\n-\n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n-            }\n+    /**\n+     * The upper limit for the number of iterations.\n+     */\n+    private static final int ITERATION_LIMIT = 100;\n \n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n-            }\n+    /**\n+     * The array of coefficients for the reversed polynomial.\n+     */\n+    private final double[] coefficients;\n \n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n+    /**\n+     * The maximum number of iterations allowed.\n+     */\n+    private final int maxIterations;\n \n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n+    /**\n+     * Construct a solver with default accuracy settings.\n+     */\n+    public BrentSolverFixed() {\n+        this(DEFAULT_RELATIVE_ACCURACY, DEFAULT_ABSOLUTE_ACCURACY, DEFAULT_FUNCTION_VALUE_ACCURACY, ITERATION_LIMIT);\n+    }\n \n-            } else  if (nbPoints == x.length) {\n+    /**\n+     * Construct a solver.\n+     *\n+     * @param relativeAccuracy maximum relative error\n+     * @param absoluteAccuracy maximum absolute error\n+     * @param functionValueAccuracy maximum function value error\n+     * @param maxIterations maximum number of iterations\n+     */\n+    public BrentSolverFixed(final double relativeAccuracy,\n+                            final double absoluteAccuracy,\n+                            final double functionValueAccuracy,\n+                            final int maxIterations) {\n+        super(relativeAccuracy, absoluteAccuracy, functionValueAccuracy);\n+        MathUtils.checkPositive(maxIterations, \"maximum iteration count\");\n+        this.coefficients = new double[maxIterations + 1];\n+        this.maxIterations = maxIterations;\n+    }\n \n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n+    /** {@inheritDoc} */\n+    @Override\n+    protected final double doSolve() throws TooManyEvaluationsException, NumberIsTooSmallException {\n+        // Get initial solution\n+        double x0 = getMin();\n+        double x1 = getStartValue();\n+        double x2 = getMax();\n+        double y0 = computeObjectiveValue(x0);\n+        double y1 = computeObjectiveValue(x1);\n+        double y2 = computeObjectiveValue(x2);\n+\n+        // Check if either of the endpoints is the root\n+        if (y0 == 0) {\n+            return x0;\n+        }\n+        if (y1 == 0) {\n+            return x1;\n+        }\n+        if (y2 == 0) {\n+            return x2;\n+        }\n+        verifySequence(x0, x1, x2);\n \n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n+        // Check if we need to use bisection\n+        if (y0 * y1 > 0 && y1 * y2 > 0) {\n+            throw new NoBracketingException(x0, x2, y0, y2);\n+        }\n+        if (y0 > 0 ^ y2 > 0 && y1 == 0) {\n+            x0 = x1;\n+            y0 = y1;\n+        } else if (y1 > 0 ^ y0 > 0 && y2 == 0) {\n+            x2 = x1;\n+            y2 = y1;\n+        } else if (y1 * y2 > 0) {\n+            // Switching order of the arguments improves convergence\n+            double t = x0;\n+            x0 = x2;\n+            x2 = t;\n+            t = y0;\n+            y0 = y2;\n+            y2 = t;\n+        }\n \n+        double rtol = getRelativeAccuracy();\n+        double atol = getAbsoluteAccuracy();\n+        double ftol = getFunctionValueAccuracy();\n+        double f = y2;\n+        double d = 0;\n+        double e = 0;\n+        double s = 0;\n+        double p = 0;\n+        double q = 0;\n+        int iter = 0;\n+        while (iter++ < maxIterations) {\n+            double prevD = d;\n+            double prevF = f;\n+            double prevS = s;\n+            double prevE = e;\n+            double a = x0;\n+            double b = x2;\n+            double c = x2;\n+            if (y0 * y2 <= 0) {\n+                c = x1;\n+                f = y1;\n+                d = e = x2 - x1;\n+                p = (b - x1) * f - (c - x1) * y0;\n+                q = (b - x1) * y0 - (c - x1) * f;\n+            } else {\n+                f = y2;\n+                d = e = x1 - x2;\n+                p = (b - x2) * f - (c - x2) * y2;\n+                q = (b - x2) * y2 - (c - x2) * f;\n             }\n-\n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n+            if (p > 0) {\n+                q = -q;\n             } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n+                p = -p;\n             }\n-\n-        }\n-\n-    }\n+            double minTol = rtol * FastMath.abs(s) + atol;\n+            double sig = q > 0 ? 1 : -1;\n+            double r = q == 0 ? Double.POSITIVE_INFINITY : p / q;\n+            double tmpS = s;\n+            s = FastMath.max(\n+                FastMath.max(s + r * sig, c - x1),\n+                a - x1\n+            );\n+            e = q >= p && 2 * r <= prevD ? prevE : d;\n+            d = r <= 0 || q >= p && 2 * r < prevD ? s - c : e;\n+            if (d * sig >= 0) {\n+                a = x2;\n+                f = y2;\n+                d = e = x1 - x2;\n+                p = (b - x2) * f - (c - x2) * y2;\n+                q = (b - x2) * y2 - (c - x2) * f;\n+            } else {\n+                f = y1;\n+                p = (b - x1) * f - (c - x1) * y0;\n+                q = (b - x1) * y0 - (c - x1) * f;\n+            }\n+            if (p > 0) {\n+                q = -q;\n+            } else {\n+                p = -p;\n+            }\n+            sig = q > 0 ? 1 : -1;\n+            r = q == 0 ? Double.POSITIVE_INFINITY : p / q;\n+            prevS = tmpS;\n+            tmpS = s;\n+            s = FastMath.max(\n+                FastMath.max(s + r * sig, c - x1),\n+                a - x1\n+            );\n+            prevE = e;\n+            e = q >= p && 2 * r <= prevD ? prevE : d;\n+            d = r <= 0 || q >= p && 2 * r < prevD ? s - c : e;\n+            double nextTol = rtol * FastMath.abs(s) + atol;\n+            if (nextTol <= minTol || FastMath.abs(s - prevS) <= ftol) {\n+                double minValue = FastMath.min(y0, FastMath.min(y1, y2));\n+                double maxValue = FastMath.max(y0, FastMath.max(y1, y2));\n+                double middleValue = y0 + y1 + y2 - minValue - maxValue;\n+                return middleValue >= 0 ?\n+                    BrentUtils.ensureBracketing(x0, x1, x2, minValue, middleValue, eps) :\n+                    BrentUtils.ensureBracketing(x0, x1, x2, middleValue, maxValue, eps);\n+            }\n+            double nextX = x1 + s;\n+            double nextY;\n+            try {\n+                nextY = computeObjectiveValue(nextX);\n+            } catch (TooManyEvaluationsException ex) {\n+                // Prepare and throw the exception\n+                final TooManyEvaluationsException qmte;\n+                qmte = new TooManyEvaluationsException(\n+                        getMaxEvaluations(),\n+                        ex.getMaxEvaluations());\n+                qmte.addSuppressed(ex);\n+                thro\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}