{
    "patch": "if (value.isFunction()) {\n  Node callParent = reference.getParent();\n  if (callParent.isCall() && declaration != initialization) {\n    Node callTarget = callParent.getFirstChild();\n    if ((callTarget.isName() && callTarget.getString().equals(\"define\")) // AMD-style define\n        || (callTarget.isGetProp() && \"goog\".equals(callTarget.getFirstChild().getString())\n            && \"module\".equals(callTarget.getLastChild().getString()))) {  // goog.module call\n      return false;\n    }\n  }\n\n  if (callParent.getParent().isCall()) {\n    Node callee = callParent.getParent().getFirstChild();\n    if (callee == callParent && reference != callParent.getFirstChild()) {\n      // Don't inline functions into non-adjacent call nodes\n      return false;\n    }\n    if (callee.isName() && callee.getString().equals(\"goog.bind\")) {\n      // Don't inline functions into goog.bind\n      return false;\n    }\n  } else if (callParent.isNew()) {\n    if (callParent.getParent().isAssign() && reference != declaration) {\n      // Don't inline if this is a constructor and the result is not being assigned to the l-value.\n      return false;\n    }\n  }\n\n  if (declaration != initialization &&\n      (callParent.isAssign() || callParent.isCall() ||\n       callParent.getParent().isCall() || callParent.getParent().isName())) {\n    return false;\n  }\n\n  if (reference.getParent().isCall() &&\n      reference.getParent().getFirstChild() == reference.getNode()) {\n    return false;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..54ac34eb 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,45 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+if (value.isFunction()) {\n+  Node callParent = reference.getParent();\n+  if (callParent.isCall() && declaration != initialization) {\n+    Node callTarget = callParent.getFirstChild();\n+    if ((callTarget.isName() && callTarget.getString().equals(\"define\")) // AMD-style define\n+        || (callTarget.isGetProp() && \"goog\".equals(callTarget.getFirstChild().getString())\n+            && \"module\".equals(callTarget.getLastChild().getString()))) {  // goog.module call\n+      return false;\n+    }\n+  }\n+\n+  if (callParent.getParent().isCall()) {\n+    Node callee = callParent.getParent().getFirstChild();\n+    if (callee == callParent && reference != callParent.getFirstChild()) {\n+      // Don't inline functions into non-adjacent call nodes\n+      return false;\n+    }\n+    if (callee.isName() && callee.getString().equals(\"goog.bind\")) {\n+      // Don't inline functions into goog.bind\n+      return false;\n+    }\n+  } else if (callParent.isNew()) {\n+    if (callParent.getParent().isAssign() && reference != declaration) {\n+      // Don't inline if this is a constructor and the result is not being assigned to the l-value.\n+      return false;\n+    }\n+  }\n+\n+  if (declaration != initialization &&\n+      (callParent.isAssign() || callParent.isCall() ||\n+       callParent.getParent().isCall() || callParent.getParent().isName())) {\n+    return false;\n+  }\n+\n+  if (reference.getParent().isCall() &&\n+      reference.getParent().getFirstChild() == reference.getNode()) {\n+    return false;\n+  }\n+}\n         }\n       }\n ",
    "result_reason": "error: incomparable types: Reference and Node",
    "test_result": "ERROR"
}