{
    "patch": "public int compare(EventState es0, EventState es1) {\n    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n}\n\npublic void doEvents() throws MaxCountExceededException {\n    final int n = eventsStates.size();\n    final ArrayList<EventState> occuringEvents = new ArrayList<>(n);\n    if (isLastStep) {\n        interpolator.storeTime(currentState.getTime());\n    }\n    double tMin = currentState.getTime();\n    for (final EventState state : eventsStates) {\n        final double t0 = state.getEventTime();\n        final double dt = t0 - tMin;\n        if (dt < -1.0e-12) {\n            // event is before the end of the interplation interval,\n            // despite some limited numerical errors\n            throw new MathIllegalStateException(LocalizedCoreFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                    t0, tMin, false);\n        }\n        if (state.evaluateStep(interpolator)) {\n            // the event occurs during the current step\n            occuringEvents.add(state);\n        }\n    }\n    while (!occuringEvents.isEmpty()) {\n        // handle the chronologically first event\n        final EventState currentEvent = Collections.min(occuringEvents, eventsComparator);\n        final double eventT = currentEvent.getEventTime();\n        if (eventT <= tMin) {\n            // this event has not been triggered yet, we need to trigger it first\n            interpolator.setSoftPreviousTime(previousT);\n            interpolator.setSoftCurrentTime(eventT);\n            interpolator.setInterpolatedTime(eventT);\n            // get state at event time\n            final double[] eventY = interpolator.getInterpolatedState().clone();\n            // advance all event states to current time\n            currentEvent.stepAccepted(eventT, eventY);\n            isLastStep = currentEvent.stop();\n            if (isLastStep) {\n                interpolator.storeTime(currentState.getTime());\n            }\n            // setup next iteration\n            tMin = currentEvent.getEventTime();\n            occuringEvents.clear();\n            for (final EventState state : eventsStates) {\n                final double t0 = state.getEventTime();\n                final double dt = t0 - tMin;\n                if (dt < -1.0e-12) {\n                    // event is before the end of the interplation interval,\n                    // despite some limited numerical errors\n                    throw new MathIllegalStateException(LocalizedCoreFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                            t0, tMin, false);\n                }\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n            continue;\n        }\n        // restrict the interpolator to the first part of the step, up to the event\n        interpolator.setSoftPreviousTime(previousT);\n        interpolator.setSoftCurrentTime(eventT);\n        // get state at event time\n        interpolator.setInterpolatedTime(eventT);\n        final double[] eventY = interpolator.getInterpolatedState().clone();\n        // advance all event states to current time\n        currentEvent.stepAccepted(eventT, eventY);\n        isLastStep = currentEvent.stop();\n        // handle the first part of the step, up to the event\n        for (final StepHandler handler : stepHandlers) {\n            handler.handleStep(interpolator, isLastStep);\n        }\n        if (isLastStep) {\n            interpolator.storeTime(currentState.getTime());\n        }\n        // setup next iteration\n        tMin = currentEvent.getEventTime();\n        occuringEvents.clear();\n        for (final EventState state : eventsStates) {\n            final double t0 = state.getEventTime();\n            final double dt = t0 - tMin;\n            if (dt < -1.0e-12) {\n                // event is before the end of the interplation interval,\n                // despite some limited numerical errors\n                throw new MathIllegalStateException(LocalizedCoreFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n                        t0, tMin, false);\n            }\n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                occuringEvents.add(state);\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..de34735cb 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,102 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n-\n-            });\n+public int compare(EventState es0, EventState es1) {\n+    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n+}\n \n+public void doEvents() throws MaxCountExceededException {\n+    final int n = eventsStates.size();\n+    final ArrayList<EventState> occuringEvents = new ArrayList<>(n);\n+    if (isLastStep) {\n+        interpolator.storeTime(currentState.getTime());\n+    }\n+    double tMin = currentState.getTime();\n+    for (final EventState state : eventsStates) {\n+        final double t0 = state.getEventTime();\n+        final double dt = t0 - tMin;\n+        if (dt < -1.0e-12) {\n+            // event is before the end of the interplation interval,\n+            // despite some limited numerical errors\n+            throw new MathIllegalStateException(LocalizedCoreFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n+                    t0, tMin, false);\n+        }\n+        if (state.evaluateStep(interpolator)) {\n+            // the event occurs during the current step\n+            occuringEvents.add(state);\n+        }\n+    }\n+    while (!occuringEvents.isEmpty()) {\n+        // handle the chronologically first event\n+        final EventState currentEvent = Collections.min(occuringEvents, eventsComparator);\n+        final double eventT = currentEvent.getEventTime();\n+        if (eventT <= tMin) {\n+            // this event has not been triggered yet, we need to trigger it first\n+            interpolator.setSoftPreviousTime(previousT);\n+            interpolator.setSoftCurrentTime(eventT);\n+            interpolator.setInterpolatedTime(eventT);\n+            // get state at event time\n+            final double[] eventY = interpolator.getInterpolatedState().clone();\n+            // advance all event states to current time\n+            currentEvent.stepAccepted(eventT, eventY);\n+            isLastStep = currentEvent.stop();\n+            if (isLastStep) {\n+                interpolator.storeTime(currentState.getTime());\n+            }\n+            // setup next iteration\n+            tMin = currentEvent.getEventTime();\n+            occuringEvents.clear();\n             for (final EventState state : eventsStates) {\n+                final double t0 = state.getEventTime();\n+                final double dt = t0 - tMin;\n+                if (dt < -1.0e-12) {\n+                    // event is before the end of the interplation interval,\n+                    // despite some limited numerical errors\n+                    throw new MathIllegalStateException(LocalizedCoreFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n+                            t0, tMin, false);\n+                }\n                 if (state.evaluateStep(interpolator)) {\n                     // the event occurs during the current step\n                     occuringEvents.add(state);\n                 }\n             }\n-\n-            while (!occuringEvents.isEmpty()) {\n-\n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n-\n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n-\n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n-\n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n-\n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n+            continue;\n+        }\n+        // restrict the interpolator to the first part of the step, up to the event\n+        interpolator.setSoftPreviousTime(previousT);\n+        interpolator.setSoftCurrentTime(eventT);\n+        // get state at event time\n+        interpolator.setInterpolatedTime(eventT);\n+        final double[] eventY = interpolator.getInterpolatedState().clone();\n+        // advance all event states to current time\n+        currentEvent.stepAccepted(eventT, eventY);\n+        isLastStep = currentEvent.stop();\n+        // handle the first part of the step, up to the event\n+        for (final StepHandler handler : stepHandlers) {\n+            handler.handleStep(interpolator, isLastStep);\n+        }\n+        if (isLastStep) {\n+            interpolator.storeTime(currentState.getTime());\n+        }\n+        // setup next iteration\n+        tMin = currentEvent.getEventTime();\n+        occuringEvents.clear();\n+        for (final EventState state : eventsStates) {\n+            final double t0 = state.getEventTime();\n+            final double dt = t0 - tMin;\n+            if (dt < -1.0e-12) {\n+                // event is before the end of the interplation interval,\n+                // despite some limited numerical errors\n+                throw new MathIllegalStateException(LocalizedCoreFormats.TOO_SMALL_INTEGRATION_INTERVAL,\n+                        t0, tMin, false);\n+            }\n+            if (state.evaluateStep(interpolator)) {\n+                // the event occurs during the current step\n+                occuringEvents.add(state);\n+            }\n+        }\n+    }\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}