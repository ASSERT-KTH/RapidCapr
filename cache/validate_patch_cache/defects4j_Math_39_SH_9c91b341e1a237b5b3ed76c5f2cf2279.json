{
    "patch": "if (nextIsLast) {\n    hNew = t - stepStart;\n}\n\nfor (int j = 0; j < y0.length; ++j) {\n    double sum    = b[0] * yDotK[0][j];\n    for (int l = 1; l < stages; ++l) {\n        sum    += b[l] * yDotK[l][j];\n    }\n    yTmp[j] = y[j] + hNew * sum;\n}\n\ncomputeDerivatives(stepStart + hNew, yTmp, yDotK[0]);\nfinal double errorNew = estimateError(yDotK, y, yTmp, hNew);\n\nif (errorNew > error) {\n    filterStep(safety * stepSize * FastMath.pow(errorNew, -0.5), forward, false);\n    continue;\n}\n\nerror = errorNew;\n\nstepSize = filterStep(safety * hNew * FastMath.pow(error, -0.5), forward, nextIsLast);\n\nif (error > 1.0) {\n    stepStart = previousStepStart;\n    System.arraycopy(previousY, 0, y, 0, y.length);\n    System.arraycopy(previousYDot, 0, yDotK[0], 0, y.length);\n    continue;\n}\n\ninterpolator.storeTime(stepStart + hNew);\nSystem.arraycopy(yTmp, 0, y, 0, y0.length);\nSystem.arraycopy(yDotK[0], 0, yDotTmp, 0, y0.length);\nstepStart = acceptStep(interpolator, y, yDotTmp, t);\nSystem.arraycopy(y, 0, yTmp, 0, y.length);\n\nif (!isLastStep) {\n    interpolator.storeTime(stepStart);\n    if (fsal) {\n        System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n    }\n\n    final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n    hNew = filterStep(stepSize * factor, forward, nextIsLast);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 13ced27d7..eb8084eb2 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -247,6 +247,52 @@ public abstract class EmbeddedRungeKuttaIntegrator\n         }\n \n         stepSize = hNew;\n+if (nextIsLast) {\n+    hNew = t - stepStart;\n+}\n+\n+for (int j = 0; j < y0.length; ++j) {\n+    double sum    = b[0] * yDotK[0][j];\n+    for (int l = 1; l < stages; ++l) {\n+        sum    += b[l] * yDotK[l][j];\n+    }\n+    yTmp[j] = y[j] + hNew * sum;\n+}\n+\n+computeDerivatives(stepStart + hNew, yTmp, yDotK[0]);\n+final double errorNew = estimateError(yDotK, y, yTmp, hNew);\n+\n+if (errorNew > error) {\n+    filterStep(safety * stepSize * FastMath.pow(errorNew, -0.5), forward, false);\n+    continue;\n+}\n+\n+error = errorNew;\n+\n+stepSize = filterStep(safety * hNew * FastMath.pow(error, -0.5), forward, nextIsLast);\n+\n+if (error > 1.0) {\n+    stepStart = previousStepStart;\n+    System.arraycopy(previousY, 0, y, 0, y.length);\n+    System.arraycopy(previousYDot, 0, yDotK[0], 0, y.length);\n+    continue;\n+}\n+\n+interpolator.storeTime(stepStart + hNew);\n+System.arraycopy(yTmp, 0, y, 0, y0.length);\n+System.arraycopy(yDotK[0], 0, yDotTmp, 0, y0.length);\n+stepStart = acceptStep(interpolator, y, yDotTmp, t);\n+System.arraycopy(y, 0, yTmp, 0, y.length);\n+\n+if (!isLastStep) {\n+    interpolator.storeTime(stepStart);\n+    if (fsal) {\n+        System.arraycopy(yDotTmp, 0, yDotK[0], 0, y0.length);\n+    }\n+\n+    final double factor = FastMath.min(maxGrowth, FastMath.max(minReduction, safety * FastMath.pow(error, exp)));\n+    hNew = filterStep(stepSize * factor, forward, nextIsLast);\n+}\n \n         // next stages\n         for (int k = 1; k < stages; ++k) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}