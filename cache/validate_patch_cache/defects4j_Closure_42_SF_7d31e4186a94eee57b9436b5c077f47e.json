{
    "patch": "import java.util.HashSet;\nimport java.util.Set;\nimport org.mozilla.javascript.Node;\nimport org.mozilla.javascript.Token;\nimport org.mozilla.javascript.ast.*;\n\npublic class TransformDispatcher implements IRFactory.TransformDispatcher {\n\n  private final String sourceName;\n  private final AstRoot astRoot;\n  private final ErrorReporter errorReporter;\n\n  private static final Set<String> ALLOWED_DIRECTIVES = new HashSet<>();\n\n  static {\n    ALLOWED_DIRECTIVES.add(\"use strict\");\n    ALLOWED_DIRECTIVES.add(\"@license\");\n  }\n\n  public TransformDispatcher(\n      String sourceName, AstRoot astRoot, ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.astRoot = astRoot;\n    this.errorReporter = errorReporter;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT\n        && n.getFirstChild().isString()\n        && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  private Node newNode(int type, AstNode... children) {\n    Node node = new Node(type);\n    for (AstNode child : children) {\n      if (child != null) {\n        node.addChildToBack(child);\n      }\n    }\n    return node;\n  }\n\n  private Node transform(AstNode node) {\n    if (node == null) return null;\n    return node.visit(this);\n  }\n\n  private Node transformBlock(AstNode node) {\n    if (node == null) return null;\n    if (node instanceof Block) {\n      return processBlock((Block) node);\n    }\n    return transform(node);\n  }\n\n  private int transformTokenType(int type) {\n    switch (type) {\n      case Token.LE:\n        return Token.LT;\n      case Token.GE:\n        return Token.GT;\n      case Token.SEQ:\n        return Token.EQ;\n      case Token.NE:\n        return Token.NE;\n      case Token.AND:\n        return Token.AND;\n      case Token.OR:\n        return Token.OR;\n      case Token.BITOR:\n        return Token.BITOR;\n      case Token.BITXOR:\n        return Token.BITXOR;\n      case Token.BITAND:\n        return Token.BITAND;\n      case Token.SHEQ:\n        return Token.EQ;\n      case Token.SHNE:\n        return Token.NE;\n      case Token.MUL:\n        return Token.MUL;\n      case Token.DIV:\n        return Token.DIV;\n      case Token.MOD:\n        return Token.MOD;\n      case Token.ADD:\n        return Token.ADD;\n      case Token.SUB:\n        return Token.SUB;\n      case Token.LSH:\n        return Token.LSH;\n      case Token.RSH:\n        return Token.RSH;\n      case Token.URSH:\n        return Token.URSH;\n      case Token.NOT:\n        return Token.NOT;\n      case Token.BITNOT:\n        return Token.BITNOT;\n      default:\n        return type;\n    }\n  }\n\n  private boolean isBlockEmpty(Block blockNode) {\n    return blockNode.getStatements().isEmpty();\n  }\n\n  // Implementing TypeSafeDispatcher methods\n\n  @Override\n  public Node processBlock(Block blockNode) {\n    Node block = newNode(Token.BLOCK);\n    for (AstNode statement : blockNode.getStatements()) {\n      Node transformed = transform(statement);\n      if (transformed != null) {\n        block.addChildToBack(transformed);\n      }\n    }\n    return block;\n  }\n\n  @Override\n  public Node processFunctionCall(FunctionCall callNode) {\n    Node call = new Node(Token.CALL, transform(callNode.getTarget()));\n    for (AstNode arg : callNode.getArguments()) {\n      call.addChildToBack(transform(arg));\n    }\n    return call;\n  }\n\n  @Override\n  public Node processFunctionNode(FunctionNode functionNode) {\n    Node function =\n        new Node(Token.FUNCTION, new Node(Token.NAME, functionNode.getName()), processBlock(functionNode.getBody()));\n    function.setIsArrowFunction(functionNode.isArrowFunction());\n    Node arguments = function.getFirstChild().getNext().setIsVarArgs(functionNode.isVarArgs());\n    for (int i = 0; i < functionNode.getParams().size(); i++) {\n      Name name = functionNode.getParams().get(i);\n      if (name.getIdentifier().equals(\"this\")) {\n        arguments.addChildToBack(newNode(Token.THIS));\n      } else {\n        arguments.addChildToBack(newNode(Token.NAME, name.getIdentifier()));\n      }\n    }\n    function.setLineno(functionNode.getLineno());\n    return function;\n  }\n\n  @Override\n  public Node processVariableInitializer(VariableInitializer initializerNode) {\n    Node name = transform(initializerNode.getTarget());\n    Node value = transform(initializerNode.getInitializer());\n\n    Node var = new Node(Token.VAR);\n    var.addChildToBack(name);\n    if (value != null) {\n      var.addChildToBack(value);\n    }\n    return var;\n  }\n\n  @Override\n  public Node processName(Name nameNode) {\n    return new Node(Token.NAME, nameNode.getIdentifier());\n  }\n\n  @Override\n  public Node processNumber(NumberLiteral numberNode) {\n    return new Node(Token.NUMBER, numberNode.getNumber());\n  }\n\n  @Override\n  public Node processString(StringLiteral stringNode) {\n    return new Node(Token.STRING, stringNode.getValue());\n  }\n\n  @Override\n  public Node processRegExp(RegExpLiteral regExpNode) {\n    return new Node(Token.REGEXP, regExpNode.getValue());\n  }\n\n  @Override\n  public Node processBinary(BinaryExpression exprNode) {\n    int leftToken = transformTokenType(exprNode.getLeft().getType());\n    int rightToken = transformTokenType(exprNode.getRight().getType());\n    return newNode(\n        rightToken, transform(exprNode.getLeft()), transform(exprNode.getRight()));\n  }\n\n  @Override\n  public Node processUnary(UnaryExpression unaryNode) {\n    int tokenType = transformTokenType(unaryNode.getType());\n    if (tokenType == Token.TYPEOF && unaryNode.getOperand() instanceof XmlElemRef) {\n      errorReporter.error(\n          \"Typeof is not allowed for XML element references\",\n          sourceName,\n          unaryNode.getLineno(),\n          null,\n          0);\n    }\n    return new Node(tokenType, transform(unaryNode.getOperand()));\n  }\n\n  @Override\n  public Node processObjectProperty(ObjectProperty propNode) {\n    AstNode propNameNode = propNode.getLeft();\n    if (propNameNode instanceof Name) {\n      return newNode(\n          Token.STRING,\n          new Node(Token.STRING_KEY, ((Name) propNameNode).getIdentifier()),\n          transform(propNode.getRight()));\n    }\n    if (propNameNode instanceof StringLiteral) {\n      return newNode(\n          Token.STRING,\n          new Node(Token.STRING_KEY, ((StringLiteral) propNameNode).getValue()),\n          transform(propNode.getRight()));\n    }\n    if (propNameNode instanceof NumberLiteral) {\n      return newNode(\n          Token.STRING,\n          new Node(Token.STRING_KEY, ((NumberLiteral) propNameNode).getValue()),\n          transform(propNode.getRight()));\n    }\n    return null;\n  }\n\n  @Override\n  public Node processArrayLiteral(ArrayLiteral arrayNode) {\n    Node array = new Node(Token.ARRAYLIT);\n    for (AstNode element : arrayNode.getElements()) {\n      array.addChildToBack(transform(element));\n    }\n    return array;\n  }\n\n  @Override\n  public Node processObjectLiteral(ObjectLiteral objectNode) {\n    Node obj = new Node(Token.OBJECTLIT);\n    for (ObjectProperty prop : objectNode.getElements()) {\n      Node nameValue = transform(prop);\n      if (nameValue != null) {\n        obj.addChildToBack(nameValue);\n      }\n    }\n    return obj;\n  }\n\n  @Override\n  public Node processPropertyGet(PropertyGet propertyGetNode) {\n    return new Node(Token.GETPROP, transform(propertyGetNode.getTarget()), new Node(Token.STRING, propertyGetNode.getProperty().getIdentifier()));\n  }\n\n  @Override\n  public Node processElementGet(ElementGet elementGetNode) {\n    return new Node(Token.GETELEM, transform(elementGetNode.getTarget()), transform(elementGetNode.getElement()));\n  }\n\n  @Override\n  public Node processConditionalExpression(ConditionalExpression conditionalExpression) {\n    Node conditional = new Node(Token.HOOK, transform(conditionalExpression.getTestExpression()));\n    conditional.addChildToBack(transform(conditionalExpression.getTrueExpression()));\n    conditional.addChildToBack(transform(conditionalExpression.getFalseExpression()));\n    return conditional;\n  }\n\n  @Override\n  public Node processInfixExpression(InfixExpression infixExpression) {\n    int operatorType = infixExpression.getType();\n    if (infixExpression instanceof XmlDotQuery) {\n      XmlDotQuery x = (XmlDotQuery) infixExpression;\n      return new Node(Token.DOTQUERY, transform(x.getLeft()), transform(x.getRight()));\n    } else if (infixExpression instanceof XmlElemRef) {\n      XmlElemRef x = (XmlElemRef) infixExpression;\n      return new Node(Token.REF, transform(x.getLeft()), transform(x.getRight()));\n    } else if (infixExpression.getLeft().getType() == Token.STRING\n        && infixExpression.getLeft().getString().equals(\"typeof\")) {\n      operatorType = Token.TYPEOF;\n    }\n    Node result = new Node(operatorType, transform(infixExpression.getLeft()), transform(infixExpression.getRight()));\n    if (operatorType == Token.INSTANCEOF) {\n      return new Node(Token.PAREN, result);\n    }\n    return result;\n  }\n\n  @Override\n  public Node processExpressionStatement(ExpressionStatement statementNode) {\n    return new Node(Token.EXPR_VOID, transform(statementNode.getExpression()));\n  }\n\n  @Override\n  public Node processEmptyStatement(EmptyStatement statementNode) {\n    return new Node(Token.EMPTY);\n  }\n\n  @Override\n  public Node processIfStatement(IfStatement statementNode) {\n    Node ifNode = new Node(Token.IF, transform(statementNode.getCondition()));\n    ifNode.addChildToBack(transform(statementNode.getThenPart()));\n    if (statementNode.getElsePart() != null) {\n      ifNode.addChildToBack(transform(statementNode.getElsePart()));\n    }\n    return ifNode;\n  }\n\n  @Override\n  public Node processSwitchStatement(SwitchStatement statementNode) {\n    Node switchNode = new Node(Token.SWITCH, transform(statementNode.getExpression()));\n    for (SwitchCase caseNode : statementNode.getCases()) {\n      Node caseGroup = new Node(Token.CASE, transform(caseNode.getExpression()));\n      for (AstNode stmt : caseNode.getStatements()) {\n        caseGroup.addChildToBack(transform(stmt));\n      }\n      switchNode.addChildToBack(caseGroup);\n    }\n    return switchNode;\n  }\n\n  @Override\n  public Node processWhileLoop(WhileLoop loopNode) {\n    return new Node(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processDoLoop(DoLoop loopNode) {\n    return new Node(Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n  }\n\n  @Override\n  public Node processForLoop(ForLoop loopNode) {\n    Node forNode = new Node(Token.FOR);\n    if (loopNode.getInitializer() instanceof VariableDeclaration) {\n      forNode.addChildToBack(transform(loopNode.getInitializer()));\n    } else if (loopNode.getInitializer() != null) {\n      // This should be an expression.\n      Node fakeVar = newNode(Token.VAR, new Node(Token.EMPTY));\n      fakeVar.getFirstChild().addChildToBack(transform(loopNode.getInitializer()));\n      forNode.addChildToBack(fakeVar);\n    } else {\n      forNode.addChildToBack(newNode(Token.EMPTY));\n    }\n    forNode.addChildToBack(transform(loopNode.getCondition()));\n    forNode.addChildToBack(transform(loopNode.getIncrement()));\n    forNode.addChildToBack(transformBlock(loopNode.getBody()));\n    return forNode;\n  }\n\n  @Override\n  public Node processForInLoop(ForInLoop loopNode) {\n    Node lhs = transform(loopNode.getIterator());\n    Node obj = transform(loopNode.getIteratedObject());\n    Node body = transformBlock(loopNode.getBody());\n    // Wrap lhs in a variable declaration to ensure a distinct variable is used.\n    Node decl = new Node(Token.VAR, new Node(Token.EMPTY));\n    decl.getFirstChild().addChildToBack(lhs);\n\n    Node forIn = new Node(Token.FOR_IN, decl, obj, body);\n    forIn.putProp(Node.FOR_OF, false);\n    return forIn;\n  }\n\n  @Override\n  public Node processBreakStatement(BreakStatement statementNode) {\n    Node breakNode = new Node(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      breakNode.addChildToBack(transform(statementNode.getBreakLabel()));\n    }\n    return breakNode;\n  }\n\n  @Override\n  public Node processContinueStatement(ContinueStatement statementNode) {\n    Node continueNode = new Node(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      continueNode.addChildToBack(transform(statementNode.getLabel()));\n    }\n    return continueNode;\n  }\n\n  @Override\n  public Node processVariableDeclaration(VariableDeclaration statementNode) {\n    Node var = new Node(Token.VAR);\n    for (VariableInitializer init : statementNode.getVariables()) {\n      Node varInit = transform(init);\n      if (varInit != null) {\n        var.addChildToBack(varInit);\n      }\n    }\n    return var;\n  }\n\n  @Override\n  public Node processReturnStatement(ReturnStatement statementNode) {\n    return new Node(Token.RETURN, transform(statementNode.getReturnValue()));\n  }\n\n  @Override\n  public Node processTryStatement(TryStatement statementNode) {\n    Node tryNode = new Node(Token.TRY, transformBlock(statementNode.getTryBlock()));\n    for (CatchClause catchClause : statementNode.getCatchClauses()) {\n      tryNode.addChildToBack(transform(catchClause));\n    }\n    if (statementNode.getFinallyBlock() != null) {\n      tryNode.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n    }\n    return tryNode;\n  }\n\n  @Override\n  public Node processThrowStatement(ThrowStatement statementNode) {\n    return new Node(Token.THROW, transform(statementNode.getExpression()));\n  }\n\n  @Override\n  public Node processNewExpression(NewExpression newExpression) {\n    int type = newExpression.isCall() ? Token.CALL_NEW : Token.NEW;\n    Node call = new Node(type, transform(newExpression.getTarget()));\n    for (AstNode arg : newExpression.getArguments()) {\n    ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..4b55c6da 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,430 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import java.util.HashSet;\n+import java.util.Set;\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+import org.mozilla.javascript.ast.*;\n+\n+public class TransformDispatcher implements IRFactory.TransformDispatcher {\n+\n+  private final String sourceName;\n+  private final AstRoot astRoot;\n+  private final ErrorReporter errorReporter;\n+\n+  private static final Set<String> ALLOWED_DIRECTIVES = new HashSet<>();\n+\n+  static {\n+    ALLOWED_DIRECTIVES.add(\"use strict\");\n+    ALLOWED_DIRECTIVES.add(\"@license\");\n+  }\n+\n+  public TransformDispatcher(\n+      String sourceName, AstRoot astRoot, ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.astRoot = astRoot;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT\n+        && n.getFirstChild().isString()\n+        && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private Node newNode(int type, AstNode... children) {\n+    Node node = new Node(type);\n+    for (AstNode child : children) {\n+      if (child != null) {\n+        node.addChildToBack(child);\n+      }\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  private Node transform(AstNode node) {\n+    if (node == null) return null;\n+    return node.visit(this);\n+  }\n+\n+  private Node transformBlock(AstNode node) {\n+    if (node == null) return null;\n+    if (node instanceof Block) {\n+      return processBlock((Block) node);\n     }\n+    return transform(node);\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  private int transformTokenType(int type) {\n+    switch (type) {\n+      case Token.LE:\n+        return Token.LT;\n+      case Token.GE:\n+        return Token.GT;\n+      case Token.SEQ:\n+        return Token.EQ;\n+      case Token.NE:\n+        return Token.NE;\n+      case Token.AND:\n+        return Token.AND;\n+      case Token.OR:\n+        return Token.OR;\n+      case Token.BITOR:\n+        return Token.BITOR;\n+      case Token.BITXOR:\n+        return Token.BITXOR;\n+      case Token.BITAND:\n+        return Token.BITAND;\n+      case Token.SHEQ:\n+        return Token.EQ;\n+      case Token.SHNE:\n+        return Token.NE;\n+      case Token.MUL:\n+        return Token.MUL;\n+      case Token.DIV:\n+        return Token.DIV;\n+      case Token.MOD:\n+        return Token.MOD;\n+      case Token.ADD:\n+        return Token.ADD;\n+      case Token.SUB:\n+        return Token.SUB;\n+      case Token.LSH:\n+        return Token.LSH;\n+      case Token.RSH:\n+        return Token.RSH;\n+      case Token.URSH:\n+        return Token.URSH;\n+      case Token.NOT:\n+        return Token.NOT;\n+      case Token.BITNOT:\n+        return Token.BITNOT;\n+      default:\n+        return type;\n+    }\n+  }\n+\n+  private boolean isBlockEmpty(Block blockNode) {\n+    return blockNode.getStatements().isEmpty();\n+  }\n+\n+  // Implementing TypeSafeDispatcher methods\n+\n+  @Override\n+  public Node processBlock(Block blockNode) {\n+    Node block = newNode(Token.BLOCK);\n+    for (AstNode statement : blockNode.getStatements()) {\n+      Node transformed = transform(statement);\n+      if (transformed != null) {\n+        block.addChildToBack(transformed);\n       }\n-      return node;\n     }\n+    return block;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  @Override\n+  public Node processFunctionCall(FunctionCall callNode) {\n+    Node call = new Node(Token.CALL, transform(callNode.getTarget()));\n+    for (AstNode arg : callNode.getArguments()) {\n+      call.addChildToBack(transform(arg));\n+    }\n+    return call;\n+  }\n+\n+  @Override\n+  public Node processFunctionNode(FunctionNode functionNode) {\n+    Node function =\n+        new Node(Token.FUNCTION, new Node(Token.NAME, functionNode.getName()), processBlock(functionNode.getBody()));\n+    function.setIsArrowFunction(functionNode.isArrowFunction());\n+    Node arguments = function.getFirstChild().getNext().setIsVarArgs(functionNode.isVarArgs());\n+    for (int i = 0; i < functionNode.getParams().size(); i++) {\n+      Name name = functionNode.getParams().get(i);\n+      if (name.getIdentifier().equals(\"this\")) {\n+        arguments.addChildToBack(newNode(Token.THIS));\n+      } else {\n+        arguments.addChildToBack(newNode(Token.NAME, name.getIdentifier()));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n+    function.setLineno(functionNode.getLineno());\n+    return function;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+  @Override\n+  public Node processVariableInitializer(VariableInitializer initializerNode) {\n+    Node name = transform(initializerNode.getTarget());\n+    Node value = transform(initializerNode.getInitializer());\n+\n+    Node var = new Node(Token.VAR);\n+    var.addChildToBack(name);\n+    if (value != null) {\n+      var.addChildToBack(value);\n+    }\n+    return var;\n+  }\n+\n+  @Override\n+  public Node processName(Name nameNode) {\n+    return new Node(Token.NAME, nameNode.getIdentifier());\n+  }\n+\n+  @Override\n+  public Node processNumber(NumberLiteral numberNode) {\n+    return new Node(Token.NUMBER, numberNode.getNumber());\n+  }\n+\n+  @Override\n+  public Node processString(StringLiteral stringNode) {\n+    return new Node(Token.STRING, stringNode.getValue());\n+  }\n+\n+  @Override\n+  public Node processRegExp(RegExpLiteral regExpNode) {\n+    return new Node(Token.REGEXP, regExpNode.getValue());\n+  }\n+\n+  @Override\n+  public Node processBinary(BinaryExpression exprNode) {\n+    int leftToken = transformTokenType(exprNode.getLeft().getType());\n+    int rightToken = transformTokenType(exprNode.getRight().getType());\n+    return newNode(\n+        rightToken, transform(exprNode.getLeft()), transform(exprNode.getRight()));\n+  }\n+\n+  @Override\n+  public Node processUnary(UnaryExpression unaryNode) {\n+    int tokenType = transformTokenType(unaryNode.getType());\n+    if (tokenType == Token.TYPEOF && unaryNode.getOperand() instanceof XmlElemRef) {\n+      errorReporter.error(\n+          \"Typeof is not allowed for XML element references\",\n+          sourceName,\n+          unaryNode.getLineno(),\n+          null,\n+          0);\n+    }\n+    return new Node(tokenType, transform(unaryNode.getOperand()));\n+  }\n+\n+  @Override\n+  public Node processObjectProperty(ObjectProperty propNode) {\n+    AstNode propNameNode = propNode.getLeft();\n+    if (propNameNode instanceof Name) {\n+      return newNode(\n+          Token.STRING,\n+          new Node(Token.STRING_KEY, ((Name) propNameNode).getIdentifier()),\n+          transform(propNode.getRight()));\n+    }\n+    if (propNameNode instanceof StringLiteral) {\n+      return newNode(\n+          Token.STRING,\n+          new Node(Token.STRING_KEY, ((StringLiteral) propNameNode).getValue()),\n+          transform(propNode.getRight()));\n+    }\n+    if (propNameNode instanceof NumberLiteral) {\n       return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+          Token.STRING,\n+          new Node(Token.STRING_KEY, ((NumberLiteral) propNameNode).getValue()),\n+          transform(propNode.getRight()));\n     }\n+    return null;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  @Override\n+  public Node processArrayLiteral(ArrayLiteral arrayNode) {\n+    Node array = new Node(Token.ARRAYLIT);\n+    for (AstNode element : arrayNode.getElements()) {\n+      array.addChildToBack(transform(element));\n+    }\n+    return array;\n+  }\n+\n+  @Override\n+  public Node processObjectLiteral(ObjectLiteral objectNode) {\n+    Node obj = new Node(Token.OBJECTLIT);\n+    for (ObjectProperty prop : objectNode.getElements()) {\n+      Node nameValue = transform(prop);\n+      if (nameValue != null) {\n+        obj.addChildToBack(nameValue);\n       }\n-      return node;\n     }\n+    return obj;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  @Override\n+  public Node processPropertyGet(PropertyGet propertyGetNode) {\n+    return new Node(Token.GETPROP, transform(propertyGetNode.getTarget()), new Node(Token.STRING, propertyGetNode.getProperty().getIdentifier()));\n+  }\n+\n+  @Override\n+  public Node processElementGet(ElementGet elementGetNode) {\n+    return new Node(Token.GETELEM, transform(elementGetNode.getTarget()), transform(elementGetNode.getElement()));\n+  }\n+\n+  @Override\n+  public Node processConditionalExpression(ConditionalExpression conditionalExpression) {\n+    Node conditional = new Node(Token.HOOK, transform(conditionalExpression.getTestExpression()));\n+    conditional.addChildToBack(transform(conditionalExpression.getTrueExpression()));\n+    conditional.addChildToBack(transform(conditionalExpression.getFalseExpression()));\n+    return conditional;\n+  }\n+\n+  @Override\n+  public Node processInfixExpression(InfixExpression infixExpression) {\n+    int operatorType = infixExpression.getType();\n+    if (infixExpression instanceof XmlDotQuery) {\n+      XmlDotQuery x = (XmlDotQuery) infixExpression;\n+      return new Node(Token.DOTQUERY, transform(x.getLeft()), transform(x.getRight()));\n+    } else if (infixExpression instanceof XmlElemRef) {\n+      XmlElemRef x = (XmlElemRef) infixExpression;\n+      return new Node(Token.REF, transform(x.getLeft()), transform(x.getRight()));\n+    } else if (infixExpression.getLeft().getType() == Token.STRING\n+        && infixExpression.getLeft().getString().equals(\"typeof\")) {\n+      operatorType = Token.TYPEOF;\n+    }\n+    Node result = new Node(operatorType, transform(infixExpression.getLeft()), transform(infixExpression.getRight()));\n+    if (operatorType == Token.INSTANCEOF) {\n+      return new Node(Token.PAREN, result);\n+    }\n+    return result;\n+  }\n+\n+  @Override\n+  public Node processExpressionStatement(ExpressionStatement statementNode) {\n+    return new Node(Token.EXPR_VOID, transform(statementNode.getExpression()));\n+  }\n+\n+  @Override\n+  public Node processEmptyStatement(EmptyStatement statementNode) {\n+    return new Node(Token.EMPTY);\n+  }\n+\n+  @Override\n+  public Node processIfStatement(IfStatement statementNode) {\n+    Node ifNode = new Node(Token.IF, transform(statementNode.getCondition()));\n+    ifNode.addChildToBack(transform(statementNode.getThenPart()));\n+    if (statementNode.getElsePart() != null) {\n+      ifNode.addChildToBack(transform(statementNode.getElsePart()));\n     }\n+    return ifNode;\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  public Node processSwitchStatement(SwitchStatement statementNode) {\n+    Node switchNode = new Node(Token.SWITCH, transform(statementNode.getExpression()));\n+    for (SwitchCase caseNode : statementNode.getCases()) {\n+      Node caseGroup = new Node(Token.CASE, transform(caseNode.getExpression()));\n+      for (AstNode stmt : caseNode.getStatements()) {\n+        caseGroup.addChildToBack(transform(stmt));\n+      }\n+      switchNode.addChildToBack(caseGroup);\n     }\n+    return switchNode;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node processWhileLoop(WhileLoop loopNode) {\n+    return new Node(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processDoLoop(DoLoop loopNode) {\n+    return new Node(Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  public Node processForLoop(ForLoop loopNode) {\n+    Node forNode = new Node(Token.FOR);\n+    if (loopNode.getInitializer() instanceof VariableDeclaration) {\n+      forNode.addChildToBack(transform(loopNode.getInitializer()));\n+    } else if (loopNode.getInitializer() != null) {\n+      // This should be an expression.\n+      Node fakeVar = newNode(Token.VAR, new Node(Token.EMPTY));\n+      fakeVar.getFirstChild().addChildToBack(transform(loopNode.getInitializer()));\n+      forNode.addChildToBack(fakeVar);\n+    } else {\n+      forNode.addChildToBack(newNode(Token.EMPTY));\n     }\n+    forNode.addChildToBack(transform(loopNode.getCondition()));\n+    forNode.addChildToBack(transform(loopNode.getIncrement()));\n+    forNode.addChildToBack(transformBlock(loopNode.getBody()));\n+    return forNode;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  public Node processForInLoop(ForInLoop loopNode) {\n+    Node lhs = transform(loopNode.getIterator());\n+    Node obj = transform(loopNode.getIteratedObject());\n+    Node body = transformBlock(loopNode.getBody());\n+    // Wrap lhs in a variable declaration to ensure a distinct variable is used.\n+    Node decl = new Node(Token.VAR, new Node(Token.EMPTY));\n+    decl.getFirstChild().addChildToBack(lhs);\n+\n+    Node forIn = new Node(Token.FOR_IN, decl, obj, body);\n+    forIn.putProp(Node.FOR_OF, false);\n+    return forIn;\n+  }\n+\n+  @Override\n+  public Node processBreakStatement(BreakStatement statementNode) {\n+    Node breakNode = new Node(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      breakNode.addChildToBack(transform(statementNode.getBreakLabel()));\n     }\n+    return breakNode;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  public Node processContinueStatement(ContinueStatement statementNode) {\n+    Node continueNode = new Node(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      continueNode.addChildToBack(transform(statementNode.getLabel()));\n+    }\n+    return continueNode;\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  public Node processVariableDeclaration(VariableDeclaration statementNode) {\n+    Node var = new Node(Token.VAR);\n+    for (VariableInitializer init : statementNode.getVariables()) {\n+      Node varInit = transform(init);\n+      if (varInit != null) {\n+        var.addChildToBack(varInit);\n+      }\n     }\n+    return var;\n+  }\n+\n+  @Override\n+  public Node processReturnStatement(ReturnStatement statementNode) {\n+    return new Node(Token.RETURN, transform(statementNode.getReturnValue()));\n+  }\n+\n+  @Override\n+  public Node processTryStatement(TryStatement statementNode) {\n+    Node tryNode = new Node(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+    for (CatchClause catchClause : statementNode.getCatchClauses()) {\n+      tryNode.addChildToBack(transform(catchClause));\n+    }\n+    if (statementNode.getFinallyBlock() != null) {\n+      tryNode.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n+    }\n+    return tryNode;\n+  }\n+\n+  @Override\n+  public Node processThrowStatement(ThrowStatement statementNode) {\n+    return new Node(Token.THROW, transform(statementNode.getExpression()));\n+  }\n+\n+  @Override\n+  public Node processNewExpression(NewExpression newExpression) {\n+    int type = newExpression.isCall() ? Token.CALL_NEW : Token.NEW;\n+    Node call = new Node(type, transform(newExpression.getTarget()));\n+    for (AstNode arg : newExpression.getArguments()) {\n+    \n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}