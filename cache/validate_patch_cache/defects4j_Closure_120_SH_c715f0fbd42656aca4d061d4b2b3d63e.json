{
    "patch": "        BlockScope scope = getCurrentScope();\n        Definition definition = attemptGetGlobalSlot(name);\n        if (definition != null && definition.getName().equals(name) && scope.getRoot().getName().equals(name)) {\n          // Special case: this is a definition matching the global built-in object.\n          definition = null;\n        } else if (definition == null) {\n          // If we haven't found anything, we recurse into the enclosing scope.\n          definition = findVariableDefinition(name, true);\n        } else {\n          if (definition.getType() == Type.ERROR) {\n            return definition;\n          }\n\n          if (isSkipFunctionVariable(name)) {\n            // Ignore redeclarations of known variables.\n            return definition;\n          }\n\n          if (definition.getScope() != scope) {\n            if (scope.getMinimizedName() == null || scope == getGlobalScope()) {\n              /*\n               * If the variable appears in an inner scope, we need to make\n               * sure it's declared in its original scope (within the file, if not global).\n               */\n              error(\n                  \"variable \" + name + \" is undeclared in the function\",\n                  getSourceName(),\n                  node.getLineno(),\n                  ChainedProperties.get(\n                      \"compiler.report.undeclared\"),\n                  name);\n            }\n\n            // Repair: change the scope of the definition to the current scope.\n            Definition fixedDefinition = definition.withScope(scope);\n            swapDefinition(definition, fixedDefinition);\n            definition = fixedDefinition;\n          } else if (isAllowSharpVariable(name)\n              && definition.getKind() != Kind.SHARP) {\n            /*\n             * Special case: we encountered a sharp variable outside of the\n             * block where it was declared.\n             */\n            warning(\n                \"var \" + name + \" has already been declared in the current scope\",\n                getSourceName(),\n                node.getLineno(),\n                String.valueOf(node.getCharno()));\n            return definition;\n          }\n\n          // Check whether the redeclaration is a valid one.\n          VarCheck.checkRedeclaration(\n              scope, name, definition, getSourceName(),\n              node.getLineno(), getCompiler());\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..62756eba 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,62 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+        BlockScope scope = getCurrentScope();\n+        Definition definition = attemptGetGlobalSlot(name);\n+        if (definition != null && definition.getName().equals(name) && scope.getRoot().getName().equals(name)) {\n+          // Special case: this is a definition matching the global built-in object.\n+          definition = null;\n+        } else if (definition == null) {\n+          // If we haven't found anything, we recurse into the enclosing scope.\n+          definition = findVariableDefinition(name, true);\n+        } else {\n+          if (definition.getType() == Type.ERROR) {\n+            return definition;\n+          }\n+\n+          if (isSkipFunctionVariable(name)) {\n+            // Ignore redeclarations of known variables.\n+            return definition;\n+          }\n+\n+          if (definition.getScope() != scope) {\n+            if (scope.getMinimizedName() == null || scope == getGlobalScope()) {\n+              /*\n+               * If the variable appears in an inner scope, we need to make\n+               * sure it's declared in its original scope (within the file, if not global).\n+               */\n+              error(\n+                  \"variable \" + name + \" is undeclared in the function\",\n+                  getSourceName(),\n+                  node.getLineno(),\n+                  ChainedProperties.get(\n+                      \"compiler.report.undeclared\"),\n+                  name);\n+            }\n+\n+            // Repair: change the scope of the definition to the current scope.\n+            Definition fixedDefinition = definition.withScope(scope);\n+            swapDefinition(definition, fixedDefinition);\n+            definition = fixedDefinition;\n+          } else if (isAllowSharpVariable(name)\n+              && definition.getKind() != Kind.SHARP) {\n+            /*\n+             * Special case: we encountered a sharp variable outside of the\n+             * block where it was declared.\n+             */\n+            warning(\n+                \"var \" + name + \" has already been declared in the current scope\",\n+                getSourceName(),\n+                node.getLineno(),\n+                String.valueOf(node.getCharno()));\n+            return definition;\n+          }\n+\n+          // Check whether the redeclaration is a valid one.\n+          VarCheck.checkRedeclaration(\n+              scope, name, definition, getSourceName(),\n+              node.getLineno(), getCompiler());\n+        }\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}