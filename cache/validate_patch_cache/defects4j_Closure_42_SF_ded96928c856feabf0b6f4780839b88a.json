{
    "patch": "import com.google.common.collect.ImmutableSet;\nimport org.mozilla.javascript.ErrorReporter;\nimport org.mozilla.javascript.Node;\nimport org.mozilla.javascript.Token;\nimport org.mozilla.javascript.ast.*;\n\nimport java.util.Set;\n\nclass IRFactory {\n  private final String sourceName;\n  private final AstRoot astRoot;\n  private final Node executionScopeNode;\n  private final ErrorReporter errorReporter;\n\n  IRFactory(String source,\n            String sourceName,\n            AstRoot astRoot,\n            Node executionScopeNode,\n            ErrorReporter errorReporter) {\n    this.sourceName = sourceName;\n    this.astRoot = astRoot;\n    this.executionScopeNode = executionScopeNode;\n    this.errorReporter = errorReporter;\n  }\n\n  Node generateFunction(FunctionNode functionNode) {\n    Node function = newNode(Token.FUNCTION);\n    function.setLineno(functionNode.getLineno());\n    function.setCharno(functionNode.getCharno());\n\n    String name = functionNode.getFunctionName();\n    if (name != null) {\n      function.addChildToBack(Node.newString(Token.NAME, name));\n    }\n\n    Node paramList = Node.newString(Token.PARAM_LIST);\n    AstNode[] params = functionNode.getParams();\n    for (AstNode param : params) {\n      Node paramNode =\n          param instanceof InfixExpression && ((InfixExpression)param).getType() == Token.IN ?\n          newNode(Token.TARGET) : newNode(Token.NAME);\n      paramNode.setString(param.getString());\n      paramList.addChildToBack(paramNode);\n    }\n    function.addChildToBack(paramList);\n\n    Node block = Node.newString(Token.BLOCK);\n    Node previousBlock = block;\n    NodeTraversal.Callback recordLabels = new NodeTraversal.Callback() {\n      @Override\n      public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n        if (n.getType() == Token.LABEL) {\n          previousBlock.addChildToBack(newNode(Token.BLOCK));\n          previousBlock = previousBlock.getLastChild();\n          previousBlock.addChildToBack(\n              newNode(Token.LABEL, n.getFirstChild().getIdentifier()));\n          previousBlock.addChildToBack(newNode(Token.EMPTY));\n        }\n        return true;\n      }\n\n      @Override\n      public void visit(NodeTraversal t, Node n, Node parent) {\n      }\n    };\n    NodeTraversal.traverse(compiler, functionNode.getBody(), recordLabels);\n\n    previousBlock.addChildToBack(transform(blockNode.getBody()));\n\n    function.putProp(Node.SYNTACTIC_PURPOSE_PROPERTY, \"function\");\n\n    return function;\n  }\n\n  Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  Node processForInLoop(ForInLoop loopNode) {\n\n      // Return the bare minimum to put the AST in a valid state.\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getIterator()),\n        transform(loopNode.getIteratedObject()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  Node processForLoop(ForLoop loopNode) {\n    Node loop = newNode(\n        Token.FOR,\n        Node.newString(Token.EMPTY),\n        transform(loopNode.getCondition()),\n        Node.newString(Token.EMPTY));\n\n    if (loopNode.getInitializer() != null) {\n      loop.getFirstChild().addChildToBack(transform(loopNode.getInitializer()));\n    }\n\n    if (loopNode.getIncrement() != null) {\n      loop.getLastChild().addChildToBack(transform(loopNode.getIncrement()));\n    }\n\n    loop.addChildToBack(transformBlock(loopNode.getBody()));\n\n    return loop;\n  }\n\n  Node processFunctionCall(FunctionCall callNode) {\n    Node call = newNode(Token.CALL);\n    call.addChildToBack(transform(callNode.getTarget()));\n    for (AstNode arg : callNode.getArguments()) {\n      call.addChildToBack(transform(arg));\n    }\n    return call;\n  }\n\n  Node processFunctionNode(FunctionNode functionNode) {\n    return generateFunction(functionNode);\n  }\n\n  Node processIfStatement(IfStatement ifNode) {\n    return newNode(\n        Token.IF,\n        transform(ifNode.getCondition()),\n        transformBlock(ifNode.getThenPart()),\n        ifNode.getElsePart() != null ? transformBlock(ifNode.getElsePart()) : null);\n  }\n\n  Node processLabeledStatement(LabeledStatement labelledStatementNode) {\n    Node block = newNode(Token.BLOCK);\n    block.addChildToBack(newNode(Token.LABEL, labelledStatementNode.getLabelName()));\n    block.addChildToBack(transform(labelledStatementNode.getStatement()));\n    return block;\n  }\n\n  Node processName(Name nameNode) {\n    String identifier = nameNode.getIdentifier();\n    Node newNode;\n    if (identifier.equals(\"undefined\")) {\n      newNode = newNode(Token.VOID);\n    } else {\n      // Try to replace with this reference if we're referencing a variable defined in this function.\n      // This is not correct, but it is the closest fix currently available for the class of bugs\n      // that this transformer is concerned about.\n      Scope executionScope = NodeUtil.getEnclosingScope(executionScopeNode);\n      Scope.Variable variable = null;\n      if (executionScope != null) {\n        variable = executionScope.getClosestHoistScope().getOwnSlot(identifier);\n      }\n      // If we're accessing a variable from a parent scope, or from a sibling scope which is defined\n      // before the current scope, the hoisting mechanism ensures that the variable will always be\n      // undefined if it's accessed before it's defined. Unfortunately this class of bugs can't be\n      // fixed by this transformer.\n      if (variable != null &&\n          (variable.getDeclType() == Scope.VarDecl.Let ||\n           variable.getDeclType() == Scope.VarDecl.Const ||\n           variable.getScope() == executionScopeNode)) {\n        newNode = newNode(Token.THIS);\n        newNode.setString(identifier);\n      } else {\n        newNode = newNode(Token.NAME);\n        newNode.setString(identifier);\n      }\n    }\n    return newNode;\n  }\n\n  Node processNumber(NumberLiteral numberNode) {\n    Node number = Node.newString(Token.NUMBER, numberNode.getValue());\n    number.setLineno(numberNode.getLineno());\n    number.setCharno(numberNode.getCharno());\n    return number;\n  }\n\n  Node processObjectLiteral(ObjectLiteral objectNode) {\n    Node object = newNode(Token.OBJECTLIT);\n    for (ObjectProperty property : objectNode.getElements()) {\n      object.addChildToBack(transform(property));\n    }\n    return object;\n  }\n\n  Node processObjectProperty(ObjectProperty propertyNode) {\n    Node property = newNode();\n    if (propertyNode.getLeft() instanceof Name) {\n      property.setType(Token.STRING);\n      property.setString(((Name) propertyNode.getLeft()).getIdentifier());\n    } else {\n      property.addChildToBack(transform(propertyNode.getLeft()));\n    }\n    property.addChildToBack(transform(propertyNode.getRight()));\n    return property;\n  }\n\n  Node processParenthesizedExpression(ParenthesizedExpression node) {\n    Node result = transform(node.getExpression()).detachFromParent();\n    result.setLineno(node.getLinen",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..1fc83094 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,272 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.common.collect.ImmutableSet;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+import org.mozilla.javascript.ast.*;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+import java.util.Set;\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+class IRFactory {\n+  private final String sourceName;\n+  private final AstRoot astRoot;\n+  private final Node executionScopeNode;\n+  private final ErrorReporter errorReporter;\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  IRFactory(String source,\n+            String sourceName,\n+            AstRoot astRoot,\n+            Node executionScopeNode,\n+            ErrorReporter errorReporter) {\n+    this.sourceName = sourceName;\n+    this.astRoot = astRoot;\n+    this.executionScopeNode = executionScopeNode;\n+    this.errorReporter = errorReporter;\n+  }\n+\n+  Node generateFunction(FunctionNode functionNode) {\n+    Node function = newNode(Token.FUNCTION);\n+    function.setLineno(functionNode.getLineno());\n+    function.setCharno(functionNode.getCharno());\n+\n+    String name = functionNode.getFunctionName();\n+    if (name != null) {\n+      function.addChildToBack(Node.newString(Token.NAME, name));\n+    }\n+\n+    Node paramList = Node.newString(Token.PARAM_LIST);\n+    AstNode[] params = functionNode.getParams();\n+    for (AstNode param : params) {\n+      Node paramNode =\n+          param instanceof InfixExpression && ((InfixExpression)param).getType() == Token.IN ?\n+          newNode(Token.TARGET) : newNode(Token.NAME);\n+      paramNode.setString(param.getString());\n+      paramList.addChildToBack(paramNode);\n+    }\n+    function.addChildToBack(paramList);\n+\n+    Node block = Node.newString(Token.BLOCK);\n+    Node previousBlock = block;\n+    NodeTraversal.Callback recordLabels = new NodeTraversal.Callback() {\n+      @Override\n+      public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+        if (n.getType() == Token.LABEL) {\n+          previousBlock.addChildToBack(newNode(Token.BLOCK));\n+          previousBlock = previousBlock.getLastChild();\n+          previousBlock.addChildToBack(\n+              newNode(Token.LABEL, n.getFirstChild().getIdentifier()));\n+          previousBlock.addChildToBack(newNode(Token.EMPTY));\n+        }\n+        return true;\n       }\n-      return node;\n-    }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+      @Override\n+      public void visit(NodeTraversal t, Node n, Node parent) {\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    };\n+    NodeTraversal.traverse(compiler, functionNode.getBody(), recordLabels);\n+\n+    previousBlock.addChildToBack(transform(blockNode.getBody()));\n+\n+    function.putProp(Node.SYNTACTIC_PURPOSE_PROPERTY, \"function\");\n+\n+    return function;\n+  }\n+\n+  Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  Node processForInLoop(ForInLoop loopNode) {\n+\n+      // Return the bare minimum to put the AST in a valid state.\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getIterator()),\n+        transform(loopNode.getIteratedObject()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  Node processForLoop(ForLoop loopNode) {\n+    Node loop = newNode(\n+        Token.FOR,\n+        Node.newString(Token.EMPTY),\n+        transform(loopNode.getCondition()),\n+        Node.newString(Token.EMPTY));\n+\n+    if (loopNode.getInitializer() != null) {\n+      loop.getFirstChild().addChildToBack(transform(loopNode.getInitializer()));\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    if (loopNode.getIncrement() != null) {\n+      loop.getLastChild().addChildToBack(transform(loopNode.getIncrement()));\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    loop.addChildToBack(transformBlock(loopNode.getBody()));\n+\n+    return loop;\n+  }\n+\n+  Node processFunctionCall(FunctionCall callNode) {\n+    Node call = newNode(Token.CALL);\n+    call.addChildToBack(transform(callNode.getTarget()));\n+    for (AstNode arg : callNode.getArguments()) {\n+      call.addChildToBack(transform(arg));\n     }\n+    return call;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  Node processFunctionNode(FunctionNode functionNode) {\n+    return generateFunction(functionNode);\n+  }\n+\n+  Node processIfStatement(IfStatement ifNode) {\n+    return newNode(\n+        Token.IF,\n+        transform(ifNode.getCondition()),\n+        transformBlock(ifNode.getThenPart()),\n+        ifNode.getElsePart() != null ? transformBlock(ifNode.getElsePart()) : null);\n+  }\n+\n+  Node processLabeledStatement(LabeledStatement labelledStatementNode) {\n+    Node block = newNode(Token.BLOCK);\n+    block.addChildToBack(newNode(Token.LABEL, labelledStatementNode.getLabelName()));\n+    block.addChildToBack(transform(labelledStatementNode.getStatement()));\n+    return block;\n+  }\n+\n+  Node processName(Name nameNode) {\n+    String identifier = nameNode.getIdentifier();\n+    Node newNode;\n+    if (identifier.equals(\"undefined\")) {\n+      newNode = newNode(Token.VOID);\n+    } else {\n+      // Try to replace with this reference if we're referencing a variable defined in this function.\n+      // This is not correct, but it is the closest fix currently available for the class of bugs\n+      // that this transformer is concerned about.\n+      Scope executionScope = NodeUtil.getEnclosingScope(executionScopeNode);\n+      Scope.Variable variable = null;\n+      if (executionScope != null) {\n+        variable = executionScope.getClosestHoistScope().getOwnSlot(identifier);\n+      }\n+      // If we're accessing a variable from a parent scope, or from a sibling scope which is defined\n+      // before the current scope, the hoisting mechanism ensures that the variable will always be\n+      // undefined if it's accessed before it's defined. Unfortunately this class of bugs can't be\n+      // fixed by this transformer.\n+      if (variable != null &&\n+          (variable.getDeclType() == Scope.VarDecl.Let ||\n+           variable.getDeclType() == Scope.VarDecl.Const ||\n+           variable.getScope() == executionScopeNode)) {\n+        newNode = newNode(Token.THIS);\n+        newNode.setString(identifier);\n+      } else {\n+        newNode = newNode(Token.NAME);\n+        newNode.setString(identifier);\n+      }\n     }\n+    return newNode;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  Node processNumber(NumberLiteral numberNode) {\n+    Node number = Node.newString(Token.NUMBER, numberNode.getValue());\n+    number.setLineno(numberNode.getLineno());\n+    number.setCharno(numberNode.getCharno());\n+    return number;\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  Node processObjectLiteral(ObjectLiteral objectNode) {\n+    Node object = newNode(Token.OBJECTLIT);\n+    for (ObjectProperty property : objectNode.getElements()) {\n+      object.addChildToBack(transform(property));\n+    }\n+    return object;\n+  }\n+\n+  Node processObjectProperty(ObjectProperty propertyNode) {\n+    Node property = newNode();\n+    if (propertyNode.getLeft() instanceof Name) {\n+      property.setType(Token.STRING);\n+      property.setString(((Name) propertyNode.getLeft()).getIdentifier());\n+    } else {\n+      property.addChildToBack(transform(propertyNode.getLeft()));\n     }\n+    property.addChildToBack(transform(propertyNode.getRight()));\n+    return property;\n+  }\n+\n+  Node processParenthesizedExpression(ParenthesizedExpression node) {\n+    Node result = transform(node.getExpression()).detachFromParent();\n+    result.setLineno(node.getLinen\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}