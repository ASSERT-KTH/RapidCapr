{
    "patch": "attachLiteralTypes(n);\n\nif (n.getType() == Token.FUNCTION) {\n  if ((parent.getType() == Token.EXPR_RESULT && nodeStack.peek().getType() == Token.SCRIPT) \n    || (parent.getType() == Token.NAME \n       && (parent.getParent().getType() == Token.SCRIPT || parent.getParent().getType() == Token.BLOCK))) {\n    defineDeclaredFunction(n, parent);\n    return;\n  }\n}\n\nif (n.getType() == Token.LP && parent.getType() == Token.CALL) {\n  handleFunctionInputs(parent);\n  return;\n}\n\nif (parent.getType() == Token.SCRIPT) {\n  // definitions at the top-level scope\n  if (n.getType() == Token.VAR) {\n    defineVar(n, parent);\n    if (n.hasChildren() && n.getFirstChild().getType() == Token.NAME) {\n      for (Var v : scope.getVars()) {\n        if (v.getName().equals(n.getFirstChild().getString())) {\n          if (v.isExtern()) {\n            // We don't need an extern declaration here if the var is\n            // already in the externs file.\n            return;\n          } else {\n            // Redeclaring a var in the global scope shadows the original decl.\n            compiler.report(\n                JSError.make(\n                    dupVarDeclarationHasInitializer(n.getFirstChild().getString()),\n                    n));\n            return;\n          }\n        }\n      }\n    }\n  } else if (n.getType() == Token.NAME) {\n    defineVar(n, parent);\n  }\n  return;\n}\n\nif (n.getType() == Token.LP && parent == scope.getRootNode()) {\n  handleFunctionInputs(parent);\n  return;\n}\n\nif (n.getType() == Token.CATCH) {\n  defineCatch(n, parent);\n  return;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..4709c539 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1448,22 +1448,60 @@ final class TypedScopeCreator implements ScopeCreator {\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n+attachLiteralTypes(n);\n+\n+if (n.getType() == Token.FUNCTION) {\n+  if ((parent.getType() == Token.EXPR_RESULT && nodeStack.peek().getType() == Token.SCRIPT) \n+    || (parent.getType() == Token.NAME \n+       && (parent.getParent().getType() == Token.SCRIPT || parent.getParent().getType() == Token.BLOCK))) {\n+    defineDeclaredFunction(n, parent);\n+    return;\n+  }\n+}\n+\n+if (n.getType() == Token.LP && parent.getType() == Token.CALL) {\n+  handleFunctionInputs(parent);\n+  return;\n+}\n+\n+if (parent.getType() == Token.SCRIPT) {\n+  // definitions at the top-level scope\n+  if (n.getType() == Token.VAR) {\n+    defineVar(n, parent);\n+    if (n.hasChildren() && n.getFirstChild().getType() == Token.NAME) {\n+      for (Var v : scope.getVars()) {\n+        if (v.getName().equals(n.getFirstChild().getString())) {\n+          if (v.isExtern()) {\n+            // We don't need an extern declaration here if the var is\n+            // already in the externs file.\n+            return;\n+          } else {\n+            // Redeclaring a var in the global scope shadows the original decl.\n+            compiler.report(\n+                JSError.make(\n+                    dupVarDeclarationHasInitializer(n.getFirstChild().getString()),\n+                    n));\n             return;\n           }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n+        }\n       }\n     }\n+  } else if (n.getType() == Token.NAME) {\n+    defineVar(n, parent);\n+  }\n+  return;\n+}\n+\n+if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n+  handleFunctionInputs(parent);\n+  return;\n+}\n+\n+if (n.getType() == Token.CATCH) {\n+  defineCatch(n, parent);\n+  return;\n+}\n+    }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}