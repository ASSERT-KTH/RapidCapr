{
    "patch": "public void matchConstraint(ObjectType constraintObj) {\n    // Do nothing if the constraint object is not anonymous.\n    if (!constraintObj.isNominalType() && !constraintObj.isFunctionType()) {\n      return;\n    }\n\n    // Handle the case when the constraint object is a single-property record\n    // type: we turn the type into a type union with undefined.\n    //\n    // param constraintObj {{prop: (number|undefined)}}\n    // function f(constraintObj) {}\n    // f({prop: 123});\n    // f({otherProp: 'hello'}); // produces a warning\n    //\n    // We want to warn, unless there is already a declared property 'prop' on\n    // this object, or unless this object has a property with the same name\n    // as the required property, but with a type that is a\n    // subtype of the required type (this second case is rare).\n    if (constraintObj.isRecordType()) {\n      ImmutableList<String> propNames = constraintObj.getOwnPropertyNames();\n      if (propNames.size() == 1) {\n        String propName = propNames.get(0);\n        JSType propType = constraintObj.getPropertyType(propName);\n        boolean isPropDeclared = isPropertyTypeDeclared(propName);\n        if (!isPropDeclared && !hasProperty(propName, propType)) {\n          defineInferredProperty(propName,\n              getNativeType(JSTypeNative.UNDEFINED_TYPE).getLeastSupertype(propType),\n              null);\n        }\n      } else {\n        for (String propName : propNames) {\n          JSType propType = constraintObj.getPropertyType(propName);\n          if (!isPropertyTypeDeclared(propName)) {\n            JSType typeToInfer = propType;\n            // If there is no declared property with that name, then we will pretend\n            // that this object has a declared property of the appropriate type. This\n            // may trigger a warning later on, but it will ensure that we don't forget\n            // that this property existed.\n            if (!hasProperty(propName)) {\n              typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                  .getLeastSupertype(propType);\n            }\n            defineInferredProperty(propName, typeToInfer, null);\n          }\n        }\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex b6e3fc78..24e2e373 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -552,28 +552,50 @@ class PrototypeObjectType extends ObjectType {\n   }\n \n   @Override\n-  public void matchConstraint(ObjectType constraintObj) {\n-    // We only want to match contraints on anonymous types.\n+public void matchConstraint(ObjectType constraintObj) {\n+    // Do nothing if the constraint object is not anonymous.\n+    if (!constraintObj.isNominalType() && !constraintObj.isFunctionType()) {\n+      return;\n+    }\n \n-    // Handle the case where the constraint object is a record type.\n+    // Handle the case when the constraint object is a single-property record\n+    // type: we turn the type into a type union with undefined.\n     //\n     // param constraintObj {{prop: (number|undefined)}}\n     // function f(constraintObj) {}\n-    // f({});\n+    // f({prop: 123});\n+    // f({otherProp: 'hello'}); // produces a warning\n     //\n-    // We want to modify the object literal to match the constraint, by\n-    // taking any each property on the record and trying to match\n-    // properties on this object.\n+    // We want to warn, unless there is already a declared property 'prop' on\n+    // this object, or unless this object has a property with the same name\n+    // as the required property, but with a type that is a\n+    // subtype of the required type (this second case is rare).\n     if (constraintObj.isRecordType()) {\n-      for (String prop : constraintObj.getOwnPropertyNames()) {\n-        JSType propType = constraintObj.getPropertyType(prop);\n-        if (!isPropertyTypeDeclared(prop)) {\n-          JSType typeToInfer = propType;\n-          if (!hasProperty(prop)) {\n-            typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n-                .getLeastSupertype(propType);\n+      ImmutableList<String> propNames = constraintObj.getOwnPropertyNames();\n+      if (propNames.size() == 1) {\n+        String propName = propNames.get(0);\n+        JSType propType = constraintObj.getPropertyType(propName);\n+        boolean isPropDeclared = isPropertyTypeDeclared(propName);\n+        if (!isPropDeclared && !hasProperty(propName, propType)) {\n+          defineInferredProperty(propName,\n+              getNativeType(JSTypeNative.UNDEFINED_TYPE).getLeastSupertype(propType),\n+              null);\n+        }\n+      } else {\n+        for (String propName : propNames) {\n+          JSType propType = constraintObj.getPropertyType(propName);\n+          if (!isPropertyTypeDeclared(propName)) {\n+            JSType typeToInfer = propType;\n+            // If there is no declared property with that name, then we will pretend\n+            // that this object has a declared property of the appropriate type. This\n+            // may trigger a warning later on, but it will ensure that we don't forget\n+            // that this property existed.\n+            if (!hasProperty(propName)) {\n+              typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n+                  .getLeastSupertype(propType);\n+            }\n+            defineInferredProperty(propName, typeToInfer, null);\n           }\n-          defineInferredProperty(prop, typeToInfer, null);\n         }\n       }\n     }",
    "result_reason": "error: incompatible types",
    "test_result": "ERROR"
}