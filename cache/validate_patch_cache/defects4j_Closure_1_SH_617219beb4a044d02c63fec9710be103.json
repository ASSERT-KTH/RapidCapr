{
    "patch": "    Node function = fnScope.getRootNode();\n    Node functionParent = function.getParent();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(functionParent)) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n\n    // Map of unreferenced parameters to their declarations.\n    Multimap<String, Node> unreferenced = TreeMultimap.create();\n    // Maps variable names to var and referenced status.\n    Map<String, Pair<Var, Boolean>> varInfo = Maps.newHashMap();\n    // List of all vars declared in the scope.\n    List<Var> fnScopeVars = fnScope.getVars();\n\n    // Assume vars are unreferenced until we traverse the function body\n    // and find a reference.\n    for (Var var : fnScopeVars) {\n      varInfo.put(var.getName(), Pair.of(var, false));\n    }\n\n    // Add parameters to the varInfo map using the argList.\n    for (int i = 0, len = argList.getChildCount(); i < len; i++) {\n      Node arg = argList.getChildAtIndex(i);\n      String name = arg.getString();\n      Var var = fnScope.getVar(name);\n      Preconditions.checkNotNull(var, \"Var should have been in scope: %s\", arg);\n      varInfo.put(name, Pair.of(var, false));\n    }\n\n    // Let the first reference to a var enable all vars with that name.\n    new NodeTraversal(compiler, new AbstractPostOrderCallback() {\n      @Override public void visit(NodeTraversal t, Node n, Node parent) {\n        if (varInfo.containsKey(n.getString())) {\n          Pair<Var, Boolean> info = varInfo.get(n.getString());\n          if (!info.getSecond()) {\n            info = Pair.of(info.getFirst(), true);\n            varInfo.put(n.getString(), info);\n            referenced.add(info.getFirst());\n          }\n        }\n      }\n    }).traverseAtScope(fnScope);\n\n    // Map parameter names back to their declarations.\n    for (Map.Entry<String, Pair<Var, Boolean>> entry : varInfo.entrySet()) {\n      Pair<Var, Boolean> info = entry.getValue();\n      if (!info.getSecond()) {\n        Var param = entry.getValue().getFirst();\n        if (param.getParentNode() == argList) {\n          unreferenced.put(param.getName(), param);\n        } else {\n          // We already checked the vars in the argList so no need to check them again.\n          Preconditions.checkState(!param.isParam());\n        }\n      }\n    }\n\n    // Remove unreferenced parameters from the argList.\n    NodeTraversal.traverseEs6(compiler, function, new NodeTraversal.Callback() {\n      @Override public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n          Node parent) {\n        if (n == function || !n.isParamList()) {\n          return true;\n        }\n        String paramName = n.getString();\n        if (unreferenced.containsKey(paramName)) {\n          unreferenced.get(paramName).forEach(param -> {\n            Preconditions.checkState(param.isParam());\n            n.removeChild(param);\n            compiler.reportCodeChange();\n          });\n          unreferenced.removeAll(paramName);\n          if (n.getChildCount() == 0) {\n            parent.removeChild(n);\n            compiler.reportCodeChange();\n          }\n          return false;\n        }\n        return !modifyCallers || !callSiteOptimizer.isCallArgument(n);\n      }\n\n      @Override public void visit(NodeTraversal t, Node n, Node parent) {}\n    });\n\n    checkState(unreferenced.isEmpty());\n    if (modifyCallers) {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..6e18056e 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,100 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+    Node functionParent = function.getParent();\n+\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(functionParent)) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers = modifyCallSites\n+        && callSiteOptimizer.canModifyCallers(function);\n+\n+    // Map of unreferenced parameters to their declarations.\n+    Multimap<String, Node> unreferenced = TreeMultimap.create();\n+    // Maps variable names to var and referenced status.\n+    Map<String, Pair<Var, Boolean>> varInfo = Maps.newHashMap();\n+    // List of all vars declared in the scope.\n+    List<Var> fnScopeVars = fnScope.getVars();\n+\n+    // Assume vars are unreferenced until we traverse the function body\n+    // and find a reference.\n+    for (Var var : fnScopeVars) {\n+      varInfo.put(var.getName(), Pair.of(var, false));\n+    }\n+\n+    // Add parameters to the varInfo map using the argList.\n+    for (int i = 0, len = argList.getChildCount(); i < len; i++) {\n+      Node arg = argList.getChildAtIndex(i);\n+      String name = arg.getString();\n+      Var var = fnScope.getVar(name);\n+      Preconditions.checkNotNull(var, \"Var should have been in scope: %s\", arg);\n+      varInfo.put(name, Pair.of(var, false));\n+    }\n+\n+    // Let the first reference to a var enable all vars with that name.\n+    new NodeTraversal(compiler, new AbstractPostOrderCallback() {\n+      @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+        if (varInfo.containsKey(n.getString())) {\n+          Pair<Var, Boolean> info = varInfo.get(n.getString());\n+          if (!info.getSecond()) {\n+            info = Pair.of(info.getFirst(), true);\n+            varInfo.put(n.getString(), info);\n+            referenced.add(info.getFirst());\n+          }\n+        }\n+      }\n+    }).traverseAtScope(fnScope);\n+\n+    // Map parameter names back to their declarations.\n+    for (Map.Entry<String, Pair<Var, Boolean>> entry : varInfo.entrySet()) {\n+      Pair<Var, Boolean> info = entry.getValue();\n+      if (!info.getSecond()) {\n+        Var param = entry.getValue().getFirst();\n+        if (param.getParentNode() == argList) {\n+          unreferenced.put(param.getName(), param);\n+        } else {\n+          // We already checked the vars in the argList so no need to check them again.\n+          Preconditions.checkState(!param.isParam());\n+        }\n+      }\n+    }\n+\n+    // Remove unreferenced parameters from the argList.\n+    NodeTraversal.traverseEs6(compiler, function, new NodeTraversal.Callback() {\n+      @Override public boolean shouldTraverse(NodeTraversal nodeTraversal, Node n,\n+          Node parent) {\n+        if (n == function || !n.isParamList()) {\n+          return true;\n+        }\n+        String paramName = n.getString();\n+        if (unreferenced.containsKey(paramName)) {\n+          unreferenced.get(paramName).forEach(param -> {\n+            Preconditions.checkState(param.isParam());\n+            n.removeChild(param);\n+            compiler.reportCodeChange();\n+          });\n+          unreferenced.removeAll(paramName);\n+          if (n.getChildCount() == 0) {\n+            parent.removeChild(n);\n+            compiler.reportCodeChange();\n+          }\n+          return false;\n+        }\n+        return !modifyCallers || !callSiteOptimizer.isCallArgument(n);\n+      }\n+\n+      @Override public void visit(NodeTraversal t, Node n, Node parent) {}\n+    });\n+\n+    checkState(unreferenced.isEmpty());\n+    if (modifyCallers) {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}