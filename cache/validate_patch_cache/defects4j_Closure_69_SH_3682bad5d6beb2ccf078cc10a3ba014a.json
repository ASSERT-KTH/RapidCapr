{
    "patch": "      // Functions with explicit 'this' types must be called in a GETPROP or GETELEM.\n      Node parent = n.getParent();\n      if (!NodeUtil.isGet(parent) && !NodeUtil.isGetElem(parent)) {\n        report(t, n, MUST_BE_CALLED_WITH_NEW, childType.toString());\n      } else {\n        // If the function is invoked via a GETPROP or GETELEM node, mark the node so that\n        // 'this' is typed correctly.\n        JSType objectType = getJSType(parent.getFirstChild()).restrictByNotNullOrUndefined();\n        if (objectType.hasTypeVariable()) {\n          // If objectType has a type variable, it means that it is itself a method receiver\n          // and we want to set the 'this' type on the receiver expression itself.\n          ObjectType ownerType = objectType.mergeOwnerTypeWith(functionType);\n          if (ownerType != null && ownerType.getNominalType() != null) {\n            ObjectType thisType = ownerType.createCallableThisType(functionType);\n            JSType firstChildType = getJSType(parent.getFirstChild()).withProperty(\"prototype\");\n            ObjectType objectTypeWithPrototype = firstChildType == null ? null : firstChildType.autobox();\n            if (ownerType.getNominalType() != null && thisType != null) {\n              if (objectTypeWithPrototype != null && !objectTypeWithPrototype.isEquivalentTo(thisType)) {\n                report(t, n, INVALID_THIS_TYPE_IN_NON_STRICT, childType.toString(),\n                        objectTypeWithPrototype.toString(), thisType.toString());\n              }\n              JSTypeExpression expression = registry.createOptionalType(thisType);\n              n.getFirstChild().putProp(Node.FREE_CALL_TYPE_REFERENCE, expression);\n            }\n          }\n        } else {\n          // If objectType does not have a type variable, we modify the parent node\n          // by setting the JSTypeExpression for 'this'.\n          ObjectType thisType = objectType.createCallableThisType(functionType);\n          JSType firstChildType = getJSType(parent.getFirstChild()).withoutProperty(\"prototype\");\n          ObjectType objectTypeWithoutPrototype = firstChildType == null ? null : firstChildType.autobox();\n          if (thisType != null) {\n            if (objectTypeWithoutPrototype != null && !objectTypeWithoutPrototype.isEquivalentTo(thisType)) {\n              report(t, n, INVALID_THIS_TYPE_IN_NON_STRICT, childType.toString(),\n                      objectTypeWithoutPrototype.toString(), thisType.toString());\n            }\n            JSTypeExpression expression = registry.createOptionalType(thisType);\n            parent.putProp(Node.FREE_CALL_TYPE_REFERENCE, expression);\n          }\n        }\n      }\n\n      visitParameterList(t, n, functionType);\n      ensureTyped(t, n, functionType.getReturnType());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..cd964127 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,50 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+      // Functions with explicit 'this' types must be called in a GETPROP or GETELEM.\n+      Node parent = n.getParent();\n+      if (!NodeUtil.isGet(parent) && !NodeUtil.isGetElem(parent)) {\n+        report(t, n, MUST_BE_CALLED_WITH_NEW, childType.toString());\n+      } else {\n+        // If the function is invoked via a GETPROP or GETELEM node, mark the node so that\n+        // 'this' is typed correctly.\n+        JSType objectType = getJSType(parent.getFirstChild()).restrictByNotNullOrUndefined();\n+        if (objectType.hasTypeVariable()) {\n+          // If objectType has a type variable, it means that it is itself a method receiver\n+          // and we want to set the 'this' type on the receiver expression itself.\n+          ObjectType ownerType = objectType.mergeOwnerTypeWith(functionType);\n+          if (ownerType != null && ownerType.getNominalType() != null) {\n+            ObjectType thisType = ownerType.createCallableThisType(functionType);\n+            JSType firstChildType = getJSType(parent.getFirstChild()).withProperty(\"prototype\");\n+            ObjectType objectTypeWithPrototype = firstChildType == null ? null : firstChildType.autobox();\n+            if (ownerType.getNominalType() != null && thisType != null) {\n+              if (objectTypeWithPrototype != null && !objectTypeWithPrototype.isEquivalentTo(thisType)) {\n+                report(t, n, INVALID_THIS_TYPE_IN_NON_STRICT, childType.toString(),\n+                        objectTypeWithPrototype.toString(), thisType.toString());\n+              }\n+              JSTypeExpression expression = registry.createOptionalType(thisType);\n+              n.getFirstChild().putProp(Node.FREE_CALL_TYPE_REFERENCE, expression);\n+            }\n+          }\n+        } else {\n+          // If objectType does not have a type variable, we modify the parent node\n+          // by setting the JSTypeExpression for 'this'.\n+          ObjectType thisType = objectType.createCallableThisType(functionType);\n+          JSType firstChildType = getJSType(parent.getFirstChild()).withoutProperty(\"prototype\");\n+          ObjectType objectTypeWithoutPrototype = firstChildType == null ? null : firstChildType.autobox();\n+          if (thisType != null) {\n+            if (objectTypeWithoutPrototype != null && !objectTypeWithoutPrototype.isEquivalentTo(thisType)) {\n+              report(t, n, INVALID_THIS_TYPE_IN_NON_STRICT, childType.toString(),\n+                      objectTypeWithoutPrototype.toString(), thisType.toString());\n+            }\n+            JSTypeExpression expression = registry.createOptionalType(thisType);\n+            parent.putProp(Node.FREE_CALL_TYPE_REFERENCE, expression);\n+          }\n+        }\n+      }\n+\n+      visitParameterList(t, n, functionType);\n+      ensureTyped(t, n, functionType.getReturnType());\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}