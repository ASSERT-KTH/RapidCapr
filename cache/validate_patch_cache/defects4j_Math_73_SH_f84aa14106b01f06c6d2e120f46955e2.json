{
    "patch": "        // full Brent algorithm starting with provided initial guess\n        double a = min;\n        double b = max;\n\n        double d = Double.NaN;\n        double e = Double.NaN;\n\n        double fa = yMin;\n        double fb = yMax;\n        double fc = yInitial;\n\n        double tol1 = relativeAccuracy * Math.abs(initial) + absoluteAccuracy;\n        double tol2 = 2 * tol1;\n\n        for (int i = 0; i < maximalIterationCount; ++i) {\n            double m = 0.5 * (a + b);\n\n            double tolI = 2 * eps * Math.abs(m) + 0.5 * tol2;\n            double dTest = tolI - (b - a) * 0.5;\n            if (dTest <= 0 || Math.abs(fc) < functionValueAccuracy) {\n                setResult(initial, i);\n                return result;\n            }\n\n            if (Math.abs(e) > tolI) {\n                double s = fc / e;\n                double p;\n                double q;\n                if (a == initial) {\n                    p = 2 * m - initial;\n                    q = 1 - fc / fa;\n                } else {\n                    q = fa / fc;\n                    final double r = fc / fb;\n                    p = s * (2 * m - a) * (q - r) - (1 - s) * (b - m) * (r - 1);\n                }\n                if (p > 0) {\n                    q = 1 - q;\n                } else {\n                    p = -p;\n                }\n                double min1 = 3 * m - a;\n                double min2 = 3 * b - m;\n                if (Math.abs(p * 2) < Math.min((b - m) * q, (m - a) * q)) {\n                    e = d;\n                    d = p / q;\n                } else {\n                    d = tolI;\n                    e = d;\n                }\n            } else {\n                d = tolI;\n                e = d;\n            }\n            a = initial;\n            fa = fc;\n\n            if (Math.abs(d) > tol1) {\n                initial += d;\n            } else {\n                initial += (m >= 0 ? tol1 : -tol1);\n            }\n\n            fc = f.value(initial);\n            if ((fc > 0 && yMax > 0) || (fc <= 0 && yMax <= 0)) {\n                b = max;\n                fb = yMax;\n                if ((fc > 0 && yMin > 0) || (fc <= 0 && yMin <= 0)) {\n                    setResult(initial, i);\n                    return result;\n                }\n            } else {\n                a = min;\n                fa = yMin;\n                b = initial;\n                fb = fc;\n            }\n\n            if (b - a < tol2) {\n                if (Math.abs(fc) < Math.abs(fa)) {\n                    setResult(initial, i);\n                    return result;\n                }\n                initial -= m;\n                fc = f.value(initial);\n                setResult(initial, i);\n                return result;\n            }\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..29f54db96 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,96 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        // full Brent algorithm starting with provided initial guess\n+        double a = min;\n+        double b = max;\n+\n+        double d = Double.NaN;\n+        double e = Double.NaN;\n+\n+        double fa = yMin;\n+        double fb = yMax;\n+        double fc = yInitial;\n+\n+        double tol1 = relativeAccuracy * Math.abs(initial) + absoluteAccuracy;\n+        double tol2 = 2 * tol1;\n+\n+        for (int i = 0; i < maximalIterationCount; ++i) {\n+            double m = 0.5 * (a + b);\n+\n+            double tolI = 2 * eps * Math.abs(m) + 0.5 * tol2;\n+            double dTest = tolI - (b - a) * 0.5;\n+            if (dTest <= 0 || Math.abs(fc) < functionValueAccuracy) {\n+                setResult(initial, i);\n+                return result;\n+            }\n+\n+            if (Math.abs(e) > tolI) {\n+                double s = fc / e;\n+                double p;\n+                double q;\n+                if (a == initial) {\n+                    p = 2 * m - initial;\n+                    q = 1 - fc / fa;\n+                } else {\n+                    q = fa / fc;\n+                    final double r = fc / fb;\n+                    p = s * (2 * m - a) * (q - r) - (1 - s) * (b - m) * (r - 1);\n+                }\n+                if (p > 0) {\n+                    q = 1 - q;\n+                } else {\n+                    p = -p;\n+                }\n+                double min1 = 3 * m - a;\n+                double min2 = 3 * b - m;\n+                if (Math.abs(p * 2) < Math.min((b - m) * q, (m - a) * q)) {\n+                    e = d;\n+                    d = p / q;\n+                } else {\n+                    d = tolI;\n+                    e = d;\n+                }\n+            } else {\n+                d = tolI;\n+                e = d;\n+            }\n+            a = initial;\n+            fa = fc;\n+\n+            if (Math.abs(d) > tol1) {\n+                initial += d;\n+            } else {\n+                initial += (m >= 0 ? tol1 : -tol1);\n+            }\n+\n+            fc = f.value(initial);\n+            if ((fc > 0 && yMax > 0) || (fc <= 0 && yMax <= 0)) {\n+                b = max;\n+                fb = yMax;\n+                if ((fc > 0 && yMin > 0) || (fc <= 0 && yMin <= 0)) {\n+                    setResult(initial, i);\n+                    return result;\n+                }\n+            } else {\n+                a = min;\n+                fa = yMin;\n+                b = initial;\n+                fb = fc;\n+            }\n+\n+            if (b - a < tol2) {\n+                if (Math.abs(fc) < Math.abs(fa)) {\n+                    setResult(initial, i);\n+                    return result;\n+                }\n+                initial -= m;\n+                fc = f.value(initial);\n+                setResult(initial, i);\n+                return result;\n+            }\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}