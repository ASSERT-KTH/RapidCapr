{
    "patch": "import com.google.common.collect.ImmutableList;\nimport com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.CheckLevel;\nimport com.google.javascript.jscomp.Compiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.DiagnosticType;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.JSModule;\nimport com.google.javascript.jscomp.JSSourceFile;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.jscomp.SourceMap;\nimport com.google.javascript.jscomp.WarningLevel;\nimport com.google.javascript.jscomp.base.Tri;\nimport com.google.javascript.jscomp.deps.ModuleLoader;\nimport com.google.javascript.rhino.ErrorReporter;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.StaticSourceFile;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.jstype.JSTypeRegistry;\n\nimport java.io.File;\nimport java.io.PrintStream;\nimport java.nio.charset.Charset;\nimport java.util.ArrayList;\nimport java.util.List;\n\n/**\n * This class provides a wrapper around the Closure Compiler to make\n * it easier to use.\n */\npublic class ClosureCompilerWrapper {\n    private final CompilerOptions options;\n    private final ErrorReporter reporter;\n    private final AbstractCompiler compiler;\n\n    /**\n     * Creates a new instance of the closure compiler wrapper.\n     */\n    public ClosureCompilerWrapper() {\n        this(null);\n    }\n\n    /**\n     * Creates a new instance of the closure compiler wrapper with\n     * the specified options.\n     * \n     * @param options The compiler options to use.\n     */\n    public ClosureCompilerWrapper(CompilerOptions options) {\n        if (options == null) {\n            options = new CompilerOptions();\n            CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);\n            WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n        }\n\n        this.options = options;\n\n        this.reporter = new ErrorReporter() {\n            @Override\n            public void error(String message, String sourceName, int line, int lineOffset) {\n                System.err.printf(\"%s:%d:%d: %s\\n\", sourceName, line, lineOffset, message);\n            }\n\n            @Override\n            public void warning(String message, String sourceName, int line, int lineOffset) {\n                System.err.printf(\"%s:%d:%d: warning: %s\\n\", sourceName, line, lineOffset, message);\n            }\n\n            @Override\n            public void runtimeError(String message, String sourceName, int line, int lineOffset) {\n                System.err.printf(\"%s:%d:%d: runtime error: %s\\n\", sourceName, line, lineOffset, message);\n            }\n        };\n\n        this.compiler = new Compiler(new PrintStream(System.err), reporter);\n    }\n\n    /**\n     * Compiles the specified JavaScript code.\n     *\n     * @param code The code to compile.\n     * @return The compiled code.\n     */\n    public String compile(String code) {\n        return compile(\"\", code);\n    }\n\n    /**\n     * Compiles the specified JavaScript code.\n     * \n     * @param filename The name of the JavaScript source file.\n     * @param code The code to compile.\n     * @return The compiled code.\n     */\n    public String compile(String filename, String code) {\n        return compile(filename, code, ImmutableList.<SourceFile>of()).get(0).getCode();\n    }\n\n    /**\n     * Compiles the specified JavaScript code with advanced optimizations.\n     * \n     * @param code The code to compile.\n     * @return The compiled code.\n     */\n    public String compileWithAdvancedOptimizations(String code) {\n        return compileWithAdvancedOptimizations(\"\", code);\n    }\n\n    /**\n     * Compiles the specified JavaScript code with advanced optimizations.\n     * \n     * @param filename The name of the JavaScript source file.\n     * @param code The code to compile.\n     * @return The compiled code.\n     */\n    public String compileWithAdvancedOptimizations(String filename, String code) {\n        return compileWithAdvancedOptimizations(filename, code, ImmutableList.<SourceFile>of()).get(0).getCode();\n    }\n\n    /**\n     * Compiles the specified JavaScript files.\n     *\n     * @param sourceFiles The files to compile.\n     * @return The compiled code.\n     */\n    public String compile(List<SourceFile> sourceFiles) {\n      return compile(sourceFiles, ImmutableList.<SourceFile>of(), ImmutableList.<String>of());\n    }\n\n    /**\n     * Compiles the specified JavaScript files using modules.\n     *\n     * @param sourceFiles the source files to compile\n     * @param jsModules the JSModule objects representing the modules\n     * @return The compiled code\n     */\n    public String compile(List<SourceFile> sourceFiles, List<JSModule> jsModules) {\n      return compile(sourceFiles, jsModules, ImmutableList.<String>of());\n    }\n\n    /**\n     * Compiles the specified JavaScript files using externs, warning levels,\n     * and modules\n     *\n     * @param sourceFiles The files to compile.\n     * @param externs The files containing the externs.\n     * @param warnings The warning levels to enable.\n     * @return The compiled code.\n     */\n    public String compile(List<SourceFile> sourceFiles, List<SourceFile> externs, List<String> warnings) {\n      return compile(sourceFiles, externs, ImmutableList.<String>copyOf(warnings), ImmutableList.<JSModule>of()).get(0).getCode();\n    }\n\n    /**\n     * Compiles the specified JavaScript files using modules, externs, and warning levels\n     *\n     * @param sourceFiles The files to compile.\n     * @param jsModules the JSModules representing the source files and how they map to each other\n     * @param externs The files containing the externs.\n     * @param warnings The warning levels to enable.\n     * @return The compiled code.\n     */\n    public String compile(List<SourceFile> sourceFiles, List<JSModule> jsModules, List<SourceFile> externs, List<String> warnings) {\n      return compile(sourceFiles, externs, ImmutableList.<String>copyOf(warnings), jsModules).get(0).getCode();\n    }\n\n    /**\n     * Compiles the specified JavaScript files using modules and externs.\n     *\n     * @param sourceFiles The files to compile.\n     * @param externs The files containing the externs.\n     * @return The compiled code.\n     */\n    public String compile(List<SourceFile> sourceFiles, List<SourceFile> externs, List<JSModule> jsModules) {\n      return compile(sourceFiles, externs, ImmutableList.<String>of(), jsModules).get(0).getCode();\n    }\n\n    /**\n     * Compiles the specified JavaScript files using modules, externs, and warnings.\n     *\n     * @param sourceFiles The files to compile.\n     * @param externs The files containing the externs.\n     * @param warnings The warning levels to enable.\n     * @return The compiled code.\n     */\n    public String compile(List<SourceFile> sourceFiles, List<SourceFile> externs, List<String> warnings, List<JSModule> jsModules) {\n        options.setCheckTypes(false);\n        options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.OFF);\n\n        if (!warnings.isEmpty()) {\n            options.setWarningsGuard(new CustomWarningsGuard(warnings));\n        }\n\n        Compiler.setLoggingLevel(Level.SEVERE);\n\n        List<SourceFile> inputs = new ArrayList<>(sourceFiles);\n        inputs.addAll(externs);\n\n        List<StaticSourceFile> staticInputs = new ArrayList<>(inputs.size());\n        for (SourceFile file : inputs) {\n            staticInputs.add(new StaticSourceFile(file.getName(), file.getCode()));\n        }\n\n        List<StaticSourceFile> externFiles = new ArrayList<>(externs.size());\n        for (SourceFile file : externs) {\n            externFiles.add(new StaticSourceFile(file.getName(), file.getCode()));\n        }\n\n        List<JSModule> modules = new ArrayList<>();\n        boolean hasModules = !jsModules.isEmpty();\n        if (hasModules) {\n            ModuleLoader.PathEscaper pathEscaper = new ModuleLoader.ModulePathEscaper(\"\");\n            ModuleLoader loader = new ModuleLoader(pathEscaper);\n            try {\n                modules.addAll(JSModule.createModulesFromFiles(jsModules, loader));\n            } catch (Exception e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        Compiler compiler = this.compiler;\n        compiler.disableThreads();\n        // We need to ensure that the TypeRegistry is already initialized in case any of\n        // the inputs introduce new type aliases. \n        JSTypeRegistry typeRegistry = compiler.getTypeRegistry();\n\n        try {\n            compiler.compileModules(staticInputs, externFiles, options, modules);\n        } catch (RuntimeException e) {\n            // If there was a compilation error, convert the error to a clickable error message string.\n            System.err.println(e.getMessage());\n            return null;\n        }\n\n        if (hasModules) {\n            // Concatenate the modules together.\n            StringBuilder sb = new StringBuilder();\n            for (JSModule module : modules) {\n                List<CompilerInput> inputsInModule = module.getInputs();\n                for (CompilerInput input : inputsInModule) {\n                    // Don't add externs to the output.\n                    if (externs.contains(input.getSourceFile())) {\n                        continue;\n                    }\n\n                    // Add the compiled code of the input to the output.\n                    String compiledCode = compiler.toSource(input);\n                    sb.append(compiledCode);\n                    if (!compiledCode.endsWith(\"\\n\")) {\n                        sb.append(\"\\n\");\n                    }\n                }\n            }\n\n            return sb.toString();\n        } else {\n            return compiler.toSource();\n        }\n    }\n\n    /**\n     * Returns the last error message reported by the compiler, or null\n     * if there were no errors.\n     * \n     * @return The last error message, or null if there were no errors.\n     */\n    public String getLastError() {\n        List<JSError> errors = this.compiler.getErrors();\n        if (errors.isEmpty()) {\n            return null;\n        } else {\n            return errors.get(errors.size() - 1).description;\n        }\n    }\n\n    /**\n     * Returns the last error source reported by the compiler, or null\n     * if there were no errors.\n     * \n     * @return The last error source, or null if there were no errors.\n     */\n    public String getLastErrorSource() {\n        List<JSError> errors = this.compiler.getErrors();\n        if (errors.isEmpty()) {\n            return null;\n        } else {\n            return errors.get(errors.size() - 1).sourceName;\n        }\n    }\n\n    /**\n     * Resets the warnings.\n     */\n    public void resetWarnings() {\n        CustomWarningsGuard.reset();\n    }\n\n    /**\n     * Returns the source map generated by the last compilation.\n     *\n     * @return The source map.\n     */\n    public SourceMap getSourceMap() {\n        return compiler.getSourceMap();\n    }\n\n    /**\n     * This is a custom implementation of the WarningsGuard interface that\n     * enables a specific set of warnings.\n     */\n    private static class CustomWarningsGuard implements WarningsGuard {\n        private static boolean enabled = true;\n\n        private final List<String> warningNames;\n\n        private CustomWarningsGuard(List<String> warningNames) {\n            this.warningNames = warningNames;\n        }\n\n        @Override\n        public CheckLevel level(JSError error) {\n            if (!enabled || !warningNames.contains(error.getType().key)) {\n                return null;\n            }\n\n            return CheckLevel.WARNING;\n        }\n\n        /**\n         * This method resets the enabled state of the warnings.\n         */\n        private static void reset() {\n            enabled = true;\n        }\n    }\n\n    /**\n     * This class provides a wrapper around a JavaScript input source file\n     * that can be compiled by the Closure Compiler.\n     */\n    public static class CompilerInput extends SourceFile {\n        private final Tri<CompilerInput, JSModule, String> tri;\n\n        /**\n         * Creates a new instance of the CompilerInput class.\n         * \n         * @param filename The name of the input file.\n         * @param code The code to compile.\n         */\n        public CompilerInput(String filename, String code) {\n          ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\nindex f6a64007..f0a40b3c 100644\n--- a/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n+++ b/src/com/google/javascript/jscomp/parsing/JsDocInfoParser.java\n@@ -1326,107 +1326,357 @@ public final class JsDocInfoParser {\n    * @return The extraction information.\n    */\n   @SuppressWarnings(\"fallthrough\")\n-  private ExtractionInfo extractMultilineTextualBlock(JsDocToken token,\n-                                                      WhitespaceOption option) {\n+import com.google.common.collect.ImmutableList;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.CheckLevel;\n+import com.google.javascript.jscomp.Compiler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.DiagnosticType;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.jscomp.JSModule;\n+import com.google.javascript.jscomp.JSSourceFile;\n+import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.jscomp.SourceMap;\n+import com.google.javascript.jscomp.WarningLevel;\n+import com.google.javascript.jscomp.base.Tri;\n+import com.google.javascript.jscomp.deps.ModuleLoader;\n+import com.google.javascript.rhino.ErrorReporter;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.StaticSourceFile;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.jstype.JSTypeRegistry;\n \n-    if (token == JsDocToken.EOC || token == JsDocToken.EOL ||\n-        token == JsDocToken.EOF) {\n-      return new ExtractionInfo(\"\", token);\n-    }\n+import java.io.File;\n+import java.io.PrintStream;\n+import java.nio.charset.Charset;\n+import java.util.ArrayList;\n+import java.util.List;\n \n-    stream.update();\n-    int startLineno = stream.getLineno();\n-    int startCharno = stream.getCharno() + 1;\n+/**\n+ * This class provides a wrapper around the Closure Compiler to make\n+ * it easier to use.\n+ */\n+public class ClosureCompilerWrapper {\n+    private final CompilerOptions options;\n+    private final ErrorReporter reporter;\n+    private final AbstractCompiler compiler;\n \n-    // Read the content from the first line.\n-    String line = stream.getRemainingJSDocLine();\n-    if (option != WhitespaceOption.PRESERVE) {\n-      line = line.trim();\n+    /**\n+     * Creates a new instance of the closure compiler wrapper.\n+     */\n+    public ClosureCompilerWrapper() {\n+        this(null);\n     }\n \n-    StringBuilder builder = new StringBuilder();\n-    builder.append(line);\n+    /**\n+     * Creates a new instance of the closure compiler wrapper with\n+     * the specified options.\n+     * \n+     * @param options The compiler options to use.\n+     */\n+    public ClosureCompilerWrapper(CompilerOptions options) {\n+        if (options == null) {\n+            options = new CompilerOptions();\n+            CompilationLevel.SIMPLE_OPTIMIZATIONS.setOptionsForCompilationLevel(options);\n+            WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n+        }\n \n-    state = State.SEARCHING_ANNOTATION;\n-    token = next();\n+        this.options = options;\n \n-    boolean ignoreStar = false;\n+        this.reporter = new ErrorReporter() {\n+            @Override\n+            public void error(String message, String sourceName, int line, int lineOffset) {\n+                System.err.printf(\"%s:%d:%d: %s\\n\", sourceName, line, lineOffset, message);\n+            }\n \n-    // Track the start of the line to count whitespace that\n-    // the tokenizer skipped. Because this case is rare, it's easier\n-    // to do this here than in the tokenizer.\n+            @Override\n+            public void warning(String message, String sourceName, int line, int lineOffset) {\n+                System.err.printf(\"%s:%d:%d: warning: %s\\n\", sourceName, line, lineOffset, message);\n+            }\n \n-    do {\n-      switch (token) {\n-        case STAR:\n-          if (ignoreStar) {\n-            // Mark the position after the star as the new start of the line.\n-          } else {\n-            // The star is part of the comment.\n-            if (builder.length() > 0) {\n-              builder.append(' ');\n+            @Override\n+            public void runtimeError(String message, String sourceName, int line, int lineOffset) {\n+                System.err.printf(\"%s:%d:%d: runtime error: %s\\n\", sourceName, line, lineOffset, message);\n             }\n+        };\n \n-            builder.append('*');\n-          }\n+        this.compiler = new Compiler(new PrintStream(System.err), reporter);\n+    }\n \n-          token = next();\n-          continue;\n+    /**\n+     * Compiles the specified JavaScript code.\n+     *\n+     * @param code The code to compile.\n+     * @return The compiled code.\n+     */\n+    public String compile(String code) {\n+        return compile(\"\", code);\n+    }\n \n-        case EOL:\n-          if (option != WhitespaceOption.SINGLE_LINE) {\n-            builder.append(\"\\n\");\n-          }\n+    /**\n+     * Compiles the specified JavaScript code.\n+     * \n+     * @param filename The name of the JavaScript source file.\n+     * @param code The code to compile.\n+     * @return The compiled code.\n+     */\n+    public String compile(String filename, String code) {\n+        return compile(filename, code, ImmutableList.<SourceFile>of()).get(0).getCode();\n+    }\n \n-          ignoreStar = true;\n-          token = next();\n-          continue;\n+    /**\n+     * Compiles the specified JavaScript code with advanced optimizations.\n+     * \n+     * @param code The code to compile.\n+     * @return The compiled code.\n+     */\n+    public String compileWithAdvancedOptimizations(String code) {\n+        return compileWithAdvancedOptimizations(\"\", code);\n+    }\n \n-        default:\n-          ignoreStar = false;\n-          state = State.SEARCHING_ANNOTATION;\n+    /**\n+     * Compiles the specified JavaScript code with advanced optimizations.\n+     * \n+     * @param filename The name of the JavaScript source file.\n+     * @param code The code to compile.\n+     * @return The compiled code.\n+     */\n+    public String compileWithAdvancedOptimizations(String filename, String code) {\n+        return compileWithAdvancedOptimizations(filename, code, ImmutableList.<SourceFile>of()).get(0).getCode();\n+    }\n+\n+    /**\n+     * Compiles the specified JavaScript files.\n+     *\n+     * @param sourceFiles The files to compile.\n+     * @return The compiled code.\n+     */\n+    public String compile(List<SourceFile> sourceFiles) {\n+      return compile(sourceFiles, ImmutableList.<SourceFile>of(), ImmutableList.<String>of());\n+    }\n+\n+    /**\n+     * Compiles the specified JavaScript files using modules.\n+     *\n+     * @param sourceFiles the source files to compile\n+     * @param jsModules the JSModule objects representing the modules\n+     * @return The compiled code\n+     */\n+    public String compile(List<SourceFile> sourceFiles, List<JSModule> jsModules) {\n+      return compile(sourceFiles, jsModules, ImmutableList.<String>of());\n+    }\n+\n+    /**\n+     * Compiles the specified JavaScript files using externs, warning levels,\n+     * and modules\n+     *\n+     * @param sourceFiles The files to compile.\n+     * @param externs The files containing the externs.\n+     * @param warnings The warning levels to enable.\n+     * @return The compiled code.\n+     */\n+    public String compile(List<SourceFile> sourceFiles, List<SourceFile> externs, List<String> warnings) {\n+      return compile(sourceFiles, externs, ImmutableList.<String>copyOf(warnings), ImmutableList.<JSModule>of()).get(0).getCode();\n+    }\n+\n+    /**\n+     * Compiles the specified JavaScript files using modules, externs, and warning levels\n+     *\n+     * @param sourceFiles The files to compile.\n+     * @param jsModules the JSModules representing the source files and how they map to each other\n+     * @param externs The files containing the externs.\n+     * @param warnings The warning levels to enable.\n+     * @return The compiled code.\n+     */\n+    public String compile(List<SourceFile> sourceFiles, List<JSModule> jsModules, List<SourceFile> externs, List<String> warnings) {\n+      return compile(sourceFiles, externs, ImmutableList.<String>copyOf(warnings), jsModules).get(0).getCode();\n+    }\n \n-              // All tokens must be separated by a space.\n+    /**\n+     * Compiles the specified JavaScript files using modules and externs.\n+     *\n+     * @param sourceFiles The files to compile.\n+     * @param externs The files containing the externs.\n+     * @return The compiled code.\n+     */\n+    public String compile(List<SourceFile> sourceFiles, List<SourceFile> externs, List<JSModule> jsModules) {\n+      return compile(sourceFiles, externs, ImmutableList.<String>of(), jsModules).get(0).getCode();\n+    }\n+\n+    /**\n+     * Compiles the specified JavaScript files using modules, externs, and warnings.\n+     *\n+     * @param sourceFiles The files to compile.\n+     * @param externs The files containing the externs.\n+     * @param warnings The warning levels to enable.\n+     * @return The compiled code.\n+     */\n+    public String compile(List<SourceFile> sourceFiles, List<SourceFile> externs, List<String> warnings, List<JSModule> jsModules) {\n+        options.setCheckTypes(false);\n+        options.setWarningLevel(DiagnosticGroups.CHECK_TYPES, CheckLevel.OFF);\n+\n+        if (!warnings.isEmpty()) {\n+            options.setWarningsGuard(new CustomWarningsGuard(warnings));\n+        }\n \n-          if (token == JsDocToken.EOC ||\n-              token == JsDocToken.EOF ||\n-              // When we're capturing a license block, annotations\n-              // in the block are ok.\n-              (token == JsDocToken.ANNOTATION &&\n-               option != WhitespaceOption.PRESERVE)) {\n-            String multilineText = builder.toString();\n+        Compiler.setLoggingLevel(Level.SEVERE);\n \n-            if (option != WhitespaceOption.PRESERVE) {\n-              multilineText = multilineText.trim();\n+        List<SourceFile> inputs = new ArrayList<>(sourceFiles);\n+        inputs.addAll(externs);\n+\n+        List<StaticSourceFile> staticInputs = new ArrayList<>(inputs.size());\n+        for (SourceFile file : inputs) {\n+            staticInputs.add(new StaticSourceFile(file.getName(), file.getCode()));\n+        }\n+\n+        List<StaticSourceFile> externFiles = new ArrayList<>(externs.size());\n+        for (SourceFile file : externs) {\n+            externFiles.add(new StaticSourceFile(file.getName(), file.getCode()));\n+        }\n+\n+        List<JSModule> modules = new ArrayList<>();\n+        boolean hasModules = !jsModules.isEmpty();\n+        if (hasModules) {\n+            ModuleLoader.PathEscaper pathEscaper = new ModuleLoader.ModulePathEscaper(\"\");\n+            ModuleLoader loader = new ModuleLoader(pathEscaper);\n+            try {\n+                modules.addAll(JSModule.createModulesFromFiles(jsModules, loader));\n+            } catch (Exception e) {\n+                throw new RuntimeException(e);\n             }\n+        }\n+\n+        Compiler compiler = this.compiler;\n+        compiler.disableThreads();\n+        // We need to ensure that the TypeRegistry is already initialized in case any of\n+        // the inputs introduce new type aliases. \n+        JSTypeRegistry typeRegistry = compiler.getTypeRegistry();\n+\n+        try {\n+            compiler.compileModules(staticInputs, externFiles, options, modules);\n+        } catch (RuntimeException e) {\n+            // If there was a compilation error, convert the error to a clickable error message string.\n+            System.err.println(e.getMessage());\n+            return null;\n+        }\n \n-            int endLineno = stream.getLineno();\n-            int endCharno = stream.getCharno();\n+        if (hasModules) {\n+            // Concatenate the modules together.\n+            StringBuilder sb = new StringBuilder();\n+            for (JSModule module : modules) {\n+                List<CompilerInput> inputsInModule = module.getInputs();\n+                for (CompilerInput input : inputsInModule) {\n+                    // Don't add externs to the output.\n+                    if (externs.contains(input.getSourceFile())) {\n+                        continue;\n+                    }\n \n-            if (multilineText.length() > 0) {\n-              jsdocBuilder.markText(multilineText, startLineno, startCharno,\n-                  endLineno, endCharno);\n+                    // Add the compiled code of the input to the output.\n+                    String compiledCode = compiler.toSource(input);\n+                    sb.append(compiledCode);\n+                    if (!compiledCode.endsWith(\"\\n\")) {\n+                        sb.append(\"\\n\");\n+                    }\n+                }\n             }\n \n-            return new ExtractionInfo(multilineText, token);\n-          }\n+            return sb.toString();\n+        } else {\n+            return compiler.toSource();\n+        }\n+    }\n \n-          if (builder.length() > 0) {\n-            builder.append(' ');\n-          }\n-          builder.append(toString(token));\n+    /**\n+     * Returns the last error message reported by the compiler, or null\n+     * if there were no errors.\n+     * \n+     * @return The last error message, or null if there were no errors.\n+     */\n+    public String getLastError() {\n+        List<JSError> errors = this.compiler.getErrors();\n+        if (errors.isEmpty()) {\n+            return null;\n+        } else {\n+            return errors.get(errors.size() - 1).description;\n+        }\n+    }\n \n-          line = stream.getRemainingJSDocLine();\n+    /**\n+     * Returns the last error source reported by the compiler, or null\n+     * if there were no errors.\n+     * \n+     * @return The last error source, or null if there were no errors.\n+     */\n+    public String getLastErrorSource() {\n+        List<JSError> errors = this.compiler.getErrors();\n+        if (errors.isEmpty()) {\n+            return null;\n+        } else {\n+            return errors.get(errors.size() - 1).sourceName;\n+        }\n+    }\n \n-          if (option != WhitespaceOption.PRESERVE) {\n-            line = trimEnd(line);\n-          }\n+    /**\n+     * Resets the warnings.\n+     */\n+    public void resetWarnings() {\n+        CustomWarningsGuard.reset();\n+    }\n \n-          builder.append(line);\n-          token = next();\n-      }\n-    } while (true);\n-  }\n+    /**\n+     * Returns the source map generated by the last compilation.\n+     *\n+     * @return The source map.\n+     */\n+    public SourceMap getSourceMap() {\n+        return compiler.getSourceMap();\n+    }\n+\n+    /**\n+     * This is a custom implementation of the WarningsGuard interface that\n+     * enables a specific set of warnings.\n+     */\n+    private static class CustomWarningsGuard implements WarningsGuard {\n+        private static boolean enabled = true;\n+\n+        private final List<String> warningNames;\n+\n+        private CustomWarningsGuard(List<String> warningNames) {\n+            this.warningNames = warningNames;\n+        }\n+\n+        @Override\n+        public CheckLevel level(JSError error) {\n+            if (!enabled || !warningNames.contains(error.getType().key)) {\n+                return null;\n+            }\n+\n+            return CheckLevel.WARNING;\n+        }\n+\n+        /**\n+         * This method resets the enabled state of the warnings.\n+         */\n+        private static void reset() {\n+            enabled = true;\n+        }\n+    }\n+\n+    /**\n+     * This class provides a wrapper around a JavaScript input source file\n+     * that can be compiled by the Closure Compiler.\n+     */\n+    public static class CompilerInput extends SourceFile {\n+        private final Tri<CompilerInput, JSModule, String> tri;\n+\n+        /**\n+         * Creates a new instance of the CompilerInput class.\n+         * \n+         * @param filename The name of the input file.\n+         * @param code The code to compile.\n+         */\n+        public CompilerInput(String filename, String code) {\n+          \n \n \n   /**",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}