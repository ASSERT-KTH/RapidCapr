{
    "patch": "private static class FieldTypeWithValue implements ReadablePartial {\n    private final DateTimeFieldType fieldType;\n    private final int value;\n\n    FieldTypeWithValue(DateTimeFieldType fieldType, int value) {\n        this.fieldType = fieldType;\n        this.value = value;\n    }\n\n    public DateTimeFieldType getFieldType(int i) {\n        return fieldType;\n    }\n\n    public int getValue(int i) {\n        return (getFieldType(i) == fieldType ? value : 0);\n    }\n\n    public int size() {\n        return 1;\n    }\n\n    public Chronology getChronology() {\n        return null;\n    }\n\n    public DateTimeField getField(int i) {\n        return getFieldType(i).getField(getChronology());\n    }\n\n    public boolean isSupported(DateTimeField field) {\n        return (fieldType == field.getType());\n    }\n\n    public boolean isSupported(DateTimeFieldType fieldType) {\n        return (this.fieldType == fieldType);\n    }\n\n    public int get(DateTimeField field) {\n        return (fieldType == field.getType() ? value : 0);\n    }\n\n    public int get(DateTimeFieldType fieldType) {\n        return (this.fieldType == fieldType ? value : 0);\n    }\n\n    public partial with(DateTimeField field, int value) {\n        if (fieldType == field.getType()) {\n            return new Partial(this, value);\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public Partial with(DateTimeFieldType fieldType, int value) {\n        if (this.fieldType == fieldType) {\n            return new Partial(this, value);\n        }\n        return withFieldAdded(new FieldTypeWithValue(fieldType, value));\n    }\n\n    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n        return new Partial(period, scalar).withFieldAdded(this);\n    }\n\n    public Partial withFieldAdded(DurationFieldType fieldType, int value) {\n        if (fieldType.getField(getChronology()).isSupported()) {\n            return new Partial(this, fieldType.getField(getChronology()).add(getValues(), 0, value), fieldType);\n        }\n        throw new UnsupportedOperationException();\n    }\n\n    public Partial withFieldAdded(ReadablePeriod period) {\n        int[] newValues = getValues();\n        for (int i = 0, isize = period.size(); i < isize; i++) {\n            newValues = period.getFieldType(i).getField(getChronology()).add(newValues, i, period.getValue(i));\n        }\n        return new Partial(this, newValues);\n    }\n\n    public Partial withFieldRemoved(DateTimeFieldType fieldType) {\n        if (this.fieldType == fieldType) {\n            return new Partial();\n        }\n        return withFieldAdded(new FieldTypeWithValue(fieldType, 0));\n    }\n\n    public Partial withField(DateTimeFieldType fieldType, int value) {\n        return withfieldAdded(fieldType, value).withFieldRemoved(fieldType);\n    }\n\n    public Partial plus(ReadablePeriod period) {\n        return new Partial(this, period).withChronologyRetainPartial(getChronology());\n    }\n\n    public Partial minus(ReadablePeriod period) {\n        return new Partial(this, period.negate()).withChronologyRetainPartial(getChronology());\n    }\n\n    public Partial multipliedBy(int scalar) {\n        return new Partial(this, scalar).withChronologyRetainPartial(getChronology());\n    }\n\n    public Partial dividedBy(int divisor) {\n        if (divisor == 1) {\n            return this;\n        }\n        return new Partial(this, divisor).withChronologyRetainPartial(getChronology());\n    }\n\n    public Partial negated() {\n        return multipliedBy(-1);\n    }\n\n    public boolean isBefore(ReadablePartial other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        if (size() != other.size()) {\n            throw new IllegalArgumentException(\"The partial must have the same size as the specified object\");\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) != other.getFieldType(i)) {\n                throw new IllegalArgumentException(\"The partial must match on field: \" + getFieldType(i));\n            }\n            if (getValue(i) < other.getValue(i)) {\n                return true;\n            } else if (getValue(i) > other.getValue(i)) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    public boolean isBefore(ReadableInstant instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        return instant.isAfter(this);\n    }\n\n    public boolean isAfter(ReadablePartial other) {\n        if (other == null) {\n            throw new IllegalArgumentException(\"The partial must not be null\");\n        }\n        if (size() != other.size()) {\n            throw new IllegalArgumentException(\"The partial must have the same size as the specified object\");\n        }\n        for (int i = 0, isize = size(); i < isize; i++) {\n            if (getFieldType(i) != other.getFieldType(i)) {\n                throw new IllegalArgumentException(\"The partial must match on field: \" + getFieldType(i));\n            }\n            if (getValue(i) > other.getValue(i)) {\n                return true;\n            } else if (getValue(i) < other.getValue(i)) {\n                return false;\n            }\n        }\n        return false;\n    }\n\n    public boolean isAfter(ReadableInstant instant) {\n        if (instant == null) {\n            throw new IllegalArgumentException(\"The instant must not be null\");\n        }\n        return instant.isBefore(this);\n    }\n\n    public Partial withChronologyRetainPartial(Chronology chrono) {\n        if (chrono == getChronology()) {\n            return this;\n        }\n        int[] newValues = getValues();\n        Chronology newChrono = DateTimeUtils.getChronology(chrono);\n        newChrono.validate(this, newValues);\n        return new Partial(this, newChrono);\n    }\n\n    public Partial withChronology(Chronology chrono) {\n        return new Partial(this, chrono);\n    }\n\n    public Partial withField(DateTimeField field, int value) {\n        return withFieldAdded(field.getType(), value).withFieldRemoved(field.getType());\n    }\n\n    public MutableDateTime toMutableDateTime() {\n        return new MutableDateTime(getMillis(), getChronology());\n    }\n\n    public DateTime toDateTime() {\n        return new DateTime(getMillis(), getChronology());\n    }\n\n    public Interval toIntervalBefore(ReadableInstant end) {\n        return new Interval(end, this);\n    }\n\n    public Interval toIntervalAfter(ReadableInstant start) {\n        return new Interval(start, this);\n    }\n\n    public long getLong(DateTimeFieldType fieldType) {\n        int index = indexOfSupported(fieldType);\n        if (index == -1) {\n            return 0L;\n        }\n        return getValue(index);\n    }\n\n    public String toString(String pattern) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter().print(this);\n    }\n\n    public String toString(String pattern, Locale locale) {\n        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale).print(this);\n    }\n\n    public String toString() {\n        return ISODateTimeFormat.date().print(this);\n    }\n\n    public DateTime toDateTimeAtStartOfDay() {\n        Chronology chrono = getChronology().withUTC();\n        long instant = toDateTime().withChronology(chrono).withTimeAtStartOfDay().getMillis();\n        return new DateTime(instant, chrono);\n    }\n\n    public Interval toInterval() {\n        return new Interval(this, null);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 0d4edf47..323f71a8 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,236 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+private static class FieldTypeWithValue implements ReadablePartial {\n+    private final DateTimeFieldType fieldType;\n+    private final int value;\n+\n+    FieldTypeWithValue(DateTimeFieldType fieldType, int value) {\n+        this.fieldType = fieldType;\n+        this.value = value;\n+    }\n+\n+    public DateTimeFieldType getFieldType(int i) {\n+        return fieldType;\n+    }\n+\n+    public int getValue(int i) {\n+        return (getFieldType(i) == fieldType ? value : 0);\n+    }\n+\n+    public int size() {\n+        return 1;\n+    }\n+\n+    public Chronology getChronology() {\n+        return null;\n+    }\n+\n+    public DateTimeField getField(int i) {\n+        return getFieldType(i).getField(getChronology());\n+    }\n+\n+    public boolean isSupported(DateTimeField field) {\n+        return (fieldType == field.getType());\n+    }\n+\n+    public boolean isSupported(DateTimeFieldType fieldType) {\n+        return (this.fieldType == fieldType);\n+    }\n+\n+    public int get(DateTimeField field) {\n+        return (fieldType == field.getType() ? value : 0);\n+    }\n+\n+    public int get(DateTimeFieldType fieldType) {\n+        return (this.fieldType == fieldType ? value : 0);\n+    }\n+\n+    public partial with(DateTimeField field, int value) {\n+        if (fieldType == field.getType()) {\n+            return new Partial(this, value);\n+        }\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public Partial with(DateTimeFieldType fieldType, int value) {\n+        if (this.fieldType == fieldType) {\n+            return new Partial(this, value);\n+        }\n+        return withFieldAdded(new FieldTypeWithValue(fieldType, value));\n+    }\n+\n+    public Partial withPeriodAdded(ReadablePeriod period, int scalar) {\n+        return new Partial(period, scalar).withFieldAdded(this);\n+    }\n+\n+    public Partial withFieldAdded(DurationFieldType fieldType, int value) {\n+        if (fieldType.getField(getChronology()).isSupported()) {\n+            return new Partial(this, fieldType.getField(getChronology()).add(getValues(), 0, value), fieldType);\n+        }\n+        throw new UnsupportedOperationException();\n+    }\n+\n+    public Partial withFieldAdded(ReadablePeriod period) {\n+        int[] newValues = getValues();\n+        for (int i = 0, isize = period.size(); i < isize; i++) {\n+            newValues = period.getFieldType(i).getField(getChronology()).add(newValues, i, period.getValue(i));\n+        }\n+        return new Partial(this, newValues);\n+    }\n+\n+    public Partial withFieldRemoved(DateTimeFieldType fieldType) {\n+        if (this.fieldType == fieldType) {\n+            return new Partial();\n+        }\n+        return withFieldAdded(new FieldTypeWithValue(fieldType, 0));\n+    }\n+\n+    public Partial withField(DateTimeFieldType fieldType, int value) {\n+        return withfieldAdded(fieldType, value).withFieldRemoved(fieldType);\n+    }\n+\n+    public Partial plus(ReadablePeriod period) {\n+        return new Partial(this, period).withChronologyRetainPartial(getChronology());\n+    }\n+\n+    public Partial minus(ReadablePeriod period) {\n+        return new Partial(this, period.negate()).withChronologyRetainPartial(getChronology());\n+    }\n+\n+    public Partial multipliedBy(int scalar) {\n+        return new Partial(this, scalar).withChronologyRetainPartial(getChronology());\n+    }\n+\n+    public Partial dividedBy(int divisor) {\n+        if (divisor == 1) {\n+            return this;\n+        }\n+        return new Partial(this, divisor).withChronologyRetainPartial(getChronology());\n+    }\n+\n+    public Partial negated() {\n+        return multipliedBy(-1);\n+    }\n+\n+    public boolean isBefore(ReadablePartial other) {\n+        if (other == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        if (size() != other.size()) {\n+            throw new IllegalArgumentException(\"The partial must have the same size as the specified object\");\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) != other.getFieldType(i)) {\n+                throw new IllegalArgumentException(\"The partial must match on field: \" + getFieldType(i));\n+            }\n+            if (getValue(i) < other.getValue(i)) {\n+                return true;\n+            } else if (getValue(i) > other.getValue(i)) {\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean isBefore(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return instant.isAfter(this);\n+    }\n+\n+    public boolean isAfter(ReadablePartial other) {\n+        if (other == null) {\n+            throw new IllegalArgumentException(\"The partial must not be null\");\n+        }\n+        if (size() != other.size()) {\n+            throw new IllegalArgumentException(\"The partial must have the same size as the specified object\");\n+        }\n+        for (int i = 0, isize = size(); i < isize; i++) {\n+            if (getFieldType(i) != other.getFieldType(i)) {\n+                throw new IllegalArgumentException(\"The partial must match on field: \" + getFieldType(i));\n+            }\n+            if (getValue(i) > other.getValue(i)) {\n+                return true;\n+            } else if (getValue(i) < other.getValue(i)) {\n+                return false;\n+            }\n+        }\n+        return false;\n+    }\n+\n+    public boolean isAfter(ReadableInstant instant) {\n+        if (instant == null) {\n+            throw new IllegalArgumentException(\"The instant must not be null\");\n+        }\n+        return instant.isBefore(this);\n+    }\n+\n+    public Partial withChronologyRetainPartial(Chronology chrono) {\n+        if (chrono == getChronology()) {\n+            return this;\n+        }\n+        int[] newValues = getValues();\n+        Chronology newChrono = DateTimeUtils.getChronology(chrono);\n+        newChrono.validate(this, newValues);\n+        return new Partial(this, newChrono);\n+    }\n+\n+    public Partial withChronology(Chronology chrono) {\n+        return new Partial(this, chrono);\n+    }\n+\n+    public Partial withField(DateTimeField field, int value) {\n+        return withFieldAdded(field.getType(), value).withFieldRemoved(field.getType());\n+    }\n+\n+    public MutableDateTime toMutableDateTime() {\n+        return new MutableDateTime(getMillis(), getChronology());\n+    }\n+\n+    public DateTime toDateTime() {\n+        return new DateTime(getMillis(), getChronology());\n+    }\n+\n+    public Interval toIntervalBefore(ReadableInstant end) {\n+        return new Interval(end, this);\n+    }\n+\n+    public Interval toIntervalAfter(ReadableInstant start) {\n+        return new Interval(start, this);\n+    }\n+\n+    public long getLong(DateTimeFieldType fieldType) {\n+        int index = indexOfSupported(fieldType);\n+        if (index == -1) {\n+            return 0L;\n+        }\n+        return getValue(index);\n+    }\n+\n+    public String toString(String pattern) {\n+        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter().print(this);\n+    }\n+\n+    public String toString(String pattern, Locale locale) {\n+        return new DateTimeFormatterBuilder().appendPattern(pattern).toFormatter(locale).print(this);\n+    }\n+\n+    public String toString() {\n+        return ISODateTimeFormat.date().print(this);\n+    }\n+\n+    public DateTime toDateTimeAtStartOfDay() {\n+        Chronology chrono = getChronology().withUTC();\n+        long instant = toDateTime().withChronology(chrono).withTimeAtStartOfDay().getMillis();\n+        return new DateTime(instant, chrono);\n+    }\n+\n+    public Interval toInterval() {\n+        return new Interval(this, null);\n+    }\n+}\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}