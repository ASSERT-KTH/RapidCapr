{
    "patch": "public static double regularizedGammaP(double a, double x) {\n    if (a <= 0.0 || x < 0.0) {\n        return Double.NaN;\n    }\n    if (x == 0.0) {\n        return 0.0;\n    }\n    if (x >= a + 1) {\n        double sum = continuedFractionA(a, x);\n        return 1.0 - Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a)) * sum;\n    } else {\n        double sum = seriesA(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n        return sum * Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a));\n    }\n}\n\nprivate static double seriesA(double a, double x, double epsilon, int maxIterations) {\n    double n = 1.0;\n    double an = a;\n    double sum = a;\n    while (Math.abs(an / sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n        n++;\n        an *= x / n;\n        sum += an;\n    }\n    return sum;\n}\n\nprivate static double continuedFractionA(double a, double x) {\n    double tiny = 1e-30;\n    double value = 1.0 / (x + a);\n    double g = value;\n    double a0 = 0.0;\n    double a1 = 1.0;\n    double b0 = 1.0;\n    double b1 = x + a;\n    double an = (a1 + a0 * x) * value;\n    double ana = an;\n    while (Math.abs(an / ana) > tiny) {\n        a0 = a1;\n        a1 = an;\n        b0 = b1;\n        b1 = x * b0 + a * b0 / b1;\n        value = 1.0 / (b1 + a1 * x);\n        an = (a1 + a0 * b1) * value;\n        ana = Math.abs(an);\n        g *= an;\n    }\n    return g;\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..5c3bfdd2e 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,56 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x) {\n+    if (a <= 0.0 || x < 0.0) {\n+        return Double.NaN;\n+    }\n+    if (x == 0.0) {\n+        return 0.0;\n+    }\n+    if (x >= a + 1) {\n+        double sum = continuedFractionA(a, x);\n+        return 1.0 - Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a)) * sum;\n+    } else {\n+        double sum = seriesA(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n+        return sum * Math.exp(-x + a * Math.log(x) - Gamma.logGamma(a));\n+    }\n+}\n+\n+private static double seriesA(double a, double x, double epsilon, int maxIterations) {\n+    double n = 1.0;\n+    double an = a;\n+    double sum = a;\n+    while (Math.abs(an / sum) > epsilon && n < maxIterations && sum < Double.POSITIVE_INFINITY) {\n+        n++;\n+        an *= x / n;\n+        sum += an;\n+    }\n+    return sum;\n+}\n+\n+private static double continuedFractionA(double a, double x) {\n+    double tiny = 1e-30;\n+    double value = 1.0 / (x + a);\n+    double g = value;\n+    double a0 = 0.0;\n+    double a1 = 1.0;\n+    double b0 = 1.0;\n+    double b1 = x + a;\n+    double an = (a1 + a0 * x) * value;\n+    double ana = an;\n+    while (Math.abs(an / ana) > tiny) {\n+        a0 = a1;\n+        a1 = an;\n+        b0 = b1;\n+        b1 = x * b0 + a * b0 / b1;\n+        value = 1.0 / (b1 + a1 * x);\n+        an = (a1 + a0 * b1) * value;\n+        ana = Math.abs(an);\n+        g *= an;\n+    }\n+    return g;\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}