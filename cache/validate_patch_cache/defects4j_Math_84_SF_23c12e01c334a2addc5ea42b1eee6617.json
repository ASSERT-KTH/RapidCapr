{
    "patch": "import org.apache.commons.math3.exception.FunctionEvaluationException;\nimport org.apache.commons.math3.exception.OptimizationException;\nimport org.apache.commons.math3.optim.PointValuePair;\nimport org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\nimport org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\nimport org.apache.commons.math3.util.FastMath;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class SimplexOptimizer extends AbstractSimplexOptimizer {\n\n    /** Reflection coefficient. */\n    private final double rho;\n\n    /** Contraction coefficient. */\n    private final double gamma;\n\n    /** Expansion coefficient. */\n    private final double khi;\n\n    /**\n     * Builds a Nelder-Mead optimizer with default coefficients.\n     *\n     * @see NelderMeadTransform\n     */\n    public SimplexOptimizer() {\n        this(1d, 0.5d, 2d);\n    }\n\n    /**\n     * Builds a Nelder-Mead optimizer with specified coefficients.\n     *\n     * @param rho Reflection coefficient.\n     * @param gamma Contraction coefficient.\n     * @param khi Expansion coefficient.\n     *\n     * @see NelderMeadTransform\n     */\n    public SimplexOptimizer(final double rho,\n                            final double gamma,\n                            final double khi) {\n        this(rho, gamma, khi, AbstractSimplexOptimizer.DEFAULT_RELATIVE_TOLERANCE, AbstractSimplexOptimizer.DEFAULT_ABSOLUTE_TOLERANCE);\n    }\n\n    /**\n     * Builds a Nelder-Mead optimizer with specified coefficients and tolerances.\n     *\n     * @param rho Reflection coefficient.\n     * @param gamma Contraction coefficient.\n     * @param khi Expansion coefficient.\n     * @param relativeThreshold Relative threshold for convergence.\n     * @param absoluteThreshold Absolute threshold for convergence.\n     *\n     * @see NelderMeadTransform\n     */\n    public SimplexOptimizer(final double rho,\n                            final double gamma,\n                            final double khi,\n                            final double relativeThreshold,\n                            final double absoluteThreshold) {\n        super(relativeThreshold, absoluteThreshold);\n        this.rho = rho;\n        this.gamma = gamma;\n        this.khi = khi;\n    }\n\n\n    /**\n     * {@inheritDoc}\n     */\n    @Override\n    protected void doOptimize() {\n\n        final Comparator<RealPointValuePair> order = getOrder();\n\n        // Initialize all variables\n        initializeSimplex();\n        PointValuePair previous = null;\n\n        while (true) {\n\n            // Sort simplex vertices\n            Arrays.sort(simplex, order);\n\n            // Check convergence\n            final PointValuePair current = simplex[0];\n            if (previous != null &&\n                    (FastMath.abs(previous.getValue() - current.getValue()) <= getRelativeThreshold() * (FastMath.abs(previous.getValue()) + getAbsoluteThreshold()))) {\n                setResult(previous, getIterations(), getEvaluations());\n                return;\n            }\n            previous = current;\n\n            // Perform a simplex iteration\n            iterateSimplex(order);\n\n        }\n\n    }\n\n    /**\n     * Finds the worst point in the simplex and replaces it.\n     *\n     * @param original Simplex to use as reference.\n     * @param replacement New point to use.\n     * @param comparator Comparator to use for sorting the simplex.\n     * @return the new simplex.\n     */\n    private RealPointValuePair[] replaceWorstPoint(final RealPointValuePair[] original,\n                                                    final RealPointValuePair replacement,\n                                                    final Comparator<RealPointValuePair> comparator) {\n\n        final RealPointValuePair[] simplex = Arrays.copyOf(original, original.length);\n        simplex[simplex.length - 1] = replacement;\n\n        // Sort the simplex\n        Arrays.sort(simplex, comparator);\n\n        return simplex;\n\n    }\n\n    /**\n     * Shrinks the simplex towards the best point.\n     *\n     * @param original Simplex to use as reference.\n     * @param comparator Comparator to use for sorting the simplex.\n     * @return the new simplex.\n     */\n    private RealPointValuePair[] shrinkSimplex(final RealPointValuePair[] original,\n                                                final Comparator<RealPointValuePair> comparator) {\n\n        final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n\n        for (int i = 0; i < simplex.length; i++) {\n            double[] newRow = new double[original[0].getPoint().length];\n            for (int j = 0; j < newRow.length; j++) {\n                newRow[j] = getStartPoint()[j] + getShrink() * (original[i].getPoint()[j] - getStartPoint()[j]);\n            }\n            final double value = computeObjectiveValue(newRow);\n            simplex[i] = new RealPointValuePair(newRow, value);\n        }\n\n        // Sort the simplex\n        Arrays.sort(simplex, comparator);\n\n        return simplex;\n\n    }\n\n    /**\n     * Perform a single iteration of the simplex algorithm.\n     *\n     * @param comparator Comparator used to sort the simplex vertices.\n     * @throws FunctionEvaluationException if an error occurs computing the objective function.\n     * @throws OptimizationException if an error occurs during optimization (e.g. too many evaluations).\n     */\n    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n            throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n        while (true) {\n\n            incrementIterationsCounter();\n\n            // Save the original simplex\n            final RealPointValuePair[] oldVertices = simplex;\n\n            // Compute the value of the reflected simplex at a reflection coefficient of 1.0\n            final RealPointValuePair best = oldVertices[0];\n            final RealPointValuePair reflectedVertex = evaluateNewSimplex(oldVertices, 1.0, comparator);\n\n            if (comparator.compare(reflectedVertex, best) < 0) {\n\n                // Compute the value of the reflected simplex at a reflection coefficient of rho\n                final RealPointValuePair expandedVertex = evaluateNewSimplex(oldVertices, rho, comparator);\n\n                // Use the expanded simplex if it is better than the reflected one, else use the reflected one\n                if (comparator.compare(expandedVertex, reflectedVertex) < 0) {\n                    simplex = replaceWorstPoint(oldVertices, expandedVertex, comparator);\n                } else {\n                    simplex = replaceWorstPoint(oldVertices, reflectedVertex, comparator);\n                }\n\n            } else {\n\n                // Calculate the contraction and do an outside contraction\n                final RealPointValuePair contractedVertex = evaluateNewSimplex(oldVertices, -gamma, comparator);\n\n                if (comparator.compare(contractedVertex, best) < 0) {\n\n                    simplex = replaceWorstPoint(oldVertices, contractedVertex, comparator);\n\n                } else {\n\n                    // If the contraction is not better than the best point, perform a shrink\n                    simplex = shrinkSimplex(oldVertices, comparator);\n\n                }\n            }\n\n            // Check convergence and iteration termination\n            final RealPointValuePair newBest = simplex[0];\n            boolean isConverged = true;\n\n            for (int i = 0; i < simplex.length; i++) {\n                isConverged &= Math.abs(newBest.getValue() - simplex[i].getValue()) <= getRelativeThreshold() * (Math.abs(newBest.getValue()) + getAbsoluteThreshold());\n            }\n\n            if (isConverged || getEvaluations() >= getMaxEvaluations()) {\n                return;\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..0fa9f5b76 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,45 +58,224 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n+import org.apache.commons.math3.exception.FunctionEvaluationException;\n+import org.apache.commons.math3.exception.OptimizationException;\n+import org.apache.commons.math3.optim.PointValuePair;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n+import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\n+import org.apache.commons.math3.util.FastMath;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n+\n+public class SimplexOptimizer extends AbstractSimplexOptimizer {\n+\n+    /** Reflection coefficient. */\n+    private final double rho;\n+\n+    /** Contraction coefficient. */\n+    private final double gamma;\n+\n+    /** Expansion coefficient. */\n+    private final double khi;\n+\n+    /**\n+     * Builds a Nelder-Mead optimizer with default coefficients.\n+     *\n+     * @see NelderMeadTransform\n+     */\n+    public SimplexOptimizer() {\n+        this(1d, 0.5d, 2d);\n+    }\n+\n+    /**\n+     * Builds a Nelder-Mead optimizer with specified coefficients.\n+     *\n+     * @param rho Reflection coefficient.\n+     * @param gamma Contraction coefficient.\n+     * @param khi Expansion coefficient.\n+     *\n+     * @see NelderMeadTransform\n+     */\n+    public SimplexOptimizer(final double rho,\n+                            final double gamma,\n+                            final double khi) {\n+        this(rho, gamma, khi, AbstractSimplexOptimizer.DEFAULT_RELATIVE_TOLERANCE, AbstractSimplexOptimizer.DEFAULT_ABSOLUTE_TOLERANCE);\n+    }\n+\n+    /**\n+     * Builds a Nelder-Mead optimizer with specified coefficients and tolerances.\n+     *\n+     * @param rho Reflection coefficient.\n+     * @param gamma Contraction coefficient.\n+     * @param khi Expansion coefficient.\n+     * @param relativeThreshold Relative threshold for convergence.\n+     * @param absoluteThreshold Absolute threshold for convergence.\n+     *\n+     * @see NelderMeadTransform\n+     */\n+    public SimplexOptimizer(final double rho,\n+                            final double gamma,\n+                            final double khi,\n+                            final double relativeThreshold,\n+                            final double absoluteThreshold) {\n+        super(relativeThreshold, absoluteThreshold);\n+        this.rho = rho;\n+        this.gamma = gamma;\n+        this.khi = khi;\n+    }\n+\n+\n+    /**\n+     * {@inheritDoc}\n+     */\n+    @Override\n+    protected void doOptimize() {\n+\n+        final Comparator<RealPointValuePair> order = getOrder();\n+\n+        // Initialize all variables\n+        initializeSimplex();\n+        PointValuePair previous = null;\n+\n+        while (true) {\n+\n+            // Sort simplex vertices\n+            Arrays.sort(simplex, order);\n+\n+            // Check convergence\n+            final PointValuePair current = simplex[0];\n+            if (previous != null &&\n+                    (FastMath.abs(previous.getValue() - current.getValue()) <= getRelativeThreshold() * (FastMath.abs(previous.getValue()) + getAbsoluteThreshold()))) {\n+                setResult(previous, getIterations(), getEvaluations());\n+                return;\n+            }\n+            previous = current;\n+\n+            // Perform a simplex iteration\n+            iterateSimplex(order);\n+\n+        }\n+\n+    }\n+\n+    /**\n+     * Finds the worst point in the simplex and replaces it.\n+     *\n+     * @param original Simplex to use as reference.\n+     * @param replacement New point to use.\n+     * @param comparator Comparator to use for sorting the simplex.\n+     * @return the new simplex.\n+     */\n+    private RealPointValuePair[] replaceWorstPoint(final RealPointValuePair[] original,\n+                                                    final RealPointValuePair replacement,\n+                                                    final Comparator<RealPointValuePair> comparator) {\n+\n+        final RealPointValuePair[] simplex = Arrays.copyOf(original, original.length);\n+        simplex[simplex.length - 1] = replacement;\n+\n+        // Sort the simplex\n+        Arrays.sort(simplex, comparator);\n+\n+        return simplex;\n+\n+    }\n+\n+    /**\n+     * Shrinks the simplex towards the best point.\n+     *\n+     * @param original Simplex to use as reference.\n+     * @param comparator Comparator to use for sorting the simplex.\n+     * @return the new simplex.\n+     */\n+    private RealPointValuePair[] shrinkSimplex(final RealPointValuePair[] original,\n+                                                final Comparator<RealPointValuePair> comparator) {\n+\n+        final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n+\n+        for (int i = 0; i < simplex.length; i++) {\n+            double[] newRow = new double[original[0].getPoint().length];\n+            for (int j = 0; j < newRow.length; j++) {\n+                newRow[j] = getStartPoint()[j] + getShrink() * (original[i].getPoint()[j] - getStartPoint()[j]);\n+            }\n+            final double value = computeObjectiveValue(newRow);\n+            simplex[i] = new RealPointValuePair(newRow, value);\n+        }\n+\n+        // Sort the simplex\n+        Arrays.sort(simplex, comparator);\n+\n+        return simplex;\n+\n+    }\n+\n+    /**\n+     * Perform a single iteration of the simplex algorithm.\n+     *\n+     * @param comparator Comparator used to sort the simplex vertices.\n+     * @throws FunctionEvaluationException if an error occurs computing the objective function.\n+     * @throws OptimizationException if an error occurs during optimization (e.g. too many evaluations).\n+     */\n     protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+            throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n         while (true) {\n \n             incrementIterationsCounter();\n \n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n+            // Save the original simplex\n+            final RealPointValuePair[] oldVertices = simplex;\n+\n+            // Compute the value of the reflected simplex at a reflection coefficient of 1.0\n+            final RealPointValuePair best = oldVertices[0];\n+            final RealPointValuePair reflectedVertex = evaluateNewSimplex(oldVertices, 1.0, comparator);\n+\n+            if (comparator.compare(reflectedVertex, best) < 0) {\n \n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n+                // Compute the value of the reflected simplex at a reflection coefficient of rho\n+                final RealPointValuePair expandedVertex = evaluateNewSimplex(oldVertices, rho, comparator);\n \n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n+                // Use the expanded simplex if it is better than the reflected one, else use the reflected one\n+                if (comparator.compare(expandedVertex, reflectedVertex) < 0) {\n+                    simplex = replaceWorstPoint(oldVertices, expandedVertex, comparator);\n+                } else {\n+                    simplex = replaceWorstPoint(oldVertices, reflectedVertex, comparator);\n                 }\n \n-                return;\n+            } else {\n+\n+                // Calculate the contraction and do an outside contraction\n+                final RealPointValuePair contractedVertex = evaluateNewSimplex(oldVertices, -gamma, comparator);\n+\n+                if (comparator.compare(contractedVertex, best) < 0) {\n+\n+                    simplex = replaceWorstPoint(oldVertices, contractedVertex, comparator);\n \n+                } else {\n+\n+                    // If the contraction is not better than the best point, perform a shrink\n+                    simplex = shrinkSimplex(oldVertices, comparator);\n+\n+                }\n             }\n \n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n+            // Check convergence and iteration termination\n+            final RealPointValuePair newBest = simplex[0];\n+            boolean isConverged = true;\n \n-            // check convergence\n-                return;\n+            for (int i = 0; i < simplex.length; i++) {\n+                isConverged &= Math.abs(newBest.getValue() - simplex[i].getValue()) <= getRelativeThreshold() * (Math.abs(newBest.getValue()) + getAbsoluteThreshold());\n             }\n \n+            if (isConverged || getEvaluations() >= getMaxEvaluations()) {\n+                return;\n+            }\n         }\n-\n     }\n+}\n \n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}