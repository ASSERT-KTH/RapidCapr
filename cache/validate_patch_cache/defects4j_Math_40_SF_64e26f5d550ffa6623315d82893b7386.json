{
    "patch": "    protected double doSolve() {\n        // prepare arrays with the first points\n        final double[] x = new double[maximalOrder + 1];\n        final double[] y = new double[maximalOrder + 1];\n        x[0] = getMin();\n        x[1] = getStartValue();\n        x[2] = getMax();\n        verifySequence(x[0], x[1], x[2]);\n\n        // evaluate initial guess\n        y[1] = computeObjectiveValue(x[1]);\n        if (Precision.equals(y[1], 0.0, 1)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0.0, 1)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;        // number of points sampled so far\n        int signChangeIndex; // index of the point bracketing the root\n        if (y[0] * y[1] < 0) {\n            // the root is bracketed between x[0] and x[1]\n            nbPoints        = 2;\n            signChangeIndex = 1;\n        } else {\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0.0, 1)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n\n            if (y[1] * y[2] < 0) {\n                // the root is bracketed between x[1] and x[2]\n                nbPoints        = 3;\n                signChangeIndex = 2;\n            } else {\n                // the interval does not bracket the root\n                // throw exception and abort search\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA    = x[signChangeIndex - 1];\n        double yA    = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA   = 0;\n        double xB    = x[signChangeIndex];\n        double yB    = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB   = 0;\n        boolean bisectInterval = false;  // flag to trigger bisection fallback\n\n        // search loop\n        while (true) {\n            // check convergence of bracketing interval\n            final double xTol = getAbsoluteAccuracy() +\n                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                switch (allowed) {\n                    case ANY_SIDE :\n                        return absYA < absYB ? xA : xB;\n                    case LEFT_SIDE :\n                        return xA;\n                    case RIGHT_SIDE :\n                        return xB;\n                    case BELOW_SIDE :\n                        return (yA <= 0) ? xA : xB;\n                    case ABOVE_SIDE :\n                        return (yA <  0) ? xB : xA;\n                    default :\n                        // this should never happen\n                        throw new MathInternalError(null);\n                }\n            }\n\n            // select an appropriate endpoint to sample next\n            final double guess;\n            if (bisectInterval || (nbPoints == getMaximalOrder() + 1)) {\n                // bisection fallback, or maximal sampling order reached\n                guess = xA + 0.5 * (xB - xA);\n                bisectInterval = false;\n                ++nbPoints;\n            } else if (agingA >= MAXIMAL_AGING) {\n                // we keep updating the high bracket, try to compensate this\n                guess = xA + 0.5 * (xB - xA);\n                ++nbPoints;\n                agingA = 0;\n            } else if (agingB >= MAXIMAL_AGING) {\n                // we keep updating the low bracket, try to compensate this\n                guess = xB - 0.5 * (xB - xA);\n                ++nbPoints;\n                agingB = 0;\n            } else {\n                // bracketing is balanced, try to find the root itself\n                if(nbPoints == 3 && FastMath.abs(yA) > FastMath.abs(yB)) {\n                    // special case where f(x0) has magnitude greater than that of f(x2) and max order is 3\n                    guess = xA + FastMath.signum(yA) * FastMath.abs((xB - xA) / R);\n                } else {\n                    // inverse interpolation based on existing sampled points\n                    System.arraycopy(x, 0, tmpX, 0, nbPoints);\n                    guess = LagrangeInterpolator.interpolate(x, y).value(0);\n                }\n                // fallback to bisection if intermediate guess is not within bracketing interval\n                bisectInterval = ((guess < xA) || (guess > xB));\n            }\n\n            // evaluate the function at the guessed root\n            final double nextY = computeObjectiveValue(guess);\n            if (Precision.equals(nextY, 0.0, 1)) {\n                // we have found an exact root, since it is not an approximation\n                // we don't need to bother about the allowed solutions setting\n                return guess;\n            }\n\n            // update the sampling points array\n            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n            x[signChangeIndex] = guess;\n            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n            y[signChangeIndex] = nextY;\n            ++nbPoints;\n\n            // update the bracketing interval\n            if (nextY * yA <= 0) {\n                // the sign change occurs before the inserted point\n                xB = guess;\n                yB = nextY;\n                absYB = FastMath.abs(yB);\n                agingA++;\n                agingB = 0;\n            } else {\n                // the sign change occurs after the inserted point\n                xA = guess;\n                yA = nextY;\n                absYA = FastMath.abs(yA);\n                agingA = 0;\n                agingB++;\n\n                // update the sign change index\n                signChangeIndex++;\n            }\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..1e522a67b 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -141,7 +141,6 @@ public class BracketingNthOrderBrentSolver\n      */\n     @Override\n     protected double doSolve() {\n-\n         // prepare arrays with the first points\n         final double[] x = new double[maximalOrder + 1];\n         final double[] y = new double[maximalOrder + 1];\n@@ -164,16 +163,13 @@ public class BracketingNthOrderBrentSolver\n             return x[0];\n         }\n \n-        int nbPoints;\n-        int signChangeIndex;\n+        int nbPoints;        // number of points sampled so far\n+        int signChangeIndex; // index of the point bracketing the root\n         if (y[0] * y[1] < 0) {\n-\n-            // reduce interval if it brackets the root\n+            // the root is bracketed between x[0] and x[1]\n             nbPoints        = 2;\n             signChangeIndex = 1;\n-\n         } else {\n-\n             // evaluate second endpoint\n             y[2] = computeObjectiveValue(x[2]);\n             if (Precision.equals(y[2], 0.0, 1)) {\n@@ -182,13 +178,14 @@ public class BracketingNthOrderBrentSolver\n             }\n \n             if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n+                // the root is bracketed between x[1] and x[2]\n                 nbPoints        = 3;\n                 signChangeIndex = 2;\n             } else {\n+                // the interval does not bracket the root\n+                // throw exception and abort search\n                 throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n             }\n-\n         }\n \n         // prepare a work array for inverse polynomial interpolation\n@@ -203,118 +200,73 @@ public class BracketingNthOrderBrentSolver\n         double yB    = y[signChangeIndex];\n         double absYB = FastMath.abs(yB);\n         int agingB   = 0;\n+        boolean bisectInterval = false;  // flag to trigger bisection fallback\n \n         // search loop\n         while (true) {\n-\n             // check convergence of bracketing interval\n             final double xTol = getAbsoluteAccuracy() +\n                                 getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n             if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n                 switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n+                    case ANY_SIDE :\n+                        return absYA < absYB ? xA : xB;\n+                    case LEFT_SIDE :\n+                        return xA;\n+                    case RIGHT_SIDE :\n+                        return xB;\n+                    case BELOW_SIDE :\n+                        return (yA <= 0) ? xA : xB;\n+                    case ABOVE_SIDE :\n+                        return (yA <  0) ? xB : xA;\n+                    default :\n+                        // this should never happen\n+                        throw new MathInternalError(null);\n                 }\n             }\n \n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n+            // select an appropriate endpoint to sample next\n+            final double guess;\n+            if (bisectInterval || (nbPoints == getMaximalOrder() + 1)) {\n+                // bisection fallback, or maximal sampling order reached\n+                guess = xA + 0.5 * (xB - xA);\n+                bisectInterval = false;\n+                ++nbPoints;\n+            } else if (agingA >= MAXIMAL_AGING) {\n                 // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n+                guess = xA + 0.5 * (xB - xA);\n+                ++nbPoints;\n+                agingA = 0;\n             } else if (agingB >= MAXIMAL_AGING) {\n                 // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n+                guess = xB - 0.5 * (xB - xA);\n+                ++nbPoints;\n+                agingB = 0;\n             } else {\n                 // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n-            }\n-\n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n-                    }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n+                if(nbPoints == 3 && FastMath.abs(yA) > FastMath.abs(yB)) {\n+                    // special case where f(x0) has magnitude greater than that of f(x2) and max order is 3\n+                    guess = xA + FastMath.signum(yA) * FastMath.abs((xB - xA) / R);\n+                } else {\n+                    // inverse interpolation based on existing sampled points\n+                    System.arraycopy(x, 0, tmpX, 0, nbPoints);\n+                    guess = LagrangeInterpolator.interpolate(x, y).value(0);\n                 }\n-\n-            } while (Double.isNaN(nextX) && (end - start > 1));\n-\n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n+                // fallback to bisection if intermediate guess is not within bracketing interval\n+                bisectInterval = ((guess < xA) || (guess > xB));\n             }\n \n             // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n+            final double nextY = computeObjectiveValue(guess);\n             if (Precision.equals(nextY, 0.0, 1)) {\n                 // we have found an exact root, since it is not an approximation\n                 // we don't need to bother about the allowed solutions setting\n-                return nextX;\n-            }\n-\n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n-\n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n-\n+                return guess;\n             }\n \n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n+            // update the sampling points array\n             System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n+            x[signChangeIndex] = guess;\n             System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n             y[signChangeIndex] = nextY;\n             ++nbPoints;\n@@ -322,26 +274,23 @@ public class BracketingNthOrderBrentSolver\n             // update the bracketing interval\n             if (nextY * yA <= 0) {\n                 // the sign change occurs before the inserted point\n-                xB = nextX;\n+                xB = guess;\n                 yB = nextY;\n                 absYB = FastMath.abs(yB);\n-                ++agingA;\n+                agingA++;\n                 agingB = 0;\n             } else {\n                 // the sign change occurs after the inserted point\n-                xA = nextX;\n+                xA = guess;\n                 yA = nextY;\n                 absYA = FastMath.abs(yA);\n                 agingA = 0;\n-                ++agingB;\n+                agingB++;\n \n                 // update the sign change index\n                 signChangeIndex++;\n-\n             }\n-\n         }\n-\n     }\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}