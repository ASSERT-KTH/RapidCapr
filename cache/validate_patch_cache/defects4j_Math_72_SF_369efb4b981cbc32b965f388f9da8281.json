{
    "patch": "            setResult(min, 0);\n            return result;\n        }\n\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        double yInitial = f.value(initial);\n        if (Math.abs(yInitial) <= functionValueAccuracy) {\n            setResult(initial, 0);\n            return result;\n        }\n\n        if (yMin * yMax > 0) {\n            throw MathRuntimeException.createIllegalArgumentException(\n                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n        }\n\n        double x = initial, y = yInitial, a = min, b = max, c = initial, d = yInitial;\n        double oldX = Double.NaN;\n\n        boolean oldFa = false;\n        boolean fa;\n        while (getIterations() < getMaximalIterationCount()) {\n            oldX = x;\n            double tol = getAbsoluteAccuracy() + getRelativeAccuracy() * Math.abs(x);\n            double m = 0.5 * (a + b);\n            double updated = false;\n            if (Math.abs(y) < Math.abs(d)) {\n                a = c;\n                b = oldX;\n                c = oldX;\n                oldFa = fa;\n                fa = false;\n                d = y;\n                y = f.value(b);\n                updated = true;\n            } else {\n                a = oldX;\n                b = c;\n                c = oldX;\n                fa = oldFa;\n                d = y;\n                y = f.value(b);\n                updated = true;\n            }\n\n            if (Math.abs(y) <= functionValueAccuracy) {\n                setResult(b, getIterations());\n                return result;\n            }\n\n            if (fa ^ (y < 0)) {\n                if (fa) {\n                    d = y;\n                } else {\n                    c = b;\n                    d = y;\n                }\n                a = oldX;\n                fa = !fa;\n                x = b;\n                y = d;\n            }\n\n            // convergence test\n            if (updated && (Math.abs(d) + Math.abs(y) < tol)) {\n                setResult(b, getIterations());\n                return result;\n            }\n\n            // check for proximity of the previous values\n            if (updated && (Math.abs(oldX - b) < functionValueAccuracy)) {\n                setResult(b, getIterations());\n                return result;\n            }\n        }\n        throw new MaxIterationsExceededException(getMaximalIterationCount());",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..e1f7744e9 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,42 +95,19 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-\n-        clearResult();\n-        verifySequence(min, initial, max);\n-\n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n-        }\n-\n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        double yInitial = f.value(initial);\n+        if (Math.abs(yInitial) <= functionValueAccuracy) {\n+            setResult(initial, 0);\n+            return result;\n         }\n \n         if (yMin * yMax > 0) {\n@@ -138,10 +115,66 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n                   NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n         }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        double x = initial, y = yInitial, a = min, b = max, c = initial, d = yInitial;\n+        double oldX = Double.NaN;\n \n-    }\n+        boolean oldFa = false;\n+        boolean fa;\n+        while (getIterations() < getMaximalIterationCount()) {\n+            oldX = x;\n+            double tol = getAbsoluteAccuracy() + getRelativeAccuracy() * Math.abs(x);\n+            double m = 0.5 * (a + b);\n+            double updated = false;\n+            if (Math.abs(y) < Math.abs(d)) {\n+                a = c;\n+                b = oldX;\n+                c = oldX;\n+                oldFa = fa;\n+                fa = false;\n+                d = y;\n+                y = f.value(b);\n+                updated = true;\n+            } else {\n+                a = oldX;\n+                b = c;\n+                c = oldX;\n+                fa = oldFa;\n+                d = y;\n+                y = f.value(b);\n+                updated = true;\n+            }\n+\n+            if (Math.abs(y) <= functionValueAccuracy) {\n+                setResult(b, getIterations());\n+                return result;\n+            }\n+\n+            if (fa ^ (y < 0)) {\n+                if (fa) {\n+                    d = y;\n+                } else {\n+                    c = b;\n+                    d = y;\n+                }\n+                a = oldX;\n+                fa = !fa;\n+                x = b;\n+                y = d;\n+            }\n+\n+            // convergence test\n+            if (updated && (Math.abs(d) + Math.abs(y) < tol)) {\n+                setResult(b, getIterations());\n+                return result;\n+            }\n+\n+            // check for proximity of the previous values\n+            if (updated && (Math.abs(oldX - b) < functionValueAccuracy)) {\n+                setResult(b, getIterations());\n+                return result;\n+            }\n+        }\n+        throw new MaxIterationsExceededException(getMaximalIterationCount());\n \n     /**\n      * Find a zero in the given interval.",
    "result_reason": "error: invalid method declaration; return type required",
    "test_result": "ERROR"
}