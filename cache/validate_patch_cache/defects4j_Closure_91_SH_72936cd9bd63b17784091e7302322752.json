{
    "patch": "      Node parentParent = parent.getParent();\n      if (NodeUtil.isExprAssign(parentParent)) {\n        Node targetName = parentParent.getFirstChild();\n        if (NodeUtil.isGet(targetName)) {\n          if (isPrototype(targetName.getLastChild().getString(), targetName.getFirstChild())) {\n            return false;\n          }\n        }\n      } else if (NodeUtil.isObjectLitKey(parent) && \"constructor\".equals(parent.getString())) {\n        // Don't traverse constructor object literal keys.\n        return false;\n      }\n\n      // Only traverse if this is a block-scoped function or its parent is a block.\n      return isFunctionBlock(n);\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n\n      if (n == lhs) {\n        // Always traverse the left side of the assignment. To handle\n        // nested assignments properly (e.g., (a = this).property = c;),\n        // assignLhsChild should not be overridden.\n        if (assignLhsChild == null) {\n          assignLhsChild = lhs;\n        }\n      } else {\n        // Only traverse the right side if it's not an assignment to a prototype, and ignore\n        // assignments of function expressions to properties or variables (e.g. var x = function() {}).\n        boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(rhs);\n        boolean isFunctionExpression =\n            (NodeUtil.isFunctionExpression(rhs) && lhs.getType() != Token.GETELEM);\n        if (NodeUtil.isGet(lhs) && !isFunctionDeclaration && !isFunctionExpression) {\n          if (isPrototype(lhs.getLastChild().getString(), lhs.getFirstChild())) {\n            return false;\n          }\n        } else if (parent.getParent() != null) {\n          Node parentParent = parent.getParent();\n          if (NodeUtil.isGet(parentParent) && parentParent.getType() == Token.GETPROP &&\n              parentParent.getLastChild().getString().equals(\"prototype\")) {\n            if (isPrototype(parentParent.getFirstChild().getLastChild().getString(), \n                parentParent.getFirstChild().getFirstChild())) {\n              return false;\n            }\n          } \n        }\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines if a node is in a block scope.\n   * @param n The node to check.\n   */\n  private boolean isFunctionBlock(Node n) {\n    Node curNode = n;\n    while (curNode != null) {\n      if (NodeUtil.createsBlockScope(curNode)) {\n        return true;\n      }\n      curNode = curNode.getParent();\n    }\n    return false;\n  }\n\n  /**\n   * Determines if a property with the given name is a prototype property.\n   * @param propName The name of the property.\n   * @param base The base expression of the property access.\n   */\n  private boolean isPrototype(String propName, Node base) {\n    return \"prototype\".equals(propName) && \n        (NodeUtil.isName(base) && (\"Object\".equals(base.getString()) || \"Function\".equals(base.getString()))\n        || NodeUtil.isGet(base) && isPrototype(base.getLastChild().getString(), base.getFirstChild()));",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..aeeb1324 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,84 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      Node parentParent = parent.getParent();\n+      if (NodeUtil.isExprAssign(parentParent)) {\n+        Node targetName = parentParent.getFirstChild();\n+        if (NodeUtil.isGet(targetName)) {\n+          if (isPrototype(targetName.getLastChild().getString(), targetName.getFirstChild())) {\n+            return false;\n+          }\n+        }\n+      } else if (NodeUtil.isObjectLitKey(parent) && \"constructor\".equals(parent.getString())) {\n+        // Don't traverse constructor object literal keys.\n+        return false;\n+      }\n+\n+      // Only traverse if this is a block-scoped function or its parent is a block.\n+      return isFunctionBlock(n);\n+    }\n+\n+    if (parent != null && parent.getType() == Token.ASSIGN) {\n+      Node lhs = parent.getFirstChild();\n+      Node rhs = lhs.getNext();\n+\n+      if (n == lhs) {\n+        // Always traverse the left side of the assignment. To handle\n+        // nested assignments properly (e.g., (a = this).property = c;),\n+        // assignLhsChild should not be overridden.\n+        if (assignLhsChild == null) {\n+          assignLhsChild = lhs;\n+        }\n+      } else {\n+        // Only traverse the right side if it's not an assignment to a prototype, and ignore\n+        // assignments of function expressions to properties or variables (e.g. var x = function() {}).\n+        boolean isFunctionDeclaration = NodeUtil.isFunctionDeclaration(rhs);\n+        boolean isFunctionExpression =\n+            (NodeUtil.isFunctionExpression(rhs) && lhs.getType() != Token.GETELEM);\n+        if (NodeUtil.isGet(lhs) && !isFunctionDeclaration && !isFunctionExpression) {\n+          if (isPrototype(lhs.getLastChild().getString(), lhs.getFirstChild())) {\n+            return false;\n+          }\n+        } else if (parent.getParent() != null) {\n+          Node parentParent = parent.getParent();\n+          if (NodeUtil.isGet(parentParent) && parentParent.getType() == Token.GETPROP &&\n+              parentParent.getLastChild().getString().equals(\"prototype\")) {\n+            if (isPrototype(parentParent.getFirstChild().getLastChild().getString(), \n+                parentParent.getFirstChild().getFirstChild())) {\n+              return false;\n+            }\n+          } \n+        }\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Determines if a node is in a block scope.\n+   * @param n The node to check.\n+   */\n+  private boolean isFunctionBlock(Node n) {\n+    Node curNode = n;\n+    while (curNode != null) {\n+      if (NodeUtil.createsBlockScope(curNode)) {\n+        return true;\n+      }\n+      curNode = curNode.getParent();\n+    }\n+    return false;\n+  }\n+\n+  /**\n+   * Determines if a property with the given name is a prototype property.\n+   * @param propName The name of the property.\n+   * @param base The base expression of the property access.\n+   */\n+  private boolean isPrototype(String propName, Node base) {\n+    return \"prototype\".equals(propName) && \n+        (NodeUtil.isName(base) && (\"Object\".equals(base.getString()) || \"Function\".equals(base.getString()))\n+        || NodeUtil.isGet(base) && isPrototype(base.getLastChild().getString(), base.getFirstChild()));\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}