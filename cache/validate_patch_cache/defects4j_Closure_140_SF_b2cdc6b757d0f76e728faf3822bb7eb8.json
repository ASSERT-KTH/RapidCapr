{
    "patch": "@Override\nNode getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n        if (inputs.length == 0) {\n            throw new IllegalStateException(\"No inputs\");\n        }\n\n        Node root = inputs[0].getAstRoot(this);\n        // If the root is null or empty, then create a BLOCK node as the root.\n        if (root == null || root.isEmpty()) {\n            root = new Block();\n            root.setInputId(inputs[0].getName());\n            AstNode fakeScript = new AstNode(Token.SCRIPT);\n            fakeScript.addChildToBack(root);\n            fakeScript.setSourceName(inputs[0].getName());\n            fakeScript.setLineno(1);\n            fakeScript.setCharno(0);\n\n            root.setStaticSourceFile(\n                    new SyntheticAstInfo(\n                            this, fakeScript,\n                            SynthesizedNodeInfo.SynthesizedCode.CANNOT_COPY));\n        }\n        return root;\n    }\n\n    List<CompilerInput> inputs = module.getInputs();\n    if (inputs.size() > 0) {\n        Node root = inputs.get(0).getAstRoot(this);\n        // If the root is null or empty, then create a BLOCK node as the root.\n        if (root == null || root.isEmpty()) {\n            root = new Block();\n            root.setInputId(inputs.get(0).getName());\n            AstNode fakeScript = new AstNode(Token.SCRIPT);\n            fakeScript.addChildToBack(root);\n            fakeScript.setSourceName(inputs.get(0).getName());\n            fakeScript.setLineno(1);\n            fakeScript.setCharno(0);\n\n            root.setStaticSourceFile(\n                    new SyntheticAstInfo(\n                            this, fakeScript,\n                            SynthesizedNodeInfo.SynthesizedCode.CANNOT_COPY));\n        }\n        return root;\n    }\n    \n    // If the module has no inputs, do not throw an exception, just return null.\n    return null;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..718beff5 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,56 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n-\n-    checkFirstModule(modules);\n+@Override\n+Node getNodeForCodeInsertion(JSModule module) {\n+    if (module == null) {\n+        if (inputs.length == 0) {\n+            throw new IllegalStateException(\"No inputs\");\n+        }\n \n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n+        Node root = inputs[0].getAstRoot(this);\n+        // If the root is null or empty, then create a BLOCK node as the root.\n+        if (root == null || root.isEmpty()) {\n+            root = new Block();\n+            root.setInputId(inputs[0].getName());\n+            AstNode fakeScript = new AstNode(Token.SCRIPT);\n+            fakeScript.addChildToBack(root);\n+            fakeScript.setSourceName(inputs[0].getName());\n+            fakeScript.setLineno(1);\n+            fakeScript.setCharno(0);\n+\n+            root.setStaticSourceFile(\n+                    new SyntheticAstInfo(\n+                            this, fakeScript,\n+                            SynthesizedNodeInfo.SynthesizedCode.CANNOT_COPY));\n+        }\n+        return root;\n     }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n \n-    initInputsByNameMap();\n-  }\n-\n-  /**\n-   * Do any initialization that is dependent on the compiler options.\n-   */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+    List<CompilerInput> inputs = module.getInputs();\n+    if (inputs.size() > 0) {\n+        Node root = inputs.get(0).getAstRoot(this);\n+        // If the root is null or empty, then create a BLOCK node as the root.\n+        if (root == null || root.isEmpty()) {\n+            root = new Block();\n+            root.setInputId(inputs.get(0).getName());\n+            AstNode fakeScript = new AstNode(Token.SCRIPT);\n+            fakeScript.addChildToBack(root);\n+            fakeScript.setSourceName(inputs.get(0).getName());\n+            fakeScript.setLineno(1);\n+            fakeScript.setCharno(0);\n+\n+            root.setStaticSourceFile(\n+                    new SyntheticAstInfo(\n+                            this, fakeScript,\n+                            SynthesizedNodeInfo.SynthesizedCode.CANNOT_COPY));\n+        }\n+        return root;\n     }\n-  }\n-\n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n+    \n+    // If the module has no inputs, do not throw an exception, just return null.\n+    return null;\n+}\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}