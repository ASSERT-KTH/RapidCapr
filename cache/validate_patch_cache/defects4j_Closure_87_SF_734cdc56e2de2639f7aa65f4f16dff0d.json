{
    "patch": "private boolean isFoldableExpressBlock(Node n) {\n  if (n.getType() == Token.BLOCK && n.hasOneChild()) {\n    Node child = n.getFirstChild();\n    Node parent = child.getParent();\n\n    // Not foldable if the child node is a function expression or if the enclosing\n    // expression is assigned to a variable\n    if (NodeUtil.isFunctionExpression(child) || (parent != null && parent.getType() == Token.ASSIGN)) {\n      return false;\n    }\n\n    Node prevChild = null;\n    // Traverse through the child expression until we reach the final expression\n    while (child != null) {\n      Node nextChild = child.getFirstChild();\n      if (nextChild != null) {\n        // Go deeper in the tree\n        prevChild = child;\n        child = nextChild;\n        continue;\n      }\n\n      // The current node is the final expression\n      if (isFoldable(child)) {\n        // The expression is foldable, so we can return true\n        foldExpression(prevChild, child);\n        return true;\n      }\n\n      // Move to the next node in the tree\n      nextChild = child.getNext();\n      while (nextChild == null && child != null) {\n        child = child.getParent();\n        nextChild = child != null ? child.getNext() : null;\n        prevChild = child;\n      }\n      child = nextChild;\n    }\n  }\n\n  return false;\n}\n\nprivate boolean isFoldable(Node node) {\n  // Foldable only if the child expression is an expression statement and it does not have\n  // any side effects\n  if (node.getType() == Token.EXPR_RESULT && !NodeUtil.mayHaveSideEffects(node.getFirstChild())) {\n    Node expr = node.getFirstChild();\n\n    // Check if the expression is the form \"(name || call())\"\n    if (expr.getType() == Token.OR) {\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      return left.getType() == Token.NAME && right.getType() == Token.CALL;\n    }\n\n    // Check if the expression is the form \"if (!name) call()\"\n    if (expr.getType() == Token.IF) {\n      Node condition = expr.getFirstChild();\n      Node conditionChild = condition.getFirstChild();\n      if (condition.getType() == Token.NOT && conditionChild.getType() == Token.NAME) {\n        Node ifBlock = condition.getNext();\n        return ifBlock != null && ifBlock.getFirstChild() != null && ifBlock.getFirstChild().getType() == Token.EXPR_RESULT && ifBlock.getFirstChild().getFirstChild().getType() == Token.CALL;\n      }\n    }\n  }\n\n  return false;\n}\n\nprivate void foldExpression(Node prevChild, Node node) {\n  // Replace the expression block with the folded expression\n  Node parent = node.getParent();\n  Node firstChild = node.getFirstChild();\n  Node replacementNode = null;\n  if (node.getType() == Token.EXPR_RESULT && firstChild.getType() == Token.OR) {\n    // Fold the expression \"(name || call())\" to \"name || call()\"\n    Node left = firstChild.getFirstChild().detach();\n    Node right = firstChild.getLastChild().detach();\n    replacementNode = new Node(Token.OR, left, right);\n  } else if (node.getType() == Token.EXPR_RESULT && firstChild.getType() == Token.IF) {\n    // Fold the expression \"if (!name) call()\" to \"name || call()\"\n    Node ifNode = firstChild.detach();\n    Node condition = ifNode.getFirstChild().detach();\n    Node notNode = condition.getFirstChild().detach();\n    Node nameNode = notNode.getFirstChild().detach().cloneNode();\n    Node callNode = ifNode.getLastChild().detach().getFirstChild().detach().cloneNode();\n    Node left = nameNode;\n    Node right = callNode;\n    replacementNode = new Node(Token.OR, left, right);\n  }\n  if (replacementNode != null) {\n    if (parent.getType() == Token.LABEL) {\n      parent.replaceChild(node, replacementNode.cloneNode());\n    } else if (parent.getType() == Token.EXPR_RESULT) {\n      parent.replaceWith(replacementNode.cloneTree());\n    } else {\n      Node exprResult = new Node(Token.EXPR_RESULT, replacementNode.cloneNode());\n      if (prevChild != null) {\n        parent.addChildAfter(exprResult, prevChild);\n      } else {\n        parent.addChildToFront(exprResult);\n      }\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..a85b06ae 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,26 +516,112 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+private boolean isFoldableExpressBlock(Node n) {\n+  if (n.getType() == Token.BLOCK && n.hasOneChild()) {\n+    Node child = n.getFirstChild();\n+    Node parent = child.getParent();\n+\n+    // Not foldable if the child node is a function expression or if the enclosing\n+    // expression is assigned to a variable\n+    if (NodeUtil.isFunctionExpression(child) || (parent != null && parent.getType() == Token.ASSIGN)) {\n+      return false;\n+    }\n+\n+    Node prevChild = null;\n+    // Traverse through the child expression until we reach the final expression\n+    while (child != null) {\n+      Node nextChild = child.getFirstChild();\n+      if (nextChild != null) {\n+        // Go deeper in the tree\n+        prevChild = child;\n+        child = nextChild;\n+        continue;\n       }\n+\n+      // The current node is the final expression\n+      if (isFoldable(child)) {\n+        // The expression is foldable, so we can return true\n+        foldExpression(prevChild, child);\n+        return true;\n+      }\n+\n+      // Move to the next node in the tree\n+      nextChild = child.getNext();\n+      while (nextChild == null && child != null) {\n+        child = child.getParent();\n+        nextChild = child != null ? child.getNext() : null;\n+        prevChild = child;\n+      }\n+      child = nextChild;\n     }\n+  }\n \n-    return false;\n+  return false;\n+}\n+\n+private boolean isFoldable(Node node) {\n+  // Foldable only if the child expression is an expression statement and it does not have\n+  // any side effects\n+  if (node.getType() == Token.EXPR_RESULT && !NodeUtil.mayHaveSideEffects(node.getFirstChild())) {\n+    Node expr = node.getFirstChild();\n+\n+    // Check if the expression is the form \"(name || call())\"\n+    if (expr.getType() == Token.OR) {\n+      Node left = expr.getFirstChild();\n+      Node right = left.getNext();\n+      return left.getType() == Token.NAME && right.getType() == Token.CALL;\n+    }\n+\n+    // Check if the expression is the form \"if (!name) call()\"\n+    if (expr.getType() == Token.IF) {\n+      Node condition = expr.getFirstChild();\n+      Node conditionChild = condition.getFirstChild();\n+      if (condition.getType() == Token.NOT && conditionChild.getType() == Token.NAME) {\n+        Node ifBlock = condition.getNext();\n+        return ifBlock != null && ifBlock.getFirstChild() != null && ifBlock.getFirstChild().getType() == Token.EXPR_RESULT && ifBlock.getFirstChild().getFirstChild().getType() == Token.CALL;\n+      }\n+    }\n+  }\n+\n+  return false;\n+}\n+\n+private void foldExpression(Node prevChild, Node node) {\n+  // Replace the expression block with the folded expression\n+  Node parent = node.getParent();\n+  Node firstChild = node.getFirstChild();\n+  Node replacementNode = null;\n+  if (node.getType() == Token.EXPR_RESULT && firstChild.getType() == Token.OR) {\n+    // Fold the expression \"(name || call())\" to \"name || call()\"\n+    Node left = firstChild.getFirstChild().detach();\n+    Node right = firstChild.getLastChild().detach();\n+    replacementNode = new Node(Token.OR, left, right);\n+  } else if (node.getType() == Token.EXPR_RESULT && firstChild.getType() == Token.IF) {\n+    // Fold the expression \"if (!name) call()\" to \"name || call()\"\n+    Node ifNode = firstChild.detach();\n+    Node condition = ifNode.getFirstChild().detach();\n+    Node notNode = condition.getFirstChild().detach();\n+    Node nameNode = notNode.getFirstChild().detach().cloneNode();\n+    Node callNode = ifNode.getLastChild().detach().getFirstChild().detach().cloneNode();\n+    Node left = nameNode;\n+    Node right = callNode;\n+    replacementNode = new Node(Token.OR, left, right);\n   }\n+  if (replacementNode != null) {\n+    if (parent.getType() == Token.LABEL) {\n+      parent.replaceChild(node, replacementNode.cloneNode());\n+    } else if (parent.getType() == Token.EXPR_RESULT) {\n+      parent.replaceWith(replacementNode.cloneTree());\n+    } else {\n+      Node exprResult = new Node(Token.EXPR_RESULT, replacementNode.cloneNode());\n+      if (prevChild != null) {\n+        parent.addChildAfter(exprResult, prevChild);\n+      } else {\n+        parent.addChildToFront(exprResult);\n+      }\n+    }\n+  }\n+}\n \n   /**\n    * @return The expression node.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}