{
    "patch": "import org.mockito.internal.creation.bytebuddy.MockAccess;\nimport org.mockito.internal.creation.bytebuddy.MockAccessDispatcher;\nimport org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\nimport org.mockito.internal.creation.bytebuddy.SubclassMockMaker;\nimport org.mockito.internal.handler.MockHandlerImpl;\nimport org.mockito.internal.handler.MockHandlerInterface;\nimport org.mockito.internal.handler.MockHandlerLoader;\nimport org.mockito.invocation.Invocation;\nimport org.mockito.plugins.MockMaker;\nimport org.mockito.stubbing.Answer;\n\nimport java.util.Collections;\nimport java.util.LinkedHashMap;\nimport java.util.Map;\n\npublic class MockResetter {\n\n    public static<T> void resetMock(T mock) {\n        MockAccess mockAccess = getMockAccess(mock);\n        SubclassMockMaker subclassMockMaker = new SubclassMockMaker();\n        MockAccess newMock = subclassMockMaker.createMock(mockAccess.mockitoCore(), mockAccess.settings().mockName().toString(), mockAccess.mockitoCore().getMockSettings(mockAccess.mock()), Collections.<Class<?>>emptySet());\n        mockAccess.dispatcher().apply(new ResetMock(mockAccess.mock(), newMock.mock()));\n    }\n\n    private static<T> MockAccess getMockAccess(T mock) {\n        return ((MockAccess) mock);\n    }\n\n    private static class ResetMock implements MockAccessDispatcher.Dispatcher {\n\n        private final Object oldMock;\n        private final Object newMock;\n\n        private ResetMock(Object oldMock, Object newMock) {\n            this.oldMock = oldMock;\n            this.newMock = newMock;\n        }\n\n        @Override\n        public Object dispatch(MethodNameMatcher methodNameMatcher) {\n            final MockHandlerInterface<MockAccess> oldHandler = MockHandlerLoader.load((MockAccess) oldMock);\n            final MockAccess newMockAccess = (MockAccess) newMock;\n            final Invocation invocation = defaultInvocation();\n            Map<String, Object> mocks = new LinkedHashMap<>();\n            mocks.put(newMockAccess.toString(), newMockAccess.getMock());\n            Map<Object, Answer> answers = new LinkedHashMap<>();\n            answers.put(oldMock, oldHandler);\n            MockHandlerImpl<MockAccess> newHandler = new MockHandlerImpl<>(newMockAccess, invocation, mocks);\n            newHandler.setAnswers(answers);\n            newHandler.setAdditionalInterfaces(oldHandler.getMockSettings().getExtraInterfaces());\n            newMockAccess.setMockitoInterceptor(new MockMethodInterceptor<>(newHandler));\n            return null;\n        }\n\n        private Invocation defaultInvocation() {\n            final Object[] arguments = new Object[0];\n            final Class<?>[] parameterTypes = new Class[0];\n            return new Invocation() {\n                @Override\n                public Object getMock() {\n                    return oldMock;\n                }\n                @Override\n                public MockAccess getMockAccess() {\n                    return (MockAccess) oldMock;\n                }\n                @Override\n                public Object[] getArguments() {\n                    return arguments;\n                }\n                @Override\n                public Object getArgument(int index) {\n                    return arguments[index];\n                }\n                @Override\n                public Class<?> getArgumentType(int index) {\n                    return parameterTypes[index];\n                }\n                @Override\n                public void markVerified() {\n                }\n                @Override\n                public boolean isVerified() {\n                    return false;\n                }\n                @Override\n                public MockMaker getMockMaker() {\n                    return ((MockAccess)oldMock).mockMaker();\n                }\n                @Override\n                public MethodNameMatcher getMethodNameMatcher() {\n                    return DefaultMockitoCore.defaultMethodNameMatcher();\n                }\n                @Override\n                public int getSequenceNumber() {\n                    return 0;\n                }\n                @Override\n                public Object callRealMethod() throws Throwable {\n                    return null;\n                }\n            };\n        }\n\n    }\n\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..3904642ec 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,114 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.internal.creation.bytebuddy.MockAccess;\n+import org.mockito.internal.creation.bytebuddy.MockAccessDispatcher;\n+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\n+import org.mockito.internal.creation.bytebuddy.SubclassMockMaker;\n+import org.mockito.internal.handler.MockHandlerImpl;\n+import org.mockito.internal.handler.MockHandlerInterface;\n+import org.mockito.internal.handler.MockHandlerLoader;\n+import org.mockito.invocation.Invocation;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.stubbing.Answer;\n+\n+import java.util.Collections;\n+import java.util.LinkedHashMap;\n+import java.util.Map;\n+\n+public class MockResetter {\n+\n+    public static<T> void resetMock(T mock) {\n+        MockAccess mockAccess = getMockAccess(mock);\n+        SubclassMockMaker subclassMockMaker = new SubclassMockMaker();\n+        MockAccess newMock = subclassMockMaker.createMock(mockAccess.mockitoCore(), mockAccess.settings().mockName().toString(), mockAccess.mockitoCore().getMockSettings(mockAccess.mock()), Collections.<Class<?>>emptySet());\n+        mockAccess.dispatcher().apply(new ResetMock(mockAccess.mock(), newMock.mock()));\n+    }\n+\n+    private static<T> MockAccess getMockAccess(T mock) {\n+        return ((MockAccess) mock);\n+    }\n+\n+    private static class ResetMock implements MockAccessDispatcher.Dispatcher {\n+\n+        private final Object oldMock;\n+        private final Object newMock;\n+\n+        private ResetMock(Object oldMock, Object newMock) {\n+            this.oldMock = oldMock;\n+            this.newMock = newMock;\n+        }\n+\n+        @Override\n+        public Object dispatch(MethodNameMatcher methodNameMatcher) {\n+            final MockHandlerInterface<MockAccess> oldHandler = MockHandlerLoader.load((MockAccess) oldMock);\n+            final MockAccess newMockAccess = (MockAccess) newMock;\n+            final Invocation invocation = defaultInvocation();\n+            Map<String, Object> mocks = new LinkedHashMap<>();\n+            mocks.put(newMockAccess.toString(), newMockAccess.getMock());\n+            Map<Object, Answer> answers = new LinkedHashMap<>();\n+            answers.put(oldMock, oldHandler);\n+            MockHandlerImpl<MockAccess> newHandler = new MockHandlerImpl<>(newMockAccess, invocation, mocks);\n+            newHandler.setAnswers(answers);\n+            newHandler.setAdditionalInterfaces(oldHandler.getMockSettings().getExtraInterfaces());\n+            newMockAccess.setMockitoInterceptor(new MockMethodInterceptor<>(newHandler));\n+            return null;\n+        }\n+\n+        private Invocation defaultInvocation() {\n+            final Object[] arguments = new Object[0];\n+            final Class<?>[] parameterTypes = new Class[0];\n+            return new Invocation() {\n+                @Override\n+                public Object getMock() {\n+                    return oldMock;\n+                }\n+                @Override\n+                public MockAccess getMockAccess() {\n+                    return (MockAccess) oldMock;\n+                }\n+                @Override\n+                public Object[] getArguments() {\n+                    return arguments;\n+                }\n+                @Override\n+                public Object getArgument(int index) {\n+                    return arguments[index];\n+                }\n+                @Override\n+                public Class<?> getArgumentType(int index) {\n+                    return parameterTypes[index];\n+                }\n+                @Override\n+                public void markVerified() {\n+                }\n+                @Override\n+                public boolean isVerified() {\n+                    return false;\n+                }\n+                @Override\n+                public MockMaker getMockMaker() {\n+                    return ((MockAccess)oldMock).mockMaker();\n+                }\n+                @Override\n+                public MethodNameMatcher getMethodNameMatcher() {\n+                    return DefaultMockitoCore.defaultMethodNameMatcher();\n+                }\n+                @Override\n+                public int getSequenceNumber() {\n+                    return 0;\n+                }\n+                @Override\n+                public Object callRealMethod() throws Throwable {\n+                    return null;\n+                }\n+            };\n+        }\n+\n+    }\n+\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}