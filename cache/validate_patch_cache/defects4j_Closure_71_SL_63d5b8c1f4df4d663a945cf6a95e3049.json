{
    "patch": "  private static boolean isPrivateProperty(String propertyName, ObjectType objectType) {\n    JSDocInfo docInfo = null;\n    for (; objectType != null;\n         objectType = objectType.getImplicitPrototype()) {\n      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n      if (docInfo != null &&\n          docInfo.getVisibility() != Visibility.INHERITED) {\n        break;\n      }\n    }\n    return docInfo != null && docInfo.getVisibility() == Visibility.PRIVATE;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckAccessControls.java b/src/com/google/javascript/jscomp/CheckAccessControls.java\nindex b23fd7af..1b3acc86 100644\n--- a/src/com/google/javascript/jscomp/CheckAccessControls.java\n+++ b/src/com/google/javascript/jscomp/CheckAccessControls.java\n@@ -413,7 +413,18 @@ class CheckAccessControls implements ScopedCallback, HotSwapCompilerPass {\n     if (objectType != null) {\n       // Is this a normal property access, or are we trying to override\n       // an existing property?\n-      boolean isOverride = t.inGlobalScope() &&\n+  private static boolean isPrivateProperty(String propertyName, ObjectType objectType) {\n+    JSDocInfo docInfo = null;\n+    for (; objectType != null;\n+         objectType = objectType.getImplicitPrototype()) {\n+      docInfo = objectType.getOwnPropertyJSDocInfo(propertyName);\n+      if (docInfo != null &&\n+          docInfo.getVisibility() != Visibility.INHERITED) {\n+        break;\n+      }\n+    }\n+    return docInfo != null && docInfo.getVisibility() == Visibility.PRIVATE;\n+  }\n           parent.getType() == Token.ASSIGN &&\n           parent.getFirstChild() == getprop;\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}