{
    "patch": "        double yMid;\n        double xMid;\n        double yTol = 2 * functionValueAccuracy;\n        double xTol = absoluteAccuracy + relativeAccuracy * (Math.max(Math.abs(initial), Math.abs(max)) - Math.min(Math.abs(initial), Math.abs(max)));\n        \n        double fmin = f.value(min);\n        double fmax = yMax;\n        double fm = yMid=f.value(xMid = xMin + 0.5 * (xMax - xMin));\n        double s = 0;\n        double r = Double.NaN;\n        double bisectTol = relativeAccuracy;\n        while (this.getMaxEvaluations() > this.getEvaluations()) {\n            final double previousMidpoint = xMid;\n            final double delta  = 0.5 * (xMax - xMin);\n            final boolean bisect = (Math.abs(s) < bisectTol ) || (Math.abs(fm) <= yTol);\n            if (delta <= xTol || (bisect && (r != Double.NaN && Math.abs(r) <= xiTol))) {\n                setResult(xMid, delta);\n                return result;\n            }\n            if (!bisect) {\n                double p;\n                if (Math.abs(s) >= xiTol) {\n                    p = 2 * delta * (fm > fmin ? -1 : 1) * (fm - yMid);\n                    final double q = Math.abs(s) - delta * (r != Double.NaN ? Math.signum(r) : p > 0 ? 1 : -1) * (Math.abs(p) <= Math.abs(0.5 * s * r) ? p / r : 0.5 * s * s / (r + eps*(r < 0 ? -r : r)));\n                    final double x = xMid + q;\n                    if (x < previousMidpoint || x > xMax) {\n                        p = Math.abs(delta * 0.5 * r);\n                        q = delta * 0.5 * s;\n                        bisect = true;\n                    } else if (Math.abs(q) < Math.abs(0.5 * s * r) && q > 0 && q < s*(xMax - xMid) && r != Double.NaN) {\n                        s = q / r;\n                        setResult(x, delta);\n                        return result;\n                    } else {\n                        bisect = true;\n                    }\n                } else {\n                    p = 2 * delta * (fm > fmin ? -1 : 1) * (fm - yMid);\n                    q = 1 - delta * (fm - yMin)/(yMid - yMin);\n\n                    final double x = xMin + q * (xMid - xMin);\n                    if (x < previousMidpoint || x > xMax) {\n                        p = Math.abs(delta * 0.5 * r);\n                        q = delta * 0.5 * s;\n                        bisect = true;\n                    } else {\n                        s = q;\n                        setResult(x, delta);\n                        return result;\n                    }\n                }\n                if (bisect) {\n                    if (Double.isNaN(r)) {\n                        r = xMid - previousMidpoint;\n                        s = r;\n                    }\n                    else {\n                        r = xMid - previousMidpoint > 0 ? Math.abs(delta) : -Math.abs(delta);\n                        s = r;\n                    }\n                }\n            }\n            else {\n                if (Double.isNaN(r)) {\n                    r = xMid - previousMidpoint;\n                    s = r;\n                }\n                else {\n                    r = xMid - previousMidpoint > 0 ? Math.abs(delta) : -Math.abs(delta);\n                    s = r;\n                }\n            }\n            fm = f.value(xMid+=MathUtils.round(s, RoundingMode.HALF_UP));\n            if (fm * yMid >= 0.0) {\n                yMin = fm > 0 ? yMin : fm;\n                yMid = fm > 0 ? fm : yMid;\n                xMin = fm > 0 ? xMin : xMid;\n                xMid = fm > 0 ? xMid : xMin;\n            } else {\n                yMax = fm > 0 ? fm : yMax;\n                yMid = fm > 0 ? yMid : fm;\n                xMax = fm > 0 ? xMid : xMax;\n                xMid = fm > 0 ? xMin : xMid;\n            }\n            if (Math.abs(yMax - yMin) <= functionValueAccuracy) {\n                setResult(xMid, Math.abs(yMax-yMin)/2);\n                return result;\n            }\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..530572e3b 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,97 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double yMid;\n+        double xMid;\n+        double yTol = 2 * functionValueAccuracy;\n+        double xTol = absoluteAccuracy + relativeAccuracy * (Math.max(Math.abs(initial), Math.abs(max)) - Math.min(Math.abs(initial), Math.abs(max)));\n+        \n+        double fmin = f.value(min);\n+        double fmax = yMax;\n+        double fm = yMid=f.value(xMid = xMin + 0.5 * (xMax - xMin));\n+        double s = 0;\n+        double r = Double.NaN;\n+        double bisectTol = relativeAccuracy;\n+        while (this.getMaxEvaluations() > this.getEvaluations()) {\n+            final double previousMidpoint = xMid;\n+            final double delta  = 0.5 * (xMax - xMin);\n+            final boolean bisect = (Math.abs(s) < bisectTol ) || (Math.abs(fm) <= yTol);\n+            if (delta <= xTol || (bisect && (r != Double.NaN && Math.abs(r) <= xiTol))) {\n+                setResult(xMid, delta);\n+                return result;\n+            }\n+            if (!bisect) {\n+                double p;\n+                if (Math.abs(s) >= xiTol) {\n+                    p = 2 * delta * (fm > fmin ? -1 : 1) * (fm - yMid);\n+                    final double q = Math.abs(s) - delta * (r != Double.NaN ? Math.signum(r) : p > 0 ? 1 : -1) * (Math.abs(p) <= Math.abs(0.5 * s * r) ? p / r : 0.5 * s * s / (r + eps*(r < 0 ? -r : r)));\n+                    final double x = xMid + q;\n+                    if (x < previousMidpoint || x > xMax) {\n+                        p = Math.abs(delta * 0.5 * r);\n+                        q = delta * 0.5 * s;\n+                        bisect = true;\n+                    } else if (Math.abs(q) < Math.abs(0.5 * s * r) && q > 0 && q < s*(xMax - xMid) && r != Double.NaN) {\n+                        s = q / r;\n+                        setResult(x, delta);\n+                        return result;\n+                    } else {\n+                        bisect = true;\n+                    }\n+                } else {\n+                    p = 2 * delta * (fm > fmin ? -1 : 1) * (fm - yMid);\n+                    q = 1 - delta * (fm - yMin)/(yMid - yMin);\n+\n+                    final double x = xMin + q * (xMid - xMin);\n+                    if (x < previousMidpoint || x > xMax) {\n+                        p = Math.abs(delta * 0.5 * r);\n+                        q = delta * 0.5 * s;\n+                        bisect = true;\n+                    } else {\n+                        s = q;\n+                        setResult(x, delta);\n+                        return result;\n+                    }\n+                }\n+                if (bisect) {\n+                    if (Double.isNaN(r)) {\n+                        r = xMid - previousMidpoint;\n+                        s = r;\n+                    }\n+                    else {\n+                        r = xMid - previousMidpoint > 0 ? Math.abs(delta) : -Math.abs(delta);\n+                        s = r;\n+                    }\n+                }\n+            }\n+            else {\n+                if (Double.isNaN(r)) {\n+                    r = xMid - previousMidpoint;\n+                    s = r;\n+                }\n+                else {\n+                    r = xMid - previousMidpoint > 0 ? Math.abs(delta) : -Math.abs(delta);\n+                    s = r;\n+                }\n+            }\n+            fm = f.value(xMid+=MathUtils.round(s, RoundingMode.HALF_UP));\n+            if (fm * yMid >= 0.0) {\n+                yMin = fm > 0 ? yMin : fm;\n+                yMid = fm > 0 ? fm : yMid;\n+                xMin = fm > 0 ? xMin : xMid;\n+                xMid = fm > 0 ? xMid : xMin;\n+            } else {\n+                yMax = fm > 0 ? fm : yMax;\n+                yMid = fm > 0 ? yMid : fm;\n+                xMax = fm > 0 ? xMid : xMax;\n+                xMid = fm > 0 ? xMin : xMid;\n+            }\n+            if (Math.abs(yMax - yMin) <= functionValueAccuracy) {\n+                setResult(xMid, Math.abs(yMax-yMin)/2);\n+                return result;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}