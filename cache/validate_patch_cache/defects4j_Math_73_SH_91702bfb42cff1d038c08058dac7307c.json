{
    "patch": "        final int maximalIterationCount = 100;\n        double x0 = min;\n        double x1 = initial;\n        double x2 = max;\n        double y0 = f.value(x0);\n        double y1 = f.value(x1);\n        double y2 = f.value(x2);\n\n        double oldx = Double.POSITIVE_INFINITY;\n        double x = x1;\n        double fx = y1;\n        double fy = fx;\n        double delta = 0;\n        double delta1 = 0;\n        double delta2 = 0;\n        double tol = eps * Math.abs(x1) + t;\n        while (iterationCount < maximalIterationCount) {\n            if (Math.abs(y2 - y1) > Math.abs(y0 - y1)) {\n                // Swap x0, x1, y0, and y1\n                double temp = x0;\n                x0 = x2;\n                x2 = temp;\n                temp = y0;\n                y0 = y2;\n                y2 = temp;\n            }\n            // If y1 is very small relative to y0 and y2 then either\n            // x1 is a root or a close approximation is obtained.\n            if (Math.abs(y1) <= functionValueAccuracy) {\n                setResult(x1, iterationCount);\n                return result;\n            }\n            if (Math.abs(oldx - x) < tol && fy == fx) {\n                setResult(x, iterationCount);\n                return result;\n            }\n            oldx = x;\n            // Secant method with one point.\n            if (y0 != y1 && y1 != y2 && y0 != y2) {\n                double delta12 = y1 * (y2 - y0);\n                double delta02 = y0 * (y2 - y1);\n                x = ((x1 * delta12) + (x0 * delta02)) / (delta12 + delta02);\n            } else {\n                // A very unlikely case: x0, x1, and x2 are very close so that\n                // numerical precision spoils the calculation.\n                x = x1 - (fx / fy) * (x1 - x0);\n            }\n            fx = f.value(x);\n            fy = fx;\n            delta2 = delta1;\n            delta1 = delta;\n            delta = fx;\n            // Adjust the brackets.\n            if (fx * y1 < 0) {\n                x0 = x1;\n                y0 = y1;\n            } else {\n                x2 = x1;\n                y2 = y1;\n            }\n            if (Math.abs(y2) < Math.abs(y1)) {\n                double temp = x0;\n                x0 = x1;\n                x1 = x2;\n                x2 = temp;\n                temp = y0;\n                y0 = y1;\n                y1 = y2;\n                y2 = temp;\n            }\n            double fx2 = f.value(x2);\n            if (Math.abs(fx2) <= functionValueAccuracy) {\n                setResult(x2, iterationCount);\n                return result;\n            }\n            ++iterationCount;\n        }\n        throw new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..39d11de4f 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,84 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        final int maximalIterationCount = 100;\n+        double x0 = min;\n+        double x1 = initial;\n+        double x2 = max;\n+        double y0 = f.value(x0);\n+        double y1 = f.value(x1);\n+        double y2 = f.value(x2);\n+\n+        double oldx = Double.POSITIVE_INFINITY;\n+        double x = x1;\n+        double fx = y1;\n+        double fy = fx;\n+        double delta = 0;\n+        double delta1 = 0;\n+        double delta2 = 0;\n+        double tol = eps * Math.abs(x1) + t;\n+        while (iterationCount < maximalIterationCount) {\n+            if (Math.abs(y2 - y1) > Math.abs(y0 - y1)) {\n+                // Swap x0, x1, y0, and y1\n+                double temp = x0;\n+                x0 = x2;\n+                x2 = temp;\n+                temp = y0;\n+                y0 = y2;\n+                y2 = temp;\n+            }\n+            // If y1 is very small relative to y0 and y2 then either\n+            // x1 is a root or a close approximation is obtained.\n+            if (Math.abs(y1) <= functionValueAccuracy) {\n+                setResult(x1, iterationCount);\n+                return result;\n+            }\n+            if (Math.abs(oldx - x) < tol && fy == fx) {\n+                setResult(x, iterationCount);\n+                return result;\n+            }\n+            oldx = x;\n+            // Secant method with one point.\n+            if (y0 != y1 && y1 != y2 && y0 != y2) {\n+                double delta12 = y1 * (y2 - y0);\n+                double delta02 = y0 * (y2 - y1);\n+                x = ((x1 * delta12) + (x0 * delta02)) / (delta12 + delta02);\n+            } else {\n+                // A very unlikely case: x0, x1, and x2 are very close so that\n+                // numerical precision spoils the calculation.\n+                x = x1 - (fx / fy) * (x1 - x0);\n+            }\n+            fx = f.value(x);\n+            fy = fx;\n+            delta2 = delta1;\n+            delta1 = delta;\n+            delta = fx;\n+            // Adjust the brackets.\n+            if (fx * y1 < 0) {\n+                x0 = x1;\n+                y0 = y1;\n+            } else {\n+                x2 = x1;\n+                y2 = y1;\n+            }\n+            if (Math.abs(y2) < Math.abs(y1)) {\n+                double temp = x0;\n+                x0 = x1;\n+                x1 = x2;\n+                x2 = temp;\n+                temp = y0;\n+                y0 = y1;\n+                y1 = y2;\n+                y2 = temp;\n+            }\n+            double fx2 = f.value(x2);\n+            if (Math.abs(fx2) <= functionValueAccuracy) {\n+                setResult(x2, iterationCount);\n+                return result;\n+            }\n+            ++iterationCount;\n+        }\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}