{
    "patch": "      Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n      if(candidate != null) {\n        Class<?> candidateClass = candidate.getClass();\n        while(candidateClass != null) {\n          if(field.getType().isAssignableFrom(candidateClass)) {\n            try {\n              field.setAccessible(true);\n              // check if field is final\n              Field modifiers = Field.class.getDeclaredField(\"modifiers\");\n              modifiers.setAccessible(true);\n              modifiers.setInt(field, field.getModifiers() & ~Modifier.FINAL);\n              field.set(fieldInstance, candidate);\n              if(!field.getType().equals(candidateClass)) {\n                  injectMockCandidate(candidateClass.getSuperclass(), mocks, candidate);\n              }\n              return;\n            } catch(IllegalAccessException | NoSuchFieldException | SecurityException e) {\n              throw new IllegalStateException(\"Couldnot set field value\", e);\n            }\n          }\n          candidateClass = candidateClass.getSuperclass();\n        }\n        injectMockCandidate(field.getType(), mocks, fieldInstance);\n      }",
    "patch_diff": "diff --git a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\nindex 213ebf351..a3eee79c7 100644\n--- a/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n+++ b/src/org/mockito/internal/configuration/DefaultInjectionEngine.java\n@@ -88,9 +88,33 @@ public class DefaultInjectionEngine {\n         }\n     }\n \n+\n     private void injectMockCandidate(Class<?> awaitingInjectionClazz, Set<Object> mocks, Object fieldInstance) {\n         for(Field field : orderedInstanceFieldsFrom(awaitingInjectionClazz)) {\n-            mockCandidateFilter.filterCandidate(mocks, field, fieldInstance).thenInject();\n+      Object candidate = mockCandidateFilter.filterCandidate(mocks, field, fieldInstance);\n+      if(candidate != null) {\n+        Class<?> candidateClass = candidate.getClass();\n+        while(candidateClass != null) {\n+          if(field.getType().isAssignableFrom(candidateClass)) {\n+            try {\n+              field.setAccessible(true);\n+              // check if field is final\n+              Field modifiers = Field.class.getDeclaredField(\"modifiers\");\n+              modifiers.setAccessible(true);\n+              modifiers.setInt(field, field.getModifiers() & ~Modifier.FINAL);\n+              field.set(fieldInstance, candidate);\n+              if(!field.getType().equals(candidateClass)) {\n+                  injectMockCandidate(candidateClass.getSuperclass(), mocks, candidate);\n+              }\n+              return;\n+            } catch(IllegalAccessException | NoSuchFieldException | SecurityException e) {\n+              throw new IllegalStateException(\"Couldnot set field value\", e);\n+            }\n+          }\n+          candidateClass = candidateClass.getSuperclass();\n+        }\n+        injectMockCandidate(field.getType(), mocks, fieldInstance);\n+      }\n         }\n     }\n ",
    "result_reason": "error: multi-catch statement is not supported in -source 1.5",
    "test_result": "ERROR"
}