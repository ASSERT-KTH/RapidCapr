{
    "patch": "import org.apache.commons.math3.analysis.MultivariateFunction;\nimport org.apache.commons.math3.analysis.SimpleBounds;\nimport org.apache.commons.math3.optim.InitialGuess;\nimport org.apache.commons.math3.optim.MaxEval;\nimport org.apache.commons.math3.optim.PointValuePair;\nimport org.apache.commons.math3.optim.SimpleBounds;\nimport org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\nimport org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.LifecycleListener;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.RetryBehavior;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.TerminationException;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerUtils;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexSolver;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexTableau;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SingleObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.PointValuePairComparator;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.Simplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexTableau;\nimport org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\nimport org.apache.commons.math3.optim.univariate.UnivariateOptimizer;\nimport org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\nimport org.apache.commons.math3.optim.univariate.search.BracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.ExpandableBracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.GoldenSectionBracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.SearchInterval;\nimport org.apache.commons.math3.optim.univariate.search.UnivariateSearch;\nimport org.apache.commons.math3.optim.univariate.search.UnivariateSearch.Direction;\nimport org.apache.commons.math3.util.FastMath;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class NelderMead implements MultivariateOptimizer {\n\n    private static final int DEFAULT_MAX_ITERATIONS = 200;\n    private static final double DEFAULT_ABSOLUTE_TOLERANCE = 1e-6;\n    private static final double DEFAULT_RELATIVE_TOLERANCE = 1e-6;\n    private static final double DEFAULT_SIMPLE_MAX = 1.0;\n    private static final double DEFAULT_SIMPLE_MIN = 0.5;\n\n    private final double rho;\n    private final double khi;\n    private final double gamma;\n    private final double sigma;\n    private final LifecycleListener lifecycleListener;\n\n    private int iterations;\n    private int maxIterations;\n    private double absoluteThreshold;\n    private double relativeThreshold;\n\n    public NelderMead() {\n        this(1.0, 2.0, 0.5, 0.5, DEFAULT_MAX_ITERATIONS, DEFAULT_ABSOLUTE_TOLERANCE, DEFAULT_RELATIVE_TOLERANCE);\n    }\n\n    public NelderMead(final double rho, final double khi, final double gamma, final double sigma,\n                      final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n        this.rho = rho;\n        this.khi = khi;\n        this.gamma = gamma;\n        this.sigma = sigma;\n        this.lifecycleListener = null;\n        setMaxIterations(maxIterations);\n        setAbsoluteThreshold(absoluteThreshold);\n        setRelativeThreshold(relativeThreshold);\n    }\n\n    /**\n     * Gets the reflection coefficient.\n     *\n     * @return the reflection coefficient.\n     */\n    public double getRho() {\n        return rho;\n    }\n\n    /**\n     * Gets the expansion coefficient.\n     *\n     * @return the expansion coefficient.\n     */\n    public double getKhi() {\n        return khi;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..17ae2b5ab 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,46 +58,94 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-\n-        while (true) {\n-\n-            incrementIterationsCounter();\n-\n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n-\n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n+import org.apache.commons.math3.analysis.MultivariateFunction;\n+import org.apache.commons.math3.analysis.SimpleBounds;\n+import org.apache.commons.math3.optim.InitialGuess;\n+import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.PointValuePair;\n+import org.apache.commons.math3.optim.SimpleBounds;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n+import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.LifecycleListener;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.RetryBehavior;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.TerminationException;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerUtils;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexSolver;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexTableau;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SingleObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.PointValuePairComparator;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.Simplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexTableau;\n+import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\n+import org.apache.commons.math3.optim.univariate.UnivariateOptimizer;\n+import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\n+import org.apache.commons.math3.optim.univariate.search.BracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.ExpandableBracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.GoldenSectionBracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.SearchInterval;\n+import org.apache.commons.math3.optim.univariate.search.UnivariateSearch;\n+import org.apache.commons.math3.optim.univariate.search.UnivariateSearch.Direction;\n+import org.apache.commons.math3.util.FastMath;\n+\n+import java.util.Arrays;\n+import java.util.Comparator;\n \n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n+public class NelderMead implements MultivariateOptimizer {\n \n-                return;\n+    private static final int DEFAULT_MAX_ITERATIONS = 200;\n+    private static final double DEFAULT_ABSOLUTE_TOLERANCE = 1e-6;\n+    private static final double DEFAULT_RELATIVE_TOLERANCE = 1e-6;\n+    private static final double DEFAULT_SIMPLE_MAX = 1.0;\n+    private static final double DEFAULT_SIMPLE_MIN = 0.5;\n \n-            }\n+    private final double rho;\n+    private final double khi;\n+    private final double gamma;\n+    private final double sigma;\n+    private final LifecycleListener lifecycleListener;\n \n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n+    private int iterations;\n+    private int maxIterations;\n+    private double absoluteThreshold;\n+    private double relativeThreshold;\n \n-            // check convergence\n-                return;\n-            }\n+    public NelderMead() {\n+        this(1.0, 2.0, 0.5, 0.5, DEFAULT_MAX_ITERATIONS, DEFAULT_ABSOLUTE_TOLERANCE, DEFAULT_RELATIVE_TOLERANCE);\n+    }\n \n-        }\n+    public NelderMead(final double rho, final double khi, final double gamma, final double sigma,\n+                      final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n+        this.rho = rho;\n+        this.khi = khi;\n+        this.gamma = gamma;\n+        this.sigma = sigma;\n+        this.lifecycleListener = null;\n+        setMaxIterations(maxIterations);\n+        setAbsoluteThreshold(absoluteThreshold);\n+        setRelativeThreshold(relativeThreshold);\n+    }\n \n+    /**\n+     * Gets the reflection coefficient.\n+     *\n+     * @return the reflection coefficient.\n+     */\n+    public double getRho() {\n+        return rho;\n     }\n \n+    /**\n+     * Gets the expansion coefficient.\n+     *\n+     * @return the expansion coefficient.\n+     */\n+    public double getKhi() {\n+        return khi;\n+\n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)\n      * @param coeff linear coefficient",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}