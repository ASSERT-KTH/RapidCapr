{
    "patch": "      // Functions with explicit 'this' types must be called in a GETPROP\n      // or GETELEM.\n      JSTypeRegistry registry = getTypeCheck().getCompiler().getTypeRegistry();\n      JSType thisType = functionType.getTypeOfThis();\n      \n      if (!thisType.isUnknownType() && !child.isGetProp() && !child.isGetElem()) {\n        if (registry.isSubtype(getJSType(child), registry.createFunctionType(registry.getNativeType(NUMBER_TYPE)))) {\n          // The function is being treated as a constructor by calling it with new.\n          // No warnings need to be raised in this case.\n        } else {\n          // If this is a constructor, make sure the function is called with new,\n          // otherwise warn that the \"this\" type is being lost.\n          if (functionType.isConstructor()) {\n            ConformanceLevel level = ConformanceLevel.VIOLATION;\n            String message = \"Losing 'this' type of function in non-constructor call.\";\n            if (!thisType.isConstructor()) {\n              level = ConformanceLevel.WARNING;\n              message = \"Losing 'this' type of non-constructor function in non-getprop/getelem call.\";\n            }\n            reportConformanceViolation(getTypedPercent() < 99, level, n, message);\n          } else {\n            report(t, n, FunctionTypeBuilder.INVALID_THIS_TYPE);\n          }\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..21807568 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,30 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+      // Functions with explicit 'this' types must be called in a GETPROP\n+      // or GETELEM.\n+      JSTypeRegistry registry = getTypeCheck().getCompiler().getTypeRegistry();\n+      JSType thisType = functionType.getTypeOfThis();\n+      \n+      if (!thisType.isUnknownType() && !child.isGetProp() && !child.isGetElem()) {\n+        if (registry.isSubtype(getJSType(child), registry.createFunctionType(registry.getNativeType(NUMBER_TYPE)))) {\n+          // The function is being treated as a constructor by calling it with new.\n+          // No warnings need to be raised in this case.\n+        } else {\n+          // If this is a constructor, make sure the function is called with new,\n+          // otherwise warn that the \"this\" type is being lost.\n+          if (functionType.isConstructor()) {\n+            ConformanceLevel level = ConformanceLevel.VIOLATION;\n+            String message = \"Losing 'this' type of function in non-constructor call.\";\n+            if (!thisType.isConstructor()) {\n+              level = ConformanceLevel.WARNING;\n+              message = \"Losing 'this' type of non-constructor function in non-getprop/getelem call.\";\n+            }\n+            reportConformanceViolation(getTypedPercent() < 99, level, n, message);\n+          } else {\n+            report(t, n, FunctionTypeBuilder.INVALID_THIS_TYPE);\n+          }\n+        }\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}