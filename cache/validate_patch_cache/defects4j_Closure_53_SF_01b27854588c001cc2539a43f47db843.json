{
    "patch": "    private void replaceAssignmentExpression(Var v, Reference ref,\n                                             Map<String, String> varmap) {\n      // Compute all of the assignments necessary\n      List<Node> nodes = new LinkedList<>();\n      Node val = ref.getAssignedValue();\n      blacklistVarReferencesInTree(val, v.scope);\n      if (val.isObjectLit()) {\n        Set<String> all = new LinkedHashSet<>(varmap.keySet());\n        for (Node key = val.getFirstChild(); key != null;\n             key = key.getNext()) {\n          String var = key.getString();\n          Node value = key.removeFirstChild();\n          nodes.add(\n              IR.assign(\n                  IR.name(varmap.get(var)),\n                  value));\n          all.remove(var);\n        }\n\n        /* Better source information. */\n        for (String var : all) {\n          nodes.add(\n              IR.assign(\n                  IR.name(varmap.get(var)),\n                  IR.undefined()));\n        }\n\n        /* All assignments evaluate to true. */\n        nodes.add(IR.trueNode());\n\n        /* Join these using COMMA:\n         * A COMMA node must have 2 children, so we create a tree. In the tree the\n         * first child be the COMMA to match the parser, otherwise tree equality\n         * tests fail.\n         */\n        nodes = Lists.reverse(nodes);\n        Node replacement = IR.comma();\n        Node cur = replacement;\n        int i;\n        for (i = 0; i < nodes.size() - 2; i++) {\n          cur.addChildToFront(nodes.get(i));\n          Node t = IR.comma();\n          cur.addChildToFront(t);\n          cur = t;\n        }\n        cur.addChildToFront(nodes.get(i));\n        cur.addChildToFront(nodes.get(i + 1));\n\n        Node parent = ref.getParent();\n        replacement.srcrefTree(parent);\n        if (parent.isName()) {\n          // This is an assignment that first assigns a name, then its value. For\n          // example:\n          //   varname = val;\n          // In this case, we replace the name node with the new expression, which\n          // contains the new name (which is a temporary name), and the original\n          // assignment expression as its second child.\n          //\n          // The resulting code will look something like this:\n          //\n          //   var _1; _1 = val;\n          Node newExpr = NodeUtil.newExpr(replacement);\n          Node originalName = parent.detachFromParent();\n          Node exprStmt = IR.exprResult(originalName, newExpr).srcref(newExpr);\n\n          parent.replaceWith(exprStmt);\n        } else {\n          // This is a regular assignment, e.g.:\n          //   obj.prop = val;\n          // or\n          //   varname = val;\n          // In this case, we replace the entire assignment node with the new\n          // expression.\n          parent.replaceWith(new Node(Token.EXPR_RESULT, replacement).srcrefTree(parent));\n        }\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 9061925d..38b73611 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -303,59 +303,78 @@ class InlineObjectLiterals implements CompilerPass {\n     private void replaceAssignmentExpression(Var v, Reference ref,\n                                              Map<String, String> varmap) {\n       // Compute all of the assignments necessary\n-      List<Node> nodes = Lists.newArrayList();\n+      List<Node> nodes = new LinkedList<>();\n       Node val = ref.getAssignedValue();\n       blacklistVarReferencesInTree(val, v.scope);\n-      Preconditions.checkState(val.getType() == Token.OBJECTLIT);\n-      Set<String> all = Sets.newLinkedHashSet(varmap.keySet());\n-      for (Node key = val.getFirstChild(); key != null;\n-           key = key.getNext()) {\n-        String var = key.getString();\n-        Node value = key.removeFirstChild();\n-        // TODO(user): Copy type information.\n-        nodes.add(\n-          new Node(Token.ASSIGN,\n-                   Node.newString(Token.NAME, varmap.get(var)), value));\n-        all.remove(var);\n-      }\n+      if (val.isObjectLit()) {\n+        Set<String> all = new LinkedHashSet<>(varmap.keySet());\n+        for (Node key = val.getFirstChild(); key != null;\n+             key = key.getNext()) {\n+          String var = key.getString();\n+          Node value = key.removeFirstChild();\n+          nodes.add(\n+              IR.assign(\n+                  IR.name(varmap.get(var)),\n+                  value));\n+          all.remove(var);\n+        }\n \n-      // TODO(user): Better source information.\n-      for (String var : all) {\n-        nodes.add(\n-          new Node(Token.ASSIGN,\n-                   Node.newString(Token.NAME, varmap.get(var)),\n-                   NodeUtil.newUndefinedNode(null)));\n-      }\n+        /* Better source information. */\n+        for (String var : all) {\n+          nodes.add(\n+              IR.assign(\n+                  IR.name(varmap.get(var)),\n+                  IR.undefined()));\n+        }\n \n-      Node replacement;\n-        // All assignments evaluate to true, so make sure that the\n-        // expr statement evaluates to true in case it matters.\n-        nodes.add(new Node(Token.TRUE));\n+        /* All assignments evaluate to true. */\n+        nodes.add(IR.trueNode());\n \n-        // Join these using COMMA.  A COMMA node must have 2 children, so we\n-        // create a tree. In the tree the first child be the COMMA to match\n-        // the parser, otherwise tree equality tests fail.\n+        /* Join these using COMMA:\n+         * A COMMA node must have 2 children, so we create a tree. In the tree the\n+         * first child be the COMMA to match the parser, otherwise tree equality\n+         * tests fail.\n+         */\n         nodes = Lists.reverse(nodes);\n-        replacement = new Node(Token.COMMA);\n+        Node replacement = IR.comma();\n         Node cur = replacement;\n         int i;\n         for (i = 0; i < nodes.size() - 2; i++) {\n           cur.addChildToFront(nodes.get(i));\n-          Node t = new Node(Token.COMMA);\n+          Node t = IR.comma();\n           cur.addChildToFront(t);\n           cur = t;\n         }\n         cur.addChildToFront(nodes.get(i));\n         cur.addChildToFront(nodes.get(i + 1));\n \n-      Node replace = ref.getParent();\n-      replacement.copyInformationFromForTree(replace);\n-\n-      if (replace.getType() == Token.VAR) {\n-        replace.getParent().replaceChild(\n-            replace, NodeUtil.newExpr(replacement));\n-      } else {\n-        replace.getParent().replaceChild(replace, replacement);\n+        Node parent = ref.getParent();\n+        replacement.srcrefTree(parent);\n+        if (parent.isName()) {\n+          // This is an assignment that first assigns a name, then its value. For\n+          // example:\n+          //   varname = val;\n+          // In this case, we replace the name node with the new expression, which\n+          // contains the new name (which is a temporary name), and the original\n+          // assignment expression as its second child.\n+          //\n+          // The resulting code will look something like this:\n+          //\n+          //   var _1; _1 = val;\n+          Node newExpr = NodeUtil.newExpr(replacement);\n+          Node originalName = parent.detachFromParent();\n+          Node exprStmt = IR.exprResult(originalName, newExpr).srcref(newExpr);\n+\n+          parent.replaceWith(exprStmt);\n+        } else {\n+          // This is a regular assignment, e.g.:\n+          //   obj.prop = val;\n+          // or\n+          //   varname = val;\n+          // In this case, we replace the entire assignment node with the new\n+          // expression.\n+          parent.replaceWith(new Node(Token.EXPR_RESULT, replacement).srcrefTree(parent));\n+        }\n       }\n     }\n ",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}