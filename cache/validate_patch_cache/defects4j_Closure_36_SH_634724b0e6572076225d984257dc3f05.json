{
    "patch": "String prefix = options.getModuleIdPrefix();\n    Map<String, String> moduleNameMap = options.getModuleNameMap();\n    for (JSModule module : modules) {\n      Node moduleGraph = processModule(module, prefix, moduleNameMap);\n\n      // In this scenario, it's easier to just set\n      // a specific property to the Root node.\n      if ((module.getId() != null) && module.getId().equals(entryPoint)) {\n        moduleGraph.putBooleanProp(Node.OUTPUT_MARKER, true);\n      }\n      root.addChildrenToBack(moduleGraph.removeChildren());\n    }\n\n    // Make it just a single instance.\n    codeChangeHandler.process(root);\n\n    List<Node> orderedDeps = createOrderedDependenciesList(root);\n    if (options.shouldRemoveUnusedCode()) {\n      removeUnusedCode(orderedDeps);\n    }\n    if (options.shouldCollapseAnonymousFunctions()) {\n      new CollapseAnonymousFunctions(compiler).process(orderedDeps);\n    }\n    if (options.shouldOptimizeCalls()) {\n      new OptimizeParameters(compiler).process(orderedDeps);\n    }\n\n    // Type checking, report based on errors, and compute function info.\n    checkTypes(root, orderedDeps);\n    reportBasedOnWarnings();\n    return root;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..f0dbf4ac 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,38 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+String prefix = options.getModuleIdPrefix();\n+    Map<String, String> moduleNameMap = options.getModuleNameMap();\n+    for (JSModule module : modules) {\n+      Node moduleGraph = processModule(module, prefix, moduleNameMap);\n+\n+      // In this scenario, it's easier to just set\n+      // a specific property to the Root node.\n+      if ((module.getId() != null) && module.getId().equals(entryPoint)) {\n+        moduleGraph.putBooleanProp(Node.OUTPUT_MARKER, true);\n+      }\n+      root.addChildrenToBack(moduleGraph.removeChildren());\n+    }\n+\n+    // Make it just a single instance.\n+    codeChangeHandler.process(root);\n+\n+    List<Node> orderedDeps = createOrderedDependenciesList(root);\n+    if (options.shouldRemoveUnusedCode()) {\n+      removeUnusedCode(orderedDeps);\n+    }\n+    if (options.shouldCollapseAnonymousFunctions()) {\n+      new CollapseAnonymousFunctions(compiler).process(orderedDeps);\n+    }\n+    if (options.shouldOptimizeCalls()) {\n+      new OptimizeParameters(compiler).process(orderedDeps);\n+    }\n+\n+    // Type checking, report based on errors, and compute function info.\n+    checkTypes(root, orderedDeps);\n+    reportBasedOnWarnings();\n+    return root;\n+  }\n         }\n       }\n ",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}