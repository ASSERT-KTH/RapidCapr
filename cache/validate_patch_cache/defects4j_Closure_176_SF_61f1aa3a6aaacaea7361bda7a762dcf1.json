{
    "patch": "/**\n   * Determines the type of an assignment operation.\n   *\n   * @param scope The current scope.\n   * @param left The left-hand side of the assign expression.\n   * @param leftType The type of the left-hand side of the assignment.\n   * @param resultType The type of the right-hand side of the assignment.\n   */\n  private void inferAssignment(\n      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n    if (leftType == null) {\n      // This can happen with\n      // var x;\n      // x = [1,2,3];\n      // See testInferAssignment5.\n      left.setJSType(resultType);\n      return;\n    }\n    switch (left.getType()) {\n      case Token.NAME:\n        String varName = left.getString();\n        Var var = syntacticScope.getVar(varName);\n        boolean isVarDeclaration = left.hasChildren();\n        boolean isVarTypeBetter =\n            !isVarDeclaration || var == null || var.isTypeInferred();\n        if (isVarTypeBetter) {\n          redeclareSimpleVar(scope, left, resultType);\n        } else {\n          JSType oldType = var.getType();\n          if (oldType == null && resultType != null) {\n            var.setType(resultType);\n          } else if (oldType != null && resultType != null) {\n            var.setType(oldType.getLeastSupertype(resultType));\n          }\n        }\n        left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n        break;\n      case Token.GETPROP:\n        String qualifiedName = left.getQualifiedName();\n        if (qualifiedName != null) {\n          scope.inferQualifiedSlot(left, qualifiedName,\n              leftType == null ? unknownType : leftType, resultType);\n        }\n        left.setJSType(resultType);\n        ensurePropertyDefined(left, resultType);\n        break;\n      case Token.GETELEM:\n        if (leftType == null) {\n          left.setJSType(resultType);\n        } else {\n          JSType arrayBaseType = ArrayType.getArrayElementType(resultType);\n          if (arrayBaseType != null) {\n            left.getFirstChild().setJSType(leftType.restrictByNotNullOrUndefined());\n            left.getLastChild().setJSType(checkNotNull(arrayBaseType));\n          }\n          // If an array element is assigned null or undefined, the array loses its element type.\n          else if (JSType.NULL_OR_VOID.contains(resultType)) {\n            left.getFirstChild().setJSType(leftType.restrictByNotNullOrUndefined());\n            left.getLastChild().setJSType(stringType);\n          } else {\n            left.setJSType(resultType);\n          }\n        }\n        break;\n      case Token.OR:\n      case Token.AND:\n        if (leftType != null) {\n          left.setJSType(leftType);\n        }\n        break;\n      case Token.HOOK:\n        if (leftType != null) {\n          left.setJSType(leftType);\n        }\n        Node trueNode = left.getLastChild().getNext();\n        Node falseNode = trueNode.getNext();\n        JSType trueType = getJSType(trueNode);\n        JSType falseType = getJSType(falseNode);\n        JSType result = null;\n        if (trueType != null && falseType != null) {\n          result = JSType.join(trueType, falseType);\n        }\n        left.getLastChild().setJSType(booleanType);\n        if (result != null) {\n          left.setJSType(result);\n        }\n        break;\n      case Token.TEMPLATELIT:\n        if (leftType == null) {\n          left.setJSType(resultType);\n        } else {\n          left.setJSType(leftType.restrictByNotNullOrUndefined());\n        }\n        break;\n      default:\n        left.setJSType(resultType);\n        break;\n    }\n  }\n\n  /**\n   * Defines a property if the property has not been defined yet.\n   */\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(\n        nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor =\n        obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor();\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else {\n      if (nodeType.isStructuralType() && !objectType.hasProperty(propName)) {\n        // In general, we don't want to define a property on a struct object,\n        // b/c TypeCheck will later check for improper property creation on\n        // structs. There are two exceptions.\n        // 1) If it's a property created inside the constructor, on the newly\n        //    created instance, allow it.\n        // 2) If it's a prototype property, allow it. For example:\n        //    Foo.prototype.bar = baz;\n        //    where Foo.prototype is a struct and the assignment happens at the\n        //    top level and the constructor Foo is defined in the same file.\n        boolean staticPropCreation = false;\n        Node maybeAssignStm = getprop.getParent().getParent();\n        if (syntacticScope.isGlobal() &&\n            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n          String propCreationFilename = maybeAssignStm.getSourceFileName();\n          Node ctor = objectType.getOwnerFunction().getSource();\n          if (ctor != null &&\n              ctor.getSourceFileName().equals(propCreationFilename)) {\n            staticPropCreation = true;\n          }\n        }\n        if (!propCreationInConstructor && !staticPropCreation) {\n          return; // Early return to avoid creating the property below.\n        }\n      }\n      // Issue 1056: Upgrade object type to declared type if it exists and is appropriate to ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..830cd305 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,66 +521,103 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n+/**\n+   * Determines the type of an assignment operation.\n+   *\n+   * @param scope The current scope.\n+   * @param left The left-hand side of the assign expression.\n+   * @param leftType The type of the left-hand side of the assignment.\n+   * @param resultType The type of the right-hand side of the assignment.\n+   */\n+  private void inferAssignment(\n       FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n+    if (leftType == null) {\n+      // This can happen with\n+      // var x;\n+      // x = [1,2,3];\n+      // See testInferAssignment5.\n+      left.setJSType(resultType);\n+      return;\n+    }\n     switch (left.getType()) {\n       case Token.NAME:\n         String varName = left.getString();\n         Var var = syntacticScope.getVar(varName);\n         boolean isVarDeclaration = left.hasChildren();\n-\n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n-\n-\n+        boolean isVarTypeBetter =\n+            !isVarDeclaration || var == null || var.isTypeInferred();\n         if (isVarTypeBetter) {\n           redeclareSimpleVar(scope, left, resultType);\n-        }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n-\n-        if (var != null && var.isTypeInferred()) {\n+        } else {\n           JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n+          if (oldType == null && resultType != null) {\n+            var.setType(resultType);\n+          } else if (oldType != null && resultType != null) {\n+            var.setType(oldType.getLeastSupertype(resultType));\n+          }\n         }\n+        left.setJSType(isVarDeclaration || leftType == null ? resultType : null);\n         break;\n       case Token.GETPROP:\n         String qualifiedName = left.getQualifiedName();\n         if (qualifiedName != null) {\n           scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n+              leftType == null ? unknownType : leftType, resultType);\n         }\n-\n         left.setJSType(resultType);\n         ensurePropertyDefined(left, resultType);\n         break;\n+      case Token.GETELEM:\n+        if (leftType == null) {\n+          left.setJSType(resultType);\n+        } else {\n+          JSType arrayBaseType = ArrayType.getArrayElementType(resultType);\n+          if (arrayBaseType != null) {\n+            left.getFirstChild().setJSType(leftType.restrictByNotNullOrUndefined());\n+            left.getLastChild().setJSType(checkNotNull(arrayBaseType));\n+          }\n+          // If an array element is assigned null or undefined, the array loses its element type.\n+          else if (JSType.NULL_OR_VOID.contains(resultType)) {\n+            left.getFirstChild().setJSType(leftType.restrictByNotNullOrUndefined());\n+            left.getLastChild().setJSType(stringType);\n+          } else {\n+            left.setJSType(resultType);\n+          }\n+        }\n+        break;\n+      case Token.OR:\n+      case Token.AND:\n+        if (leftType != null) {\n+          left.setJSType(leftType);\n+        }\n+        break;\n+      case Token.HOOK:\n+        if (leftType != null) {\n+          left.setJSType(leftType);\n+        }\n+        Node trueNode = left.getLastChild().getNext();\n+        Node falseNode = trueNode.getNext();\n+        JSType trueType = getJSType(trueNode);\n+        JSType falseType = getJSType(falseNode);\n+        JSType result = null;\n+        if (trueType != null && falseType != null) {\n+          result = JSType.join(trueType, falseType);\n+        }\n+        left.getLastChild().setJSType(booleanType);\n+        if (result != null) {\n+          left.setJSType(result);\n+        }\n+        break;\n+      case Token.TEMPLATELIT:\n+        if (leftType == null) {\n+          left.setJSType(resultType);\n+        } else {\n+          left.setJSType(leftType.restrictByNotNullOrUndefined());\n+        }\n+        break;\n+      default:\n+        left.setJSType(resultType);\n+        break;\n     }\n   }\n \n@@ -593,13 +630,12 @@ class TypeInference\n     JSType nodeType = getJSType(obj);\n     ObjectType objectType = ObjectType.cast(\n         nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n-        getJSType(syntacticScope.getRootNode()).isConstructor();\n-\n+    boolean propCreationInConstructor =\n+        obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor();\n     if (objectType == null) {\n       registry.registerPropertyOnType(propName, nodeType);\n     } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n+      if (nodeType.isStructuralType() && !objectType.hasProperty(propName)) {\n         // In general, we don't want to define a property on a struct object,\n         // b/c TypeCheck will later check for improper property creation on\n         // structs. There are two exceptions.\n@@ -624,6 +660,7 @@ class TypeInference\n           return; // Early return to avoid creating the property below.\n         }\n       }\n+      // Issue 1056: Upgrade object type to declared type if it exists and is appropriate to \n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}