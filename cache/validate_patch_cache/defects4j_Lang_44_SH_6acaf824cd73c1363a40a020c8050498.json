{
    "patch": "public static Number createNumber(String val) throws NumberFormatException {\n    if (val == null) {\n        return null;\n    }\n    if (val.length() == 0) {\n        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n    }\n    if (val.charAt(0) == '+' || val.charAt(0) == '-') {\n        if (val.length() == 1) {\n            throw new NumberFormatException(val + \" is not a valid number.\");\n        }\n        if (val.charAt(1) == '+' || val.charAt(1) == '-') {\n            return null; // protection for poorness in java.math.BigDecimal.\n        }\n        try {\n            Long.parseLong(val);\n        } catch (NumberFormatException nfe) {\n            try {\n                Double.parseDouble(val);\n            } catch (NumberFormatException e) {\n                // empty catch\n            }\n        }\n        // All the other numeric types will fit into the Long range except for BigInteger\n        // Check this one separately\n        try {\n            return new BigInteger(val);\n        } catch (NumberFormatException e) {\n            // empty catch\n        }\n        // Original implementation\n        if (val.startsWith(\"--\")) {\n            // this is protection for poorness in java.lang.BigDecimal.\n            // it accepts this as a legal value, but it does not appear\n            // to be in specification of class. OS X Java parses it to\n            // a wrong value.\n            return null;\n        }\n    } else {\n        char lastChar = val.charAt(val.length() - 1);\n        int decPos = val.indexOf('.');\n        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n\n        if (decPos > -1) {\n            if (expPos > -1) {\n                if (expPos < decPos) {\n                    throw new NumberFormatException(val + \" is not a valid number.\");\n                }\n            }\n            return Double.parseDouble(val);\n        }\n\n        if (expPos > -1) {\n            if (expPos == 1) {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n            try {\n                return Float.parseFloat(val);\n            } catch (NumberFormatException nfe) {\n                return Double.parseDouble(val);\n            }\n        }\n\n        if (lastChar == 'f' || lastChar == 'F') {\n            try {\n                return Float.parseFloat(val);\n            } catch (NumberFormatException e) {\n                // empty catch\n            }\n        }\n        try {\n            return Integer.decode(val);\n        } catch (NumberFormatException e) {\n            // empty catch\n        }\n        try {\n            return Long.decode(val);\n        } catch (NumberFormatException e) {\n            // empty catch\n        }\n        try {\n            return new BigInteger(val);\n        } catch (NumberFormatException e) {\n            // empty catch\n        }\n    }\n    throw new NumberFormatException(val + \" is not a valid number.\");\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex 18a05efe..99ef1fab 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -142,6 +142,94 @@ public final class NumberUtils {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n+public static Number createNumber(String val) throws NumberFormatException {\n+    if (val == null) {\n+        return null;\n+    }\n+    if (val.length() == 0) {\n+        throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+    }\n+    if (val.charAt(0) == '+' || val.charAt(0) == '-') {\n+        if (val.length() == 1) {\n+            throw new NumberFormatException(val + \" is not a valid number.\");\n+        }\n+        if (val.charAt(1) == '+' || val.charAt(1) == '-') {\n+            return null; // protection for poorness in java.math.BigDecimal.\n+        }\n+        try {\n+            Long.parseLong(val);\n+        } catch (NumberFormatException nfe) {\n+            try {\n+                Double.parseDouble(val);\n+            } catch (NumberFormatException e) {\n+                // empty catch\n+            }\n+        }\n+        // All the other numeric types will fit into the Long range except for BigInteger\n+        // Check this one separately\n+        try {\n+            return new BigInteger(val);\n+        } catch (NumberFormatException e) {\n+            // empty catch\n+        }\n+        // Original implementation\n+        if (val.startsWith(\"--\")) {\n+            // this is protection for poorness in java.lang.BigDecimal.\n+            // it accepts this as a legal value, but it does not appear\n+            // to be in specification of class. OS X Java parses it to\n+            // a wrong value.\n+            return null;\n+        }\n+    } else {\n+        char lastChar = val.charAt(val.length() - 1);\n+        int decPos = val.indexOf('.');\n+        int expPos = val.indexOf('e') + val.indexOf('E') + 1;\n+\n+        if (decPos > -1) {\n+            if (expPos > -1) {\n+                if (expPos < decPos) {\n+                    throw new NumberFormatException(val + \" is not a valid number.\");\n+                }\n+            }\n+            return Double.parseDouble(val);\n+        }\n+\n+        if (expPos > -1) {\n+            if (expPos == 1) {\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+            }\n+            try {\n+                return Float.parseFloat(val);\n+            } catch (NumberFormatException nfe) {\n+                return Double.parseDouble(val);\n+            }\n+        }\n+\n+        if (lastChar == 'f' || lastChar == 'F') {\n+            try {\n+                return Float.parseFloat(val);\n+            } catch (NumberFormatException e) {\n+                // empty catch\n+            }\n+        }\n+        try {\n+            return Integer.decode(val);\n+        } catch (NumberFormatException e) {\n+            // empty catch\n+        }\n+        try {\n+            return Long.decode(val);\n+        } catch (NumberFormatException e) {\n+            // empty catch\n+        }\n+        try {\n+            return new BigInteger(val);\n+        } catch (NumberFormatException e) {\n+            // empty catch\n+        }\n+    }\n+    throw new NumberFormatException(val + \" is not a valid number.\");\n+}\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}