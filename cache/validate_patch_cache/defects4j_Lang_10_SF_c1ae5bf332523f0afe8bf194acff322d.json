{
    "patch": "public class TestDateUtils extends junit.framework.TestCase {\n\n    private static final String FMT_DATE = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n    private static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\");\n    private static final String[] PATTERNS = { FMT_DATE, \"MMM dd, yyyy hh:mm:ss a\",\n                                               \"EEE MMM dd HH:mm:ss zzz yyyy\",\n                                               \"yyyy-MM-dd'T'HH:mm:ss'Z'\",\n                                               \"yyyy-MM-dd'T'HH:mm:ssZ\" };\n    private static final String DATE_1_STRING = \"2014-06-14T10:30:00.000Z\";\n    private static final String DATE_2_STRING = \"2014-06-15T10:30:00.000Z\";\n    private static final String DATE_3_STRING = \"2014-06-16T10:30:00.000Z\";\n    private static final String[] DATE_PATTERNS = { FMT_DATE, \"yyyy-MM-dd'T'HH:mm:ssZ\" };\n    private static final Date DATE_1 = new Date(1402717800000L);\n    private static final Date DATE_2 = new Date(1402804200000L);\n    private static final Date DATE_3 = new Date(1402890600000L);\n    private static final String DATE_RANGE_STRING = \"[\" + DATE_1_STRING + \" TO \" + DATE_3_STRING + \"]\";\n\n    public void testLANG_828() {\n        final FastDateFormat dateFormatGmt = FastDateFormat.getInstance(\"yyyy-MMM-dd HH:mm:ss.SSS z\", TimeZone.getTimeZone(\"GMT+0\"));\n        assertFalse(dateFormatGmt.format(new Date()).contains(\"GMT+\"));\n    }\n\n    public void testLANG_831() {\n        final Date d = DateUtils.parseDate(DATE_1_STRING, PATTERNS);\n        final String ds1 = DateUtils.formatDate(d, FMT_DATE);\n        assertEquals(\"Dates should be equal\", DATE_1_STRING, ds1);\n\n        final Date dlo = DateUtils.truncate(d, Calendar.DAY_OF_MONTH);\n        final String dslo = DateUtils.formatDate(dlo, FMT_DATE);\n        assertEquals(\"Dates should be equal\", \"2014-06-14T00:00:00.000Z\", dslo);\n\n        final Date dhi = DateUtils.addMilliseconds(DateUtils.ceiling(dlo, Calendar.DATE), -1);\n        final String dshi =  DateUtils.formatDate(dhi, FMT_DATE);\n        assertEquals(\"Dates should be equal\", \"2014-06-14T23:59:59.999Z\", dshi);\n\n        final Date dsdf = DateUtils.setDays(d, 1);\n        final Date dfdp = DateUtils.parseDate(ds1, PATTERNS);\n        assertEquals(\"Parsed dates should be equal\", dsdf, dfdp);\n    }\n\n    public void testLANG_909() {\n        final Date dHigh = new Date(1394037010222l);\n        final Date dLow = new Date(dHigh.getTime() - 2000); // 2 seconds earlier\n        assertTrue(DateUtils.getFragmentInMilliseconds(dLow, Calendar.MINUTE) < DateUtils.getFragmentInMilliseconds(dHigh, Calendar.MINUTE));\n    }\n\n    public void testLANG_911() {\n        final Date now = new Date();\n        final Calendar calNow = Calendar.getInstance();\n        calNow.setTime(now);\n\n        final Calendar calTrunc = DateUtils.truncate(calNow, Calendar.DATE);\n        final Calendar calCeil = DateUtils.ceiling(calNow, Calendar.DATE);\n\n        assertTrue(new Date().compareTo(calTrunc.getTime()) >= 0);\n        assertTrue(new Date().compareTo(calCeil.getTime()) >= 0);\n    }\n\n    public void testLANG_976() {\n        // Test formatDate with a date before 01/01/1970.\n        final Calendar cal = Calendar.getInstance();\n        cal.set(50, Calendar.JANUARY, 1, 12, 30, 45);\n\n        // SimpleDateFormat interpretation of 1st January 50AD at 12:30 is EST (-0500)\n        // hence the 17:00:45:000 output below.\n        assertEquals(\"Format produced incorrect format\",\n                     \"01/01/0050 05:00:45.000\", DateUtils.formatDate(cal.getTime(), \"MM/dd/yyyy HH:mm:ss.SSS\", TimeZone.getTimeZone(\"GMT-8\")));\n    }\n\n    public void testLANG_1048_a() throws Exception {\n        try {\n            formatDateUTC(null, DATE_1_STRING);\n            fail(\"NullPointerException expected\");\n        } catch (final NullPointerException ex) {\n            // Expected exception\n        }\n    }\n\n    public void testLANG_1048_b() throws Exception {\n        try {\n            formatDateUTC(FMT_DATE, null);\n            fail(\"NullPointerException expected\");\n        } catch (final NullPointerException ex) {\n            // Expected exception\n        }\n    }\n\n    public void testLANG_1048_c() throws Exception {\n        final String formattedDate = formatDateUTC(FMT_DATE, DATE_1_STRING);\n        assertEquals(\"Invalid formatted date\", \"2014-06-14T10:30:00.000Z\", formattedDate);\n    }\n\n    public void testLANG_1048_d() throws Exception {\n        final String formattedDate = formatDateUTC(FMT_DATE, DATE_RANGE_STRING);\n        assertEquals(\"Invalid formatted date in range\", \"[2014-06-14T10:30:00.000Z TO 2014-06-16T10:30:00.000Z]\", formattedDate);\n    }\n\n    public void testLANG_1192() {\n        // test DateUtils.ceiling with DAY\n        final Calendar cal = Calendar.getInstance();\n        cal.set(Calendar.YEAR, 2015);\n        cal.set(Calendar.MONTH, Calendar.APRIL);\n        cal.set(Calendar.DAY_OF_MONTH, 8);\n        cal.set(Calendar.HOUR_OF_DAY, 9);\n        cal.set(Calendar.MINUTE, 13);\n        cal.set(Calendar.SECOND, 50);\n        cal.set(Calendar.MILLISECOND, 123);\n        Date dateIn = cal.getTime();\n        Date dateOut = DateUtils.ceiling(dateIn, Calendar.DAY_OF_MONTH);\n        cal.setTime(dateOut);\n        assertEquals(0, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(0, cal.get(Calendar.MINUTE));\n        assertEquals(0, cal.get(Calendar.SECOND));\n        assertEquals(0, cal.get(Calendar.MILLISECOND));\n        // test DateUtils.ceiling with MONTH\n        cal.set(Calendar.MONTH, Calendar.APRIL);\n        dateOut = DateUtils.ceiling(dateIn, Calendar.MONTH);\n        cal.setTime(dateOut);\n        assertEquals(Calendar.MAY, cal.get(Calendar.MONTH));\n        assertEquals(1, cal.get(Calendar.DAY_OF_MONTH));\n        assertEquals(0, cal.get(Calendar.HOUR_OF_DAY));\n        assertEquals(0, cal.get(Calendar.MINUTE));\n        assertEquals(0, cal.get(Calendar.SECOND));\n        assertEquals(0, cal.get(Calendar.MILLISECOND));\n        // test DateUtils.c",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex a01159bd..f40131a4 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -300,48 +300,132 @@ public class FastDateParser implements DateParser, Serializable {\n      * @param unquote If true, replace two success quotes ('') with single quote (')\n      * @return The <code>StringBuilder</code>\n      */\n-    private static StringBuilder escapeRegex(StringBuilder regex, String value, boolean unquote) {\n-        boolean wasWhite= false;\n-        for(int i= 0; i<value.length(); ++i) {\n-            char c= value.charAt(i);\n-            if(Character.isWhitespace(c)) {\n-                if(!wasWhite) {\n-                    wasWhite= true;\n-                    regex.append(\"\\\\s*+\");\n-                }\n-                continue;\n-            }\n-            wasWhite= false;\n-            switch(c) {\n-            case '\\'':\n-                if(unquote) {\n-                    if(++i==value.length()) {\n-                        return regex;\n-                    }\n-                    c= value.charAt(i);\n-                }\n-                break;\n-            case '?':\n-            case '[':\n-            case ']':\n-            case '(':\n-            case ')':\n-            case '{':\n-            case '}':\n-            case '\\\\':\n-            case '|':\n-            case '*':\n-            case '+':\n-            case '^':\n-            case '$':\n-            case '.':\n-                regex.append('\\\\');\n-            }\n-            regex.append(c);\n+public class TestDateUtils extends junit.framework.TestCase {\n+\n+    private static final String FMT_DATE = \"yyyy-MM-dd'T'HH:mm:ss.SSSZ\";\n+    private static final TimeZone UTC = TimeZone.getTimeZone(\"UTC\");\n+    private static final String[] PATTERNS = { FMT_DATE, \"MMM dd, yyyy hh:mm:ss a\",\n+                                               \"EEE MMM dd HH:mm:ss zzz yyyy\",\n+                                               \"yyyy-MM-dd'T'HH:mm:ss'Z'\",\n+                                               \"yyyy-MM-dd'T'HH:mm:ssZ\" };\n+    private static final String DATE_1_STRING = \"2014-06-14T10:30:00.000Z\";\n+    private static final String DATE_2_STRING = \"2014-06-15T10:30:00.000Z\";\n+    private static final String DATE_3_STRING = \"2014-06-16T10:30:00.000Z\";\n+    private static final String[] DATE_PATTERNS = { FMT_DATE, \"yyyy-MM-dd'T'HH:mm:ssZ\" };\n+    private static final Date DATE_1 = new Date(1402717800000L);\n+    private static final Date DATE_2 = new Date(1402804200000L);\n+    private static final Date DATE_3 = new Date(1402890600000L);\n+    private static final String DATE_RANGE_STRING = \"[\" + DATE_1_STRING + \" TO \" + DATE_3_STRING + \"]\";\n+\n+    public void testLANG_828() {\n+        final FastDateFormat dateFormatGmt = FastDateFormat.getInstance(\"yyyy-MMM-dd HH:mm:ss.SSS z\", TimeZone.getTimeZone(\"GMT+0\"));\n+        assertFalse(dateFormatGmt.format(new Date()).contains(\"GMT+\"));\n+    }\n+\n+    public void testLANG_831() {\n+        final Date d = DateUtils.parseDate(DATE_1_STRING, PATTERNS);\n+        final String ds1 = DateUtils.formatDate(d, FMT_DATE);\n+        assertEquals(\"Dates should be equal\", DATE_1_STRING, ds1);\n+\n+        final Date dlo = DateUtils.truncate(d, Calendar.DAY_OF_MONTH);\n+        final String dslo = DateUtils.formatDate(dlo, FMT_DATE);\n+        assertEquals(\"Dates should be equal\", \"2014-06-14T00:00:00.000Z\", dslo);\n+\n+        final Date dhi = DateUtils.addMilliseconds(DateUtils.ceiling(dlo, Calendar.DATE), -1);\n+        final String dshi =  DateUtils.formatDate(dhi, FMT_DATE);\n+        assertEquals(\"Dates should be equal\", \"2014-06-14T23:59:59.999Z\", dshi);\n+\n+        final Date dsdf = DateUtils.setDays(d, 1);\n+        final Date dfdp = DateUtils.parseDate(ds1, PATTERNS);\n+        assertEquals(\"Parsed dates should be equal\", dsdf, dfdp);\n+    }\n+\n+    public void testLANG_909() {\n+        final Date dHigh = new Date(1394037010222l);\n+        final Date dLow = new Date(dHigh.getTime() - 2000); // 2 seconds earlier\n+        assertTrue(DateUtils.getFragmentInMilliseconds(dLow, Calendar.MINUTE) < DateUtils.getFragmentInMilliseconds(dHigh, Calendar.MINUTE));\n+    }\n+\n+    public void testLANG_911() {\n+        final Date now = new Date();\n+        final Calendar calNow = Calendar.getInstance();\n+        calNow.setTime(now);\n+\n+        final Calendar calTrunc = DateUtils.truncate(calNow, Calendar.DATE);\n+        final Calendar calCeil = DateUtils.ceiling(calNow, Calendar.DATE);\n+\n+        assertTrue(new Date().compareTo(calTrunc.getTime()) >= 0);\n+        assertTrue(new Date().compareTo(calCeil.getTime()) >= 0);\n+    }\n+\n+    public void testLANG_976() {\n+        // Test formatDate with a date before 01/01/1970.\n+        final Calendar cal = Calendar.getInstance();\n+        cal.set(50, Calendar.JANUARY, 1, 12, 30, 45);\n+\n+        // SimpleDateFormat interpretation of 1st January 50AD at 12:30 is EST (-0500)\n+        // hence the 17:00:45:000 output below.\n+        assertEquals(\"Format produced incorrect format\",\n+                     \"01/01/0050 05:00:45.000\", DateUtils.formatDate(cal.getTime(), \"MM/dd/yyyy HH:mm:ss.SSS\", TimeZone.getTimeZone(\"GMT-8\")));\n+    }\n+\n+    public void testLANG_1048_a() throws Exception {\n+        try {\n+            formatDateUTC(null, DATE_1_STRING);\n+            fail(\"NullPointerException expected\");\n+        } catch (final NullPointerException ex) {\n+            // Expected exception\n+        }\n+    }\n+\n+    public void testLANG_1048_b() throws Exception {\n+        try {\n+            formatDateUTC(FMT_DATE, null);\n+            fail(\"NullPointerException expected\");\n+        } catch (final NullPointerException ex) {\n+            // Expected exception\n         }\n-        return regex;\n     }\n \n+    public void testLANG_1048_c() throws Exception {\n+        final String formattedDate = formatDateUTC(FMT_DATE, DATE_1_STRING);\n+        assertEquals(\"Invalid formatted date\", \"2014-06-14T10:30:00.000Z\", formattedDate);\n+    }\n+\n+    public void testLANG_1048_d() throws Exception {\n+        final String formattedDate = formatDateUTC(FMT_DATE, DATE_RANGE_STRING);\n+        assertEquals(\"Invalid formatted date in range\", \"[2014-06-14T10:30:00.000Z TO 2014-06-16T10:30:00.000Z]\", formattedDate);\n+    }\n+\n+    public void testLANG_1192() {\n+        // test DateUtils.ceiling with DAY\n+        final Calendar cal = Calendar.getInstance();\n+        cal.set(Calendar.YEAR, 2015);\n+        cal.set(Calendar.MONTH, Calendar.APRIL);\n+        cal.set(Calendar.DAY_OF_MONTH, 8);\n+        cal.set(Calendar.HOUR_OF_DAY, 9);\n+        cal.set(Calendar.MINUTE, 13);\n+        cal.set(Calendar.SECOND, 50);\n+        cal.set(Calendar.MILLISECOND, 123);\n+        Date dateIn = cal.getTime();\n+        Date dateOut = DateUtils.ceiling(dateIn, Calendar.DAY_OF_MONTH);\n+        cal.setTime(dateOut);\n+        assertEquals(0, cal.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(0, cal.get(Calendar.MINUTE));\n+        assertEquals(0, cal.get(Calendar.SECOND));\n+        assertEquals(0, cal.get(Calendar.MILLISECOND));\n+        // test DateUtils.ceiling with MONTH\n+        cal.set(Calendar.MONTH, Calendar.APRIL);\n+        dateOut = DateUtils.ceiling(dateIn, Calendar.MONTH);\n+        cal.setTime(dateOut);\n+        assertEquals(Calendar.MAY, cal.get(Calendar.MONTH));\n+        assertEquals(1, cal.get(Calendar.DAY_OF_MONTH));\n+        assertEquals(0, cal.get(Calendar.HOUR_OF_DAY));\n+        assertEquals(0, cal.get(Calendar.MINUTE));\n+        assertEquals(0, cal.get(Calendar.SECOND));\n+        assertEquals(0, cal.get(Calendar.MILLISECOND));\n+        // test DateUtils.c\n+\n     /**\n      * A class to store Key / Value pairs\n      */",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}