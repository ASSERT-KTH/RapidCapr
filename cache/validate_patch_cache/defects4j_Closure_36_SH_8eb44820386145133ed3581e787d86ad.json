{
    "patch": "Node callTarget = reference.getNearestFunction();\n          if (callTarget != null && NodeUtil.isFunctionExpression(callTarget)) {\n            callTarget = null;  // Skip function expressions.\n          }\n\n          if (callNode.getChildCount() == 2 && callTarget != null) {\n            Node firstArg = callNode.getSecondChild();\n            if (firstArg.isString()) {\n              String entryName = firstArg.getString();\n              if (entryName != null &&\n                  entryName.equals(\n                      compiler.getCodingConvention().getSingletonGetterClassName(initialization))) {\n                return false;\n              }\n            }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..774e2807 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,21 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+Node callTarget = reference.getNearestFunction();\n+          if (callTarget != null && NodeUtil.isFunctionExpression(callTarget)) {\n+            callTarget = null;  // Skip function expressions.\n+          }\n+\n+          if (callNode.getChildCount() == 2 && callTarget != null) {\n+            Node firstArg = callNode.getSecondChild();\n+            if (firstArg.isString()) {\n+              String entryName = firstArg.getString();\n+              if (entryName != null &&\n+                  entryName.equals(\n+                      compiler.getCodingConvention().getSingletonGetterClassName(initialization))) {\n+                return false;\n+              }\n+            }\n         }\n       }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}