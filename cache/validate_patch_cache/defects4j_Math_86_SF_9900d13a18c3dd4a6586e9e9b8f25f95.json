{
    "patch": "public BandMatrix(final int rows, final int columns, final int lower, final int upper) {\n    super(rows, columns);\n    if (lower > upper) { // check for negative bandwidth\n        throw new IllegalArgumentException(\"lower: \" + lower + \" must not be greater than \" +\n                \"upper: \" + upper);\n    }\n    if (rows < 1 || columns < 1) { // check for inappropriate input dimensions\n        throw new MatrixIndexException(\"Invalid matrix dimensions: \" + rows + \" x \" + columns);\n    }\n    if (2 * lower >= rows) {\n        throw new IllegalArgumentException(\"Illegal BandMatrix dimensions: \" + rows +\n                \" x \" + columns + \", \" + lower + \" has to be smaller than (rows / 2).\");\n    }\n    if (2 * upper >= columns) {\n        throw new IllegalArgumentException(\"Illegal BandMatrix dimensions: \" + rows +\n                \" x \" + columns + \", \" + upper + \" has to be smaller than (columns / 2).\");\n    }\n    diagonalShift = upper;\n    diagonals = new double[diagonalShift + lower + 1][];\n    for (int i = 0; i < diagonals.length; ++i) {\n        final int m = i + lower - diagonalShift;\n        final int s = FastMath.max(0, diagonalShift - i);\n        final int e = FastMath.min(rows + diagonalShift - i - lower, columns);\n        diagonals[i] = new double[e - s];\n        if (m >= 0 && m < rows) { // only setup diagonals that are actually in the matrix\n            if (i >= lower && i <= upper) {\n                // check that main diagonals are ascending\n                if (i != lower && diagonals[i - 1 - lower].length != diagonals[i - lower].length - 1) {\n                    throw new IllegalArgumentException(\"Diagonal size mismatch at i=\" + i);\n                }\n                if (i != upper && diagonals[i - upper + diagonalShift].length != diagonals[i - diagonalShift].length - 1) {\n                    throw new IllegalArgumentException(\"Diagonal size mismatch at i=\" + i);\n                }\n            }\n            final int jA = FastMath.max(0, i - diagonalShift - upper);\n            final int jx = FastMath.max(0, diagonalShift - i - lower);\n            final int jB = e - s - 1;\n            final int jy = columns - 1 - i - diagonalShift - upper;\n            final int cp = jB - jA + 1;\n            if (cp < 1) {\n                throw new IllegalArgumentException(\"Empty diagonal in band matrix.\");\n            }\n            diagonals[i] = new double[cp];\n            MatrixUtils.checkRowIndex(rows, m);\n            MatrixUtils.checkColumnIndex(columns, cp + m - lower - diagonalShift - 1);\n            MatrixUtils.checkRangeIndices(jA + s, jB + s, columns);\n            final int q0 = i - lower + FastMath.max(0, jA - jx);\n            for (int q = 0; q < q0 - i + lower + diagonalShift; q++) {\n                diagonals[i][q] = Double.NaN;\n            }\n            int d = 0;\n            for (int q = FastMath.max(0, jA - jx); q <= FastMath.min(jB - jx, diagonals[i].length - 1); q++) {\n                diagonals[i][q] = elements[d++];\n            }\n            final int q1 = i + upper - FastMath.max(0, jy);\n            for (int q = q1 + 1 - i + lower + diagonalShift; q < diagonals[i].length; q++) {\n                diagonals[i][q] = Double.NaN;\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\nindex acd9222f6..b3a07f343 100644\n--- a/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n+++ b/src/java/org/apache/commons/math/linear/CholeskyDecompositionImpl.java\n@@ -90,65 +90,67 @@ public class CholeskyDecompositionImpl implements CholeskyDecomposition {\n      * @see #DEFAULT_RELATIVE_SYMMETRY_THRESHOLD\n      * @see #DEFAULT_ABSOLUTE_POSITIVITY_THRESHOLD\n      */\n-    public CholeskyDecompositionImpl(final RealMatrix matrix,\n-                                     final double relativeSymmetryThreshold,\n-                                     final double absolutePositivityThreshold)\n-        throws NonSquareMatrixException,\n-               NotSymmetricMatrixException, NotPositiveDefiniteMatrixException {\n-\n-        if (!matrix.isSquare()) {\n-            throw new NonSquareMatrixException(matrix.getRowDimension(),\n-                                               matrix.getColumnDimension());\n-        }\n-\n-        final int order = matrix.getRowDimension();\n-        lTData   = matrix.getData();\n-        cachedL  = null;\n-        cachedLT = null;\n-\n-        // check the matrix before transformation\n-        for (int i = 0; i < order; ++i) {\n-\n-            final double[] lI = lTData[i];\n-\n-            if (lTData[i][i] < absolutePositivityThreshold) {\n-                throw new NotPositiveDefiniteMatrixException();\n-            }\n-            // check off-diagonal elements (and reset them to 0)\n-            for (int j = i + 1; j < order; ++j) {\n-                final double[] lJ = lTData[j];\n-                final double lIJ = lI[j];\n-                final double lJI = lJ[i];\n-                final double maxDelta =\n-                    relativeSymmetryThreshold * Math.max(Math.abs(lIJ), Math.abs(lJI));\n-                if (Math.abs(lIJ - lJI) > maxDelta) {\n-                    throw new NotSymmetricMatrixException();\n+public BandMatrix(final int rows, final int columns, final int lower, final int upper) {\n+    super(rows, columns);\n+    if (lower > upper) { // check for negative bandwidth\n+        throw new IllegalArgumentException(\"lower: \" + lower + \" must not be greater than \" +\n+                \"upper: \" + upper);\n+    }\n+    if (rows < 1 || columns < 1) { // check for inappropriate input dimensions\n+        throw new MatrixIndexException(\"Invalid matrix dimensions: \" + rows + \" x \" + columns);\n+    }\n+    if (2 * lower >= rows) {\n+        throw new IllegalArgumentException(\"Illegal BandMatrix dimensions: \" + rows +\n+                \" x \" + columns + \", \" + lower + \" has to be smaller than (rows / 2).\");\n+    }\n+    if (2 * upper >= columns) {\n+        throw new IllegalArgumentException(\"Illegal BandMatrix dimensions: \" + rows +\n+                \" x \" + columns + \", \" + upper + \" has to be smaller than (columns / 2).\");\n+    }\n+    diagonalShift = upper;\n+    diagonals = new double[diagonalShift + lower + 1][];\n+    for (int i = 0; i < diagonals.length; ++i) {\n+        final int m = i + lower - diagonalShift;\n+        final int s = FastMath.max(0, diagonalShift - i);\n+        final int e = FastMath.min(rows + diagonalShift - i - lower, columns);\n+        diagonals[i] = new double[e - s];\n+        if (m >= 0 && m < rows) { // only setup diagonals that are actually in the matrix\n+            if (i >= lower && i <= upper) {\n+                // check that main diagonals are ascending\n+                if (i != lower && diagonals[i - 1 - lower].length != diagonals[i - lower].length - 1) {\n+                    throw new IllegalArgumentException(\"Diagonal size mismatch at i=\" + i);\n                 }\n-                lJ[i] = 0;\n-           }\n-        }\n-\n-        // transform the matrix\n-        for (int i = 0; i < order; ++i) {\n-\n-            final double[] ltI = lTData[i];\n-\n-            // check diagonal element\n-\n-            ltI[i] = Math.sqrt(ltI[i]);\n-            final double inverse = 1.0 / ltI[i];\n-\n-            for (int q = order - 1; q > i; --q) {\n-                ltI[q] *= inverse;\n-                final double[] ltQ = lTData[q];\n-                for (int p = q; p < order; ++p) {\n-                    ltQ[p] -= ltI[q] * ltI[p];\n+                if (i != upper && diagonals[i - upper + diagonalShift].length != diagonals[i - diagonalShift].length - 1) {\n+                    throw new IllegalArgumentException(\"Diagonal size mismatch at i=\" + i);\n                 }\n             }\n-\n+            final int jA = FastMath.max(0, i - diagonalShift - upper);\n+            final int jx = FastMath.max(0, diagonalShift - i - lower);\n+            final int jB = e - s - 1;\n+            final int jy = columns - 1 - i - diagonalShift - upper;\n+            final int cp = jB - jA + 1;\n+            if (cp < 1) {\n+                throw new IllegalArgumentException(\"Empty diagonal in band matrix.\");\n+            }\n+            diagonals[i] = new double[cp];\n+            MatrixUtils.checkRowIndex(rows, m);\n+            MatrixUtils.checkColumnIndex(columns, cp + m - lower - diagonalShift - 1);\n+            MatrixUtils.checkRangeIndices(jA + s, jB + s, columns);\n+            final int q0 = i - lower + FastMath.max(0, jA - jx);\n+            for (int q = 0; q < q0 - i + lower + diagonalShift; q++) {\n+                diagonals[i][q] = Double.NaN;\n+            }\n+            int d = 0;\n+            for (int q = FastMath.max(0, jA - jx); q <= FastMath.min(jB - jx, diagonals[i].length - 1); q++) {\n+                diagonals[i][q] = elements[d++];\n+            }\n+            final int q1 = i + upper - FastMath.max(0, jy);\n+            for (int q = q1 + 1 - i + lower + diagonalShift; q < diagonals[i].length; q++) {\n+                diagonals[i][q] = Double.NaN;\n+            }\n         }\n-\n     }\n+}\n \n     /** {@inheritDoc} */\n     public RealMatrix getL() {",
    "result_reason": "error: invalid method declaration; return type required",
    "test_result": "ERROR"
}