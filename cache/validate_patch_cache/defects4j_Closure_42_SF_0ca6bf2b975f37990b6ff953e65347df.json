{
    "patch": "class TransformDispatcher implements TypeSafeDispatcher {\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n\n  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n        n.getFirstChild().isString() &&\n        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  @Override\n  public Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  @Override\n  public Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  public Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  public Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  @Override\n  public Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  @Override\n  public Node processEmptyExpression(EmptyExpression exprNode) {\n    Node node = newNode(Token.EMPTY);\n    return node;\n  }\n\n  @Override\n  public Node processExpression(Expression expression) {\n    return transform(expression);\n  }\n\n  @Override\n  public Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(Token.EXPR_RESULT);\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  public Node processForInLoop(ForInLoop loopNode) {\n    AstNode iterator = loopNode.getIterator();\n    AstNode iteratedObject = loopNode.getIteratedObject();\n\n    // Throw an error if for-each loop is detected\n    if (iterator.getType() == Token.LET) {\n      errorReporter.error(\n          \"For-each loops are not supported\",\n          sourceName,\n          loopNode.getLineno(), \"\", 0);\n    }\n\n    return newNode(\n        Token.FOR,\n        transform(iterator),\n        transform(iteratedObject),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processForLoop(ForLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getInitializer()),\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processFunctionCall(FunctionCall callNode) {\n    return newNode(\n        Token.CALL,\n        transform(callNode.getTarget()),\n        transform(callNode.getArguments()));\n  }\n\n  @Override\n  public Node processFunctionNode(FunctionNode functionNode) {\n    return IRFactory.createFunction(functionNode);\n  }\n\n  @Override\n  public Node processIfStatement(IfStatement statementNode) {\n    Node node = newNode(Token.IF);\n    node.addChildToBack(transform(statementNode.getCondition()));\n    node.addChildToBack(transformBlock(statementNode.getThenPart()));\n    AstNode elsePart = statementNode.getElsePart();\n    if (elsePart != null) {\n      if (elsePart instanceof Block) {\n        node.addChildToBack(transformBlock((Block) elsePart));\n      } else {\n        node.addChildToBack(newNode(Token.BLOCK, transform(elsePart)));\n      }\n    }\n    return node;\n  }\n\n  @Override\n  public Node processLabeledStatement(LabeledStatement statementNode) {\n    Node node = newNode(Token.LABEL);\n    node.addChildToBack(transform(statementNode.getLabel()));\n    node.addChildToBack(transform(statementNode.getStatement()));\n    return node;\n  }\n\n  @Override\n  public Node processLetNode(LetNode statementNode) {\n    return newNode(\n        Token.LET,\n        transform(statementNode.getVariables()),\n        transformBlock(statementNode.getBody()));\n  }\n\n  @Override\n  public Node processName(Name nameNode) {\n    return newNode(Token.NAME, nameNode.getIdentifier());\n  }\n\n  @Override\n  public Node processNewExpression(NewExpression callNode) {\n    Node target = transform(callNode.getTarget());\n    Node arguments = transform(callNode.getArguments());\n    Node node = newNode(Token.NEW);\n    node.addChildToBack(target);\n    if (!arguments.isEmpty()) {\n      node.addChildToBack(arguments);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processNumberLiteral(NumberLiteral literalNode) {\n    return newNode(Token.NUMBER, literalNode.getValue());\n  }\n\n  @Override\n  public Node processObjectLiteral(ObjectLiteral node) {\n    return IRFactory.transformObjectLiteral(node, this);\n  }\n\n  @Override\n  public Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n    return newNode(\n        Token.PARENTHESIZED,\n        transform(exprNode.getExpression()));\n  }\n\n  @Override\n  public Node processPropertyGet(PropertyGet getNode) {\n    return newNode(\n        Token.GETPROP,\n        transform(getNode.getTarget()),\n        newNode(Token.STRING, getNode.getProperty().getIdentifier()));\n  }\n\n  @Override\n  public Node processRegExpLiteral(RegExpLiteral literalNode) {\n    return newNode(Token.REGEXP, literalNode.getValue());\n  }\n\n  @Override\n  public Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = newNode(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      node.addChildToBack(transform(statementNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processStringLiteral(StringLiteral literalNode) {\n    String value = literalNode.getValue();\n    // We want to reuse the JS parsing logic for string literals.\n    // Stripping the string of quote characters accomplishes this\n    // while preserving the original value of the string.\n    value = value.substring(1, value.length() - 1);\n    return newNode(Token.STRING, value);\n  }\n\n  @Override\n  public Node processSwitchCase(SwitchCase switchCaseNode) {\n    Node node = null;\n    if (switchCaseNode.getExpression() == null) {\n      node = newNode(Token.DEFAULT);\n    } else {\n      node = newNode(Token.CASE, transform(switchCaseNode.getExpression()));\n    }\n    node.addChildToBack(transformBlock(switchCaseNode.getStatements()));\n    return node;\n  }\n\n  @Override\n  public Node processSwitchStatement(SwitchStatement statementNode) {\n    Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n    node.addChildrenToFront(transformArrayLiteral(statementNode.getCases()));\n    return node;\n  }\n\n  @Override\n  public Node processThrowStatement(ThrowStatement statementNode) {\n    Node node = newNode(Token.THROW, transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  public Node processTryCatchFinally(TryCatchFinally statementNode) {\n    Node node = newNode(Token.TRY);\n    node.addChildToBack(transformBlock(statementNode.getTryBlock()));\n    if (statementNode.getCatchClauses() != null) {\n      node.addChildrenToFront(transformArrayLiteral(statementNode.getCatchClauses()));\n    }\n    if (statementNode.getFinallyBlock() != null) {\n      // Transform the finally block to a try-catch statement with an empty catch clause\n      Node catchNode = newNode(Token.CATCH);\n      catchNode.addChildToBack(newNode(Token.NAME, \"\"));\n      catchNode.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n      node.addChildrenToFront(newNode(Token.CATCH, catchNode));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processUnaryExpression(UnaryExpression exprNode) {\n    return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n  }\n\n  @Override\n  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n    return newNode(\n        Token.VAR,\n        transform(declarationNode.getVariables()));\n  }\n\n  @Override\n  public Node processVariableInitializer(VariableInitializer initializerNode) {\n    Node node = newNode(Token.NAME, initializerNode.getTarget().getIdentifier());\n    AstNode value = initializerNode.getInitializer();\n    if (value != null) {\n      node.addChildToBack(transform(value));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processWhileLoop(WhileLoop loopNode) {\n    return newNode(\n        Token.WHILE,\n        transform(loopNode.getCondition()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processWithStatement(WithStatement statementNode) {\n    errorReporter.error(\n        \"'with' statements are not supported\",\n        sourceName,\n        statementNode.getLineno(), \"\", 0);\n    return newNode(Token.EMPTY);\n  }\n\n  private Node processGeneric(AstNode n) {\n    int type = transformTokenType(n.getType());\n    Node result = newNode(type);\n    for (Node cursor = n.getFirstChild(); cursor != null; cursor = cursor.getNext()) {\n      result.addChildToBack(transform(cursor));\n    }\n    return result;\n  }\n\n  private Node transform(AstNode n) {\n    return NodeTransformer.transform(n, this);\n  }\n\n  private Node transformArrayLiteral(ArrayLiteral arrayNode) {\n    return IRFactory.transformArrayLiteral(arrayNode, this);\n  }\n\n  private Node transformBlock(Block blockNode) {\n    return IRFactory.transformBlock(blockNode, this);\n  }\n\n  private Node transform(TokenType type) {\n    return newNode(transformTokenType(type));\n  }\n\n  private int transformTokenType(int tokenType) {\n    switch (tokenType) {\n      case Token.ADD:\n      case Token.ADD_EQ:\n        return Token.ADD;\n      case Token.AND:\n      case Token.AND_EQ:\n        return Token.BITAND;\n      case Token.ASSIGN:\n      case Token.ASSIGN_ADD:\n      case Token.ASSIGN_BITAND:\n      case Token.ASSIGN_BITOR:\n      case Token.ASSIGN_DIV:\n      case Token.ASSIGN_LSH:\n      case Token.ASSIGN_MOD:\n      case Token.ASSIGN_MUL:\n      case Token.ASSIGN_RSH:\n      case Token.ASSIGN_SUB:\n      case Token.ASSIGN_URSH:\n        return Token.ASSIGN;\n      case Token.BITNOT:\n        return Token.BITNOT;\n      case Token.BITOR:\n      case Token.BITOR_EQ:\n        return Token.BITOR;\n      case Token.BREAK:\n        return Token.BREAK;\n      case Token.CALL:\n        return Token.CALL;\n      case Token.CASE:\n        return Token.CASE;\n      case Token.CATCH:\n        return Token.CATCH;\n      case Token.COLON:\n        return Token.COLON;\n      case Token.COMMA:\n        return Token.COMMA;\n      case Token.CONST:\n        return Token.NAME;\n      case Token.CONTINUE:\n        return Token.CONTINUE;\n      case Token.DEBUGGER:\n        return Token.DEBUGGER;\n      case Token.DEFAULT:\n        return Token.DEFAULT;\n      case Token.DELETE:\n        return Token.DELPROP;\n      case Token.DIV:\n      case Token.DIV_EQ:\n        return Token.DIV;\n      case Token.DO:\n        return Token.DO;\n      case Token.DOT:\n        return Token.GETPROP;\n      case Token.EQ:\n      case Token.EQ_EQ:\n      case Token.EQ_EQ_EQ:\n        return Token.EQ;\n      case Token.FALSE:\n        return Token.FALSE;\n      case Token.FINALLY:\n        return Token.FINALLY;\n      case Token.FOR:\n        return Token.FOR;\n      case Token.FUNCTION:\n        return Token.FUNCTION;\n      case Token.GE:\n        return Token.GE;\n      case Token.GETELEM:\n        return Token.GETELEM;\n      case Token.GETPROP:\n        return Token.GETPROP;\n      case Token.GT:\n        return Token.GT;\n      case Token.HOOK:\n        return Token.HOOK;\n      case Token.IF:\n        return Token.IF;\n      case Token.IN:\n        return Token.IN;\n      case Token.INSTANCEOF:\n        return Token.INSTANCEOF;\n      case Token.LABEL:\n        return Token.LABEL;\n      case Token.LB:\n        return Token.LB;\n      case Token.LE:\n        return Token.LE;\n      case Token.LET:\n        return Token.VAR;\n      case Token.LSH:\n      case Token.LSH_EQ:\n        return Token.LSH;\n      case Token.LT:\n        return Token.LT;\n      case Token.MOD:\n      case Token.MOD_EQ:\n        return Token.MOD;\n      case Token.MUL:\n      case Token.MUL_EQ:\n        return Token.MUL;\n      case Token.NAME:\n        return Token.NAME;\n      case Token.NEG:\n        return Token.NEG;\n      case Token.NEW:\n        return Token.NEW;\n      case Token.NE:\n      case Token.NE_NE:\n      case Token.NE_STRICT:\n        return Token.NE;\n      case Token.NOT:\n      case Token.NOT_EQ:\n      case Token.NOT_EQ_EQ:\n        return Token.NOT;\n      case Token.NULL:\n        return Token.NULL;\n      case Token.NUMBER:",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..8871d6d5 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,475 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher implements TypeSafeDispatcher {\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n+\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+        n.getFirstChild().isString() &&\n+        ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  @Override\n+  public Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  @Override\n+  public Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  @Override\n+  public Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  @Override\n+  public Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  public Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  @Override\n+  public Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  public Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  public Node processEmptyExpression(EmptyExpression exprNode) {\n+    Node node = newNode(Token.EMPTY);\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processExpression(Expression expression) {\n+    return transform(expression);\n+  }\n+\n+  @Override\n+  public Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(Token.EXPR_RESULT);\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processForInLoop(ForInLoop loopNode) {\n+    AstNode iterator = loopNode.getIterator();\n+    AstNode iteratedObject = loopNode.getIteratedObject();\n+\n+    // Throw an error if for-each loop is detected\n+    if (iterator.getType() == Token.LET) {\n+      errorReporter.error(\n+          \"For-each loops are not supported\",\n+          sourceName,\n+          loopNode.getLineno(), \"\", 0);\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    return newNode(\n+        Token.FOR,\n+        transform(iterator),\n+        transform(iteratedObject),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processForLoop(ForLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getInitializer()),\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processFunctionCall(FunctionCall callNode) {\n+    return newNode(\n+        Token.CALL,\n+        transform(callNode.getTarget()),\n+        transform(callNode.getArguments()));\n+  }\n+\n+  @Override\n+  public Node processFunctionNode(FunctionNode functionNode) {\n+    return IRFactory.createFunction(functionNode);\n+  }\n+\n+  @Override\n+  public Node processIfStatement(IfStatement statementNode) {\n+    Node node = newNode(Token.IF);\n+    node.addChildToBack(transform(statementNode.getCondition()));\n+    node.addChildToBack(transformBlock(statementNode.getThenPart()));\n+    AstNode elsePart = statementNode.getElsePart();\n+    if (elsePart != null) {\n+      if (elsePart instanceof Block) {\n+        node.addChildToBack(transformBlock((Block) elsePart));\n+      } else {\n+        node.addChildToBack(newNode(Token.BLOCK, transform(elsePart)));\n       }\n-      return node;\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  @Override\n+  public Node processLabeledStatement(LabeledStatement statementNode) {\n+    Node node = newNode(Token.LABEL);\n+    node.addChildToBack(transform(statementNode.getLabel()));\n+    node.addChildToBack(transform(statementNode.getStatement()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processLetNode(LetNode statementNode) {\n+    return newNode(\n+        Token.LET,\n+        transform(statementNode.getVariables()),\n+        transformBlock(statementNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processName(Name nameNode) {\n+    return newNode(Token.NAME, nameNode.getIdentifier());\n+  }\n+\n+  @Override\n+  public Node processNewExpression(NewExpression callNode) {\n+    Node target = transform(callNode.getTarget());\n+    Node arguments = transform(callNode.getArguments());\n+    Node node = newNode(Token.NEW);\n+    node.addChildToBack(target);\n+    if (!arguments.isEmpty()) {\n+      node.addChildToBack(arguments);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  public Node processNumberLiteral(NumberLiteral literalNode) {\n+    return newNode(Token.NUMBER, literalNode.getValue());\n+  }\n+\n+  @Override\n+  public Node processObjectLiteral(ObjectLiteral node) {\n+    return IRFactory.transformObjectLiteral(node, this);\n+  }\n+\n+  @Override\n+  public Node processParenthesizedExpression(ParenthesizedExpression exprNode) {\n+    return newNode(\n+        Token.PARENTHESIZED,\n+        transform(exprNode.getExpression()));\n+  }\n+\n+  @Override\n+  public Node processPropertyGet(PropertyGet getNode) {\n+    return newNode(\n+        Token.GETPROP,\n+        transform(getNode.getTarget()),\n+        newNode(Token.STRING, getNode.getProperty().getIdentifier()));\n+  }\n+\n+  @Override\n+  public Node processRegExpLiteral(RegExpLiteral literalNode) {\n+    return newNode(Token.REGEXP, literalNode.getValue());\n+  }\n+\n+  @Override\n+  public Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(statementNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node processStringLiteral(StringLiteral literalNode) {\n+    String value = literalNode.getValue();\n+    // We want to reuse the JS parsing logic for string literals.\n+    // Stripping the string of quote characters accomplishes this\n+    // while preserving the original value of the string.\n+    value = value.substring(1, value.length() - 1);\n+    return newNode(Token.STRING, value);\n+  }\n+\n+  @Override\n+  public Node processSwitchCase(SwitchCase switchCaseNode) {\n+    Node node = null;\n+    if (switchCaseNode.getExpression() == null) {\n+      node = newNode(Token.DEFAULT);\n+    } else {\n+      node = newNode(Token.CASE, transform(switchCaseNode.getExpression()));\n     }\n+    node.addChildToBack(transformBlock(switchCaseNode.getStatements()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  public Node processSwitchStatement(SwitchStatement statementNode) {\n+    Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+    node.addChildrenToFront(transformArrayLiteral(statementNode.getCases()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processThrowStatement(ThrowStatement statementNode) {\n+    Node node = newNode(Token.THROW, transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processTryCatchFinally(TryCatchFinally statementNode) {\n+    Node node = newNode(Token.TRY);\n+    node.addChildToBack(transformBlock(statementNode.getTryBlock()));\n+    if (statementNode.getCatchClauses() != null) {\n+      node.addChildrenToFront(transformArrayLiteral(statementNode.getCatchClauses()));\n+    }\n+    if (statementNode.getFinallyBlock() != null) {\n+      // Transform the finally block to a try-catch statement with an empty catch clause\n+      Node catchNode = newNode(Token.CATCH);\n+      catchNode.addChildToBack(newNode(Token.NAME, \"\"));\n+      catchNode.addChildToBack(transformBlock(statementNode.getFinallyBlock()));\n+      node.addChildrenToFront(newNode(Token.CATCH, catchNode));\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processUnaryExpression(UnaryExpression exprNode) {\n+    return newNode(transformTokenType(exprNode.getType()), transform(exprNode.getOperand()));\n+  }\n+\n+  @Override\n+  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n+    return newNode(\n+        Token.VAR,\n+        transform(declarationNode.getVariables()));\n+  }\n+\n+  @Override\n+  public Node processVariableInitializer(VariableInitializer initializerNode) {\n+    Node node = newNode(Token.NAME, initializerNode.getTarget().getIdentifier());\n+    AstNode value = initializerNode.getInitializer();\n+    if (value != null) {\n+      node.addChildToBack(transform(value));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  public Node processWhileLoop(WhileLoop loopNode) {\n+    return newNode(\n+        Token.WHILE,\n+        transform(loopNode.getCondition()),\n+        transformBlock(loopNode.getBody()));\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  public Node processWithStatement(WithStatement statementNode) {\n+    errorReporter.error(\n+        \"'with' statements are not supported\",\n+        sourceName,\n+        statementNode.getLineno(), \"\", 0);\n+    return newNode(Token.EMPTY);\n+  }\n+\n+  private Node processGeneric(AstNode n) {\n+    int type = transformTokenType(n.getType());\n+    Node result = newNode(type);\n+    for (Node cursor = n.getFirstChild(); cursor != null; cursor = cursor.getNext()) {\n+      result.addChildToBack(transform(cursor));\n     }\n+    return result;\n+  }\n+\n+  private Node transform(AstNode n) {\n+    return NodeTransformer.transform(n, this);\n+  }\n+\n+  private Node transformArrayLiteral(ArrayLiteral arrayNode) {\n+    return IRFactory.transformArrayLiteral(arrayNode, this);\n+  }\n+\n+  private Node transformBlock(Block blockNode) {\n+    return IRFactory.transformBlock(blockNode, this);\n+  }\n+\n+  private Node transform(TokenType type) {\n+    return newNode(transformTokenType(type));\n+  }\n+\n+  private int transformTokenType(int tokenType) {\n+    switch (tokenType) {\n+      case Token.ADD:\n+      case Token.ADD_EQ:\n+        return Token.ADD;\n+      case Token.AND:\n+      case Token.AND_EQ:\n+        return Token.BITAND;\n+      case Token.ASSIGN:\n+      case Token.ASSIGN_ADD:\n+      case Token.ASSIGN_BITAND:\n+      case Token.ASSIGN_BITOR:\n+      case Token.ASSIGN_DIV:\n+      case Token.ASSIGN_LSH:\n+      case Token.ASSIGN_MOD:\n+      case Token.ASSIGN_MUL:\n+      case Token.ASSIGN_RSH:\n+      case Token.ASSIGN_SUB:\n+      case Token.ASSIGN_URSH:\n+        return Token.ASSIGN;\n+      case Token.BITNOT:\n+        return Token.BITNOT;\n+      case Token.BITOR:\n+      case Token.BITOR_EQ:\n+        return Token.BITOR;\n+      case Token.BREAK:\n+        return Token.BREAK;\n+      case Token.CALL:\n+        return Token.CALL;\n+      case Token.CASE:\n+        return Token.CASE;\n+      case Token.CATCH:\n+        return Token.CATCH;\n+      case Token.COLON:\n+        return Token.COLON;\n+      case Token.COMMA:\n+        return Token.COMMA;\n+      case Token.CONST:\n+        return Token.NAME;\n+      case Token.CONTINUE:\n+        return Token.CONTINUE;\n+      case Token.DEBUGGER:\n+        return Token.DEBUGGER;\n+      case Token.DEFAULT:\n+        return Token.DEFAULT;\n+      case Token.DELETE:\n+        return Token.DELPROP;\n+      case Token.DIV:\n+      case Token.DIV_EQ:\n+        return Token.DIV;\n+      case Token.DO:\n+        return Token.DO;\n+      case Token.DOT:\n+        return Token.GETPROP;\n+      case Token.EQ:\n+      case Token.EQ_EQ:\n+      case Token.EQ_EQ_EQ:\n+        return Token.EQ;\n+      case Token.FALSE:\n+        return Token.FALSE;\n+      case Token.FINALLY:\n+        return Token.FINALLY;\n+      case Token.FOR:\n+        return Token.FOR;\n+      case Token.FUNCTION:\n+        return Token.FUNCTION;\n+      case Token.GE:\n+        return Token.GE;\n+      case Token.GETELEM:\n+        return Token.GETELEM;\n+      case Token.GETPROP:\n+        return Token.GETPROP;\n+      case Token.GT:\n+        return Token.GT;\n+      case Token.HOOK:\n+        return Token.HOOK;\n+      case Token.IF:\n+        return Token.IF;\n+      case Token.IN:\n+        return Token.IN;\n+      case Token.INSTANCEOF:\n+        return Token.INSTANCEOF;\n+      case Token.LABEL:\n+        return Token.LABEL;\n+      case Token.LB:\n+        return Token.LB;\n+      case Token.LE:\n+        return Token.LE;\n+      case Token.LET:\n+        return Token.VAR;\n+      case Token.LSH:\n+      case Token.LSH_EQ:\n+        return Token.LSH;\n+      case Token.LT:\n+        return Token.LT;\n+      case Token.MOD:\n+      case Token.MOD_EQ:\n+        return Token.MOD;\n+      case Token.MUL:\n+      case Token.MUL_EQ:\n+        return Token.MUL;\n+      case Token.NAME:\n+        return Token.NAME;\n+      case Token.NEG:\n+        return Token.NEG;\n+      case Token.NEW:\n+        return Token.NEW;\n+      case Token.NE:\n+      case Token.NE_NE:\n+      case Token.NE_STRICT:\n+        return Token.NE;\n+      case Token.NOT:\n+      case Token.NOT_EQ:\n+      case Token.NOT_EQ_EQ:\n+        return Token.NOT;\n+      case Token.NULL:\n+        return Token.NULL;\n+      case Token.NUMBER:\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}