{
    "patch": "private FlowScope traverseNew(Node n, FlowScope scope) {\n    Node constructor = n.getFirstChild();\n\n    JSType constructorType = constructor.getJSType();\n    JSType type = null;\n    if (constructorType != null) {\n        constructorType = constructorType.restrictByNotNullOrUndefined();\n        FunctionType ft = constructorType.toMaybeFunctionType();\n        if (ft != null && ft.isConstructor()) {\n            type = ft.getPrototype();\n\n            // Propagate the type to arguments.\n            for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n                // Infer the type of the arg.\n                scope = traverse(arg, scope);\n                JSType argType = arg.getJSType() == null ? getNativeType(UNKNOWN_TYPE) : arg.getJSType();\n\n                // If the parameter type is optional or varargs, default to the parameter type.\n                int index = arg.getIntProp(Node.ANALYZED_DURING_GTI);\n                if (index != -1) {\n                    Node functionNode = NodeUtil.getEnclosingFunction(n);\n                    FunctionType functionType = functionNode.getJSType() != null\n                            ? functionNode.getJSType().toMaybeFunctionType()\n                            : null;\n                    if (functionType != null) {\n                        boolean isOptionalParameter = index < functionType.getParametersCount()\n                                && functionType.getParameterType(index).isOptionalParameter();\n                        boolean isVarArgsParameter = index < functionType.getParametersCount()\n                                && functionType.getParameterType(index).isVarargs();\n                        if (isOptionalParameter || isVarArgsParameter) {\n                            argType = type.getTemplateTypeMap().getResolvedTemplateType(ft.getTypeParameters()[index]);\n                        }\n                    }\n                }\n\n                // Assign the inferred type.\n                arg.setJSType(argType);\n            }\n        } else {\n            type = getNativeType(UNKNOWN_TYPE);\n        }\n    } else {\n        type = getNativeType(UNKNOWN_TYPE);\n    }\n\n    // Assign the inferred type to the 'new' expression.\n    n.setJSType(type);\n    return scope;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 7e218d88..0fa37a38 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1032,35 +1032,55 @@ class TypeInference\n     }\n   }\n \n-  private FlowScope traverseNew(Node n, FlowScope scope) {\n-\n+private FlowScope traverseNew(Node n, FlowScope scope) {\n     Node constructor = n.getFirstChild();\n-    scope = traverse(constructor, scope);\n+\n     JSType constructorType = constructor.getJSType();\n     JSType type = null;\n     if (constructorType != null) {\n-      constructorType = constructorType.restrictByNotNullOrUndefined();\n-      if (constructorType.isUnknownType()) {\n-        type = getNativeType(UNKNOWN_TYPE);\n-      } else {\n-        FunctionType ct = constructorType.toMaybeFunctionType();\n-        if (ct == null && constructorType instanceof FunctionType) {\n-          // If constructorType is a NoObjectType, then toMaybeFunctionType will\n-          // return null. But NoObjectType implements the FunctionType\n-          // interface, precisely because it can validly construct objects.\n-          ct = (FunctionType) constructorType;\n-        }\n-        if (ct != null && ct.isConstructor()) {\n-          type = ct.getInstanceType();\n+        constructorType = constructorType.restrictByNotNullOrUndefined();\n+        FunctionType ft = constructorType.toMaybeFunctionType();\n+        if (ft != null && ft.isConstructor()) {\n+            type = ft.getPrototype();\n+\n+            // Propagate the type to arguments.\n+            for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n+                // Infer the type of the arg.\n+                scope = traverse(arg, scope);\n+                JSType argType = arg.getJSType() == null ? getNativeType(UNKNOWN_TYPE) : arg.getJSType();\n+\n+                // If the parameter type is optional or varargs, default to the parameter type.\n+                int index = arg.getIntProp(Node.ANALYZED_DURING_GTI);\n+                if (index != -1) {\n+                    Node functionNode = NodeUtil.getEnclosingFunction(n);\n+                    FunctionType functionType = functionNode.getJSType() != null\n+                            ? functionNode.getJSType().toMaybeFunctionType()\n+                            : null;\n+                    if (functionType != null) {\n+                        boolean isOptionalParameter = index < functionType.getParametersCount()\n+                                && functionType.getParameterType(index).isOptionalParameter();\n+                        boolean isVarArgsParameter = index < functionType.getParametersCount()\n+                                && functionType.getParameterType(index).isVarargs();\n+                        if (isOptionalParameter || isVarArgsParameter) {\n+                            argType = type.getTemplateTypeMap().getResolvedTemplateType(ft.getTypeParameters()[index]);\n+                        }\n+                    }\n+                }\n+\n+                // Assign the inferred type.\n+                arg.setJSType(argType);\n+            }\n+        } else {\n+            type = getNativeType(UNKNOWN_TYPE);\n         }\n-      }\n+    } else {\n+        type = getNativeType(UNKNOWN_TYPE);\n     }\n+\n+    // Assign the inferred type to the 'new' expression.\n     n.setJSType(type);\n-    for (Node arg = constructor.getNext(); arg != null; arg = arg.getNext()) {\n-      scope = traverse(arg, scope);\n-    }\n     return scope;\n-  }\n+}\n \n   private BooleanOutcomePair traverseAnd(Node n, FlowScope scope) {\n     return traverseShortCircuitingBinOp(n, scope, true);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}