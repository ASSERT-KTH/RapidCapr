{
    "patch": "public void doEvents(final ODEStateAndDerivative currentState, final boolean isLast)\n    throws MathIllegalStateException {\n\n    // get the time of the current step, and also the minimum step\n    final double t = currentState.getTime();\n    final double h = integrator.getCurrentSignedStepsize();\n\n    // initialize working data\n    final int n = currentState.getState().length;\n    final double[] y = currentState.getState().clone();\n    final double[] yDot = currentState.getDerivative().clone();\n\n    final ODEStateInterpolator interpolator = new ODEStateInterpolator();\n    interpolator.reinitialize(this, currentState);\n\n    // create an empty sorted set for events\n    final TreeSet<EventState> eventsStates = new TreeSet<EventState>(new Comparator<EventState>() {\n        public int compare(EventState es0, EventState es1) {\n            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n        }\n    });\n\n    // initialize all events states for the first step\n    for (final StateEvent stateEvent : stateEventsManager.getEvents()) {\n        stateEvent.reinitializeBegin(currentState);\n        final EventState es = stateEvent.createEventState();\n        eventsStates.add(es);\n    }\n\n    boolean needReset = false;\n    do {\n        // iterate over events, to locate the next one that occurs\n        final ListIterator<EventState> iterator = eventsStates.listIterator();\n        EventState currentStateEvent = null;\n        while ((currentStateEvent == null) && iterator.hasNext()) {\n            final EventState state = iterator.next();\n            state.stepAccepted(currentState.getTime(), currentState.getState());\n            \n            if (state.evaluateStep(interpolator)) {\n                // the event occurs during the current step\n                currentStateEvent = state;\n            } else {\n                // we move this event state to the end of the list\n                // so that future iterations start closer to the event\n                // that is most likely to occur next\n                iterator.remove();\n                iterator.add(state);\n            }\n        }\n\n        if (currentStateEvent != null) {\n            // we've detected an event\n            \n            // we need to use interpolation of the state at the actual event time\n            // rather than simply the state at the end of the step\n            final double exactRootTime = currentStateEvent.getEventTime();\n            interpolator.setSoftCurrentTime(exactRootTime);\n\n            // evaluate the g function at the precise event time\n            final double[] yAtEvent = interpolator.getInterpolatedState().clone();\n            final double[] yDotAtEvent = computeDerivatives(yAtEvent);\n            final double g = currentStateEvent.getEventDetector().g(exactRootTime, yAtEvent, yDotAtEvent);\n            final boolean isIncreasing = currentStateEvent.getEventDetector().isIncreasing();\n\n            if (g >= 0) { // we have a sign change at the event\n                if (isIncreasing) {\n                    currentStateEvent.eventsHandlersManager.handleEvent(currentStateEvent, isLast);\n                } else {\n                    currentStateEvent.eventsHandlersManager.handleEvent(currentStateEvent, isLast);\n                }\n                \n                // update state (stepToEvent)\n                final double dt = exactRootTime - t;\n                if (FastMath.abs(dt) <= 1.0e-12 * FastMath.max(FastMath.abs(t), 1.0)) {\n                    needReset = true;\n                } else {\n                    System.arraycopy(yAtEvent, 0, y, 0, n);\n                    computeDerivatives(y, yDot);\n                    interpolator.reinitialize(new ODEState(exactRootTime, y), new ODEState(y, yDot));\n                }\n\n                // sims time and its associated scale factor are reset after each step,\n                // thus they are reset at this point as well\n                stateEventsManager.stepAccepted(currentStateEvent);\n            } else {\n                // update state (stepToEvent)\n                final double dt = currentStateEvent.getEventTime() - t;\n                if (FastMath.abs(dt) <= 1.0e-12 * FastMath.max(FastMath.abs(t), 1.0)) {\n                    needReset = true;\n                } else {\n                    System.arraycopy(yAtEvent, 0, y, 0, n);\n                    computeDerivatives(y, yDot);\n                    interpolator.reinitialize(new ODEState(exactRootTime, y), new ODEState(y, yDot));\n                }\n\n                stateEventsManager.stepRejected(currentStateEvent, new DerivativeException());\n            }\n        }\n    } while ((needReset = !stateEventsManager.getEvents().isEmpty()) && !isLast);\n\n    // finalize the step\n    for (final EventHandler handler : handlersManager.getHandlers()) {\n        handler.finish(currentState);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..296fc6701 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,44 +313,112 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n+public void doEvents(final ODEStateAndDerivative currentState, final boolean isLast)\n+    throws MathIllegalStateException {\n \n-            });\n+    // get the time of the current step, and also the minimum step\n+    final double t = currentState.getTime();\n+    final double h = integrator.getCurrentSignedStepsize();\n \n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n-                }\n-            }\n+    // initialize working data\n+    final int n = currentState.getState().length;\n+    final double[] y = currentState.getState().clone();\n+    final double[] yDot = currentState.getDerivative().clone();\n \n-            while (!occuringEvents.isEmpty()) {\n+    final ODEStateInterpolator interpolator = new ODEStateInterpolator();\n+    interpolator.reinitialize(this, currentState);\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+    // create an empty sorted set for events\n+    final TreeSet<EventState> eventsStates = new TreeSet<EventState>(new Comparator<EventState>() {\n+        public int compare(EventState es0, EventState es1) {\n+            return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n+        }\n+    });\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+    // initialize all events states for the first step\n+    for (final StateEvent stateEvent : stateEventsManager.getEvents()) {\n+        stateEvent.reinitializeBegin(currentState);\n+        final EventState es = stateEvent.createEventState();\n+        eventsStates.add(es);\n+    }\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+    boolean needReset = false;\n+    do {\n+        // iterate over events, to locate the next one that occurs\n+        final ListIterator<EventState> iterator = eventsStates.listIterator();\n+        EventState currentStateEvent = null;\n+        while ((currentStateEvent == null) && iterator.hasNext()) {\n+            final EventState state = iterator.next();\n+            state.stepAccepted(currentState.getTime(), currentState.getState());\n+            \n+            if (state.evaluateStep(interpolator)) {\n+                // the event occurs during the current step\n+                currentStateEvent = state;\n+            } else {\n+                // we move this event state to the end of the list\n+                // so that future iterations start closer to the event\n+                // that is most likely to occur next\n+                iterator.remove();\n+                iterator.add(state);\n+            }\n+        }\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+        if (currentStateEvent != null) {\n+            // we've detected an event\n+            \n+            // we need to use interpolation of the state at the actual event time\n+            // rather than simply the state at the end of the step\n+            final double exactRootTime = currentStateEvent.getEventTime();\n+            interpolator.setSoftCurrentTime(exactRootTime);\n+\n+            // evaluate the g function at the precise event time\n+            final double[] yAtEvent = interpolator.getInterpolatedState().clone();\n+            final double[] yDotAtEvent = computeDerivatives(yAtEvent);\n+            final double g = currentStateEvent.getEventDetector().g(exactRootTime, yAtEvent, yDotAtEvent);\n+            final boolean isIncreasing = currentStateEvent.getEventDetector().isIncreasing();\n+\n+            if (g >= 0) { // we have a sign change at the event\n+                if (isIncreasing) {\n+                    currentStateEvent.eventsHandlersManager.handleEvent(currentStateEvent, isLast);\n+                } else {\n+                    currentStateEvent.eventsHandlersManager.handleEvent(currentStateEvent, isLast);\n+                }\n+                \n+                // update state (stepToEvent)\n+                final double dt = exactRootTime - t;\n+                if (FastMath.abs(dt) <= 1.0e-12 * FastMath.max(FastMath.abs(t), 1.0)) {\n+                    needReset = true;\n+                } else {\n+                    System.arraycopy(yAtEvent, 0, y, 0, n);\n+                    computeDerivatives(y, yDot);\n+                    interpolator.reinitialize(new ODEState(exactRootTime, y), new ODEState(y, yDot));\n+                }\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n+                // sims time and its associated scale factor are reset after each step,\n+                // thus they are reset at this point as well\n+                stateEventsManager.stepAccepted(currentStateEvent);\n+            } else {\n+                // update state (stepToEvent)\n+                final double dt = currentStateEvent.getEventTime() - t;\n+                if (FastMath.abs(dt) <= 1.0e-12 * FastMath.max(FastMath.abs(t), 1.0)) {\n+                    needReset = true;\n+                } else {\n+                    System.arraycopy(yAtEvent, 0, y, 0, n);\n+                    computeDerivatives(y, yDot);\n+                    interpolator.reinitialize(new ODEState(exactRootTime, y), new ODEState(y, yDot));\n                 }\n \n+                stateEventsManager.stepRejected(currentStateEvent, new DerivativeException());\n+            }\n+        }\n+    } while ((needReset = !stateEventsManager.getEvents().isEmpty()) && !isLast);\n+\n+    // finalize the step\n+    for (final EventHandler handler : handlersManager.getHandlers()) {\n+        handler.finish(currentState);\n+    }\n+}\n+\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}