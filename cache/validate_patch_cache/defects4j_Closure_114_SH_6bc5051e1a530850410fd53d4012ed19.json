{
    "patch": "if (ns != null) {\n  // Check if the parent of the node is a call expression.\n  // If so, do not associate the right-hand side with the dependency scope.\n  // This is because the right-hand side is actually a callee, not a reference.\n  if (!NodeUtil.isParentCall(parent)) {\n    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n      // Patch for assignments that appear in the init,\n      // condition or iteration part of a FOR loop.\n      // ...\n    } else {\n      recordDepScope(recordNode, ns);\n    }\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 0fc5ae8f..c0978610 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -575,7 +575,20 @@ final class NameAnalyzer implements CompilerPass {\n           } else {\n             recordDepScope(nameNode, ns);\n           }\n-        } else {\n+if (ns != null) {\n+  // Check if the parent of the node is a call expression.\n+  // If so, do not associate the right-hand side with the dependency scope.\n+  // This is because the right-hand side is actually a callee, not a reference.\n+  if (!NodeUtil.isParentCall(parent)) {\n+    if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n+      // Patch for assignments that appear in the init,\n+      // condition or iteration part of a FOR loop.\n+      // ...\n+    } else {\n+      recordDepScope(recordNode, ns);\n+    }\n+  }\n+}\n           // The rhs of the assignment is the caller, so it's used by the\n           // context. Don't associate it w/ the lhs.\n           // FYI: this fixes only the specific case where the assignment is the",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}