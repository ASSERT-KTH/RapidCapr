{
    "patch": "if (val == null) {\n    return null;\n}\nif (val.isEmpty()) {\n    throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n}\nchar firstChar = val.charAt(0);\nchar lastChar = val.charAt(val.length() - 1);\n// Checking for negative sign and adding offset\nint offset = (firstChar == '-') ? 1 : 0;\nif (!Character.isDigit(firstChar) && val.length() == 1 + offset) {\n    throw new NumberFormatException(val + \" is not a valid number.\");\n}\nif (!Character.isDigit(lastChar)) {\n    // handling cases like \"123f\"\n    if (val.endsWith(\"f\") || val.endsWith(\"F\")) {\n        try {\n            return Float.parseFloat(val);\n        } catch (NumberFormatException ignored) {\n        }\n    }\n    // handling cases like \"123d\"\n    if (val.endsWith(\"d\") || val.endsWith(\"D\")) {\n        try {\n            return Double.parseDouble(val);\n        } catch (NumberFormatException ignored) {\n        }\n    }\n    // handling cases like \"123L\"\n    if (val.endsWith(\"l\") || val.endsWith(\"L\")) {\n        String numeric = val.substring(offset, val.length() - 1);\n        //Checking that all remaining characters are integers\n        for (char ch : numeric.toCharArray()) {\n            if (ch < '0' || ch > '9') {\n                throw new NumberFormatException(val + \" is not a valid number.\");\n            }\n        }\n        if (numeric.length() <= String.valueOf(Long.MAX_VALUE).length()) {\n            return createLong(numeric);\n        }\n        return createBigInteger(numeric);\n    }\n    // handling cases like \"123.45\" or \"123e5\"\n    String numeric = (lastChar == 'd' || lastChar == 'D' || lastChar == 'f' || lastChar == 'F')\n            ? val.substring(offset, val.length() - 1)\n            : val.substring(offset);\n    if (numeric.indexOf('.') > -1 || numeric.indexOf('e') > -1 || numeric.indexOf('E') > -1) {\n        try {\n            if (numeric.charAt(numeric.length() - 1) == 'f' || numeric.charAt(numeric.length() - 1) == 'F') {\n                return Float.parseFloat(numeric);\n            } else {\n                return Double.parseDouble(numeric);\n            }\n        } catch (NumberFormatException ignored) {\n        }\n        return createBigDecimal(numeric);\n    }\n}\n// parsing integer values like \"123\", \"-123\" etc.\nif (offset > 0 || (firstChar >= '0' && firstChar <= '9')) {\n    try {\n        if (val.length() <= String.valueOf(Integer.MAX_VALUE).length() + offset) {\n            return createInteger(val);\n        }\n        if (val.length() <= String.valueOf(Long.MAX_VALUE).length() + offset) {\n            return createLong(val);\n        }\n        return createBigInteger(val);\n    } catch (NumberFormatException ignored) {\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang/NumberUtils.java b/src/java/org/apache/commons/lang/NumberUtils.java\nindex 18a05efe..503caed1 100644\n--- a/src/java/org/apache/commons/lang/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/NumberUtils.java\n@@ -142,6 +142,77 @@ public final class NumberUtils {\n         if (val.length() == 0) {\n             throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n         }\n+if (val == null) {\n+    return null;\n+}\n+if (val.isEmpty()) {\n+    throw new NumberFormatException(\"\\\"\\\" is not a valid number.\");\n+}\n+char firstChar = val.charAt(0);\n+char lastChar = val.charAt(val.length() - 1);\n+// Checking for negative sign and adding offset\n+int offset = (firstChar == '-') ? 1 : 0;\n+if (!Character.isDigit(firstChar) && val.length() == 1 + offset) {\n+    throw new NumberFormatException(val + \" is not a valid number.\");\n+}\n+if (!Character.isDigit(lastChar)) {\n+    // handling cases like \"123f\"\n+    if (val.endsWith(\"f\") || val.endsWith(\"F\")) {\n+        try {\n+            return Float.parseFloat(val);\n+        } catch (NumberFormatException ignored) {\n+        }\n+    }\n+    // handling cases like \"123d\"\n+    if (val.endsWith(\"d\") || val.endsWith(\"D\")) {\n+        try {\n+            return Double.parseDouble(val);\n+        } catch (NumberFormatException ignored) {\n+        }\n+    }\n+    // handling cases like \"123L\"\n+    if (val.endsWith(\"l\") || val.endsWith(\"L\")) {\n+        String numeric = val.substring(offset, val.length() - 1);\n+        //Checking that all remaining characters are integers\n+        for (char ch : numeric.toCharArray()) {\n+            if (ch < '0' || ch > '9') {\n+                throw new NumberFormatException(val + \" is not a valid number.\");\n+            }\n+        }\n+        if (numeric.length() <= String.valueOf(Long.MAX_VALUE).length()) {\n+            return createLong(numeric);\n+        }\n+        return createBigInteger(numeric);\n+    }\n+    // handling cases like \"123.45\" or \"123e5\"\n+    String numeric = (lastChar == 'd' || lastChar == 'D' || lastChar == 'f' || lastChar == 'F')\n+            ? val.substring(offset, val.length() - 1)\n+            : val.substring(offset);\n+    if (numeric.indexOf('.') > -1 || numeric.indexOf('e') > -1 || numeric.indexOf('E') > -1) {\n+        try {\n+            if (numeric.charAt(numeric.length() - 1) == 'f' || numeric.charAt(numeric.length() - 1) == 'F') {\n+                return Float.parseFloat(numeric);\n+            } else {\n+                return Double.parseDouble(numeric);\n+            }\n+        } catch (NumberFormatException ignored) {\n+        }\n+        return createBigDecimal(numeric);\n+    }\n+}\n+// parsing integer values like \"123\", \"-123\" etc.\n+if (offset > 0 || (firstChar >= '0' && firstChar <= '9')) {\n+    try {\n+        if (val.length() <= String.valueOf(Integer.MAX_VALUE).length() + offset) {\n+            return createInteger(val);\n+        }\n+        if (val.length() <= String.valueOf(Long.MAX_VALUE).length() + offset) {\n+            return createLong(val);\n+        }\n+        return createBigInteger(val);\n+    } catch (NumberFormatException ignored) {\n+    }\n+}\n         if (val.startsWith(\"--\")) {\n             // this is protection for poorness in java.lang.BigDecimal.\n             // it accepts this as a legal value, but it does not appear ",
    "result_reason": "error: for-each loops are not supported in -source 1.3",
    "test_result": "ERROR"
}