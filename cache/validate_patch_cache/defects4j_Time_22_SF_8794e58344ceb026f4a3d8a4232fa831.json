{
    "patch": "public abstract class BasePeriod\n        implements ReadablePeriod, Serializable {\n\n    /** Serialization version */\n    private static final long serialVersionUID = -2110953284060001145L;\n\n    //-----------------------------------------------------------------------\n    /**\n     * Calculates the duration of this period relative to a start instant.\n     *\n     * @param startInstant  the instant to calculate the duration relative to, null means now\n     * @return the duration of the period as an ISO8601 duration string\n     */\n    public String toString(ReadableInstant startInstant) {\n        if (startInstant == null) {\n            return toString();\n        }\n        Duration dur = new Duration(startInstant.getMillis(), getMillis());\n        return dur.toString();\n    }\n\n    /**\n     * Compares this object with the specified object for equality based\n     * on the values of each of the fields. All ReadablePeriod instances are accepted.\n     * <p>\n     * Note that a zero length period (which this class supports) equals a zero length period\n     * in another duration class, such as {@link org.joda.time.Duration}.\n     *\n     * @param readablePeriod  a readable period to check against\n     * @return true if all the field values are equal, false if\n     *  not or if {@code readablePeriod} is null or of an incorrect type\n     */\n    public boolean equals(Object readablePeriod) {\n        if (this == readablePeriod) {\n            return true;\n        }\n        if (readablePeriod instanceof ReadablePeriod == false) {\n            return false;\n        }\n        ReadablePeriod other = (ReadablePeriod) readablePeriod;\n        return (getPeriodType().equals(other.getPeriodType()) && \n                getDurationField().getUnitMillis() == other.getDurationField().getUnitMillis() &&\n                getYears() == other.getYears() &&\n                getMonths() == other.getMonths() &&\n                getWeeks() == other.getWeeks() &&\n                getDays() == other.getDays() &&\n                getHours() == other.getHours() &&\n                getMinutes() == other.getMinutes() &&\n                getSeconds() == other.getSeconds() &&\n                getMillis() == other.getMillis());\n    }\n\n    /**\n     * Gets a hash code for the period that is compatable with the \n     * equals method.\n     *\n     * @return a hash code\n     */\n    public int hashCode() {\n        return (getYears() << 28) + (getMonths() << 24) + \n                (getWeeks() << 20) + (getDays() << 16) +\n                (getHours() << 12) + (getMinutes() << 8) +\n                (getSeconds() << 4) + getMillis();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Gets the years field value.\n     *\n     * @return the number of years in the period\n     */\n    public abstract int getYears();\n\n    /**\n     * Gets the months field value.\n     *\n     * @return the number of months in the period\n     */\n    public abstract int getMonths();\n\n    /**\n     * Gets the weeks field value.\n     *\n     * @return the number of weeks in the period\n     */\n    public abstract int getWeeks();\n\n    /**\n     * Gets the days field value.\n     * Note that one day has a different duration in daylight savings to\n     * one day in standard time. The {@link Days} class represents a standard\n     * 24 hour day.\n     *\n     * @return the number of days in the period\n     */\n    public abstract int getDays();\n\n    //-----------------------------------------------------------------------\n    /**\n     * Is this period zero length.\n     * \n     * @return true if the period is zero length\n     */\n    public boolean isZero() {\n        return (getMillis() == 0 && \n                getSeconds() == 0 &&\n                getMinutes() == 0 &&\n                getHours() == 0 &&\n                getDays() == 0 &&\n                getWeeks() == 0 &&\n                getMonths() == 0 &&\n                getYears() == 0);\n    }\n\n    /**\n     * Is this period a whole number of days, such that the number of hours,\n     * minutes, seconds and millis are all zero.\n     * \n     * @return true if the period is a number of days and has no time elements\n     */\n    public boolean isDays() {\n        return (getMillis() == 0 && \n                getSeconds() == 0 &&\n                getMinutes() == 0 &&\n                getHours() == 0 &&\n                ((getDays() != 0 && getWeeks() == 0 && getMonths() == 0 && getYears() == 0) ||\n                 (getDays() == 0 && getWeeks() != 0 && getMonths() == 0 && getYears() == 0)));\n    }\n\n    /**\n     * Is this period a whole number of months, such that the number of days,\n     * hours, minutes, seconds and millis are all zero.\n     * \n     * @return true if the period is a number of months and has no other fields\n     */\n    public boolean isMonths() {\n        return (getMillis() == 0 && \n                getSeconds() == 0 &&\n                getMinutes() == 0 &&\n                getHours() == 0 &&\n                getDays() == 0 &&\n                ((getYears() != 0 && getMonths() != 0 && getWeeks() == 0) ||\n                 (getYears() == 0 && getMonths() != 0 && getWeeks() != 0)));\n    }\n\n    /**\n     * Gets the total millisecond duration of this period relative to a start instant.\n     *\n     * @param startInstant  the instant to calculate the duration relative to, null means now\n     * @return the total length of the period in milliseconds.\n     */\n    public long toDurationFrom(ReadableInstant startInstant) {\n        return new Interval(startInstant, this).toDurationMillis();\n    }\n\n    /**\n     * Gets the total millisecond duration of this period relative to an \n     * instant at the start of 1970-01-01T00:00:00Z.\n     * <p>\n     * This method performs the same conversion as using an {@link Interval}\n     * constructed with this period and an instant at the start of 1970.\n     *\n     * @return the total length of the period in milliseconds.\n     */\n    public long toDurationMillis() {\n        return new Duration(\n                getYears(), getMonths(), getWeeks(), getDays(),\n                getHours(), getMinutes(), getSeconds(), getMillis()).getMillis();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Adds this period to the specified instant, returning a new instant.\n     *\n     * @param instant  the instant to add to, null means now\n     * @return an instant plus this period.\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public Instant addTo(ReadableInstant instant) {\n        return instant.toInstant().withPeriodAdded(this, 1);\n    }\n\n    /**\n     * Subtracts this period from the specified instant, returning a new instant.\n     *\n     * @param instant  the instant to subtract from, null means now\n     * @return an instant minus this period.\n     * @throws ArithmeticException if the result exceeds the capacity of the instant\n     */\n    public Instant subtractFrom(ReadableInstant instant) {\n        return instant.toInstant().withPeriodAdded(this, -1);\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Normalizes this period using standard rules, assuming a 12 month year.\n     * <p>\n     * This normalizes each field, years/months/weeks/days, in turn. Only\n     * the non-zero fields are processed. First the milliseconds are\n     * normalized. The milliseconds field is split such that one second is\n     * added to the seconds field and the remainder is milliseconds.\n     * Next the seconds are normalized in the same way. Then minutes, then\n     * hours. At this point the time fields have been normalized and the\n     * date fields are normalized including the days field.\n     * <p>\n     * The days field is normalized by trying to ensure that every month\n     * has the same number of days. If the day of month that this period\n     * refers to is greater than the maximum for the month the day is set\n     * to the maximum. If the original day was at the end of the month (e.g.\n     * day 31 and the month has 30 days) then it is adjusted to the maximum\n     * for the new month.\n     * <p>\n     * The months field is then normalized in the same way, adjusting the\n     * year field if necessary. Similarly, the years field is normalized,\n     * adjusting the century field if necessary.\n     * <p>\n     * The result is then evaluated against fixed limits: the year and\n     * milliseconds are limited to max values; the other fields are limited\n     * to typical maximums.\n     *\n     * @return this period normalized into standard rules\n     *\n     * @see PeriodType#standard()\n     */\n    public Period normalizedStandard() {\n        return normalizedStandard(PeriodType.standard());\n    }\n\n    /**\n     * Normalizes this period using standard rules.\n     * <p>\n     * This normalizes each field in turn. Only the non-zero fields are processed.\n     * First the milliseconds are normalized. The milliseconds field is split\n     * such that one second is added to the seconds field and the remainder is\n     * milliseconds. Next the seconds are normalized in the same way. Then\n     * minutes, then hours. At this point the time fields have been normalized\n     * and the date fields are normalized including the days field.\n     * <p>\n     * The days field is normalized by trying to ensure that every month has the\n     * same number of days. If the day of month that this period refers to is\n     * greater than the maximum for the month the day is set to the maximum. If\n     * the original day was at the end of the month (e.g. day 31 and the month\n     * has 30 days) then it is adjust to the maximum for the new month.\n     * <p>\n     * The months field is then normalized in the same way, adjusting the year\n     * field if necessary. Similarly, the years field is normalized, adjusting\n     * the century field if necessary.\n     * <p>\n     * The type of the specified field is ignored unless it is necessary to\n     * determine the maximum size of the days field. All other fields are\n     * normalized to their maximum potential size.\n     * <p>\n     * The result is then evaluated against fixed limits: the year and\n     * milliseconds are limited to max values; the other fields are limited\n     * to typical maximums.\n     *\n     * @param type  which set of rules to use to build the duration\n     * @return this period normalized into standard rules\n     *\n     * @throws IllegalArgumentException if this period contains fields not\n     *  supported by the specified period type\n     */\n    public Period normalizedStandard(PeriodType type) {\n        return new Period(\n                getYears(), getMonths(), getWeeks(), getDays(),\n                getHours(), getMinutes(), getSeconds(), getMillis(), type).normalizedStandard();\n    }\n\n    //-----------------------------------------------------------------------\n    /**\n     * Standard string format for the period using ISO-8601 notation,\n     * such as \"P6H3M7S\" or \"P1Y2M3W4DT5H6M7S\".\n     * <p>\n     * The format of the returned string will be ISO-8601 standard format.\n     *\n     * @return the period formatted using ISO-8601 notation\n     */\n    public String toString() {\n        return ISOPeriodFormat.standard().print(this);\n    }\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/base/BasePeriod.java b/src/main/java/org/joda/time/base/BasePeriod.java\nindex 679b734a..516a29ba 100644\n--- a/src/main/java/org/joda/time/base/BasePeriod.java\n+++ b/src/main/java/org/joda/time/base/BasePeriod.java\n@@ -218,11 +218,289 @@ public abstract class BasePeriod\n      *\n      * @param duration  the duration, in milliseconds\n      */\n-    protected BasePeriod(long duration) {\n-        this(duration, null, null);\n-        // bug [3264409]\n+public abstract class BasePeriod\n+        implements ReadablePeriod, Serializable {\n+\n+    /** Serialization version */\n+    private static final long serialVersionUID = -2110953284060001145L;\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Calculates the duration of this period relative to a start instant.\n+     *\n+     * @param startInstant  the instant to calculate the duration relative to, null means now\n+     * @return the duration of the period as an ISO8601 duration string\n+     */\n+    public String toString(ReadableInstant startInstant) {\n+        if (startInstant == null) {\n+            return toString();\n+        }\n+        Duration dur = new Duration(startInstant.getMillis(), getMillis());\n+        return dur.toString();\n+    }\n+\n+    /**\n+     * Compares this object with the specified object for equality based\n+     * on the values of each of the fields. All ReadablePeriod instances are accepted.\n+     * <p>\n+     * Note that a zero length period (which this class supports) equals a zero length period\n+     * in another duration class, such as {@link org.joda.time.Duration}.\n+     *\n+     * @param readablePeriod  a readable period to check against\n+     * @return true if all the field values are equal, false if\n+     *  not or if {@code readablePeriod} is null or of an incorrect type\n+     */\n+    public boolean equals(Object readablePeriod) {\n+        if (this == readablePeriod) {\n+            return true;\n+        }\n+        if (readablePeriod instanceof ReadablePeriod == false) {\n+            return false;\n+        }\n+        ReadablePeriod other = (ReadablePeriod) readablePeriod;\n+        return (getPeriodType().equals(other.getPeriodType()) && \n+                getDurationField().getUnitMillis() == other.getDurationField().getUnitMillis() &&\n+                getYears() == other.getYears() &&\n+                getMonths() == other.getMonths() &&\n+                getWeeks() == other.getWeeks() &&\n+                getDays() == other.getDays() &&\n+                getHours() == other.getHours() &&\n+                getMinutes() == other.getMinutes() &&\n+                getSeconds() == other.getSeconds() &&\n+                getMillis() == other.getMillis());\n+    }\n+\n+    /**\n+     * Gets a hash code for the period that is compatable with the \n+     * equals method.\n+     *\n+     * @return a hash code\n+     */\n+    public int hashCode() {\n+        return (getYears() << 28) + (getMonths() << 24) + \n+                (getWeeks() << 20) + (getDays() << 16) +\n+                (getHours() << 12) + (getMinutes() << 8) +\n+                (getSeconds() << 4) + getMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Gets the years field value.\n+     *\n+     * @return the number of years in the period\n+     */\n+    public abstract int getYears();\n+\n+    /**\n+     * Gets the months field value.\n+     *\n+     * @return the number of months in the period\n+     */\n+    public abstract int getMonths();\n+\n+    /**\n+     * Gets the weeks field value.\n+     *\n+     * @return the number of weeks in the period\n+     */\n+    public abstract int getWeeks();\n+\n+    /**\n+     * Gets the days field value.\n+     * Note that one day has a different duration in daylight savings to\n+     * one day in standard time. The {@link Days} class represents a standard\n+     * 24 hour day.\n+     *\n+     * @return the number of days in the period\n+     */\n+    public abstract int getDays();\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Is this period zero length.\n+     * \n+     * @return true if the period is zero length\n+     */\n+    public boolean isZero() {\n+        return (getMillis() == 0 && \n+                getSeconds() == 0 &&\n+                getMinutes() == 0 &&\n+                getHours() == 0 &&\n+                getDays() == 0 &&\n+                getWeeks() == 0 &&\n+                getMonths() == 0 &&\n+                getYears() == 0);\n+    }\n+\n+    /**\n+     * Is this period a whole number of days, such that the number of hours,\n+     * minutes, seconds and millis are all zero.\n+     * \n+     * @return true if the period is a number of days and has no time elements\n+     */\n+    public boolean isDays() {\n+        return (getMillis() == 0 && \n+                getSeconds() == 0 &&\n+                getMinutes() == 0 &&\n+                getHours() == 0 &&\n+                ((getDays() != 0 && getWeeks() == 0 && getMonths() == 0 && getYears() == 0) ||\n+                 (getDays() == 0 && getWeeks() != 0 && getMonths() == 0 && getYears() == 0)));\n+    }\n+\n+    /**\n+     * Is this period a whole number of months, such that the number of days,\n+     * hours, minutes, seconds and millis are all zero.\n+     * \n+     * @return true if the period is a number of months and has no other fields\n+     */\n+    public boolean isMonths() {\n+        return (getMillis() == 0 && \n+                getSeconds() == 0 &&\n+                getMinutes() == 0 &&\n+                getHours() == 0 &&\n+                getDays() == 0 &&\n+                ((getYears() != 0 && getMonths() != 0 && getWeeks() == 0) ||\n+                 (getYears() == 0 && getMonths() != 0 && getWeeks() != 0)));\n     }\n \n+    /**\n+     * Gets the total millisecond duration of this period relative to a start instant.\n+     *\n+     * @param startInstant  the instant to calculate the duration relative to, null means now\n+     * @return the total length of the period in milliseconds.\n+     */\n+    public long toDurationFrom(ReadableInstant startInstant) {\n+        return new Interval(startInstant, this).toDurationMillis();\n+    }\n+\n+    /**\n+     * Gets the total millisecond duration of this period relative to an \n+     * instant at the start of 1970-01-01T00:00:00Z.\n+     * <p>\n+     * This method performs the same conversion as using an {@link Interval}\n+     * constructed with this period and an instant at the start of 1970.\n+     *\n+     * @return the total length of the period in milliseconds.\n+     */\n+    public long toDurationMillis() {\n+        return new Duration(\n+                getYears(), getMonths(), getWeeks(), getDays(),\n+                getHours(), getMinutes(), getSeconds(), getMillis()).getMillis();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Adds this period to the specified instant, returning a new instant.\n+     *\n+     * @param instant  the instant to add to, null means now\n+     * @return an instant plus this period.\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public Instant addTo(ReadableInstant instant) {\n+        return instant.toInstant().withPeriodAdded(this, 1);\n+    }\n+\n+    /**\n+     * Subtracts this period from the specified instant, returning a new instant.\n+     *\n+     * @param instant  the instant to subtract from, null means now\n+     * @return an instant minus this period.\n+     * @throws ArithmeticException if the result exceeds the capacity of the instant\n+     */\n+    public Instant subtractFrom(ReadableInstant instant) {\n+        return instant.toInstant().withPeriodAdded(this, -1);\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Normalizes this period using standard rules, assuming a 12 month year.\n+     * <p>\n+     * This normalizes each field, years/months/weeks/days, in turn. Only\n+     * the non-zero fields are processed. First the milliseconds are\n+     * normalized. The milliseconds field is split such that one second is\n+     * added to the seconds field and the remainder is milliseconds.\n+     * Next the seconds are normalized in the same way. Then minutes, then\n+     * hours. At this point the time fields have been normalized and the\n+     * date fields are normalized including the days field.\n+     * <p>\n+     * The days field is normalized by trying to ensure that every month\n+     * has the same number of days. If the day of month that this period\n+     * refers to is greater than the maximum for the month the day is set\n+     * to the maximum. If the original day was at the end of the month (e.g.\n+     * day 31 and the month has 30 days) then it is adjusted to the maximum\n+     * for the new month.\n+     * <p>\n+     * The months field is then normalized in the same way, adjusting the\n+     * year field if necessary. Similarly, the years field is normalized,\n+     * adjusting the century field if necessary.\n+     * <p>\n+     * The result is then evaluated against fixed limits: the year and\n+     * milliseconds are limited to max values; the other fields are limited\n+     * to typical maximums.\n+     *\n+     * @return this period normalized into standard rules\n+     *\n+     * @see PeriodType#standard()\n+     */\n+    public Period normalizedStandard() {\n+        return normalizedStandard(PeriodType.standard());\n+    }\n+\n+    /**\n+     * Normalizes this period using standard rules.\n+     * <p>\n+     * This normalizes each field in turn. Only the non-zero fields are processed.\n+     * First the milliseconds are normalized. The milliseconds field is split\n+     * such that one second is added to the seconds field and the remainder is\n+     * milliseconds. Next the seconds are normalized in the same way. Then\n+     * minutes, then hours. At this point the time fields have been normalized\n+     * and the date fields are normalized including the days field.\n+     * <p>\n+     * The days field is normalized by trying to ensure that every month has the\n+     * same number of days. If the day of month that this period refers to is\n+     * greater than the maximum for the month the day is set to the maximum. If\n+     * the original day was at the end of the month (e.g. day 31 and the month\n+     * has 30 days) then it is adjust to the maximum for the new month.\n+     * <p>\n+     * The months field is then normalized in the same way, adjusting the year\n+     * field if necessary. Similarly, the years field is normalized, adjusting\n+     * the century field if necessary.\n+     * <p>\n+     * The type of the specified field is ignored unless it is necessary to\n+     * determine the maximum size of the days field. All other fields are\n+     * normalized to their maximum potential size.\n+     * <p>\n+     * The result is then evaluated against fixed limits: the year and\n+     * milliseconds are limited to max values; the other fields are limited\n+     * to typical maximums.\n+     *\n+     * @param type  which set of rules to use to build the duration\n+     * @return this period normalized into standard rules\n+     *\n+     * @throws IllegalArgumentException if this period contains fields not\n+     *  supported by the specified period type\n+     */\n+    public Period normalizedStandard(PeriodType type) {\n+        return new Period(\n+                getYears(), getMonths(), getWeeks(), getDays(),\n+                getHours(), getMinutes(), getSeconds(), getMillis(), type).normalizedStandard();\n+    }\n+\n+    //-----------------------------------------------------------------------\n+    /**\n+     * Standard string format for the period using ISO-8601 notation,\n+     * such as \"P6H3M7S\" or \"P1Y2M3W4DT5H6M7S\".\n+     * <p>\n+     * The format of the returned string will be ISO-8601 standard format.\n+     *\n+     * @return the period formatted using ISO-8601 notation\n+     */\n+    public String toString() {\n+        return ISOPeriodFormat.standard().print(this);\n+    }\n+\n+}\n+\n     /**\n      * Creates a period from the given millisecond duration, which is only really\n      * suitable for durations less than one day.",
    "result_reason": "error: class BasePeriod is already defined in package org.joda.time.base",
    "test_result": "ERROR"
}