{
    "patch": "// getBytes converts such a string to a byte sequence in a\n// \"suitable\" encoding, with one non-portable exception: \\0\n// in a string is encoded as a 0 byte, but *may* also be the\n// end of the whole byte sequence. So for our purposes, we\n// forbid \\0's in strings.\ntry {\n    byte[] bytes = s.getBytes(\"ISO8859_1\");\n    if (bytes == null) {\n        // Should never happen.\n        throw new NullPointerException(\"bytes == null\");\n    }\n    for (int i = 0, j = bytes.length; i < j; i++) {\n        byte b = bytes[i];\n        if (b == 0) {\n            throw new IllegalArgumentException(\"Invalid null byte in string: \\\"\" + s + \"\\\"\");\n        }\n        if (b == '\\\\') {\n            i++;\n            b = bytes[i];\n            switch (b) {\n                case 'n':\n                    c = '\\n';\n                    break;\n                case 'r':\n                    c = '\\r';\n                    break;\n                case 't':\n                    c = '\\t';\n                    break;\n\n                case 'b': // '\\b'\n                case 'f': // '\\f'\n                case '\\\"': // '\\\"'\n                case '\\'': // '\\''\n                case '\\\\': // '\\\\'\n                    c = (char)b;\n                    break;\n\n                case 'u':\n                    // A unicode escape of the form \\uxxxx, where xxxx is a\n                    // 4 digit hexadecimal number.\n                    if (i >= j - 4) {\n                        throw new IllegalArgumentException(\"Invalid unicode sequence: \\\"\\\\u\" + new String(bytes, i, j - i) + \"\\\"\");\n                    }\n                    int ch4 = hexToInt(bytes[i+1]);\n                    int ch3 = hexToInt(bytes[i+2]);\n                    int ch2 = hexToInt(bytes[i+3]);\n                    int ch1 = hexToInt(bytes[i+4]);\n                    if (ch4 < 0 || ch3 < 0 || ch2 < 0 || ch1 < 0) {\n                        throw new IllegalArgumentException(\"Invalid unicode sequence: \\\"\\\\u\" + new String(bytes, i, j - i) + \"\\\"\");\n                    }\n                    i += 4;\n                    c = (char)((ch4 << 12) + (ch3 << 8) + (ch2 << 4) + ch1);\n                    break;\n\n                default:\n                    throw new IllegalArgumentException(\"Unrecognized escape sequence: '\\\\\" + (char)b + \"'\");\n            }\n        } else {\n            c = (char)(b & 0xff);\n        }\n        buf.append(c);\n    }\n    success = true;\n} catch (UnsupportedEncodingException e) {\n    // ISO-8859-1 should always be supported\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\nindex 8caca580..5033afe0 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n@@ -27,7 +27,7 @@ package org.apache.commons.lang3.text.translate;\n  */\n public class EntityArrays {\n \n-    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\n+\n     private static final String[][] ISO8859_1_ESCAPE = {\n         {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n         {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark",
    "result_reason": "error: operand expected (error token is \"=\")",
    "test_result": "ERROR"
}