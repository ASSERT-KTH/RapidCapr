{
    "patch": "import org.mockito.Mockito;\nimport org.mockito.internal.creation.bytebuddy.MocksCreationSettings;\nimport org.mockito.internal.handler.MockHandlerImpl;\nimport org.mockito.internal.handler.MockHandlerInterface;\nimport org.mockito.internal.handler.MockHandlerLoader;\nimport org.mockito.internal.progress.MockingProgressImpl;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\nimport org.mockito.internal.stubbing.answers.CallsRealMethods;\nimport org.mockito.internal.stubbing.answers.Returns;\nimport org.mockito.internal.stubbing.defaultanswers.ReturnsMocks;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.invocation.MockInvocation;\nimport org.mockito.mock.MockCreationSettings;\nimport org.mockito.plugins.MockMaker;\nimport org.mockito.stubbing.Answer;\n\nimport java.lang.reflect.Proxy;\nimport java.util.Arrays;\nimport java.util.Collections;\n\npublic class BugFixer {\n    private static final ThreadSafeMockingProgress THREAD_SAFE_MOCKING_PROGRESS =\n            new ThreadSafeMockingProgress();\n    private static final MockHandlerLoader HANDLER_LOADER =\n            new MockHandlerLoader();\n    private static final MockUtil MOCK_UTIL = new MockUtil();\n\n    public static <T> void resetMock(T mock) {\n        MockHandlerImpl<T> oldMockHandler = getMockHandler(mock);\n        MockCreationSettings<T> settings = MocksCreationSettings.defaultMockitoSettings();\n        MockHandlerImpl<T> newMockHandler = new MockHandlerImpl<>(\n                settings.getMockName(),\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces(),\n                settings.getInvocationContainer(),\n                settings.getSerializableMode(),\n                settings.getAnswers(),\n                settings.getDefaultAnswer(),\n                settings.getMockCreationSettings().getSerializableMode(),\n                Collections.<MockInvocation>emptyList());\n        MethodInterceptorFilter<T> newFilter = new MethodInterceptorFilter<>(\n                newMockHandler,\n                new MockSettingsImpl()\n                        .defaultAnswer(settings.getMockCreationSettings().getDefaultAnswer())\n                        .build());\n        MockMaker mockMaker = Mockito.framework().getMockMaker();\n        Class<?>[] interfaces = HANDLER_LOADER.getMockedTypeInterfaces(mock);\n        T newMock;\n        if (mockMaker.isTypeMockable(settings.getTypeToMock())) {\n            newMock = mockMaker.createMock(settings);\n        } else {\n            newMock = buildMock(settings.getTypeToMock(), interfaces, newFilter);\n        }\n        setMockHandler(newMock, newMockHandler);\n    }\n\n    private static <T> MockHandlerImpl<T> getMockHandler(T mock) {\n        MockHandlerImpl<T> mockHandler;\n        if (MOCK_UTIL.isMock(mock)) {\n            mockHandler = (MockHandlerImpl<T>) MOCK_UTIL.getMockHandler(mock);\n        } else if (Proxy.isProxyClass(mock.getClass())) {\n            mockHandler = (MockHandlerImpl<T>) Proxy.getInvocationHandler(mock);\n        } else {\n            throw new IllegalArgumentException(\n                    \"Not a mock or a proxy: \" + mock.getClass().getName());\n        }\n        return mockHandler;\n    }\n\n    private static <T> void setMockHandler(T mock, MockHandlerImpl<T> mockHandler) {\n        if (Proxy.isProxyClass(mock.getClass())) {\n            ((java.lang.reflect.InvocationHandler) Proxy.getInvocationHandler(mock)).setMockitoHandler(mockHandler);\n        } else if (MOCK_UTIL.isMock(mock)) {\n            MOCK_UTIL.getInvocationContainer(mock).setMockitoHandler(mockHandler);\n        } else {\n            throw new IllegalArgumentException(\n                    \"Not a mock or a proxy: \" + mock.getClass().getName());\n        }\n    }\n\n    private static <T> T buildMock(Class<T> type,\n                                   Class<?>[] interfaces,\n                                   MethodInterceptorFilter<T> filter) {\n        ClassLoader classLoader = type.getClassLoader();\n        return (T) Proxy.newProxyInstance(\n                classLoader,\n                interfaces,\n                filter\n        );\n    }\n\n    private static class MockSettingsImpl implements MockCreationSettings {\n        private Answer defaultAnswer;\n\n        @Override\n        public Object[] getSpiedInstances() {\n            return new Object[0];\n        }\n\n        @Override\n        public MockCreationSettings enableMockitoDebug() {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings disableMockitoDebug() {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings name(String name) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings serializable() {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings notSerializable() {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings spiedInstance(Object spiedInstance) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings defaultAnswer(Answer defaultAnswer) {\n            this.defaultAnswer = defaultAnswer;\n            return this;\n        }\n\n        @Override\n        public MockitoConfiguration getMockitoConfiguration() {\n            return null;\n        }\n\n        @Override\n        public MockCreationSettings useConstructor(Constructor constructor) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings extraInterfaces(Class<?>... extraInterfaces) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings invocationListeners(InvocationListener... listeners) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings stubOnly() {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings verboseLogging() {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings lenient() {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings defaultAnswer(Answers answer) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings retainActualArguments(boolean retainActualArguments) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings globalAnswer(Answer answer) {\n            return this;\n        }\n\n        @Override\n        public MockCreationSettings bddMockitoOnly() {\n            return this;\n        }\n\n        public Answer getDefaultAnswer() {\n            if (defaultAnswer != null) {\n                return defaultAnswer;\n            }\n            if (MOCK_UTIL.isSpy(MockSettingsImpl.this.getTypeToMock())) {\n                return new CallsRealMethods();\n            }\n            if (MOCK_UTIL.isMock(MockSettingsImpl.this.getTypeToMock())) {\n                return new ReturnsMocks();\n            }\n            return new Returns(MockSettingsImpl.this.getTypeToMock());\n        }\n\n        @Override\n        public boolean isSerializable() {\n            return false;\n        }\n\n        @Override\n        public MockCreationSettings serializable(MockCreationSettings.SerializableMode serializableMode) {\n            return null;\n        }\n\n        @Override\n        public MockCreationSettings spiedInstance(SpyCreationSettings spyCreationSettings) {\n            return null;\n        }\n\n        @Override\n        public MockCreationSettings lenientArgThat(ArgumentMatcher<?> matcher) {\n            return null;\n        }\n\n        @Override\n        public MockCreationSettings withSettings() {\n            return null;\n        }\n\n        @Override\n        public boolean isUsingConstructor() {\n            return false;\n        }\n\n        @Override\n        public Constructor getConstructorArgs() {\n            return null;\n        }\n\n        @Override\n        public Class<?>[] getExtraInterfaces() {\n            return new Class<?>[0];\n        }\n\n        @Override\n        public InvocationListener[] getInvocationListeners() {\n            return new InvocationListener[0];\n        }\n\n        @Override\n        public boolean isStubOnly() {\n            return false;\n        }\n\n        @Override\n        public boolean isLenient() {\n            return false;\n        }\n\n        @Override\n        public Answers getDefaultAnswerEnum() {\n            return null;\n        }\n\n        @Override\n        public boolean isRetainActualArguments() {\n            return false;\n        }\n\n        @Override\n        public Answer getGlobalAnswer() {\n            return null;\n        }\n\n        @Override\n        public boolean getSerializableMode() {\n            return false;\n        }\n\n        @Override\n        public SpyCreationSettings getSpySettings() {\n            return null;\n        }\n\n        @Override\n        public SerializableMode getMockitoSerializationFeature() {\n            return null;\n        }\n\n        @Override\n        public Object getMockitoInterceptor() {\n            return null;\n        }\n\n        @Override\n        public MockCreationSettings verboseLogging(boolean verbose) {\n            return null;\n        }\n    }\n\n    private static class MethodInterceptorFilter<T> implements java.lang.reflect.InvocationHandler {\n        private MockHandlerImpl<T> mockHandler;\n        private MockSettingsImpl mockSettings;\n\n        public MethodInterceptorFilter(MockHandlerImpl<T> mockHandler, MockSettingsImpl mockSettings) {\n            this.mockHandler = mockHandler;\n            this.mockSettings = mockSettings;\n        }\n\n        @Override\n        public Object invoke(Object proxy, java.lang.reflect.Method method, Object[] args) throws Throwable {\n            return mockHandler.handle(new MockInvocation(proxy, method, args, mockSettings));\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..d933e9d7b 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,321 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.Mockito;\n+import org.mockito.internal.creation.bytebuddy.MocksCreationSettings;\n+import org.mockito.internal.handler.MockHandlerImpl;\n+import org.mockito.internal.handler.MockHandlerInterface;\n+import org.mockito.internal.handler.MockHandlerLoader;\n+import org.mockito.internal.progress.MockingProgressImpl;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+import org.mockito.internal.stubbing.answers.CallsRealMethods;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsMocks;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.MockInvocation;\n+import org.mockito.mock.MockCreationSettings;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.stubbing.Answer;\n+\n+import java.lang.reflect.Proxy;\n+import java.util.Arrays;\n+import java.util.Collections;\n+\n+public class BugFixer {\n+    private static final ThreadSafeMockingProgress THREAD_SAFE_MOCKING_PROGRESS =\n+            new ThreadSafeMockingProgress();\n+    private static final MockHandlerLoader HANDLER_LOADER =\n+            new MockHandlerLoader();\n+    private static final MockUtil MOCK_UTIL = new MockUtil();\n+\n+    public static <T> void resetMock(T mock) {\n+        MockHandlerImpl<T> oldMockHandler = getMockHandler(mock);\n+        MockCreationSettings<T> settings = MocksCreationSettings.defaultMockitoSettings();\n+        MockHandlerImpl<T> newMockHandler = new MockHandlerImpl<>(\n+                settings.getMockName(),\n+                settings.getTypeToMock(),\n+                settings.getExtraInterfaces(),\n+                settings.getInvocationContainer(),\n+                settings.getSerializableMode(),\n+                settings.getAnswers(),\n+                settings.getDefaultAnswer(),\n+                settings.getMockCreationSettings().getSerializableMode(),\n+                Collections.<MockInvocation>emptyList());\n+        MethodInterceptorFilter<T> newFilter = new MethodInterceptorFilter<>(\n+                newMockHandler,\n+                new MockSettingsImpl()\n+                        .defaultAnswer(settings.getMockCreationSettings().getDefaultAnswer())\n+                        .build());\n+        MockMaker mockMaker = Mockito.framework().getMockMaker();\n+        Class<?>[] interfaces = HANDLER_LOADER.getMockedTypeInterfaces(mock);\n+        T newMock;\n+        if (mockMaker.isTypeMockable(settings.getTypeToMock())) {\n+            newMock = mockMaker.createMock(settings);\n+        } else {\n+            newMock = buildMock(settings.getTypeToMock(), interfaces, newFilter);\n+        }\n+        setMockHandler(newMock, newMockHandler);\n+    }\n+\n+    private static <T> MockHandlerImpl<T> getMockHandler(T mock) {\n+        MockHandlerImpl<T> mockHandler;\n+        if (MOCK_UTIL.isMock(mock)) {\n+            mockHandler = (MockHandlerImpl<T>) MOCK_UTIL.getMockHandler(mock);\n+        } else if (Proxy.isProxyClass(mock.getClass())) {\n+            mockHandler = (MockHandlerImpl<T>) Proxy.getInvocationHandler(mock);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    \"Not a mock or a proxy: \" + mock.getClass().getName());\n+        }\n+        return mockHandler;\n+    }\n+\n+    private static <T> void setMockHandler(T mock, MockHandlerImpl<T> mockHandler) {\n+        if (Proxy.isProxyClass(mock.getClass())) {\n+            ((java.lang.reflect.InvocationHandler) Proxy.getInvocationHandler(mock)).setMockitoHandler(mockHandler);\n+        } else if (MOCK_UTIL.isMock(mock)) {\n+            MOCK_UTIL.getInvocationContainer(mock).setMockitoHandler(mockHandler);\n+        } else {\n+            throw new IllegalArgumentException(\n+                    \"Not a mock or a proxy: \" + mock.getClass().getName());\n+        }\n+    }\n+\n+    private static <T> T buildMock(Class<T> type,\n+                                   Class<?>[] interfaces,\n+                                   MethodInterceptorFilter<T> filter) {\n+        ClassLoader classLoader = type.getClassLoader();\n+        return (T) Proxy.newProxyInstance(\n+                classLoader,\n+                interfaces,\n+                filter\n+        );\n+    }\n+\n+    private static class MockSettingsImpl implements MockCreationSettings {\n+        private Answer defaultAnswer;\n+\n+        @Override\n+        public Object[] getSpiedInstances() {\n+            return new Object[0];\n+        }\n+\n+        @Override\n+        public MockCreationSettings enableMockitoDebug() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings disableMockitoDebug() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings name(String name) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings serializable() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings notSerializable() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings spiedInstance(Object spiedInstance) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings defaultAnswer(Answer defaultAnswer) {\n+            this.defaultAnswer = defaultAnswer;\n+            return this;\n+        }\n+\n+        @Override\n+        public MockitoConfiguration getMockitoConfiguration() {\n+            return null;\n+        }\n+\n+        @Override\n+        public MockCreationSettings useConstructor(Constructor constructor) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings extraInterfaces(Class<?>... extraInterfaces) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings invocationListeners(InvocationListener... listeners) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings stubOnly() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings verboseLogging() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings lenient() {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings defaultAnswer(Answers answer) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings retainActualArguments(boolean retainActualArguments) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings globalAnswer(Answer answer) {\n+            return this;\n+        }\n+\n+        @Override\n+        public MockCreationSettings bddMockitoOnly() {\n+            return this;\n+        }\n+\n+        public Answer getDefaultAnswer() {\n+            if (defaultAnswer != null) {\n+                return defaultAnswer;\n+            }\n+            if (MOCK_UTIL.isSpy(MockSettingsImpl.this.getTypeToMock())) {\n+                return new CallsRealMethods();\n+            }\n+            if (MOCK_UTIL.isMock(MockSettingsImpl.this.getTypeToMock())) {\n+                return new ReturnsMocks();\n+            }\n+            return new Returns(MockSettingsImpl.this.getTypeToMock());\n+        }\n+\n+        @Override\n+        public boolean isSerializable() {\n+            return false;\n+        }\n+\n+        @Override\n+        public MockCreationSettings serializable(MockCreationSettings.SerializableMode serializableMode) {\n+            return null;\n+        }\n+\n+        @Override\n+        public MockCreationSettings spiedInstance(SpyCreationSettings spyCreationSettings) {\n+            return null;\n+        }\n+\n+        @Override\n+        public MockCreationSettings lenientArgThat(ArgumentMatcher<?> matcher) {\n+            return null;\n+        }\n+\n+        @Override\n+        public MockCreationSettings withSettings() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean isUsingConstructor() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Constructor getConstructorArgs() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Class<?>[] getExtraInterfaces() {\n+            return new Class<?>[0];\n+        }\n+\n+        @Override\n+        public InvocationListener[] getInvocationListeners() {\n+            return new InvocationListener[0];\n+        }\n+\n+        @Override\n+        public boolean isStubOnly() {\n+            return false;\n+        }\n+\n+        @Override\n+        public boolean isLenient() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Answers getDefaultAnswerEnum() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean isRetainActualArguments() {\n+            return false;\n+        }\n+\n+        @Override\n+        public Answer getGlobalAnswer() {\n+            return null;\n+        }\n+\n+        @Override\n+        public boolean getSerializableMode() {\n+            return false;\n+        }\n+\n+        @Override\n+        public SpyCreationSettings getSpySettings() {\n+            return null;\n+        }\n+\n+        @Override\n+        public SerializableMode getMockitoSerializationFeature() {\n+            return null;\n+        }\n+\n+        @Override\n+        public Object getMockitoInterceptor() {\n+            return null;\n+        }\n+\n+        @Override\n+        public MockCreationSettings verboseLogging(boolean verbose) {\n+            return null;\n+        }\n+    }\n+\n+    private static class MethodInterceptorFilter<T> implements java.lang.reflect.InvocationHandler {\n+        private MockHandlerImpl<T> mockHandler;\n+        private MockSettingsImpl mockSettings;\n+\n+        public MethodInterceptorFilter(MockHandlerImpl<T> mockHandler, MockSettingsImpl mockSettings) {\n+            this.mockHandler = mockHandler;\n+            this.mockSettings = mockSettings;\n+        }\n+\n+        @Override\n+        public Object invoke(Object proxy, java.lang.reflect.Method method, Object[] args) throws Throwable {\n+            return mockHandler.handle(new MockInvocation(proxy, method, args, mockSettings));\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}