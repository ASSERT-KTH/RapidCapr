{
    "patch": "private static Node computeFollowNode(\n      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n    /*\n     * This is the case where:\n     *\n     * 1. Parent is null implies that we are transferring control to the end of\n     * the script.\n     *\n     * 2. Parent is a function implies that we are transferring control back to\n     * the caller of the function.\n     *\n     * 3. If the node is a return statement, we should also transfer control\n     * back to the caller of the function.\n     *\n     * 4. If the node is root then we have reached the end of what we have been\n     * asked to traverse.\n     *\n     * In all cases we should transfer control to a \"symbolic return\" node.\n     * This will make life easier for DFAs.\n     */\n    Node parent = node.getParent();\n    if (parent == null || parent.isFunction() || NodeUtil.isFunctionDeclaration(parent)) {\n      // For FUNCTION nodes, fall through to the parent.\n      return computeFollowNode(fromNode, parent, cfa);\n    } else if (node.isReturn()) {\n      // If the node is a return statement, we should also transfer control back to the caller of the function.\n      Node funcNode = NodeUtil.getEnclosingFunction(node);\n      if (funcNode != null) {\n        return computeFollowNode(fromNode, funcNode, cfa);\n      }\n      // If funcNode is null, we have a syntax error.\n    } else if (node.isScript() || (cfa != null && node == cfa.getRoot())) {\n      // If the node is root then we have reached the end of what we have been asked to traverse.\n      // Same goes for ControlFlowAnalysis's root.\n      return null;\n    } else if (parent.isCase()) {\n      // After the body of a CASE, the control goes to the body of the next\n      // case, without having to go to the case condition.\n      if (parent.getNext() != null) {\n        if (parent.getNext().isCase()) {\n          return parent.getNext().getFirstChild().getNext();\n        } else if (parent.getNext().isDefaultCase()) {\n          return parent.getNext().getFirstChild();\n        } else {\n          Preconditions.checkState(false, \"Not reachable\");\n        }\n      } else {\n        return computeFollowNode(fromNode, parent, cfa);\n      }\n    } else if (parent.isSwitch()) {\n      return computeFollowNode(fromNode, parent, cfa);\n    } else if (parent.isNormalBlock()\n        || parent.isModuleBody()\n        || parent.isFunction()\n        || parent.isTry()) {\n      // Now that we are done with the special cases follow should be its\n      // immediate sibling, unless its sibling is a function\n      Node nextSibling = node.getNext();\n\n      // Skip function declarations because control doesn't get pass into it.\n      while (nextSibling != null && nextSibling.isFunction()) {\n        nextSibling = nextSibling.getNext();\n      }\n\n      if (nextSibling != null) {\n        return computeFallThrough(nextSibling);\n      } else {\n        // If there are no more siblings, control is transferred up the AST.\n        return computeFollowNode(fromNode, parent, cfa);\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..e093133a 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,76 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+private static Node computeFollowNode(\n+      Node fromNode, Node node, ControlFlowAnalysis cfa) {\n+    /*\n+     * This is the case where:\n+     *\n+     * 1. Parent is null implies that we are transferring control to the end of\n+     * the script.\n+     *\n+     * 2. Parent is a function implies that we are transferring control back to\n+     * the caller of the function.\n+     *\n+     * 3. If the node is a return statement, we should also transfer control\n+     * back to the caller of the function.\n+     *\n+     * 4. If the node is root then we have reached the end of what we have been\n+     * asked to traverse.\n+     *\n+     * In all cases we should transfer control to a \"symbolic return\" node.\n+     * This will make life easier for DFAs.\n+     */\n+    Node parent = node.getParent();\n+    if (parent == null || parent.isFunction() || NodeUtil.isFunctionDeclaration(parent)) {\n+      // For FUNCTION nodes, fall through to the parent.\n+      return computeFollowNode(fromNode, parent, cfa);\n+    } else if (node.isReturn()) {\n+      // If the node is a return statement, we should also transfer control back to the caller of the function.\n+      Node funcNode = NodeUtil.getEnclosingFunction(node);\n+      if (funcNode != null) {\n+        return computeFollowNode(fromNode, funcNode, cfa);\n+      }\n+      // If funcNode is null, we have a syntax error.\n+    } else if (node.isScript() || (cfa != null && node == cfa.getRoot())) {\n+      // If the node is root then we have reached the end of what we have been asked to traverse.\n+      // Same goes for ControlFlowAnalysis's root.\n+      return null;\n+    } else if (parent.isCase()) {\n+      // After the body of a CASE, the control goes to the body of the next\n+      // case, without having to go to the case condition.\n+      if (parent.getNext() != null) {\n+        if (parent.getNext().isCase()) {\n+          return parent.getNext().getFirstChild().getNext();\n+        } else if (parent.getNext().isDefaultCase()) {\n+          return parent.getNext().getFirstChild();\n+        } else {\n+          Preconditions.checkState(false, \"Not reachable\");\n+        }\n+      } else {\n+        return computeFollowNode(fromNode, parent, cfa);\n+      }\n+    } else if (parent.isSwitch()) {\n+      return computeFollowNode(fromNode, parent, cfa);\n+    } else if (parent.isNormalBlock()\n+        || parent.isModuleBody()\n+        || parent.isFunction()\n+        || parent.isTry()) {\n+      // Now that we are done with the special cases follow should be its\n+      // immediate sibling, unless its sibling is a function\n+      Node nextSibling = node.getNext();\n+\n+      // Skip function declarations because control doesn't get pass into it.\n+      while (nextSibling != null && nextSibling.isFunction()) {\n+        nextSibling = nextSibling.getNext();\n+      }\n+\n+      if (nextSibling != null) {\n+        return computeFallThrough(nextSibling);\n+      } else {\n+        // If there are no more siblings, control is transferred up the AST.\n+        return computeFollowNode(fromNode, parent, cfa);\n+      }\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}