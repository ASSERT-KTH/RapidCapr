{
    "patch": "    // check if an array index is out of bounds\n    \n    // Array accesses with a constant index are already handled above.\n    // Here, we check only the variable indexes.\n    if (right.getType() == Token.NAME) {\n        Scope.Var var = getVar(right.getString());\n        // we don't handle out-of-bounds access if we don't know the value of the index\n        if (var == null || !var.isNumber()) {\n            return n;\n        }\n        double index = var.getNumber();\n        int intIndex = (int) index;\n        if (intIndex < 0) {\n            error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n            return n;\n        }\n        Node elem = left.getFirstChild();\n        for (int i = 0; elem != null && i < intIndex; i++) {\n            elem = elem.getNext();\n        }\n        if (elem == null) {\n            error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n            return n;\n        }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 0b2636f4..882503f1 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1280,6 +1280,31 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     // If GETPROP/GETELEM is used as assignment target the array literal is\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n+    // check if an array index is out of bounds\n+    \n+    // Array accesses with a constant index are already handled above.\n+    // Here, we check only the variable indexes.\n+    if (right.getType() == Token.NAME) {\n+        Scope.Var var = getVar(right.getString());\n+        // we don't handle out-of-bounds access if we don't know the value of the index\n+        if (var == null || !var.isNumber()) {\n+            return n;\n+        }\n+        double index = var.getNumber();\n+        int intIndex = (int) index;\n+        if (intIndex < 0) {\n+            error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+            return n;\n+        }\n+        Node elem = left.getFirstChild();\n+        for (int i = 0; elem != null && i < intIndex; i++) {\n+            elem = elem.getNext();\n+        }\n+        if (elem == null) {\n+            error(INDEX_OUT_OF_BOUNDS_ERROR, right);\n+            return n;\n+        }\n+    }\n \n     if (right.getType() != Token.NUMBER) {\n       // Sometimes people like to use complex expressions to index into",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}