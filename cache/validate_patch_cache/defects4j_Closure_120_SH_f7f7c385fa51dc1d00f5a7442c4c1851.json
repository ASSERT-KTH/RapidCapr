{
    "patch": "// check if the variable is initialized before being used\nif (getInitializingReference() == null) {\n  return false;\n}\n\nReference firstRead = getOneAndOnlyReferenceIndex(1);\nPattern regex = null;\nif (firstRead != null && firstRead.getNode().isGetProp()) {\n  ObjectNode objNode = (ObjectNode) firstRead.getNode().getLastChild();\n  if (objNode.isString()) {\n    String property = objNode.getString();\n    StringRegexp regexp = new StringRegexp(property);\n    regex = regexp.getRegExp(patternFinder);\n  }\n}\nif (regex == null) {\n  return false;\n}\n\nString initValue = null;\nReference initRef = getInitializingReference();\nif (initRef != null && initRef.isLiteralValue()) {\n  initValue = initRef.getNode().getString();\n}\nif (initValue == null) {\n  return false;\n}\n\nreturn regex.matcher(initValue).find();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..e4a43ced 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,35 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+// check if the variable is initialized before being used\n+if (getInitializingReference() == null) {\n+  return false;\n+}\n+\n+Reference firstRead = getOneAndOnlyReferenceIndex(1);\n+Pattern regex = null;\n+if (firstRead != null && firstRead.getNode().isGetProp()) {\n+  ObjectNode objNode = (ObjectNode) firstRead.getNode().getLastChild();\n+  if (objNode.isString()) {\n+    String property = objNode.getString();\n+    StringRegexp regexp = new StringRegexp(property);\n+    regex = regexp.getRegExp(patternFinder);\n+  }\n+}\n+if (regex == null) {\n+  return false;\n+}\n+\n+String initValue = null;\n+Reference initRef = getInitializingReference();\n+if (initRef != null && initRef.isLiteralValue()) {\n+  initValue = initRef.getNode().getString();\n+}\n+if (initValue == null) {\n+  return false;\n+}\n+\n+return regex.matcher(initValue).find();\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}