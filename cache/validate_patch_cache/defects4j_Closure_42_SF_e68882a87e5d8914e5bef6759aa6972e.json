{
    "patch": "class TransformDispatcher implements TypeSafeDispatcher {\n  protected ErrorReporter errorReporter;\n  protected String sourceName;\n\n  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  Node processExpression(AstNode node) {\n    // Subclasses should override this method.\n    throw new RuntimeException(\"processExpression not implemented in \" + getClass().getName());\n  }\n\n  Node processStatement(AstNode node) {\n    // Subclasses should override this method.\n    throw new RuntimeException(\"processStatement not implemented in \" + getClass().getName());\n  }\n\n  Node processBlock(Block blockNode) {\n    return processGeneric(blockNode);\n  }\n\n  Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression()));\n  }\n\n  Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  Node processDoLoop(DoLoop loopNode) {\n    return newNode(Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n  }\n\n  Node processElementGet(ElementGet getNode) {\n    return newNode(Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n  }\n\n  Node processEmptyExpression(EmptyExpression exprNode) {\n    return newNode(Token.EMPTY);\n  }\n\n  Node processExpressionStatement(ExpressionStatement statementNode) {\n    return process(statementNode.getExpression());\n  }\n\n  Node processForInLoop(ForInLoop loopNode) {\n    Node lhsNode = transform(loopNode.getIterator());\n    Node rhsNode = transform(loopNode.getIteratedObject());\n    Node bodyNode = transformBlock(loopNode.getBody());\n    Node node = newNode(Token.FOR_IN, lhsNode, rhsNode, bodyNode);\n    node.putProp(Node.FOR_IN_DEF_PROP, Boolean.TRUE);\n    return node;\n  }\n\n  Node processForLoop(ForLoop loopNode) {\n    Node init = transform(loopNode.getInitializer());\n    Node cond = transform(loopNode.getCondition());\n    Node incr = transform(loopNode.getIncrement());\n    Node body = transformBlock(loopNode.getBody());\n    return newNode(Token.FOR, init, cond, incr, body);\n  }\n\n  Node processFunctionCall(FunctionCall callNode) {\n    Node target = transform(callNode.getTarget());\n    NodeList<Node> args = transform(callNode.getArguments());\n    return newCall(target, args);\n  }\n\n  Node processFunctionNode(FunctionNode functionNode) {\n    Node body = transform(functionNode.getBody());\n    Node node = newFunction(\n        createName(functionNode.getFunctionName()),\n        body,\n        functionNode.getLineno(),\n        functionNode.getFunctionType(),\n        functionNode.getEncodedSourceEnd(),\n        functionNode.isExpressionClosure(),\n        functionNode.getParams());\n    transferTypeInfo(functionNode, node);\n    return node;\n  }\n\n  Node processGeneratorExpression(GeneratorExpression node) {\n    throw new UnsupportedOperationException(\"GeneratorExpression not supported.\");\n  }\n\n  Node processIfStatement(IfStatement ifNode) {\n    Node node = newNode(Token.IF, transform(ifNode.getCondition()));\n\n    node.addChildToBack(transform(ifNode.getThenPart()));\n    if (ifNode.getElsePart() != null) {\n      node.addChildToBack(transform(ifNode.getElsePart()));\n    }\n\n    return node;\n  }\n\n  Node processInfixExpression(InfixExpression node) {\n    return newNode(\n        transformTokenType(node.getType()), transform(node.getLeft()), transform(node.getRight()));\n  }\n\n  Node processKeywordLiteral(KeywordLiteral node) {\n    return newNode(transformTokenType(node.getType()));\n  }\n\n  Node processLabel(Label labelNode) {\n    Node statement = transform(labelNode.getStatement());\n    Node label = createName(labelNode.getName());\n    label.setType(Token.LABEL_NAME);\n    return newNode(Token.LABEL, label, statement);\n  }\n\n  Node processLetNode(LetNode letNode) {\n    throw new UnsupportedOperationException(\"LetNode not supported.\");\n  }\n\n  Node processName(Name nameNode) {\n    return createName(nameNode.getIdentifier());\n  }\n\n  Node processNewExpression(NewExpression callNode) {\n    Node target = transform(callNode.getTarget());\n    NodeList<Node> args = transform(callNode.getArguments());\n    return newNew(target, args);\n  }\n\n  Node processNumber(NumberLiteral node) {\n    Node newNode = newNumber(node.getNumber());\n    newNode.setLineno(node.getLineno());\n    return newNode;\n  }\n\n  Node processObjectLiteral(ObjectLiteral node) {\n    NodeList<Node> props = new NodeList<>();\n    for (AstNode prop : node.getElements()) {\n      props.add(transform(prop));\n    }\n    return newObjectLiteral(props);\n  }\n\n  Node processParenthesizedExpression(ParenthesizedExpression node) {\n    return transform(node.getExpression());\n  }\n\n  Node processPropertyGet(PropertyGet node) {\n    Node target = transform(node.getTarget());\n    Node property = createName(node.getProperty().getIdentifier());\n    return newNode(Token.GETPROP, target, property);\n  }\n\n  Node processRegExpLiteral(RegExpLiteral node) {\n    Node newNode = newRegExp(node.getValue(), node.getFlags());\n    newNode.setLineno(node.getLineno());\n    return newNode;\n  }\n\n  Node processReturnStatement(ReturnStatement returnNode) {\n    Node node = newNode(Token.RETURN);\n    if (returnNode.getReturnValue() != null) {\n      node.addChildToBack(transform(returnNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  Node processString(StringLiteral node) {\n    Node newNode = newString(node.getValue());\n    newNode.setLineno(node.getLineno());\n    return newNode;\n  }\n\n  Node processSwitchCase(SwitchCase caseNode) {\n    return newNode(Token.CASE, transform(caseNode.getExpression()), transform(caseNode.getStatements()));\n  }\n\n  Node processSwitchStatement(SwitchStatement switchNode) {\n    return newNode(Token.SWITCH, transform(switchNode.getExpression()), transform(switchNode.getCases()));\n  }\n\n  Node processThrowStatement(ThrowStatement throwNode) {\n    return newNode(Token.THROW, transform(throwNode.getExpression()));\n  }\n\n  Node processTryStatement(TryStatement tryNode) {\n    Node tryBlock = transform(tryNode.getTryBlock());\n    Node catchBlocks = null;\n    if (tryNode.getCatchClauses() != null) {\n      catchBlocks = transformArray(tryNode.getCatchClauses());\n    }\n    Node finallyBlock = null;\n    if (tryNode.getFinallyBlock() != null) {\n      finallyBlock = transform(tryNode.getFinallyBlock());\n    }\n    return newTry(tryBlock, catchBlocks, finallyBlock);\n  }\n\n  Node processUnaryExpression(UnaryExpression node) {\n    return newNode(transformTokenType(node.getType()), transform(node.getOperand()));\n  }\n\n  Node processVariableDeclaration(VariableDeclaration node) {\n    Token declType = Token.LET;\n    switch (node.getType()) {\n      case Token.CONST:\n        declType = Token.CONST;\n        break;\n      case Token.VAR:\n        declType = Token.VAR;\n        break;\n      case Token.LET:\n        declType = Token.LET;\n        break;\n      default:\n        throw new RuntimeException(\"Unsupported decl type: \" + node.getType());\n    }\n\n    Node newNode = newNode(declType);\n    NodeList<AstNode> variables = node.getVariables();\n    for (int i = 0; i < variables.size(); i++) {\n      AstNode variable = variables.get(i);\n      Node name = createName(variable.getString());\n      name.setLineno(variable.getLineno());\n      newNode.addChildToBack(newNode(Token.NAME, name));\n      if (variable.getInitializer() != null) {\n        newNode.getLastChild().addChildToBack(transform(variable.getInitializer()));\n      }\n    }\n\n    return newNode;\n  }\n\n  Node processVariableInitializer(Assignment node) {\n    return newNode(\n        Token.ASSIGN, transform(node.getLeft()), transform(node.getRight()));\n  }\n\n  Node processWhileLoop(WhileLoop loopNode) {\n    return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..12b01a04 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,275 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher implements TypeSafeDispatcher {\n+  protected ErrorReporter errorReporter;\n+  protected String sourceName;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+  Node processExpression(AstNode node) {\n+    // Subclasses should override this method.\n+    throw new RuntimeException(\"processExpression not implemented in \" + getClass().getName());\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+  Node processStatement(AstNode node) {\n+    // Subclasses should override this method.\n+    throw new RuntimeException(\"processStatement not implemented in \" + getClass().getName());\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+  Node processBlock(Block blockNode) {\n+    return processGeneric(blockNode);\n+  }\n+\n+  Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(), \"\", 0);\n     }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(Token.HOOK, transform(exprNode.getTestExpression()), transform(exprNode.getTrueExpression()), transform(exprNode.getFalseExpression()));\n+  }\n+\n+  Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  Node processDoLoop(DoLoop loopNode) {\n+    return newNode(Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n+  }\n+\n+  Node processElementGet(ElementGet getNode) {\n+    return newNode(Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n+  }\n+\n+  Node processEmptyExpression(EmptyExpression exprNode) {\n+    return newNode(Token.EMPTY);\n+  }\n+\n+  Node processExpressionStatement(ExpressionStatement statementNode) {\n+    return process(statementNode.getExpression());\n+  }\n+\n+  Node processForInLoop(ForInLoop loopNode) {\n+    Node lhsNode = transform(loopNode.getIterator());\n+    Node rhsNode = transform(loopNode.getIteratedObject());\n+    Node bodyNode = transformBlock(loopNode.getBody());\n+    Node node = newNode(Token.FOR_IN, lhsNode, rhsNode, bodyNode);\n+    node.putProp(Node.FOR_IN_DEF_PROP, Boolean.TRUE);\n+    return node;\n+  }\n+\n+  Node processForLoop(ForLoop loopNode) {\n+    Node init = transform(loopNode.getInitializer());\n+    Node cond = transform(loopNode.getCondition());\n+    Node incr = transform(loopNode.getIncrement());\n+    Node body = transformBlock(loopNode.getBody());\n+    return newNode(Token.FOR, init, cond, incr, body);\n+  }\n+\n+  Node processFunctionCall(FunctionCall callNode) {\n+    Node target = transform(callNode.getTarget());\n+    NodeList<Node> args = transform(callNode.getArguments());\n+    return newCall(target, args);\n+  }\n+\n+  Node processFunctionNode(FunctionNode functionNode) {\n+    Node body = transform(functionNode.getBody());\n+    Node node = newFunction(\n+        createName(functionNode.getFunctionName()),\n+        body,\n+        functionNode.getLineno(),\n+        functionNode.getFunctionType(),\n+        functionNode.getEncodedSourceEnd(),\n+        functionNode.isExpressionClosure(),\n+        functionNode.getParams());\n+    transferTypeInfo(functionNode, node);\n+    return node;\n+  }\n+\n+  Node processGeneratorExpression(GeneratorExpression node) {\n+    throw new UnsupportedOperationException(\"GeneratorExpression not supported.\");\n+  }\n+\n+  Node processIfStatement(IfStatement ifNode) {\n+    Node node = newNode(Token.IF, transform(ifNode.getCondition()));\n+\n+    node.addChildToBack(transform(ifNode.getThenPart()));\n+    if (ifNode.getElsePart() != null) {\n+      node.addChildToBack(transform(ifNode.getElsePart()));\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    return node;\n+  }\n+\n+  Node processInfixExpression(InfixExpression node) {\n+    return newNode(\n+        transformTokenType(node.getType()), transform(node.getLeft()), transform(node.getRight()));\n+  }\n+\n+  Node processKeywordLiteral(KeywordLiteral node) {\n+    return newNode(transformTokenType(node.getType()));\n+  }\n+\n+  Node processLabel(Label labelNode) {\n+    Node statement = transform(labelNode.getStatement());\n+    Node label = createName(labelNode.getName());\n+    label.setType(Token.LABEL_NAME);\n+    return newNode(Token.LABEL, label, statement);\n+  }\n+\n+  Node processLetNode(LetNode letNode) {\n+    throw new UnsupportedOperationException(\"LetNode not supported.\");\n+  }\n+\n+  Node processName(Name nameNode) {\n+    return createName(nameNode.getIdentifier());\n+  }\n+\n+  Node processNewExpression(NewExpression callNode) {\n+    Node target = transform(callNode.getTarget());\n+    NodeList<Node> args = transform(callNode.getArguments());\n+    return newNew(target, args);\n+  }\n+\n+  Node processNumber(NumberLiteral node) {\n+    Node newNode = newNumber(node.getNumber());\n+    newNode.setLineno(node.getLineno());\n+    return newNode;\n+  }\n+\n+  Node processObjectLiteral(ObjectLiteral node) {\n+    NodeList<Node> props = new NodeList<>();\n+    for (AstNode prop : node.getElements()) {\n+      props.add(transform(prop));\n     }\n+    return newObjectLiteral(props);\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  Node processParenthesizedExpression(ParenthesizedExpression node) {\n+    return transform(node.getExpression());\n+  }\n+\n+  Node processPropertyGet(PropertyGet node) {\n+    Node target = transform(node.getTarget());\n+    Node property = createName(node.getProperty().getIdentifier());\n+    return newNode(Token.GETPROP, target, property);\n+  }\n+\n+  Node processRegExpLiteral(RegExpLiteral node) {\n+    Node newNode = newRegExp(node.getValue(), node.getFlags());\n+    newNode.setLineno(node.getLineno());\n+    return newNode;\n+  }\n+\n+  Node processReturnStatement(ReturnStatement returnNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (returnNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(returnNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  Node processString(StringLiteral node) {\n+    Node newNode = newString(node.getValue());\n+    newNode.setLineno(node.getLineno());\n+    return newNode;\n+  }\n+\n+  Node processSwitchCase(SwitchCase caseNode) {\n+    return newNode(Token.CASE, transform(caseNode.getExpression()), transform(caseNode.getStatements()));\n+  }\n+\n+  Node processSwitchStatement(SwitchStatement switchNode) {\n+    return newNode(Token.SWITCH, transform(switchNode.getExpression()), transform(switchNode.getCases()));\n+  }\n+\n+  Node processThrowStatement(ThrowStatement throwNode) {\n+    return newNode(Token.THROW, transform(throwNode.getExpression()));\n+  }\n+\n+  Node processTryStatement(TryStatement tryNode) {\n+    Node tryBlock = transform(tryNode.getTryBlock());\n+    Node catchBlocks = null;\n+    if (tryNode.getCatchClauses() != null) {\n+      catchBlocks = transformArray(tryNode.getCatchClauses());\n     }\n+    Node finallyBlock = null;\n+    if (tryNode.getFinallyBlock() != null) {\n+      finallyBlock = transform(tryNode.getFinallyBlock());\n+    }\n+    return newTry(tryBlock, catchBlocks, finallyBlock);\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  Node processUnaryExpression(UnaryExpression node) {\n+    return newNode(transformTokenType(node.getType()), transform(node.getOperand()));\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  Node processVariableDeclaration(VariableDeclaration node) {\n+    Token declType = Token.LET;\n+    switch (node.getType()) {\n+      case Token.CONST:\n+        declType = Token.CONST;\n+        break;\n+      case Token.VAR:\n+        declType = Token.VAR;\n+        break;\n+      case Token.LET:\n+        declType = Token.LET;\n+        break;\n+      default:\n+        throw new RuntimeException(\"Unsupported decl type: \" + node.getType());\n+    }\n+\n+    Node newNode = newNode(declType);\n+    NodeList<AstNode> variables = node.getVariables();\n+    for (int i = 0; i < variables.size(); i++) {\n+      AstNode variable = variables.get(i);\n+      Node name = createName(variable.getString());\n+      name.setLineno(variable.getLineno());\n+      newNode.addChildToBack(newNode(Token.NAME, name));\n+      if (variable.getInitializer() != null) {\n+        newNode.getLastChild().addChildToBack(transform(variable.getInitializer()));\n+      }\n     }\n \n+    return newNode;\n+  }\n+\n+  Node processVariableInitializer(Assignment node) {\n+    return newNode(\n+        Token.ASSIGN, transform(node.getLeft()), transform(node.getRight()));\n+  }\n+\n+  Node processWhileLoop(WhileLoop loopNode) {\n+    return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n+  }\n+}\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}