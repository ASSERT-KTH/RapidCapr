{
    "patch": "            // This should never happen, but let's handle it just in case\n            if (indexOfVararg < matchers.size()) {\n                // Capture arguments up to vararg matcher\n                for (int position = 0; position <= indexOfVararg; position++) {\n                    Matcher m = matchers.get(position);\n                    if (m instanceof CapturesArguments) {\n                        ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n                    }\n                }\n                // Capture vararg arguments\n                Object vararg = invocation.getArgumentAt(indexOfVararg, Object[].class);\n                Matcher varargMatcher = matchers.get(indexOfVararg);\n                if (varargMatcher instanceof CapturesArguments) {\n                    for (Object arg : (Object[]) vararg) {\n                        ((CapturesArguments) varargMatcher).captureFrom(arg);\n                    }\n                }\n                // Capture arguments after vararg matcher\n                for (int position = indexOfVararg + 1; position < matchers.size(); position++) {\n                    Matcher m = matchers.get(position);\n                    if (m instanceof CapturesArguments) {\n                        ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position - 1, Object.class));\n                    }\n                }\n                return;\n            }",
    "patch_diff": "diff --git a/src/org/mockito/internal/invocation/InvocationMatcher.java b/src/org/mockito/internal/invocation/InvocationMatcher.java\nindex 7b877b1e2..4693d948d 100644\n--- a/src/org/mockito/internal/invocation/InvocationMatcher.java\n+++ b/src/org/mockito/internal/invocation/InvocationMatcher.java\n@@ -120,7 +120,32 @@ public class InvocationMatcher implements DescribedInvocation, CapturesArgumensF\n     public void captureArgumentsFrom(Invocation invocation) {\n         if (invocation.getMethod().isVarArgs()) {\n             int indexOfVararg = invocation.getRawArguments().length - 1;\n-            throw new UnsupportedOperationException();\n+            // This should never happen, but let's handle it just in case\n+            if (indexOfVararg < matchers.size()) {\n+                // Capture arguments up to vararg matcher\n+                for (int position = 0; position <= indexOfVararg; position++) {\n+                    Matcher m = matchers.get(position);\n+                    if (m instanceof CapturesArguments) {\n+                        ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position, Object.class));\n+                    }\n+                }\n+                // Capture vararg arguments\n+                Object vararg = invocation.getArgumentAt(indexOfVararg, Object[].class);\n+                Matcher varargMatcher = matchers.get(indexOfVararg);\n+                if (varargMatcher instanceof CapturesArguments) {\n+                    for (Object arg : (Object[]) vararg) {\n+                        ((CapturesArguments) varargMatcher).captureFrom(arg);\n+                    }\n+                }\n+                // Capture arguments after vararg matcher\n+                for (int position = indexOfVararg + 1; position < matchers.size(); position++) {\n+                    Matcher m = matchers.get(position);\n+                    if (m instanceof CapturesArguments) {\n+                        ((CapturesArguments) m).captureFrom(invocation.getArgumentAt(position - 1, Object.class));\n+                    }\n+                }\n+                return;\n+            }\n \n         } else {\n             for (int position = 0; position < matchers.size(); position++) {",
    "result_reason": "java.lang.ArrayIndexOutOfBoundsException: 0",
    "test_result": "FAIL"
}