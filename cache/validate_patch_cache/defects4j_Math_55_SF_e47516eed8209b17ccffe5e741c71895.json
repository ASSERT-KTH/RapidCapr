{
    "patch": "      double v1x = v1.getX();\n      double v1y = v1.getY();\n      double v1z = v1.getZ();\n      double v2x = v2.getX();\n      double v2y = v2.getY();\n      double v2z = v2.getZ();\n\n      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n      double rho = 0.00390625 * ((v1x * v2x + v1y * v2y) + v1z * v2z);\n\n      // rescale both vectors without losing precision,\n      // to ensure their norm are the same order of magnitude\n      double t;\n      double tx = v1y * v2z - v1z * v2y;\n      double ty = v1z * v2x - v1x * v2z;\n      double tz = v1x * v2y - v1y * v2x;\n      double size = FastMath.max(FastMath.max(FastMath.abs(tx), FastMath.abs(ty)), FastMath.abs(tz));\n      if (size < 3.3763891375449E-4) {\n          // normal case\n          return new Vector3D(tx, ty, tz);\n      } else {\n          // rescale everything to avoid overflow or underflow\n          t = INV_THRESHOLD * FastMath.sqrt(v1x * v1x + v1y * v1y + v1z * v1z);\n          v1x *= t;\n          v1y *= t;\n          v1z *= t;\n          t = INV_THRESHOLD * FastMath.sqrt(v2x * v2x + v2y * v2y + v2z * v2z);\n          v2x *= t;\n          v2y *= t;\n          v2z *= t;\n          tx *= t;\n          ty *= t;\n          tz *= t;\n          // applying the formula with rescaled vectors\n          double cx = v1y * v2z - v1z * v2y;\n          double cy = v1z * v2x - v1x * v2z;\n          double cz = v1x * v2y - v1y * v2x;\n          double cSize = FastMath.max(FastMath.max(FastMath.abs(cx), FastMath.abs(cy)), FastMath.abs(cz));\n          if (cSize < 0.99 * size) {\n              // we can trust the cross product\n              return new Vector3D(cx, cy, cz);\n          } else {\n              // either v1 or v2 were too large\n              t = 0.5 * (rho * (1.5 - 0.5 * rho * v2.dotProduct(v2)) * v1.getNorm() / size + v2.getNorm());\n              cx = v1y * v2z - v1z * v2y;\n              cy = v1z * v2x - v1x * v2z;\n              cz = v1x * v2y - v1y * v2x;\n              cSize = FastMath.max(FastMath.max(FastMath.abs(cx), FastMath.abs(cy)), FastMath.abs(cz));\n              if (cSize > size) {\n                  // rescaling did not work, we take the safest vector we can find\n                  if (FastMath.abs(v1x) >= FastMath.abs(v1y) && FastMath.abs(v1x) >= FastMath.abs(v1z)) {\n                      t = INV_THRESHOLD * FastMath.sqrt(1.0 + (v1y * v1y + v1z * v1z) / (v1x * v1x));\n                      v1x *= t;\n                      v1y *= t;\n                      v1z *= t;\n                      return new Vector3D(cx, cy, cz);\n                  } else if (FastMath.abs(v1y) >= FastMath.abs(v1z)) {\n                      t = INV_THRESHOLD * FastMath.sqrt(1.0 + (v1x * v1x + v1z * v1z) / (v1y * v1y));\n                      v1x *= t;\n                      v1y *= t;\n                      v1z *= t;\n                      return new Vector3D(cx, cy, cz);\n                  } else {\n                      t = INV_THRESHOLD * FastMath.sqrt(1.0 + (v1x * v1x + v1y * v1y) / (v1z * v1z));\n                      v1x *= t;\n                      v1y *= t;\n                      v1z *= t;\n                      return new Vector3D(cx, cy, cz);\n                  }\n              } else {\n                  return new Vector3D(cx, cy, cz);\n              }\n          }\n      }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/geometry/Vector3D.java b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\nindex 3c741e9e2..1772356f4 100644\n--- a/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n+++ b/src/main/java/org/apache/commons/math/geometry/Vector3D.java\n@@ -454,25 +454,80 @@ public class Vector3D implements Serializable {\n    * @param v2 second vector\n    * @return the cross product v1 ^ v2 as a new Vector\n    */\n-  public static Vector3D crossProduct(final Vector3D v1, final Vector3D v2) {\n+      double v1x = v1.getX();\n+      double v1y = v1.getY();\n+      double v1z = v1.getZ();\n+      double v2x = v2.getX();\n+      double v2y = v2.getY();\n+      double v2z = v2.getZ();\n \n+      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n+      double rho = 0.00390625 * ((v1x * v2x + v1y * v2y) + v1z * v2z);\n \n       // rescale both vectors without losing precision,\n       // to ensure their norm are the same order of magnitude\n-\n-      // we reduce cancellation errors by preconditioning,\n-      // we replace v1 by v3 = v1 - rho v2 with rho chosen in order to compute\n-      // v3 without loss of precision. See Kahan lecture\n-      // \"Computing Cross-Products and Rotations in 2- and 3-Dimensional Euclidean Spaces\"\n-      // available at http://www.cs.berkeley.edu/~wkahan/MathH110/Cross.pdf\n-\n-      // compute rho as an 8 bits approximation of v1.v2 / v2.v2\n-\n-\n-      // compute cross product from v3 and v2 instead of v1 and v2\n-      return new Vector3D(v1.y * v2.z - v1.z * v2.y, v1.z * v2.x - v1.x * v2.z, v1.x * v2.y - v1.y * v2.x);\n-\n-  }\n+      double t;\n+      double tx = v1y * v2z - v1z * v2y;\n+      double ty = v1z * v2x - v1x * v2z;\n+      double tz = v1x * v2y - v1y * v2x;\n+      double size = FastMath.max(FastMath.max(FastMath.abs(tx), FastMath.abs(ty)), FastMath.abs(tz));\n+      if (size < 3.3763891375449E-4) {\n+          // normal case\n+          return new Vector3D(tx, ty, tz);\n+      } else {\n+          // rescale everything to avoid overflow or underflow\n+          t = INV_THRESHOLD * FastMath.sqrt(v1x * v1x + v1y * v1y + v1z * v1z);\n+          v1x *= t;\n+          v1y *= t;\n+          v1z *= t;\n+          t = INV_THRESHOLD * FastMath.sqrt(v2x * v2x + v2y * v2y + v2z * v2z);\n+          v2x *= t;\n+          v2y *= t;\n+          v2z *= t;\n+          tx *= t;\n+          ty *= t;\n+          tz *= t;\n+          // applying the formula with rescaled vectors\n+          double cx = v1y * v2z - v1z * v2y;\n+          double cy = v1z * v2x - v1x * v2z;\n+          double cz = v1x * v2y - v1y * v2x;\n+          double cSize = FastMath.max(FastMath.max(FastMath.abs(cx), FastMath.abs(cy)), FastMath.abs(cz));\n+          if (cSize < 0.99 * size) {\n+              // we can trust the cross product\n+              return new Vector3D(cx, cy, cz);\n+          } else {\n+              // either v1 or v2 were too large\n+              t = 0.5 * (rho * (1.5 - 0.5 * rho * v2.dotProduct(v2)) * v1.getNorm() / size + v2.getNorm());\n+              cx = v1y * v2z - v1z * v2y;\n+              cy = v1z * v2x - v1x * v2z;\n+              cz = v1x * v2y - v1y * v2x;\n+              cSize = FastMath.max(FastMath.max(FastMath.abs(cx), FastMath.abs(cy)), FastMath.abs(cz));\n+              if (cSize > size) {\n+                  // rescaling did not work, we take the safest vector we can find\n+                  if (FastMath.abs(v1x) >= FastMath.abs(v1y) && FastMath.abs(v1x) >= FastMath.abs(v1z)) {\n+                      t = INV_THRESHOLD * FastMath.sqrt(1.0 + (v1y * v1y + v1z * v1z) / (v1x * v1x));\n+                      v1x *= t;\n+                      v1y *= t;\n+                      v1z *= t;\n+                      return new Vector3D(cx, cy, cz);\n+                  } else if (FastMath.abs(v1y) >= FastMath.abs(v1z)) {\n+                      t = INV_THRESHOLD * FastMath.sqrt(1.0 + (v1x * v1x + v1z * v1z) / (v1y * v1y));\n+                      v1x *= t;\n+                      v1y *= t;\n+                      v1z *= t;\n+                      return new Vector3D(cx, cy, cz);\n+                  } else {\n+                      t = INV_THRESHOLD * FastMath.sqrt(1.0 + (v1x * v1x + v1y * v1y) / (v1z * v1z));\n+                      v1x *= t;\n+                      v1y *= t;\n+                      v1z *= t;\n+                      return new Vector3D(cx, cy, cz);\n+                  }\n+              } else {\n+                  return new Vector3D(cx, cy, cz);\n+              }\n+          }\n+      }\n \n   /** Compute the distance between two vectors according to the L<sub>1</sub> norm.\n    * <p>Calling this method is equivalent to calling:",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}