{
    "patch": "        final int maximumIterations = 100;\n        double yMid;\n        double xMid;\n        double delta;\n        double xMin;\n        double xMax;\n        double yMax;\n        double yMin;\n        double y;\n        double correction;\n        xMin = min;\n        xMax = max;\n        yMin = f.value(xMin);\n        yMax = f.value(xMax);\n\n        for (int i = 0; i < maximumIterations; ++i) {\n            // calculate the inverse golden ratio and its squared value\n            delta = (xMax - xMin) * INV_GOLDEN_RATIO;\n            correction = i > 0 && (Math.abs(y) >= Math.abs(yMid) || Math.abs(yMid) >= Math.abs(yPrevMid))) ?\n                delta / 2.0 : 0;\n\n            // check for tolerance on x\n            if (Math.abs(delta) <= relativeAccuracy * Math.max(Math.abs(xMid), 1.0)) {\n                setResult(xMid, i);\n                return result;\n            }\n\n            // calculate the trial value\n            if (Math.abs(correction) <= absoluteAccuracy) {\n                // the correction is smaller than the absolute error tolerance\n                // in this case we pretend that the correction is zero and we jump\n                // directly to the bisection step\n                xMid = xMin + delta;\n            } else {\n                // the correction is greater than the absolute error tolerance\n                // the next trial value is modified accordingly\n                xMid = xMin + delta + correction;\n            }\n\n            // compute the y value for the mid-point\n            yMid = f.value(xMid);\n\n            // check for convergence\n            if (Math.abs(yMid) <= functionValueAccuracy) {\n                setResult(xMid, i);\n                return result;\n            }\n\n            // update the bracketing interval\n            if ((yMid > 0) == (yMin > 0)) {\n                // the min and mid points share the same sign\n                yMin = yMid;\n                xMin = xMid;\n            } else if ((yMid > 0) == (yMax > 0)) {\n                // the max and mid points share the same sign\n                yMax = yMid;\n                xMax = xMid;\n            } else {\n                // the sign of the mid point differs from both limits,\n                // this indicates that the bracket is contracting, we keep\n                // only the most recent solution within the brackets.\n\n                // we check that we are not outside of the bounds of the search\n                // interval, in which case we choose to use bisection.\n                if (yMid >= 0) {\n                    if (yMax <= 0) {\n                        xMin = xMid;\n                        yMin = yMid;\n                    } else {\n                        xMax = xMid;\n                        yMax = yMid;\n                    }\n                } else {\n                    if (yMin >= 0) {\n                        xMax = xMid;\n                        yMax = yMid;\n                    } else {\n                        xMin = xMid;\n                        yMin = yMid;\n                    }\n                }\n                if (Math.abs(xMax - xMin) <= absoluteAccuracy) {\n                    setResult(xMid, i);\n                    return result;\n                }\n            }\n\n            // update prev mid\n            yPrevMid = yMid;\n        }\n\n        // maximum number of iterations reached\n        throw new MaxIterationsExceededException(maximumIterations);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..06f64ae7f 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,99 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        final int maximumIterations = 100;\n+        double yMid;\n+        double xMid;\n+        double delta;\n+        double xMin;\n+        double xMax;\n+        double yMax;\n+        double yMin;\n+        double y;\n+        double correction;\n+        xMin = min;\n+        xMax = max;\n+        yMin = f.value(xMin);\n+        yMax = f.value(xMax);\n+\n+        for (int i = 0; i < maximumIterations; ++i) {\n+            // calculate the inverse golden ratio and its squared value\n+            delta = (xMax - xMin) * INV_GOLDEN_RATIO;\n+            correction = i > 0 && (Math.abs(y) >= Math.abs(yMid) || Math.abs(yMid) >= Math.abs(yPrevMid))) ?\n+                delta / 2.0 : 0;\n+\n+            // check for tolerance on x\n+            if (Math.abs(delta) <= relativeAccuracy * Math.max(Math.abs(xMid), 1.0)) {\n+                setResult(xMid, i);\n+                return result;\n+            }\n+\n+            // calculate the trial value\n+            if (Math.abs(correction) <= absoluteAccuracy) {\n+                // the correction is smaller than the absolute error tolerance\n+                // in this case we pretend that the correction is zero and we jump\n+                // directly to the bisection step\n+                xMid = xMin + delta;\n+            } else {\n+                // the correction is greater than the absolute error tolerance\n+                // the next trial value is modified accordingly\n+                xMid = xMin + delta + correction;\n+            }\n+\n+            // compute the y value for the mid-point\n+            yMid = f.value(xMid);\n+\n+            // check for convergence\n+            if (Math.abs(yMid) <= functionValueAccuracy) {\n+                setResult(xMid, i);\n+                return result;\n+            }\n+\n+            // update the bracketing interval\n+            if ((yMid > 0) == (yMin > 0)) {\n+                // the min and mid points share the same sign\n+                yMin = yMid;\n+                xMin = xMid;\n+            } else if ((yMid > 0) == (yMax > 0)) {\n+                // the max and mid points share the same sign\n+                yMax = yMid;\n+                xMax = xMid;\n+            } else {\n+                // the sign of the mid point differs from both limits,\n+                // this indicates that the bracket is contracting, we keep\n+                // only the most recent solution within the brackets.\n+\n+                // we check that we are not outside of the bounds of the search\n+                // interval, in which case we choose to use bisection.\n+                if (yMid >= 0) {\n+                    if (yMax <= 0) {\n+                        xMin = xMid;\n+                        yMin = yMid;\n+                    } else {\n+                        xMax = xMid;\n+                        yMax = yMid;\n+                    }\n+                } else {\n+                    if (yMin >= 0) {\n+                        xMax = xMid;\n+                        yMax = yMid;\n+                    } else {\n+                        xMin = xMid;\n+                        yMin = yMid;\n+                    }\n+                }\n+                if (Math.abs(xMax - xMin) <= absoluteAccuracy) {\n+                    setResult(xMid, i);\n+                    return result;\n+                }\n+            }\n+\n+            // update prev mid\n+            yPrevMid = yMid;\n+        }\n+\n+        // maximum number of iterations reached\n+        throw new MaxIterationsExceededException(maximumIterations);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}