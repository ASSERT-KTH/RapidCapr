{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final int n = m.getRowDimension(); // get number of rows (assuming square matrix)\n    final int threshold = 500; // set a threshold to divide large matrices\n    if (n > threshold) {\n        // divide the matrix into smaller sub-matrices\n        final int numSubMatrices = (n / threshold) + (n % threshold == 0 ? 0 : 1);\n        final EigenDecomposition[] decomposition = new EigenDecomposition[numSubMatrices];\n        for (int i = 0; i < numSubMatrices; ++i) {\n            final int leftIdx = i * threshold;\n            final int size = Math.min(n - leftIdx, threshold);\n            final RealMatrix subMatrix = m.getSubMatrix(leftIdx, leftIdx + size - 1, leftIdx, leftIdx + size - 1);\n            decomposition[i] = new EigenDecomposition(subMatrix);\n        }\n\n        // combine the square roots of sub-matrices\n        RealMatrix result = MatrixUtils.createRealMatrix(n, n);\n        for (int i = 0; i < numSubMatrices; ++i) {\n            final int leftIdx = i * threshold;\n            final int size = Math.min(n - leftIdx, threshold);\n            final RealMatrix subMatrix = MatrixUtils.createRealMatrix(size, size);\n            final RealMatrix v = decomposition[i].getV();\n            final RealMatrix d = decomposition[i].getD();\n            for (int j = 0; j < size; ++j) {\n                final double lambda = d.getEntry(j, j);\n                final double sqrtLambda = FastMath.sqrt(FastMath.max(lambda, 0));\n                for (int k = 0; k < size; ++k) {\n                    subMatrix.setEntry(k, j, v.getEntry(k, j) * sqrtLambda);\n                }\n            }\n            result.setSubMatrix(subMatrix.getData(), leftIdx, leftIdx);\n        }\n        return result;\n    } else {\n        // perform eigen decomposition directly\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..cc181ee92 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,42 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final int n = m.getRowDimension(); // get number of rows (assuming square matrix)\n+    final int threshold = 500; // set a threshold to divide large matrices\n+    if (n > threshold) {\n+        // divide the matrix into smaller sub-matrices\n+        final int numSubMatrices = (n / threshold) + (n % threshold == 0 ? 0 : 1);\n+        final EigenDecomposition[] decomposition = new EigenDecomposition[numSubMatrices];\n+        for (int i = 0; i < numSubMatrices; ++i) {\n+            final int leftIdx = i * threshold;\n+            final int size = Math.min(n - leftIdx, threshold);\n+            final RealMatrix subMatrix = m.getSubMatrix(leftIdx, leftIdx + size - 1, leftIdx, leftIdx + size - 1);\n+            decomposition[i] = new EigenDecomposition(subMatrix);\n+        }\n+\n+        // combine the square roots of sub-matrices\n+        RealMatrix result = MatrixUtils.createRealMatrix(n, n);\n+        for (int i = 0; i < numSubMatrices; ++i) {\n+            final int leftIdx = i * threshold;\n+            final int size = Math.min(n - leftIdx, threshold);\n+            final RealMatrix subMatrix = MatrixUtils.createRealMatrix(size, size);\n+            final RealMatrix v = decomposition[i].getV();\n+            final RealMatrix d = decomposition[i].getD();\n+            for (int j = 0; j < size; ++j) {\n+                final double lambda = d.getEntry(j, j);\n+                final double sqrtLambda = FastMath.sqrt(FastMath.max(lambda, 0));\n+                for (int k = 0; k < size; ++k) {\n+                    subMatrix.setEntry(k, j, v.getEntry(k, j) * sqrtLambda);\n+                }\n+            }\n+            result.setSubMatrix(subMatrix.getData(), leftIdx, leftIdx);\n+        }\n+        return result;\n+    } else {\n+        // perform eigen decomposition directly\n+        final EigenDecomposition dec = new EigenDecomposition(m);\n+        return dec.getSquareRoot();\n     }\n }\n+}",
    "result_reason": "org.apache.commons.math3.exception.MathUnsupportedOperationException: unsupported operation",
    "test_result": "FAIL"
}