{
    "patch": "  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n    // Notice that removing unreferenced function args breaks\n    // Function.prototype.length. In advanced mode, we don't really care\n    // about this: we consider \"length\" the equivalent of reflecting on\n    // the function's lexical source.\n    //\n    // Rather than create a new option for this, we assume that if the user\n    // is removing globals, then it's OK to remove unused function args.\n    //\n    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n\n    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers =\n        modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n\n    // New code begins here.\n    Set<String> usedArgs = new HashSet<>();\n    Set<String> unusedArgs = new HashSet<>();\n\n    NodeTraversal.traverseEs6(\n        compiler,\n        fnScope.getRootNode(),\n        new NodeTraversal.AbstractShallowCallback() {\n          @Override\n          public void visit(NodeTraversal t, Node n, Node parent) {\n            switch (parent.getToken()) {\n              case FUNCTION:\n                String paramName = n.getString();\n                usedArgs.add(paramName);\n                break;\n              case CALL:\n              case NEW:\n                if (n.isFirstChildOf(parent)) {\n                  FunctionType functionType = n.getFirstChild().getJSType().toMaybeFunctionType();\n                  if (functionType != null) {\n                    ImmutableList<String> paramNames = functionType.getParameterNames();\n                    int i = 0;\n                    for (Node arg : n.getLastChild().children()) {\n                      if (i >= paramNames.size()) {\n                        break;\n                      }\n                      if (usedArgs.contains(paramNames.get(i))) {\n                        unusedArgs.remove(paramNames.get(i));\n                      } else {\n                        unusedArgs.add(paramNames.get(i));\n                      }\n                      i++;\n                    }\n                  }\n                }\n                break;\n              default:\n                break;\n            }\n          }\n        });\n\n    int removedArgCount = 0;\n    for (Node param : argList.children()) {\n      String paramName = param.getString();\n      if (!usedArgs.contains(paramName) && !unusedArgs.contains(paramName)) {\n        unusedArgs.add(paramName);\n      }\n      if (unusedArgs.contains(paramName)) {\n        if (++removedArgCount == unusedArgs.size()) {\n          break;\n        }\n      }\n    }\n\n    if (removedArgCount == 0) {\n      return;\n    }\n\n    for (Node param = argList.getFirstChild();\n        param != null;\n        param = param.getNext()) {\n      String paramName = param.getString();\n      if (unusedArgs.contains(paramName)) {\n        argList.removeChild(param);\n        unusedArgs.remove(paramName);\n        removeAllMatchingParamDefaultValues(param);\n        compiler.reportCodeChange();\n        if (unusedArgs.isEmpty()) {\n          break;\n        }\n      }\n    }\n\n    List<Node> statements = NodeUtil.getFunctionBody(function).children();\n    boolean remapArguments = false;\n    for (Node statement : statements) {\n      if (statement.isParamList()) {\n        continue;\n      }\n      if (!remapArguments && NodeUtil.mayReferenceName(statement, \"arguments\")) {\n        remapArguments = true;\n      }\n      NodeTraversal.traverseEs6(compiler, statement,\n          new NodeTraversal.AbstractShallowCallback() {\n            @Override\n            public void visit(NodeTraversal t, Node n, Node parent) {\n              if (n.isName() && !n.getString().equals(\"undefined\")) {\n                if (n.isParam()) {\n                  String paramName = n.getString();\n                  if (!usedArgs.contains(paramName) && unusedArgs.contains(paramName)) {\n                    return;\n                  }\n                }\n                if (remapArguments || n.getString().equals(\"this\")) {\n                  if (n.getString().equals(\"arguments\")) {\n                    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n                  } else {\n                    Var var = fnScope.getVar(n.getString());\n                    if (var != null) {\n                      var.setName(null, compiler);\n                    }\n                  }\n                }\n              }\n            }\n          });\n    }\n\n    if (remapArguments) {\n      NodeTraversal.traverseEs6(compiler, NodeUtil.getFnParameters(function),\n          new NodeTraversal.AbstractShallowCallback() {\n            @Override\n            public void visit(NodeTraversal t, Node n, Node parent) {\n              if (n.isName() && n.getString().equals(\"arguments\")) {\n                NodeUtil.addFeatureToScript(t.getScope().getRootNode(), Feature.ARGUMENTS);\n              }\n            }\n          });\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..38e4bc7b 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,151 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n+    // Notice that removing unreferenced function args breaks\n+    // Function.prototype.length. In advanced mode, we don't really care\n+    // about this: we consider \"length\" the equivalent of reflecting on\n+    // the function's lexical source.\n+    //\n+    // Rather than create a new option for this, we assume that if the user\n+    // is removing globals, then it's OK to remove unused function args.\n+    //\n+    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+\n+    Node function = fnScope.getRootNode();\n+\n+    Preconditions.checkState(function.isFunction());\n+\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers =\n+        modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n+\n+    // New code begins here.\n+    Set<String> usedArgs = new HashSet<>();\n+    Set<String> unusedArgs = new HashSet<>();\n+\n+    NodeTraversal.traverseEs6(\n+        compiler,\n+        fnScope.getRootNode(),\n+        new NodeTraversal.AbstractShallowCallback() {\n+          @Override\n+          public void visit(NodeTraversal t, Node n, Node parent) {\n+            switch (parent.getToken()) {\n+              case FUNCTION:\n+                String paramName = n.getString();\n+                usedArgs.add(paramName);\n+                break;\n+              case CALL:\n+              case NEW:\n+                if (n.isFirstChildOf(parent)) {\n+                  FunctionType functionType = n.getFirstChild().getJSType().toMaybeFunctionType();\n+                  if (functionType != null) {\n+                    ImmutableList<String> paramNames = functionType.getParameterNames();\n+                    int i = 0;\n+                    for (Node arg : n.getLastChild().children()) {\n+                      if (i >= paramNames.size()) {\n+                        break;\n+                      }\n+                      if (usedArgs.contains(paramNames.get(i))) {\n+                        unusedArgs.remove(paramNames.get(i));\n+                      } else {\n+                        unusedArgs.add(paramNames.get(i));\n+                      }\n+                      i++;\n+                    }\n+                  }\n+                }\n+                break;\n+              default:\n+                break;\n+            }\n+          }\n+        });\n+\n+    int removedArgCount = 0;\n+    for (Node param : argList.children()) {\n+      String paramName = param.getString();\n+      if (!usedArgs.contains(paramName) && !unusedArgs.contains(paramName)) {\n+        unusedArgs.add(paramName);\n+      }\n+      if (unusedArgs.contains(paramName)) {\n+        if (++removedArgCount == unusedArgs.size()) {\n+          break;\n+        }\n+      }\n+    }\n+\n+    if (removedArgCount == 0) {\n+      return;\n+    }\n+\n+    for (Node param = argList.getFirstChild();\n+        param != null;\n+        param = param.getNext()) {\n+      String paramName = param.getString();\n+      if (unusedArgs.contains(paramName)) {\n+        argList.removeChild(param);\n+        unusedArgs.remove(paramName);\n+        removeAllMatchingParamDefaultValues(param);\n+        compiler.reportCodeChange();\n+        if (unusedArgs.isEmpty()) {\n+          break;\n+        }\n+      }\n+    }\n+\n+    List<Node> statements = NodeUtil.getFunctionBody(function).children();\n+    boolean remapArguments = false;\n+    for (Node statement : statements) {\n+      if (statement.isParamList()) {\n+        continue;\n+      }\n+      if (!remapArguments && NodeUtil.mayReferenceName(statement, \"arguments\")) {\n+        remapArguments = true;\n+      }\n+      NodeTraversal.traverseEs6(compiler, statement,\n+          new NodeTraversal.AbstractShallowCallback() {\n+            @Override\n+            public void visit(NodeTraversal t, Node n, Node parent) {\n+              if (n.isName() && !n.getString().equals(\"undefined\")) {\n+                if (n.isParam()) {\n+                  String paramName = n.getString();\n+                  if (!usedArgs.contains(paramName) && unusedArgs.contains(paramName)) {\n+                    return;\n+                  }\n+                }\n+                if (remapArguments || n.getString().equals(\"this\")) {\n+                  if (n.getString().equals(\"arguments\")) {\n+                    n.putBooleanProp(Node.ANALYZED_DURING_GTI, true);\n+                  } else {\n+                    Var var = fnScope.getVar(n.getString());\n+                    if (var != null) {\n+                      var.setName(null, compiler);\n+                    }\n+                  }\n+                }\n+              }\n+            }\n+          });\n+    }\n+\n+    if (remapArguments) {\n+      NodeTraversal.traverseEs6(compiler, NodeUtil.getFnParameters(function),\n+          new NodeTraversal.AbstractShallowCallback() {\n+            @Override\n+            public void visit(NodeTraversal t, Node n, Node parent) {\n+              if (n.isName() && n.getString().equals(\"arguments\")) {\n+                NodeUtil.addFeatureToScript(t.getScope().getRootNode(), Feature.ARGUMENTS);\n+              }\n+            }\n+          });\n+    }\n+  }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}