{
    "patch": "import com.google.javascript.jscomp.*;\nimport com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.jstype.*;\n\nimport java.util.Iterator;\n\nclass Example {\n  private static final DiagnosticType WRONG_ARGUMENT_COUNT =\n      DiagnosticType.warning(\n          \"JSC_WRONG_ARGUMENT_COUNT\",\n          \"Function {0} called with {1} argument(s). Function requires at least {2}{3}.\");\n\n  private final AbstractCompiler compiler;\n  private final Validator validator;\n  private final JSTypeRegistry typeRegistry;\n  private final VariableMap variableMap;\n\n  Example(\n      AbstractCompiler compiler,\n      CompilerOptions options,\n      VariableMap variableMap) {\n    this.compiler = compiler;\n    this.validator = new Validator(compiler, new TypeRegistry(options), options);\n    this.typeRegistry = validator.getTypeRegistry();\n    this.variableMap = variableMap;\n  }\n\n  void visitFunction(NodeTraversal t, Node function) {\n    if (compiler.getLifeCycleStage().isNormalized()) {\n      // Don't check \"normalized\" passes that run as part of the compilation\n      // pipeline, because those cannot generate invalid code; checking for\n      // errors in those cases would just add unnecessary overhead.\n      return;\n    }\n\n    FunctionType functionType = validator.getFunctionType(function);\n\n    // Handle function calls with no arguments.\n    if (functionType.getRequiredArity() == 0) {\n      return;\n    }\n\n    Node caller = t.getClosestHoistScope().getRootNode();\n    NodeTraversal callTrav =\n        new NodeTraversal(\n            compiler,\n            new Callback() {\n              @Override\n              public boolean shouldTraverse(\n                  NodeTraversal nodeTraversal, Node n, Node parent) {\n                return n.isCall()\n                    || (n.isNew() && n.getLastChild().isQualifiedName())\n                    || n.isTaggedTemplateLit()\n                    || n.isTemplateLit();\n              }\n\n              @Override\n              public void visit(NodeTraversal t, Node n, Node parent) {\n                if (n.isCall()) {\n                  visitParameterList(t, n, functionType);\n                } else if (n.isNew() && n.getLastChild().isQualifiedName()) {\n                  visitParameterList(t, n.getLastChild(), functionType);\n                } else {\n                  visitChildren(t, n);\n                }\n              }\n            });\n    callTrav.traverse(caller);\n  }\n\n  private void visitParameterList(\n      NodeTraversal t, Node call, FunctionType functionType) {\n    Iterator<Node> arguments = call.children().iterator();\n    arguments.next(); // skip the function name\n\n    Iterator<Node> parameters = functionType.getParameters().iterator();\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n\n    while (arguments.hasNext() && parameters.hasNext()) {\n      parameter = parameters.next();\n      argument = arguments.next();\n      ordinal++;\n      validator.expectArgumentMatchesParameter(\n          t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\n    }\n\n    if (functionType.hasRestFormals()) {\n      // This is a function that has varargs.\n      if (parameters.hasNext()) {\n        throw new RuntimeException(\"Invalid declaration of function type\");\n      }\n\n      while (arguments.hasNext()) {\n        argument = arguments.next();\n        ordinal++;\n        JSType restType = functionType.getRestFormalsType();\n        validator.expectArgumentMatchesParameter(\n            t, argument, getJSType(argument), restType, call, ordinal);\n      }\n    } else {\n      // Check that the number of arguments matches the function signature.\n      int numArgs = call.getChildCount() - 1;\n      int minArgs = functionType.getMinArguments();\n      int maxArgs = functionType.getMaxArguments();\n      if (minArgs > numArgs || maxArgs < numArgs) {\n        report(\n            t,\n            call,\n            WRONG_ARGUMENT_COUNT,\n            validator.getReadableJSTypeName(call.getFirstChild(), false),\n            String.valueOf(numArgs),\n            String.valueOf(minArgs),\n            maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n      }\n    }\n  }\n\n  private JSType getJSType(Node n) {\n    JSTypeExpression typeExpr = validator.getTypeOfExpression(n);\n    if (typeExpr == null) {\n      return null;\n    }\n    return typeExpr.evaluate(null, typeRegistry);\n  }\n\n  private void report(\n      NodeTraversal t, Node n, DiagnosticType diagnosticType, Object... arguments) {\n    t.report(n, diagnosticType, arguments);\n  }\n}\n\nclass Validator {\n  private final TypeCheck typeCheck;\n\n  Validator(AbstractCompiler compiler, TypeRegistry registry, CompilerOptions options) {\n    typeCheck = new TypeCheck(compiler, registry, options, null);\n  }\n\n  public void expectArgumentMatchesParameter(\n      NodeTraversal t,\n      Node arg,\n      JSType argType,\n      JSType paramType,\n      Node call,\n      int ordinal) {\n    if (argType == null) {\n      return;\n    }\n\n    // Special case for objects with call signatures, like function instances;\n    // we compare the callee types instead of the instance type in that case.\n    FunctionType expectedFnType = null;\n    if (paramType.isConstructor() && argType.isInstanceType()) {\n      expectedFnType = paramType.getConstructorFunction();\n    } else if (paramType.isFunctionType()) {\n      expectedFnType = paramType.toMaybeFunctionType();\n    }\n\n    if (expectedFnType != null) {\n      JSType actualFnType = getJSType(arg).autobox().restrictByNotNullOrUndefined();\n      if (actualFnType.isFunctionType() || actualFnType.isConstructor()) {\n        if (!expectedFnType.isEquivalentTo(actualFnType)) {\n          report(\n              t,\n              call,\n              JSTypeMismatch.MISTYPED_ASSIGN_RHS,\n              ordinal,\n              expectedFnType.toString(),\n              actualFnType.toString());\n          return;\n        }\n      } else {\n        // fall through to normal comparison below\n      }\n    }\n\n    if (paramType.isTemplatizedType() && argType.isConcreteType()) {\n      // We want to compare the resolvedTemplated type to the actual type.\n      JSTypeParameterMap typeMap =\n          getTypeMap(\n              paramType.toMaybeTemplatizedType().getReferenceName(),\n              argType.toMaybeObjectType());\n      JSType resolvedType =\n          paramType\n              .toMaybeTemplatizedType()\n              .instantiateGenerics(typeMap);\n      // We may find the resolved type by using JSType#getResolvedType, but this version of Closure\n      // only supports JSType#getResolvedType on the UNIVERSE instance and we are not running through\n      // that code path.\n      if (!(argType.isSubtype(resolvedType) || resolvedType.isSubtype(argType))\n          && paramType\n              .toMaybeTemplatizedType()\n              .getUseSiteType()\n              .isEquivalentTo(argType)) {\n        report(\n            t,\n            call,\n            JSTypeMismatch.MISTYPED_ASSIGN_RHS_TEMPLATE,\n            ordinal,\n            resolvedType.toString(),\n            argType.toString());\n      }\n      return;\n    }\n\n    // Warn if the parameter type doesn't match the argument type.\n    if (!argType.isSubtype(paramType)) {\n      report(\n          t,\n          call,\n          JSTypeMismatch.MISTYPED_ASSIGN_RHS,\n          ordinal,\n          paramType.toString(),\n          argType.toString());\n    }\n  }\n\n  private JSTypeParameterMap getTypeMap(\n      String templateTypeName, ObjectType argObjectType) {\n    JSTypeParameterMap paramMap = JSTypeParameterMap.EMPTY;\n    ObjectType currentObjectType = argObjectType;\n\n    while (currentObjectType != null) {\n      JSType templateType = currentObjectType.getTemplateType(templateTypeName);\n      if (templateType != null) {\n        if (templateType.isUnknow",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 8077e0d8..cfce15e5 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1396,8 +1396,78 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n   /**\n    * Visits the parameters of a CALL or a NEW node.\n    */\n-  private void visitParameterList(NodeTraversal t, Node call,\n-      FunctionType functionType) {\n+import com.google.javascript.jscomp.*;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.jstype.*;\n+\n+import java.util.Iterator;\n+\n+class Example {\n+  private static final DiagnosticType WRONG_ARGUMENT_COUNT =\n+      DiagnosticType.warning(\n+          \"JSC_WRONG_ARGUMENT_COUNT\",\n+          \"Function {0} called with {1} argument(s). Function requires at least {2}{3}.\");\n+\n+  private final AbstractCompiler compiler;\n+  private final Validator validator;\n+  private final JSTypeRegistry typeRegistry;\n+  private final VariableMap variableMap;\n+\n+  Example(\n+      AbstractCompiler compiler,\n+      CompilerOptions options,\n+      VariableMap variableMap) {\n+    this.compiler = compiler;\n+    this.validator = new Validator(compiler, new TypeRegistry(options), options);\n+    this.typeRegistry = validator.getTypeRegistry();\n+    this.variableMap = variableMap;\n+  }\n+\n+  void visitFunction(NodeTraversal t, Node function) {\n+    if (compiler.getLifeCycleStage().isNormalized()) {\n+      // Don't check \"normalized\" passes that run as part of the compilation\n+      // pipeline, because those cannot generate invalid code; checking for\n+      // errors in those cases would just add unnecessary overhead.\n+      return;\n+    }\n+\n+    FunctionType functionType = validator.getFunctionType(function);\n+\n+    // Handle function calls with no arguments.\n+    if (functionType.getRequiredArity() == 0) {\n+      return;\n+    }\n+\n+    Node caller = t.getClosestHoistScope().getRootNode();\n+    NodeTraversal callTrav =\n+        new NodeTraversal(\n+            compiler,\n+            new Callback() {\n+              @Override\n+              public boolean shouldTraverse(\n+                  NodeTraversal nodeTraversal, Node n, Node parent) {\n+                return n.isCall()\n+                    || (n.isNew() && n.getLastChild().isQualifiedName())\n+                    || n.isTaggedTemplateLit()\n+                    || n.isTemplateLit();\n+              }\n+\n+              @Override\n+              public void visit(NodeTraversal t, Node n, Node parent) {\n+                if (n.isCall()) {\n+                  visitParameterList(t, n, functionType);\n+                } else if (n.isNew() && n.getLastChild().isQualifiedName()) {\n+                  visitParameterList(t, n.getLastChild(), functionType);\n+                } else {\n+                  visitChildren(t, n);\n+                }\n+              }\n+            });\n+    callTrav.traverse(caller);\n+  }\n+\n+  private void visitParameterList(\n+      NodeTraversal t, Node call, FunctionType functionType) {\n     Iterator<Node> arguments = call.children().iterator();\n     arguments.next(); // skip the function name\n \n@@ -1405,30 +1475,156 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n-    while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n-      // If there are no parameters left in the list, then the while loop\n-      // above implies that this must be a var_args function.\n-        parameter = parameters.next();\n+\n+    while (arguments.hasNext() && parameters.hasNext()) {\n+      parameter = parameters.next();\n       argument = arguments.next();\n       ordinal++;\n+      validator.expectArgumentMatchesParameter(\n+          t, argument, getJSType(argument), getJSType(parameter), call, ordinal);\n+    }\n+\n+    if (functionType.hasRestFormals()) {\n+      // This is a function that has varargs.\n+      if (parameters.hasNext()) {\n+        throw new RuntimeException(\"Invalid declaration of function type\");\n+      }\n+\n+      while (arguments.hasNext()) {\n+        argument = arguments.next();\n+        ordinal++;\n+        JSType restType = functionType.getRestFormalsType();\n+        validator.expectArgumentMatchesParameter(\n+            t, argument, getJSType(argument), restType, call, ordinal);\n+      }\n+    } else {\n+      // Check that the number of arguments matches the function signature.\n+      int numArgs = call.getChildCount() - 1;\n+      int minArgs = functionType.getMinArguments();\n+      int maxArgs = functionType.getMaxArguments();\n+      if (minArgs > numArgs || maxArgs < numArgs) {\n+        report(\n+            t,\n+            call,\n+            WRONG_ARGUMENT_COUNT,\n+            validator.getReadableJSTypeName(call.getFirstChild(), false),\n+            String.valueOf(numArgs),\n+            String.valueOf(minArgs),\n+            maxArgs != Integer.MAX_VALUE ? \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+      }\n+    }\n+  }\n+\n+  private JSType getJSType(Node n) {\n+    JSTypeExpression typeExpr = validator.getTypeOfExpression(n);\n+    if (typeExpr == null) {\n+      return null;\n+    }\n+    return typeExpr.evaluate(null, typeRegistry);\n+  }\n \n-      validator.expectArgumentMatchesParameter(t, argument,\n-          getJSType(argument), getJSType(parameter), call, ordinal);\n+  private void report(\n+      NodeTraversal t, Node n, DiagnosticType diagnosticType, Object... arguments) {\n+    t.report(n, diagnosticType, arguments);\n+  }\n+}\n+\n+class Validator {\n+  private final TypeCheck typeCheck;\n+\n+  Validator(AbstractCompiler compiler, TypeRegistry registry, CompilerOptions options) {\n+    typeCheck = new TypeCheck(compiler, registry, options, null);\n+  }\n+\n+  public void expectArgumentMatchesParameter(\n+      NodeTraversal t,\n+      Node arg,\n+      JSType argType,\n+      JSType paramType,\n+      Node call,\n+      int ordinal) {\n+    if (argType == null) {\n+      return;\n     }\n \n-    int numArgs = call.getChildCount() - 1;\n-    int minArgs = functionType.getMinArguments();\n-    int maxArgs = functionType.getMaxArguments();\n-    if (minArgs > numArgs || maxArgs < numArgs) {\n-      report(t, call, WRONG_ARGUMENT_COUNT,\n-              validator.getReadableJSTypeName(call.getFirstChild(), false),\n-              String.valueOf(numArgs), String.valueOf(minArgs),\n-              maxArgs != Integer.MAX_VALUE ?\n-              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+    // Special case for objects with call signatures, like function instances;\n+    // we compare the callee types instead of the instance type in that case.\n+    FunctionType expectedFnType = null;\n+    if (paramType.isConstructor() && argType.isInstanceType()) {\n+      expectedFnType = paramType.getConstructorFunction();\n+    } else if (paramType.isFunctionType()) {\n+      expectedFnType = paramType.toMaybeFunctionType();\n+    }\n+\n+    if (expectedFnType != null) {\n+      JSType actualFnType = getJSType(arg).autobox().restrictByNotNullOrUndefined();\n+      if (actualFnType.isFunctionType() || actualFnType.isConstructor()) {\n+        if (!expectedFnType.isEquivalentTo(actualFnType)) {\n+          report(\n+              t,\n+              call,\n+              JSTypeMismatch.MISTYPED_ASSIGN_RHS,\n+              ordinal,\n+              expectedFnType.toString(),\n+              actualFnType.toString());\n+          return;\n+        }\n+      } else {\n+        // fall through to normal comparison below\n+      }\n+    }\n+\n+    if (paramType.isTemplatizedType() && argType.isConcreteType()) {\n+      // We want to compare the resolvedTemplated type to the actual type.\n+      JSTypeParameterMap typeMap =\n+          getTypeMap(\n+              paramType.toMaybeTemplatizedType().getReferenceName(),\n+              argType.toMaybeObjectType());\n+      JSType resolvedType =\n+          paramType\n+              .toMaybeTemplatizedType()\n+              .instantiateGenerics(typeMap);\n+      // We may find the resolved type by using JSType#getResolvedType, but this version of Closure\n+      // only supports JSType#getResolvedType on the UNIVERSE instance and we are not running through\n+      // that code path.\n+      if (!(argType.isSubtype(resolvedType) || resolvedType.isSubtype(argType))\n+          && paramType\n+              .toMaybeTemplatizedType()\n+              .getUseSiteType()\n+              .isEquivalentTo(argType)) {\n+        report(\n+            t,\n+            call,\n+            JSTypeMismatch.MISTYPED_ASSIGN_RHS_TEMPLATE,\n+            ordinal,\n+            resolvedType.toString(),\n+            argType.toString());\n+      }\n+      return;\n+    }\n+\n+    // Warn if the parameter type doesn't match the argument type.\n+    if (!argType.isSubtype(paramType)) {\n+      report(\n+          t,\n+          call,\n+          JSTypeMismatch.MISTYPED_ASSIGN_RHS,\n+          ordinal,\n+          paramType.toString(),\n+          argType.toString());\n     }\n   }\n \n+  private JSTypeParameterMap getTypeMap(\n+      String templateTypeName, ObjectType argObjectType) {\n+    JSTypeParameterMap paramMap = JSTypeParameterMap.EMPTY;\n+    ObjectType currentObjectType = argObjectType;\n+\n+    while (currentObjectType != null) {\n+      JSType templateType = currentObjectType.getTemplateType(templateTypeName);\n+      if (templateType != null) {\n+        if (templateType.isUnknow\n+\n   /**\n    * Visits a RETURN node.\n    *",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}