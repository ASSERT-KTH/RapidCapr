{
    "patch": "            if (NodeUtil.isDeleted(left) || NodeUtil.isVarOrSimpleAssignLhs(left, parent)) {\n              return false;\n            }\n            if (NodeUtil.isFunctionExpression(right)) {\n              // Function expressions should not be called from the enclosing function,\n              // but never inlined.  Doing so is likely to change the behavior of the\n              // program, since the value of 'this' will be different.\n              //\n              // Example:\n              // var x = {\n              //   f : function() { ... }\n              // }\n              // var g = function() { x.f() };\n              // ...\n              \n              // On the other hand:\n              // var g = function() { x.f; };\n              // This is safe to inline, since we know that f cannot directly access 'this'\n              // with object-dot notation.\n              Node func = right.getFirstChild();\n              if (NodeUtil.getFunctionBody(func) != null) {\n                return false;\n              }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..19e0f834 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,29 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+            if (NodeUtil.isDeleted(left) || NodeUtil.isVarOrSimpleAssignLhs(left, parent)) {\n+              return false;\n+            }\n+            if (NodeUtil.isFunctionExpression(right)) {\n+              // Function expressions should not be called from the enclosing function,\n+              // but never inlined.  Doing so is likely to change the behavior of the\n+              // program, since the value of 'this' will be different.\n+              //\n+              // Example:\n+              // var x = {\n+              //   f : function() { ... }\n+              // }\n+              // var g = function() { x.f() };\n+              // ...\n+              \n+              // On the other hand:\n+              // var g = function() { x.f; };\n+              // This is safe to inline, since we know that f cannot directly access 'this'\n+              // with object-dot notation.\n+              Node func = right.getFirstChild();\n+              if (NodeUtil.getFunctionBody(func) != null) {\n+                return false;\n+              }\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}