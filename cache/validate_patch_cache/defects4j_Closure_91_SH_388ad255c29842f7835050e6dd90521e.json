{
    "patch": "    if (n.getJSDocInfo() != null &&\n        (n.getJSDocInfo().isConstructor() ||\n         n.getJSDocInfo().isInterface() ||\n         n.getJSDocInfo().isOverride())) {\n      return false;\n    }\n\n    if (parent != null && parent.getType() == Token.ASSIGN) {\n      Node lhs = parent.getFirstChild();\n      Node rhs = lhs.getNext();\n      if (n == lhs && lhs.getType() == Token.NAME) {\n        return true;\n      }\n      if (lhs.getType() == Token.GETPROP) {\n        Node object = lhs.getFirstChild();\n        if (object.getType() == Token.NAME && \"prototype\".equals(lhs.getLastChild().getString())) {\n          return false;\n        }\n      }\n    }\n\n    if (n.getType() == Token.FUNCTION) {\n      if (isLentToPrototype(parent)) {\n        return false;\n      }\n      if (!canHaveThisAnnotation(n)) {\n        return false;\n      }\n      if (!isFunctionNameAllowedInExpression(parent)) {\n\t\t    return false;\n      }\n    }\n\n    return true;\n  }\n\n  /**\n   * Determines if the function can legally have the @this annotation.\n   *\n   * <p>In particular, functions declared in the following manner <em>cannot</em> have the @this\n   * annotation:\n   * <ul>\n   * <li>function statements (see the function in case Token.FUNCTION)\n   * <li>function expressions under certain operators (OR, AND, COMMA)\n   * <li>functions assigned to anything except variables.\n   * <li>functions assigned to variables with complex or non-assignment RHS expressions.\n   * </ul>\n   *\n   * <p>It has already been determined that this is a function node.\n   * @return Whether the function can legally have the @this annotation.\n   */\n  private static boolean canHaveThisAnnotation(Node fnNode) {\n    Preconditions.checkArgument(\n        fnNode.isFunction(), \"Expected function node instead of %s\", fnNode);\n\n    // declarations don't need to be used in an assignment context.\n    Node parent = fnNode.getParent();\n    if (parent.isDeclaration()) {\n      return true;\n    }\n\n    Node refParent = NodeUtil.getBestLValueReferenceParent(fnNode);\n    \n    // refParent is null if fnNode's name is not an lvalue, like in `(function(name)` or `()`,\n    // which can't have an @this annotation since its name can't be used to refer to it.\n    if (refParent == null) {\n      return false;\n    }\n\n    // The function is being assigned to something.\n    if (refParent.isAssign()) {\n      Node assignTarget = refParent.getFirstChild();\n      if (!assignTarget.isQualifiedName()) {\n        // Assignment dereferences should be assignment targets too.\n        return false;\n      }\n      return fnNode.getString().equals(refParent.getLastChild().getString());\n    }\n\n    // Cannot chain \".\"\n    if (NodeUtil.isNormalGet(refParent.getParent())) {\n      return false;\n    }\n\n    // Can't reference a fn that's a direct child of an OR.\n    if (refParent.isOr()\n        && NodeUtil.getBooleanValue(refParent.getFirstChild())) {\n      return false;\n    }\n    // Can't reference a fn that's a direct child of an AND.\n    if (refParent.isAnd()\n        && !NodeUtil.getBooleanValue(refParent.getFirstChild())) {\n      return false;\n    }\n\n    // Non-assignment, non-declaration function statement.\n    return false;\n  }\n\n  private static boolean isLentToPrototype(Node parent) {\n    if (parent == null || !NodeUtil.isGet(parent)) {\n      return false;\n    }\n\n    Node getTarget = parent.getFirstChild();\n    Node lastChild = getTarget.getLastChild();\n    if (!lastChild.getString().equals(\"prototype\")) {\n      return false;\n    }\n    return true;\n  }\n\n  private static boolean isFunctionNameAllowedInExpression(Node parent) {\n    if (parent == null) {\n      return false;\n    }\n\n    int type = parent.getType();\n\n    if (type == Token.SCRIPT || // var a = function() {};\n        type == Token.BLOCK || // { var a = function() {}; }\n        type == Token.LABEL) { // label: function() {}\n      return true;\n    }\n\n    if (type == Token.EXPR_RESULT) {\n      Node expr = parent.getFirstChild();\n      int exprType = expr.getType();\n\n      if (exprType == Token.ASSIGN || // a = function() {};\n          exprType == Token.HOOK || // a ? function() {} : b;\n          exprType == Token.COMMA || // a, function() {};\n          exprType == Token.BITOR || // a | function() {};\n          exprType == Token.BITXOR || // a ^ function() {};\n          exprType == Token.BITAND || // a & function() {};\n          exprType == Token.SHEQ || // a === function() {};\n          exprType == Token.SHNE || // a !== function() {};\n          exprType == Token.EQ || // a == function() {};\n          exprType == Token.NE || // a != function() {};\n          exprType == Token.LT || // a < function() {};\n          exprType == Token.LE || // a <= function() {};\n          exprType == Token.GT || // a > function() {};\n          exprType == Token.GE || // a >= function() {};\n          exprType == Token.INSTANCEOF || // a instanceof function() {};\n          exprType == Token.TYPEOF || // typeof function() {};\n          exprType == Token.VOID || // void function() {};\n          exprType == Token.NOT || // !function() {};\n          exprType == Token.BITNOT || // ~function() {}\n          exprType == Token.NEW || // new function() {};\n          exprType == Token.DELPROP) {\n        return true;\n      }\n    }\n\n    return false;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..085f7b8f 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,162 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+    if (n.getJSDocInfo() != null &&\n+        (n.getJSDocInfo().isConstructor() ||\n+         n.getJSDocInfo().isInterface() ||\n+         n.getJSDocInfo().isOverride())) {\n+      return false;\n+    }\n+\n+    if (parent != null && parent.getType() == Token.ASSIGN) {\n+      Node lhs = parent.getFirstChild();\n+      Node rhs = lhs.getNext();\n+      if (n == lhs && lhs.getType() == Token.NAME) {\n+        return true;\n+      }\n+      if (lhs.getType() == Token.GETPROP) {\n+        Node object = lhs.getFirstChild();\n+        if (object.getType() == Token.NAME && \"prototype\".equals(lhs.getLastChild().getString())) {\n+          return false;\n+        }\n+      }\n+    }\n+\n+    if (n.getType() == Token.FUNCTION) {\n+      if (isLentToPrototype(parent)) {\n+        return false;\n+      }\n+      if (!canHaveThisAnnotation(n)) {\n+        return false;\n+      }\n+      if (!isFunctionNameAllowedInExpression(parent)) {\n+\t\t    return false;\n+      }\n+    }\n+\n+    return true;\n+  }\n+\n+  /**\n+   * Determines if the function can legally have the @this annotation.\n+   *\n+   * <p>In particular, functions declared in the following manner <em>cannot</em> have the @this\n+   * annotation:\n+   * <ul>\n+   * <li>function statements (see the function in case Token.FUNCTION)\n+   * <li>function expressions under certain operators (OR, AND, COMMA)\n+   * <li>functions assigned to anything except variables.\n+   * <li>functions assigned to variables with complex or non-assignment RHS expressions.\n+   * </ul>\n+   *\n+   * <p>It has already been determined that this is a function node.\n+   * @return Whether the function can legally have the @this annotation.\n+   */\n+  private static boolean canHaveThisAnnotation(Node fnNode) {\n+    Preconditions.checkArgument(\n+        fnNode.isFunction(), \"Expected function node instead of %s\", fnNode);\n+\n+    // declarations don't need to be used in an assignment context.\n+    Node parent = fnNode.getParent();\n+    if (parent.isDeclaration()) {\n+      return true;\n+    }\n+\n+    Node refParent = NodeUtil.getBestLValueReferenceParent(fnNode);\n+    \n+    // refParent is null if fnNode's name is not an lvalue, like in `(function(name)` or `()`,\n+    // which can't have an @this annotation since its name can't be used to refer to it.\n+    if (refParent == null) {\n+      return false;\n+    }\n+\n+    // The function is being assigned to something.\n+    if (refParent.isAssign()) {\n+      Node assignTarget = refParent.getFirstChild();\n+      if (!assignTarget.isQualifiedName()) {\n+        // Assignment dereferences should be assignment targets too.\n+        return false;\n+      }\n+      return fnNode.getString().equals(refParent.getLastChild().getString());\n+    }\n+\n+    // Cannot chain \".\"\n+    if (NodeUtil.isNormalGet(refParent.getParent())) {\n+      return false;\n+    }\n+\n+    // Can't reference a fn that's a direct child of an OR.\n+    if (refParent.isOr()\n+        && NodeUtil.getBooleanValue(refParent.getFirstChild())) {\n+      return false;\n+    }\n+    // Can't reference a fn that's a direct child of an AND.\n+    if (refParent.isAnd()\n+        && !NodeUtil.getBooleanValue(refParent.getFirstChild())) {\n+      return false;\n+    }\n+\n+    // Non-assignment, non-declaration function statement.\n+    return false;\n+  }\n+\n+  private static boolean isLentToPrototype(Node parent) {\n+    if (parent == null || !NodeUtil.isGet(parent)) {\n+      return false;\n+    }\n+\n+    Node getTarget = parent.getFirstChild();\n+    Node lastChild = getTarget.getLastChild();\n+    if (!lastChild.getString().equals(\"prototype\")) {\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  private static boolean isFunctionNameAllowedInExpression(Node parent) {\n+    if (parent == null) {\n+      return false;\n+    }\n+\n+    int type = parent.getType();\n+\n+    if (type == Token.SCRIPT || // var a = function() {};\n+        type == Token.BLOCK || // { var a = function() {}; }\n+        type == Token.LABEL) { // label: function() {}\n+      return true;\n+    }\n+\n+    if (type == Token.EXPR_RESULT) {\n+      Node expr = parent.getFirstChild();\n+      int exprType = expr.getType();\n+\n+      if (exprType == Token.ASSIGN || // a = function() {};\n+          exprType == Token.HOOK || // a ? function() {} : b;\n+          exprType == Token.COMMA || // a, function() {};\n+          exprType == Token.BITOR || // a | function() {};\n+          exprType == Token.BITXOR || // a ^ function() {};\n+          exprType == Token.BITAND || // a & function() {};\n+          exprType == Token.SHEQ || // a === function() {};\n+          exprType == Token.SHNE || // a !== function() {};\n+          exprType == Token.EQ || // a == function() {};\n+          exprType == Token.NE || // a != function() {};\n+          exprType == Token.LT || // a < function() {};\n+          exprType == Token.LE || // a <= function() {};\n+          exprType == Token.GT || // a > function() {};\n+          exprType == Token.GE || // a >= function() {};\n+          exprType == Token.INSTANCEOF || // a instanceof function() {};\n+          exprType == Token.TYPEOF || // typeof function() {};\n+          exprType == Token.VOID || // void function() {};\n+          exprType == Token.NOT || // !function() {};\n+          exprType == Token.BITNOT || // ~function() {}\n+          exprType == Token.NEW || // new function() {};\n+          exprType == Token.DELPROP) {\n+        return true;\n+      }\n+    }\n+\n+    return false;\n+  }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}