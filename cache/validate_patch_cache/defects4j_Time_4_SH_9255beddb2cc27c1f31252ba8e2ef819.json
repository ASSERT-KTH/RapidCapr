{
    "patch": "if (unitField.isSupported()) {\n    for (; i < iTypes.length; i++) {\n        DateTimeFieldType loopType = iTypes[i];\n        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n        if (loopUnitField.isSupported()) {\n            int compare = unitField.compareTo(loopUnitField);\n            if (compare > 0) {\n                break;\n            } else if (compare == 0) {\n                DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                if (rangeField.compareTo(loopRangeField) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n    // find correct insertion point to keep largest-smallest order\n    System.arraycopy(iTypes, 0, newTypes, 0, i);\n    System.arraycopy(iValues, 0, newValues, 0, i);\n    newTypes[i] = fieldType;\n    newValues[i] = value;\n    System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n    System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n    // use public constructor to ensure full validation\n    // this isn't overly efficient, but is safe\n    Partial newPartial = new Partial(iChronology, newTypes, newValues);\n    iChronology.validate(newPartial, newValues);\n    return newPartial;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 0d4edf47..78267b96 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,36 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+if (unitField.isSupported()) {\n+    for (; i < iTypes.length; i++) {\n+        DateTimeFieldType loopType = iTypes[i];\n+        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+        if (loopUnitField.isSupported()) {\n+            int compare = unitField.compareTo(loopUnitField);\n+            if (compare > 0) {\n+                break;\n+            } else if (compare == 0) {\n+                DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n+                DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                if (rangeField.compareTo(loopRangeField) > 0) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+    // find correct insertion point to keep largest-smallest order\n+    System.arraycopy(iTypes, 0, newTypes, 0, i);\n+    System.arraycopy(iValues, 0, newValues, 0, i);\n+    newTypes[i] = fieldType;\n+    newValues[i] = value;\n+    System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n+    System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n+    // use public constructor to ensure full validation\n+    // this isn't overly efficient, but is safe\n+    Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+    iChronology.validate(newPartial, newValues);\n+    return newPartial;\n+}\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}