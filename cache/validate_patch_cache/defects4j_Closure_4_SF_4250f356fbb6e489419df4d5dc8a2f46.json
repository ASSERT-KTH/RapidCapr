{
    "patch": "import com.google.javascript.jscomp.DiagnosticGroup;\nimport com.google.javascript.jscomp.ErrorManager;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.WarningLevel;\n\nimport java.util.List;\nimport java.util.logging.Level;\nimport java.util.logging.Logger;\nimport java.util.regex.Matcher;\nimport java.util.regex.Pattern;\n\nimport com.google.common.base.Charsets;\nimport com.google.common.collect.Lists;\nimport com.google.common.io.CharSource;\nimport com.google.common.io.CharStreams;\nimport com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.ControlFlowAnalysis;\nimport com.google.javascript.jscomp.ControlFlowGraph;\nimport com.google.javascript.jscomp.DiagnosticGroups;\nimport com.google.javascript.jscomp.GraphvizGraph;\nimport com.google.javascript.jscomp.JSCompiler;\nimport com.google.javascript.jscomp.JSError;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\n\npublic class AutomaticProgramRepairTool {\n  private final AbstractCompiler compiler;\n  private final String jsSource;\n\n  public AutomaticProgramRepairTool(String jsSource) {\n    this.jsSource = jsSource;\n    this.compiler = new JSCompiler();\n    CompilerOptions options = new CompilerOptions();\n    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n\n    List<SourceFile> inputs = Lists.newArrayList();\n    inputs.add(SourceFile.fromCode(\"input\", jsSource));\n    compiler.compile(new ArrayList<SourceFile>(), inputs, options);\n  }\n\n  private ControlFlowGraph<Node> getCfg() {\n    ControlFlowAnalysis<Node> cfa = new ControlFlowAnalysis<Node>(compiler, false, false);\n    cfa.process(null, compiler.getTopScope());\n    return cfa.getCfg();\n  }\n\n  private boolean hasExceptionHandler(Node cfgNode) {\n    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n      if (edge.getValue() == Branch.ON_EX) {\n        return true;\n      }\n    }\n    return false;\n  }\n\n  private static class ErrorReporterImpl implements ErrorReporter {\n    private final ErrorManager errorManager;\n\n    public ErrorReporterImpl(ErrorManager errorManager) {\n      this.errorManager = errorManager;\n    }\n\n    @Override\n    public void warning(String message, JSError error) {\n      errorManager.reportWarning(error);\n    }\n\n    @Override\n    public void error(String message, JSError error) {\n      errorManager.report(CheckLevel.ERROR, error);\n    }\n\n    @Override\n    public void error(String message) {\n      throw new IllegalStateException(message);\n    }\n\n    @Override\n    public void errorTree(Node n, String message) {\n      DiagnosticGroups.DEPRECATED.report(\n          CheckLevel.ERROR, errorManager, n, message);\n    }\n  }\n\n  private static CharSource jsCharSource(final String jsSource) {\n    return new CharSource() {\n      @Override\n      public Reader openStream() throws IOException {\n        return new StringReader(jsSource);\n      }\n    };\n  }\n\n  private static Logger getLogger() {\n    Logger logger = Logger.getLogger(\"APRTool\");\n    logger.setLevel(Level.WARNING);\n    return logger;\n  }\n\n  public static String getErrorMessage(JSError e) {\n    String description;\n    if (e.getSourceName() != null) {\n      description = e.getSourceName();\n      if (e.getLineno() != -1) {\n        description += \":\" + (e.getLineno() + 1);\n        if (e.getCharno() != -1) {\n          description += \":\" + (e.getCharno() + 1);\n        }\n        description += \": \";\n      } else {\n        description += \": \";\n      }\n    } else {\n      description = \"\";\n    }\n    description += e.description;\n    return description;\n  }\n\n\n  public String runTest(String testName) {\n    final String regex = \"test\\\\((.*)\\\\)\";\n    final Pattern pattern = Pattern.compile(regex);\n\n    Node script = compilerJsInput(false, jsSource);\n\n    List<Node> externs = Lists.newArrayList();\n    for (Node n : script.children()) {\n      if (isExternFunction(n)) {\n        externs.add(n);\n      } else {\n        NodeTraversal.traverse(compiler, n, new NodeTraversal.AbstractPreOrderCallback() {\n          @Override\n          public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n            if (n.isCall() && n.getFirstChild().isName()\n                && n.getFirstChild().getString().equals(\"test\")) {\n              Matcher matcher = pattern.matcher(n.toStringTree());\n              if (matcher.find()) {\n                String test = matcher.group(1);\n                if (test.equals(testName)) {\n                  runTestCompiler(t.getInput(), n);\n                  return false;\n                }\n              }\n            }\n            return true;\n          }\n        });\n      }\n    }\n\n    throw new IllegalArgumentException(\"Test not found: \" + testName);\n  }\n\n  private Node compilerJsInput(boolean isExtern, String inputJs) {\n    return compiler.parse(SourceFile.fromCode(isExtern ? \"extern\" : \"input\", inputJs));\n  }\n\n  private static boolean isExternFunction(Node node) {\n    return node.isFunction() && node.getFirstChild().getString().startsWith(\"EXTERN\");\n  }\n\n  private void runTestCompiler(String inputJs, Node n) {\n    Node scopeRoot = NodeUtil.getEnclosingScopeRoot(n);\n    StaticScope<JSType> scope = ScopeCreator.createScope(scopeRoot, null);\n\n    List<JSType> argTypes = Lists.newArrayList();\n    boolean expectsException = false;\n\n    for (Node arg : n.getLastChild().getChildren()) {\n      if (arg.isString()) {\n        argTypes.add(getStringType());\n      } else if (arg.isNumber()) {\n        argTypes.add(getNumberType());\n      } else if (arg.isBoolean()) {\n        argTypes.add(getBooleanType());\n      } else if (arg.isObjectLit()) {\n        argTypes.add(getTypeFromClassDef(arg));\n      } else {\n        // This is either a type literal or an expected exception\n        String code = sourceForNode(arg);\n        if (code.contains(\"throws\")) {\n          expectsException = true;\n        } else {\n          argTypes.add(parseStringAsJSType(code));\n        }\n      }\n    }\n\n    JSType type = null;\n    try {\n      type = generateExpressionType(n.getFirstChild().getNext(), scope, argTypes);\n      if (expectsException) {\n        throw new AssertionError(\"Expected an exception to be thrown\");\n      }\n      assertNotEquals(JSType.UNKNOWN, type);\n    } catch (AssertionError e) {\n      // Exception was expected\n      if (!expectsException) {\n        Description.Builder fix = Description.builder();\n        ExceptionTestGenerator generator =\n            new ExceptionTestGenerator(compiler, script);\n        fix.addAllExpectations(generator.generate(n));\n        throw new AssertionError(fix.build(), e);\n      }\n    }\n\n    assertEquals(getTypeFromClassDef(n.getLastChild().getChildAtIndex(0)), type);\n  }\n\n  private void runPatchCompiler(String inputJs, List<String> patches) {\n    Node script = compilerJsInput(false, inputJs);\n\n    Node traversalRoot = script;\n    if (generatedExternsInput != null) {\n      testMode = TestMode.PATCH_INPLACE;\n      traversalRoot = compilerJsInput(true, generatedExternsInput + \"\\n\\n\" + inputJs);\n    }\n\n    StaticScope<JSType> scope =\n        ScopeCreator.createScope(NodeUtil.getEnclosingScopeRoot(traversalRoot), null);\n\n    List<Description> descriptions = Lists.newArrayList();\n    for (String patch : patches) {\n      Node patchedTree = CharSource.wrap(patch)\n          .readLines(new LineProcessor<Node>() {\n            @Override\n            public boolean processLine(String line) throws IOException {\n              return true;\n            }\n\n            @Override\n            public Node getResult() {\n              return compiler.parse(SourceFile.fromCode(\"patch\", patch));\n            }\n          });\n      ApplySuggestedFixes transformer = new ApplySuggestedFixes(\n          ImmutableList.of(\n              new SuggestedFix(patchedTree, new Description.Builder())));\n      NodeTraversal.traverse(compiler, patchAsScript.apply(patchedTree), transformer);\n\n      Description description = transformer.getDescription();\n      if (description.describesFix()) {\n        descriptions.add(description);\n      } else {\n        getLogger().warning(String.format(\n            \"Patch failed to produce suggested fixes: %s\", patch));\n      }\n    }\n\n    List<SourceFile> inputs = ImmutableList.of(\n        SourceFile.fromCode(\"input\", inputJs));\n\n    List<SourceFile> generatedExterns = Collections.emptyList();\n    if (generatedExternsInput != null) {\n      generatedExterns = ImmutableList.of(\n          SourceFile.fromCode(\"externs\", generatedExternsInput));\n    }\n\n    CompilerOptions options = new CompilerOptions();\n\n    StringWriter out = new StringWriter();\n    ErrorManager errorManager = new BasicErrorManager() {\n      @Override\n      public void println(CheckLevel level, JSError error) {\n        // Ignore warnings, as we only care about errors\n        if (level == CheckLevel.ERROR) {\n          idToDescription.put(error.getErrorId(), Description.of(getErrorMessage(error)));\n        }\n      }\n    };\n    options.setErrorManager(errorManager);\n    options.setDiagnosticGroups(DiagnosticGroups.makeHighSeverityGroups());\n    options.setDebugLogDirectory(\"/tmp/\");\n\n    JSCompiler compiler = new JSCompiler(errorManager, new ModulesProcessor(), options);\n    List<SourceFile> externs = GatherExternsUtil.getPlatformExterns();\n\n    compiler.compileModules(\n        externs, inputs, generatedExterns, options, null, null, descriptions, ImmutableList.of());\n    if (idToDescription.size() == 0) {\n      // If no errors were reported, then the patch was successful,\n      // and we only need to print the resulting JavaScript\n      compiler.toSource(compiler.getTopScope());\n      CharStreams.write(jsCharSource(out.toString()), new CharSink() {\n        @Override\n        public Writer openStream() {\n          return new OutputStreamWriter(System.out);\n        }\n      });\n    } else {\n      // If errors were reported, then we only print the messages\n      for (Map.Entry<String, Description> entry : idToDescription.entrySet()) {\n        getLogger().severe(entry.getValue().getMessage());\n        if (entry.getValue().hasFixes()) {\n          Description.Fix rootFix = entry.getValue().getFix();\n          ImmutableList<Description.Fix> fixes = rootFix.getChildren();\n\n          if (fixes != null) {\n            for (Description.Fix fix : fixes) {\n              System.out.println(fix.getFilePath() + \":\");\n              System.out.println(fix.getLineNum() + \":\" + fix.getCharOffset());\n              System.out.println(fix.getMessage());\n              System.out.println(fix.getCodeSnippet());\n              System.out.println();\n            }\n          }\n        }\n      }\n      System.exit(1);\n    }\n  }\n\n  private JSType parseStringAsJSType(String s) {\n    JSTypeRegistry registry = getTypeRegistry();\n    JSType alias = registry.getGlobalType(\"alias\");\n    Node typeNode = null;\n    try {\n      typeNode = compiler.parseSyntheticCode(\"var x = \" + s).getFirstChild().getFirstChild();\n    } catch (Exception e) {\n      throw new IllegalStateException(\"Could not parse string as JSType: \" + s, e);\n    }\n    JSType parsedType = getJSType(typeNode);\n    parsedType.setAlias(alias);\n    return parsedType;\n  }\n\n  private JSType generateExpressionType(Node expr, StaticScope<JSType> scope,\n      List<JSType> argTypes) {\n    return getTypeInEnvironment(expr, createTypeEnvironment(expr, scope, argTypes));\n  }\n\n  private StaticScope<JSType> createTypeEnvironment(Node expr, StaticScope<JSType> scope,\n      List<JSType> argTypes) {\n    StaticScope.Builder<JSType> builder = StaticScope.builder(scope).isGlobal(false);\n    NodeTraversal.traverse(compiler, expr, new TypeEnvBuilder(builder, argTypes));\n    return builder.build();\n  }\n\n  private JSType getTypeInEnvironment(Node expr, final StaticScope<JSType> env) {\n    JSType result = NodeUtil.getBestJSType(expr);\n    if (result == null) {\n      throw new IllegalStateException(\"Could not determine type for node: \" + expr);\n    }\n    if (result.isLate()) {\n      result = result.resolve(getTypeRegistry()).evaluate(null);\n    }\n    return result.visit(new JSType.AbstractVisitor<JSType>() {\n      private final Set<JSType> visitedTypes = Sets.newHashSet();\n      @Override\n      public JSType visitNonNullType(JSType type) {\n        if (visitedTypes.add(type)) {\n          TypeValidator validator = new TypeValidator(compiler, getTypeRegistry(), type);\n          validator.traverse(env.getRootNode());\n        }\n        return type;\n      }\n      @Override\n      public JSType visitUnionType(JSType type) {\n        visit(type.getAlternates());\n        return type;\n      }\n    });\n  }\n\n  private JSType getTypeFromClassDef(Node classDef) {\n    JSTypeRegistry registry = getTypeRegistry();\n    String typeName = classDef.getFirstChild().getQualifiedName();\n    JSType type = registry.getGlobalType(typeName);\n    if (type == null) {\n      type = registry.createUnionType(Lists.<JSType>newArrayList());\n    }\n  ",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/NamedType.java b/src/com/google/javascript/rhino/jstype/NamedType.java\nindex 70142c45..e96bfc85 100644\n--- a/src/com/google/javascript/rhino/jstype/NamedType.java\n+++ b/src/com/google/javascript/rhino/jstype/NamedType.java\n@@ -181,36 +181,385 @@ class NamedType extends ProxyObjectType {\n    * Resolve the referenced type within the enclosing scope.\n    */\n   @Override\n-  JSType resolveInternal(ErrorReporter t, StaticScope<JSType> enclosing) {\n-    // TODO(user): Investigate whether it is really necessary to keep two\n-    // different mechanisms for resolving named types, and if so, which order\n-    // makes more sense. Now, resolution via registry is first in order to\n-    // avoid triggering the warnings built into the resolution via properties.\n-    boolean resolved = resolveViaRegistry(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n-      handleTypeCycle(t);\n+import com.google.javascript.jscomp.DiagnosticGroup;\n+import com.google.javascript.jscomp.ErrorManager;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.jscomp.WarningLevel;\n+\n+import java.util.List;\n+import java.util.logging.Level;\n+import java.util.logging.Logger;\n+import java.util.regex.Matcher;\n+import java.util.regex.Pattern;\n+\n+import com.google.common.base.Charsets;\n+import com.google.common.collect.Lists;\n+import com.google.common.io.CharSource;\n+import com.google.common.io.CharStreams;\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.ControlFlowAnalysis;\n+import com.google.javascript.jscomp.ControlFlowGraph;\n+import com.google.javascript.jscomp.DiagnosticGroups;\n+import com.google.javascript.jscomp.GraphvizGraph;\n+import com.google.javascript.jscomp.JSCompiler;\n+import com.google.javascript.jscomp.JSError;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph.DiGraphNode;\n+import com.google.javascript.rhino.Node;\n+\n+public class AutomaticProgramRepairTool {\n+  private final AbstractCompiler compiler;\n+  private final String jsSource;\n+\n+  public AutomaticProgramRepairTool(String jsSource) {\n+    this.jsSource = jsSource;\n+    this.compiler = new JSCompiler();\n+    CompilerOptions options = new CompilerOptions();\n+    WarningLevel.VERBOSE.setOptionsForWarningLevel(options);\n+\n+    List<SourceFile> inputs = Lists.newArrayList();\n+    inputs.add(SourceFile.fromCode(\"input\", jsSource));\n+    compiler.compile(new ArrayList<SourceFile>(), inputs, options);\n+  }\n+\n+  private ControlFlowGraph<Node> getCfg() {\n+    ControlFlowAnalysis<Node> cfa = new ControlFlowAnalysis<Node>(compiler, false, false);\n+    cfa.process(null, compiler.getTopScope());\n+    return cfa.getCfg();\n+  }\n+\n+  private boolean hasExceptionHandler(Node cfgNode) {\n+    List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+    for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+      if (edge.getValue() == Branch.ON_EX) {\n+        return true;\n+      }\n     }\n+    return false;\n+  }\n+\n+  private static class ErrorReporterImpl implements ErrorReporter {\n+    private final ErrorManager errorManager;\n \n-    if (resolved) {\n-      super.resolveInternal(t, enclosing);\n-      finishPropertyContinuations();\n-      return registry.isLastGeneration() ?\n-          getReferencedType() : this;\n+    public ErrorReporterImpl(ErrorManager errorManager) {\n+      this.errorManager = errorManager;\n     }\n \n-    resolveViaProperties(t, enclosing);\n-    if (detectImplicitPrototypeCycle()) {\n-      handleTypeCycle(t);\n+    @Override\n+    public void warning(String message, JSError error) {\n+      errorManager.reportWarning(error);\n+    }\n+\n+    @Override\n+    public void error(String message, JSError error) {\n+      errorManager.report(CheckLevel.ERROR, error);\n+    }\n+\n+    @Override\n+    public void error(String message) {\n+      throw new IllegalStateException(message);\n+    }\n+\n+    @Override\n+    public void errorTree(Node n, String message) {\n+      DiagnosticGroups.DEPRECATED.report(\n+          CheckLevel.ERROR, errorManager, n, message);\n+    }\n+  }\n+\n+  private static CharSource jsCharSource(final String jsSource) {\n+    return new CharSource() {\n+      @Override\n+      public Reader openStream() throws IOException {\n+        return new StringReader(jsSource);\n+      }\n+    };\n+  }\n+\n+  private static Logger getLogger() {\n+    Logger logger = Logger.getLogger(\"APRTool\");\n+    logger.setLevel(Level.WARNING);\n+    return logger;\n+  }\n+\n+  public static String getErrorMessage(JSError e) {\n+    String description;\n+    if (e.getSourceName() != null) {\n+      description = e.getSourceName();\n+      if (e.getLineno() != -1) {\n+        description += \":\" + (e.getLineno() + 1);\n+        if (e.getCharno() != -1) {\n+          description += \":\" + (e.getCharno() + 1);\n+        }\n+        description += \": \";\n+      } else {\n+        description += \": \";\n+      }\n+    } else {\n+      description = \"\";\n+    }\n+    description += e.description;\n+    return description;\n+  }\n+\n+\n+  public String runTest(String testName) {\n+    final String regex = \"test\\\\((.*)\\\\)\";\n+    final Pattern pattern = Pattern.compile(regex);\n+\n+    Node script = compilerJsInput(false, jsSource);\n+\n+    List<Node> externs = Lists.newArrayList();\n+    for (Node n : script.children()) {\n+      if (isExternFunction(n)) {\n+        externs.add(n);\n+      } else {\n+        NodeTraversal.traverse(compiler, n, new NodeTraversal.AbstractPreOrderCallback() {\n+          @Override\n+          public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+            if (n.isCall() && n.getFirstChild().isName()\n+                && n.getFirstChild().getString().equals(\"test\")) {\n+              Matcher matcher = pattern.matcher(n.toStringTree());\n+              if (matcher.find()) {\n+                String test = matcher.group(1);\n+                if (test.equals(testName)) {\n+                  runTestCompiler(t.getInput(), n);\n+                  return false;\n+                }\n+              }\n+            }\n+            return true;\n+          }\n+        });\n+      }\n+    }\n+\n+    throw new IllegalArgumentException(\"Test not found: \" + testName);\n+  }\n+\n+  private Node compilerJsInput(boolean isExtern, String inputJs) {\n+    return compiler.parse(SourceFile.fromCode(isExtern ? \"extern\" : \"input\", inputJs));\n+  }\n+\n+  private static boolean isExternFunction(Node node) {\n+    return node.isFunction() && node.getFirstChild().getString().startsWith(\"EXTERN\");\n+  }\n+\n+  private void runTestCompiler(String inputJs, Node n) {\n+    Node scopeRoot = NodeUtil.getEnclosingScopeRoot(n);\n+    StaticScope<JSType> scope = ScopeCreator.createScope(scopeRoot, null);\n+\n+    List<JSType> argTypes = Lists.newArrayList();\n+    boolean expectsException = false;\n+\n+    for (Node arg : n.getLastChild().getChildren()) {\n+      if (arg.isString()) {\n+        argTypes.add(getStringType());\n+      } else if (arg.isNumber()) {\n+        argTypes.add(getNumberType());\n+      } else if (arg.isBoolean()) {\n+        argTypes.add(getBooleanType());\n+      } else if (arg.isObjectLit()) {\n+        argTypes.add(getTypeFromClassDef(arg));\n+      } else {\n+        // This is either a type literal or an expected exception\n+        String code = sourceForNode(arg);\n+        if (code.contains(\"throws\")) {\n+          expectsException = true;\n+        } else {\n+          argTypes.add(parseStringAsJSType(code));\n+        }\n+      }\n     }\n \n-    super.resolveInternal(t, enclosing);\n-    if (isResolved()) {\n-      finishPropertyContinuations();\n+    JSType type = null;\n+    try {\n+      type = generateExpressionType(n.getFirstChild().getNext(), scope, argTypes);\n+      if (expectsException) {\n+        throw new AssertionError(\"Expected an exception to be thrown\");\n+      }\n+      assertNotEquals(JSType.UNKNOWN, type);\n+    } catch (AssertionError e) {\n+      // Exception was expected\n+      if (!expectsException) {\n+        Description.Builder fix = Description.builder();\n+        ExceptionTestGenerator generator =\n+            new ExceptionTestGenerator(compiler, script);\n+        fix.addAllExpectations(generator.generate(n));\n+        throw new AssertionError(fix.build(), e);\n+      }\n     }\n-    return registry.isLastGeneration() ?\n-        getReferencedType() : this;\n+\n+    assertEquals(getTypeFromClassDef(n.getLastChild().getChildAtIndex(0)), type);\n   }\n \n+  private void runPatchCompiler(String inputJs, List<String> patches) {\n+    Node script = compilerJsInput(false, inputJs);\n+\n+    Node traversalRoot = script;\n+    if (generatedExternsInput != null) {\n+      testMode = TestMode.PATCH_INPLACE;\n+      traversalRoot = compilerJsInput(true, generatedExternsInput + \"\\n\\n\" + inputJs);\n+    }\n+\n+    StaticScope<JSType> scope =\n+        ScopeCreator.createScope(NodeUtil.getEnclosingScopeRoot(traversalRoot), null);\n+\n+    List<Description> descriptions = Lists.newArrayList();\n+    for (String patch : patches) {\n+      Node patchedTree = CharSource.wrap(patch)\n+          .readLines(new LineProcessor<Node>() {\n+            @Override\n+            public boolean processLine(String line) throws IOException {\n+              return true;\n+            }\n+\n+            @Override\n+            public Node getResult() {\n+              return compiler.parse(SourceFile.fromCode(\"patch\", patch));\n+            }\n+          });\n+      ApplySuggestedFixes transformer = new ApplySuggestedFixes(\n+          ImmutableList.of(\n+              new SuggestedFix(patchedTree, new Description.Builder())));\n+      NodeTraversal.traverse(compiler, patchAsScript.apply(patchedTree), transformer);\n+\n+      Description description = transformer.getDescription();\n+      if (description.describesFix()) {\n+        descriptions.add(description);\n+      } else {\n+        getLogger().warning(String.format(\n+            \"Patch failed to produce suggested fixes: %s\", patch));\n+      }\n+    }\n+\n+    List<SourceFile> inputs = ImmutableList.of(\n+        SourceFile.fromCode(\"input\", inputJs));\n+\n+    List<SourceFile> generatedExterns = Collections.emptyList();\n+    if (generatedExternsInput != null) {\n+      generatedExterns = ImmutableList.of(\n+          SourceFile.fromCode(\"externs\", generatedExternsInput));\n+    }\n+\n+    CompilerOptions options = new CompilerOptions();\n+\n+    StringWriter out = new StringWriter();\n+    ErrorManager errorManager = new BasicErrorManager() {\n+      @Override\n+      public void println(CheckLevel level, JSError error) {\n+        // Ignore warnings, as we only care about errors\n+        if (level == CheckLevel.ERROR) {\n+          idToDescription.put(error.getErrorId(), Description.of(getErrorMessage(error)));\n+        }\n+      }\n+    };\n+    options.setErrorManager(errorManager);\n+    options.setDiagnosticGroups(DiagnosticGroups.makeHighSeverityGroups());\n+    options.setDebugLogDirectory(\"/tmp/\");\n+\n+    JSCompiler compiler = new JSCompiler(errorManager, new ModulesProcessor(), options);\n+    List<SourceFile> externs = GatherExternsUtil.getPlatformExterns();\n+\n+    compiler.compileModules(\n+        externs, inputs, generatedExterns, options, null, null, descriptions, ImmutableList.of());\n+    if (idToDescription.size() == 0) {\n+      // If no errors were reported, then the patch was successful,\n+      // and we only need to print the resulting JavaScript\n+      compiler.toSource(compiler.getTopScope());\n+      CharStreams.write(jsCharSource(out.toString()), new CharSink() {\n+        @Override\n+        public Writer openStream() {\n+          return new OutputStreamWriter(System.out);\n+        }\n+      });\n+    } else {\n+      // If errors were reported, then we only print the messages\n+      for (Map.Entry<String, Description> entry : idToDescription.entrySet()) {\n+        getLogger().severe(entry.getValue().getMessage());\n+        if (entry.getValue().hasFixes()) {\n+          Description.Fix rootFix = entry.getValue().getFix();\n+          ImmutableList<Description.Fix> fixes = rootFix.getChildren();\n+\n+          if (fixes != null) {\n+            for (Description.Fix fix : fixes) {\n+              System.out.println(fix.getFilePath() + \":\");\n+              System.out.println(fix.getLineNum() + \":\" + fix.getCharOffset());\n+              System.out.println(fix.getMessage());\n+              System.out.println(fix.getCodeSnippet());\n+              System.out.println();\n+            }\n+          }\n+        }\n+      }\n+      System.exit(1);\n+    }\n+  }\n+\n+  private JSType parseStringAsJSType(String s) {\n+    JSTypeRegistry registry = getTypeRegistry();\n+    JSType alias = registry.getGlobalType(\"alias\");\n+    Node typeNode = null;\n+    try {\n+      typeNode = compiler.parseSyntheticCode(\"var x = \" + s).getFirstChild().getFirstChild();\n+    } catch (Exception e) {\n+      throw new IllegalStateException(\"Could not parse string as JSType: \" + s, e);\n+    }\n+    JSType parsedType = getJSType(typeNode);\n+    parsedType.setAlias(alias);\n+    return parsedType;\n+  }\n+\n+  private JSType generateExpressionType(Node expr, StaticScope<JSType> scope,\n+      List<JSType> argTypes) {\n+    return getTypeInEnvironment(expr, createTypeEnvironment(expr, scope, argTypes));\n+  }\n+\n+  private StaticScope<JSType> createTypeEnvironment(Node expr, StaticScope<JSType> scope,\n+      List<JSType> argTypes) {\n+    StaticScope.Builder<JSType> builder = StaticScope.builder(scope).isGlobal(false);\n+    NodeTraversal.traverse(compiler, expr, new TypeEnvBuilder(builder, argTypes));\n+    return builder.build();\n+  }\n+\n+  private JSType getTypeInEnvironment(Node expr, final StaticScope<JSType> env) {\n+    JSType result = NodeUtil.getBestJSType(expr);\n+    if (result == null) {\n+      throw new IllegalStateException(\"Could not determine type for node: \" + expr);\n+    }\n+    if (result.isLate()) {\n+      result = result.resolve(getTypeRegistry()).evaluate(null);\n+    }\n+    return result.visit(new JSType.AbstractVisitor<JSType>() {\n+      private final Set<JSType> visitedTypes = Sets.newHashSet();\n+      @Override\n+      public JSType visitNonNullType(JSType type) {\n+        if (visitedTypes.add(type)) {\n+          TypeValidator validator = new TypeValidator(compiler, getTypeRegistry(), type);\n+          validator.traverse(env.getRootNode());\n+        }\n+        return type;\n+      }\n+      @Override\n+      public JSType visitUnionType(JSType type) {\n+        visit(type.getAlternates());\n+        return type;\n+      }\n+    });\n+  }\n+\n+  private JSType getTypeFromClassDef(Node classDef) {\n+    JSTypeRegistry registry = getTypeRegistry();\n+    String typeName = classDef.getFirstChild().getQualifiedName();\n+    JSType type = registry.getGlobalType(typeName);\n+    if (type == null) {\n+      type = registry.createUnionType(Lists.<JSType>newArrayList());\n+    }\n+  \n+\n   /**\n    * Resolves a named type by looking it up in the registry.\n    * @return True if we resolved successfully.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}