{
    "patch": "          name.aliasingGets == 0) {\n        // {@code name} meets condition (b).\n        // Check that there is only one definition.\n        if (name.getDeclaration() == null) {\n          continue;\n        }\n        List<Ref> refs = Lists.newArrayList(name.getRefs());\n        boolean referencesLocalDefinitions = false;\n        for (Ref ref : refs) {\n          if (ref.type != Type.ALIASING_GET) {\n            throw new IllegalStateException(\n                \"Unexpected reference: \" + ref.type);\n          }\n          if (ref.scope.isLocal()) {\n            referencesLocalDefinitions = true;\n            break;\n          }\n        }\n        if (!referencesLocalDefinitions) {\n          continue;\n        }\n\n        // Check that inlining is safe.\n        Node enclosingStatement = null;\n        for (Ref ref : name.getRefs()) {\n          if (ref.type == Type.SET_FROM_GLOBAL && ref.getScope().isLocal()) {\n            Node n = ref.getNode();\n            Node statement = NodeUtil.getEnclosingStatement(n);\n            if (enclosingStatement == null) {\n              enclosingStatement = statement;\n            } else if (statement != enclosingStatement) {\n              // Unsafe to inline.\n              // We don't currently inline if there is more than one\n              // local assignment that is not in the same statment.\n              enclosingStatement = null;\n              break;\n            }\n          }\n        }\n\n        if (enclosingStatement != null) {\n          // {@code name} meets condition (b).\n          // {@code name} needs to be inlined.\n          List<Ref> aliasesVersions = new LinkedList<>();\n          List<Ref> localVersions = new LinkedList<>();\n          for (Ref ref : refs) {\n            if (ref.type == Type.ALIASING_GET) {\n              aliasesVersions.add(ref);\n            } else if (ref.type == Type.SET_FROM_GLOBAL &&\n                ref.getScope().isLocal()) {\n              localVersions.add(ref);\n            } else {\n              throw new IllegalStateException(\n                  \"Unexpected reference: \" + ref.type);\n            }\n          }\n          checkState(aliasesVersions.size() > 0,\n                      \"Encountered reference without an aliases.\");\n          checkState(localVersions.size() > 0,\n                      \"Encountered reference without a local definition.\");\n\n          // Pick the version of the name to use for each remaining reference.\n          Ref preferredRef = localVersions.get(0);\n          for (Ref ref : aliasesVersions) {\n            ref.getNode().replaceWith(preferredRef.getNode().cloneTree());\n            ref.getScope().undeclareName(ref);\n          }\n          name.clearRefs();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..327e13a4 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,74 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+          name.aliasingGets == 0) {\n+        // {@code name} meets condition (b).\n+        // Check that there is only one definition.\n+        if (name.getDeclaration() == null) {\n+          continue;\n+        }\n+        List<Ref> refs = Lists.newArrayList(name.getRefs());\n+        boolean referencesLocalDefinitions = false;\n+        for (Ref ref : refs) {\n+          if (ref.type != Type.ALIASING_GET) {\n+            throw new IllegalStateException(\n+                \"Unexpected reference: \" + ref.type);\n+          }\n+          if (ref.scope.isLocal()) {\n+            referencesLocalDefinitions = true;\n+            break;\n+          }\n+        }\n+        if (!referencesLocalDefinitions) {\n+          continue;\n+        }\n+\n+        // Check that inlining is safe.\n+        Node enclosingStatement = null;\n+        for (Ref ref : name.getRefs()) {\n+          if (ref.type == Type.SET_FROM_GLOBAL && ref.getScope().isLocal()) {\n+            Node n = ref.getNode();\n+            Node statement = NodeUtil.getEnclosingStatement(n);\n+            if (enclosingStatement == null) {\n+              enclosingStatement = statement;\n+            } else if (statement != enclosingStatement) {\n+              // Unsafe to inline.\n+              // We don't currently inline if there is more than one\n+              // local assignment that is not in the same statment.\n+              enclosingStatement = null;\n+              break;\n+            }\n+          }\n+        }\n+\n+        if (enclosingStatement != null) {\n+          // {@code name} meets condition (b).\n+          // {@code name} needs to be inlined.\n+          List<Ref> aliasesVersions = new LinkedList<>();\n+          List<Ref> localVersions = new LinkedList<>();\n+          for (Ref ref : refs) {\n+            if (ref.type == Type.ALIASING_GET) {\n+              aliasesVersions.add(ref);\n+            } else if (ref.type == Type.SET_FROM_GLOBAL &&\n+                ref.getScope().isLocal()) {\n+              localVersions.add(ref);\n+            } else {\n+              throw new IllegalStateException(\n+                  \"Unexpected reference: \" + ref.type);\n+            }\n+          }\n+          checkState(aliasesVersions.size() > 0,\n+                      \"Encountered reference without an aliases.\");\n+          checkState(localVersions.size() > 0,\n+                      \"Encountered reference without a local definition.\");\n+\n+          // Pick the version of the name to use for each remaining reference.\n+          Ref preferredRef = localVersions.get(0);\n+          for (Ref ref : aliasesVersions) {\n+            ref.getNode().replaceWith(preferredRef.getNode().cloneTree());\n+            ref.getScope().undeclareName(ref);\n+          }\n+          name.clearRefs();\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: not a statement",
    "test_result": "ERROR"
}