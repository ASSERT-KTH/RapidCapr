{
    "patch": "            // calculate the next and previous transition times for both instants\n            long nextLocal = nextTransition(instantAdjusted);\n            long prevLocal = previousTransition(instantAdjusted);\n            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n            long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n\n            // check for same next transition for both times\n            if (nextLocal == nextAdjusted) {\n                // get the difference in offset between the current and next offset\n                int offsetDiff = offsetAdjusted - offsetLocal;\n\n                // ensure that both the next and previous transitions fall before or after\n                // the current local time depending on offset diff\n                boolean okNextLocal = (nextLocal - instantAdjusted >= offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n                boolean okNextAdjusted = (nextAdjusted - instantLocal >= offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n                boolean okPrevLocal = (instantAdjusted - prevLocal >= -offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n                boolean okPrevAdjusted = (instantLocal - prevAdjusted >= -offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n\n                // if all conditions are met, then return the local offset\n                if (okNextLocal && okNextAdjusted && okPrevLocal && okPrevAdjusted) {\n                    return offsetLocal;\n                }\n            } else {\n                // get the offsets for both the previous and next transition times\n                int offsetBeforeLocal = getOffset(nextLocal - 1);\n                int offsetBeforeAdjusted = getOffset(nextAdjusted - 1);\n                int offsetAfterLocal = getOffset(nextLocal);\n                int offsetAfterAdjusted = getOffset(nextAdjusted);\n\n                // if the offset difference is greater than or equal to 2 hours and\n                // the next and previous transitions for both times are different,\n                // return the local offset\n                if (Math.abs(offsetAfterAdjusted - offsetBeforeAdjusted) >= 2 &&\n                    nextLocal != prevLocal &&\n                    nextAdjusted != prevAdjusted) {\n                    return offsetLocal;\n                }\n\n                // based on whether the offset difference is positive or negative,\n                // determine the offset to return\n                if (offsetAdjusted > offsetLocal) {\n                    // if the current local time is already using the later offset,\n                    // use the later offset\n                    if (offsetLocal < offsetAfterLocal) {\n                        return offsetAfterLocal;\n                    } else {\n                        return offsetLocal;\n                    }\n                } else {\n                    // if the current local time is already using the earlier offset,\n                    // use the earlier offset\n                    if (offsetLocal > offsetBeforeLocal) {\n                        return offsetBeforeLocal;\n                    } else {\n                        return offsetLocal;\n                    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..5ce993c6 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,62 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+            // calculate the next and previous transition times for both instants\n+            long nextLocal = nextTransition(instantAdjusted);\n+            long prevLocal = previousTransition(instantAdjusted);\n+            long nextAdjusted = nextTransition(instantLocal - offsetAdjusted);\n+            long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n+\n+            // check for same next transition for both times\n+            if (nextLocal == nextAdjusted) {\n+                // get the difference in offset between the current and next offset\n+                int offsetDiff = offsetAdjusted - offsetLocal;\n+\n+                // ensure that both the next and previous transitions fall before or after\n+                // the current local time depending on offset diff\n+                boolean okNextLocal = (nextLocal - instantAdjusted >= offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n+                boolean okNextAdjusted = (nextAdjusted - instantLocal >= offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n+                boolean okPrevLocal = (instantAdjusted - prevLocal >= -offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n+                boolean okPrevAdjusted = (instantLocal - prevAdjusted >= -offsetDiff * DateTimeConstants.MILLIS_PER_HOUR);\n+\n+                // if all conditions are met, then return the local offset\n+                if (okNextLocal && okNextAdjusted && okPrevLocal && okPrevAdjusted) {\n+                    return offsetLocal;\n+                }\n+            } else {\n+                // get the offsets for both the previous and next transition times\n+                int offsetBeforeLocal = getOffset(nextLocal - 1);\n+                int offsetBeforeAdjusted = getOffset(nextAdjusted - 1);\n+                int offsetAfterLocal = getOffset(nextLocal);\n+                int offsetAfterAdjusted = getOffset(nextAdjusted);\n+\n+                // if the offset difference is greater than or equal to 2 hours and\n+                // the next and previous transitions for both times are different,\n+                // return the local offset\n+                if (Math.abs(offsetAfterAdjusted - offsetBeforeAdjusted) >= 2 &&\n+                    nextLocal != prevLocal &&\n+                    nextAdjusted != prevAdjusted) {\n+                    return offsetLocal;\n+                }\n+\n+                // based on whether the offset difference is positive or negative,\n+                // determine the offset to return\n+                if (offsetAdjusted > offsetLocal) {\n+                    // if the current local time is already using the later offset,\n+                    // use the later offset\n+                    if (offsetLocal < offsetAfterLocal) {\n+                        return offsetAfterLocal;\n+                    } else {\n+                        return offsetLocal;\n+                    }\n+                } else {\n+                    // if the current local time is already using the earlier offset,\n+                    // use the earlier offset\n+                    if (offsetLocal > offsetBeforeLocal) {\n+                        return offsetBeforeLocal;\n+                    } else {\n+                        return offsetLocal;\n+                    }\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}