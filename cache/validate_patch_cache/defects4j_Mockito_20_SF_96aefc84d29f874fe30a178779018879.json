{
    "patch": "public class MockMethodInterceptor implements Serializable, InvocationHandler, MockAccess {\n\n    @SuppressWarnings(\"unchecked\")\n    private static final Map<String, MockHandler> EMPTY_MAP = Collections.EMPTY_MAP;\n\n    private final transient MockCreationSettings settings;\n    private final transient MockHandler handler;\n    private final transient Map<String, MockHandler> mockedMethodHandlers;\n    private final transient AtomicBoolean verified;\n\n    private Map<Object, Object> arguments;\n    private AtomicBoolean stubbingMode;\n\n    public MockMethodInterceptor(MockHandler handler, MockCreationSettings settings) {\n        this.settings = settings;\n        this.handler = handler;\n        this.verified = new AtomicBoolean(false);\n        this.mockedMethodHandlers = new ConcurrentHashMap<String, MockHandler>();\n        this.stubbingMode = new AtomicBoolean(false);\n    }\n\n    @Override\n    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n        Invocation invocation = new SimpleInvocation(proxy, method, args);\n        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, this.settings.getMatchers());\n        return handleMethodCall(invocationMatcher, invocation);\n    }\n\n    public Object handleMethodCall(InvocationMatcher invocationMatcher, Invocation invocation) throws Throwable {\n        if (stubbingMode.get()) {\n            return handleStubbing(invocationMatcher);\n        }\n\n        Object ret = null;\n        try {\n            ret = handleIntercept(invocationMatcher, invocation);\n        } catch (Throwable t) {\n            if (handler.shouldBreakMockCreation(invocation, t)) {\n                throw t;\n            }\n        }\n\n        if (settings.isSerializable()) {\n            handler.getInvocationContainer().setInvocationForPotentialStubbing(invocationMatcher.getInvocation());\n        }\n\n        return ret;\n    }\n    \n    // ensure mockedMethodHandlers is initialized before being used\n    private void ensureMockedMethodHandlers() {\n        if (this.mockedMethodHandlers.isEmpty()) {\n            mockedMethodHandlers.putAll(EMPTY_MAP);\n        }\n    }\n\n    private Object handleIntercept(InvocationMatcher invocationMatcher, Invocation invocation) throws Throwable {\n        String mockitoMethodName = invocation.getMethod().getName();\n        ensureMockedMethodHandlers();\n        MockHandler handler = mockedMethodHandlers.get(mockitoMethodName);\n        if (handler == null) {\n            return handleNotFoundMethod(invocation);\n        }\n        return handler.handle(invocation);\n    }\n\n    @Override\n    public void setMockitoInterceptor(MockitoInvocationHandler mockitoInterceptor) {\n        mockedMethodHandlers.putAll(mockitoInterceptor.getHandlerForMockedMethod());\n    }\n\n    @Override\n    public Object getMock() {\n        return handler;\n    }\n\n    @Override\n    public Map<Object, Object> getArguments() {\n        if (arguments == null) {\n            arguments = new HashMap<Object, Object>();\n        }\n        return arguments;\n    }\n\n    @Override\n    public void setAnswersForStubbing(List<Answer<?>> answers) {\n        ensureMockedMethodHandlers();\n        for (Answer<?> a: answers) {\n            MockMethodAdvice advice = new MakeStubbingReal(a);\n            mockedMethodHandlers.put(advice.getIdentifier(), advice);\n        }\n    }\n\n    private Object handleStubbing(InvocationMatcher im) {\n        ensureMockedMethodHandlers();\n        try {\n            this.stubbingMode.set(false);\n            if (isVoidMethod(im.getInvocation())) {\n                MockMethodAdvice advice = new AddUnexpectedVoidCallReal(im.getInvocation());\n                Object retValue = advice.call();\n                handleResult(retValue);\n                return null;\n            } else {\n                MockMethodAdvice advice = new AddUnexpectedCallReal(im.getInvocation());\n                Object retValue = advice.call();\n                handleResult(retValue);\n                return ReturnsMoreEmptyValues.getDefaultFor(im.getInvocation().getMethod().getReturnType());\n            }\n        } catch(Throwable t) {\n            return UnfinishedStubbingReport.createReport(t, im.toString());\n        }\n    }\n\n    private void handleResult(Object retValue) {\n        verifyNoMoreInteractions();\n        if (retValue instanceof Throwable) {\n            Throwable t = (Throwable) retValue;\n            throw UnfinishedStubbingExceptionImpl.forReturnValueWasNotUsed(t);\n        }\n    }\n\n    private Object handleNotFoundMethod(Invocation invocation) throws Throwable {\n        Object ret = null;\n        if (handler.getDelegate() == null) {\n            return handleNullReturn(invocation);\n        }\n\n        try {\n            boolean wasInStubbingMode = stubbingMode.getAndSet(false);\n            ret = invocation.callRealMethod();\n            stubbingMode.set(wasInStubbingMode);\n            return ret;\n        } catch (Throwable t) {\n            boolean wasInStubbingMode = stubbingMode.getAndSet(false);\n            returnTypeMismatch(invocation.getMethod(), t);\n            return null; // Never executed but necessary to compile\n        }\n    }\n\n    private Object handleNullReturn(Invocation call) {\n        if (isSmartNullable(call.getMethod().getReturnType())) {\n            return GeneratesNulls.SmartNull.get(call.getMethod().getReturnType());\n        } else {\n            boolean wasInStubbingMode = stubbingMode.getAndSet(false);\n            Object nullValue = Defaults.defaultValue(call.getMethod().getReturnType());\n            stubbingMode.set(wasInStubbingMode);\n            return nullValue;\n        }\n    }\n\n    private boolean isVoidMethod(Invocation invocation) {\n        return Void.class == invocation.getMethod().getReturnType() || void.class == invocation.getMethod().getReturnType();\n    }\n\n    private void returnTypeMismatch(Method method, Throwable t) throws Throwable {\n        Class<?> returnType = method.getReturnType();\n        if (returnType == Void.TYPE) {\n            throw t;\n        } else if (t instanceof ClassCastException) {\n            throw t;\n        }\n        throw new MockitoException(join(\n                \"ReturnTypeMismatch\",\n                \"    \",\n                \"type wanted:<\" + returnType.getSimpleName() + \">\",\n                \"    \",\n                \"but was:<\" + t.getClass().getSimpleName() + \">\",\n                \"\",\n                \"You have not passed the correct arguments at the implementation of the verification stage of the test.\",\n                \"\",\n                \"Correct usage would be to mock the right call and leave its implementation - To-be-done.\",\n                \"\"\n        ), t);\n    }\n\n    private boolean isSmartNullable(Class<?> returnType) {\n        return returnType.isInterface() || Modifier.isAbstract(returnType.getModifiers());\n    }\n\n    void setStubbingMode(boolean stubbingMode) {\n        this.stubbingMode.set(stubbingMode);\n    }\n\n    public void verifyNoMoreInteractions() {\n        if (!verified.compareAndSet(false, true)) {\n            throw new MockitoVerificationAssertionError(join(\n                    \"No interactions wanted\",\n                    \"\",\n                    \"However, there were other interactions with this mock\",\n                    \"\",\n                    \"MockitoStubber.captureArguments() should be used directly after mock declaration\"\n            ));\n        }\n    }\n\n    public MockCreationSettings getMockSettings() {\n        return this.settings;\n    }\n\n    public boolean canCallRealMethods() {\n        return settings.isCallRealMethodForAllMocks() ||\n                settings.isSerializable() ||\n                settings.getMockCreationSettingsType() == MockSettingsType.CALLS_REAL_METHODS ||\n                handler.getMockSettings().isStubOnly();\n    }\n\n    @Override\n    public void verify(VerificationMode verificationMode) {\n        handler.verify(invocationContainer -> {\n            invocationContainer.verify(verificationMode);\n            return null;\n        });\n    }\n\n    @Override\n    public void verify(VerificationDataImpl data) {\n        handler.verify(invocationContainer -> {\n            invocationContainer.verify(data);\n            return null;\n        });\n    }\n\n    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n        in.defaultReadObject();\n        this.stubbingMode = new AtomicBoolean(false);\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\nindex 9dc44e663..d87d87c2a 100644\n--- a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n+++ b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n@@ -21,37 +21,234 @@ public class ByteBuddyMockMaker implements MockMaker {\n         cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n     }\n \n-    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n-        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n-            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n+public class MockMethodInterceptor implements Serializable, InvocationHandler, MockAccess {\n+\n+    @SuppressWarnings(\"unchecked\")\n+    private static final Map<String, MockHandler> EMPTY_MAP = Collections.EMPTY_MAP;\n+\n+    private final transient MockCreationSettings settings;\n+    private final transient MockHandler handler;\n+    private final transient Map<String, MockHandler> mockedMethodHandlers;\n+    private final transient AtomicBoolean verified;\n+\n+    private Map<Object, Object> arguments;\n+    private AtomicBoolean stubbingMode;\n+\n+    public MockMethodInterceptor(MockHandler handler, MockCreationSettings settings) {\n+        this.settings = settings;\n+        this.handler = handler;\n+        this.verified = new AtomicBoolean(false);\n+        this.mockedMethodHandlers = new ConcurrentHashMap<String, MockHandler>();\n+        this.stubbingMode = new AtomicBoolean(false);\n+    }\n+\n+    @Override\n+    public Object intercept(Object proxy, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n+        Invocation invocation = new SimpleInvocation(proxy, method, args);\n+        InvocationMatcher invocationMatcher = new InvocationMatcher(invocation, this.settings.getMatchers());\n+        return handleMethodCall(invocationMatcher, invocation);\n+    }\n+\n+    public Object handleMethodCall(InvocationMatcher invocationMatcher, Invocation invocation) throws Throwable {\n+        if (stubbingMode.get()) {\n+            return handleStubbing(invocationMatcher);\n         }\n-        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n-                settings.getTypeToMock(),\n-                settings.getExtraInterfaces()\n-        );\n-        T mockInstance = null;\n+\n+        Object ret = null;\n         try {\n-            mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n+            ret = handleIntercept(invocationMatcher, invocation);\n+        } catch (Throwable t) {\n+            if (handler.shouldBreakMockCreation(invocation, t)) {\n+                throw t;\n+            }\n+        }\n \n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n+        if (settings.isSerializable()) {\n+            handler.getInvocationContainer().setInvocationForPotentialStubbing(invocationMatcher.getInvocation());\n+        }\n+\n+        return ret;\n+    }\n+    \n+    // ensure mockedMethodHandlers is initialized before being used\n+    private void ensureMockedMethodHandlers() {\n+        if (this.mockedMethodHandlers.isEmpty()) {\n+            mockedMethodHandlers.putAll(EMPTY_MAP);\n+        }\n+    }\n+\n+    private Object handleIntercept(InvocationMatcher invocationMatcher, Invocation invocation) throws Throwable {\n+        String mockitoMethodName = invocation.getMethod().getName();\n+        ensureMockedMethodHandlers();\n+        MockHandler handler = mockedMethodHandlers.get(mockitoMethodName);\n+        if (handler == null) {\n+            return handleNotFoundMethod(invocation);\n+        }\n+        return handler.handle(invocation);\n+    }\n+\n+    @Override\n+    public void setMockitoInterceptor(MockitoInvocationHandler mockitoInterceptor) {\n+        mockedMethodHandlers.putAll(mockitoInterceptor.getHandlerForMockedMethod());\n+    }\n+\n+    @Override\n+    public Object getMock() {\n+        return handler;\n+    }\n+\n+    @Override\n+    public Map<Object, Object> getArguments() {\n+        if (arguments == null) {\n+            arguments = new HashMap<Object, Object>();\n+        }\n+        return arguments;\n+    }\n+\n+    @Override\n+    public void setAnswersForStubbing(List<Answer<?>> answers) {\n+        ensureMockedMethodHandlers();\n+        for (Answer<?> a: answers) {\n+            MockMethodAdvice advice = new MakeStubbingReal(a);\n+            mockedMethodHandlers.put(advice.getIdentifier(), advice);\n+        }\n+    }\n+\n+    private Object handleStubbing(InvocationMatcher im) {\n+        ensureMockedMethodHandlers();\n+        try {\n+            this.stubbingMode.set(false);\n+            if (isVoidMethod(im.getInvocation())) {\n+                MockMethodAdvice advice = new AddUnexpectedVoidCallReal(im.getInvocation());\n+                Object retValue = advice.call();\n+                handleResult(retValue);\n+                return null;\n+            } else {\n+                MockMethodAdvice advice = new AddUnexpectedCallReal(im.getInvocation());\n+                Object retValue = advice.call();\n+                handleResult(retValue);\n+                return ReturnsMoreEmptyValues.getDefaultFor(im.getInvocation().getMethod().getReturnType());\n+            }\n+        } catch(Throwable t) {\n+            return UnfinishedStubbingReport.createReport(t, im.toString());\n+        }\n+    }\n+\n+    private void handleResult(Object retValue) {\n+        verifyNoMoreInteractions();\n+        if (retValue instanceof Throwable) {\n+            Throwable t = (Throwable) retValue;\n+            throw UnfinishedStubbingExceptionImpl.forReturnValueWasNotUsed(t);\n+        }\n+    }\n+\n+    private Object handleNotFoundMethod(Invocation invocation) throws Throwable {\n+        Object ret = null;\n+        if (handler.getDelegate() == null) {\n+            return handleNullReturn(invocation);\n+        }\n+\n+        try {\n+            boolean wasInStubbingMode = stubbingMode.getAndSet(false);\n+            ret = invocation.callRealMethod();\n+            stubbingMode.set(wasInStubbingMode);\n+            return ret;\n+        } catch (Throwable t) {\n+            boolean wasInStubbingMode = stubbingMode.getAndSet(false);\n+            returnTypeMismatch(invocation.getMethod(), t);\n+            return null; // Never executed but necessary to compile\n+        }\n+    }\n+\n+    private Object handleNullReturn(Invocation call) {\n+        if (isSmartNullable(call.getMethod().getReturnType())) {\n+            return GeneratesNulls.SmartNull.get(call.getMethod().getReturnType());\n+        } else {\n+            boolean wasInStubbingMode = stubbingMode.getAndSet(false);\n+            Object nullValue = Defaults.defaultValue(call.getMethod().getReturnType());\n+            stubbingMode.set(wasInStubbingMode);\n+            return nullValue;\n+        }\n+    }\n+\n+    private boolean isVoidMethod(Invocation invocation) {\n+        return Void.class == invocation.getMethod().getReturnType() || void.class == invocation.getMethod().getReturnType();\n+    }\n+\n+    private void returnTypeMismatch(Method method, Throwable t) throws Throwable {\n+        Class<?> returnType = method.getReturnType();\n+        if (returnType == Void.TYPE) {\n+            throw t;\n+        } else if (t instanceof ClassCastException) {\n+            throw t;\n+        }\n+        throw new MockitoException(join(\n+                \"ReturnTypeMismatch\",\n+                \"    \",\n+                \"type wanted:<\" + returnType.getSimpleName() + \">\",\n+                \"    \",\n+                \"but was:<\" + t.getClass().getSimpleName() + \">\",\n+                \"\",\n+                \"You have not passed the correct arguments at the implementation of the verification stage of the test.\",\n+                \"\",\n+                \"Correct usage would be to mock the right call and leave its implementation - To-be-done.\",\n+                \"\"\n+        ), t);\n+    }\n+\n+    private boolean isSmartNullable(Class<?> returnType) {\n+        return returnType.isInterface() || Modifier.isAbstract(returnType.getModifiers());\n+    }\n+\n+    void setStubbingMode(boolean stubbingMode) {\n+        this.stubbingMode.set(stubbingMode);\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        if (!verified.compareAndSet(false, true)) {\n+            throw new MockitoVerificationAssertionError(join(\n+                    \"No interactions wanted\",\n                     \"\",\n-                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n-                    \"\"\n-            ),cce);\n-        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n-            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n+                    \"However, there were other interactions with this mock\",\n+                    \"\",\n+                    \"MockitoStubber.captureArguments() should be used directly after mock declaration\"\n+            ));\n         }\n     }\n \n+    public MockCreationSettings getMockSettings() {\n+        return this.settings;\n+    }\n+\n+    public boolean canCallRealMethods() {\n+        return settings.isCallRealMethodForAllMocks() ||\n+                settings.isSerializable() ||\n+                settings.getMockCreationSettingsType() == MockSettingsType.CALLS_REAL_METHODS ||\n+                handler.getMockSettings().isStubOnly();\n+    }\n+\n+    @Override\n+    public void verify(VerificationMode verificationMode) {\n+        handler.verify(invocationContainer -> {\n+            invocationContainer.verify(verificationMode);\n+            return null;\n+        });\n+    }\n+\n+    @Override\n+    public void verify(VerificationDataImpl data) {\n+        handler.verify(invocationContainer -> {\n+            invocationContainer.verify(data);\n+            return null;\n+        });\n+    }\n+\n+    private void readObject(ObjectInputStream in) throws IOException, ClassNotFoundException {\n+        in.defaultReadObject();\n+        this.stubbingMode = new AtomicBoolean(false);\n+    }\n+}\n+\n     private <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {\n         // Force explicit cast to mocked type here, instead of\n         // relying on the JVM to implicitly cast on the client call site.",
    "result_reason": "error: lambda expressions are not supported in -source 1.5",
    "test_result": "ERROR"
}