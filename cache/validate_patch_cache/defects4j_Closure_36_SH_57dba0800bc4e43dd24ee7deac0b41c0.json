{
    "patch": "if (value.isMemberFunctionDef()\n          && NodeUtil.isExpressionResult(callNode.getParent())\n          && callNode.getGrandparent().isAssign()) {\n        // inline singleton getter method used only once\n        Node assignNode = callNode.getGrandparent();\n\n        Node nameNode = value.getFirstChild();\n        Node classNode = nameNode.getFirstChild();\n\n        // Verify that the class only has a single instance and that the getter\n        // method is returning it.\n        if (!convention.isSingletonGetter(classNode, nameNode)\n            || !convention.isGetFunction(value, nameNode)) {\n          return false;\n        }\n\n        Node instanceNode =\n            convention.getOnlyInstanceIdInClassDefiningCall(assignNode);\n        if (instanceNode == null) {\n          return false;\n        }\n\n        // Constant inline the value and make sure the result is valid.\n        Node instanceClone = instanceNode.cloneTree();\n        instanceClone.useSourceInfoIfMissingFromForTree(callNode);\n        NodeUtil.markNewScopesChanged(instanceClone, compiler);\n        NodeUtil.copyNameAnnotations(instanceNode, instanceClone);\n        NodeUtil.replaceWithCall(instanceClone, value);\n        if (!NodeUtil.isValidExpressionResult(callNode.getParent())) {\n          return false;\n        }\n\n        // Remove the property assignment to the singleton instance.\n        Node valueNode =\n            assignNode.getLastChild().detachFromParent();\n        compiler.reportCodeChange();\n        return true;\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..adc36576 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,44 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+if (value.isMemberFunctionDef()\n+          && NodeUtil.isExpressionResult(callNode.getParent())\n+          && callNode.getGrandparent().isAssign()) {\n+        // inline singleton getter method used only once\n+        Node assignNode = callNode.getGrandparent();\n+\n+        Node nameNode = value.getFirstChild();\n+        Node classNode = nameNode.getFirstChild();\n+\n+        // Verify that the class only has a single instance and that the getter\n+        // method is returning it.\n+        if (!convention.isSingletonGetter(classNode, nameNode)\n+            || !convention.isGetFunction(value, nameNode)) {\n+          return false;\n+        }\n+\n+        Node instanceNode =\n+            convention.getOnlyInstanceIdInClassDefiningCall(assignNode);\n+        if (instanceNode == null) {\n+          return false;\n+        }\n+\n+        // Constant inline the value and make sure the result is valid.\n+        Node instanceClone = instanceNode.cloneTree();\n+        instanceClone.useSourceInfoIfMissingFromForTree(callNode);\n+        NodeUtil.markNewScopesChanged(instanceClone, compiler);\n+        NodeUtil.copyNameAnnotations(instanceNode, instanceClone);\n+        NodeUtil.replaceWithCall(instanceClone, value);\n+        if (!NodeUtil.isValidExpressionResult(callNode.getParent())) {\n+          return false;\n+        }\n+\n+        // Remove the property assignment to the singleton instance.\n+        Node valueNode =\n+            assignNode.getLastChild().detachFromParent();\n+        compiler.reportCodeChange();\n+        return true;\n+      }\n         }\n       }\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}