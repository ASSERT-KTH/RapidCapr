{
    "patch": "// After the body of a CASE, the control goes to the body of the next\n// case, without having to go to the case condition.\nif (parent.getNext() != null) {\n  if (parent.getNext().isCase()) {\n    return parent.getNext().getFirstChild().getNext();\n  } else if (parent.getNext().isDefaultCase()) {\n    return parent.getNext().getFirstChild();\n  } else {\n    Preconditions.checkState(false, \"Not reachable\");\n  }\n} else if (cfa != null && NodeUtil.isFunctionBlock(parent)) {\n  return cfa.getSyntheticReturn().getFirstFirstChild();\n} else {\n  return computeFollowNode(fromNode, parent, cfa);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..28289ec1 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,21 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+// After the body of a CASE, the control goes to the body of the next\n+// case, without having to go to the case condition.\n+if (parent.getNext() != null) {\n+  if (parent.getNext().isCase()) {\n+    return parent.getNext().getFirstChild().getNext();\n+  } else if (parent.getNext().isDefaultCase()) {\n+    return parent.getNext().getFirstChild();\n+  } else {\n+    Preconditions.checkState(false, \"Not reachable\");\n+  }\n+} else if (cfa != null && NodeUtil.isFunctionBlock(parent)) {\n+  return cfa.getSyntheticReturn().getFirstFirstChild();\n+} else {\n+  return computeFollowNode(fromNode, parent, cfa);\n+}\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}