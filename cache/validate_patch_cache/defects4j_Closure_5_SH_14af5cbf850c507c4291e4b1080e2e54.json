{
    "patch": "        if (body == null) {\n            return false;\n          }\n\n          Node newBlock = null;\n          Node lastStatement = null;\n\n          for (Node current = body.getFirstChild(); current != null;) {\n            // \"last\" here stands for \"last non-empty statement\".\n            // Once we have decided to collapse some statements into a block,\n            // we move \"last\" past all empty statements.\n            // This way we don't end up with trailing empty statements in our\n            // new block.\n            Node last = current;\n\n            // We want to try collapsing from here to the end of the list of\n            // statements.\n            // So set afterLast to be after the last statement.\n            Node afterLast = body.getLastChild().getNext();\n\n            while (current != null && current.getNext() != afterLast) {\n              Node testNode = null;\n              Node consequent = null;\n              Node alternate = null;\n\n              // Look for patterns of the form:\n              // if (x) { break; } else { <rest of flow> }\n              // and replace them with\n              // if (!x) { <rest of flow> }\n              // as a form of forward conditional.\n              if (current.isIf()) {\n                Node condition = current.getFirstChild().getNext();\n                consequent = current.getFirstChild().getNext().getNext();\n                if ((lastStatement != null && lastStatement.getNext() != current) ||\n                    matchBreakWithCondition(consequent, current)) {\n                  // The previous statement was not a break and the current if-else\n                  // controls a block that ends with a break statement.\n                  // Special case:\n                  // if (!x) { break; } else { break; }\n                  // becomes\n                  // if (!(x)) { break; }\n                  //\n                  // Remove the break statement if there's nothing after it.\n                  if (NodeUtil.isStatementBlock(consequent) &&\n                      !current.getNext().isTry()) {\n                    Node las = current.getLastChild();\n                    if (las.isIf()) {\n                      rewroteConditional = true;\n                      condition.replaceWith(\n                          IR.not(consequent.getFirstChild().detach()).useSourceInfoFrom(condition));\n                      alternate = NodeUtil.getOppositeControlFlowBranch(current);\n                      \n                      body.addChildAfter(consequent, current);\n\n                      // point the loop back to the new last statement.\n                      last = (alternate == null) ? current.getLastChild() : alternate.getLastChild();\n                    } else if (las.isBreak() &&\n                               las.getFirstChild() == consequent.getLastChild()) {\n                      rewroteConditional = true;\n\n                      // Remove the break statement.\n                      las.detach();\n\n                      // Point the loop back past the last (removed) statement.\n                      last = las.getPrevious();\n                      if (last != null) {\n                        lastStatement = last;\n                      }\n                    }\n                  }\n                }\n              }\n              last = current;\n              current = current.getNext();\n\n              if (newBlock == null &&\n                  (testNode != null || alternate != null)) {\n                // we have a conjunction/disjunction\n                newBlock = NodeUtil.getEnclosingBlock(lastStatement);\n              }\n\n              if (newBlock != null && testNode != null) {\n                // we have a conjunction/disjunction\n                // reattach to enclosing block\n                newBlock.addChildToBack(consequent.detach());\n                alternate.detach();\n\n                Node replacement = IR.ifNode(IR.not(testNode), alternate);\n                replacement.useSourceInfoFrom(current);\n                lastStatement.getParent().replaceChild(lastStatement, replacement);\n                rewroteConditional = true;\n                alternate.replaceWith(replacement);\n              }\n          \n              if (testNode != null) {\n                Node replacement = IR.ifNode(testNode, consequent, alternate);\n                replacement.useSourceInfoFrom(current);\n                if (continuationAfter != null) {\n                  newBlock.getParent().addChildBefore(replacement, continuationAfter);\n                } else {\n                  newBlock.getParent().addChildAfter(replacement, newBlock);\n                }\n                lastStatement.getParent().replaceChild(lastStatement, replacement);\n                rewroteConditional = true;\n              }\n\n              if (NodeUtil.isControlStructure(current) ||\n                  current.isExprResult()) {\n                lastStatement = current;\n              }\n            }\n          }\n\n          if (newBlock == null) {\n            return rewroteConditional;\n          }\n\n          return true;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..d4e339bf 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,124 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+        if (body == null) {\n+            return false;\n+          }\n+\n+          Node newBlock = null;\n+          Node lastStatement = null;\n+\n+          for (Node current = body.getFirstChild(); current != null;) {\n+            // \"last\" here stands for \"last non-empty statement\".\n+            // Once we have decided to collapse some statements into a block,\n+            // we move \"last\" past all empty statements.\n+            // This way we don't end up with trailing empty statements in our\n+            // new block.\n+            Node last = current;\n+\n+            // We want to try collapsing from here to the end of the list of\n+            // statements.\n+            // So set afterLast to be after the last statement.\n+            Node afterLast = body.getLastChild().getNext();\n+\n+            while (current != null && current.getNext() != afterLast) {\n+              Node testNode = null;\n+              Node consequent = null;\n+              Node alternate = null;\n+\n+              // Look for patterns of the form:\n+              // if (x) { break; } else { <rest of flow> }\n+              // and replace them with\n+              // if (!x) { <rest of flow> }\n+              // as a form of forward conditional.\n+              if (current.isIf()) {\n+                Node condition = current.getFirstChild().getNext();\n+                consequent = current.getFirstChild().getNext().getNext();\n+                if ((lastStatement != null && lastStatement.getNext() != current) ||\n+                    matchBreakWithCondition(consequent, current)) {\n+                  // The previous statement was not a break and the current if-else\n+                  // controls a block that ends with a break statement.\n+                  // Special case:\n+                  // if (!x) { break; } else { break; }\n+                  // becomes\n+                  // if (!(x)) { break; }\n+                  //\n+                  // Remove the break statement if there's nothing after it.\n+                  if (NodeUtil.isStatementBlock(consequent) &&\n+                      !current.getNext().isTry()) {\n+                    Node las = current.getLastChild();\n+                    if (las.isIf()) {\n+                      rewroteConditional = true;\n+                      condition.replaceWith(\n+                          IR.not(consequent.getFirstChild().detach()).useSourceInfoFrom(condition));\n+                      alternate = NodeUtil.getOppositeControlFlowBranch(current);\n+                      \n+                      body.addChildAfter(consequent, current);\n+\n+                      // point the loop back to the new last statement.\n+                      last = (alternate == null) ? current.getLastChild() : alternate.getLastChild();\n+                    } else if (las.isBreak() &&\n+                               las.getFirstChild() == consequent.getLastChild()) {\n+                      rewroteConditional = true;\n+\n+                      // Remove the break statement.\n+                      las.detach();\n+\n+                      // Point the loop back past the last (removed) statement.\n+                      last = las.getPrevious();\n+                      if (last != null) {\n+                        lastStatement = last;\n+                      }\n+                    }\n+                  }\n+                }\n+              }\n+              last = current;\n+              current = current.getNext();\n+\n+              if (newBlock == null &&\n+                  (testNode != null || alternate != null)) {\n+                // we have a conjunction/disjunction\n+                newBlock = NodeUtil.getEnclosingBlock(lastStatement);\n+              }\n+\n+              if (newBlock != null && testNode != null) {\n+                // we have a conjunction/disjunction\n+                // reattach to enclosing block\n+                newBlock.addChildToBack(consequent.detach());\n+                alternate.detach();\n+\n+                Node replacement = IR.ifNode(IR.not(testNode), alternate);\n+                replacement.useSourceInfoFrom(current);\n+                lastStatement.getParent().replaceChild(lastStatement, replacement);\n+                rewroteConditional = true;\n+                alternate.replaceWith(replacement);\n+              }\n+          \n+              if (testNode != null) {\n+                Node replacement = IR.ifNode(testNode, consequent, alternate);\n+                replacement.useSourceInfoFrom(current);\n+                if (continuationAfter != null) {\n+                  newBlock.getParent().addChildBefore(replacement, continuationAfter);\n+                } else {\n+                  newBlock.getParent().addChildAfter(replacement, newBlock);\n+                }\n+                lastStatement.getParent().replaceChild(lastStatement, replacement);\n+                rewroteConditional = true;\n+              }\n+\n+              if (NodeUtil.isControlStructure(current) ||\n+                  current.isExprResult()) {\n+                lastStatement = current;\n+              }\n+            }\n+          }\n+\n+          if (newBlock == null) {\n+            return rewroteConditional;\n+          }\n+\n+          return true;\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}