{
    "patch": "public class IRFactory extends Parser {\n  // Constructor\n  public IRFactory(ErrorReporter reporter) {\n    super(reporter);\n  }\n\n  // IR Factory Methods\n  private Node newNode(int type) {\n    return new Node(type);\n  }\n\n  private Node newNode(int type, String str) {\n    return Node.newString(type, str);\n  }\n\n  private Node newNode(int type, Node child) {\n    return new Node(type, child);\n  }\n\n  private Node newNode(int type, Node left, Node right) {\n    return new Node(type, left, right);\n  }\n\n  private Node newNode(int type, Node left, Node right, Node third) {\n    return new Node(type, left, right, third);\n  }\n\n  // Process Methods\n  private void processFunction(FunctionNode functionNode, Node node) {\n    for (AstNode parameter : functionNode.getParams()) {\n      node.addChildToBack(transform(parameter));\n    }\n    node.addChildToBack(transform(functionNode.getBody()));\n  }\n\n  private Node processGeneric(AstNode node) {\n    return transform(node);\n  }\n\n  private boolean isDirective(AstNode n) {\n    if (!(n instanceof ExpressionStatement)) {\n      return false;\n    }\n\n    AstNode expr = ((ExpressionStatement) n).getExpression();\n    if (!(expr instanceof StringLiteral)) {\n      return false;\n    }\n\n    String directive = ((StringLiteral) expr).getValue();\n    return directive.equals(\"use asm\");\n  }\n\n  // Transform Methods\n  private Node transform(AstNode node) {\n    if (node instanceof FunctionNode) {\n      Node newNode = newNode(Token.FUNCTION);\n      newNode.setLineno(node.getLineno());\n      processFunction((FunctionNode) node, newNode);\n      return newNode;\n    } else if (node instanceof Name) {\n      String identifier = ((Name) node).getIdentifier();\n      return newNode(Token.NAME, identifier);\n    } else if (node instanceof StringLiteral) {\n      String value = ((StringLiteral) node).getValue();\n      return newNode(Token.STRING, value);\n    } else if (node instanceof NumberLiteral) {\n      double value = ((NumberLiteral) node).getNumber();\n      return Node.newNumber(value);\n    } else if (node instanceof ReturnStatement) {\n      Node newNode = newNode(Token.RETURN);\n      AstNode returnValue = ((ReturnStatement) node).getReturnValue();\n      if (returnValue != null) {\n        newNode.addChildToBack(transform(returnValue));\n      }\n      return newNode;\n    } else if (node instanceof ExpressionStatement) {\n      Node newNode = transform(((ExpressionStatement) node).getExpression());\n      if (isDirective(node)) {\n        newNode.putProp(Node.DIRECTIVES, \"use asm\");\n      }\n      return newNode;\n    } else if (node instanceof Block) {\n      return transformBlock((Block) node);\n    } else if (node instanceof IfStatement) {\n      Node condition = transform(((IfStatement) node).getCondition());\n      Node ifTrue = transform(((IfStatement) node).getThenPart());\n      AstNode ifFalse = ((IfStatement) node).getElsePart();\n      Node ifFalseNode = null;\n      if (ifFalse != null) {\n        ifFalseNode = transform(ifFalse);\n      }\n\n      return newNode(Token.IF, condition, ifTrue, ifFalseNode);\n    } else if (node instanceof ForLoop) {\n      Node init = transform(((ForLoop) node).getInitializer());\n      Node condition = transform(((ForLoop) node).getCondition());\n      Node increment = transform(((ForLoop) node).getIncrement());\n      Node body = transform(((ForLoop) node).getBody());\n\n      return newNode(Token.FOR, init, condition, increment, body);\n    } else if (node instanceof WhileLoop) {\n      Node condition = transform(((WhileLoop) node).getCondition());\n      Node body = transform(((WhileLoop) node).getBody());\n\n      return newNode(Token.WHILE, condition, body);\n    } else if (node instanceof DoLoop) {\n      Node body = transform(((DoLoop) node).getBody());\n      Node condition = transform(((DoLoop) node).getCondition());\n\n      return newNode(Token.DO, body, condition);\n    } else if (node instanceof SwitchStatement) {\n      AstNode expression = ((SwitchStatement) node).getExpression();\n      Node cases = newNode(Token.CASES);\n\n      for (SwitchCase switchCase : ((SwitchStatement) node).getCases()) {\n        Node caseNode;\n        if (switchCase.getExpression() == null) {\n          caseNode = newNode(Token.DEFAULT);\n        } else {\n          caseNode = newNode(Token.CASE, transform(switchCase.getExpression()));\n        }\n        caseNode.addChildToBack(transformBlock(switchCase.getStatements()));\n        cases.addChildToBack(caseNode);\n      }\n\n      return newNode(Token.SWITCH, transform(expression), cases);\n    } else if (node instanceof BreakStatement) {\n      Name label = ((BreakStatement) node).getBreakLabel();\n      if (label != null) {\n        return newNode(Token.BREAK, newNode(Token.LABEL_NAME, label.getIdentifier()));\n      } else {\n        return newNode(Token.BREAK);\n      }\n    } else if (node instanceof ContinueStatement) {\n      Name label = ((ContinueStatement) node).getLabel();\n      if (label != null) {\n        return newNode(Token.CONTINUE, newNode(Token.LABEL_NAME, label.getIdentifier()));\n      } else {\n        return newNode(Token.CONTINUE);\n      }\n    } else if (node instanceof TryStatement) {\n      Node tryBlock = transform(((TryStatement) node).getTryBlock());\n      Node catchBlock = null;\n      if (((TryStatement) node).getCatchBlock() != null) {\n        catchBlock = newNode(\n            Token.CATCH,\n            transform(((TryStatement) node).getCatchBlock().getCatchCondition()),\n            transform(((TryStatement) node).getCatchBlock().getBody()));\n      }\n      Node finallyBlock = null;\n      if (((TryStatement) node).getFinallyBlock() != null) {\n        finallyBlock = transform(((TryStatement) node).getFinallyBlock());\n      }\n      return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n    } else if (node instanceof ThrowStatement) {\n      return newNode(Token.THROW, transform(((ThrowStatement) node).getExpression()));\n    } else if (node instanceof ObjectLiteral) {\n      Node objectNode = newNode(Token.OBJECTLIT);\n      for (ObjectProperty prop : ((ObjectLiteral) node).getElements()) {\n        if (prop.getLeft() instanceof Name) {\n          Name name = (Name) prop.getLeft();\n          String identifier = name.getIdentifier();\n          objectNode.addChildToBack(newNode(Token.STRING_KEY, identifier, transform(prop.getRight())));\n        } else {\n          objectNode.addChildToBack(newNode(Token.GETELEM, transform(prop.getLeft()), transform(prop.getRight())));\n        }\n      }\n      return objectNode;\n    } else if (node instanceof ArrayLiteral) {\n      Node arrayNode = newNode(Token.ARRAYLIT);\n      for (AstNode element : ((ArrayLiteral) node).getElements()) {\n        if (element == null) {\n          arrayNode.addChildToBack(newNode(Token.EMPTY));\n        } else {\n          arrayNode.addChildToBack(transform(element));\n        }\n      }\n      return arrayNode;\n    } else if (node instanceof RegExpLiteral) {\n      String value = ((RegExpLiteral) node).getValue();\n      int flags = ((RegExpLiteral) node).getFlags();\n      return Node.newRegExp(value, \"\", flags);\n    } else if (node instanceof ParenthesizedExpression) {\n      return transform(((ParenthesizedExpression) node).getExpression());\n    } else if (node instanceof ConditionalExpression) {\n      Node condition = transform(((ConditionalExpression) node).getTestExpression());\n      Node trueExpr = transform(((ConditionalExpression) node).getTrueExpression());\n      Node falseExpr = transform(((ConditionalExpression) node).getFalseExpression());\n      return newNode(Token.HOOK, condition, trueExpr, falseExpr);\n    } else if (node instanceof UnaryExpression) {\n      int type = ((UnaryExpression) node).getOperator();\n      Node child = transform(((UnaryExpression) node).getOperand());\n      if (type == Token.TYPEOF) {\n        return newNode(Token.TYPEOFNAME, child);\n      } else {\n        return newNode(type, child);\n      }\n    } else if (node instanceof XmlLiteral) {\n      errorReporter.error(\n          \"XML literals are not supported\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n      return newNode(Token.EMPTY);\n    } else if (node instanceof XmlMemberGet) {\n      errorReporter.error(\n          \"XML literals are not supported\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n      return newNode(Token.EMPTY);\n    } else if (node instanceof XmlString) {\n      errorReporter.error(\n          \"XML literals are not supported\",\n          sourceName,\n          node.getLineno(), \"\", 0);\n      return newNode(Token.EMPTY);\n    } else if (node instanceof InfixExpression) {\n      int type = ((InfixExpression) node).getOperator();\n      if (type == Token.AND || type == Token.OR) {\n        Node left = transform(((InfixExpression) node).getLeft());\n        Node right = transform(((InfixExpression) node).getRight());\n        return new Node(type, left, right);\n      } else {\n        Node left = transform(((InfixExpression) node).getLeft());\n        Node right = transform(((InfixExpression) node).getRight());\n        return newNode(type, left, right);\n      }\n    } else if (node instanceof ElementGet) {\n      Node target = transform(((ElementGet) node).getTarget());\n      Node element = transform(((ElementGet) node).getElement());\n      return newNode(Token.GETELEM, target, element);\n    } else if (node instanceof KeywordLiteral) {\n      int tokenType = Token.FALSE;\n      if (((KeywordLiteral) node).getType() == Token.TRUE) {\n        tokenType = Token.TRUE;\n      }\n\n      return newNode(tokenType);\n    } else if (node instanceof EmptyExpression) {\n      return newNode(Token.EMPTY);\n    } else if (node instanceof Comment) {\n      return newNode(Token.EMPTY);\n    } else if (node instanceof ScriptNode) {\n      Node scriptNode = newNode(Token.SCRIPT);\n      for (AstNode childNode : node) {\n        scriptNode.addChildToBack(transform(childNode));\n      }\n      return scriptNode;\n    } else {\n      errorReporter.error(\n          \"Unsupported node type: \" + node.shortName(),\n          sourceName,\n          node.getLineno(), \"\", 0);\n      return newNode(Token.EMPTY);\n    }\n  }\n\n  private Node transformBlock(Block blockNode) {\n    Node block = newNode(Token.BLOCK);\n    for (AstNode statement : blockNode) {\n      if (statement instanceof VariableDeclaration) {\n        for (VariableInitializer initializer : ((VariableDeclaration) statement).getVariables()) {\n          block.addChildToBack(transform(initializer));\n        }\n      } else {\n        block.addChildToBack(transform(statement));\n      }\n    }\n    return block;\n  }\n\n  private Node transformTokenType(int type) {\n    switch (type) {\n      case Token.RETURN:\n        return newNode(Token.RETURN);\n      case Token.BREAK:\n        return newNode(Token.BREAK);\n      case Token.CONTINUE:\n        return newNode(Token.CONTINUE);\n      case Token.EXPR_VOID:\n      case Token.EXPR_RESULT:\n        return newNode(Token.EXPR_RESULT);\n      case Token.WITH:\n        // With statements not supported - convert them as blocks\n        return newNode(Token.BLOCK);\n      default:\n        throw new RuntimeException(\"Unexpected token type \" + Token.name(type));\n    }\n  }\n\n  // Type-safe Dispatcher\n  private static abstract class TransformDispatcher implements NodeVisitor {\n    @Override\n    public final boolean visit(AstNode node) {\n      throw new RuntimeException(\"Invalid visit call\");\n    }\n\n    @Override\n    public final boolean visitBinaryOperation(BinaryOperator node) {\n      return true;\n    }\n\n    public abstract Node processFunction(FunctionNode functionNode);\n\n    public abstract Node processVariableDeclaration(VariableDeclaration variableDeclaration);\n\n    public abstract Node processExpressionStatement(ExpressionStatement statementNode);\n\n    public abstract Node processIfStatement(IfStatement statementNode);\n\n    public abstract Node processForLoop(ForLoop loopNode);\n\n    public abstract Node processWhileLoop(WhileLoop loopNode);\n\n    public abstract Node processDoLoop(DoLoop loopNode);\n\n    public abstract Node processSwitchStatement(SwitchStatement switchNode);\n\n    public abstract Node processBreakStatement(BreakStatement statementNode);\n\n    public abstract Node processContinueStatement(ContinueStatement statementNode);\n\n    public abstract Node processTryStatement(TryStatement statementNode);\n\n    public abstract Node processThrowStatement(ThrowStatement statementNode);\n\n    public abstract Node processObjectLiteral(ObjectLiteral literalNode);\n\n    public abstract Node processArrayLiteral(ArrayLiteral literalNode);\n\n    public abstract Node processInfixExpression(InfixExpression infixExpression);\n\n    public abstract Node processElementGet(ElementGet getNode);\n\n    public abstract Node processUnaryExpression(UnaryExpression unaryExpression);\n\n    public abstract Node processParenthesizedExpression(ParenthesizedExpression parenthesizedExpression);\n\n    public abstract Node processKeywordLiteral(KeywordLiteral literalNode);\n\n    public abstract Node processEmptyExpression(EmptyExpression emptyExpression);\n\n    public abstract Node processComment(Comment node);\n  }\n\n  private class TransformDispatch extends TransformDispatcher {\n    @Override\n    public Node processFunction(FunctionNode functionNode) {\n      Node node = newNode(Token.FUNCTION);\n      processFunction(functionNode, node);\n      return node;\n    }\n\n    @Override\n    public Node processVariableDeclaration(VariableDeclaration variableDeclaration) {\n      Node node = newNode(Token.VAR);\n      for (VariableInitializer initializer : variableDeclaration.getVariables()) {\n        node.addChildToBack(transform(initializer));\n      }\n      return node;\n    }\n\n    @Override\n    public Node processExpressionStatement(ExpressionStatement statementNode) {\n      return newNode(Token.EXPR_RESULT, transform(statementNode.getExpression()));\n    }\n\n    @Override\n    public Node processIfStatement(IfStatement statementNode) {\n      Node node = newNode(Token.IF);\n      node.addChildToBack(transform(statementNode.getCondition()));\n      node.addChildToBack(transform(statementNode.getThenPart()));\n      if (statementNode.getElsePart() != null) {\n        node.addChildToBack(transform(statementNode.getElsePart()));\n      }\n      return node;\n    }\n\n    @Override\n    public Node processForLoop(ForLoop loopNode) {\n      Node node = newNode(Token.FOR);\n      node.addChildToBack(transform(loopNode.getInitializer()));\n      node.addChildToBack(transform(loopNode.getCondition()));\n      node.addChildToBack(transform(loopNode.getIncrement()));\n      node.addChildToBack(transform(loopNode.getBody()));\n      return node;\n    }\n\n    @Override\n    public Node processWhileLoop(WhileLoop loopNode) {\n      Node node = newNode(Token.WHILE);\n      node.addChildToBack(transform(loopNode.getCondition()));\n      node.addChildToBack(transform(loopNode.getBody()));\n      return nod",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..545560ec 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,400 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory extends Parser {\n+  // Constructor\n+  public IRFactory(ErrorReporter reporter) {\n+    super(reporter);\n+  }\n+\n+  // IR Factory Methods\n+  private Node newNode(int type) {\n+    return new Node(type);\n+  }\n+\n+  private Node newNode(int type, String str) {\n+    return Node.newString(type, str);\n+  }\n+\n+  private Node newNode(int type, Node child) {\n+    return new Node(type, child);\n+  }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private Node newNode(int type, Node left, Node right) {\n+    return new Node(type, left, right);\n+  }\n+\n+  private Node newNode(int type, Node left, Node right, Node third) {\n+    return new Node(type, left, right, third);\n+  }\n+\n+  // Process Methods\n+  private void processFunction(FunctionNode functionNode, Node node) {\n+    for (AstNode parameter : functionNode.getParams()) {\n+      node.addChildToBack(transform(parameter));\n     }\n+    node.addChildToBack(transform(functionNode.getBody()));\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  private Node processGeneric(AstNode node) {\n+    return transform(node);\n+  }\n+\n+  private boolean isDirective(AstNode n) {\n+    if (!(n instanceof ExpressionStatement)) {\n+      return false;\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    AstNode expr = ((ExpressionStatement) n).getExpression();\n+    if (!(expr instanceof StringLiteral)) {\n+      return false;\n+    }\n+\n+    String directive = ((StringLiteral) expr).getValue();\n+    return directive.equals(\"use asm\");\n+  }\n+\n+  // Transform Methods\n+  private Node transform(AstNode node) {\n+    if (node instanceof FunctionNode) {\n+      Node newNode = newNode(Token.FUNCTION);\n+      newNode.setLineno(node.getLineno());\n+      processFunction((FunctionNode) node, newNode);\n+      return newNode;\n+    } else if (node instanceof Name) {\n+      String identifier = ((Name) node).getIdentifier();\n+      return newNode(Token.NAME, identifier);\n+    } else if (node instanceof StringLiteral) {\n+      String value = ((StringLiteral) node).getValue();\n+      return newNode(Token.STRING, value);\n+    } else if (node instanceof NumberLiteral) {\n+      double value = ((NumberLiteral) node).getNumber();\n+      return Node.newNumber(value);\n+    } else if (node instanceof ReturnStatement) {\n+      Node newNode = newNode(Token.RETURN);\n+      AstNode returnValue = ((ReturnStatement) node).getReturnValue();\n+      if (returnValue != null) {\n+        newNode.addChildToBack(transform(returnValue));\n       }\n-      return node;\n+      return newNode;\n+    } else if (node instanceof ExpressionStatement) {\n+      Node newNode = transform(((ExpressionStatement) node).getExpression());\n+      if (isDirective(node)) {\n+        newNode.putProp(Node.DIRECTIVES, \"use asm\");\n+      }\n+      return newNode;\n+    } else if (node instanceof Block) {\n+      return transformBlock((Block) node);\n+    } else if (node instanceof IfStatement) {\n+      Node condition = transform(((IfStatement) node).getCondition());\n+      Node ifTrue = transform(((IfStatement) node).getThenPart());\n+      AstNode ifFalse = ((IfStatement) node).getElsePart();\n+      Node ifFalseNode = null;\n+      if (ifFalse != null) {\n+        ifFalseNode = transform(ifFalse);\n+      }\n+\n+      return newNode(Token.IF, condition, ifTrue, ifFalseNode);\n+    } else if (node instanceof ForLoop) {\n+      Node init = transform(((ForLoop) node).getInitializer());\n+      Node condition = transform(((ForLoop) node).getCondition());\n+      Node increment = transform(((ForLoop) node).getIncrement());\n+      Node body = transform(((ForLoop) node).getBody());\n+\n+      return newNode(Token.FOR, init, condition, increment, body);\n+    } else if (node instanceof WhileLoop) {\n+      Node condition = transform(((WhileLoop) node).getCondition());\n+      Node body = transform(((WhileLoop) node).getBody());\n+\n+      return newNode(Token.WHILE, condition, body);\n+    } else if (node instanceof DoLoop) {\n+      Node body = transform(((DoLoop) node).getBody());\n+      Node condition = transform(((DoLoop) node).getCondition());\n+\n+      return newNode(Token.DO, body, condition);\n+    } else if (node instanceof SwitchStatement) {\n+      AstNode expression = ((SwitchStatement) node).getExpression();\n+      Node cases = newNode(Token.CASES);\n+\n+      for (SwitchCase switchCase : ((SwitchStatement) node).getCases()) {\n+        Node caseNode;\n+        if (switchCase.getExpression() == null) {\n+          caseNode = newNode(Token.DEFAULT);\n+        } else {\n+          caseNode = newNode(Token.CASE, transform(switchCase.getExpression()));\n+        }\n+        caseNode.addChildToBack(transformBlock(switchCase.getStatements()));\n+        cases.addChildToBack(caseNode);\n+      }\n+\n+      return newNode(Token.SWITCH, transform(expression), cases);\n+    } else if (node instanceof BreakStatement) {\n+      Name label = ((BreakStatement) node).getBreakLabel();\n+      if (label != null) {\n+        return newNode(Token.BREAK, newNode(Token.LABEL_NAME, label.getIdentifier()));\n+      } else {\n+        return newNode(Token.BREAK);\n+      }\n+    } else if (node instanceof ContinueStatement) {\n+      Name label = ((ContinueStatement) node).getLabel();\n+      if (label != null) {\n+        return newNode(Token.CONTINUE, newNode(Token.LABEL_NAME, label.getIdentifier()));\n+      } else {\n+        return newNode(Token.CONTINUE);\n+      }\n+    } else if (node instanceof TryStatement) {\n+      Node tryBlock = transform(((TryStatement) node).getTryBlock());\n+      Node catchBlock = null;\n+      if (((TryStatement) node).getCatchBlock() != null) {\n+        catchBlock = newNode(\n+            Token.CATCH,\n+            transform(((TryStatement) node).getCatchBlock().getCatchCondition()),\n+            transform(((TryStatement) node).getCatchBlock().getBody()));\n+      }\n+      Node finallyBlock = null;\n+      if (((TryStatement) node).getFinallyBlock() != null) {\n+        finallyBlock = transform(((TryStatement) node).getFinallyBlock());\n+      }\n+      return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+    } else if (node instanceof ThrowStatement) {\n+      return newNode(Token.THROW, transform(((ThrowStatement) node).getExpression()));\n+    } else if (node instanceof ObjectLiteral) {\n+      Node objectNode = newNode(Token.OBJECTLIT);\n+      for (ObjectProperty prop : ((ObjectLiteral) node).getElements()) {\n+        if (prop.getLeft() instanceof Name) {\n+          Name name = (Name) prop.getLeft();\n+          String identifier = name.getIdentifier();\n+          objectNode.addChildToBack(newNode(Token.STRING_KEY, identifier, transform(prop.getRight())));\n+        } else {\n+          objectNode.addChildToBack(newNode(Token.GETELEM, transform(prop.getLeft()), transform(prop.getRight())));\n+        }\n+      }\n+      return objectNode;\n+    } else if (node instanceof ArrayLiteral) {\n+      Node arrayNode = newNode(Token.ARRAYLIT);\n+      for (AstNode element : ((ArrayLiteral) node).getElements()) {\n+        if (element == null) {\n+          arrayNode.addChildToBack(newNode(Token.EMPTY));\n+        } else {\n+          arrayNode.addChildToBack(transform(element));\n+        }\n+      }\n+      return arrayNode;\n+    } else if (node instanceof RegExpLiteral) {\n+      String value = ((RegExpLiteral) node).getValue();\n+      int flags = ((RegExpLiteral) node).getFlags();\n+      return Node.newRegExp(value, \"\", flags);\n+    } else if (node instanceof ParenthesizedExpression) {\n+      return transform(((ParenthesizedExpression) node).getExpression());\n+    } else if (node instanceof ConditionalExpression) {\n+      Node condition = transform(((ConditionalExpression) node).getTestExpression());\n+      Node trueExpr = transform(((ConditionalExpression) node).getTrueExpression());\n+      Node falseExpr = transform(((ConditionalExpression) node).getFalseExpression());\n+      return newNode(Token.HOOK, condition, trueExpr, falseExpr);\n+    } else if (node instanceof UnaryExpression) {\n+      int type = ((UnaryExpression) node).getOperator();\n+      Node child = transform(((UnaryExpression) node).getOperand());\n+      if (type == Token.TYPEOF) {\n+        return newNode(Token.TYPEOFNAME, child);\n+      } else {\n+        return newNode(type, child);\n+      }\n+    } else if (node instanceof XmlLiteral) {\n+      errorReporter.error(\n+          \"XML literals are not supported\",\n+          sourceName,\n+          node.getLineno(), \"\", 0);\n+      return newNode(Token.EMPTY);\n+    } else if (node instanceof XmlMemberGet) {\n+      errorReporter.error(\n+          \"XML literals are not supported\",\n+          sourceName,\n+          node.getLineno(), \"\", 0);\n+      return newNode(Token.EMPTY);\n+    } else if (node instanceof XmlString) {\n+      errorReporter.error(\n+          \"XML literals are not supported\",\n+          sourceName,\n+          node.getLineno(), \"\", 0);\n+      return newNode(Token.EMPTY);\n+    } else if (node instanceof InfixExpression) {\n+      int type = ((InfixExpression) node).getOperator();\n+      if (type == Token.AND || type == Token.OR) {\n+        Node left = transform(((InfixExpression) node).getLeft());\n+        Node right = transform(((InfixExpression) node).getRight());\n+        return new Node(type, left, right);\n+      } else {\n+        Node left = transform(((InfixExpression) node).getLeft());\n+        Node right = transform(((InfixExpression) node).getRight());\n+        return newNode(type, left, right);\n+      }\n+    } else if (node instanceof ElementGet) {\n+      Node target = transform(((ElementGet) node).getTarget());\n+      Node element = transform(((ElementGet) node).getElement());\n+      return newNode(Token.GETELEM, target, element);\n+    } else if (node instanceof KeywordLiteral) {\n+      int tokenType = Token.FALSE;\n+      if (((KeywordLiteral) node).getType() == Token.TRUE) {\n+        tokenType = Token.TRUE;\n+      }\n+\n+      return newNode(tokenType);\n+    } else if (node instanceof EmptyExpression) {\n+      return newNode(Token.EMPTY);\n+    } else if (node instanceof Comment) {\n+      return newNode(Token.EMPTY);\n+    } else if (node instanceof ScriptNode) {\n+      Node scriptNode = newNode(Token.SCRIPT);\n+      for (AstNode childNode : node) {\n+        scriptNode.addChildToBack(transform(childNode));\n+      }\n+      return scriptNode;\n+    } else {\n+      errorReporter.error(\n+          \"Unsupported node type: \" + node.shortName(),\n+          sourceName,\n+          node.getLineno(), \"\", 0);\n+      return newNode(Token.EMPTY);\n     }\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  private Node transformBlock(Block blockNode) {\n+    Node block = newNode(Token.BLOCK);\n+    for (AstNode statement : blockNode) {\n+      if (statement instanceof VariableDeclaration) {\n+        for (VariableInitializer initializer : ((VariableDeclaration) statement).getVariables()) {\n+          block.addChildToBack(transform(initializer));\n+        }\n+      } else {\n+        block.addChildToBack(transform(statement));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n+    return block;\n+  }\n+\n+  private Node transformTokenType(int type) {\n+    switch (type) {\n+      case Token.RETURN:\n+        return newNode(Token.RETURN);\n+      case Token.BREAK:\n+        return newNode(Token.BREAK);\n+      case Token.CONTINUE:\n+        return newNode(Token.CONTINUE);\n+      case Token.EXPR_VOID:\n+      case Token.EXPR_RESULT:\n+        return newNode(Token.EXPR_RESULT);\n+      case Token.WITH:\n+        // With statements not supported - convert them as blocks\n+        return newNode(Token.BLOCK);\n+      default:\n+        throw new RuntimeException(\"Unexpected token type \" + Token.name(type));\n+    }\n+  }\n \n+  // Type-safe Dispatcher\n+  private static abstract class TransformDispatcher implements NodeVisitor {\n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public final boolean visit(AstNode node) {\n+      throw new RuntimeException(\"Invalid visit call\");\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n+    public final boolean visitBinaryOperation(BinaryOperator node) {\n+      return true;\n+    }\n+\n+    public abstract Node processFunction(FunctionNode functionNode);\n+\n+    public abstract Node processVariableDeclaration(VariableDeclaration variableDeclaration);\n+\n+    public abstract Node processExpressionStatement(ExpressionStatement statementNode);\n+\n+    public abstract Node processIfStatement(IfStatement statementNode);\n+\n+    public abstract Node processForLoop(ForLoop loopNode);\n+\n+    public abstract Node processWhileLoop(WhileLoop loopNode);\n+\n+    public abstract Node processDoLoop(DoLoop loopNode);\n+\n+    public abstract Node processSwitchStatement(SwitchStatement switchNode);\n+\n+    public abstract Node processBreakStatement(BreakStatement statementNode);\n+\n+    public abstract Node processContinueStatement(ContinueStatement statementNode);\n+\n+    public abstract Node processTryStatement(TryStatement statementNode);\n+\n+    public abstract Node processThrowStatement(ThrowStatement statementNode);\n+\n+    public abstract Node processObjectLiteral(ObjectLiteral literalNode);\n+\n+    public abstract Node processArrayLiteral(ArrayLiteral literalNode);\n+\n+    public abstract Node processInfixExpression(InfixExpression infixExpression);\n+\n+    public abstract Node processElementGet(ElementGet getNode);\n+\n+    public abstract Node processUnaryExpression(UnaryExpression unaryExpression);\n+\n+    public abstract Node processParenthesizedExpression(ParenthesizedExpression parenthesizedExpression);\n+\n+    public abstract Node processKeywordLiteral(KeywordLiteral literalNode);\n+\n+    public abstract Node processEmptyExpression(EmptyExpression emptyExpression);\n+\n+    public abstract Node processComment(Comment node);\n+  }\n+\n+  private class TransformDispatch extends TransformDispatcher {\n+    @Override\n+    public Node processFunction(FunctionNode functionNode) {\n+      Node node = newNode(Token.FUNCTION);\n+      processFunction(functionNode, node);\n       return node;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node processVariableDeclaration(VariableDeclaration variableDeclaration) {\n+      Node node = newNode(Token.VAR);\n+      for (VariableInitializer initializer : variableDeclaration.getVariables()) {\n+        node.addChildToBack(transform(initializer));\n+      }\n+      return node;\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node processExpressionStatement(ExpressionStatement statementNode) {\n+      return newNode(Token.EXPR_RESULT, transform(statementNode.getExpression()));\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n+    public Node processIfStatement(IfStatement statementNode) {\n+      Node node = newNode(Token.IF);\n+      node.addChildToBack(transform(statementNode.getCondition()));\n+      node.addChildToBack(transform(statementNode.getThenPart()));\n+      if (statementNode.getElsePart() != null) {\n+        node.addChildToBack(transform(statementNode.getElsePart()));\n+      }\n       return node;\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n+    public Node processForLoop(ForLoop loopNode) {\n+      Node node = newNode(Token.FOR);\n+      node.addChildToBack(transform(loopNode.getInitializer()));\n+      node.addChildToBack(transform(loopNode.getCondition()));\n+      node.addChildToBack(transform(loopNode.getIncrement()));\n+      node.addChildToBack(transform(loopNode.getBody()));\n       return node;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-\n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+    public Node processWhileLoop(WhileLoop loopNode) {\n+      Node node = newNode(Token.WHILE);\n+      node.addChildToBack(transform(loopNode.getCondition()));\n+      node.addChildToBack(transform(loopNode.getBody()));\n+      return nod\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}