{
    "patch": "public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n    }\n    Class<?> typeToMock = settings.getTypeToMock();\n\n    T mockInstance = null;\n\n    if (typeToMock.isMemberClass() && !Modifier.isStatic(typeToMock.getModifiers())) {\n        /*\n        For inner non-static classes, we must provide a reference to the outer instance\n        to the constructor of the mock object. This is necessary because the mock object\n        needs to have access to the outer instance's fields and methods. We create the mock\n        object manually using reflection in order to pass this reference to the constructor.\n         */\n        Object outerInstance = Mockito.mock(typeToMock.getEnclosingClass());\n        try {\n            Constructor<T> ctor = typeToMock.getDeclaredConstructor(typeToMock.getEnclosingClass());\n            ctor.setAccessible(true);\n            mockInstance = ctor.newInstance(outerInstance);\n        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n            throw new MockitoException(\"Unable to create mock object for non-static inner class: \" + typeToMock, e);\n        }\n    } else {\n        /*\n        For all other classes, just use the default mock creation process.\n         */\n        Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                settings.getTypeToMock(),\n                settings.getExtraInterfaces()\n        );\n        try {\n            mockInstance = classInstantiator.instantiate(mockedProxyType);\n        } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n            throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n        }\n    }\n\n    /*\n    Set the MockitoInterceptor on the mock object.\n    */\n    MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n    mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n    return ensureMockIsAssignableToMockedType(settings, mockInstance);\n\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\nindex 9dc44e663..7ee1a457d 100644\n--- a/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n+++ b/src/org/mockito/internal/creation/bytebuddy/ByteBuddyMockMaker.java\n@@ -21,37 +21,53 @@ public class ByteBuddyMockMaker implements MockMaker {\n         cachingMockBytecodeGenerator = new CachingMockBytecodeGenerator();\n     }\n \n-    public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n-        if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n-            throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n+public <T> T createMock(MockCreationSettings<T> settings, MockHandler handler) {\n+    if (settings.getSerializableMode() == SerializableMode.ACROSS_CLASSLOADERS) {\n+        throw new MockitoException(\"Serialization across classloaders not yet supported with ByteBuddyMockMaker\");\n+    }\n+    Class<?> typeToMock = settings.getTypeToMock();\n+\n+    T mockInstance = null;\n+\n+    if (typeToMock.isMemberClass() && !Modifier.isStatic(typeToMock.getModifiers())) {\n+        /*\n+        For inner non-static classes, we must provide a reference to the outer instance\n+        to the constructor of the mock object. This is necessary because the mock object\n+        needs to have access to the outer instance's fields and methods. We create the mock\n+        object manually using reflection in order to pass this reference to the constructor.\n+         */\n+        Object outerInstance = Mockito.mock(typeToMock.getEnclosingClass());\n+        try {\n+            Constructor<T> ctor = typeToMock.getDeclaredConstructor(typeToMock.getEnclosingClass());\n+            ctor.setAccessible(true);\n+            mockInstance = ctor.newInstance(outerInstance);\n+        } catch (NoSuchMethodException | InstantiationException | IllegalAccessException | InvocationTargetException e) {\n+            throw new MockitoException(\"Unable to create mock object for non-static inner class: \" + typeToMock, e);\n         }\n+    } else {\n+        /*\n+        For all other classes, just use the default mock creation process.\n+         */\n         Class<? extends T> mockedProxyType = cachingMockBytecodeGenerator.get(\n                 settings.getTypeToMock(),\n                 settings.getExtraInterfaces()\n         );\n-        T mockInstance = null;\n         try {\n             mockInstance = classInstantiator.instantiate(mockedProxyType);\n-            MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n-            mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n-\n-            return ensureMockIsAssignableToMockedType(settings, mockInstance);\n-        } catch (ClassCastException cce) {\n-            throw new MockitoException(join(\n-                    \"ClassCastException occurred while creating the mockito mock :\",\n-                    \"  class to mock : \" + describeClass(mockedProxyType),\n-                    \"  created class : \" + describeClass(settings.getTypeToMock()),\n-                    \"  proxy instance class : \" + describeClass(mockInstance),\n-                    \"  instance creation by : \" + classInstantiator.getClass().getSimpleName(),\n-                    \"\",\n-                    \"You might experience classloading issues, please ask the mockito mailing-list.\",\n-                    \"\"\n-            ),cce);\n         } catch (org.mockito.internal.creation.instance.InstantiationException e) {\n             throw new MockitoException(\"Unable to create mock instance of type '\" + mockedProxyType.getSuperclass().getSimpleName() + \"'\", e);\n         }\n     }\n \n+    /*\n+    Set the MockitoInterceptor on the mock object.\n+    */\n+    MockMethodInterceptor.MockAccess mockAccess = (MockMethodInterceptor.MockAccess) mockInstance;\n+    mockAccess.setMockitoInterceptor(new MockMethodInterceptor(asInternalMockHandler(handler), settings));\n+    return ensureMockIsAssignableToMockedType(settings, mockInstance);\n+\n+}\n+\n     private <T> T ensureMockIsAssignableToMockedType(MockCreationSettings<T> settings, T mock) {\n         // Force explicit cast to mocked type here, instead of\n         // relying on the JVM to implicitly cast on the client call site.",
    "result_reason": "error: multi-catch statement is not supported in -source 1.5",
    "test_result": "ERROR"
}