{
    "patch": "DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\nint[] newValues = new int[newTypes.length];\n\n// find correct insertion point to keep largest-smallest order\nint i = 0;\nDurationField unitField = fieldType.getDurationType().getField(iChronology);\nif (unitField.isSupported()) {\n    for (; i < iTypes.length; i++) {\n        DateTimeFieldType loopType = iTypes[i];\n        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n        if (loopUnitField.isSupported()) {\n            int compare = unitField.compareTo(loopUnitField);\n            if (compare > 0) {\n                break;\n            } else if (compare == 0) {\n                DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n                DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n                if (rangeField.compareTo(loopRangeField) > 0) {\n                    break;\n                }\n            }\n        }\n    }\n}\nSystem.arraycopy(iTypes, 0, newTypes, 0, i);\nSystem.arraycopy(iValues, 0, newValues, 0, i);\nnewTypes[i] = fieldType;\nnewValues[i] = value;\nSystem.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\nSystem.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n\nPartial newPartial = new Partial(newTypes, newValues);\nnewPartial = newPartial.withChronology(iChronology);\nreturn newPartial;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/Partial.java b/src/main/java/org/joda/time/Partial.java\nindex 0d4edf47..1c954846 100644\n--- a/src/main/java/org/joda/time/Partial.java\n+++ b/src/main/java/org/joda/time/Partial.java\n@@ -461,7 +461,40 @@ public final class Partial\n             System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n             // use public constructor to ensure full validation\n             // this isn't overly efficient, but is safe\n-            Partial newPartial = new Partial(iChronology, newTypes, newValues);\n+DateTimeFieldType[] newTypes = new DateTimeFieldType[iTypes.length + 1];\n+int[] newValues = new int[newTypes.length];\n+\n+// find correct insertion point to keep largest-smallest order\n+int i = 0;\n+DurationField unitField = fieldType.getDurationType().getField(iChronology);\n+if (unitField.isSupported()) {\n+    for (; i < iTypes.length; i++) {\n+        DateTimeFieldType loopType = iTypes[i];\n+        DurationField loopUnitField = loopType.getDurationType().getField(iChronology);\n+        if (loopUnitField.isSupported()) {\n+            int compare = unitField.compareTo(loopUnitField);\n+            if (compare > 0) {\n+                break;\n+            } else if (compare == 0) {\n+                DurationField rangeField = fieldType.getRangeDurationType().getField(iChronology);\n+                DurationField loopRangeField = loopType.getRangeDurationType().getField(iChronology);\n+                if (rangeField.compareTo(loopRangeField) > 0) {\n+                    break;\n+                }\n+            }\n+        }\n+    }\n+}\n+System.arraycopy(iTypes, 0, newTypes, 0, i);\n+System.arraycopy(iValues, 0, newValues, 0, i);\n+newTypes[i] = fieldType;\n+newValues[i] = value;\n+System.arraycopy(iTypes, i, newTypes, i + 1, newTypes.length - i - 1);\n+System.arraycopy(iValues, i, newValues, i + 1, newValues.length - i - 1);\n+\n+Partial newPartial = new Partial(newTypes, newValues);\n+newPartial = newPartial.withChronology(iChronology);\n+return newPartial;\n             iChronology.validate(newPartial, newValues);\n             return newPartial;\n         }",
    "result_reason": "error: variable newTypes is already defined in method with(DateTimeFieldType,int)",
    "test_result": "ERROR"
}