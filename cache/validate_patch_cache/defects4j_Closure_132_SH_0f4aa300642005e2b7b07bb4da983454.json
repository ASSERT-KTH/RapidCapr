{
    "patch": "              areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              NodeUtil.mayHaveSideEffects(thenOp)) {\n\n            n.removeChild(cond);\n            Node assignName = thenOp.removeFirstChild();\n            Node testHookNode = IR.hook(cond.cloneTree(), IR.trueNode(), IR.falseNode());\n            Node thenHookNode = IR.hook(\n                testHookNode.cloneTree(), thenOp.cloneTree(), elseOp.getLastChild().cloneTree());\n            Node elseHookNode = IR.hook(\n                assignName.cloneTree(), thenOp.removeFirstChild(), IR.undefined());\n            Node hookNode = IR.hook(\n                testHookNode.cloneTree(), thenHookNode, elseHookNode\n            ).srcref(n);\n            Node expr = NodeUtil.newExpr(hookNode);\n            parent.replaceChild(n, expr);\n            reportCodeChange();\n\n            return expr;\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..adaba4d6 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,25 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n+              NodeUtil.mayHaveSideEffects(thenOp)) {\n+\n+            n.removeChild(cond);\n+            Node assignName = thenOp.removeFirstChild();\n+            Node testHookNode = IR.hook(cond.cloneTree(), IR.trueNode(), IR.falseNode());\n+            Node thenHookNode = IR.hook(\n+                testHookNode.cloneTree(), thenOp.cloneTree(), elseOp.getLastChild().cloneTree());\n+            Node elseHookNode = IR.hook(\n+                assignName.cloneTree(), thenOp.removeFirstChild(), IR.undefined());\n+            Node hookNode = IR.hook(\n+                testHookNode.cloneTree(), thenHookNode, elseHookNode\n+            ).srcref(n);\n+            Node expr = NodeUtil.newExpr(hookNode);\n+            parent.replaceChild(n, expr);\n+            reportCodeChange();\n+\n+            return expr;\n+          }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}