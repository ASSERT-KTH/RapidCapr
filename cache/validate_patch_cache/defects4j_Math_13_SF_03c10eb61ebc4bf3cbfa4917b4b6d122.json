{
    "patch": "        final int n = m.getRowDimension();\n        final double[][] a = m.getData();\n\n        // Compute the Cholesky decomposition\n        final CholeskyDecomposition cholesky = new CholeskyDecomposition(m);\n\n        // Compute the lower triangular matrix L\n        final double[][] lData = new double[n][n];\n        for (int i = 0; i < n; i++) {\n          for (int j = 0; j < (i + 1); j++) {\n            double sum = 0.0d;\n            for (int k = 0; k < j; k++) {\n              sum += lData[i][k] * lData[j][k];\n            }\n            if (i == j) {\n              lData[i][j] = Math.sqrt(a[i][i] - sum);\n            } else {\n              lData[i][j] = (1.0d / lData[j][j]) * (a[i][j] - sum);\n            }\n          }\n        }\n\n        // Compute L^T * L\n        final double[][] lTlData = new double[n][n];\n        for (int i = 0; i < n; i++) {\n          for (int j = 0; j <= i; j++) {\n            double sum = 0.0d;\n            for (int k = i; k < n; k++) {\n              sum += lData[k][i] * lData[k][j];\n            }\n            lTlData[j][i] = sum;\n            lTlData[i][j] = sum;\n          }\n        }\n\n        // Create the square root matrix\n        final RealMatrix lTl = MatrixUtils.createRealMatrix(lTlData);\n        final RealMatrix l = MatrixUtils.createRealMatrix(lData);\n        final RealMatrix lT = l.transpose();\n        final RealMatrix lTlSqrt = new CholeskyDecomposition(lTl).getL();\n        final RealMatrix result = l.multiply(lTlSqrt).multiply(lT);\n\n        return result;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..e1efddb01 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,47 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n-    }\n+        final int n = m.getRowDimension();\n+        final double[][] a = m.getData();\n+\n+        // Compute the Cholesky decomposition\n+        final CholeskyDecomposition cholesky = new CholeskyDecomposition(m);\n+\n+        // Compute the lower triangular matrix L\n+        final double[][] lData = new double[n][n];\n+        for (int i = 0; i < n; i++) {\n+          for (int j = 0; j < (i + 1); j++) {\n+            double sum = 0.0d;\n+            for (int k = 0; k < j; k++) {\n+              sum += lData[i][k] * lData[j][k];\n+            }\n+            if (i == j) {\n+              lData[i][j] = Math.sqrt(a[i][i] - sum);\n+            } else {\n+              lData[i][j] = (1.0d / lData[j][j]) * (a[i][j] - sum);\n+            }\n+          }\n+        }\n+\n+        // Compute L^T * L\n+        final double[][] lTlData = new double[n][n];\n+        for (int i = 0; i < n; i++) {\n+          for (int j = 0; j <= i; j++) {\n+            double sum = 0.0d;\n+            for (int k = i; k < n; k++) {\n+              sum += lData[k][i] * lData[k][j];\n+            }\n+            lTlData[j][i] = sum;\n+            lTlData[i][j] = sum;\n+          }\n+        }\n+\n+        // Create the square root matrix\n+        final RealMatrix lTl = MatrixUtils.createRealMatrix(lTlData);\n+        final RealMatrix l = MatrixUtils.createRealMatrix(lData);\n+        final RealMatrix lT = l.transpose();\n+        final RealMatrix lTlSqrt = new CholeskyDecomposition(lTl).getL();\n+        final RealMatrix result = l.multiply(lTlSqrt).multiply(lT);\n+\n+        return result;\n }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}