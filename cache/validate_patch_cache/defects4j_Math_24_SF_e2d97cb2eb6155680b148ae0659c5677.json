{
    "patch": "protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        BigDecimal lo = BigDecimal.valueOf(getMin());\n        BigDecimal mid = BigDecimal.valueOf(getStartValue());\n        BigDecimal hi = BigDecimal.valueOf(getMax());\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n        BigDecimal a;\n        BigDecimal b;\n        if (lo.compareTo(hi) < 0) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        BigDecimal x = mid;\n        BigDecimal v = x;\n        BigDecimal w = x;\n        BigDecimal d = BigDecimal.ZERO;\n        BigDecimal e = BigDecimal.ZERO;\n        BigDecimal fx = BigDecimal.valueOf(computeObjectiveValue(x.doubleValue()));\n        if (!isMinim) {\n            fx = fx.negate();\n        }\n        BigDecimal fv = fx;\n        BigDecimal fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n                = new UnivariatePointValuePair(x.doubleValue(), isMinim ? fx.doubleValue() : -fx.doubleValue());\n\n        int iter = 0;\n        while (true) {\n            final BigDecimal m = (a.add(b)).multiply(BigDecimal.valueOf(0.5));\n            final BigDecimal tol1 = BigDecimal.valueOf(relativeThreshold)\n                    .multiply(x.abs())\n                    .add(BigDecimal.valueOf(absoluteThreshold));\n            final BigDecimal tol2 = tol1.multiply(BigDecimal.valueOf(2));\n\n            // Default stopping criterion.\n            final boolean stop = (x.subtract(m).abs().compareTo(tol2.subtract(b.subtract(a)).multiply(BigDecimal.valueOf(0.5))) <= 0);\n            if (!stop) {\n                BigDecimal p = BigDecimal.ZERO;\n                BigDecimal q = BigDecimal.ZERO;\n                BigDecimal r = BigDecimal.ZERO;\n                BigDecimal u;\n\n                if (e.abs().compareTo(tol1) > 0) { // Fit parabola.\n                    r = (x.subtract(w)).multiply(fx.subtract(fv));\n                    q = (x.subtract(v)).multiply(fx.subtract(fw));\n                    p = (x.subtract(v)).multiply(q).subtract((x.subtract(w)).multiply(r));\n                    q = q.multiply(BigDecimal.valueOf(2));\n\n                    if (q.compareTo(BigDecimal.ZERO) > 0) {\n                        p = p.negate();\n                    } else {\n                        q = q.negate();\n                    }\n\n                    r = e;\n                    e = d;\n\n                    if (p.compareTo(q.multiply(a.subtract(x))) > 0\n                            && p.compareTo(q.multiply(b.subtract(x))) < 0\n                            && p.abs().compareTo(BigDecimal.valueOf(0.5).multiply(q).multiply(r).abs()) < 0) {\n                        // Parabolic interpolation step.\n                        d = p.divide(q, RoundingMode.HALF_UP);\n                        u = x.add(d);\n\n                        // f must not be evaluated too close to a or b.\n                        if (u.subtract(a).compareTo(tol2.negate()) <= 0 || b.subtract(u).compareTo(tol2.negate()) <= 0) {\n                            if (x.compareTo(m) <= 0) {\n                                d = tol1;\n                            } else {\n                                d = tol1.negate();\n                            }\n                        }\n                    } else {\n                        // Golden section step.\n                        if (x.compareTo(m) < 0) {\n                            e = b.subtract(x);\n                        } else {\n                            e = a.subtract(x);\n                        }\n                        d = e.multiply(BigDecimal.valueOf(GOLDEN_SECTION));\n                    }\n                } else {\n                    // Golden section step.\n                    if (x.compareTo(m) < 0) {\n                        e = b.subtract(x);\n                    } else {\n                        e = a.subtract(x);\n                    }\n                    d = e.multiply(BigDecimal.valueOf(GOLDEN_SECTION));\n                }\n\n                // Update by at least \"tol1\".\n                if (d.abs().compareTo(tol1) < 0) {\n                    if (d.compareTo(BigDecimal.ZERO) >= 0) {\n                        u = x.add(tol1);\n                    } else {\n                        u = x.subtract(tol1);\n                    }\n                } else {\n                    u = x.add(d);\n                }\n\n                BigDecimal fu = BigDecimal.valueOf(computeObjectiveValue(u.doubleValue()));\n                if (!isMinim) {\n                    fu = fu.negate();\n                }\n\n                // User-defined convergence checker.\n                previous = current;\n                current = new UnivariatePointValuePair(u.doubleValue(), isMinim ? fu.doubleValue() : -fu.doubleValue());\n\n                if (checker != null) {\n                    if (checker.converged(iter, previous, current)) {\n                        return current;\n                    }\n                }\n\n                // Update a, b, v, w and x.\n                if (fu.compareTo(fx) <= 0) {\n                    if (u.compareTo(x) < 0) {\n                        b = x;\n                    } else {\n                        a = x;\n                    }\n                    v = w;\n                    fv = fw;\n                    w = x;\n                    fw = fx;\n                    x = u;\n                    fx = fu;\n                } else {\n                    if (u.compareTo(x) < 0) {\n                        a = u;\n                    } else {\n                        b = u;\n                    }\n                    if (fu.compareTo(fw) <= 0\n                            || Precision.equals(w.doubleValue(), x.doubleValue())) {\n                        v = w;\n                        fv = fw;\n                        w = u;\n                        fw = fu;\n                    } else if (fu.compareTo(fv) <= 0\n                            || Precision.equals(v.doubleValue(), x.doubleValue())\n                            || Precision.equals(v.doubleValue(), w.doubleValue())) {\n                        v = u;\n                        fv = fu;\n                    }\n                }\n            } else { // Default termination (Brent's criterion).\n                return current;\n            }\n            ++iter;\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex b6ce68ef3..1113cfba9 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -106,19 +106,18 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariatePointValuePair doOptimize() {\n+protected UnivariatePointValuePair doOptimize() {\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n-        final double lo = getMin();\n-        final double mid = getStartValue();\n-        final double hi = getMax();\n+        BigDecimal lo = BigDecimal.valueOf(getMin());\n+        BigDecimal mid = BigDecimal.valueOf(getStartValue());\n+        BigDecimal hi = BigDecimal.valueOf(getMax());\n \n         // Optional additional convergence criteria.\n-        final ConvergenceChecker<UnivariatePointValuePair> checker\n-            = getConvergenceChecker();\n+        final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n \n-        double a;\n-        double b;\n-        if (lo < hi) {\n+        BigDecimal a;\n+        BigDecimal b;\n+        if (lo.compareTo(hi) < 0) {\n             a = lo;\n             b = hi;\n         } else {\n@@ -126,104 +125,106 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n             b = lo;\n         }\n \n-        double x = mid;\n-        double v = x;\n-        double w = x;\n-        double d = 0;\n-        double e = 0;\n-        double fx = computeObjectiveValue(x);\n+        BigDecimal x = mid;\n+        BigDecimal v = x;\n+        BigDecimal w = x;\n+        BigDecimal d = BigDecimal.ZERO;\n+        BigDecimal e = BigDecimal.ZERO;\n+        BigDecimal fx = BigDecimal.valueOf(computeObjectiveValue(x.doubleValue()));\n         if (!isMinim) {\n-            fx = -fx;\n+            fx = fx.negate();\n         }\n-        double fv = fx;\n-        double fw = fx;\n+        BigDecimal fv = fx;\n+        BigDecimal fw = fx;\n \n         UnivariatePointValuePair previous = null;\n         UnivariatePointValuePair current\n-            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+                = new UnivariatePointValuePair(x.doubleValue(), isMinim ? fx.doubleValue() : -fx.doubleValue());\n \n         int iter = 0;\n         while (true) {\n-            final double m = 0.5 * (a + b);\n-            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n-            final double tol2 = 2 * tol1;\n+            final BigDecimal m = (a.add(b)).multiply(BigDecimal.valueOf(0.5));\n+            final BigDecimal tol1 = BigDecimal.valueOf(relativeThreshold)\n+                    .multiply(x.abs())\n+                    .add(BigDecimal.valueOf(absoluteThreshold));\n+            final BigDecimal tol2 = tol1.multiply(BigDecimal.valueOf(2));\n \n             // Default stopping criterion.\n-            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n+            final boolean stop = (x.subtract(m).abs().compareTo(tol2.subtract(b.subtract(a)).multiply(BigDecimal.valueOf(0.5))) <= 0);\n             if (!stop) {\n-                double p = 0;\n-                double q = 0;\n-                double r = 0;\n-                double u = 0;\n+                BigDecimal p = BigDecimal.ZERO;\n+                BigDecimal q = BigDecimal.ZERO;\n+                BigDecimal r = BigDecimal.ZERO;\n+                BigDecimal u;\n \n-                if (FastMath.abs(e) > tol1) { // Fit parabola.\n-                    r = (x - w) * (fx - fv);\n-                    q = (x - v) * (fx - fw);\n-                    p = (x - v) * q - (x - w) * r;\n-                    q = 2 * (q - r);\n+                if (e.abs().compareTo(tol1) > 0) { // Fit parabola.\n+                    r = (x.subtract(w)).multiply(fx.subtract(fv));\n+                    q = (x.subtract(v)).multiply(fx.subtract(fw));\n+                    p = (x.subtract(v)).multiply(q).subtract((x.subtract(w)).multiply(r));\n+                    q = q.multiply(BigDecimal.valueOf(2));\n \n-                    if (q > 0) {\n-                        p = -p;\n+                    if (q.compareTo(BigDecimal.ZERO) > 0) {\n+                        p = p.negate();\n                     } else {\n-                        q = -q;\n+                        q = q.negate();\n                     }\n \n                     r = e;\n                     e = d;\n \n-                    if (p > q * (a - x) &&\n-                        p < q * (b - x) &&\n-                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n+                    if (p.compareTo(q.multiply(a.subtract(x))) > 0\n+                            && p.compareTo(q.multiply(b.subtract(x))) < 0\n+                            && p.abs().compareTo(BigDecimal.valueOf(0.5).multiply(q).multiply(r).abs()) < 0) {\n                         // Parabolic interpolation step.\n-                        d = p / q;\n-                        u = x + d;\n+                        d = p.divide(q, RoundingMode.HALF_UP);\n+                        u = x.add(d);\n \n                         // f must not be evaluated too close to a or b.\n-                        if (u - a < tol2 || b - u < tol2) {\n-                            if (x <= m) {\n+                        if (u.subtract(a).compareTo(tol2.negate()) <= 0 || b.subtract(u).compareTo(tol2.negate()) <= 0) {\n+                            if (x.compareTo(m) <= 0) {\n                                 d = tol1;\n                             } else {\n-                                d = -tol1;\n+                                d = tol1.negate();\n                             }\n                         }\n                     } else {\n                         // Golden section step.\n-                        if (x < m) {\n-                            e = b - x;\n+                        if (x.compareTo(m) < 0) {\n+                            e = b.subtract(x);\n                         } else {\n-                            e = a - x;\n+                            e = a.subtract(x);\n                         }\n-                        d = GOLDEN_SECTION * e;\n+                        d = e.multiply(BigDecimal.valueOf(GOLDEN_SECTION));\n                     }\n                 } else {\n                     // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n+                    if (x.compareTo(m) < 0) {\n+                        e = b.subtract(x);\n                     } else {\n-                        e = a - x;\n+                        e = a.subtract(x);\n                     }\n-                    d = GOLDEN_SECTION * e;\n+                    d = e.multiply(BigDecimal.valueOf(GOLDEN_SECTION));\n                 }\n \n                 // Update by at least \"tol1\".\n-                if (FastMath.abs(d) < tol1) {\n-                    if (d >= 0) {\n-                        u = x + tol1;\n+                if (d.abs().compareTo(tol1) < 0) {\n+                    if (d.compareTo(BigDecimal.ZERO) >= 0) {\n+                        u = x.add(tol1);\n                     } else {\n-                        u = x - tol1;\n+                        u = x.subtract(tol1);\n                     }\n                 } else {\n-                    u = x + d;\n+                    u = x.add(d);\n                 }\n \n-                double fu = computeObjectiveValue(u);\n+                BigDecimal fu = BigDecimal.valueOf(computeObjectiveValue(u.doubleValue()));\n                 if (!isMinim) {\n-                    fu = -fu;\n+                    fu = fu.negate();\n                 }\n \n                 // User-defined convergence checker.\n                 previous = current;\n-                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+                current = new UnivariatePointValuePair(u.doubleValue(), isMinim ? fu.doubleValue() : -fu.doubleValue());\n \n                 if (checker != null) {\n                     if (checker.converged(iter, previous, current)) {\n@@ -232,8 +233,8 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                 }\n \n                 // Update a, b, v, w and x.\n-                if (fu <= fx) {\n-                    if (u < x) {\n+                if (fu.compareTo(fx) <= 0) {\n+                    if (u.compareTo(x) < 0) {\n                         b = x;\n                     } else {\n                         a = x;\n@@ -245,20 +246,20 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n                     x = u;\n                     fx = fu;\n                 } else {\n-                    if (u < x) {\n+                    if (u.compareTo(x) < 0) {\n                         a = u;\n                     } else {\n                         b = u;\n                     }\n-                    if (fu <= fw ||\n-                        Precision.equals(w, x)) {\n+                    if (fu.compareTo(fw) <= 0\n+                            || Precision.equals(w.doubleValue(), x.doubleValue())) {\n                         v = w;\n                         fv = fw;\n                         w = u;\n                         fw = fu;\n-                    } else if (fu <= fv ||\n-                               Precision.equals(v, x) ||\n-                               Precision.equals(v, w)) {\n+                    } else if (fu.compareTo(fv) <= 0\n+                            || Precision.equals(v.doubleValue(), x.doubleValue())\n+                            || Precision.equals(v.doubleValue(), w.doubleValue())) {\n                         v = u;\n                         fv = fu;\n                     }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}