{
    "patch": "        int year = iDefaultYear; // new line to fix weekyear bug\n\n        if (count > 0) {\n            // alter base year for parsing if first field is month or day\n            DurationField months = DurationFieldType.months().getField(iChrono);\n            DurationField days = DurationFieldType.days().getField(iChrono);\n            DurationField first = savedFields[0].iField.getDurationField();\n            if (compareReverse(first, months) >= 0 && compareReverse(first, days) <= 0) {\n                saveField(DateTimeFieldType.year(), iDefaultYear);\n                return computeMillis(resetFields, text);\n            }\n\n            // Fix the order of weekyear, year and centuryOfEra if necessary\n            DurationFieldType fieldType = savedFields[0].iField.getType();\n            if (fieldType == DateTimeFieldType.weekyear()) {\n                // Get the year and adjust the saved fields accordingly\n                Partial p = new Partial(iChrono, new DateTimeField[] { savedFields[0].iField }, new int[] { savedFields[0].iValue });\n                int weekyear = iChrono.weekyear().roundCeiling(p);\n                if (weekyear <= 0) {\n                    weekyear = iDefaultYear;\n                }\n                Partial p2 = new Partial(iChrono, new DateTimeField[] { DateTimeFieldType.year(), DateTimeFieldType.weekyear(), DateTimeFieldType.centuryOfEra() },\n                                                new int[] { weekyear, weekyear, iDefaultYear / 100 });\n                savedFields = replaceFields(savedFields, p2);\n                count = savedFields.length;\n                fieldType = savedFields[0].iField.getType();\n                year = weekyear;\n            }\n            if (fieldType == DateTimeFieldType.year()) {\n                // Check if it needs to adjust the century\n                DurationField centuryField = iChrono.centuryOfEra().getField(iChrono);\n                Partial p = new Partial(iChrono, new DateTimeField[] { savedFields[0].iField, DateTimeFieldType.centuryOfEra() },\n                                     new int[] { savedFields[0].iValue, iChrono.centuryOfEra().get(iMillis) });\n                int yearOfCentury = iChrono.yearOfCentury().roundCeiling(p);\n                int century = (yearOfCentury <= 0 ? year / 100 - 1 : year / 100);\n                Partial p2 = new Partial(iChrono, new DateTimeField[] { DateTimeFieldType.centuryOfEra(), savedFields[0].iField },\n                                     new int[] { century, yearOfCentury });\n                savedFields = replaceFields(savedFields, p2);\n                count = savedFields.length;\n            }\n        }\n\n        long millis = iMillis;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (text != null) {\n                e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n            }\n            throw e;\n        }\n\n        if (iZone == null) {\n            millis -= iOffset;\n        } else {\n            int offset = iZone.getOffsetFromLocal(millis);\n            millis -= offset;\n            if (offset != iZone.getOffset(millis)) {\n                String message =\n                        \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                if (text != null) {\n                    message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                }\n                throw new IllegalArgumentException(message);\n            }\n        }\n\n        return millis;\n    }\n\n    private SavedField[] replaceFields(SavedField[] savedFields, Partial partial) {\n        SavedField[] newSavedFields = new SavedField[savedFields.length];\n        int[] yearMonthDay = partial.getValues(); // year, monthOfYear, dayOfMonth\n        for (int i = 0; i < savedFields.length; i++) {\n            DateTimeField field = savedFields[i].iField;\n            int value = savedFields[i].iValue;\n            if (field.getType() == DateTimeFieldType.year()) {\n                field = partial.getField(DateTimeFieldType.yearOfEra());\n                value = yearMonthDay[0] + (value < 0 ? 1 : 0);\n            } else if (field.getType() == DateTimeFieldType.monthOfYear()) {\n                field = partial.getField(DateTimeFieldType.monthOfYear());\n                value = yearMonthDay[1];\n            } else if (field.getType() == DateTimeFieldType.dayOfMonth()) {\n                field = partial.getField(DateTimeFieldType.dayOfMonth());\n                value = yearMonthDay[2];\n            } else if (field.getType() == DateTimeFieldType.weekyear()) {\n                // Update to full year now that century is known\n                field = partial.getField(DateTimeFieldType.weekyear());\n                value = yearMonthDay[0];\n            }\n            newSavedFields[i] = new SavedField(field, value);\n        }\n        return newSavedFields;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..aa029e45 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -328,14 +328,8 @@ public class DateTimeParserBucket {\n      * @throws IllegalArgumentException if any field is out of range\n      * @since 1.3\n      */\n-    public long computeMillis(boolean resetFields, String text) {\n-        SavedField[] savedFields = iSavedFields;\n-        int count = iSavedFieldsCount;\n-        if (iSavedFieldsShared) {\n-            iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n-            iSavedFieldsShared = false;\n-        }\n-        sort(savedFields, count);\n+        int year = iDefaultYear; // new line to fix weekyear bug\n+\n         if (count > 0) {\n             // alter base year for parsing if first field is month or day\n             DurationField months = DurationFieldType.months().getField(iChrono);\n@@ -345,6 +339,35 @@ public class DateTimeParserBucket {\n                 saveField(DateTimeFieldType.year(), iDefaultYear);\n                 return computeMillis(resetFields, text);\n             }\n+\n+            // Fix the order of weekyear, year and centuryOfEra if necessary\n+            DurationFieldType fieldType = savedFields[0].iField.getType();\n+            if (fieldType == DateTimeFieldType.weekyear()) {\n+                // Get the year and adjust the saved fields accordingly\n+                Partial p = new Partial(iChrono, new DateTimeField[] { savedFields[0].iField }, new int[] { savedFields[0].iValue });\n+                int weekyear = iChrono.weekyear().roundCeiling(p);\n+                if (weekyear <= 0) {\n+                    weekyear = iDefaultYear;\n+                }\n+                Partial p2 = new Partial(iChrono, new DateTimeField[] { DateTimeFieldType.year(), DateTimeFieldType.weekyear(), DateTimeFieldType.centuryOfEra() },\n+                                                new int[] { weekyear, weekyear, iDefaultYear / 100 });\n+                savedFields = replaceFields(savedFields, p2);\n+                count = savedFields.length;\n+                fieldType = savedFields[0].iField.getType();\n+                year = weekyear;\n+            }\n+            if (fieldType == DateTimeFieldType.year()) {\n+                // Check if it needs to adjust the century\n+                DurationField centuryField = iChrono.centuryOfEra().getField(iChrono);\n+                Partial p = new Partial(iChrono, new DateTimeField[] { savedFields[0].iField, DateTimeFieldType.centuryOfEra() },\n+                                     new int[] { savedFields[0].iValue, iChrono.centuryOfEra().get(iMillis) });\n+                int yearOfCentury = iChrono.yearOfCentury().roundCeiling(p);\n+                int century = (yearOfCentury <= 0 ? year / 100 - 1 : year / 100);\n+                Partial p2 = new Partial(iChrono, new DateTimeField[] { DateTimeFieldType.centuryOfEra(), savedFields[0].iField },\n+                                     new int[] { century, yearOfCentury });\n+                savedFields = replaceFields(savedFields, p2);\n+                count = savedFields.length;\n+            }\n         }\n \n         long millis = iMillis;\n@@ -358,7 +381,7 @@ public class DateTimeParserBucket {\n             }\n             throw e;\n         }\n-        \n+\n         if (iZone == null) {\n             millis -= iOffset;\n         } else {\n@@ -366,16 +389,40 @@ public class DateTimeParserBucket {\n             millis -= offset;\n             if (offset != iZone.getOffset(millis)) {\n                 String message =\n-                    \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n+                        \"Illegal instant due to time zone offset transition (\" + iZone + ')';\n                 if (text != null) {\n                     message = \"Cannot parse \\\"\" + text + \"\\\": \" + message;\n                 }\n                 throw new IllegalArgumentException(message);\n             }\n         }\n-        \n+\n         return millis;\n     }\n+\n+    private SavedField[] replaceFields(SavedField[] savedFields, Partial partial) {\n+        SavedField[] newSavedFields = new SavedField[savedFields.length];\n+        int[] yearMonthDay = partial.getValues(); // year, monthOfYear, dayOfMonth\n+        for (int i = 0; i < savedFields.length; i++) {\n+            DateTimeField field = savedFields[i].iField;\n+            int value = savedFields[i].iValue;\n+            if (field.getType() == DateTimeFieldType.year()) {\n+                field = partial.getField(DateTimeFieldType.yearOfEra());\n+                value = yearMonthDay[0] + (value < 0 ? 1 : 0);\n+            } else if (field.getType() == DateTimeFieldType.monthOfYear()) {\n+                field = partial.getField(DateTimeFieldType.monthOfYear());\n+                value = yearMonthDay[1];\n+            } else if (field.getType() == DateTimeFieldType.dayOfMonth()) {\n+                field = partial.getField(DateTimeFieldType.dayOfMonth());\n+                value = yearMonthDay[2];\n+            } else if (field.getType() == DateTimeFieldType.weekyear()) {\n+                // Update to full year now that century is known\n+                field = partial.getField(DateTimeFieldType.weekyear());\n+                value = yearMonthDay[0];\n+            }\n+            newSavedFields[i] = new SavedField(field, value);\n+        }\n+        return newSavedFields;\n     \n     /**\n      * Sorts elements [0,high). Calling java.util.Arrays isn't always the right",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}