{
    "patch": "        JSType typeA = null;\n        JSType typeB = null;\n        if (this instanceof NamedType && that.isStructuralType()) {\n            typeB = that;\n        } else {\n            if (that instanceof NamedType && this.isStructuralType()) {\n                typeA = this;\n            } else {\n                TypeMismatch mismatch = this.getTypeMismatch(that, Registry.get().getNativeType(NUMBER_TYPE));\n                if (mismatch != null && mismatch.strong && mismatch.description != null &&\n                        mismatch.description.contains(\"Operand types do not match\")) {\n                    typeA = getLeastSupertypeIncludeProtectingUnknown(this, that);\n                    typeB = getLeastSupertypeIncludeProtectingUnknown(that, this);\n                } else {\n                    if (that.getFunType() != null && this.isLoose()) {\n                        typeA = that.getFunType().getImplicitContext();\n                    }\n                }\n            }\n        }\n        return new TypePair(typeA, typeB);",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/JSType.java b/src/com/google/javascript/rhino/jstype/JSType.java\nindex aa8c7bc9..47d32d8b 100644\n--- a/src/com/google/javascript/rhino/jstype/JSType.java\n+++ b/src/com/google/javascript/rhino/jstype/JSType.java\n@@ -703,7 +703,27 @@ public abstract class JSType implements Serializable {\n     // other types\n     switch (this.testForEquality(that)) {\n       case TRUE:\n-        return new TypePair(null, null);\n+        JSType typeA = null;\n+        JSType typeB = null;\n+        if (this instanceof NamedType && that.isStructuralType()) {\n+            typeB = that;\n+        } else {\n+            if (that instanceof NamedType && this.isStructuralType()) {\n+                typeA = this;\n+            } else {\n+                TypeMismatch mismatch = this.getTypeMismatch(that, Registry.get().getNativeType(NUMBER_TYPE));\n+                if (mismatch != null && mismatch.strong && mismatch.description != null &&\n+                        mismatch.description.contains(\"Operand types do not match\")) {\n+                    typeA = getLeastSupertypeIncludeProtectingUnknown(this, that);\n+                    typeB = getLeastSupertypeIncludeProtectingUnknown(that, this);\n+                } else {\n+                    if (that.getFunType() != null && this.isLoose()) {\n+                        typeA = that.getFunType().getImplicitContext();\n+                    }\n+                }\n+            }\n+        }\n+        return new TypePair(typeA, typeB);\n \n       case FALSE:\n       case UNKNOWN:",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}