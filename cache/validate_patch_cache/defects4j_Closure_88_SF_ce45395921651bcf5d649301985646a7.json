{
    "patch": "private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n  VariableLiveness result = VariableLiveness.MAYBE_LIVE;\n  // stop if the variable has been killed,\n  // otherwise return the live range state.\n  for (Node currentNode = n; currentNode != null; currentNode = currentNode.getNext()) {\n    if (NodeUtil.isName(currentNode)) {\n      if (variable.equals(currentNode.getString())) {\n        if (result == VariableLiveness.KILL) {\n          return VariableLiveness.KILL;\n        } else if (NodeUtil.isLhs(currentNode, currentNode.getParent())) {\n          return VariableLiveness.KILL;\n        } else {\n          result = VariableLiveness.READ;\n        }\n      }\n    } else if (NodeUtil.mayBeFunctionDeclaration(currentNode)) {\n      Node fnNameNode = currentNode.getFirstChild();\n      String fnName = fnNameNode.getString();\n      if (VariableRenamer.GETTER_SETTER_FUNCTIONS.contains(fnName)) {\n        fnNameNode = fnNameNode.getNext();\n        if (!fnNameNode.isString()) {\n          fnNameNode = fnNameNode.getNext();\n        }\n        if (fnNameNode != null && variable.equals(fnNameNode.getString())) {\n          return VariableLiveness.KILL;\n        }\n      } else {\n        result = isVariableReadBeforeKill(fnNameNode.getNext(), variable);\n      }\n    } else if (NodeUtil.isFunctionWithoutBody(currentNode)) {\n      currentNode = currentNode.getNext();\n      Preconditions.checkState(currentNode.isFunction());\n      result = isVariableReadBeforeKill(currentNode, variable);\n    } else if (NodeUtil.isLoopStructure(currentNode)) {\n      // This is needed to cover cases like `for (x.foo in fooArray) {...`\n      // without going through the RHS of the IN operator.\n      if (result == VariableLiveness.KILL) {\n        return VariableLiveness.KILL;\n      }\n      Node tempResult = isVariableReadBeforeKill(currentNode.getFirstChild(), variable);\n      if (tempResult == VariableLiveness.READ) {\n        // If we're doing a READ in a FOR/WHILE/DO, mark results as \"MAYBE_LIVE\"\n        // since we cannot determine if the variable will be killed or read after\n        // this point.\n        result = VariableLiveness.MAYBE_LIVE;\n      }\n    } else if (NodeUtil.isBlockControlStructure(currentNode)) {\n      VariableLiveness currentResult = isVariableReadBeforeKill(currentNode.getFirstChild(), variable);\n      if (currentResult == VariableLiveness.KILL) {\n        return VariableLiveness.KILL;\n      } else if (result == VariableLiveness.MAYBE_LIVE && currentResult == VariableLiveness.READ) {\n        // If we're accumulating MAYBE_LIVE here and we encounter a READ,\n        // update the result to be MAYBE_LIVE - we've found a new branch\n        // where we have a chance of being killed.\n        result = VariableLiveness.MAYBE_LIVE;\n      }\n    } else if (NodeUtil.isExpressionNode(currentNode)) {\n      if (result == VariableLiveness.KILL) {\n        return VariableLiveness.KILL;\n      }\n    } else if (!NodeUtil.isControlStructure(currentNode)) {\n      Node parent = currentNode.getParent();\n      if (result == VariableLiveness.KILL && !NodeUtil.isName(currentNode)) {\n        if (NodeUtil.isAssignmentOp(parent)\n            && currentNode.equals(parent.getLastChild())) {\n          result = VariableLiveness.READ;\n        } else if (NodeUtil.isNormalOrOptChainGet(parent)\n            && variable.equals(currentNode.getString())) {\n          // This is a property read. We can eliminate the false positive\n          // \"indirectly killed\" report.\n          return VariableLiveness.READ;\n        } else if (NodeUtil.isFunctionDeclaration(parent)) {\n          result = VariableLiveness.MAYBE_LIVE;\n        } else if (isVariableReadBeforeKill(currentNode.getFirstChild(), variable) == VariableLiveness.READ) {\n          result = VariableLiveness.MAYBE_LIVE;\n        }\n      }\n    }\n  }\n  return result;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\nindex ef33e4c0..c4728874 100644\n--- a/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n+++ b/src/com/google/javascript/jscomp/DeadAssignmentsElimination.java\n@@ -320,29 +320,85 @@ class DeadAssignmentsElimination extends AbstractPostOrderCallback implements\n    * reference of that variable is a read. It returns KILL, if the first\n    * reference of that variable is an assignment. It returns MAY_LIVE otherwise.\n    */\n-  private VariableLiveness isVariableReadBeforeKill(\n-      Node n, String variable) {\n-    if (NodeUtil.isName(n) && variable.equals(n.getString())) {\n-      if (NodeUtil.isLhs(n, n.getParent())) {\n-        // The expression to which the assignment is made is evaluated before\n-        // the RHS is evaluated (normal left to right evaluation) but the KILL\n-        // occurs after the RHS is evaluated.\n-        return VariableLiveness.KILL;\n+private VariableLiveness isVariableReadBeforeKill(Node n, String variable) {\n+  VariableLiveness result = VariableLiveness.MAYBE_LIVE;\n+  // stop if the variable has been killed,\n+  // otherwise return the live range state.\n+  for (Node currentNode = n; currentNode != null; currentNode = currentNode.getNext()) {\n+    if (NodeUtil.isName(currentNode)) {\n+      if (variable.equals(currentNode.getString())) {\n+        if (result == VariableLiveness.KILL) {\n+          return VariableLiveness.KILL;\n+        } else if (NodeUtil.isLhs(currentNode, currentNode.getParent())) {\n+          return VariableLiveness.KILL;\n+        } else {\n+          result = VariableLiveness.READ;\n+        }\n+      }\n+    } else if (NodeUtil.mayBeFunctionDeclaration(currentNode)) {\n+      Node fnNameNode = currentNode.getFirstChild();\n+      String fnName = fnNameNode.getString();\n+      if (VariableRenamer.GETTER_SETTER_FUNCTIONS.contains(fnName)) {\n+        fnNameNode = fnNameNode.getNext();\n+        if (!fnNameNode.isString()) {\n+          fnNameNode = fnNameNode.getNext();\n+        }\n+        if (fnNameNode != null && variable.equals(fnNameNode.getString())) {\n+          return VariableLiveness.KILL;\n+        }\n       } else {\n-        return VariableLiveness.READ;\n+        result = isVariableReadBeforeKill(fnNameNode.getNext(), variable);\n       }\n-    }\n-\n-    // Expressions are evaluated left-right, depth first.\n-    for (Node child = n.getFirstChild();\n-        child != null; child = child.getNext()) {\n-      if (!ControlFlowGraph.isEnteringNewCfgNode(child)) { // Not a FUNCTION\n-        VariableLiveness state = isVariableReadBeforeKill(child, variable);\n-        if (state != VariableLiveness.MAYBE_LIVE) {\n-          return state;\n+    } else if (NodeUtil.isFunctionWithoutBody(currentNode)) {\n+      currentNode = currentNode.getNext();\n+      Preconditions.checkState(currentNode.isFunction());\n+      result = isVariableReadBeforeKill(currentNode, variable);\n+    } else if (NodeUtil.isLoopStructure(currentNode)) {\n+      // This is needed to cover cases like `for (x.foo in fooArray) {...`\n+      // without going through the RHS of the IN operator.\n+      if (result == VariableLiveness.KILL) {\n+        return VariableLiveness.KILL;\n+      }\n+      Node tempResult = isVariableReadBeforeKill(currentNode.getFirstChild(), variable);\n+      if (tempResult == VariableLiveness.READ) {\n+        // If we're doing a READ in a FOR/WHILE/DO, mark results as \"MAYBE_LIVE\"\n+        // since we cannot determine if the variable will be killed or read after\n+        // this point.\n+        result = VariableLiveness.MAYBE_LIVE;\n+      }\n+    } else if (NodeUtil.isBlockControlStructure(currentNode)) {\n+      VariableLiveness currentResult = isVariableReadBeforeKill(currentNode.getFirstChild(), variable);\n+      if (currentResult == VariableLiveness.KILL) {\n+        return VariableLiveness.KILL;\n+      } else if (result == VariableLiveness.MAYBE_LIVE && currentResult == VariableLiveness.READ) {\n+        // If we're accumulating MAYBE_LIVE here and we encounter a READ,\n+        // update the result to be MAYBE_LIVE - we've found a new branch\n+        // where we have a chance of being killed.\n+        result = VariableLiveness.MAYBE_LIVE;\n+      }\n+    } else if (NodeUtil.isExpressionNode(currentNode)) {\n+      if (result == VariableLiveness.KILL) {\n+        return VariableLiveness.KILL;\n+      }\n+    } else if (!NodeUtil.isControlStructure(currentNode)) {\n+      Node parent = currentNode.getParent();\n+      if (result == VariableLiveness.KILL && !NodeUtil.isName(currentNode)) {\n+        if (NodeUtil.isAssignmentOp(parent)\n+            && currentNode.equals(parent.getLastChild())) {\n+          result = VariableLiveness.READ;\n+        } else if (NodeUtil.isNormalOrOptChainGet(parent)\n+            && variable.equals(currentNode.getString())) {\n+          // This is a property read. We can eliminate the false positive\n+          // \"indirectly killed\" report.\n+          return VariableLiveness.READ;\n+        } else if (NodeUtil.isFunctionDeclaration(parent)) {\n+          result = VariableLiveness.MAYBE_LIVE;\n+        } else if (isVariableReadBeforeKill(currentNode.getFirstChild(), variable) == VariableLiveness.READ) {\n+          result = VariableLiveness.MAYBE_LIVE;\n         }\n       }\n     }\n-    return VariableLiveness.MAYBE_LIVE;\n   }\n+  return result;\n+}\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}