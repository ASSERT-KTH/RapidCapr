{
    "patch": "public static double regularizedGammaP(double a, double x) {\n    if (a <= 0 || x < 0) {\n        throw new IllegalArgumentException(\"Invalid input arguments for the regularized gamma function.\");\n    }\n\n    if (x < a + 1) {\n        return 1 - regularizedGammaQ(a, x);\n    }\n\n    double c = evaluatePolynomial(x, lanczosCoefficients) + lanczosG + x + 0.5;\n    double approx = Math.pow(x + lanczosG + 0.5, a + 0.5) / Math.exp(x + lanczosG + 0.5)\n            * Math.sqrt(2 * Math.PI) * evaluatePolynomial(a, lanczosCoefficientsSeriesA) / a;\n\n    // Use series representation if approx is small enough\n    if (approx < 0.9) {\n        double series = lanczosSeries(a, x);\n        if (Math.abs((approx - series) / approx) < 0.3) {\n            return approx;\n        }\n    }\n\n    return approx * Math.pow(c, a) / x;\n}\n\npublic static double regularizedGammaQ(double a, double x) {\n    if (a <= 0 || x < 0) {\n        throw new IllegalArgumentException(\"Invalid input arguments for the regularized gamma function.\");\n    }\n\n    if (x < a + 1) {\n        return 1 - regularizedGammaP(a, x);\n    }\n\n    double y = a;\n    double z = x + y + 1;\n    double c = 0.0;\n    double pkm2 = 1.0;\n    double qkm2 = x;\n    double pkm1 = x + 1;\n    double qkm1 = z * x;\n    double ans = pkm1 / qkm1;\n    double error;\n\n    do {\n        c += 1.0;\n        y += 1.0;\n        z += 2.0;\n        double yc = y * c;\n        double pk = pkm1 * z - pkm2 * yc;\n        double qk = qkm1 * z - qkm2 * yc;\n        if (qk != 0) {\n            double r = pk / qk;\n            error = Math.abs((ans - r) / r);\n            ans = r;\n        } else {\n            // Continuation: see 8.17(ii)\n            error = 1.0;\n        }\n\n        pkm2 = pkm1;\n        pkm1 = pk;\n        qkm2 = qkm1;\n        qkm1 = qk;\n\n        if (Math.abs(pk) > MAX_VALUE) {\n            pkm2 /= MAX_VALUE;\n            pkm1 /= MAX_VALUE;\n            qkm2 /= MAX_VALUE;\n            qkm1 /= MAX_VALUE;\n        }\n    } while (error > EPSILON);\n\n    return ans;\n}\n\npublic static double evaluatePolynomial(double z, double[] coefficients) {\n    double res = coefficients[0];\n    for (int i = 1; i < coefficients.length; i++) {\n        res = res * z + coefficients[i];\n    }\n    return res;\n}\n\npublic static double lanczosSeries(double a, double x) {\n    double sum = 0.0;\n    double term = 1.0 / a;\n    double sign = 1.0;\n\n    for (int n = 1; n < MAX_ITERATIONS; n++) {\n        double nextTerm = term * x / (a + n);\n        sum += sign * nextTerm;\n\n        if (Math.abs(nextTerm) < TOLERANCE * Math.abs(sum)) {\n            return sum;\n        }\n\n        term = nextTerm;\n        sign = -sign;\n    }\n\n    // No convergence after MAX_ITERATIONS iterations.\n    throw new RuntimeException(\"Maximum number of iterations reached for the regularized gamma series.\");\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..3547dd7b4 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,109 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x) {\n+    if (a <= 0 || x < 0) {\n+        throw new IllegalArgumentException(\"Invalid input arguments for the regularized gamma function.\");\n+    }\n+\n+    if (x < a + 1) {\n+        return 1 - regularizedGammaQ(a, x);\n+    }\n+\n+    double c = evaluatePolynomial(x, lanczosCoefficients) + lanczosG + x + 0.5;\n+    double approx = Math.pow(x + lanczosG + 0.5, a + 0.5) / Math.exp(x + lanczosG + 0.5)\n+            * Math.sqrt(2 * Math.PI) * evaluatePolynomial(a, lanczosCoefficientsSeriesA) / a;\n+\n+    // Use series representation if approx is small enough\n+    if (approx < 0.9) {\n+        double series = lanczosSeries(a, x);\n+        if (Math.abs((approx - series) / approx) < 0.3) {\n+            return approx;\n+        }\n+    }\n+\n+    return approx * Math.pow(c, a) / x;\n+}\n+\n+public static double regularizedGammaQ(double a, double x) {\n+    if (a <= 0 || x < 0) {\n+        throw new IllegalArgumentException(\"Invalid input arguments for the regularized gamma function.\");\n+    }\n+\n+    if (x < a + 1) {\n+        return 1 - regularizedGammaP(a, x);\n+    }\n+\n+    double y = a;\n+    double z = x + y + 1;\n+    double c = 0.0;\n+    double pkm2 = 1.0;\n+    double qkm2 = x;\n+    double pkm1 = x + 1;\n+    double qkm1 = z * x;\n+    double ans = pkm1 / qkm1;\n+    double error;\n+\n+    do {\n+        c += 1.0;\n+        y += 1.0;\n+        z += 2.0;\n+        double yc = y * c;\n+        double pk = pkm1 * z - pkm2 * yc;\n+        double qk = qkm1 * z - qkm2 * yc;\n+        if (qk != 0) {\n+            double r = pk / qk;\n+            error = Math.abs((ans - r) / r);\n+            ans = r;\n+        } else {\n+            // Continuation: see 8.17(ii)\n+            error = 1.0;\n+        }\n+\n+        pkm2 = pkm1;\n+        pkm1 = pk;\n+        qkm2 = qkm1;\n+        qkm1 = qk;\n+\n+        if (Math.abs(pk) > MAX_VALUE) {\n+            pkm2 /= MAX_VALUE;\n+            pkm1 /= MAX_VALUE;\n+            qkm2 /= MAX_VALUE;\n+            qkm1 /= MAX_VALUE;\n+        }\n+    } while (error > EPSILON);\n+\n+    return ans;\n+}\n+\n+public static double evaluatePolynomial(double z, double[] coefficients) {\n+    double res = coefficients[0];\n+    for (int i = 1; i < coefficients.length; i++) {\n+        res = res * z + coefficients[i];\n+    }\n+    return res;\n+}\n+\n+public static double lanczosSeries(double a, double x) {\n+    double sum = 0.0;\n+    double term = 1.0 / a;\n+    double sign = 1.0;\n+\n+    for (int n = 1; n < MAX_ITERATIONS; n++) {\n+        double nextTerm = term * x / (a + n);\n+        sum += sign * nextTerm;\n+\n+        if (Math.abs(nextTerm) < TOLERANCE * Math.abs(sum)) {\n+            return sum;\n+        }\n+\n+        term = nextTerm;\n+        sign = -sign;\n+    }\n+\n+    // No convergence after MAX_ITERATIONS iterations.\n+    throw new RuntimeException(\"Maximum number of iterations reached for the regularized gamma series.\");\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}