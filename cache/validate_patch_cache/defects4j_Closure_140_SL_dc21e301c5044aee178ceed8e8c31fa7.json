{
    "patch": "JSModule.ModuleType type = module.getModuleType();\nif (type == JSModule.ModuleType.ES6_MODULE || type == JSModule.ModuleType.GOOG_MODULE) {\n  List<CompilerInput> inputs = module.getInputs();\n  if (inputs.size() > 0) {\n    return inputs.get(0).getAstRoot(this);\n  }\n  throw new IllegalStateException(\"Module has no input: \" + module.getName());\n} else if (type == JSModule.ModuleType.CJS_MODULE || type == JSModule.ModuleType.WEBPACK) {\n  Node astRoot = null;\n  boolean rootFound = false;\n  for (CompilerInput input : module.getInputs()) {\n    Node n = input.getAstRoot(this);\n    if (!n.hasChildren()) {\n      continue;\n    }\n    if (rootFound) {\n      // Throws an exception if we have two valid roots.\n      // The other option is to return one or the other, but every other module type\n      // can and does only have 0 or 1 valid roots, so this code would become unique just for these types of modules.\n      throw new IllegalStateException(\"Module has multiple inputs with code\");\n    }\n    rootFound = true;\n    astRoot = n;\n  }\n  if (astRoot != null) {\n    return astRoot;\n  }\n  throw new IllegalStateException(\"Module has no input with code: \" + module.getName());\n} else {\n  throw new IllegalStateException(\"Unsupported module type: \" + type);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..9a2d6647 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,68 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n+  public Region getSourceRegion(String sourceName, int lineNumber) {\n+    if (lineNumber < 1) {\n+      return null;\n+    }\n+    SourceFile input = getSourceFileByName(sourceName);\n+    if (input != null) {\n+      return input.getRegion(lineNumber);\n+    }\n+    return null;\n+  }\n \n-    checkFirstModule(modules);\n+  //------------------------------------------------------------------------\n+  // Package-private helpers\n+  //------------------------------------------------------------------------\n \n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n-    }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n+  @Override\n+  Node getNodeForCodeInsertion(JSModule module) {\n+    if (module == null) {\n+      if (inputs.length == 0) {\n+        throw new IllegalStateException(\"No inputs\");\n+      }\n \n-    initInputsByNameMap();\n-  }\n+      return inputs[0].getAstRoot(this);\n+    }\n \n-  /**\n-   * Do any initialization that is dependent on the compiler options.\n-   */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+    List<CompilerInput> inputs = module.getInputs();\n+    if (inputs.size() > 0) {\n+      return inputs.get(0).getAstRoot(this);\n     }\n+JSModule.ModuleType type = module.getModuleType();\n+if (type == JSModule.ModuleType.ES6_MODULE || type == JSModule.ModuleType.GOOG_MODULE) {\n+  List<CompilerInput> inputs = module.getInputs();\n+  if (inputs.size() > 0) {\n+    return inputs.get(0).getAstRoot(this);\n+  }\n+  throw new IllegalStateException(\"Module has no input: \" + module.getName());\n+} else if (type == JSModule.ModuleType.CJS_MODULE || type == JSModule.ModuleType.WEBPACK) {\n+  Node astRoot = null;\n+  boolean rootFound = false;\n+  for (CompilerInput input : module.getInputs()) {\n+    Node n = input.getAstRoot(this);\n+    if (!n.hasChildren()) {\n+      continue;\n+    }\n+    if (rootFound) {\n+      // Throws an exception if we have two valid roots.\n+      // The other option is to return one or the other, but every other module type\n+      // can and does only have 0 or 1 valid roots, so this code would become unique just for these types of modules.\n+      throw new IllegalStateException(\"Module has multiple inputs with code\");\n+    }\n+    rootFound = true;\n+    astRoot = n;\n+  }\n+  if (astRoot != null) {\n+    return astRoot;\n+  }\n+  throw new IllegalStateException(\"Module has no input with code: \" + module.getName());\n+} else {\n+  throw new IllegalStateException(\"Unsupported module type: \" + type);\n+}\n+    throw new IllegalStateException(\"Root module has no inputs\");\n   }\n-\n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}