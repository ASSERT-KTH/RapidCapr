{
    "patch": "        double mid, yMid, oldDelta;\n        \n        // Verify bracketing\n        double sign = yMin * yMax;\n        if (sign >= 0) {\n            // check if either value is close to a zero\n            if (Precision.EPSILON * Precision.SAFE_MINIMUM > FastMath.abs(yMin)) {\n                setResult(min, min);\n            } else if (Precision.EPSILON * Precision.SAFE_MINIMUM > FastMath.abs(yMax)) {\n                setResult(max, max);\n            } else {\n                // neither value is close to zero and min and max do not bracket root.\n                throw new IllegalArgumentException\n                (\"Function values at endpoints do not have different signs.\" +\n                        \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                        \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n            }\n        } else {\n            // Solve using Brent algorithm.\n            double delta = 0;\n            double yDelta = 0;\n            double x, fx;\n            if (FastMath.abs(yMin) < FastMath.abs(yMax)) {\n                double tmp = min;\n                min = max;\n                max = tmp;\n                tmp = yMin;\n                yMin = yMax;\n                yMax = tmp;\n            }\n            double[] bracket = {min, max};\n            double[] fy = {yMin, yMax};\n            boolean inverted = false;\n            \n            // Brent algorithm starts here.\n            while (true) {\n                oldDelta = delta;\n                delta = (max - min) / 2;\n                if (FastMath.abs(delta) <= 10 * Precision.EPSILON * FastMath.max(FastMath.abs(max), 1)) {\n                    setResult(min, max);\n                    return (min + max) / 2;\n                }\n                inverted ^= (yMin > 0);\n                if (fy[0] * fy[1] > 0) {\n                    min = bracket[0];\n                    yMin = fy[0];\n                    delta = inverted ? (bracket[1] - bracket[0]) / 2 : delta;\n                    bracket[0] = bracket[1];\n                    fy[0] = fy[1];\n                    max = bracket[1] = bracket[1] + delta;\n                    fy[1] = yMax = f.value(max);\n                    continue;\n                } else if (fy[0] == 0) {\n                    setResult(bracket[0], bracket[0]);\n                    return bracket[0];\n                } else if (fy[1] == 0) {\n                    setResult(bracket[1], bracket[1]);\n                    return bracket[1];\n                }\n                delta = inverted ? (bracket[0] - bracket[1]) / 2 : delta;\n                mid = bracket[1] - delta;\n                yMid = f.value(mid);\n                if (yMid == 0) {\n                    setResult(mid, mid);\n                    return mid;\n                }\n                if (inverted ? ((fy[0] < 0) ^ (yMid < 0)) : ((fy[0] > 0) ^ (yMid > 0))) {\n                    bracket[1] = mid;\n                    fy[1] = yMid;\n                } else {\n                    delta = inverted ? (bracket[1] - bracket[0]) / 2 : delta;\n                    mid = bracket[0] + delta;\n                    yMid = f.value(mid);\n                    if (yMid == 0) {\n                        setResult(mid, mid);\n                        return mid;\n                    }\n                    if (inverted ? ((fy[0] < 0) ^ (yMid < 0)) : ((fy[0] > 0) ^ (yMid > 0))) {\n                        bracket[1] = bracket[0];\n                        fy[1] = fy[0];\n                        bracket[0] = mid;\n                        fy[0] = yMid;\n                    } else {\n                      bracket[0] = mid;\n                      fy[0] = yMid;\n                      bracket[1] = bracket[1];\n                      fy[1] = fy[1];\n                    }\n                }\n            }",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/analysis/BrentSolver.java b/src/java/org/apache/commons/math/analysis/BrentSolver.java\nindex 766d87ed5..b7bcbbb19 100644\n--- a/src/java/org/apache/commons/math/analysis/BrentSolver.java\n+++ b/src/java/org/apache/commons/math/analysis/BrentSolver.java\n@@ -122,34 +122,96 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if min is not less than max or the\n      * signs of the values of the function at the endpoints are not opposites\n      */\n-    public double solve(double min, double max) throws MaxIterationsExceededException, \n-        FunctionEvaluationException {\n-        \n-        clearResult();\n-        verifyInterval(min, max);\n-        \n-        double ret = Double.NaN;\n-        \n-        double yMin = f.value(min);\n-        double yMax = f.value(max);\n+        double mid, yMid, oldDelta;\n         \n         // Verify bracketing\n         double sign = yMin * yMax;\n         if (sign >= 0) {\n             // check if either value is close to a zero\n+            if (Precision.EPSILON * Precision.SAFE_MINIMUM > FastMath.abs(yMin)) {\n+                setResult(min, min);\n+            } else if (Precision.EPSILON * Precision.SAFE_MINIMUM > FastMath.abs(yMax)) {\n+                setResult(max, max);\n+            } else {\n                 // neither value is close to zero and min and max do not bracket root.\n                 throw new IllegalArgumentException\n                 (\"Function values at endpoints do not have different signs.\" +\n                         \"  Endpoints: [\" + min + \",\" + max + \"]\" + \n                         \"  Values: [\" + yMin + \",\" + yMax + \"]\");\n+            }\n         } else {\n-            // solve using only the first endpoint as initial guess\n-            ret = solve(min, yMin, max, yMax, min, yMin);\n-            // either min or max is a root\n-        }\n-\n-        return ret;\n-    }\n+            // Solve using Brent algorithm.\n+            double delta = 0;\n+            double yDelta = 0;\n+            double x, fx;\n+            if (FastMath.abs(yMin) < FastMath.abs(yMax)) {\n+                double tmp = min;\n+                min = max;\n+                max = tmp;\n+                tmp = yMin;\n+                yMin = yMax;\n+                yMax = tmp;\n+            }\n+            double[] bracket = {min, max};\n+            double[] fy = {yMin, yMax};\n+            boolean inverted = false;\n+            \n+            // Brent algorithm starts here.\n+            while (true) {\n+                oldDelta = delta;\n+                delta = (max - min) / 2;\n+                if (FastMath.abs(delta) <= 10 * Precision.EPSILON * FastMath.max(FastMath.abs(max), 1)) {\n+                    setResult(min, max);\n+                    return (min + max) / 2;\n+                }\n+                inverted ^= (yMin > 0);\n+                if (fy[0] * fy[1] > 0) {\n+                    min = bracket[0];\n+                    yMin = fy[0];\n+                    delta = inverted ? (bracket[1] - bracket[0]) / 2 : delta;\n+                    bracket[0] = bracket[1];\n+                    fy[0] = fy[1];\n+                    max = bracket[1] = bracket[1] + delta;\n+                    fy[1] = yMax = f.value(max);\n+                    continue;\n+                } else if (fy[0] == 0) {\n+                    setResult(bracket[0], bracket[0]);\n+                    return bracket[0];\n+                } else if (fy[1] == 0) {\n+                    setResult(bracket[1], bracket[1]);\n+                    return bracket[1];\n+                }\n+                delta = inverted ? (bracket[0] - bracket[1]) / 2 : delta;\n+                mid = bracket[1] - delta;\n+                yMid = f.value(mid);\n+                if (yMid == 0) {\n+                    setResult(mid, mid);\n+                    return mid;\n+                }\n+                if (inverted ? ((fy[0] < 0) ^ (yMid < 0)) : ((fy[0] > 0) ^ (yMid > 0))) {\n+                    bracket[1] = mid;\n+                    fy[1] = yMid;\n+                } else {\n+                    delta = inverted ? (bracket[1] - bracket[0]) / 2 : delta;\n+                    mid = bracket[0] + delta;\n+                    yMid = f.value(mid);\n+                    if (yMid == 0) {\n+                        setResult(mid, mid);\n+                        return mid;\n+                    }\n+                    if (inverted ? ((fy[0] < 0) ^ (yMid < 0)) : ((fy[0] > 0) ^ (yMid > 0))) {\n+                        bracket[1] = bracket[0];\n+                        fy[1] = fy[0];\n+                        bracket[0] = mid;\n+                        fy[0] = yMid;\n+                    } else {\n+                      bracket[0] = mid;\n+                      fy[0] = yMid;\n+                      bracket[1] = bracket[1];\n+                      fy[1] = fy[1];\n+                    }\n+                }\n+            }\n         \n     /**\n      * Find a zero starting search according to the three provided points.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}