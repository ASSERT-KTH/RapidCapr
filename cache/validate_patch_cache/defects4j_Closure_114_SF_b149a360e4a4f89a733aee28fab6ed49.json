{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.graph.DiGraphEdge;\nimport com.google.javascript.jscomp.graph.DiGraph;\nimport com.google.javascript.jscomp.graph.DiGraphNode;\nimport com.google.javascript.rhino.Node;\n\nimport java.util.List;\n\npublic class RecordAssignmentHandler {\n    private AbstractCompiler compiler;\n    private DiGraph<Node, Branch> cfg;\n\n    public RecordAssignmentHandler(AbstractCompiler compiler, DiGraph<Node, Branch> cfg) {\n        this.compiler = compiler;\n        this.cfg = cfg;\n    }\n\n    private static class NameInformation {\n        // contents don't matter, it is a static inner class\n    }\n\n    private static enum Branch {\n        NORMAL,\n        ON_TRUE,\n        ON_FALSE,\n        ON_EX\n    }\n\n    private DiGraph<Node, Branch> getCfg() {\n        return cfg;\n    }\n\n    private NameInformation createNameInformation(NodeTraversal t, Node nameNode) {\n        return null; // implementation doesn't matter, it's a stub\n    }\n\n    private void recordDepScope(Node n, NameInformation ns) {\n        // implementation doesn't matter, it's a stub\n    }\n\n    private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n        Node nameNode = n.getFirstChild();\n        Node parent = n.getParent();\n        NameInformation ns = createNameInformation(t, nameNode);\n        if (ns != null) {\n            if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n                // Patch for assignments that appear in the init,\n                // condition or iteration part of a FOR loop.  Without\n                // this change, all 3 of those parts try to claim the for\n                // loop as their dependency scope.  The last assignment in\n                // those three fields wins, which can result in incorrect\n                // reference edges between referenced and assigned variables.\n                //\n                // TODO(user) revisit the dependency scope calculation\n                // logic.\n                if (parent.getFirstChild().getNext() == n) {\n                    recordDepScope(nameNode, ns);\n                } else {\n                    recordDepScope(recordNode, ns);\n                }\n            } else {\n                // The rhs of the assignment is the caller, so it's used by the\n                // context. Don't associate it w/ the lhs.\n                // FYI: this fixes only the specific case where the assignment is the\n                // caller expression, but it could be nested deeper in the caller and\n                // we would still get a bug.\n                // See testAssignWithCall2 for an example of this.\n                Node rhs = nameNode.getNext();\n                if (NodeUtil.isCall(rhs)) {\n                    recordDepScope(rhs, ns);\n                    return;\n                }\n                recordDepScope(recordNode, ns);\n            }\n        }\n    }\n\n    private boolean hasExceptionHandler(Node cfgNode) {\n        List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n        for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n            if (edge.getValue() == Branch.ON_EX) {\n                return true;\n            }\n        }\n        return false;\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 0fc5ae8f..d321180b 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -555,38 +555,95 @@ final class NameAnalyzer implements CompilerPass {\n       }\n     }\n \n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.graph.DiGraphEdge;\n+import com.google.javascript.jscomp.graph.DiGraph;\n+import com.google.javascript.jscomp.graph.DiGraphNode;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.List;\n+\n+public class RecordAssignmentHandler {\n+    private AbstractCompiler compiler;\n+    private DiGraph<Node, Branch> cfg;\n+\n+    public RecordAssignmentHandler(AbstractCompiler compiler, DiGraph<Node, Branch> cfg) {\n+        this.compiler = compiler;\n+        this.cfg = cfg;\n+    }\n+\n+    private static class NameInformation {\n+        // contents don't matter, it is a static inner class\n+    }\n+\n+    private static enum Branch {\n+        NORMAL,\n+        ON_TRUE,\n+        ON_FALSE,\n+        ON_EX\n+    }\n+\n+    private DiGraph<Node, Branch> getCfg() {\n+        return cfg;\n+    }\n+\n+    private NameInformation createNameInformation(NodeTraversal t, Node nameNode) {\n+        return null; // implementation doesn't matter, it's a stub\n+    }\n+\n+    private void recordDepScope(Node n, NameInformation ns) {\n+        // implementation doesn't matter, it's a stub\n+    }\n+\n     private void recordAssignment(NodeTraversal t, Node n, Node recordNode) {\n-      Node nameNode = n.getFirstChild();\n-      Node parent = n.getParent();\n-      NameInformation ns = createNameInformation(t, nameNode);\n-      if (ns != null) {\n-        if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n-          // Patch for assignments that appear in the init,\n-          // condition or iteration part of a FOR loop.  Without\n-          // this change, all 3 of those parts try to claim the for\n-          // loop as their dependency scope.  The last assignment in\n-          // those three fields wins, which can result in incorrect\n-          // reference edges between referenced and assigned variables.\n-          //\n-          // TODO(user) revisit the dependency scope calculation\n-          // logic.\n-          if (parent.getFirstChild().getNext() != n) {\n-            recordDepScope(recordNode, ns);\n-          } else {\n-            recordDepScope(nameNode, ns);\n-          }\n-        } else {\n-          // The rhs of the assignment is the caller, so it's used by the\n-          // context. Don't associate it w/ the lhs.\n-          // FYI: this fixes only the specific case where the assignment is the\n-          // caller expression, but it could be nested deeper in the caller and\n-          // we would still get a bug.\n-          // See testAssignWithCall2 for an example of this.\n-          recordDepScope(recordNode, ns);\n+        Node nameNode = n.getFirstChild();\n+        Node parent = n.getParent();\n+        NameInformation ns = createNameInformation(t, nameNode);\n+        if (ns != null) {\n+            if (parent.isFor() && !NodeUtil.isForIn(parent)) {\n+                // Patch for assignments that appear in the init,\n+                // condition or iteration part of a FOR loop.  Without\n+                // this change, all 3 of those parts try to claim the for\n+                // loop as their dependency scope.  The last assignment in\n+                // those three fields wins, which can result in incorrect\n+                // reference edges between referenced and assigned variables.\n+                //\n+                // TODO(user) revisit the dependency scope calculation\n+                // logic.\n+                if (parent.getFirstChild().getNext() == n) {\n+                    recordDepScope(nameNode, ns);\n+                } else {\n+                    recordDepScope(recordNode, ns);\n+                }\n+            } else {\n+                // The rhs of the assignment is the caller, so it's used by the\n+                // context. Don't associate it w/ the lhs.\n+                // FYI: this fixes only the specific case where the assignment is the\n+                // caller expression, but it could be nested deeper in the caller and\n+                // we would still get a bug.\n+                // See testAssignWithCall2 for an example of this.\n+                Node rhs = nameNode.getNext();\n+                if (NodeUtil.isCall(rhs)) {\n+                    recordDepScope(rhs, ns);\n+                    return;\n+                }\n+                recordDepScope(recordNode, ns);\n+            }\n         }\n-      }\n     }\n \n+    private boolean hasExceptionHandler(Node cfgNode) {\n+        List<DiGraphEdge<Node, Branch>> branchEdges = getCfg().getOutEdges(cfgNode);\n+        for (DiGraphEdge<Node, Branch> edge : branchEdges) {\n+            if (edge.getValue() == Branch.ON_EX) {\n+                return true;\n+            }\n+        }\n+        return false;\n+    }\n+}\n+\n     /**\n      * Defines a dependency scope.\n      */",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}