{
    "patch": "if (functionType.hasInstanceType() && n.getParent().isGetProp()) {\n  String propName = n.getParent().getLastChild().getString();\n  String error = null;\n\n  // Do not check unused variables.\n  if (!compiler.getCompilerOptions().isWarningLevelSuppressed(\n          CheckLevel.WARNING) &&\n      !NodeUtil.isExpressionResultUsed(n)) {\n    error = \"'this' property access unescaped\";\n  } else if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n    if (n.getNext() == null || !n.getNext().isThis()) {\n      error = \"function call missing 'this' argument\";\n    }\n  } else if (propName.equals(\"bind\")) {\n    if (n.getNext() == null || n.getNext().isThis()) {\n      error = \"'this' argument for function bind\";\n    } else {\n      Node secondArg = n.getNext().getNext();\n      if (secondArg == null || !secondArg.isUnusedResult()) {\n        error = \"function bind should return unused value\";\n      }\n    }\n  } else if (propName.equals(\"toString\") ||\n             propName.equals(\"valueOf\")) {\n    error = \"DOM object function call not escaped\";\n  } else {\n    error = \"function call pattern not followed\";\n  }\n\n  if (error != null) {\n    report(t, n, UNSAFE_THIS, error, propName);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex f58418c6..2a38c59f 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1577,6 +1577,39 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n \n       // Functions with explcit 'this' types must be called in a GETPROP\n       // or GETELEM.\n+if (functionType.hasInstanceType() && n.getParent().isGetProp()) {\n+  String propName = n.getParent().getLastChild().getString();\n+  String error = null;\n+\n+  // Do not check unused variables.\n+  if (!compiler.getCompilerOptions().isWarningLevelSuppressed(\n+          CheckLevel.WARNING) &&\n+      !NodeUtil.isExpressionResultUsed(n)) {\n+    error = \"'this' property access unescaped\";\n+  } else if (propName.equals(\"apply\") || propName.equals(\"call\")) {\n+    if (n.getNext() == null || !n.getNext().isThis()) {\n+      error = \"function call missing 'this' argument\";\n+    }\n+  } else if (propName.equals(\"bind\")) {\n+    if (n.getNext() == null || n.getNext().isThis()) {\n+      error = \"'this' argument for function bind\";\n+    } else {\n+      Node secondArg = n.getNext().getNext();\n+      if (secondArg == null || !secondArg.isUnusedResult()) {\n+        error = \"function bind should return unused value\";\n+      }\n+    }\n+  } else if (propName.equals(\"toString\") ||\n+             propName.equals(\"valueOf\")) {\n+    error = \"DOM object function call not escaped\";\n+  } else {\n+    error = \"function call pattern not followed\";\n+  }\n+\n+  if (error != null) {\n+    report(t, n, UNSAFE_THIS, error, propName);\n+  }\n+}\n \n       visitParameterList(t, n, functionType);\n       ensureTyped(t, n, functionType.getReturnType());",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}