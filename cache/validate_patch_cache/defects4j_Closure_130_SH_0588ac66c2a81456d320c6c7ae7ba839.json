{
    "patch": "      if ((name.globalSets == 1 || name.localSets == 1) &&\n          name.localGets == 0 && name.aliasingGets == 0) {\n          // {@code name} meets condition (b).\n          // Move up the global property if:\n          // 1. It's not aliased.\n          // 2. It's not got a child with the same name. This avoids shadowing.\n          // 3. There is no local variable with the same name.\n          //    TODO(johnlenz): In some cases the local should be inlined first.\n          // We also need to check if there is another alias of the global property that\n          // we should not inline. Here are the cases:\n          // 1. The alias is a getprop of an object that we do not know is in the\n          //    same scope.\n          // 2. There is a local variable with the same name as the alias\n          //\n          // Because of the second case we cannot do the usual approach of creating a\n          // new variable. Instead we need to rename any remaining access of the global\n          // property to use the local variable name directly.\n          Node refNode = Iterables.getOnlyElement(name.getRefs()).getNode();\n          Node parent = refNode.getParent();\n          if (parent != null) {\n            switch (parent.getToken()) {\n              case ASSIGN:\n              case VAR:\n              case LET:\n              case CONST:\n              case OBJECTLIT:\n              case CLASS:\n              case FUNCTION:\n                // OK to move it up.\n                break;\n              default:\n                continue;\n            }\n          }\n          List<Name> siblings = ImmutableList.of();\n          if (name.getParent() != null) {\n            siblings = name.getParent().props;\n          }\n          boolean shadowed = false;\n          for (Name sibling : siblings) {\n            if (sibling == name) {\n              continue;\n            }\n            if (sibling.getLocalSets() > 0 || sibling.getAliasingGets() > 0 ||\n                sibling.getLocalGets() > 0) {\n              shadowed = true;\n              break;\n            }\n          }\n          if (shadowed) {\n            continue;\n          }\n          boolean canRemoveVar = true;\n          if (name.getDeclaration() != null) {\n            canRemoveVar =\n                NodeUtil.canRemoveNameNode(name.getDeclaration(), /*keepFunctionName=*/true);\n          }\n          if (canRemoveVar) {\n            if (inlineGlobalAliasedPropertyIfPossible(name, namespace)) {\n              workList.addAll(siblings);\n            }\n          }\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..3beaba13 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,69 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+      if ((name.globalSets == 1 || name.localSets == 1) &&\n+          name.localGets == 0 && name.aliasingGets == 0) {\n+          // {@code name} meets condition (b).\n+          // Move up the global property if:\n+          // 1. It's not aliased.\n+          // 2. It's not got a child with the same name. This avoids shadowing.\n+          // 3. There is no local variable with the same name.\n+          //    TODO(johnlenz): In some cases the local should be inlined first.\n+          // We also need to check if there is another alias of the global property that\n+          // we should not inline. Here are the cases:\n+          // 1. The alias is a getprop of an object that we do not know is in the\n+          //    same scope.\n+          // 2. There is a local variable with the same name as the alias\n+          //\n+          // Because of the second case we cannot do the usual approach of creating a\n+          // new variable. Instead we need to rename any remaining access of the global\n+          // property to use the local variable name directly.\n+          Node refNode = Iterables.getOnlyElement(name.getRefs()).getNode();\n+          Node parent = refNode.getParent();\n+          if (parent != null) {\n+            switch (parent.getToken()) {\n+              case ASSIGN:\n+              case VAR:\n+              case LET:\n+              case CONST:\n+              case OBJECTLIT:\n+              case CLASS:\n+              case FUNCTION:\n+                // OK to move it up.\n+                break;\n+              default:\n+                continue;\n+            }\n+          }\n+          List<Name> siblings = ImmutableList.of();\n+          if (name.getParent() != null) {\n+            siblings = name.getParent().props;\n+          }\n+          boolean shadowed = false;\n+          for (Name sibling : siblings) {\n+            if (sibling == name) {\n+              continue;\n+            }\n+            if (sibling.getLocalSets() > 0 || sibling.getAliasingGets() > 0 ||\n+                sibling.getLocalGets() > 0) {\n+              shadowed = true;\n+              break;\n+            }\n+          }\n+          if (shadowed) {\n+            continue;\n+          }\n+          boolean canRemoveVar = true;\n+          if (name.getDeclaration() != null) {\n+            canRemoveVar =\n+                NodeUtil.canRemoveNameNode(name.getDeclaration(), /*keepFunctionName=*/true);\n+          }\n+          if (canRemoveVar) {\n+            if (inlineGlobalAliasedPropertyIfPossible(name, namespace)) {\n+              workList.addAll(siblings);\n+            }\n+          }\n+        }\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: not a statement",
    "test_result": "ERROR"
}