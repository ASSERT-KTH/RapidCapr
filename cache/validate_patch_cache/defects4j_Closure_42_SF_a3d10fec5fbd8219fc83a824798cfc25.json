{
    "patch": "import com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Token;\nimport com.google.javascript.rhino.ast.*;\n\nclass IRFactory {\n    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n            ImmutableSet.of(\"use strict\");\n\n    private final ErrorReporter errorReporter;\n    private final String sourceName;\n\n    IRFactory(ErrorReporter errorReporter, String sourceName) {\n        this.errorReporter = errorReporter;\n        this.sourceName = sourceName;\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) return false;\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n                n.getFirstChild().isString() &&\n                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    Node newNode(int type, Node... children) {\n        Node n = new Node(type);\n        for (Node c : children) {\n            if (c != null) {\n                n.addChildToBack(c);\n            }\n        }\n        return n;\n    }\n\n    Node transform(AstNode node) {\n        return NodeUtil.getEnclosingStatement(node) == null ? // isExpr\n                newNode(Token.EXPR_RESULT, doTransform(node)) :\n                doTransform(node);\n    }\n\n    Node transformBlock(AstNode blockNode) {\n        return transform(blockNode);\n    }\n\n    Node processGeneric(Node n) {\n        Node nn = doTransform(n);\n        if (nn == null) {\n            return null;\n        }\n        int nnType = nn.getType();\n\n        // Filter out any directives that are not \"use strict\".\n        if (isDirective(nn) && nnType != Token.EXPR_RESULT) {\n            return null;\n        }\n\n        switch (nnType) {\n            case Token.USE_STRICT:\n            case Token.EXPR_RESULT:\n            case Token.FUNCTION:\n            case Token.CLASS:\n                return nn;\n            case Token.BLOCK:\n                return nn.hasChildren() && nn.getFirstChild() == nn.getLastChild()\n                        ? nn.removeFirstChild()\n                        : nn;\n            default:\n                return newNode(Token.EXPR_RESULT, nn);\n        }\n    }\n\n    private Node doTransform(AstNode node) {\n        if (node == null) {\n            return null;\n        }\n        return node.accept(new TransformDispatcher());\n    }\n\n    class TransformDispatcher implements NodeVisitor<Node> {\n\n        @Override\n        public Node visit(AstNode node) {\n            return null;\n        }\n\n        @Override\n        public Node visitArrayComprehension(ArrayComprehension node) {\n            throw new RuntimeException(\"Array comprehensions are not supported\");\n        }\n\n        @Override\n        public Node visitArrayComprehensionLoop(ArrayComprehensionLoop node) {\n            throw new RuntimeException(\"Array comprehensions are not supported\");\n        }\n\n        @Override\n        public Node visitArrayComprehensionIf(ArrayComprehensionIf node) {\n            throw new RuntimeException(\"Array comprehensions are not supported\");\n        }\n\n        @Override\n        public Node visitBlock(Block blockNode) {\n            return processGeneric(blockNode);\n        }\n\n        @Override\n        public Node visitBreak(BreakStatement statementNode) {\n            Node node = newNode(Token.BREAK);\n            if (statementNode.getBreakLabel() != null) {\n                Node labelName = transform(statementNode.getBreakLabel());\n                // Change the NAME to LABEL_NAME\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        public Node visitCatch(CatchClause clauseNode) {\n            AstNode catchVar = clauseNode.getVarName();\n            Node node = newNode(Token.CATCH, transform(catchVar));\n            if (clauseNode.getCatchCondition() != null) {\n                errorReporter.error(\n                    \"Catch clauses are not supported\",\n                    sourceName,\n                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n            }\n            node.addChildToBack(transformBlock(clauseNode.getBody()));\n            return node;\n        }\n\n        @Override\n        public Node visitConditionalExpression(ConditionalExpression exprNode) {\n            return newNode(\n                    Token.HOOK,\n                    transform(exprNode.getTestExpression()),\n                    transform(exprNode.getTrueExpression()),\n                    transform(exprNode.getFalseExpression()));\n        }\n\n        @Override\n        public Node visitContinue(ContinueStatement statementNode) {\n            Node node = newNode(Token.CONTINUE);\n            if (statementNode.getLabel() != null) {\n                Node labelName = transform(statementNode.getLabel());\n                // Change the NAME to LABEL_NAME\n                labelName.setType(Token.LABEL_NAME);\n                node.addChildToBack(labelName);\n            }\n            return node;\n        }\n\n        @Override\n        public Node visitDoLoop(DoLoop loopNode) {\n            return newNode(\n                    Token.DO,\n                    transformBlock(loopNode.getBody()),\n                    transform(loopNode.getCondition()));\n        }\n\n        @Override\n        public Node visitForInLoop(ForInLoop loopNode) {\n            Node varNode = null;\n            AstNode iterVar = loopNode.getIterator();\n            if (iterVar instanceof VariableDeclaration) {\n                varNode = transform(iterVar);\n            } else if (iterVar != null) {\n                varNode = newNode(Token.VAR, transform(iterVar));\n            }\n\n            return newNode(\n                    Token.FOR,\n                    varNode,\n                    transform(loopNode.getIteratedObject()),\n                    transformBlock(loopNode.getBody())\n            );\n        }\n\n        @Override\n        public Node visitFor(ForLoop loopNode) {\n            return newNode(\n                    Token.FOR,\n                    transform(loopNode.getInitializer()),\n                    transform(loopNode.getCondition()),\n                    transform(loopNode.getIncrement()),\n                    transformBlock(loopNode.getBody()));\n        }\n\n        @Override\n        public Node visitFunction(FunctionNode functionNode) {\n            Node node = newNode(Token.FUNCTION);\n            node.addChildToBack(doFunctionTransform(functionNode));\n            return node;\n        }\n\n        Node doFunctionTransform(FunctionNode functionNode) {\n            String name = functionNode.getName();\n            Node nameNode = (name == null) ? null : Node.newString(name);\n            Node fnNode = newNode(Token.FUNCTION, nameNode);\n\n            if (functionNode.getFunctionType().equals(FunctionNode.FUNCTION_EXPRESSION)) {\n                fnNode.putProp(Node.IS_DECLARED_FUNCTION_EXPRESSION, true);\n            }\n            addParametersToFunctionNode(fnNode, functionNode.getParams());\n            Node bodyNode = Node.newBlock();\n            if (functionNode.getBody() != null) {\n                bodyNode = transformBlock(functionNode.getBody());\n            }\n            fnNode.addChildToBack(bodyNode);\n\n            return fnNode;\n        }\n\n        private void addParametersToFunctionNode(\n                Node functionNode, FormalsList parameters) {\n            if (parameters == null || parameters.getLength() == 0) {\n                functionNode.addChildToBack(newNode(Token.EMPTY));\n            } else {\n                Node paramNode = newNode(Token.PARAM_LIST);\n                for (AstNode parameter : parameters) {\n                    paramNode.addChildToBack(transform(parameter));\n                }\n                functionNode.addChildToBack(paramNode);\n            }\n        }\n\n        @Override\n        public Node visitIf(IfStatement statementNode) {\n            return newNode(\n                    Token.IF,\n                    transform(statementNode.getCondition()),\n                    transform(statementNode.getThenPart()),\n                    transform(statementNode.getElsePart()));\n        }\n\n        @Override\n        public Node visitLabeledStatement(LabeledStatement statementNode) {\n            return newNode(\n                    Token.LABEL,\n                    Node.newString(statementNode.getLabelName()),\n                    transform(statementNode.getStatement()));\n        }\n\n        @Override\n        public Node visitLetNode(LetNode letNode) {\n            errorReporter.error(\"let is not supported\", sourceName, letNode.getLineno(), \"\", 0);\n            return null;\n        }\n\n        @Override\n        public Node visitName(Name nameNode) {\n            return newNode(Token.NAME, Node.newString(nameNode.getIdentifier()));\n        }\n\n        @Override\n        public Node visitNewExpr(NewExpression exprNode) {\n            return newNode(Token.NEW, transform(exprNode.getTarget()));\n        }\n\n        @Override\n        public Node visitNumber(NumberLiteral literalNode) {\n            return newNode(Token.NUMBER, Node.newNumber(literalNode.getNumber()));\n        }\n\n        @Override\n        public Node visitObjectLiteral(ObjectLiteral literalNode) {\n            Node objNode = newNode(Token.OBJECTLIT);\n            for (ObjectProperty property : literalNode.getElements()) {\n                if (!property.isGetter() && !property.isSetter()) {\n                    Node propNode = newNode(Token.OBJECTLIT);\n                    if (!property.isQuoted()) {\n                        propNode.addChildToFront(Node.newString(property.getLeft().getIdentifier()));\n                    } else {\n                        propNode.addChildToFront(newNode(Token.STRING, Node.newString(property.getLeft().getString())));\n                    }\n                    propNode.addChildToBack(transform(property.getRight()));\n                    objNode.addChildToBack(propNode);\n                } else {\n                    errorReporter.error(\n                            \"Object getter/setter properties are not supported\",\n                            sourceName,\n                            property.getLineno(), \"\", 0);\n                }\n            }\n            return objNode;\n        }\n\n        @Override\n        public Node visitRegExp(RegExpLiteral literalNode) {\n            return newNode(Token.REGEXP, Node.newString(literalNode.getValue()), Node.newString(literalNode.getFlags()));\n        }\n\n        @Override\n        public Node visitReturn(ReturnStatement statementNode) {\n            Node node = newNode(Token.RETURN);\n            if (statementNode.getReturnValue() != null) {\n                node.addChildToBack(transform(statementNode.getReturnValue()));\n            }\n            return node;\n        }\n\n        @Override\n        public Node visitString(StringLiteral literalNode) {\n            return newNode(Token.STRING, Node.newString(literalNode.getValue()));\n        }\n\n        @Override\n        public Node visitSwitch(SwitchStatement statementNode) {\n            Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n\n            for (SwitchCase switchCase : statementNode.getCases()) {\n                Node caseNode = newNode(Token.CASE, transform(switchCase.getExpression()));\n                for (AstNode stmt : switchCase.getStatements()) {\n                    caseNode.addChildToBack(transform(stmt));\n                }\n                node.addChildToBack(caseNode);\n            }\n\n            return node;\n        }\n\n        @Override\n        public Node visitThrow(ThrowStatement statementNode) {\n            return newNode(Token.THROW, transform(statementNode.getExpression()));\n        }\n\n        @Override\n        public Node visitTry(TryStatement statementNode) {\n            Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n            if (statementNode.getCatchBlock() != null) {\n                node.addChildToBack(\n                        transform(statementNode.getCatchBlock()));\n            }\n            if (statementNode.getFinallyBlock() != null) {\n                node.addChildToBack(\n                        newNode(Token.BLOCK, transformBlock(statementNode.getFinallyBlock())));\n            }\n            return node;\n        }\n\n        @Override\n        public Node visitUnary(UnaryExpression exprNode) {\n            return newNode(Token.NOT, transform(exprNode.getOperand()));\n        }\n\n        @Override\n        public Node visitVariableDeclaration(\n                VariableDeclaration declarationNode) {\n            if (declarationNode.getVariables().size() == 1) {\n                VariableInitializer variable = declarationNode.getVariables().get(0);\n                return newNode(Token.VAR, transform(variable.getTarget()), transform(variable.getInitializer()));\n            } else {\n                Node varNode = newNode(Token.VAR);\n                for (VariableInitializer variable : declarationNode.getVariables()) {\n                    varNode.addChildToBack(newNode(Token.NAME, Node.newString(variable.getTarget().getIdentifier())));\n                    varNode.addChildToBack(transform(variable.getInitializer()));\n                }\n                return varNode;\n            }\n        }\n\n        @Override\n        public Node visitVariableInitializer(VariableInitializer initializerNode) {\n            throw new RuntimeException(\"unexpected\");\n        }\n\n        @Override\n        public Node visitWhileLoop(WhileLoop loopNode) {\n            return newNode(\n                    Token.WHILE,\n                    transform(loopNode.getCondition()),\n                    transformBlock(loopNode.getBody()));\n        }\n\n        @Override\n        public Node visitWith(WithStatement statementNode) {\n            errorReporter.error(\n                    \"'with' is not supported\",\n                    sourceName,\n                    statementNode.getLineno(), \"\", 0);\n            return null;\n        }\n\n        @Override\n        public Node visitXmlLiteral(XmlLiteral literalNode) {\n            errorReporter.error(\n                    \"XML literals are not supported\",\n                    sourceName,\n                    literalNode.getLineno(), \"\", 0);\n            return null;\n        }\n\n        @Override\n        public Node visitFunctionCall(FunctionCall callNode) {\n            Node targetNode = transform(callNode.getTarget());\n            if (targetNode.getType() == Token.GETPROP\n                    && targetNode.getFirstChild().getType() == Token.NAME) {\n                String targetName = targetNode.getFirstChild().getString();\n                if (targetNode.getLastChild().getString().equals(\"apply\")\n                        && callNode.getArguments().size() == 2\n                        && targetName.equals(\"Function\")) {\n                    Node selfNode = newNode(Token.THIS);\n                    Node argsListNode = newNode(Token.ARRAYLIT);\n                    for (AstNode arg : ((ArrayLiteral) callNode.getArguments().get(1)).getElements()) {\n                        argsListNode.addChildToBack(transform(arg));\n                    }\n                    return newNode(Token.NEW, transform(callNode.getArguments().get(0)), selfNode, argsListNode);\n                } else if (targetNode.getLastChild().getString().equals(\"bind\")\n                        && callNode.getArguments().size() == 1\n                        && targetNode.getLastChild().getNext() == null) {\n                    Node selfNode = newNode(Token.THIS);\n                    Node argsListNode = newNode(Token.ARRAYLIT);\n                    return newNode(\n                            Token.NEW,\n                            newNode(Token.GETPROP, newNode(Token.NAME, Node.newString(targetName)), Node.newString(\"apply\")),\n                            selfNode,\n                            newNode(Token.ARRAYLIT, transform(callNode.getArguments().get(0)), argsListNode));\n                }\n            }\n            Node call = newNode(Token.CALL, targetNode);\n            for (AstNode arg : callNode.getArguments()) {\n                call.addChildToBack(transform(arg));\n            }\n            return call;\n        }\n\n        @Override\n        public Node visitExpressionStatement(ExpressionStatement statementNode) {\n            Node node = newNode(transformTokenType(statementNode.getType()));\n            node.addChildToBack(transform(statementNode.getExpression()));\n            return node;\n        }\n\n        @Override\n        public Node visitIfStatement(IfStatement statementNode) {\n            throw new RuntimeException(\"unexpected\");\n        }\n\n        @Override\n        public Node visitSwitchCase(SwitchCase caseNode) {\n            throw new RuntimeException(\"unexpected\");\n        }\n\n        @Override\n        public Node visitVariableDeclaration(VariableDeclaration declNode) {\n            throw new RuntimeException(\"unexpected\");\n        }\n\n        private int transformTokenType(int type) {\n            switch (type) {\n                case Token.VAR:\n                    return Token.VAR;\n                case Token.LET:\n                    errorReporter.error(\n                            \"let is not supported\",\n                            sourceName,\n                            1, \"\", 0);\n                    return Token.VAR;\n                case Token.CONST:\n                    errorReporter.error(\n                            \"const is not supported\",\n                            sourceName,\n                            1, \"\",",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..3bc100e5 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,470 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Token;\n+import com.google.javascript.rhino.ast.*;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+class IRFactory {\n+    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+            ImmutableSet.of(\"use strict\");\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+    private final ErrorReporter errorReporter;\n+    private final String sourceName;\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    IRFactory(ErrorReporter errorReporter, String sourceName) {\n+        this.errorReporter = errorReporter;\n+        this.sourceName = sourceName;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n+    private boolean isDirective(Node n) {\n+        if (n == null) return false;\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+                n.getFirstChild().isString() &&\n+                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    Node newNode(int type, Node... children) {\n+        Node n = new Node(type);\n+        for (Node c : children) {\n+            if (c != null) {\n+                n.addChildToBack(c);\n+            }\n+        }\n+        return n;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    Node transform(AstNode node) {\n+        return NodeUtil.getEnclosingStatement(node) == null ? // isExpr\n+                newNode(Token.EXPR_RESULT, doTransform(node)) :\n+                doTransform(node);\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    Node transformBlock(AstNode blockNode) {\n+        return transform(blockNode);\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    Node processGeneric(Node n) {\n+        Node nn = doTransform(n);\n+        if (nn == null) {\n+            return null;\n+        }\n+        int nnType = nn.getType();\n+\n+        // Filter out any directives that are not \"use strict\".\n+        if (isDirective(nn) && nnType != Token.EXPR_RESULT) {\n+            return null;\n+        }\n+\n+        switch (nnType) {\n+            case Token.USE_STRICT:\n+            case Token.EXPR_RESULT:\n+            case Token.FUNCTION:\n+            case Token.CLASS:\n+                return nn;\n+            case Token.BLOCK:\n+                return nn.hasChildren() && nn.getFirstChild() == nn.getLastChild()\n+                        ? nn.removeFirstChild()\n+                        : nn;\n+            default:\n+                return newNode(Token.EXPR_RESULT, nn);\n+        }\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    private Node doTransform(AstNode node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        return node.accept(new TransformDispatcher());\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    class TransformDispatcher implements NodeVisitor<Node> {\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+        @Override\n+        public Node visit(AstNode node) {\n+            return null;\n+        }\n+\n+        @Override\n+        public Node visitArrayComprehension(ArrayComprehension node) {\n+            throw new RuntimeException(\"Array comprehensions are not supported\");\n+        }\n+\n+        @Override\n+        public Node visitArrayComprehensionLoop(ArrayComprehensionLoop node) {\n+            throw new RuntimeException(\"Array comprehensions are not supported\");\n+        }\n+\n+        @Override\n+        public Node visitArrayComprehensionIf(ArrayComprehensionIf node) {\n+            throw new RuntimeException(\"Array comprehensions are not supported\");\n+        }\n+\n+        @Override\n+        public Node visitBlock(Block blockNode) {\n+            return processGeneric(blockNode);\n+        }\n+\n+        @Override\n+        public Node visitBreak(BreakStatement statementNode) {\n+            Node node = newNode(Token.BREAK);\n+            if (statementNode.getBreakLabel() != null) {\n+                Node labelName = transform(statementNode.getBreakLabel());\n+                // Change the NAME to LABEL_NAME\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node visitCatch(CatchClause clauseNode) {\n+            AstNode catchVar = clauseNode.getVarName();\n+            Node node = newNode(Token.CATCH, transform(catchVar));\n+            if (clauseNode.getCatchCondition() != null) {\n+                errorReporter.error(\n+                    \"Catch clauses are not supported\",\n+                    sourceName,\n+                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+            }\n+            node.addChildToBack(transformBlock(clauseNode.getBody()));\n+            return node;\n+        }\n+\n+        @Override\n+        public Node visitConditionalExpression(ConditionalExpression exprNode) {\n+            return newNode(\n+                    Token.HOOK,\n+                    transform(exprNode.getTestExpression()),\n+                    transform(exprNode.getTrueExpression()),\n+                    transform(exprNode.getFalseExpression()));\n+        }\n+\n+        @Override\n+        public Node visitContinue(ContinueStatement statementNode) {\n+            Node node = newNode(Token.CONTINUE);\n+            if (statementNode.getLabel() != null) {\n+                Node labelName = transform(statementNode.getLabel());\n+                // Change the NAME to LABEL_NAME\n+                labelName.setType(Token.LABEL_NAME);\n+                node.addChildToBack(labelName);\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node visitDoLoop(DoLoop loopNode) {\n+            return newNode(\n+                    Token.DO,\n+                    transformBlock(loopNode.getBody()),\n+                    transform(loopNode.getCondition()));\n+        }\n+\n+        @Override\n+        public Node visitForInLoop(ForInLoop loopNode) {\n+            Node varNode = null;\n+            AstNode iterVar = loopNode.getIterator();\n+            if (iterVar instanceof VariableDeclaration) {\n+                varNode = transform(iterVar);\n+            } else if (iterVar != null) {\n+                varNode = newNode(Token.VAR, transform(iterVar));\n+            }\n+\n+            return newNode(\n+                    Token.FOR,\n+                    varNode,\n+                    transform(loopNode.getIteratedObject()),\n+                    transformBlock(loopNode.getBody())\n+            );\n+        }\n+\n+        @Override\n+        public Node visitFor(ForLoop loopNode) {\n+            return newNode(\n+                    Token.FOR,\n+                    transform(loopNode.getInitializer()),\n+                    transform(loopNode.getCondition()),\n+                    transform(loopNode.getIncrement()),\n+                    transformBlock(loopNode.getBody()));\n+        }\n+\n+        @Override\n+        public Node visitFunction(FunctionNode functionNode) {\n+            Node node = newNode(Token.FUNCTION);\n+            node.addChildToBack(doFunctionTransform(functionNode));\n+            return node;\n+        }\n+\n+        Node doFunctionTransform(FunctionNode functionNode) {\n+            String name = functionNode.getName();\n+            Node nameNode = (name == null) ? null : Node.newString(name);\n+            Node fnNode = newNode(Token.FUNCTION, nameNode);\n+\n+            if (functionNode.getFunctionType().equals(FunctionNode.FUNCTION_EXPRESSION)) {\n+                fnNode.putProp(Node.IS_DECLARED_FUNCTION_EXPRESSION, true);\n+            }\n+            addParametersToFunctionNode(fnNode, functionNode.getParams());\n+            Node bodyNode = Node.newBlock();\n+            if (functionNode.getBody() != null) {\n+                bodyNode = transformBlock(functionNode.getBody());\n+            }\n+            fnNode.addChildToBack(bodyNode);\n+\n+            return fnNode;\n+        }\n+\n+        private void addParametersToFunctionNode(\n+                Node functionNode, FormalsList parameters) {\n+            if (parameters == null || parameters.getLength() == 0) {\n+                functionNode.addChildToBack(newNode(Token.EMPTY));\n+            } else {\n+                Node paramNode = newNode(Token.PARAM_LIST);\n+                for (AstNode parameter : parameters) {\n+                    paramNode.addChildToBack(transform(parameter));\n+                }\n+                functionNode.addChildToBack(paramNode);\n+            }\n+        }\n+\n+        @Override\n+        public Node visitIf(IfStatement statementNode) {\n+            return newNode(\n+                    Token.IF,\n+                    transform(statementNode.getCondition()),\n+                    transform(statementNode.getThenPart()),\n+                    transform(statementNode.getElsePart()));\n+        }\n+\n+        @Override\n+        public Node visitLabeledStatement(LabeledStatement statementNode) {\n+            return newNode(\n+                    Token.LABEL,\n+                    Node.newString(statementNode.getLabelName()),\n+                    transform(statementNode.getStatement()));\n+        }\n+\n+        @Override\n+        public Node visitLetNode(LetNode letNode) {\n+            errorReporter.error(\"let is not supported\", sourceName, letNode.getLineno(), \"\", 0);\n+            return null;\n+        }\n+\n+        @Override\n+        public Node visitName(Name nameNode) {\n+            return newNode(Token.NAME, Node.newString(nameNode.getIdentifier()));\n+        }\n+\n+        @Override\n+        public Node visitNewExpr(NewExpression exprNode) {\n+            return newNode(Token.NEW, transform(exprNode.getTarget()));\n+        }\n+\n+        @Override\n+        public Node visitNumber(NumberLiteral literalNode) {\n+            return newNode(Token.NUMBER, Node.newNumber(literalNode.getNumber()));\n+        }\n+\n+        @Override\n+        public Node visitObjectLiteral(ObjectLiteral literalNode) {\n+            Node objNode = newNode(Token.OBJECTLIT);\n+            for (ObjectProperty property : literalNode.getElements()) {\n+                if (!property.isGetter() && !property.isSetter()) {\n+                    Node propNode = newNode(Token.OBJECTLIT);\n+                    if (!property.isQuoted()) {\n+                        propNode.addChildToFront(Node.newString(property.getLeft().getIdentifier()));\n+                    } else {\n+                        propNode.addChildToFront(newNode(Token.STRING, Node.newString(property.getLeft().getString())));\n+                    }\n+                    propNode.addChildToBack(transform(property.getRight()));\n+                    objNode.addChildToBack(propNode);\n+                } else {\n+                    errorReporter.error(\n+                            \"Object getter/setter properties are not supported\",\n+                            sourceName,\n+                            property.getLineno(), \"\", 0);\n+                }\n+            }\n+            return objNode;\n+        }\n+\n+        @Override\n+        public Node visitRegExp(RegExpLiteral literalNode) {\n+            return newNode(Token.REGEXP, Node.newString(literalNode.getValue()), Node.newString(literalNode.getFlags()));\n+        }\n+\n+        @Override\n+        public Node visitReturn(ReturnStatement statementNode) {\n+            Node node = newNode(Token.RETURN);\n+            if (statementNode.getReturnValue() != null) {\n+                node.addChildToBack(transform(statementNode.getReturnValue()));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node visitString(StringLiteral literalNode) {\n+            return newNode(Token.STRING, Node.newString(literalNode.getValue()));\n+        }\n+\n+        @Override\n+        public Node visitSwitch(SwitchStatement statementNode) {\n+            Node node = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+\n+            for (SwitchCase switchCase : statementNode.getCases()) {\n+                Node caseNode = newNode(Token.CASE, transform(switchCase.getExpression()));\n+                for (AstNode stmt : switchCase.getStatements()) {\n+                    caseNode.addChildToBack(transform(stmt));\n+                }\n+                node.addChildToBack(caseNode);\n+            }\n+\n+            return node;\n+        }\n+\n+        @Override\n+        public Node visitThrow(ThrowStatement statementNode) {\n+            return newNode(Token.THROW, transform(statementNode.getExpression()));\n+        }\n+\n+        @Override\n+        public Node visitTry(TryStatement statementNode) {\n+            Node node = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+            if (statementNode.getCatchBlock() != null) {\n+                node.addChildToBack(\n+                        transform(statementNode.getCatchBlock()));\n+            }\n+            if (statementNode.getFinallyBlock() != null) {\n+                node.addChildToBack(\n+                        newNode(Token.BLOCK, transformBlock(statementNode.getFinallyBlock())));\n+            }\n+            return node;\n+        }\n+\n+        @Override\n+        public Node visitUnary(UnaryExpression exprNode) {\n+            return newNode(Token.NOT, transform(exprNode.getOperand()));\n+        }\n+\n+        @Override\n+        public Node visitVariableDeclaration(\n+                VariableDeclaration declarationNode) {\n+            if (declarationNode.getVariables().size() == 1) {\n+                VariableInitializer variable = declarationNode.getVariables().get(0);\n+                return newNode(Token.VAR, transform(variable.getTarget()), transform(variable.getInitializer()));\n+            } else {\n+                Node varNode = newNode(Token.VAR);\n+                for (VariableInitializer variable : declarationNode.getVariables()) {\n+                    varNode.addChildToBack(newNode(Token.NAME, Node.newString(variable.getTarget().getIdentifier())));\n+                    varNode.addChildToBack(transform(variable.getInitializer()));\n+                }\n+                return varNode;\n+            }\n+        }\n+\n+        @Override\n+        public Node visitVariableInitializer(VariableInitializer initializerNode) {\n+            throw new RuntimeException(\"unexpected\");\n+        }\n+\n+        @Override\n+        public Node visitWhileLoop(WhileLoop loopNode) {\n+            return newNode(\n+                    Token.WHILE,\n+                    transform(loopNode.getCondition()),\n+                    transformBlock(loopNode.getBody()));\n+        }\n+\n+        @Override\n+        public Node visitWith(WithStatement statementNode) {\n+            errorReporter.error(\n+                    \"'with' is not supported\",\n+                    sourceName,\n+                    statementNode.getLineno(), \"\", 0);\n+            return null;\n+        }\n+\n+        @Override\n+        public Node visitXmlLiteral(XmlLiteral literalNode) {\n+            errorReporter.error(\n+                    \"XML literals are not supported\",\n+                    sourceName,\n+                    literalNode.getLineno(), \"\", 0);\n+            return null;\n+        }\n+\n+        @Override\n+        public Node visitFunctionCall(FunctionCall callNode) {\n+            Node targetNode = transform(callNode.getTarget());\n+            if (targetNode.getType() == Token.GETPROP\n+                    && targetNode.getFirstChild().getType() == Token.NAME) {\n+                String targetName = targetNode.getFirstChild().getString();\n+                if (targetNode.getLastChild().getString().equals(\"apply\")\n+                        && callNode.getArguments().size() == 2\n+                        && targetName.equals(\"Function\")) {\n+                    Node selfNode = newNode(Token.THIS);\n+                    Node argsListNode = newNode(Token.ARRAYLIT);\n+                    for (AstNode arg : ((ArrayLiteral) callNode.getArguments().get(1)).getElements()) {\n+                        argsListNode.addChildToBack(transform(arg));\n+                    }\n+                    return newNode(Token.NEW, transform(callNode.getArguments().get(0)), selfNode, argsListNode);\n+                } else if (targetNode.getLastChild().getString().equals(\"bind\")\n+                        && callNode.getArguments().size() == 1\n+                        && targetNode.getLastChild().getNext() == null) {\n+                    Node selfNode = newNode(Token.THIS);\n+                    Node argsListNode = newNode(Token.ARRAYLIT);\n+                    return newNode(\n+                            Token.NEW,\n+                            newNode(Token.GETPROP, newNode(Token.NAME, Node.newString(targetName)), Node.newString(\"apply\")),\n+                            selfNode,\n+                            newNode(Token.ARRAYLIT, transform(callNode.getArguments().get(0)), argsListNode));\n+                }\n+            }\n+            Node call = newNode(Token.CALL, targetNode);\n+            for (AstNode arg : callNode.getArguments()) {\n+                call.addChildToBack(transform(arg));\n+            }\n+            return call;\n+        }\n+\n+        @Override\n+        public Node visitExpressionStatement(ExpressionStatement statementNode) {\n+            Node node = newNode(transformTokenType(statementNode.getType()));\n+            node.addChildToBack(transform(statementNode.getExpression()));\n+            return node;\n+        }\n+\n+        @Override\n+        public Node visitIfStatement(IfStatement statementNode) {\n+            throw new RuntimeException(\"unexpected\");\n+        }\n+\n+        @Override\n+        public Node visitSwitchCase(SwitchCase caseNode) {\n+            throw new RuntimeException(\"unexpected\");\n+        }\n+\n+        @Override\n+        public Node visitVariableDeclaration(VariableDeclaration declNode) {\n+            throw new RuntimeException(\"unexpected\");\n+        }\n+\n+        private int transformTokenType(int type) {\n+            switch (type) {\n+                case Token.VAR:\n+                    return Token.VAR;\n+                case Token.LET:\n+                    errorReporter.error(\n+                            \"let is not supported\",\n+                            sourceName,\n+                            1, \"\", 0);\n+                    return Token.VAR;\n+                case Token.CONST:\n+                    errorReporter.error(\n+                            \"const is not supported\",\n+                            sourceName,\n+                            1, \"\",\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}