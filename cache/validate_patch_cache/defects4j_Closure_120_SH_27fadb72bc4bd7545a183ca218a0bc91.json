{
    "patch": "for (BasicBlock block = ref.getBasicBlock();\n           block != null; block = block.getParent()) {\n        if (block.isFunction) {\n          BlockIterator<BasicBlock> forwardIter =\n              block.getForwardBlockIterator();\n          while (forwardIter.hasNext()) {\n            BasicBlock forwardBlock = forwardIter.next();\n            if (forwardBlock == ref.getBasicBlock()) {\n              return true;\n            }\n            if (forwardBlock.findExpressionMatches(\n                new NodeUtil.MatchShallowExpression(ref.getNode()))) {\n              break;\n            }\n          }\n          forwardIter = block.getForwardBlockIterator();\n          while (forwardIter.hasNext()) {\n            BasicBlock forwardBlock = forwardIter.next();\n            if (forwardBlock.isFunction || !forwardBlock.mayHaveSideEffects()) {\n              continue;\n            }\n            if (forwardBlock.getControlFlowGraph().getEntry().isThrow()) {\n              return false;\n            }\n            if (!forwardBlock.findExpressionMatches(\n                new NodeUtil.MatchShallowExpression(ref.getNode()))) {\n              break;\n            }\n            for (DiGraphEdge<Node, Branch> edge :\n                forwardBlock.getControlFlowGraph().getOutEdges(\n                    forwardBlock.getControlFlowGraph().getEntry())) {\n              if (edge.getValue() == Branch.ON_EX) {\n                return false;\n              }\n            }\n          }\n          break;\n        } else if (block.isLoop) {\n          return false;\n        }\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..e72ab494 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,47 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+for (BasicBlock block = ref.getBasicBlock();\n+           block != null; block = block.getParent()) {\n+        if (block.isFunction) {\n+          BlockIterator<BasicBlock> forwardIter =\n+              block.getForwardBlockIterator();\n+          while (forwardIter.hasNext()) {\n+            BasicBlock forwardBlock = forwardIter.next();\n+            if (forwardBlock == ref.getBasicBlock()) {\n+              return true;\n+            }\n+            if (forwardBlock.findExpressionMatches(\n+                new NodeUtil.MatchShallowExpression(ref.getNode()))) {\n+              break;\n+            }\n+          }\n+          forwardIter = block.getForwardBlockIterator();\n+          while (forwardIter.hasNext()) {\n+            BasicBlock forwardBlock = forwardIter.next();\n+            if (forwardBlock.isFunction || !forwardBlock.mayHaveSideEffects()) {\n+              continue;\n+            }\n+            if (forwardBlock.getControlFlowGraph().getEntry().isThrow()) {\n+              return false;\n+            }\n+            if (!forwardBlock.findExpressionMatches(\n+                new NodeUtil.MatchShallowExpression(ref.getNode()))) {\n+              break;\n+            }\n+            for (DiGraphEdge<Node, Branch> edge :\n+                forwardBlock.getControlFlowGraph().getOutEdges(\n+                    forwardBlock.getControlFlowGraph().getEntry())) {\n+              if (edge.getValue() == Branch.ON_EX) {\n+                return false;\n+              }\n+            }\n+          }\n+          break;\n+        } else if (block.isLoop) {\n+          return false;\n+        }\n+      }\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: variable block is already defined in method isAssignedOnceInLifetime()",
    "test_result": "ERROR"
}