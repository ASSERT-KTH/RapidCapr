{
    "patch": "      attachLiteralTypes(n);\n      switch (n.getType()) {\n        case Token.FUNCTION:\n          if (parent.getType() == Token.NAME) {\n            return;\n          }\n          defineDeclaredFunction(n, parent);\n          break;\n        case Token.CATCH:\n          defineCatch(n, parent);\n          break;\n        case Token.VAR:\n          defineVar(n, parent);\n          break;\n        case Token.LP:\n          if (parent == scope.getRootNode()) {\n            handleFunctionInputs(parent);\n          }\n          break;\n        default:\n          break;\n      }\n    }\n    \n    private void defineVar(Node node, Node parent) {\n      Node child = node.getFirstChild();\n      while (child != null) {\n        JSTypeExpression typeExpr = NodeUtil.getDeclaredTypeExpression(child);\n\n        if (child.getBooleanProp(Node.IS_NAMESPACE)) {\n          if (parent.getType() == Token.EXPR_RESULT) {\n            JSDocInfoBuilder doc = new JSDocInfoBuilder(false);\n            doc.recordConstancy();\n            JSTypeRegistry registry = compiler.getTypeRegistry();\n            JSType type = registry.createNamedType(registry.getGlobalType(\"Object\"));\n            Node assign =\n                IR.assign(\n                    IR.getprop(IR.name(child.getString()),\n                        IR.string(NodeUtil.JSC_PROPERTY_NAME_FN_OBJ)),\n                    IR.objectlit());\n            assign.setJSType(type);\n            Node expr = IR.exprResult(assign);\n            expr.setJSDocInfo(doc.build());\n            parent.replaceChild(node, expr);\n            compiler.reportCodeChange();\n\n            // Add new property to the namespace object\n            Node onload =\n                IR.assign(\n                    IR.getprop(IR.name(child.getString()), IR.string(\"onload\")),\n                    IR.trueNode());\n            Node objectLit = IR.objectlit(onload);\n            objectLit.setJSType(type);\n            Node newProp = IR.exprResult(objectLit);\n            parent.addChildBefore(newProp, node.getNext());\n            compiler.reportCodeChange();\n          }\n        } else if (!child.hasMoreThanOneChild()) {\n          String varName = child.getString();\n          if (vars.containsKey(varName)) {\n            compiler.report(\n                JSError.make(\n                    node, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, varName));\n          } else {\n            JSType varType = null;\n            if (typeExpr != null) {\n              varType =\n                  new JSTypeExpression(typeExpr.getRoot(), scope).evaluate(\n                      compiler.getTypeRegistry());\n            }\n            vars.put(varName, varType);\n            NodeUtil.markFunctionsDeleted(child, compiler);\n            JSParseTreeVisitor<JSType> typeUpdater =\n                new TypeUpdatingSimpleDefinitionFinder(child, this);\n            typeUpdater.visitPreorder(child);\n          }\n        } else if (typeExpr != null || parent.getType() == Token.FOR_IN) {\n          handleObjectDestructuring(child, parent);\n        } else {\n          Node rhs = child.getLastChild();\n          if (parent.getType() == Token.FOR_OF) {\n            JSType varType =\n                new TypeMatchingContext(parent.getParent(), compiler).inferType(rhs);\n            vars.put(child.getString(), varType);\n          }\n        }\n        child = child.getNext();\n      }\n    }    ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..9d9da7e8 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1462,7 +1462,81 @@ final class TypedScopeCreator implements ScopeCreator {\n         case Token.VAR:\n           defineVar(n, parent);\n           break;\n+        case Token.LP:\n+          if (parent == scope.getRootNode()) {\n+            handleFunctionInputs(parent);\n+          }\n+          break;\n+        default:\n+          break;\n+      }\n+    }\n+    \n+    private void defineVar(Node node, Node parent) {\n+      Node child = node.getFirstChild();\n+      while (child != null) {\n+        JSTypeExpression typeExpr = NodeUtil.getDeclaredTypeExpression(child);\n+\n+        if (child.getBooleanProp(Node.IS_NAMESPACE)) {\n+          if (parent.getType() == Token.EXPR_RESULT) {\n+            JSDocInfoBuilder doc = new JSDocInfoBuilder(false);\n+            doc.recordConstancy();\n+            JSTypeRegistry registry = compiler.getTypeRegistry();\n+            JSType type = registry.createNamedType(registry.getGlobalType(\"Object\"));\n+            Node assign =\n+                IR.assign(\n+                    IR.getprop(IR.name(child.getString()),\n+                        IR.string(NodeUtil.JSC_PROPERTY_NAME_FN_OBJ)),\n+                    IR.objectlit());\n+            assign.setJSType(type);\n+            Node expr = IR.exprResult(assign);\n+            expr.setJSDocInfo(doc.build());\n+            parent.replaceChild(node, expr);\n+            compiler.reportCodeChange();\n+\n+            // Add new property to the namespace object\n+            Node onload =\n+                IR.assign(\n+                    IR.getprop(IR.name(child.getString()), IR.string(\"onload\")),\n+                    IR.trueNode());\n+            Node objectLit = IR.objectlit(onload);\n+            objectLit.setJSType(type);\n+            Node newProp = IR.exprResult(objectLit);\n+            parent.addChildBefore(newProp, node.getNext());\n+            compiler.reportCodeChange();\n+          }\n+        } else if (!child.hasMoreThanOneChild()) {\n+          String varName = child.getString();\n+          if (vars.containsKey(varName)) {\n+            compiler.report(\n+                JSError.make(\n+                    node, VarCheck.VAR_MULTIPLY_DECLARED_ERROR, varName));\n+          } else {\n+            JSType varType = null;\n+            if (typeExpr != null) {\n+              varType =\n+                  new JSTypeExpression(typeExpr.getRoot(), scope).evaluate(\n+                      compiler.getTypeRegistry());\n+            }\n+            vars.put(varName, varType);\n+            NodeUtil.markFunctionsDeleted(child, compiler);\n+            JSParseTreeVisitor<JSType> typeUpdater =\n+                new TypeUpdatingSimpleDefinitionFinder(child, this);\n+            typeUpdater.visitPreorder(child);\n+          }\n+        } else if (typeExpr != null || parent.getType() == Token.FOR_IN) {\n+          handleObjectDestructuring(child, parent);\n+        } else {\n+          Node rhs = child.getLastChild();\n+          if (parent.getType() == Token.FOR_OF) {\n+            JSType varType =\n+                new TypeMatchingContext(parent.getParent(), compiler).inferType(rhs);\n+            vars.put(child.getString(), varType);\n+          }\n+        }\n+        child = child.getNext();\n       }\n+    }    \n     }\n \n     /** Handle bleeding functions and function parameters. */",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}