{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    if (offsetLocal > offsetAdjusted) {\n        // Moving to the west, i.e. earlier UTC, may cause the local time to be skipped\n        // Check if there is a gap in the local time after the transition\n        long nextTransitionLocal = nextTransition(instantLocal - offsetAdjusted);\n        long nextTransitionAdjusted = nextTransition(instantAdjusted);\n        if (nextTransitionLocal != nextTransitionAdjusted) {\n            long prevTransitionLocal = previousTransition(instantLocal - offsetAdjusted);\n            if (instantLocal - prevTransitionLocal <= DateTimeConstants.MILLIS_PER_HOUR) {\n                // There is a gap, but it is smaller than an hour, so the offset may be correct\n                return offsetAdjusted;\n            } else {\n                // The local time is skipped, but the offset is not increased enough, so the\n                // correct offset is the one before the transition\n                return offsetLocal;\n            }\n        } else {\n            // The local time is not skipped, so the offset is correct\n            return offsetAdjusted;\n        }\n    } else {\n        // Moving to the east, i.e. later UTC, may cause the local time to be repeated\n        // Check if there is an overlap in the local time before the transition\n        long prevTransitionLocal = previousTransition(instantLocal - offsetAdjusted);\n        long prevTransitionAdjusted = previousTransition(instantAdjusted);\n        if (prevTransitionLocal != prevTransitionAdjusted) {\n            long nextTransitionLocal = nextTransition(instantLocal - offsetAdjusted);\n            if (nextTransitionLocal - instantLocal <= DateTimeConstants.MILLIS_PER_HOUR) {\n                // There is an overlap, but it is smaller than an hour, so the offset may be correct\n                return offsetAdjusted;\n            } else {\n                // The local time is repeated, but the offset is not decreased enough, so the\n                // correct offset is the one before the transition\n                return offsetLocal;\n            }\n        } else {\n            // The local time is not repeated, so the offset is correct\n            return offsetAdjusted;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..81c18f7d 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,47 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    if (offsetLocal > offsetAdjusted) {\n+        // Moving to the west, i.e. earlier UTC, may cause the local time to be skipped\n+        // Check if there is a gap in the local time after the transition\n+        long nextTransitionLocal = nextTransition(instantLocal - offsetAdjusted);\n+        long nextTransitionAdjusted = nextTransition(instantAdjusted);\n+        if (nextTransitionLocal != nextTransitionAdjusted) {\n+            long prevTransitionLocal = previousTransition(instantLocal - offsetAdjusted);\n+            if (instantLocal - prevTransitionLocal <= DateTimeConstants.MILLIS_PER_HOUR) {\n+                // There is a gap, but it is smaller than an hour, so the offset may be correct\n+                return offsetAdjusted;\n+            } else {\n+                // The local time is skipped, but the offset is not increased enough, so the\n+                // correct offset is the one before the transition\n+                return offsetLocal;\n+            }\n+        } else {\n+            // The local time is not skipped, so the offset is correct\n+            return offsetAdjusted;\n+        }\n+    } else {\n+        // Moving to the east, i.e. later UTC, may cause the local time to be repeated\n+        // Check if there is an overlap in the local time before the transition\n+        long prevTransitionLocal = previousTransition(instantLocal - offsetAdjusted);\n+        long prevTransitionAdjusted = previousTransition(instantAdjusted);\n+        if (prevTransitionLocal != prevTransitionAdjusted) {\n+            long nextTransitionLocal = nextTransition(instantLocal - offsetAdjusted);\n+            if (nextTransitionLocal - instantLocal <= DateTimeConstants.MILLIS_PER_HOUR) {\n+                // There is an overlap, but it is smaller than an hour, so the offset may be correct\n+                return offsetAdjusted;\n+            } else {\n+                // The local time is repeated, but the offset is not decreased enough, so the\n+                // correct offset is the one before the transition\n+                return offsetLocal;\n+            }\n+        } else {\n+            // The local time is not repeated, so the offset is correct\n+            return offsetAdjusted;\n+        }\n+    }\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.ComparisonFailure: 2007-03-25T01:00:00.000+03:00 expected:<2007-03-25T0[3:00:00.000+04]:00> but was:<2007-03-25T0[1:00:00.000+03]:00>",
    "test_result": "FAIL"
}