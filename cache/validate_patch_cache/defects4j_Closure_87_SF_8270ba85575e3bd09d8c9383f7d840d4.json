{
    "patch": "private static boolean isFoldableExpression(Node expr, boolean isExprResult) {\n  if (NodeUtil.isFunctionExpression(expr)) {\n    Node functionBody = expr.getLastChild();\n    // Check if the function has a return statement\n    if (functionBody != null && !functionBody.hasChildren()) {\n      return true;\n    }\n    if (functionBody.getLastChild() != null &&\n        functionBody.getLastChild().getType() == Token.RETURN) {\n      Node returnExpr = functionBody.getLastChild().getFirstChild();\n      if (returnExpr != null) {\n        return isFoldableExpression(returnExpr, true);\n      }\n    }\n  } else if (NodeUtil.isExpressionNode(expr)) {\n    if (expr.getType() == Token.HOOK) {\n      Node trueExpr = expr.getFirstChild().getNext();\n      Node falseExpr = trueExpr.getNext();\n      return isFoldableExpression(trueExpr, false) &&\n          isFoldableExpression(falseExpr, false);\n    } else if (expr.getType() == Token.NOT &&\n        expr.getFirstChild().getType() == Token.NAME) {\n      String name = expr.getFirstChild().getString();\n      return !isExprResult || !name.startsWith(\"event\");\n    } else if (expr.getType() == Token.NAME) {\n      String name = expr.getString();\n      boolean isEventHandler = name.startsWith(\"on\");\n      return !isExprResult || !isEventHandler;\n    } else if (NodeUtil.isLiteralValue(expr, true)) {\n      return true;\n    } else if (expr.getType() == Token.GETPROP) {\n      Node obj = expr.getFirstChild();\n      Node prop = obj.getNext();\n      if (obj.getType() == Token.NAME &&\n          prop.getType() == Token.STRING &&\n          prop.getString().equals(\"returnValue\")) {\n        Node parent = expr.getParent();\n        if (parent.getType() == Token.HOOK &&\n            parent.getFirstChild() == expr &&\n            parent.getParent().getType() == Token.EXPR_RESULT &&\n            parent.getParent().getParent().getType() == Token.BLOCK &&\n            parent.getParent().getParent().hasOneChild()) {\n          Node condition = parent.getFirstChild().getFirstChild();\n          Node trueExpr = parent.getFirstChild().getNext();\n          Node falseExpr = trueExpr.getNext();\n          return isFoldableExpression(condition, false) &&\n              isFoldableExpression(trueExpr, false) &&\n              isFoldableExpression(falseExpr, false);\n        }\n        if (parent.getType() == Token.ASSIGN &&\n            parent.getParent().getType() == Token.EXPR_RESULT &&\n            parent.getParent().getParent().getType() == Token.BLOCK &&\n            parent.getParent().getParent().hasOneChild()) {\n          Node lhs = parent.getFirstChild();\n          Node rhs = lhs.getNext();\n          if (lhs.getType() == Token.NAME &&\n              rhs == expr.getParent() &&\n              !lhs.getBooleanProp(Node.IS_NAMESPACE)) {\n            Node grandParent = parent.getParent().getParent();\n            if (grandParent.getFirstChild() == parent.getParent()) {\n              Node maybeExprStmt = grandParent.getParent();\n              if (NodeUtil.isStatementBlock(maybeExprStmt.getParent())) {\n                Node outerBlock = maybeExprStmt.getParent();\n                if (outerBlock.getParent() == null) {\n                  return false;  // ScriptNode\n                }\n                ControlFlowGraph<Node> cfg =\n                    NodeUtil.buildCfg(outerBlock, false /* opt_loopUnrolling */);\n                Traversal<Node, ControlFlowGraph.Branch> traversal =\n                    Traversal.depthFirst(cfg, maybeExprStmt);\n                Node lastReached = null;\n                while (traversal.hasNext()) {\n                  ControlFlowGraph.Branch b = traversal.next();\n                  if (b.isBackward()) {\n                    continue;\n                  }\n                  lastReached = b.getControlNode();\n                }\n                Node nextStmt = NodeUtil.findNextStatement(lastReached);\n                if (nextStmt == null) {\n                  // There is no statement after the last one (e.g. the entire function body\n                  // is a sequence of null statements). This can happen in situations like:\n                  // function foo() {\n                  //   1;2;\n                  // }\n                  return true;\n                }\n                Node targetNode = null;\n                if (nextStmt.isBlock() && nextStmt.hasChildren()) {\n                  targetNode = nextStmt.getFirstChild();\n                } else {\n                  targetNode = nextStmt;\n                }\n                // We need to treat the parent of the RETURN node specially, since we don't want\n                // to fold its expression (if it has one) into the parent if the parent is a HOOK\n                // node or a logical operator.\n                while (targetNode.getParent().getChildCount() == 1 &&\n                    targetNode.getParent().getType() != Token.RETURN) {\n                  targetNode = targetNode.getParent();\n                }\n                return isFoldableExpression(targetNode, false);\n              }\n            }\n          }\n        }\n      }\n    } else if (expr.getType() == Token.AND ||\n        expr.getType() == Token.OR ||\n        expr.getType() == Token.EQ ||\n        expr.getType() == Token.NE) {\n      Node left = expr.getFirstChild();\n      Node right = left.getNext();\n      return isFoldableExpression(left, false) &&\n          isFoldableExpression(right, false);\n    }\n  }\n  return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..6a0f9234 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,26 +516,124 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+private static boolean isFoldableExpression(Node expr, boolean isExprResult) {\n+  if (NodeUtil.isFunctionExpression(expr)) {\n+    Node functionBody = expr.getLastChild();\n+    // Check if the function has a return statement\n+    if (functionBody != null && !functionBody.hasChildren()) {\n+      return true;\n+    }\n+    if (functionBody.getLastChild() != null &&\n+        functionBody.getLastChild().getType() == Token.RETURN) {\n+      Node returnExpr = functionBody.getLastChild().getFirstChild();\n+      if (returnExpr != null) {\n+        return isFoldableExpression(returnExpr, true);\n       }\n     }\n-\n-    return false;\n+  } else if (NodeUtil.isExpressionNode(expr)) {\n+    if (expr.getType() == Token.HOOK) {\n+      Node trueExpr = expr.getFirstChild().getNext();\n+      Node falseExpr = trueExpr.getNext();\n+      return isFoldableExpression(trueExpr, false) &&\n+          isFoldableExpression(falseExpr, false);\n+    } else if (expr.getType() == Token.NOT &&\n+        expr.getFirstChild().getType() == Token.NAME) {\n+      String name = expr.getFirstChild().getString();\n+      return !isExprResult || !name.startsWith(\"event\");\n+    } else if (expr.getType() == Token.NAME) {\n+      String name = expr.getString();\n+      boolean isEventHandler = name.startsWith(\"on\");\n+      return !isExprResult || !isEventHandler;\n+    } else if (NodeUtil.isLiteralValue(expr, true)) {\n+      return true;\n+    } else if (expr.getType() == Token.GETPROP) {\n+      Node obj = expr.getFirstChild();\n+      Node prop = obj.getNext();\n+      if (obj.getType() == Token.NAME &&\n+          prop.getType() == Token.STRING &&\n+          prop.getString().equals(\"returnValue\")) {\n+        Node parent = expr.getParent();\n+        if (parent.getType() == Token.HOOK &&\n+            parent.getFirstChild() == expr &&\n+            parent.getParent().getType() == Token.EXPR_RESULT &&\n+            parent.getParent().getParent().getType() == Token.BLOCK &&\n+            parent.getParent().getParent().hasOneChild()) {\n+          Node condition = parent.getFirstChild().getFirstChild();\n+          Node trueExpr = parent.getFirstChild().getNext();\n+          Node falseExpr = trueExpr.getNext();\n+          return isFoldableExpression(condition, false) &&\n+              isFoldableExpression(trueExpr, false) &&\n+              isFoldableExpression(falseExpr, false);\n+        }\n+        if (parent.getType() == Token.ASSIGN &&\n+            parent.getParent().getType() == Token.EXPR_RESULT &&\n+            parent.getParent().getParent().getType() == Token.BLOCK &&\n+            parent.getParent().getParent().hasOneChild()) {\n+          Node lhs = parent.getFirstChild();\n+          Node rhs = lhs.getNext();\n+          if (lhs.getType() == Token.NAME &&\n+              rhs == expr.getParent() &&\n+              !lhs.getBooleanProp(Node.IS_NAMESPACE)) {\n+            Node grandParent = parent.getParent().getParent();\n+            if (grandParent.getFirstChild() == parent.getParent()) {\n+              Node maybeExprStmt = grandParent.getParent();\n+              if (NodeUtil.isStatementBlock(maybeExprStmt.getParent())) {\n+                Node outerBlock = maybeExprStmt.getParent();\n+                if (outerBlock.getParent() == null) {\n+                  return false;  // ScriptNode\n+                }\n+                ControlFlowGraph<Node> cfg =\n+                    NodeUtil.buildCfg(outerBlock, false /* opt_loopUnrolling */);\n+                Traversal<Node, ControlFlowGraph.Branch> traversal =\n+                    Traversal.depthFirst(cfg, maybeExprStmt);\n+                Node lastReached = null;\n+                while (traversal.hasNext()) {\n+                  ControlFlowGraph.Branch b = traversal.next();\n+                  if (b.isBackward()) {\n+                    continue;\n+                  }\n+                  lastReached = b.getControlNode();\n+                }\n+                Node nextStmt = NodeUtil.findNextStatement(lastReached);\n+                if (nextStmt == null) {\n+                  // There is no statement after the last one (e.g. the entire function body\n+                  // is a sequence of null statements). This can happen in situations like:\n+                  // function foo() {\n+                  //   1;2;\n+                  // }\n+                  return true;\n+                }\n+                Node targetNode = null;\n+                if (nextStmt.isBlock() && nextStmt.hasChildren()) {\n+                  targetNode = nextStmt.getFirstChild();\n+                } else {\n+                  targetNode = nextStmt;\n+                }\n+                // We need to treat the parent of the RETURN node specially, since we don't want\n+                // to fold its expression (if it has one) into the parent if the parent is a HOOK\n+                // node or a logical operator.\n+                while (targetNode.getParent().getChildCount() == 1 &&\n+                    targetNode.getParent().getType() != Token.RETURN) {\n+                  targetNode = targetNode.getParent();\n+                }\n+                return isFoldableExpression(targetNode, false);\n+              }\n+            }\n+          }\n+        }\n+      }\n+    } else if (expr.getType() == Token.AND ||\n+        expr.getType() == Token.OR ||\n+        expr.getType() == Token.EQ ||\n+        expr.getType() == Token.NE) {\n+      Node left = expr.getFirstChild();\n+      Node right = left.getNext();\n+      return isFoldableExpression(left, false) &&\n+          isFoldableExpression(right, false);\n+    }\n   }\n+  return false;\n+}\n \n   /**\n    * @return The expression node.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}