{
    "patch": "import com.google.javascript.rhino.Node;\nimport com.google.javascript.rhino.Scope;\nimport com.google.javascript.rhino.jstype.FunctionType;\nimport com.google.javascript.rhino.jstype.Parameter;\nimport com.google.javascript.rhino.jstype.ParameterizedType;\nimport com.google.javascript.rhino.jstype.StaticSourceFile;\nimport com.google.javascript.rhino.jstype.JSType;\n\nimport java.util.HashMap;\nimport java.util.Map;\n\nimport static com.google.common.base.Preconditions.checkState;\n\nprivate void removeUnreferencedFunctionArgs(Scope fnScope, boolean modifyCallSites) {\n  Node function = fnScope.getRootNode();\n  checkState(function.isFunction());\n\n  if (isFunctionWithRestArgs(function)) {\n    return;\n  }\n\n  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n    // The parameters object literal setters can't be removed.\n    return;\n  }\n\n  Node argList = getFunctionArgList(function);\n  boolean canModifyCalls = modifyCallSites && referenceMap.acceptsCalls();\n  Map<String, Integer> referencedVarIndexMap = null;\n\n  if (!canModifyCalls) {\n    // Build a map of referenced vars and their indexes in the arg list.\n    // The function may have multiple references to the same parameter.\n    referencedVarIndexMap = new HashMap<String, Integer>();\n    int idx = 0;\n    for (Var refVar : referenced) {\n      ParamInfo paramInfo = getVarParamInfo(fnScope, refVar);\n      if (paramInfo != null && !paramInfo.isDuplicate) {\n        referencedVarIndexMap.put(refVar.name, idx++);\n      }\n    }\n\n    // Strip unreferenced args off the end of the function declaration.\n    Node lastArg;\n    while ((lastArg = argList.getLastChild()) != null) {\n      int argIndex = argList.getIndexOfChild(lastArg);\n      Var var = fnScope.getVar(lastArg.getString());\n      Integer refVarIndex = referencedVarIndexMap.get(var.name);\n      if (refVarIndex == null) {\n        argList.removeChildAtIndex(argIndex);\n        compiler.reportChangeToEnclosingScope(argList);\n      } else if (refVarIndex.equals(argIndex)) {\n        // Skip args that are duplicates of previously referenced args.\n        referencedVarIndexMap.remove(var.name);\n      } else {\n        // Once we reach an argument referred to by a future referenced var,\n        // we can't remove any more function arguments.\n        break;\n      }\n    }\n  } else {\n    rewriteFunctionCallSites(fnScope);\n  }\n}\n\n/**\n * Returns true if the function has a rest parameter.\n */\nprivate static boolean isFunctionWithRestArgs(Node function) {\n  Node args = getFunctionArgList(function);\n  return args.getLastChild() != null && args.getLastChild().isRest();\n}\n\n/**\n * Given a variable and its enclosing scope, returns a ParamInfo object with\n * information about the variable's corresponding parameter, if any.\n */\nprivate ParamInfo getVarParamInfo(Scope fnScope, Var var) {\n  if (!var.isParam()) {\n    return null;\n  }\n\n  Node function = fnScope.getRootNode();\n  checkState(function.isFunction());\n\n  Node argList = getFunctionArgList(function);\n  int idx = argList.getIndexOfChild(var.nameNode);\n  if (idx == -1) {\n    // Function parameters should appear in the argument list.\n    return null;\n  }\n\n  FunctionType functionType = getFunctionType(function, compiler.getTypeRegistry());\n  if (functionType == null) {\n    // We can't optimize calls to functions whose types we can't determine.\n    return null;\n  }\n\n  ParameterizedType paramType = functionType.getTypeOfThis().toMaybeObjectType()\n      .getParameterizedType();\n  if (paramType == null) {\n    // Functions without a 'this' context can't have parameter type information.\n    return null;\n  }\n\n  Parameter param = paramType.getParameters().get(idx);\n  boolean isDuplicate = false;\n  Node paramNode = argList.getChildAtIndex(idx);\n  // If there are multiple copies of the parameter in the function scope (e.g.\n  // from a catch declaration), we only want to reference the first copy.\n  if (var.getScope().getVar(param.getName()) != var) {\n    isDuplicate = true;\n  }\n\n  return new ParamInfo(param, paramNode, isDuplicate);\n}\n\n/**\n * Returns the type information of a function node using the type registry.\n */\nprivate FunctionType getFunctionType(Node function, TypeRegistry typeRegistry) {\n  JSType type = function.getJSType();\n  if (type == null || !type.isFunctionType()) {\n    return null;\n  }\n\n  StaticSourceFile sourceFile = type.getSourceFile();\n  if (sourceFile == null) {\n    // If it's a function without a closure in the global scope, there is no\n    // associated type information.\n    return null;\n  }\n\n  return typeRegistry.getGlobalType(\n      type.toObjectType(), type.getSourceFile().getName());\n}\n\n/**\n * A structure containing information about a function parameter.\n */\nprivate static class ParamInfo {\n  final Parameter parameter;\n  final Node node;\n  final boolean isDuplicate;\n\n  ParamInfo(Parameter parameter, Node node, boolean isDuplicate) {\n    this.parameter = parameter;\n    this.node = node;\n    this.isDuplicate = isDuplicate;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..cb154adc 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -366,44 +366,157 @@ class RemoveUnusedVars\n    *\n    * @param fnScope The scope inside the function\n    */\n-  private void removeUnreferencedFunctionArgs(Scope fnScope) {\n-    // Notice that removing unreferenced function args breaks\n-    // Function.prototype.length. In advanced mode, we don't really care\n-    // about this: we consider \"length\" the equivalent of reflecting on\n-    // the function's lexical source.\n-    //\n-    // Rather than create a new option for this, we assume that if the user\n-    // is removing globals, then it's OK to remove unused function args.\n-    //\n-    // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n-\n-    Node function = fnScope.getRootNode();\n-\n-    Preconditions.checkState(function.isFunction());\n-    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n-      // The parameters object literal setters can not be removed.\n-      return;\n-    }\n-\n-    Node argList = getFunctionArgList(function);\n-    boolean modifyCallers = modifyCallSites\n-        && callSiteOptimizer.canModifyCallers(function);\n-    if (!modifyCallers) {\n-      // Strip unreferenced args off the end of the function declaration.\n-      Node lastArg;\n-      while ((lastArg = argList.getLastChild()) != null) {\n-        Var var = fnScope.getVar(lastArg.getString());\n-        if (!referenced.contains(var)) {\n-          argList.removeChild(lastArg);\n-          compiler.reportCodeChange();\n-        } else {\n-          break;\n-        }\n+import com.google.javascript.rhino.Node;\n+import com.google.javascript.rhino.Scope;\n+import com.google.javascript.rhino.jstype.FunctionType;\n+import com.google.javascript.rhino.jstype.Parameter;\n+import com.google.javascript.rhino.jstype.ParameterizedType;\n+import com.google.javascript.rhino.jstype.StaticSourceFile;\n+import com.google.javascript.rhino.jstype.JSType;\n+\n+import java.util.HashMap;\n+import java.util.Map;\n+\n+import static com.google.common.base.Preconditions.checkState;\n+\n+private void removeUnreferencedFunctionArgs(Scope fnScope, boolean modifyCallSites) {\n+  Node function = fnScope.getRootNode();\n+  checkState(function.isFunction());\n+\n+  if (isFunctionWithRestArgs(function)) {\n+    return;\n+  }\n+\n+  if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+    // The parameters object literal setters can't be removed.\n+    return;\n+  }\n+\n+  Node argList = getFunctionArgList(function);\n+  boolean canModifyCalls = modifyCallSites && referenceMap.acceptsCalls();\n+  Map<String, Integer> referencedVarIndexMap = null;\n+\n+  if (!canModifyCalls) {\n+    // Build a map of referenced vars and their indexes in the arg list.\n+    // The function may have multiple references to the same parameter.\n+    referencedVarIndexMap = new HashMap<String, Integer>();\n+    int idx = 0;\n+    for (Var refVar : referenced) {\n+      ParamInfo paramInfo = getVarParamInfo(fnScope, refVar);\n+      if (paramInfo != null && !paramInfo.isDuplicate) {\n+        referencedVarIndexMap.put(refVar.name, idx++);\n       }\n-    } else {\n-      callSiteOptimizer.optimize(fnScope, referenced);\n     }\n+\n+    // Strip unreferenced args off the end of the function declaration.\n+    Node lastArg;\n+    while ((lastArg = argList.getLastChild()) != null) {\n+      int argIndex = argList.getIndexOfChild(lastArg);\n+      Var var = fnScope.getVar(lastArg.getString());\n+      Integer refVarIndex = referencedVarIndexMap.get(var.name);\n+      if (refVarIndex == null) {\n+        argList.removeChildAtIndex(argIndex);\n+        compiler.reportChangeToEnclosingScope(argList);\n+      } else if (refVarIndex.equals(argIndex)) {\n+        // Skip args that are duplicates of previously referenced args.\n+        referencedVarIndexMap.remove(var.name);\n+      } else {\n+        // Once we reach an argument referred to by a future referenced var,\n+        // we can't remove any more function arguments.\n+        break;\n+      }\n+    }\n+  } else {\n+    rewriteFunctionCallSites(fnScope);\n   }\n+}\n+\n+/**\n+ * Returns true if the function has a rest parameter.\n+ */\n+private static boolean isFunctionWithRestArgs(Node function) {\n+  Node args = getFunctionArgList(function);\n+  return args.getLastChild() != null && args.getLastChild().isRest();\n+}\n+\n+/**\n+ * Given a variable and its enclosing scope, returns a ParamInfo object with\n+ * information about the variable's corresponding parameter, if any.\n+ */\n+private ParamInfo getVarParamInfo(Scope fnScope, Var var) {\n+  if (!var.isParam()) {\n+    return null;\n+  }\n+\n+  Node function = fnScope.getRootNode();\n+  checkState(function.isFunction());\n+\n+  Node argList = getFunctionArgList(function);\n+  int idx = argList.getIndexOfChild(var.nameNode);\n+  if (idx == -1) {\n+    // Function parameters should appear in the argument list.\n+    return null;\n+  }\n+\n+  FunctionType functionType = getFunctionType(function, compiler.getTypeRegistry());\n+  if (functionType == null) {\n+    // We can't optimize calls to functions whose types we can't determine.\n+    return null;\n+  }\n+\n+  ParameterizedType paramType = functionType.getTypeOfThis().toMaybeObjectType()\n+      .getParameterizedType();\n+  if (paramType == null) {\n+    // Functions without a 'this' context can't have parameter type information.\n+    return null;\n+  }\n+\n+  Parameter param = paramType.getParameters().get(idx);\n+  boolean isDuplicate = false;\n+  Node paramNode = argList.getChildAtIndex(idx);\n+  // If there are multiple copies of the parameter in the function scope (e.g.\n+  // from a catch declaration), we only want to reference the first copy.\n+  if (var.getScope().getVar(param.getName()) != var) {\n+    isDuplicate = true;\n+  }\n+\n+  return new ParamInfo(param, paramNode, isDuplicate);\n+}\n+\n+/**\n+ * Returns the type information of a function node using the type registry.\n+ */\n+private FunctionType getFunctionType(Node function, TypeRegistry typeRegistry) {\n+  JSType type = function.getJSType();\n+  if (type == null || !type.isFunctionType()) {\n+    return null;\n+  }\n+\n+  StaticSourceFile sourceFile = type.getSourceFile();\n+  if (sourceFile == null) {\n+    // If it's a function without a closure in the global scope, there is no\n+    // associated type information.\n+    return null;\n+  }\n+\n+  return typeRegistry.getGlobalType(\n+      type.toObjectType(), type.getSourceFile().getName());\n+}\n+\n+/**\n+ * A structure containing information about a function parameter.\n+ */\n+private static class ParamInfo {\n+  final Parameter parameter;\n+  final Node node;\n+  final boolean isDuplicate;\n+\n+  ParamInfo(Parameter parameter, Node node, boolean isDuplicate) {\n+    this.parameter = parameter;\n+    this.node = node;\n+    this.isDuplicate = isDuplicate;\n+  }\n+}\n \n \n   /**",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}