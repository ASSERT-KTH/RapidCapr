{
    "patch": "public int getOffsetFromLocal(long instantLocal) {\n    // get the offset at instantLocal (first estimate)\n    final int initialOffset = getOffset(instantLocal);\n    \n    // find next/previous transitions\n    final long nextTransition = nextTransition(instantLocal);\n    final long prevTransition = previousTransition(instantLocal);\n\n    // check if instantLocal is within a DST interval\n    if (nextTransition == instantLocal || prevTransition == instantLocal) {\n        return initialOffset;\n    }\n    \n    // find offsets at next/previous transitions\n    final int nextOffset = getOffset(nextTransition);\n    final int prevOffset = getOffset(prevTransition);\n    \n    // calculate the duration from instantLocal to next/previous transition\n    final long nextDuration = Math.abs(nextTransition - instantLocal);\n    final long prevDuration = Math.abs(instantLocal - prevTransition);\n    \n    // if instantLocal is closer to the next transition\n    if (nextDuration < prevDuration) {\n        // if the two offsets are not equal and the next transition occurs after instantLocal,\n        // return the initial offset (avoid illegal instant due to time zone offset transition)\n        if (nextOffset != initialOffset && nextTransition > instantLocal) {\n            return initialOffset;\n        } else {\n            return nextOffset;\n        }\n    }\n    // if instantLocal is closer to the previous transition\n    else if (prevDuration < nextDuration) {\n        // if the two offsets are not equal and the previous transition occurs before instantLocal,\n        // return the previous offset (avoid illegal instant due to time zone offset transition)\n        if (prevOffset != initialOffset && prevTransition < instantLocal) {\n            return prevOffset;\n        } else {\n            return initialOffset;\n        }\n    }\n    // if instantLocal is equidistant to both transitions, return the initial offset\n    else {\n        return initialOffset;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..7bc07226 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,52 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+public int getOffsetFromLocal(long instantLocal) {\n+    // get the offset at instantLocal (first estimate)\n+    final int initialOffset = getOffset(instantLocal);\n+    \n+    // find next/previous transitions\n+    final long nextTransition = nextTransition(instantLocal);\n+    final long prevTransition = previousTransition(instantLocal);\n+\n+    // check if instantLocal is within a DST interval\n+    if (nextTransition == instantLocal || prevTransition == instantLocal) {\n+        return initialOffset;\n+    }\n+    \n+    // find offsets at next/previous transitions\n+    final int nextOffset = getOffset(nextTransition);\n+    final int prevOffset = getOffset(prevTransition);\n+    \n+    // calculate the duration from instantLocal to next/previous transition\n+    final long nextDuration = Math.abs(nextTransition - instantLocal);\n+    final long prevDuration = Math.abs(instantLocal - prevTransition);\n+    \n+    // if instantLocal is closer to the next transition\n+    if (nextDuration < prevDuration) {\n+        // if the two offsets are not equal and the next transition occurs after instantLocal,\n+        // return the initial offset (avoid illegal instant due to time zone offset transition)\n+        if (nextOffset != initialOffset && nextTransition > instantLocal) {\n+            return initialOffset;\n+        } else {\n+            return nextOffset;\n+        }\n+    }\n+    // if instantLocal is closer to the previous transition\n+    else if (prevDuration < nextDuration) {\n+        // if the two offsets are not equal and the previous transition occurs before instantLocal,\n+        // return the previous offset (avoid illegal instant due to time zone offset transition)\n+        if (prevOffset != initialOffset && prevTransition < instantLocal) {\n+            return prevOffset;\n+        } else {\n+            return initialOffset;\n+        }\n+    }\n+    // if instantLocal is equidistant to both transitions, return the initial offset\n+    else {\n+        return initialOffset;\n+    }\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}