{
    "patch": "    public Dfp multiply(final int x) {\n        if (isNaN()) { //if this number is NaN, just return NaN\n            return newInstance(getField(), NaN);\n        } else if (x == 0) { //if multiplier is zero, result is zero\n            return newInstance(getField());\n        } else {\n            Dfp result = newInstance(this);\n            boolean productSign = sign == ((x < 0) ? 1 : 0);\n            long lx = x;\n\n            if (lx < 0) { lx = -lx; }\n\n            for (int i = 0; lx != 0; ++i, lx >>>= 1) {\n                if ((lx & 1) != 0) {\n                    result = result.add(shiftedLeftProduct(i).newInstance(result.getField().getZero()).newInstance(result.getRadixDigits()));\n                }\n            }\n\n            result.sign = productSign ? 1 : 0;\n            return dotrap(DfpField.TRAP_OVERFLOW, result, result);\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..d9561b3eb 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1600,7 +1600,26 @@ public class Dfp implements FieldElement<Dfp> {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n+        if (isNaN()) { //if this number is NaN, just return NaN\n+            return newInstance(getField(), NaN);\n+        } else if (x == 0) { //if multiplier is zero, result is zero\n+            return newInstance(getField());\n+        } else {\n+            Dfp result = newInstance(this);\n+            boolean productSign = sign == ((x < 0) ? 1 : 0);\n+            long lx = x;\n+\n+            if (lx < 0) { lx = -lx; }\n+\n+            for (int i = 0; lx != 0; ++i, lx >>>= 1) {\n+                if ((lx & 1) != 0) {\n+                    result = result.add(shiftedLeftProduct(i).newInstance(result.getField().getZero()).newInstance(result.getRadixDigits()));\n+                }\n+            }\n+\n+            result.sign = productSign ? 1 : 0;\n+            return dotrap(DfpField.TRAP_OVERFLOW, result, result);\n+        }\n     }\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}