{
    "patch": "            setResult(min, 0);\n            return result;\n        }\n\n        // return the second endpoint if it is good enough\n        double yMax = f.value(max);\n        if (Math.abs(yMax) <= functionValueAccuracy) {\n            setResult(max, 0);\n            return result;\n        }\n\n        double x1 = min;\n        double x2 = initial;\n        double x3 = max;\n        double y1 = yMin;\n        double y2 = yInitial;\n        double y3 = yMax;\n\n        if(y1 * y2 * y3 == 0) {\n            setResult(y1 == 0 ? x1 : y2 == 0 ? x2 : x3, 0);\n            return result;\n        }\n        \n        while (true) {\n            double fa = (y2 - y1) / (x2 - x1);\n            double fb = (y3 - y2) / (x3 - x2);\n            double fc = (y3 - y1) / (x3 - x1);\n            double s = x2 - ((Math.pow(fa, 2))*(x2 - x1) + fa*(x3 - x2)*(fb - fa) - Math.pow(fb, 2)*(x3 - x2)) / (2*fa*(fb - fa) + (fb - fa)*(fc - fb));\n            double tol = 2.0 * Math.abs(x2) * relativeAccuracy + absoluteAccuracy;\n            double delta = Math.abs(s) - Math.abs(x2);\n            if (delta <= tol) {\n                setResult(s, 0);\n                return result;\n            }\n            double ys = f.value(s);\n            if (ys == 0) {\n                setResult(s, 0);\n                return result;\n            }\n            if (ys * y2 < 0) {\n                x1 = x2;\n                y1 = y2;\n                x2 = s;\n                y2 = ys;\n            } else if (ys * y3 < 0) {\n                x2 = x3;\n                y2 = y3;\n                x3 = s;\n                y3 = ys;\n            } else if (Math.abs(ys) < Math.abs(y2)) {\n                x2 = s;\n                y2 = ys;\n            } else {\n                if (Math.abs(y2 - y1) < Math.abs(y3 - y2)) {\n                    x2 = x1 + goldenRatio*(x2 - x1);\n                    y2 = f.value(x2);\n                } else {\n                    x2 = x3 - goldenRatio*(x3 - x2);\n                    y2 = f.value(x2);\n                }\n            }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..25ce93776 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,53 +95,67 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n-        throws MaxIterationsExceededException, FunctionEvaluationException {\n-\n-        clearResult();\n-        verifySequence(min, initial, max);\n-\n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n+            setResult(min, 0);\n             return result;\n         }\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n-\n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n-\n         // return the second endpoint if it is good enough\n         double yMax = f.value(max);\n         if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+            setResult(max, 0);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n-        }\n+        double x1 = min;\n+        double x2 = initial;\n+        double x3 = max;\n+        double y1 = yMin;\n+        double y2 = yInitial;\n+        double y3 = yMax;\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+        if(y1 * y2 * y3 == 0) {\n+            setResult(y1 == 0 ? x1 : y2 == 0 ? x2 : x3, 0);\n+            return result;\n         }\n-\n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n-\n-    }\n+        \n+        while (true) {\n+            double fa = (y2 - y1) / (x2 - x1);\n+            double fb = (y3 - y2) / (x3 - x2);\n+            double fc = (y3 - y1) / (x3 - x1);\n+            double s = x2 - ((Math.pow(fa, 2))*(x2 - x1) + fa*(x3 - x2)*(fb - fa) - Math.pow(fb, 2)*(x3 - x2)) / (2*fa*(fb - fa) + (fb - fa)*(fc - fb));\n+            double tol = 2.0 * Math.abs(x2) * relativeAccuracy + absoluteAccuracy;\n+            double delta = Math.abs(s) - Math.abs(x2);\n+            if (delta <= tol) {\n+                setResult(s, 0);\n+                return result;\n+            }\n+            double ys = f.value(s);\n+            if (ys == 0) {\n+                setResult(s, 0);\n+                return result;\n+            }\n+            if (ys * y2 < 0) {\n+                x1 = x2;\n+                y1 = y2;\n+                x2 = s;\n+                y2 = ys;\n+            } else if (ys * y3 < 0) {\n+                x2 = x3;\n+                y2 = y3;\n+                x3 = s;\n+                y3 = ys;\n+            } else if (Math.abs(ys) < Math.abs(y2)) {\n+                x2 = s;\n+                y2 = ys;\n+            } else {\n+                if (Math.abs(y2 - y1) < Math.abs(y3 - y2)) {\n+                    x2 = x1 + goldenRatio*(x2 - x1);\n+                    y2 = f.value(x2);\n+                } else {\n+                    x2 = x3 - goldenRatio*(x3 - x2);\n+                    y2 = f.value(x2);\n+                }\n+            }\n \n     /**\n      * Find a zero in the given interval.",
    "result_reason": "error: invalid method declaration; return type required",
    "test_result": "ERROR"
}