{
    "patch": "import org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathUtils;\n\npublic class Gamma {\n\n    private static final double EFAC = 2.0;\n    private static final double BIG = Double.MAX_VALUE / EFAC;\n    private static final double BIGINV = 1.0 / BIG;\n    \n    public static double gamma(double x) {\n        double ret;\n        if (Double.isNaN(x)) {\n            ret = Double.NaN;\n        } else if (x <= 0.0) {\n            if (Math.floor(x) == x) {\n                ret = Double.NaN;\n            } else if (x < 0.0 && x > -20.0) {\n                ret = gamma(1.0 - x) * FastMath.sin(FastMath.PI * x);\n            } else {\n                ret = Double.POSITIVE_INFINITY;\n            }\n        } else {\n            double ax = x + 6.5;\n            double y = (x + 0.5) * Math.log(ax) - ax;\n            double z = 1.0 / (x * x);\n            double pol = 1.000000000190015 == z\n              ? -0.000595238095238\n              : MathUtils.evaluatePolynomial(z, new double[]{\n                      0.99999999999999709182,\n                      -0.99999999999999999798,\n                      0.99999999999999925156,\n                      -0.99999999999999586258,\n                      0.99999999999988796462,\n                      -0.99999999999891012918,\n                      0.99999999999286238788,\n                      -0.99999999996353462646,\n                      0.99999999989952822373,\n                      -0.99999999970965665496,\n                      0.99999999910496791262,\n                      -0.99999999781184733799,\n                      0.99999999282722398037,\n                      -0.99999996613701424213,\n                      0.99999988003825898025,\n                      -0.99999914053213939543,\n                      0.99999778053946546927,\n                      -0.99999259411969387983,\n                      0.99997026874822821973,\n                      -0.99986214478398581467,\n                      0.99921752921538629047,\n                      -0.99578747135324328226,\n                      0.98172808623211838521,\n                      -0.90399536038516682242,\n                      0.71785708183353848085,\n                      -0.35180112342645433255,\n                      0.78539816339744830962e-1,\n                      0.0\n                  });\n            ret = FastMath.exp(y + pol) / x;\n        }\n        return ret;\n    }\n    \n    public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            return Double.NaN;\n        }\n        if (x == 0.0) {\n            return 0.0;\n        }\n        if (a == Double.POSITIVE_INFINITY) {\n            return 1.0;\n        }\n        if (x == Double.POSITIVE_INFINITY) {\n            return 1.0;\n        }\n        if (a > 1000.0) {\n            return RegularizedGammaP.Approximation.hardy(a, x);\n        }\n        return RegularizedGammaP.Series.taylor(a, x, epsilon, maxIterations);\n    }\n}\n\nclass TestUtils {\n    public static void assertEquals(double expected, double actual, double epsilon) {\n        if (Double.isNaN(expected) && Double.isNaN(actual)) {\n            return;\n        }\n        if (Double.compare(expected, actual) != 0 && \n            FastMath.abs(expected - actual) > epsilon) {\n                throw new AssertionFailedError(\"expected:<\" + expected+ \"> but was:<\" + actual + \">\");\n        }\n    }\n}\n\nclass RegularizedGammaP {\n\n    public static class Series {\n\n        public static double taylor(double a, double x, double epsilon, int maxIterations) {\n            double n = 0.0;\n            double an = 1.0 / a;\n            double sum = an;\n\n            while (FastMath.abs(an / sum) > epsilon &&\n                n < maxIterations &&\n                sum < Double.MAX_VALUE) {\n                n += 1.0;\n                an *= x / (a + n);\n                sum += an;\n            }\n            if (n >= maxIterations) {\n                throw new MaxIterationsExceededException(maxIterations);\n            }\n            if (Double.isInfinite(sum)) {\n                return 1.0;\n            }\n            return FastMath.exp(-x + (FastMath.log(x) * a)) * sum;\n        }\n    }\n\n    public static class Approximation {\n\n        public static double erfc(double z) {\n            if (z < 0) {\n                throw new IllegalArgumentException(\" z must be >= 0\");\n            }\n\n            double t = 1.0 / (1.0 + 0.5 * z);\n            double ans = 1 - t * FastMath.exp(-z * z - 1.26551223 + \n                t * (1.00002368 + \n                t * (0.37409196 + \n                t * (0.09678418 + \n                t * (-0.18628806 + \n                t * (0.27886807 + \n                t * (-1.13520398 + \n                t * (1.48851587 + \n                t * (-0.82215223 + \n                t * 0.17087277)))))))));\n            if (Double.isNaN(ans)) {\n                throw new ArithmeticException(\"Numerical computation has failed\");\n            }\n            return ans;\n        }\n\n        public static double hardy(double a, double x) {\n            double axj = a * FastMath.log(x) - x - FastMath.log(a);\n            if (axj < -709.78271289338397) {\n                return (x < a ? 0.0 : 1.0);\n            }\n\n            double xx = a * FastMath.log(a / (x));\n            double yy = a - 0.5 * x;\n            double zz = 1.0 / FastMath.sqrt(2.0 * FastMath.PI);\n\n            double e = xx + yy;\n            double p;\n            double q;\n            double sqrtt = FastMath.sqrt(a);\n            double sqrtp = FastMath.sqrt(-e / sqrtt);\n            double sqrtq = FastMath.sqrt((x / a) * e / sqrtt);\n\n            if (e < 0) {\n                p = sqrtp * (1 - erfc(sqrtt / FastMath.sqrt(2)) / 2);\n                q = sqrtq * (1 + erfc(sqrtt / FastMath.sqrt(2)) / 2);\n            } else {\n                p = sqrtp * (1 - chisq(sqrtt, e) / 2);\n                q = sqrtq * (1 + chisq(sqrtt, e) / 2);\n            }\n            return zz * (p - q);\n        }\n\n        public static double chisq(double df, double x) {\n            if (x < 0 || df < 1) {\n                throw new IllegalArgumentException();\n            }\n\n            double a = 0.5 * x;\n            double b = 0.5 * df;\n            double xx;\n            double yy;\n            double ans;\n            if (a > 1.0) {\n                xx = (a - b) / a;\n                yy = b / a * 0.5;\n                ans = FastMath.exp(-a) * igf(xx, yy);\n            } else {\n                xx = b * FastMath.log(a) - a - logGamma(b + 1.0);\n                ans = (xx > -709.78271289338397) ? FastMath.exp(xx) : 0.0;\n            }\n            return ans;\n        }\n\n        public static double igf(double a, double x) {\n            double igf;\n            if (Double.compare(x, a + 1.0) > 0) {\n                igf = 1.0 - incompleteGammaComplement(a, x);\n            } else {\n                double small = 1.0e-14;\n                double big = 1.0 / small;\n                double ans = 0.0;\n                double term = 1.0;\n                double i = 0.0;\n                boolean cont = true;\n\n                while (cont) {\n                    i += 1.0;\n                    term *= x / (a + i);\n                    double t = term < big ? term : Double.MAX_VALUE;\n                    ans += t;\n                    cont = (FastMath.abs(t / ans) > small) && (i < MAX_NUM_ITERATIONS);\n                }\n                igf = ans + Math.pow(x / a, a) * FastMath.exp(-x) / logGamma(a + 1.0) - incompleteGammaComplement(a, x);\n            }\n            return igf;\n        }\n\n        public static double incompleteGammaComplement(double a, double x) {\n            if (Double.compare(a, 0.0) < 0 || Double.compare(x, 0.0) <= 0) {\n                throw new IllegalArgumentException();\n            }\n\n            if (Double.compare(x, a + 1) < 0) {\n                return 1 - incompleteGamma(a, x);\n            }\n\n            double frac = 1.0 / x;\n            double p = frac;\n            double ans = p;\n            double q = a / x;\n            int i = 1;\n            boolean keepGoing = true;\n\n            while (keepGoing) {\n                double aplusi = a + i;\n                frac *= (aplusi - i) / x;\n                p += frac;\n                double term = p * q;\n                ans += term;\n                i += 1;\n                if (term / ans < 3.0e-7) {\n                    keepGoing = false;\n                }\n            }\n\n            return ans * FastMath.exp(-x + a * FastMath.log(x) - logGamma(a));\n        }\n\n        public static double incompleteGamma(double a, double x) {\n            if (Double.compare(a, 0.0) < 0 || Double.compare(x, 0.0) <= 0) {\n                throw new IllegalArgumentException();\n            }\n\n            if (Double.compare(x, a + 1) > 0) {\n                return 1 - incompleteGammaComplement(a, x);\n            }\n\n            double series = 1.0 / a;\n            double term = series;\n            double sum = term;\n\n            boolean keepGoing = true;\n            int n = 1;\n            while (keepGoing) {\n                term *= x / (a + n);\n                sum += term;\n                n += 1;\n                if (term / sum < 3.0e-7) {\n                    keepGoing = false;\n                }\n            }\n\n            return sum * FastMath.exp(-x + a * FastMath.log(x) - logGamma(a));\n        }\n\n        private static double logGamma(double x) {\n            return Gamma.logGamma(x);\n        }\n    }\n\n    public static class MaxIterationsExceededException extends RuntimeException {\n\n        private static final long serialVersionUID = -5924912214179672224L;\n        private int maxIterations;\n\n        public MaxIterationsExceededException(int maxIterations) {\n            this.maxIterations = maxIterations;\n        }\n\n        public int getMaxIterations() {\n            return maxIterations;\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..81c6592a8 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,299 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.util.FastMath;\n+import org.apache.commons.math3.util.MathUtils;\n+\n+public class Gamma {\n+\n+    private static final double EFAC = 2.0;\n+    private static final double BIG = Double.MAX_VALUE / EFAC;\n+    private static final double BIGINV = 1.0 / BIG;\n+    \n+    public static double gamma(double x) {\n+        double ret;\n+        if (Double.isNaN(x)) {\n+            ret = Double.NaN;\n+        } else if (x <= 0.0) {\n+            if (Math.floor(x) == x) {\n+                ret = Double.NaN;\n+            } else if (x < 0.0 && x > -20.0) {\n+                ret = gamma(1.0 - x) * FastMath.sin(FastMath.PI * x);\n+            } else {\n+                ret = Double.POSITIVE_INFINITY;\n+            }\n+        } else {\n+            double ax = x + 6.5;\n+            double y = (x + 0.5) * Math.log(ax) - ax;\n+            double z = 1.0 / (x * x);\n+            double pol = 1.000000000190015 == z\n+              ? -0.000595238095238\n+              : MathUtils.evaluatePolynomial(z, new double[]{\n+                      0.99999999999999709182,\n+                      -0.99999999999999999798,\n+                      0.99999999999999925156,\n+                      -0.99999999999999586258,\n+                      0.99999999999988796462,\n+                      -0.99999999999891012918,\n+                      0.99999999999286238788,\n+                      -0.99999999996353462646,\n+                      0.99999999989952822373,\n+                      -0.99999999970965665496,\n+                      0.99999999910496791262,\n+                      -0.99999999781184733799,\n+                      0.99999999282722398037,\n+                      -0.99999996613701424213,\n+                      0.99999988003825898025,\n+                      -0.99999914053213939543,\n+                      0.99999778053946546927,\n+                      -0.99999259411969387983,\n+                      0.99997026874822821973,\n+                      -0.99986214478398581467,\n+                      0.99921752921538629047,\n+                      -0.99578747135324328226,\n+                      0.98172808623211838521,\n+                      -0.90399536038516682242,\n+                      0.71785708183353848085,\n+                      -0.35180112342645433255,\n+                      0.78539816339744830962e-1,\n+                      0.0\n+                  });\n+            ret = FastMath.exp(y + pol) / x;\n+        }\n+        return ret;\n+    }\n+    \n+    public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n+        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n+            return Double.NaN;\n+        }\n+        if (x == 0.0) {\n+            return 0.0;\n+        }\n+        if (a == Double.POSITIVE_INFINITY) {\n+            return 1.0;\n+        }\n+        if (x == Double.POSITIVE_INFINITY) {\n+            return 1.0;\n+        }\n+        if (a > 1000.0) {\n+            return RegularizedGammaP.Approximation.hardy(a, x);\n+        }\n+        return RegularizedGammaP.Series.taylor(a, x, epsilon, maxIterations);\n+    }\n+}\n+\n+class TestUtils {\n+    public static void assertEquals(double expected, double actual, double epsilon) {\n+        if (Double.isNaN(expected) && Double.isNaN(actual)) {\n+            return;\n+        }\n+        if (Double.compare(expected, actual) != 0 && \n+            FastMath.abs(expected - actual) > epsilon) {\n+                throw new AssertionFailedError(\"expected:<\" + expected+ \"> but was:<\" + actual + \">\");\n+        }\n+    }\n+}\n+\n+class RegularizedGammaP {\n+\n+    public static class Series {\n+\n+        public static double taylor(double a, double x, double epsilon, int maxIterations) {\n+            double n = 0.0;\n+            double an = 1.0 / a;\n+            double sum = an;\n+\n+            while (FastMath.abs(an / sum) > epsilon &&\n+                n < maxIterations &&\n+                sum < Double.MAX_VALUE) {\n+                n += 1.0;\n+                an *= x / (a + n);\n+                sum += an;\n+            }\n+            if (n >= maxIterations) {\n+                throw new MaxIterationsExceededException(maxIterations);\n+            }\n+            if (Double.isInfinite(sum)) {\n+                return 1.0;\n+            }\n+            return FastMath.exp(-x + (FastMath.log(x) * a)) * sum;\n+        }\n+    }\n+\n+    public static class Approximation {\n+\n+        public static double erfc(double z) {\n+            if (z < 0) {\n+                throw new IllegalArgumentException(\" z must be >= 0\");\n+            }\n+\n+            double t = 1.0 / (1.0 + 0.5 * z);\n+            double ans = 1 - t * FastMath.exp(-z * z - 1.26551223 + \n+                t * (1.00002368 + \n+                t * (0.37409196 + \n+                t * (0.09678418 + \n+                t * (-0.18628806 + \n+                t * (0.27886807 + \n+                t * (-1.13520398 + \n+                t * (1.48851587 + \n+                t * (-0.82215223 + \n+                t * 0.17087277)))))))));\n+            if (Double.isNaN(ans)) {\n+                throw new ArithmeticException(\"Numerical computation has failed\");\n+            }\n+            return ans;\n+        }\n+\n+        public static double hardy(double a, double x) {\n+            double axj = a * FastMath.log(x) - x - FastMath.log(a);\n+            if (axj < -709.78271289338397) {\n+                return (x < a ? 0.0 : 1.0);\n+            }\n+\n+            double xx = a * FastMath.log(a / (x));\n+            double yy = a - 0.5 * x;\n+            double zz = 1.0 / FastMath.sqrt(2.0 * FastMath.PI);\n+\n+            double e = xx + yy;\n+            double p;\n+            double q;\n+            double sqrtt = FastMath.sqrt(a);\n+            double sqrtp = FastMath.sqrt(-e / sqrtt);\n+            double sqrtq = FastMath.sqrt((x / a) * e / sqrtt);\n+\n+            if (e < 0) {\n+                p = sqrtp * (1 - erfc(sqrtt / FastMath.sqrt(2)) / 2);\n+                q = sqrtq * (1 + erfc(sqrtt / FastMath.sqrt(2)) / 2);\n+            } else {\n+                p = sqrtp * (1 - chisq(sqrtt, e) / 2);\n+                q = sqrtq * (1 + chisq(sqrtt, e) / 2);\n+            }\n+            return zz * (p - q);\n+        }\n+\n+        public static double chisq(double df, double x) {\n+            if (x < 0 || df < 1) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            double a = 0.5 * x;\n+            double b = 0.5 * df;\n+            double xx;\n+            double yy;\n+            double ans;\n+            if (a > 1.0) {\n+                xx = (a - b) / a;\n+                yy = b / a * 0.5;\n+                ans = FastMath.exp(-a) * igf(xx, yy);\n+            } else {\n+                xx = b * FastMath.log(a) - a - logGamma(b + 1.0);\n+                ans = (xx > -709.78271289338397) ? FastMath.exp(xx) : 0.0;\n+            }\n+            return ans;\n+        }\n+\n+        public static double igf(double a, double x) {\n+            double igf;\n+            if (Double.compare(x, a + 1.0) > 0) {\n+                igf = 1.0 - incompleteGammaComplement(a, x);\n+            } else {\n+                double small = 1.0e-14;\n+                double big = 1.0 / small;\n+                double ans = 0.0;\n+                double term = 1.0;\n+                double i = 0.0;\n+                boolean cont = true;\n+\n+                while (cont) {\n+                    i += 1.0;\n+                    term *= x / (a + i);\n+                    double t = term < big ? term : Double.MAX_VALUE;\n+                    ans += t;\n+                    cont = (FastMath.abs(t / ans) > small) && (i < MAX_NUM_ITERATIONS);\n+                }\n+                igf = ans + Math.pow(x / a, a) * FastMath.exp(-x) / logGamma(a + 1.0) - incompleteGammaComplement(a, x);\n+            }\n+            return igf;\n+        }\n+\n+        public static double incompleteGammaComplement(double a, double x) {\n+            if (Double.compare(a, 0.0) < 0 || Double.compare(x, 0.0) <= 0) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (Double.compare(x, a + 1) < 0) {\n+                return 1 - incompleteGamma(a, x);\n+            }\n+\n+            double frac = 1.0 / x;\n+            double p = frac;\n+            double ans = p;\n+            double q = a / x;\n+            int i = 1;\n+            boolean keepGoing = true;\n+\n+            while (keepGoing) {\n+                double aplusi = a + i;\n+                frac *= (aplusi - i) / x;\n+                p += frac;\n+                double term = p * q;\n+                ans += term;\n+                i += 1;\n+                if (term / ans < 3.0e-7) {\n+                    keepGoing = false;\n+                }\n+            }\n+\n+            return ans * FastMath.exp(-x + a * FastMath.log(x) - logGamma(a));\n+        }\n+\n+        public static double incompleteGamma(double a, double x) {\n+            if (Double.compare(a, 0.0) < 0 || Double.compare(x, 0.0) <= 0) {\n+                throw new IllegalArgumentException();\n+            }\n+\n+            if (Double.compare(x, a + 1) > 0) {\n+                return 1 - incompleteGammaComplement(a, x);\n+            }\n+\n+            double series = 1.0 / a;\n+            double term = series;\n+            double sum = term;\n+\n+            boolean keepGoing = true;\n+            int n = 1;\n+            while (keepGoing) {\n+                term *= x / (a + n);\n+                sum += term;\n+                n += 1;\n+                if (term / sum < 3.0e-7) {\n+                    keepGoing = false;\n+                }\n+            }\n+\n+            return sum * FastMath.exp(-x + a * FastMath.log(x) - logGamma(a));\n+        }\n+\n+        private static double logGamma(double x) {\n+            return Gamma.logGamma(x);\n+        }\n+    }\n+\n+    public static class MaxIterationsExceededException extends RuntimeException {\n+\n+        private static final long serialVersionUID = -5924912214179672224L;\n+        private int maxIterations;\n+\n+        public MaxIterationsExceededException(int maxIterations) {\n+            this.maxIterations = maxIterations;\n+        }\n+\n+        public int getMaxIterations() {\n+            return maxIterations;\n+        }\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}