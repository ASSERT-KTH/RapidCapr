{
    "patch": "import java.util.ArrayList;\nimport java.util.Collections;\nimport java.util.Iterator;\nimport java.util.List;\n\npublic class EventStateSolver<T extends RealFieldElement<T>> {\n\n    private final List<EventState> eventsStates;\n    private final List<StepHandler> stepHandlers;\n    private final double convergence;\n    private final int maxIterationCount;\n    private final RealFieldElementInterpolator<T> interpolator;\n    private final boolean forward;\n\n    public EventStateSolver(final Field<T> field, final List<EventState> states, final RealFieldElementInterpolator<T> interp,\n                            final double convergenceThreshold, final int maxIteration) {\n        this.eventsStates = new ArrayList<>(states);\n        this.stepHandlers = new ArrayList<>();\n        this.convergence = convergenceThreshold;\n        this.maxIterationCount = maxIteration;\n        this.interpolator = interp;\n        this.forward = interp.getPreviousState().getTime().compareTo(interp.getCurrentState().getTime()) < 0;\n    }\n\n    public void addStepHandler(final StepHandler handler) {\n        stepHandlers.add(handler);\n    }\n\n    public void clearStepHandlers() {\n        stepHandlers.clear();\n    }\n\n    public realsolve(final T finalTime) {\n        final List<EventState> occuringEvents = new ArrayList<>();\n        T t = interpolator.getCurrentState().getTime();\n        final T tEnd  = finalTime;\n        interpolateAtBoundary();\n        boolean isLastStep = false;\n        while (!isLastStep) {\n            // search for next events that may arise during this step\n            resetEventsStates();\n            T tMin = forward ? tEnd : t.subtract(tEnd.subtract(t).multiply(100.0 * convergence));\n            tMin = (tMin.subtract(t)).getField().getZero().add(t).max(t);\n            addEventsWhenNeeded(t, occuringEvents, tMin);\n            // prepare switching function\n            Collections.sort(occuringEvents);\n            final T tEvent = occuringEvents.get(0).getEventTime();\n            if (!forward) {\n                Collections.reverse(occuringEvents);\n            }\n            final T dtPos = tEvent.subtract(t);\n            final T dtNeg = tEvent.subtract(tEnd);\n            // update state until the switching time\n            interpolator.setSoftPreviousTime(t);\n            interpolator.setSoftCurrentTime(tEvent);\n            boolean needReset = true;\n            int i = 0;\n            while ((dtPos.multiply(dtNeg)).getReal() < 0) {\n                performStep(true);\n                if (needReset) {\n                    // multiple events at the same time results into separate events which\n                    // are seen as occurring during the same global state transition, so only\n                    // the first one should cause a reset, otherwise the events that were only\n                    // switched on during a later local step would be missed\n                    Collections.sort(occuringEvents);\n                    final T tEventTry = occuringEvents.get(0).getEventTime();\n                    interpolator.setInterpolatedTime(tEventTry);\n                    if (!tEventTry.equals(tEvent)) {\n                        needReset = false;\n                    }\n                }\n                if (++i > maxIterationCount) {\n                    throw new ConvergenceException(new LocalizedFormats(\"EVENT_PROBLEM\"));\n                }\n                dtPos = tEvent.subtract(t);\n                dtNeg = tEvent.subtract(tEnd);\n                real finalTolerance = convergence * (Math.abs(dtNeg.getReal()) + Math.abs(dtPos.getReal())) * 0.5;\n                if (dtPos.negate().getReal() <= finalTolerance) {\n                    // we have reached tEvent, we accept the step, the next\n                    // step will deal with the event itself\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, false);\n                    }\n                    isLastStep = false;\n                    break;\n                }\n            }\n            if ((dtPos.multiply(dtNeg)).getReal() >= 0) {\n                // we have passed the event without triggering it, we accept the step\n                isLastStep = false;\n            } else {\n                // we have triggered the event\n                if (!occuringEvents.get(0).evaluateStep(interpolator)) {\n                    // refuse the step, the event handler has triggered rejection\n                    isLastStep = false;\n                } else {\n                    // accept the step, the event handler has triggered completion\n                    isLastStep = true;\n                }\n            }\n            // advance the time to the end of the step\n            if (!isLastStep) {\n                t = tEvent;\n                for (final EventState state : eventsStates) {\n                    state.stepAccepted(t, interpolator.getInterpolatedState());\n                    isLastStep |= state.stop();\n                }\n            } else {\n                t = tEnd;\n            }\n        }\n        initialState = interpolator.getCurrentState();\n        interpolator.shift();\n    }\n\n    private boolean performStep(final boolean isFirst)  {\n        boolean needUpdate = isFirst;\n        for (final FieldStepInterpolator<T> interpolator : interpolator.getInterpolators()) {\n            final FieldODEStateAndDerivative<T> current = interpolator.getCurrentState();\n            final FieldODEStateAndDerivative<T> previous = interpolator.getPreviousState();\n            // reset only once the events states at the beginning of the step\n            if (needUpdate) {\n                interpolator.setInterpolatedTime(current.getTime());\n                resetEventsStates();\n                updateEventsStates();\n            }\n            // advance all events to current time\n            for (final EventState state : eventsStates) {\n                state.stepAccepted(current.getTime(), interpolator.getInterpolatedState().toRealArray());\n            }\n            // check if any event has occurred during integration\n            final List<EventState> occurring = new ArrayList<>();\n            final T tEnd   = current.getTime();\n            final T tStart = previous.getTime();\n            addEventsWhenNeeded(tStart, occurring, tEnd);\n            if (!occurring.isEmpty()) {\n                // something occurred before we reached current time, we need a special handling\n                final Iterator<EventState> iterator = occurring.iterator();\n                while (iterator.hasNext()) {\n                    final EventState state = iterator.next();\n                    if (state.evaluateStep(interpolator)) {\n                        // the event occurs during the current step\n                        iterator.remove();\n                        occuringEvents.add(state);\n                    }\n                }\n                if (!occurring.isEmpty()) {\n                    // some event is already pending in the current time step\n                    needUpdate = false;\n                    Collections.sort(occurring);\n                    final EventState firstEvent = occurring.get(0);\n                    final T eventT = (firstEvent).getEventTime();\n                    interpolator.setSoftPreviousTime(previous.getTime());\n                    interpolator.setSoftCurrentTime(eventT);\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, false);\n                    }\n                    return false;\n                } else {\n                    // we have cleared all events before current time, continue\n                    needUpdate = true;\n                }\n            }\n            // do the step\n            final T hNew = integrator.integrate(interpolator, current.getTime().add(maxCheckInterval));\n            interpolator.shift();\n            // check convergence with respect to the start of the step\n            final real[] yTmp = new real[y0.length];\n            for (int i = 0; i < y0.length; ++i) {\n                yTmp[i] = current.getState()[i].getReal();\n            }\n            for (final FieldStepInterpolator<T> dp : interpolator.getInterpolators()) {\n                final FieldODEStateAndDerivative<T> currentI = dp.getCurrentState();\n                final FieldODEStateAndDerivative<T> previousI = dp.getPreviousState();\n                final real prev   = previousI.getTime().getReal();\n                final real curr   = currentI.getTime().getReal();\n                final real[] currY = currentI.getState().toRealArray();\n                final real[] prevY = previousI.getState().toRealArray();\n                final real[] scale = new real[y0.length];\n                for (int i = 0; i < scale.length; ++i) {\n                    scale[i] = atol + rtol * max(abs(prevY[i]), abs(currY[i]));\n                }\n                // compute error\n                real error = 0;\n                for (int i = 0; i < y0.length; ++i) {\n                    error = max(error, abs(prevY[i] - currY[i]) / scale[i]);\n                }\n                if (error > 1.0) {\n                    // reject the step, error is too large with respect to the tolerance\n                    interpolator.setInterpolatedTime(previousI.getTime());\n                    for (final StepHandler handler : stepHandlers) {\n                        handler.handleStep(interpolator, false);\n                    }\n                    return false;\n                }\n            }\n            // prepare next step\n            needUpdate = true;\n        }\n        return true;\n    }\n\n    private void resetEventsStates() {\n        for (final EventState state : eventsStates) {\n            state.setConverged(false);\n        }\n    }\n\n    private void updateEventsStates() {\n        for (final EventState state : eventsStates) {\n            state.reinitializeBegin(interpolator);\n        }\n    }\n\n    private void addEventsWhenNeeded(final T t0, final List<EventState> occurringEvents, final T tEventMax) {\n        final T epsilon = (t0.getField().getZero()).add(100.0 * convergence);\n        for (final EventState state : eventsStates) {\n            // add event to list if it occurred during step\n            final T tEvent = searchNextEvent(state, t0, tEventMax);\n            if ((tEvent.subtract(t0)).multiply(tEventMax.subtract(t0)).getReal() < 0\n                    && tEvent.subtract(t0).abs().getReal() >= epsilon.getReal()) {\n                // the event is really located within the current step, add it to\n                // the events that will be returned\n                state.setEventTime(tEvent);\n                occurringEvents.add(state);\n            }\n        }\n    }\n\n    private T searchNextEvent(final EventState es, final T t0, final T tEventMax) {\n        T t = t0.add(minimalStep);\n\n        while ((tEventMax.subtract(t)).getReal() >= 0) {\n            es.stepAccepted(t, interpolator.getInterpolatedState().toRealArray());\n            isLastStep = es.stop();\n\n            if (isLastStep) {\n                // event occurred, accept the last processed state as part of the current step\n                return es.getEventTime();\n            }\n\n            integrator.integrate(interpolator, t.add(maxCheckInterval));\n            t = interpolator.getCurrentState().getTime();\n        }\n\n        // we did not find any event within the remaining time\n        return tEventMax;\n\n    }\n\n    private void interpolateAtBoundary() {\n        if (interpolator.isForward()) {\n            interpolator.setSoftPreviousTime(interpolator.getPreviousState().getTime());\n            interpolator.setSoftCurrentTime(interpolator.getCurrentState().getTime());\n        } else {\n            interpolator.setSoftPreviousTime(interpolator.getCurrentState().getTime());\n            interpolator.setSoftCurrentTime(interpolator.getPreviousState().getTime());\n        }\n    }\n\n    public interface StepHandler {\n\n        void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast)\n                        throws org.hipparchus.exception.MathRuntimeException;\n\n    }\n\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..e748143c9 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,274 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n+import java.util.ArrayList;\n+import java.util.Collections;\n+import java.util.Iterator;\n+import java.util.List;\n+\n+public class EventStateSolver<T extends RealFieldElement<T>> {\n+\n+    private final List<EventState> eventsStates;\n+    private final List<StepHandler> stepHandlers;\n+    private final double convergence;\n+    private final int maxIterationCount;\n+    private final RealFieldElementInterpolator<T> interpolator;\n+    private final boolean forward;\n+\n+    public EventStateSolver(final Field<T> field, final List<EventState> states, final RealFieldElementInterpolator<T> interp,\n+                            final double convergenceThreshold, final int maxIteration) {\n+        this.eventsStates = new ArrayList<>(states);\n+        this.stepHandlers = new ArrayList<>();\n+        this.convergence = convergenceThreshold;\n+        this.maxIterationCount = maxIteration;\n+        this.interpolator = interp;\n+        this.forward = interp.getPreviousState().getTime().compareTo(interp.getCurrentState().getTime()) < 0;\n+    }\n+\n+    public void addStepHandler(final StepHandler handler) {\n+        stepHandlers.add(handler);\n+    }\n \n-            });\n+    public void clearStepHandlers() {\n+        stepHandlers.clear();\n+    }\n \n+    public realsolve(final T finalTime) {\n+        final List<EventState> occuringEvents = new ArrayList<>();\n+        T t = interpolator.getCurrentState().getTime();\n+        final T tEnd  = finalTime;\n+        interpolateAtBoundary();\n+        boolean isLastStep = false;\n+        while (!isLastStep) {\n+            // search for next events that may arise during this step\n+            resetEventsStates();\n+            T tMin = forward ? tEnd : t.subtract(tEnd.subtract(t).multiply(100.0 * convergence));\n+            tMin = (tMin.subtract(t)).getField().getZero().add(t).max(t);\n+            addEventsWhenNeeded(t, occuringEvents, tMin);\n+            // prepare switching function\n+            Collections.sort(occuringEvents);\n+            final T tEvent = occuringEvents.get(0).getEventTime();\n+            if (!forward) {\n+                Collections.reverse(occuringEvents);\n+            }\n+            final T dtPos = tEvent.subtract(t);\n+            final T dtNeg = tEvent.subtract(tEnd);\n+            // update state until the switching time\n+            interpolator.setSoftPreviousTime(t);\n+            interpolator.setSoftCurrentTime(tEvent);\n+            boolean needReset = true;\n+            int i = 0;\n+            while ((dtPos.multiply(dtNeg)).getReal() < 0) {\n+                performStep(true);\n+                if (needReset) {\n+                    // multiple events at the same time results into separate events which\n+                    // are seen as occurring during the same global state transition, so only\n+                    // the first one should cause a reset, otherwise the events that were only\n+                    // switched on during a later local step would be missed\n+                    Collections.sort(occuringEvents);\n+                    final T tEventTry = occuringEvents.get(0).getEventTime();\n+                    interpolator.setInterpolatedTime(tEventTry);\n+                    if (!tEventTry.equals(tEvent)) {\n+                        needReset = false;\n+                    }\n+                }\n+                if (++i > maxIterationCount) {\n+                    throw new ConvergenceException(new LocalizedFormats(\"EVENT_PROBLEM\"));\n+                }\n+                dtPos = tEvent.subtract(t);\n+                dtNeg = tEvent.subtract(tEnd);\n+                real finalTolerance = convergence * (Math.abs(dtNeg.getReal()) + Math.abs(dtPos.getReal())) * 0.5;\n+                if (dtPos.negate().getReal() <= finalTolerance) {\n+                    // we have reached tEvent, we accept the step, the next\n+                    // step will deal with the event itself\n+                    for (final StepHandler handler : stepHandlers) {\n+                        handler.handleStep(interpolator, false);\n+                    }\n+                    isLastStep = false;\n+                    break;\n+                }\n+            }\n+            if ((dtPos.multiply(dtNeg)).getReal() >= 0) {\n+                // we have passed the event without triggering it, we accept the step\n+                isLastStep = false;\n+            } else {\n+                // we have triggered the event\n+                if (!occuringEvents.get(0).evaluateStep(interpolator)) {\n+                    // refuse the step, the event handler has triggered rejection\n+                    isLastStep = false;\n+                } else {\n+                    // accept the step, the event handler has triggered completion\n+                    isLastStep = true;\n+                }\n+            }\n+            // advance the time to the end of the step\n+            if (!isLastStep) {\n+                t = tEvent;\n+                for (final EventState state : eventsStates) {\n+                    state.stepAccepted(t, interpolator.getInterpolatedState());\n+                    isLastStep |= state.stop();\n+                }\n+            } else {\n+                t = tEnd;\n+            }\n+        }\n+        initialState = interpolator.getCurrentState();\n+        interpolator.shift();\n+    }\n+\n+    private boolean performStep(final boolean isFirst)  {\n+        boolean needUpdate = isFirst;\n+        for (final FieldStepInterpolator<T> interpolator : interpolator.getInterpolators()) {\n+            final FieldODEStateAndDerivative<T> current = interpolator.getCurrentState();\n+            final FieldODEStateAndDerivative<T> previous = interpolator.getPreviousState();\n+            // reset only once the events states at the beginning of the step\n+            if (needUpdate) {\n+                interpolator.setInterpolatedTime(current.getTime());\n+                resetEventsStates();\n+                updateEventsStates();\n+            }\n+            // advance all events to current time\n             for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n+                state.stepAccepted(current.getTime(), interpolator.getInterpolatedState().toRealArray());\n+            }\n+            // check if any event has occurred during integration\n+            final List<EventState> occurring = new ArrayList<>();\n+            final T tEnd   = current.getTime();\n+            final T tStart = previous.getTime();\n+            addEventsWhenNeeded(tStart, occurring, tEnd);\n+            if (!occurring.isEmpty()) {\n+                // something occurred before we reached current time, we need a special handling\n+                final Iterator<EventState> iterator = occurring.iterator();\n+                while (iterator.hasNext()) {\n+                    final EventState state = iterator.next();\n+                    if (state.evaluateStep(interpolator)) {\n+                        // the event occurs during the current step\n+                        iterator.remove();\n+                        occuringEvents.add(state);\n+                    }\n+                }\n+                if (!occurring.isEmpty()) {\n+                    // some event is already pending in the current time step\n+                    needUpdate = false;\n+                    Collections.sort(occurring);\n+                    final EventState firstEvent = occurring.get(0);\n+                    final T eventT = (firstEvent).getEventTime();\n+                    interpolator.setSoftPreviousTime(previous.getTime());\n+                    interpolator.setSoftCurrentTime(eventT);\n+                    for (final StepHandler handler : stepHandlers) {\n+                        handler.handleStep(interpolator, false);\n+                    }\n+                    return false;\n+                } else {\n+                    // we have cleared all events before current time, continue\n+                    needUpdate = true;\n                 }\n             }\n+            // do the step\n+            final T hNew = integrator.integrate(interpolator, current.getTime().add(maxCheckInterval));\n+            interpolator.shift();\n+            // check convergence with respect to the start of the step\n+            final real[] yTmp = new real[y0.length];\n+            for (int i = 0; i < y0.length; ++i) {\n+                yTmp[i] = current.getState()[i].getReal();\n+            }\n+            for (final FieldStepInterpolator<T> dp : interpolator.getInterpolators()) {\n+                final FieldODEStateAndDerivative<T> currentI = dp.getCurrentState();\n+                final FieldODEStateAndDerivative<T> previousI = dp.getPreviousState();\n+                final real prev   = previousI.getTime().getReal();\n+                final real curr   = currentI.getTime().getReal();\n+                final real[] currY = currentI.getState().toRealArray();\n+                final real[] prevY = previousI.getState().toRealArray();\n+                final real[] scale = new real[y0.length];\n+                for (int i = 0; i < scale.length; ++i) {\n+                    scale[i] = atol + rtol * max(abs(prevY[i]), abs(currY[i]));\n+                }\n+                // compute error\n+                real error = 0;\n+                for (int i = 0; i < y0.length; ++i) {\n+                    error = max(error, abs(prevY[i] - currY[i]) / scale[i]);\n+                }\n+                if (error > 1.0) {\n+                    // reject the step, error is too large with respect to the tolerance\n+                    interpolator.setInterpolatedTime(previousI.getTime());\n+                    for (final StepHandler handler : stepHandlers) {\n+                        handler.handleStep(interpolator, false);\n+                    }\n+                    return false;\n+                }\n+            }\n+            // prepare next step\n+            needUpdate = true;\n+        }\n+        return true;\n+    }\n+\n+    private void resetEventsStates() {\n+        for (final EventState state : eventsStates) {\n+            state.setConverged(false);\n+        }\n+    }\n+\n+    private void updateEventsStates() {\n+        for (final EventState state : eventsStates) {\n+            state.reinitializeBegin(interpolator);\n+        }\n+    }\n+\n+    private void addEventsWhenNeeded(final T t0, final List<EventState> occurringEvents, final T tEventMax) {\n+        final T epsilon = (t0.getField().getZero()).add(100.0 * convergence);\n+        for (final EventState state : eventsStates) {\n+            // add event to list if it occurred during step\n+            final T tEvent = searchNextEvent(state, t0, tEventMax);\n+            if ((tEvent.subtract(t0)).multiply(tEventMax.subtract(t0)).getReal() < 0\n+                    && tEvent.subtract(t0).abs().getReal() >= epsilon.getReal()) {\n+                // the event is really located within the current step, add it to\n+                // the events that will be returned\n+                state.setEventTime(tEvent);\n+                occurringEvents.add(state);\n+            }\n+        }\n+    }\n \n-            while (!occuringEvents.isEmpty()) {\n+    private T searchNextEvent(final EventState es, final T t0, final T tEventMax) {\n+        T t = t0.add(minimalStep);\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+        while ((tEventMax.subtract(t)).getReal() >= 0) {\n+            es.stepAccepted(t, interpolator.getInterpolatedState().toRealArray());\n+            isLastStep = es.stop();\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n+            if (isLastStep) {\n+                // event occurred, accept the last processed state as part of the current step\n+                return es.getEventTime();\n+            }\n \n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+            integrator.integrate(interpolator, t.add(maxCheckInterval));\n+            t = interpolator.getCurrentState().getTime();\n+        }\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+        // we did not find any event within the remaining time\n+        return tEventMax;\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n+    }\n+\n+    private void interpolateAtBoundary() {\n+        if (interpolator.isForward()) {\n+            interpolator.setSoftPreviousTime(interpolator.getPreviousState().getTime());\n+            interpolator.setSoftCurrentTime(interpolator.getCurrentState().getTime());\n+        } else {\n+            interpolator.setSoftPreviousTime(interpolator.getCurrentState().getTime());\n+            interpolator.setSoftCurrentTime(interpolator.getPreviousState().getTime());\n+        }\n+    }\n+\n+    public interface StepHandler {\n+\n+        void handleStep(FieldStepInterpolator<T> interpolator, boolean isLast)\n+                        throws org.hipparchus.exception.MathRuntimeException;\n+\n+    }\n+\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}