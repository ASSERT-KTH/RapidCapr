{
    "patch": "    public int[] add(ReadablePartial partial, int fieldIndex, int[] values, int valueToAdd) {\n        // overridden as superclass algorithm can't handle\n        // 2004-02-29 + 48 months -> 2008-02-29 type dates\n        if (valueToAdd == 0) {\n            return values;\n        }\n            // month is largest field and being added to, such as month-day\n        if (DateTimeUtils.isContiguous(partial)) {\n            Chronology chrono = partial.getChronology();\n            DateTimeField field = partial.getField(fieldIndex);\n            // check if the field is month field because the dayOfMonth should be changed if and only if \n            // increasing months moves the year across 29-Feb.\n            if(field.getType() == DateTimeFieldType.monthOfYear()) {\n                long instant = 0L; \n                int dayOfMonth = 0;\n                // get the instant for the input partial, and the value of the day of the month\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    if (i == fieldIndex) {\n                        // validate if increasing months moves the year across 29-Feb\n                        int curMonth = values[i];\n                        LocalDate date = new LocalDate(curMonth<=0? values[i+1]-1 : values[i+1], curMonth<=0? 12 : curMonth, 1, chrono);\n                        dayOfMonth = date.dayOfMonth().getMinimumValue(); //minimum dayOfMonth\n                        //if the day of the month in the input is greater than the minimum day of the previous month then keep the dayOfMonth otherwise it should be change\n                        if(values[i+2] <= dayOfMonth)\n                            values[i+2] = dayOfMonth;\n                    }                       \n                    instant = partial.getFieldType(i).getField(chrono).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                LocalDate dateNew = new LocalDate(instant, chrono);\n                int getMonth = dateNew.getMonthOfYear();\n                //check if the month after adding the value is less or equal to the month in the input partial \n                //if true then make dayOfMonth equals to the getMaximumValue. Otherwise, it should be the minimum value.\n                dayOfMonth = (getMonth > values[fieldIndex]) ? dateNew.dayOfMonth().getMinimumValue() : dateNew.dayOfMonth().getMaximumValue();\n                values[fieldIndex] = getMonth;\n                values[fieldIndex+1] = dateNew.getYear();\n                values[fieldIndex+2] = dayOfMonth;\n                DateTimeField[] newFields = new DateTimeField[partial.size()];\n                // calculate fields up to dayOfMonth, keeping in mind leap years\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    newFields[i] = partial.getFieldType(i).getField(chrono);\n                    if (i == fieldIndex) {\n                        continue;\n                    }\n                    values[i] = newFields[i].get(instant);\n                }\n                return chrono.set(partial, fieldIndex, values, newFields);\n            } else {\n                long instant = 0L;\n                for (int i = 0, isize = partial.size(); i < isize; i++) {\n                    instant = partial.getFieldType(i).getField(chrono).set(instant, values[i]);\n                }\n                instant = add(instant, valueToAdd);\n                return chrono.get(partial, instant);\n            }\n        } else {\n            return super.add(partial, fieldIndex, values, valueToAdd);\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\nindex afca44e6..fb4a02f5 100644\n--- a/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n+++ b/src/main/java/org/joda/time/chrono/BasicMonthOfYearDateTimeField.java\n@@ -208,12 +208,53 @@ class BasicMonthOfYearDateTimeField extends ImpreciseDateTimeField {\n         }\n             // month is largest field and being added to, such as month-day\n         if (DateTimeUtils.isContiguous(partial)) {\n-            long instant = 0L;\n-            for (int i = 0, isize = partial.size(); i < isize; i++) {\n-                instant = partial.getFieldType(i).getField(iChronology).set(instant, values[i]);\n+            Chronology chrono = partial.getChronology();\n+            DateTimeField field = partial.getField(fieldIndex);\n+            // check if the field is month field because the dayOfMonth should be changed if and only if \n+            // increasing months moves the year across 29-Feb.\n+            if(field.getType() == DateTimeFieldType.monthOfYear()) {\n+                long instant = 0L; \n+                int dayOfMonth = 0;\n+                // get the instant for the input partial, and the value of the day of the month\n+                for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                    if (i == fieldIndex) {\n+                        // validate if increasing months moves the year across 29-Feb\n+                        int curMonth = values[i];\n+                        LocalDate date = new LocalDate(curMonth<=0? values[i+1]-1 : values[i+1], curMonth<=0? 12 : curMonth, 1, chrono);\n+                        dayOfMonth = date.dayOfMonth().getMinimumValue(); //minimum dayOfMonth\n+                        //if the day of the month in the input is greater than the minimum day of the previous month then keep the dayOfMonth otherwise it should be change\n+                        if(values[i+2] <= dayOfMonth)\n+                            values[i+2] = dayOfMonth;\n+                    }                       \n+                    instant = partial.getFieldType(i).getField(chrono).set(instant, values[i]);\n+                }\n+                instant = add(instant, valueToAdd);\n+                LocalDate dateNew = new LocalDate(instant, chrono);\n+                int getMonth = dateNew.getMonthOfYear();\n+                //check if the month after adding the value is less or equal to the month in the input partial \n+                //if true then make dayOfMonth equals to the getMaximumValue. Otherwise, it should be the minimum value.\n+                dayOfMonth = (getMonth > values[fieldIndex]) ? dateNew.dayOfMonth().getMinimumValue() : dateNew.dayOfMonth().getMaximumValue();\n+                values[fieldIndex] = getMonth;\n+                values[fieldIndex+1] = dateNew.getYear();\n+                values[fieldIndex+2] = dayOfMonth;\n+                DateTimeField[] newFields = new DateTimeField[partial.size()];\n+                // calculate fields up to dayOfMonth, keeping in mind leap years\n+                for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                    newFields[i] = partial.getFieldType(i).getField(chrono);\n+                    if (i == fieldIndex) {\n+                        continue;\n+                    }\n+                    values[i] = newFields[i].get(instant);\n+                }\n+                return chrono.set(partial, fieldIndex, values, newFields);\n+            } else {\n+                long instant = 0L;\n+                for (int i = 0, isize = partial.size(); i < isize; i++) {\n+                    instant = partial.getFieldType(i).getField(chrono).set(instant, values[i]);\n+                }\n+                instant = add(instant, valueToAdd);\n+                return chrono.get(partial, instant);\n             }\n-            instant = add(instant, valueToAdd);\n-            return iChronology.get(partial, instant);\n         } else {\n             return super.add(partial, fieldIndex, values, valueToAdd);\n         }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}