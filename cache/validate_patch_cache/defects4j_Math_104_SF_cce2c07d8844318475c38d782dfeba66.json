{
    "patch": "import org.apache.commons.math3.util.FastMath;\n\npublic class GammaFunction {\n\n    /**\n     * Computes the regularized gamma function using the continued fraction representation.\n     *\n     * @param a   the shape parameter\n     * @param x   the integration end point\n     * @param eps the desired accuracy (must be greater than or equal to 10^-15)\n     * @return the regularized gamma function P(a, x)\n     * @throws IllegalArgumentException if the desired accuracy is less than 10^-15\n     */\n    public static double regularizedGammaP(double a, double x, double eps) {\n        if (eps < 1e-15) {\n            throw new IllegalArgumentException(\"eps must be greater than or equal to 10^-15\");\n        }\n        double f = 1 / x;\n        double c = f;\n        double p = 1;\n        double q = 1 - a;\n        double g = q;\n        double prevSum = 1;\n        double sum = c;\n        while (FastMath.abs(sum - prevSum) > eps * FastMath.abs(prevSum)) {\n            prevSum = sum;\n            final double a1 = q * p + g * f;\n            final double a0 = p;\n            p = a1;\n            q = q * c + g * f;\n            g = f - c * g;\n            c = a0 / a1;\n            f = (x + a - 1) * f / a1;\n            sum = f * c;\n        }\n        return FastMath.exp(-x + a * FastMath.log(x) - logGamma(a)) * sum;\n    }\n\n    /**\n     * Computes the natural logarithm of the gamma function.\n     *\n     * @param x the argument\n     * @return the natural logarithm of the gamma function\n     * @throws IllegalArgumentException if x <= 0\n     */\n    public static double logGamma(double x) {\n        if (x <= 0.0) {\n            throw new IllegalArgumentException(\"x must be positive\");\n        }\n        double tmp = (x - 0.5) * FastMath.log(x + 4.5) - (x + 4.5);\n        double ser = 1.0 + 76.18009173 / x - 86.50532033 / (x + 1.0) + 24.01409822 / (x + 2.0)\n                - 1.231739516 / (x + 3.0) + 0.120858003e-2 / (x + 4.0) - 0.536382e-5 / (x + 5.0);\n        return tmp + FastMath.log(ser * FastMath.sqrt(2.0 * FastMath.PI));\n    }\n\n    /**\n     * Computes the regularized gamma function using the continued fraction representation with\n     * a default accuracy of 10e-15.\n     *\n     * @param a the shape parameter\n     * @param x the integration end point\n     * @return the regularized gamma function P(a, x)\n     */\n    public static double regularizedGammaP(double a, double x) {\n        return regularizedGammaP(a, x, 1e-15);\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..5856bfa5f 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,73 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.util.FastMath;\n+\n+public class GammaFunction {\n+\n+    /**\n+     * Computes the regularized gamma function using the continued fraction representation.\n+     *\n+     * @param a   the shape parameter\n+     * @param x   the integration end point\n+     * @param eps the desired accuracy (must be greater than or equal to 10^-15)\n+     * @return the regularized gamma function P(a, x)\n+     * @throws IllegalArgumentException if the desired accuracy is less than 10^-15\n+     */\n+    public static double regularizedGammaP(double a, double x, double eps) {\n+        if (eps < 1e-15) {\n+            throw new IllegalArgumentException(\"eps must be greater than or equal to 10^-15\");\n+        }\n+        double f = 1 / x;\n+        double c = f;\n+        double p = 1;\n+        double q = 1 - a;\n+        double g = q;\n+        double prevSum = 1;\n+        double sum = c;\n+        while (FastMath.abs(sum - prevSum) > eps * FastMath.abs(prevSum)) {\n+            prevSum = sum;\n+            final double a1 = q * p + g * f;\n+            final double a0 = p;\n+            p = a1;\n+            q = q * c + g * f;\n+            g = f - c * g;\n+            c = a0 / a1;\n+            f = (x + a - 1) * f / a1;\n+            sum = f * c;\n+        }\n+        return FastMath.exp(-x + a * FastMath.log(x) - logGamma(a)) * sum;\n+    }\n+\n+    /**\n+     * Computes the natural logarithm of the gamma function.\n+     *\n+     * @param x the argument\n+     * @return the natural logarithm of the gamma function\n+     * @throws IllegalArgumentException if x <= 0\n+     */\n+    public static double logGamma(double x) {\n+        if (x <= 0.0) {\n+            throw new IllegalArgumentException(\"x must be positive\");\n+        }\n+        double tmp = (x - 0.5) * FastMath.log(x + 4.5) - (x + 4.5);\n+        double ser = 1.0 + 76.18009173 / x - 86.50532033 / (x + 1.0) + 24.01409822 / (x + 2.0)\n+                - 1.231739516 / (x + 3.0) + 0.120858003e-2 / (x + 4.0) - 0.536382e-5 / (x + 5.0);\n+        return tmp + FastMath.log(ser * FastMath.sqrt(2.0 * FastMath.PI));\n+    }\n+\n+    /**\n+     * Computes the regularized gamma function using the continued fraction representation with\n+     * a default accuracy of 10e-15.\n+     *\n+     * @param a the shape parameter\n+     * @param x the integration end point\n+     * @return the regularized gamma function P(a, x)\n+     */\n+    public static double regularizedGammaP(double a, double x) {\n+        return regularizedGammaP(a, x, 1e-15);\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}