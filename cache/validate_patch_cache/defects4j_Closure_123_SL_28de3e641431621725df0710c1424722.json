{
    "patch": "protected void printInOperator(Expression node, Context context, int lhsPrec) {\n    InOperatorExpression inOperatorExpression = (InOperatorExpression) node;\n    Expression lhs = inOperatorExpression.getLhs();\n    Expression rhs = inOperatorExpression.getRhs();\n    if (context == Context.START_OF_EXPR) { // highest precedence\n        print(\"(\");\n    }\n    int newPrec = getPrecedence(node);\n    printSubExpr(lhs, newPrec, Context.START_OF_EXPR);\n    println(\" \" + TokenNameIN + \" \");\n    // Wrap the RHS in an array literal so that \"in\" works. We use NON_EMPTY as we don't want\n    // to print a trailing comma.\n    if (rhs instanceof ArrayLiteral) {\n        print(\"[\");\n        printSubExpr(rhs, 0, Context.START_OF_EXPR);\n        print(\"]\");\n    } else {\n        boolean isIn = false; /* <-- Adding this variable */\n        printSubExpr(rhs, newPrec, Context.OTHER);\n        if (!isIn) {\n            print(\"[\");\n            print(\"0\"); // Any value will do here, as Rhino itself ignores it.\n            print(\"]\");\n        }\n    }\n    if (context == Context.START_OF_EXPR) {\n        print(\")\");\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 54eb5cf8..6267f6c9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -104,7 +104,7 @@ class CodeGenerator {\n     add(n, Context.OTHER);\n   }\n \n-  void add(Node n, Context context) {\n+\n     if (!cc.continueProcessing()) {\n       return;\n     }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}