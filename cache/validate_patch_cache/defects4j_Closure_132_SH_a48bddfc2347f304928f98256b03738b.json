{
    "patch": "              // if LHS has side effects, don't proceed [since the optimization\n              // evaluates LHS before cond]\n              // NOTE - there are some circumstances where we can\n              // proceed even if there are side effects...\n              //\n              // If the LHS is a read-modify-write expression, then proceeding\n              // will alter the meaning of the code in a subtle way that is only observed\n              // when the returned value lives on after the conditional. Example:\n              //   var a = {}, b = {};\n              //   function f() { return a; }\n              //   function g() { return b; }\n              //   if (x) a.y |= f(); else a.y |= g();\n              // becomes:\n              //   var a = {}, b = {};\n              //   function f() { return a; }\n              //   function g() { return b; }\n              //   var $tmp;\n              //   if (x) $tmp = a.y |= f(); else $tmp = a.y |= g();\n              //   return $tmp\n              // Which is clearly not equivalent to the original.\n              Node maybeRmwChild = getRmwChild(lhs);\n              if (maybeRmwChild != null && !(maybeRmwChild.isGetElem() && !mayHaveSideEffects(maybeRmwChild.getFirstChild().getNext()))) {\n                return n;\n              } else {\n                Node assignName = thenOp.removeFirstChild();\n                Node thenExpr = thenOp.removeFirstChild();\n                Node elseExpr = elseOp.getLastChild();\n                elseOp.removeChild(elseExpr);\n\n                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                Node assign = new Node(thenOp.getType(), assignName, hookNode)\n                  .srcref(thenOp);\n                Node expr = NodeUtil.newExpr(assign);\n                parent.replaceChild(n, expr);\n                reportCodeChange();\n\n                return expr;\n              }\n            }\n          }\n      }\n      // if(x)foo();else bar(); -> x?foo():bar()\n      n.removeChild(cond);\n      thenOp.detachFromParent();\n      elseOp.detachFromParent();\n      Node expr = IR.exprResult(\n          IR.hook(cond, thenOp, elseOp).srcref(n));\n      parent.replaceChild(n, expr);\n      reportCodeChange();\n      return expr;\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..9fce62cb 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,57 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              // if LHS has side effects, don't proceed [since the optimization\n+              // evaluates LHS before cond]\n+              // NOTE - there are some circumstances where we can\n+              // proceed even if there are side effects...\n+              //\n+              // If the LHS is a read-modify-write expression, then proceeding\n+              // will alter the meaning of the code in a subtle way that is only observed\n+              // when the returned value lives on after the conditional. Example:\n+              //   var a = {}, b = {};\n+              //   function f() { return a; }\n+              //   function g() { return b; }\n+              //   if (x) a.y |= f(); else a.y |= g();\n+              // becomes:\n+              //   var a = {}, b = {};\n+              //   function f() { return a; }\n+              //   function g() { return b; }\n+              //   var $tmp;\n+              //   if (x) $tmp = a.y |= f(); else $tmp = a.y |= g();\n+              //   return $tmp\n+              // Which is clearly not equivalent to the original.\n+              Node maybeRmwChild = getRmwChild(lhs);\n+              if (maybeRmwChild != null && !(maybeRmwChild.isGetElem() && !mayHaveSideEffects(maybeRmwChild.getFirstChild().getNext()))) {\n+                return n;\n+              } else {\n+                Node assignName = thenOp.removeFirstChild();\n+                Node thenExpr = thenOp.removeFirstChild();\n+                Node elseExpr = elseOp.getLastChild();\n+                elseOp.removeChild(elseExpr);\n+\n+                Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                Node assign = new Node(thenOp.getType(), assignName, hookNode)\n+                  .srcref(thenOp);\n+                Node expr = NodeUtil.newExpr(assign);\n+                parent.replaceChild(n, expr);\n+                reportCodeChange();\n+\n+                return expr;\n+              }\n+            }\n+          }\n+      }\n+      // if(x)foo();else bar(); -> x?foo():bar()\n+      n.removeChild(cond);\n+      thenOp.detachFromParent();\n+      elseOp.detachFromParent();\n+      Node expr = IR.exprResult(\n+          IR.hook(cond, thenOp, elseOp).srcref(n));\n+      parent.replaceChild(n, expr);\n+      reportCodeChange();\n+      return expr;\n+    }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}