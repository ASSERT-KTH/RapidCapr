{
    "patch": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n\n    while (true) {\n\n        incrementIterationsCounter();\n\n        // save the original vertex\n        final RealPointValuePair[] original = simplex;\n        final RealPointValuePair best = original[0];\n\n        // perform a reflection step\n        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n        if (comparator.compare(reflected, best) < 0) {\n\n            // compute the expanded simplex\n            final RealPointValuePair[] reflectedSimplex = simplex;\n            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n            if (comparator.compare(reflected, expanded) <= 0) {\n                // accept the reflected simplex\n                simplex = reflectedSimplex;\n            } else {\n                // accept the expanded simplex\n                simplex = expandedSimplex(expanded, original, comparator);\n            }\n            // exit the loop\n            return;\n\n        } else {\n\n            // compute the contracted simplex\n            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n            if (comparator.compare(contracted, best) < 0) {\n                // accept the contracted simplex\n                simplex = contractedSimplex(contracted, original, comparator);\n                // check convergence\n                final double range = simplex[simplex.length - 1].getValue() - simplex[0].getValue();\n                final double simplexSpread = computeSimplexSpread(simplex);\n                final boolean converged = convergenceChecker.converged(getIterations(),\n                        best, simplex[0], range, simplexSpread);\n                if (converged) {\n                    return;\n                }\n            } else {\n                // if none of the above conditions are met, perform a shrink\n                simplex = shrinkSimplex(original, comparator);\n            }\n\n        }\n\n    }\n\n}\n\n/**\n * Computes a new simplex by shrinking the original simplex around the best point.\n *\n * @param original The original simplex.\n * @param comparator The comparator used to compare the values associated with each point in the simplex.\n * @return The new simplex.\n */\nprivate RealPointValuePair[] shrinkSimplex(final RealPointValuePair[] original,\n                                            final Comparator<RealPointValuePair> comparator) {\n    final double[] xSmallest = original[0].getPoint();\n    final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n    simplex[0] = original[0];\n    for (int i = 1; i < original.length; i++) {\n        final double[] xOriginal = original[i].getPoint();\n        final double[] x = new double[xOriginal.length];\n        for (int j = 0; j < x.length; ++j) {\n            x[j] = xSmallest[j] + sigma * (xOriginal[j] - xSmallest[j]);\n        }\n        final RealPointValuePair newValue = new RealPointValuePair(x,\n                Double.NaN, false);\n        simplex[i] = newValue;\n    }\n    return simplex;\n}\n\n/**\n * Computes a new simplex by expanding the original simplex around the reflection point.\n *\n * @param reflected The reflection point.\n * @param original The original simplex.\n * @param comparator The comparator used to compare the values associated with each point in the simplex.\n * @return The new simplex.\n */\nprivate RealPointValuePair[] expandedSimplex(final RealPointValuePair reflected,\n                                              final RealPointValuePair[] original,\n                                              final Comparator<RealPointValuePair> comparator) {\n    final double[] xSmallest = original[0].getPoint();\n    final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n    simplex[0] = original[0];\n    final double[] xReflection = reflected.getPoint();\n    for (int i = 1; i < original.length; i++) {\n        final double[] xOriginal = original[i].getPoint();\n        final double[] x = new double[xOriginal.length];\n        for (int j = 0; j < x.length; ++j) {\n            x[j] = gamma * (xReflection[j] - xSmallest[j]) + xSmallest[j];\n        }\n        simplex[i] = new RealPointValuePair(x, Double.NaN, false);\n    }\n    return simplex;\n}\n\n/**\n * Computes a new simplex by contracting the original simplex around the best point.\n *\n * @param contracted The contracted point around which to create the new simplex.\n * @param original The original simplex.\n * @param comparator The comparator used to compare the values associated with each point in the simplex.\n * @return The new simplex.\n */\nprivate RealPointValuePair[] contractedSimplex(final RealPointValuePair contracted,\n                                                final RealPointValuePair[] original,\n                                                final Comparator<RealPointValuePair> comparator) {\n    final double[] xSmallest = original[0].getPoint();\n    final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n    simplex[0] = original[0];\n    final double[] xContracted = contracted.getPoint();\n    for (int i = 1; i < original.length; ++i) {\n        final double[] xOriginal = original[i].getPoint();\n        final double[] x = new double[xOriginal.length];\n        for (int j = 0; j < x.length; ++j) {\n            x[j] = rho * (xContracted[j] - xSmallest[j]) + xSmallest[j];\n        }\n        simplex[i] = new RealPointValuePair(x, Double.NaN, false);\n    }\n    return simplex;\n}\n\n/**\n * Computes the spread of the current simplex (i.e., the maximum distance of all points\n * in the simplex to the best point).\n *\n * @param simplex The simplex to compute the spread of.\n * @return The spread of the simplex.\n */\nprivate double computeSimplexSpread(final RealPointValuePair[] simplex) {\n    double value = 0;\n    final double[] xSmallest = simplex[0].getPoint();\n    for (int i = 1; i < simplex.length; ++i) {\n        final double[] x = simplex[i].getPoint();\n        double sum = 0;\n        for (int j = 0; j < x.length; ++j) {\n            final double delta = x[j] - xSmallest[j];\n            sum += delta * delta;\n        }\n        value = Math.max(value, sum);\n    }\n    return Math.sqrt(value);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..1455a0701 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,46 +58,159 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n \n-        while (true) {\n+    while (true) {\n \n-            incrementIterationsCounter();\n+        incrementIterationsCounter();\n \n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n+        // save the original vertex\n+        final RealPointValuePair[] original = simplex;\n+        final RealPointValuePair best = original[0];\n \n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n-\n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n-\n-                return;\n+        // perform a reflection step\n+        final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n+        if (comparator.compare(reflected, best) < 0) {\n \n+            // compute the expanded simplex\n+            final RealPointValuePair[] reflectedSimplex = simplex;\n+            final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n+            if (comparator.compare(reflected, expanded) <= 0) {\n+                // accept the reflected simplex\n+                simplex = reflectedSimplex;\n+            } else {\n+                // accept the expanded simplex\n+                simplex = expandedSimplex(expanded, original, comparator);\n             }\n+            // exit the loop\n+            return;\n+\n+        } else {\n \n             // compute the contracted simplex\n             final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n             if (comparator.compare(contracted, best) < 0) {\n                 // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n+                simplex = contractedSimplex(contracted, original, comparator);\n+                // check convergence\n+                final double range = simplex[simplex.length - 1].getValue() - simplex[0].getValue();\n+                final double simplexSpread = computeSimplexSpread(simplex);\n+                final boolean converged = convergenceChecker.converged(getIterations(),\n+                        best, simplex[0], range, simplexSpread);\n+                if (converged) {\n+                    return;\n+                }\n+            } else {\n+                // if none of the above conditions are met, perform a shrink\n+                simplex = shrinkSimplex(original, comparator);\n             }\n \n         }\n \n     }\n \n+}\n+\n+/**\n+ * Computes a new simplex by shrinking the original simplex around the best point.\n+ *\n+ * @param original The original simplex.\n+ * @param comparator The comparator used to compare the values associated with each point in the simplex.\n+ * @return The new simplex.\n+ */\n+private RealPointValuePair[] shrinkSimplex(final RealPointValuePair[] original,\n+                                            final Comparator<RealPointValuePair> comparator) {\n+    final double[] xSmallest = original[0].getPoint();\n+    final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n+    simplex[0] = original[0];\n+    for (int i = 1; i < original.length; i++) {\n+        final double[] xOriginal = original[i].getPoint();\n+        final double[] x = new double[xOriginal.length];\n+        for (int j = 0; j < x.length; ++j) {\n+            x[j] = xSmallest[j] + sigma * (xOriginal[j] - xSmallest[j]);\n+        }\n+        final RealPointValuePair newValue = new RealPointValuePair(x,\n+                Double.NaN, false);\n+        simplex[i] = newValue;\n+    }\n+    return simplex;\n+}\n+\n+/**\n+ * Computes a new simplex by expanding the original simplex around the reflection point.\n+ *\n+ * @param reflected The reflection point.\n+ * @param original The original simplex.\n+ * @param comparator The comparator used to compare the values associated with each point in the simplex.\n+ * @return The new simplex.\n+ */\n+private RealPointValuePair[] expandedSimplex(final RealPointValuePair reflected,\n+                                              final RealPointValuePair[] original,\n+                                              final Comparator<RealPointValuePair> comparator) {\n+    final double[] xSmallest = original[0].getPoint();\n+    final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n+    simplex[0] = original[0];\n+    final double[] xReflection = reflected.getPoint();\n+    for (int i = 1; i < original.length; i++) {\n+        final double[] xOriginal = original[i].getPoint();\n+        final double[] x = new double[xOriginal.length];\n+        for (int j = 0; j < x.length; ++j) {\n+            x[j] = gamma * (xReflection[j] - xSmallest[j]) + xSmallest[j];\n+        }\n+        simplex[i] = new RealPointValuePair(x, Double.NaN, false);\n+    }\n+    return simplex;\n+}\n+\n+/**\n+ * Computes a new simplex by contracting the original simplex around the best point.\n+ *\n+ * @param contracted The contracted point around which to create the new simplex.\n+ * @param original The original simplex.\n+ * @param comparator The comparator used to compare the values associated with each point in the simplex.\n+ * @return The new simplex.\n+ */\n+private RealPointValuePair[] contractedSimplex(final RealPointValuePair contracted,\n+                                                final RealPointValuePair[] original,\n+                                                final Comparator<RealPointValuePair> comparator) {\n+    final double[] xSmallest = original[0].getPoint();\n+    final RealPointValuePair[] simplex = new RealPointValuePair[original.length];\n+    simplex[0] = original[0];\n+    final double[] xContracted = contracted.getPoint();\n+    for (int i = 1; i < original.length; ++i) {\n+        final double[] xOriginal = original[i].getPoint();\n+        final double[] x = new double[xOriginal.length];\n+        for (int j = 0; j < x.length; ++j) {\n+            x[j] = rho * (xContracted[j] - xSmallest[j]) + xSmallest[j];\n+        }\n+        simplex[i] = new RealPointValuePair(x, Double.NaN, false);\n+    }\n+    return simplex;\n+}\n+\n+/**\n+ * Computes the spread of the current simplex (i.e., the maximum distance of all points\n+ * in the simplex to the best point).\n+ *\n+ * @param simplex The simplex to compute the spread of.\n+ * @return The spread of the simplex.\n+ */\n+private double computeSimplexSpread(final RealPointValuePair[] simplex) {\n+    double value = 0;\n+    final double[] xSmallest = simplex[0].getPoint();\n+    for (int i = 1; i < simplex.length; ++i) {\n+        final double[] x = simplex[i].getPoint();\n+        double sum = 0;\n+        for (int j = 0; j < x.length; ++j) {\n+            final double delta = x[j] - xSmallest[j];\n+            sum += delta * delta;\n+        }\n+        value = Math.max(value, sum);\n+    }\n+    return Math.sqrt(value);\n+}\n+\n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)\n      * @param coeff linear coefficient",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}