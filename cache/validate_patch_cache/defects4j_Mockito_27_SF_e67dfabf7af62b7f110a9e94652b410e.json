{
    "patch": "import org.mockito.cglib.proxy.Enhancer;\nimport org.mockito.cglib.proxy.Factory;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\n\nimport java.lang.reflect.Method;\nimport java.util.ArrayList;\nimport java.util.List;\n\npublic class ResetMock {\n\n    List<InvocationReport> invocationReports = new ArrayList<>();\n\n    public <T> void resetMock(T mock) {\n        Factory factory = (Factory) mock;\n        MethodInterceptor currentInterceptor = factory.getCallback(0);\n        if (!(currentInterceptor instanceof MethodInterceptorFilter)) {\n            throw new IllegalStateException(\"Interceptor not found in mock object.\");\n        }\n\n        MethodInterceptorFilter currentFilter = (MethodInterceptorFilter) currentInterceptor;\n        MockHandlerInterface<T> oldMockHandler = currentFilter.getHandler();\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        MethodInvocationReportHandler reportHandler = new MethodInvocationReportHandler(invocationReports);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, reportHandler);\n        Enhancer.registerCallbacks(mock.getClass(), new MethodInterceptor[]{newFilter, Enhancer.DISABLED_CALLBACK});\n    }\n\n    public List<InvocationReport> getInvocationReports() {\n        return invocationReports;\n    }\n\n    private static class MethodInvocationReportHandler implements MethodInterceptor {\n\n        private final List<InvocationReport> invocationReports;\n\n        public MethodInvocationReportHandler(List<InvocationReport> invocationReports) {\n            this.invocationReports = invocationReports;\n        }\n\n        @Override\n        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n            InvocationReport invocationReport = new InvocationReport(method, args);\n            invocationReports.add(invocationReport);\n            Object result = proxy.invokeSuper(obj, args);\n            invocationReport.setResult(result);\n            return result;\n        }\n\n    }\n\n    private static class InvocationReport {\n\n        private final Method method;\n        private final Object[] arguments;\n        private Object result;\n\n        public InvocationReport(Method method, Object[] arguments) {\n            this.method = method;\n            this.arguments = arguments;\n        }\n\n        public Method getMethod() {\n            return method;\n        }\n\n        public Object[] getArguments() {\n            return arguments;\n        }\n\n        public Object getResult() {\n            return result;\n        }\n\n        public void setResult(Object result) {\n            this.result = result;\n        }\n\n    }\n\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..d5b82d24e 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,88 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.cglib.proxy.Enhancer;\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+\n+import java.lang.reflect.Method;\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+public class ResetMock {\n+\n+    List<InvocationReport> invocationReports = new ArrayList<>();\n+\n+    public <T> void resetMock(T mock) {\n+        Factory factory = (Factory) mock;\n+        MethodInterceptor currentInterceptor = factory.getCallback(0);\n+        if (!(currentInterceptor instanceof MethodInterceptorFilter)) {\n+            throw new IllegalStateException(\"Interceptor not found in mock object.\");\n+        }\n+\n+        MethodInterceptorFilter currentFilter = (MethodInterceptorFilter) currentInterceptor;\n+        MockHandlerInterface<T> oldMockHandler = currentFilter.getHandler();\n+        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n+        MethodInvocationReportHandler reportHandler = new MethodInvocationReportHandler(invocationReports);\n+        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, reportHandler);\n+        Enhancer.registerCallbacks(mock.getClass(), new MethodInterceptor[]{newFilter, Enhancer.DISABLED_CALLBACK});\n+    }\n+\n+    public List<InvocationReport> getInvocationReports() {\n+        return invocationReports;\n+    }\n+\n+    private static class MethodInvocationReportHandler implements MethodInterceptor {\n+\n+        private final List<InvocationReport> invocationReports;\n+\n+        public MethodInvocationReportHandler(List<InvocationReport> invocationReports) {\n+            this.invocationReports = invocationReports;\n+        }\n+\n+        @Override\n+        public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+            InvocationReport invocationReport = new InvocationReport(method, args);\n+            invocationReports.add(invocationReport);\n+            Object result = proxy.invokeSuper(obj, args);\n+            invocationReport.setResult(result);\n+            return result;\n+        }\n+\n+    }\n+\n+    private static class InvocationReport {\n+\n+        private final Method method;\n+        private final Object[] arguments;\n+        private Object result;\n+\n+        public InvocationReport(Method method, Object[] arguments) {\n+            this.method = method;\n+            this.arguments = arguments;\n+        }\n+\n+        public Method getMethod() {\n+            return method;\n+        }\n+\n+        public Object[] getArguments() {\n+            return arguments;\n+        }\n+\n+        public Object getResult() {\n+            return result;\n+        }\n+\n+        public void setResult(Object result) {\n+            this.result = result;\n+        }\n+\n+    }\n+\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}