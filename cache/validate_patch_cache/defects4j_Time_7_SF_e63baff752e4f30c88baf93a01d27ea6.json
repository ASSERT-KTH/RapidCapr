{
    "patch": "\n        // Get the default year from the instant's millis value\n        Chronology chrono = instant.getChronology();\n        int defaultYear = chrono.year().get(instant.getMillis());\n\n        // Use the provided position to extract the current field values from the text\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n                chrono, iLocale, iPivotYear, defaultYear, position);\n        parser.parseInto(bucket, text, position);\n\n        // Check if the year is a leap year\n        int year = bucket.computeDate(true).getYear();\n        boolean isLeapYear = chrono.isLeapYear(year);\n\n        // If the parsed month and day are invalid for a non-leap year, add 1 day to the instant\n        if (!isLeapYear && bucket.get(DateTimeFieldType.dayOfMonth()) > 28\n                && bucket.get(DateTimeFieldType.monthOfYear()) == 2) {\n            bucket.saveField(DateTimeFieldType.dayOfMonth(), 1);\n            bucket.add(DurationFieldType.days(), 1);\n        }\n\n        long instantMillis = bucket.computeMillis(false, text);\n        instant.setMillis(instantMillis);\n\n        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n            int parsedOffset = bucket.getOffsetInteger();\n            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n            chrono = chrono.withZone(parsedZone);\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        }\n\n        instant.setChronology(chrono);\n\n        if (iZone != null) {\n            instant.setZone(iZone);\n        }\n\n        return bucket.getParsePosition();",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a2..70bb101b 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -697,22 +697,30 @@ public class DateTimeFormatter {\n      * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    public int parseInto(ReadWritableInstant instant, String text, int position) {\n-        DateTimeParser parser = requireParser();\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"Instant must not be null\");\n-        }\n-        \n-        long instantMillis = instant.getMillis();\n+\n+        // Get the default year from the instant's millis value\n         Chronology chrono = instant.getChronology();\n-        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n-        chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n-        \n+        int defaultYear = chrono.year().get(instant.getMillis());\n+\n+        // Use the provided position to extract the current field values from the text\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n-        int newPos = parser.parseInto(bucket, text, position);\n-        instant.setMillis(bucket.computeMillis(false, text));\n+                chrono, iLocale, iPivotYear, defaultYear, position);\n+        parser.parseInto(bucket, text, position);\n+\n+        // Check if the year is a leap year\n+        int year = bucket.computeDate(true).getYear();\n+        boolean isLeapYear = chrono.isLeapYear(year);\n+\n+        // If the parsed month and day are invalid for a non-leap year, add 1 day to the instant\n+        if (!isLeapYear && bucket.get(DateTimeFieldType.dayOfMonth()) > 28\n+                && bucket.get(DateTimeFieldType.monthOfYear()) == 2) {\n+            bucket.saveField(DateTimeFieldType.dayOfMonth(), 1);\n+            bucket.add(DurationFieldType.days(), 1);\n+        }\n+\n+        long instantMillis = bucket.computeMillis(false, text);\n+        instant.setMillis(instantMillis);\n+\n         if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n             int parsedOffset = bucket.getOffsetInteger();\n             DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n@@ -720,12 +728,14 @@ public class DateTimeFormatter {\n         } else if (bucket.getZone() != null) {\n             chrono = chrono.withZone(bucket.getZone());\n         }\n+\n         instant.setChronology(chrono);\n+\n         if (iZone != null) {\n             instant.setZone(iZone);\n         }\n-        return newPos;\n-    }\n+\n+        return bucket.getParsePosition();\n \n     /**\n      * Parses a datetime from the given text, returning the number of",
    "result_reason": "error: <identifier> expected",
    "test_result": "ERROR"
}