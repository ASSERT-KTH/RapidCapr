{
    "patch": "              // y=x||y; can't be simplify to if(!x)y=1;, \n              // because x may have side effect\n              if ((!late && t.getJSType().isTruthy() ||\n                  f.getJSType().isFalsy()) &&\n                  !mayHaveSideEffects(cond)) {\n                if (mayHaveSideEffects(lhs)) {\n                  // if(x)y=1; else { foo(); y=1; }\n                  // should not become\n                  // y=x||1;{foo(); y=1;}\n                  return n;\n                }\n\n                if (mayHaveSideEffects(thenExpr)) {\n                  // if(x)y=1; else { foo(); y=1; }\n                  // should not become\n                  // y=x||1;{foo(); y=1;}\n                  return n;\n                }\n\n                if (mayHaveSideEffects(elseExpr)) {\n                  // if(x){foo();y=1; } else y=1;\n                  // should not become\n                  // y=(!x)&&1;{foo(); y=1;}\n                  return n;\n                }\n\n                n.removeChild(cond);\n                name.detachFromParent();\n                Node newBinOpNode = IR.assign(opToken, name, hookNode).srcref(n);\n                NodeUtil.markNewScopesChanged(newBinOpNode, compiler);\n                parent.replaceChild(n, newBinOpNode);\n                reportCodeChange();\n                return newBinOpNode;\n              }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..8020706e 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,40 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              // y=x||y; can't be simplify to if(!x)y=1;, \n+              // because x may have side effect\n+              if ((!late && t.getJSType().isTruthy() ||\n+                  f.getJSType().isFalsy()) &&\n+                  !mayHaveSideEffects(cond)) {\n+                if (mayHaveSideEffects(lhs)) {\n+                  // if(x)y=1; else { foo(); y=1; }\n+                  // should not become\n+                  // y=x||1;{foo(); y=1;}\n+                  return n;\n+                }\n+\n+                if (mayHaveSideEffects(thenExpr)) {\n+                  // if(x)y=1; else { foo(); y=1; }\n+                  // should not become\n+                  // y=x||1;{foo(); y=1;}\n+                  return n;\n+                }\n+\n+                if (mayHaveSideEffects(elseExpr)) {\n+                  // if(x){foo();y=1; } else y=1;\n+                  // should not become\n+                  // y=(!x)&&1;{foo(); y=1;}\n+                  return n;\n+                }\n+\n+                n.removeChild(cond);\n+                name.detachFromParent();\n+                Node newBinOpNode = IR.assign(opToken, name, hookNode).srcref(n);\n+                NodeUtil.markNewScopesChanged(newBinOpNode, compiler);\n+                parent.replaceChild(n, newBinOpNode);\n+                reportCodeChange();\n+                return newBinOpNode;\n+              }\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}