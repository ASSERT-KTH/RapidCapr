{
    "patch": "private Node tryMinimizeIf(Node n) {\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    /* If only the else branch exists, we can switch it to a then branch with a negated condition */\n    if (thenBranch == null) {\n        cond.detachFromParent();\n        Node notCond = IR.not(cond).srcref(cond);\n        Node newThen = elseBranch.detachFromParent();\n\n        return replaceWithOneConditionOrAssignment(n, parent, notCond, newThen, cond, elseBranch);\n    }\n\n    /* If both branches exist, we try to minimize the if/else statement */\n    if (elseBranch != null) {\n        /* If the two branches are identical, we can remove one of them and make a direct assignment or \n  \t\t* return statement depending on the node type.\n  \t\t*/\n        if (areNodesEqualForInlining(thenBranch, elseBranch)) {\n            \n            Node toReplaceNode;\n            if (n.getParent().isAssign()) {\n                toReplaceNode = NodeUtil.getEnclosingStatement(n);\n                //`if(a=b){}` -> `a=b;`\n                if (thenBranch.hasOneChild() && NodeUtil.isExpressionResult(thenBranch.getFirstChild()))\n                    return replaceWithAssignment(toReplaceNode, thenBranch.getFirstChild().detachFromParent(), n.getParent().detachFromParent());\n                //`if(a=b){return true;}` -> `a=b; return true;`\n                else if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild() && NodeUtil.isReturn(thenBranch.getFirstChild()))\n                    return replaceWithExpression(toReplaceNode, thenBranch.getFirstChild().removeFirstChild(), n.getParent().detachFromParent());\n                //`if(a=b){return true;}else{}` -> `a=b; return true;`\n                else if (elseBranch.isEmpty() && NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild() && NodeUtil.isReturn(thenBranch.getFirstChild()))\n                    return replaceWithExpression(toReplaceNode, thenBranch.getFirstChild().removeFirstChild(), n.getParent().detachFromParent());\n            }\n            //`if(a==1){return true;}else{return true;}` -> `return true;`\n            if (NodeUtil.isReturn(thenBranch) && NodeUtil.isReturn(elseBranch)) {\n                Node newReturn = thenBranch.removeFirstChild().detachFromParent();\n                n.getParent().replaceChild(n, newReturn);\n                reportCodeChange();\n                return newReturn;\n            }\n            /* Remove the else branch and keep the then branch */\n            n.removeChild(elseBranch);\n            Node newExpr = IR.exprResult(thenBranch.detachFromParent()).srcref(n);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        }\n\n        if (cond.isTrue()) {\n            /* Remove the condition and keep the then branch */\n            n.removeChild(cond);\n            Node newExpr = IR.exprResult(thenBranch.detachFromParent()).srcref(n);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        }\n\n        if (cond.isFalse()) {\n            /* Remove the condition and keep the else branch */\n            n.removeChild(cond);\n            Node newExpr = IR.exprResult(elseBranch.detachFromParent()).srcref(n);\n            parent.replaceChild(n, newExpr);\n            reportCodeChange();\n            return newExpr;\n        }\n    }\n\n    /* If the then branch is empty, then we remove the entire if statement */\n    if (thenBranch.isEmpty()) {\n        Node toReplaceNode = NodeUtil.getEnclosingStatement(n);\n        return replaceWithEmpty(toReplaceNode, n.getParent().detachFromParent());\n    }\n\n    /* If the condition is a not() expression, we can use the child as the new condition and swap the branches */\n    if (cond.isNot()) {\n        n.removeChild(cond);\n        Node notCond = cond.removeFirstChild();\n        thenBranch.detachFromParent();\n        elseBranch.detachFromParent();\n        n.addChildToFront(elseBranch);\n        n.addChildToBack(thenBranch);\n        parent.replaceChild(n, IR.ifNode(notCond, thenBranch, elseBranch).srcref(n));\n        reportCodeChange();\n        return parent;\n    }\n\n    if (elseBranch != null) {\n        /* If the then branch is a return statement and the else branch is a single, non return statement,  \n  \t\t* we can switch the branches and negate the condition. This can return early or keep going depending on the context\n  \t\t*/\n        if (NodeUtil.isReturn(thenBranch) && elseBranch.hasOneChild() && !NodeUtil.isReturn(elseBranch.getFirstChild())) {\n            cond.detachFromParent();\n            elseBranch.detachFromParent();\n            Node notCond = IR.not(cond).srcref(cond);\n            n.addChildToFront(IR.returnNode(elseBranch).srcref(elseBranch));\n            n.addChildToFront(cond);\n            parent.replaceChild(n, IR.ifNode(notCond, n.removeFirstChild(), elseBranch).srcref(n));\n            reportCodeChange();\n            return parent;\n        }\n        /* If the else branch is a return statement and the then branch is a single, non return statement, \n  \t\t* we can remove the else branch and negate the condition. This can return early or keep going depending on the context\n  \t\t*/\n        if (NodeUtil.isReturn(elseBranch) && thenBranch.hasOneChild() && !NodeUtil.isReturn(thenBranch.getFirstChild())) {\n            cond.detachFromParent();\n            elseBranch.removeChild(elseBranch.getFirstChild());\n            Node notCond = IR.not(cond).srcref(cond);\n            Node newExpr = IR.exprResult(thenBranch.detachFromParent()).srcref(n);\n            parent.replaceChild(n, IR.ifNode(notCond, elseBranch.detachFromParent(), newExpr).srcref(n));\n            reportCodeChange();\n            return parent;\n        }\n    }\n\n    /* If the then branch is a single expression statement and the else branch is empty, \n  \t* we can use a ternary operator outside of the if statement.\n  \t*/\n    if (!isStatementBlock(thenBranch) && (elseBranch == null || elseBranch.isEmpty())) {\n        if (n.getParent().isExprResult()) {\n            /* Keep the then branch with the current expression */\n            Node ternary = IR.condOp(cond, thenBranch.detachFromParent(), IR.name(\"undefined\").srcref(n)).srcref(n);\n            n.getParent().replaceChild(n, ternary);\n            reportCodeChange();\n            return ternary;\n        }\n        /* Create an expression at the location of the current if statement for the ternary operator */\n        Node newTernaryHolder = IR.exprResult(IR.condOp(cond, thenBranch.detachFromParent(), IR.name(\"undefined\").srcref(n)).srcref(n)).srcref(n);\n        /* Remove the if statement and replace it with the new expression */\n        parent.replaceChild(n, newTernaryHolder);\n        reportCodeChange();\n        return newTernaryHolder;\n    }\n\n    return n;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..86901a2c 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -633,239 +633,144 @@ class PeepholeSubstituteAlternateSyntax\n    * Returns the replacement for n or the original if no replacement was\n    * necessary.\n    */\n-  private Node tryMinimizeIf(Node n) {\n-\n+private Node tryMinimizeIf(Node n) {\n     Node parent = n.getParent();\n \n     Node cond = n.getFirstChild();\n-\n-    /* If the condition is a literal, we'll let other\n-     * optimizations try to remove useless code.\n-     */\n-    if (NodeUtil.isLiteralValue(cond, true)) {\n-      return n;\n-    }\n-\n     Node thenBranch = cond.getNext();\n     Node elseBranch = thenBranch.getNext();\n \n-    if (elseBranch == null) {\n-      if (isFoldableExpressBlock(thenBranch)) {\n-        Node expr = getBlockExpression(thenBranch);\n-        if (!late && isPropertyAssignmentInExpression(expr)) {\n-          // Keep opportunities for CollapseProperties such as\n-          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n-          // until CollapseProperties has been run.\n-          return n;\n-        }\n-\n-        if (cond.isNot()) {\n-          // if(!x)bar(); -> x||bar();\n-          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n-              isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                  OR_PRECEDENCE)) {\n-            // It's not okay to add two sets of parentheses.\n-            return n;\n-          }\n+    /* If only the else branch exists, we can switch it to a then branch with a negated condition */\n+    if (thenBranch == null) {\n+        cond.detachFromParent();\n+        Node notCond = IR.not(cond).srcref(cond);\n+        Node newThen = elseBranch.detachFromParent();\n \n-          Node or = IR.or(\n-              cond.removeFirstChild(),\n-              expr.removeFirstChild()).srcref(n);\n-          Node newExpr = NodeUtil.newExpr(or);\n-          parent.replaceChild(n, newExpr);\n-          reportCodeChange();\n+        return replaceWithOneConditionOrAssignment(n, parent, notCond, newThen, cond, elseBranch);\n+    }\n \n-          return newExpr;\n+    /* If both branches exist, we try to minimize the if/else statement */\n+    if (elseBranch != null) {\n+        /* If the two branches are identical, we can remove one of them and make a direct assignment or \n+  \t\t* return statement depending on the node type.\n+  \t\t*/\n+        if (areNodesEqualForInlining(thenBranch, elseBranch)) {\n+            \n+            Node toReplaceNode;\n+            if (n.getParent().isAssign()) {\n+                toReplaceNode = NodeUtil.getEnclosingStatement(n);\n+                //`if(a=b){}` -> `a=b;`\n+                if (thenBranch.hasOneChild() && NodeUtil.isExpressionResult(thenBranch.getFirstChild()))\n+                    return replaceWithAssignment(toReplaceNode, thenBranch.getFirstChild().detachFromParent(), n.getParent().detachFromParent());\n+                //`if(a=b){return true;}` -> `a=b; return true;`\n+                else if (NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild() && NodeUtil.isReturn(thenBranch.getFirstChild()))\n+                    return replaceWithExpression(toReplaceNode, thenBranch.getFirstChild().removeFirstChild(), n.getParent().detachFromParent());\n+                //`if(a=b){return true;}else{}` -> `a=b; return true;`\n+                else if (elseBranch.isEmpty() && NodeUtil.isStatementBlock(thenBranch) && thenBranch.hasOneChild() && NodeUtil.isReturn(thenBranch.getFirstChild()))\n+                    return replaceWithExpression(toReplaceNode, thenBranch.getFirstChild().removeFirstChild(), n.getParent().detachFromParent());\n+            }\n+            //`if(a==1){return true;}else{return true;}` -> `return true;`\n+            if (NodeUtil.isReturn(thenBranch) && NodeUtil.isReturn(elseBranch)) {\n+                Node newReturn = thenBranch.removeFirstChild().detachFromParent();\n+                n.getParent().replaceChild(n, newReturn);\n+                reportCodeChange();\n+                return newReturn;\n+            }\n+            /* Remove the else branch and keep the then branch */\n+            n.removeChild(elseBranch);\n+            Node newExpr = IR.exprResult(thenBranch.detachFromParent()).srcref(n);\n+            parent.replaceChild(n, newExpr);\n+            reportCodeChange();\n+            return newExpr;\n         }\n \n-        // if(x)foo(); -> x&&foo();\n-        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-            isLowerPrecedenceInExpression(expr.getFirstChild(),\n-                AND_PRECEDENCE)) {\n-          // One additional set of parentheses is worth the change even if\n-          // there is no immediate code size win. However, two extra pair of\n-          // {}, we would have to think twice. (unless we know for sure the\n-          // we can further optimize its parent.\n-          return n;\n+        if (cond.isTrue()) {\n+            /* Remove the condition and keep the then branch */\n+            n.removeChild(cond);\n+            Node newExpr = IR.exprResult(thenBranch.detachFromParent()).srcref(n);\n+            parent.replaceChild(n, newExpr);\n+            reportCodeChange();\n+            return newExpr;\n         }\n \n-        n.removeChild(cond);\n-        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n-        Node newExpr = NodeUtil.newExpr(and);\n-        parent.replaceChild(n, newExpr);\n-        reportCodeChange();\n-\n-        return newExpr;\n-      } else {\n-\n-        // Try to combine two IF-ELSE\n-        if (NodeUtil.isStatementBlock(thenBranch) &&\n-            thenBranch.hasOneChild()) {\n-          Node innerIf = thenBranch.getFirstChild();\n-\n-          if (innerIf.isIf()) {\n-            Node innerCond = innerIf.getFirstChild();\n-            Node innerThenBranch = innerCond.getNext();\n-            Node innerElseBranch = innerThenBranch.getNext();\n-\n-            if (innerElseBranch == null &&\n-                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n-                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n-              n.detachChildren();\n-              n.addChildToBack(\n-                  IR.and(\n-                      cond,\n-                      innerCond.detachFromParent())\n-                      .srcref(cond));\n-              n.addChildrenToBack(innerThenBranch.detachFromParent());\n-              reportCodeChange();\n-              // Not worth trying to fold the current IF-ELSE into && because\n-              // the inner IF-ELSE wasn't able to be folded into && anyways.\n-              return n;\n-            }\n-          }\n+        if (cond.isFalse()) {\n+            /* Remove the condition and keep the else branch */\n+            n.removeChild(cond);\n+            Node newExpr = IR.exprResult(elseBranch.detachFromParent()).srcref(n);\n+            parent.replaceChild(n, newExpr);\n+            reportCodeChange();\n+            return newExpr;\n         }\n-      }\n-\n-      return n;\n     }\n \n-    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n-     * peephole optimization. This should probably get moved to another pass.\n-     */\n-    tryRemoveRepeatedStatements(n);\n-\n-    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n-    // An additional set of curly braces isn't worth it.\n-    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n-      n.replaceChild(cond, cond.removeFirstChild());\n-      n.removeChild(thenBranch);\n-      n.addChildToBack(thenBranch);\n-      reportCodeChange();\n-      return n;\n+    /* If the then branch is empty, then we remove the entire if statement */\n+    if (thenBranch.isEmpty()) {\n+        Node toReplaceNode = NodeUtil.getEnclosingStatement(n);\n+        return replaceWithEmpty(toReplaceNode, n.getParent().detachFromParent());\n     }\n \n-    // if(x)return 1;else return 2; -> return x?1:2;\n-    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n-      Node thenExpr = getBlockReturnExpression(thenBranch);\n-      Node elseExpr = getBlockReturnExpression(elseBranch);\n-      n.removeChild(cond);\n-      thenExpr.detachFromParent();\n-      elseExpr.detachFromParent();\n-\n-      // note - we ignore any cases with \"return;\", technically this\n-      // can be converted to \"return undefined;\" or some variant, but\n-      // that does not help code size.\n-      Node returnNode = IR.returnNode(\n-                            IR.hook(cond, thenExpr, elseExpr)\n-                                .srcref(n));\n-      parent.replaceChild(n, returnNode);\n-      reportCodeChange();\n-      return returnNode;\n+    /* If the condition is a not() expression, we can use the child as the new condition and swap the branches */\n+    if (cond.isNot()) {\n+        n.removeChild(cond);\n+        Node notCond = cond.removeFirstChild();\n+        thenBranch.detachFromParent();\n+        elseBranch.detachFromParent();\n+        n.addChildToFront(elseBranch);\n+        n.addChildToBack(thenBranch);\n+        parent.replaceChild(n, IR.ifNode(notCond, thenBranch, elseBranch).srcref(n));\n+        reportCodeChange();\n+        return parent;\n     }\n \n-    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n-    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n-\n-    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n-      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n-      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n-      if (thenOp.getType() == elseOp.getType()) {\n-        // if(x)a=1;else a=2; -> a=x?1:2;\n-        if (NodeUtil.isAssignmentOp(thenOp)) {\n-          Node lhs = thenOp.getFirstChild();\n-          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n+    if (elseBranch != null) {\n+        /* If the then branch is a return statement and the else branch is a single, non return statement,  \n+  \t\t* we can switch the branches and negate the condition. This can return early or keep going depending on the context\n+  \t\t*/\n+        if (NodeUtil.isReturn(thenBranch) && elseBranch.hasOneChild() && !NodeUtil.isReturn(elseBranch.getFirstChild())) {\n+            cond.detachFromParent();\n+            elseBranch.detachFromParent();\n+            Node notCond = IR.not(cond).srcref(cond);\n+            n.addChildToFront(IR.returnNode(elseBranch).srcref(elseBranch));\n+            n.addChildToFront(cond);\n+            parent.replaceChild(n, IR.ifNode(notCond, n.removeFirstChild(), elseBranch).srcref(n));\n             reportCodeChange();\n-\n-            return expr;\n-          }\n+            return parent;\n+        }\n+        /* If the else branch is a return statement and the then branch is a single, non return statement, \n+  \t\t* we can remove the else branch and negate the condition. This can return early or keep going depending on the context\n+  \t\t*/\n+        if (NodeUtil.isReturn(elseBranch) && thenBranch.hasOneChild() && !NodeUtil.isReturn(thenBranch.getFirstChild())) {\n+            cond.detachFromParent();\n+            elseBranch.removeChild(elseBranch.getFirstChild());\n+            Node notCond = IR.not(cond).srcref(cond);\n+            Node newExpr = IR.exprResult(thenBranch.detachFromParent()).srcref(n);\n+            parent.replaceChild(n, IR.ifNode(notCond, elseBranch.detachFromParent(), newExpr).srcref(n));\n+            reportCodeChange();\n+            return parent;\n         }\n-      }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n-      reportCodeChange();\n-      return expr;\n     }\n \n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n-        return var;\n-      }\n-\n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n+    /* If the then branch is a single expression statement and the else branch is empty, \n+  \t* we can use a ternary operator outside of the if statement.\n+  \t*/\n+    if (!isStatementBlock(thenBranch) && (elseBranch == null || elseBranch.isEmpty())) {\n+        if (n.getParent().isExprResult()) {\n+            /* Keep the then branch with the current expression */\n+            Node ternary = IR.condOp(cond, thenBranch.detachFromParent(), IR.name(\"undefined\").srcref(n)).srcref(n);\n+            n.getParent().replaceChild(n, ternary);\n+            reportCodeChange();\n+            return ternary;\n+        }\n+        /* Create an expression at the location of the current if statement for the ternary operator */\n+        Node newTernaryHolder = IR.exprResult(IR.condOp(cond, thenBranch.detachFromParent(), IR.name(\"undefined\").srcref(n)).srcref(n)).srcref(n);\n+        /* Remove the if statement and replace it with the new expression */\n+        parent.replaceChild(n, newTernaryHolder);\n         reportCodeChange();\n-\n-        return var;\n-      }\n+        return newTernaryHolder;\n     }\n \n     return n;\n-  }\n+}\n \n   /**\n    * Try to remove duplicate statements from IF blocks. For example:",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}