{
    "patch": "private boolean isFoldableExpressBlock(Node n) {\n  if (n == null || !n.hasChildren()) {\n    // Empty node or leaf node\n    return false;\n  }\n  if (n.isExprResult()) {\n    // ExprResult may be foldable if its only child is a foldable expression\n    Node child = n.getFirstChild();\n    return child != null && isFoldableExpression(child) && child.getNext() == null;\n  }\n  if (n.isBlock()) {\n    // Block may be foldable if it has only one foldable child expression\n    Node child = n.getFirstChild();\n    if (child != null && !child.isBlock()) {\n      return isFoldableExpression(child) && child.getNext() == null;\n    }\n  }\n  if (n.isFunction()) {\n    // A function may be foldable if it has only one block child, which itself is foldable\n    Node block = n.getLastChild();\n    return block != null && isFoldableExpressBlock(block);\n  }\n  if (n.isIf()) {\n    // If statement may be foldable if its condition and consequent expressions are both foldable\n    Node condition = n.getFirstChild();\n    Node consequent = condition.getNext();\n    return isFoldableExpression(condition) && isFoldableExpressBlock(consequent);\n  }\n  if (n.isHook()) {\n    // Conditional expressions may be foldable if all sub-expressions are foldable\n    Node first = n.getFirstChild();\n    Node second = first.getNext();\n    Node third = second.getNext();\n    return isFoldableExpression(first) && isFoldableExpression(second) && isFoldableExpression(third);\n  }\n  if (n.isComma()) {\n    // Comma expressions may be foldable if all sub-expressions are foldable\n    for (Node child : n.children()) {\n      if (!isFoldableExpression(child)) {\n        return false;\n      }\n    }\n    return true;\n  }\n  if (n.isOr() || n.isAnd()) {\n    // Binary boolean expressions may be foldable if both operands are foldable\n    Node left = n.getFirstChild();\n    Node right = left.getNext();\n    return isFoldableExpression(left) && isFoldableExpression(right);\n  }\n  if (n.isAssign() || n.isAdd() || n.isSub() || n.isMul() || n.isDiv() || n.isMod() ||\n      n.isShl() || n.isShr() || n.isUShr() || n.isBitAnd() || n.isBitOr() || n.isBitXor()) {\n    // Binary arithmetic expressions may be foldable if both operands are foldable\n    Node left = n.getFirstChild();\n    Node right = left.getNext();\n    return isFoldableExpression(left) && isFoldableExpression(right);\n  }\n  if (n.isUnary()) {\n    // Unary expressions may be foldable if their only child is foldable\n    Node child = n.getFirstChild();\n    return child != null && isFoldableExpression(child) && child.getNext() == null;\n  }\n  // No folding possible\n  return false;\n}\n\nprivate boolean isFoldableExpression(Node n) {\n  return n != null && (NodeUtil.isExpressionNode(n) || NodeUtil.isFunctionDeclaration(n) ||\n                       NodeUtil.isTypeDeclaration(n) || NodeUtil.isExprAssign(n) ||\n                       NodeUtil.isCallOrNew(n) || NodeUtil.isIncOrDec(n) || n.isString() ||\n                       n.isNumber() || n.isTrue() || n.isFalse() || n.isNull());\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..9b50469c 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,26 +516,78 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+private boolean isFoldableExpressBlock(Node n) {\n+  if (n == null || !n.hasChildren()) {\n+    // Empty node or leaf node\n+    return false;\n+  }\n+  if (n.isExprResult()) {\n+    // ExprResult may be foldable if its only child is a foldable expression\n+    Node child = n.getFirstChild();\n+    return child != null && isFoldableExpression(child) && child.getNext() == null;\n+  }\n+  if (n.isBlock()) {\n+    // Block may be foldable if it has only one foldable child expression\n+    Node child = n.getFirstChild();\n+    if (child != null && !child.isBlock()) {\n+      return isFoldableExpression(child) && child.getNext() == null;\n+    }\n+  }\n+  if (n.isFunction()) {\n+    // A function may be foldable if it has only one block child, which itself is foldable\n+    Node block = n.getLastChild();\n+    return block != null && isFoldableExpressBlock(block);\n+  }\n+  if (n.isIf()) {\n+    // If statement may be foldable if its condition and consequent expressions are both foldable\n+    Node condition = n.getFirstChild();\n+    Node consequent = condition.getNext();\n+    return isFoldableExpression(condition) && isFoldableExpressBlock(consequent);\n+  }\n+  if (n.isHook()) {\n+    // Conditional expressions may be foldable if all sub-expressions are foldable\n+    Node first = n.getFirstChild();\n+    Node second = first.getNext();\n+    Node third = second.getNext();\n+    return isFoldableExpression(first) && isFoldableExpression(second) && isFoldableExpression(third);\n+  }\n+  if (n.isComma()) {\n+    // Comma expressions may be foldable if all sub-expressions are foldable\n+    for (Node child : n.children()) {\n+      if (!isFoldableExpression(child)) {\n+        return false;\n       }\n     }\n-\n-    return false;\n+    return true;\n+  }\n+  if (n.isOr() || n.isAnd()) {\n+    // Binary boolean expressions may be foldable if both operands are foldable\n+    Node left = n.getFirstChild();\n+    Node right = left.getNext();\n+    return isFoldableExpression(left) && isFoldableExpression(right);\n+  }\n+  if (n.isAssign() || n.isAdd() || n.isSub() || n.isMul() || n.isDiv() || n.isMod() ||\n+      n.isShl() || n.isShr() || n.isUShr() || n.isBitAnd() || n.isBitOr() || n.isBitXor()) {\n+    // Binary arithmetic expressions may be foldable if both operands are foldable\n+    Node left = n.getFirstChild();\n+    Node right = left.getNext();\n+    return isFoldableExpression(left) && isFoldableExpression(right);\n   }\n+  if (n.isUnary()) {\n+    // Unary expressions may be foldable if their only child is foldable\n+    Node child = n.getFirstChild();\n+    return child != null && isFoldableExpression(child) && child.getNext() == null;\n+  }\n+  // No folding possible\n+  return false;\n+}\n+\n+private boolean isFoldableExpression(Node n) {\n+  return n != null && (NodeUtil.isExpressionNode(n) || NodeUtil.isFunctionDeclaration(n) ||\n+                       NodeUtil.isTypeDeclaration(n) || NodeUtil.isExprAssign(n) ||\n+                       NodeUtil.isCallOrNew(n) || NodeUtil.isIncOrDec(n) || n.isString() ||\n+                       n.isNumber() || n.isTrue() || n.isFalse() || n.isNull());\n+}\n \n   /**\n    * @return The expression node.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}