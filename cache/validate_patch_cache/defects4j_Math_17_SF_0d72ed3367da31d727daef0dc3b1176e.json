{
    "patch": "public Dfp multiply(final int x) {\n    final DfpField field = getField();\n\n    if (isNaN()) {\n        return newInstance(this);\n    }\n    if (x == 0) {\n        return getZero();\n    }\n    if (x == 1) {\n        return newInstance(this);\n    }\n\n    final Dfp r = field.getZero().newInstance(getPrecision() + 1);\n    r[0] = 0;\n    r[1] = 0;\n    final int[] rexp = new int[] {0};\n    final byte[] rmant = new byte[r.getMantissaLength()];\n\n    final byte[] mlo = getMantissa();\n    final byte[] mhi = new byte[mlo.length + 1];\n    System.arraycopy(mlo, 0, mhi, 1, mlo.length);\n\n    int rh = 0;\n    for (int i = mhi.length - 1; i > 0; i--) {\n        final int prod = (mhi[i] & 0xff) * x + rh;\n        rh = prod >>> 8;\n        rmant[i - 1] = (byte) (prod - (rh << 8));\n    }\n\n    r.setMantissa(rmant);\n    rexp[0] = getExponent() + 3;\n\n    r.shiftLeft();\n    r.shiftLeft();\n    r.shiftLeft();\n\n    if ((r.getMantissa()[r.getMantissaLength() - 1] & 0x80) != 0) {\n        r.shiftRight();\n        rexp[0]++;\n\n        if (r.getExponent() >= getPrecision() + 1) {\n            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n            return newInstance(getZero());\n        }\n    }\n\n    rexp[0]--;\n\n    r.setExponent(r.getExponent() - 2);\n    final Dfp result = r.round(rexp[0]);\n    result.shiftRight();\n\n    return result;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..e913226a6 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1599,10 +1599,62 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param x multiplicand\n      * @return product of this and x\n      */\n-    public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n+public Dfp multiply(final int x) {\n+    final DfpField field = getField();\n+\n+    if (isNaN()) {\n+        return newInstance(this);\n+    }\n+    if (x == 0) {\n+        return getZero();\n+    }\n+    if (x == 1) {\n+        return newInstance(this);\n+    }\n+\n+    final Dfp r = field.getZero().newInstance(getPrecision() + 1);\n+    r[0] = 0;\n+    r[1] = 0;\n+    final int[] rexp = new int[] {0};\n+    final byte[] rmant = new byte[r.getMantissaLength()];\n+\n+    final byte[] mlo = getMantissa();\n+    final byte[] mhi = new byte[mlo.length + 1];\n+    System.arraycopy(mlo, 0, mhi, 1, mlo.length);\n+\n+    int rh = 0;\n+    for (int i = mhi.length - 1; i > 0; i--) {\n+        final int prod = (mhi[i] & 0xff) * x + rh;\n+        rh = prod >>> 8;\n+        rmant[i - 1] = (byte) (prod - (rh << 8));\n+    }\n+\n+    r.setMantissa(rmant);\n+    rexp[0] = getExponent() + 3;\n+\n+    r.shiftLeft();\n+    r.shiftLeft();\n+    r.shiftLeft();\n+\n+    if ((r.getMantissa()[r.getMantissaLength() - 1] & 0x80) != 0) {\n+        r.shiftRight();\n+        rexp[0]++;\n+\n+        if (r.getExponent() >= getPrecision() + 1) {\n+            field.setIEEEFlagsBits(DfpField.FLAG_INEXACT);\n+            return newInstance(getZero());\n+        }\n     }\n \n+    rexp[0]--;\n+\n+    r.setExponent(r.getExponent() - 2);\n+    final Dfp result = r.round(rexp[0]);\n+    result.shiftRight();\n+\n+    return result;\n+}\n+\n     /** Multiply this by a single digit 0&lt;=x&lt;radix.\n      * There are speed advantages in this special case.\n      * @param x multiplicand",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}