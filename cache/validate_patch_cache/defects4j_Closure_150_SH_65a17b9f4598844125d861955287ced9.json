{
    "patch": "    attachLiteralTypes(n);\n    if (n.isFunction()) {\n      if (parent.isExprResult()) {\n        // Named function expression, named function, or anonymous function def.\n        if (n.getFirstChild().getToken() == Token.NAME) {\n          defineVar(n.getFirstChild(),\n              n.isFromExterns() ? scope.getGlobalScope() : scope);\n        } else if (parent.isVar()) {\n          defineDeclaredFunction(n, parent);\n        } else {\n          defineExpressionInScope(n, scope);\n        }\n      } else if (!parent.isBlock() ||\n          parent.isFunction() && NodeUtil.getFunctionBody(n) == parent) {\n        // Anonymous function expression, function expression or function def.\n        // Don't treat a standalone function expression as a declaration.\n        // Also don't treat a function expression in a block as a declaration\n        // so that it can be used as an rvalue following a var declaration.\n        defineExpressionInScope(n, scope);\n      }\n      return;\n    }\n\n    if (n.getType() == Token.CATCH) {\n      defineCatch(n, parent);\n      return;\n    }\n\n    if (n.isVar()) {\n      defineVar(n, parent);\n      return;\n    }\n\n    if (n.isClass()) {\n      defineClass(n, scope);\n      return;\n    }\n\n    if (n.isLet() || n.isConst()) {\n      defineLetConst(n, parent, scope);\n      return;\n    }\n\n    if (NodeUtil.isNameDeclaration(n) && parent.isFor()) {\n      defineVar(n, scope);\n      return;\n    }\n\n    // Simple and compound assignmnts need to be treated as writes even if the\n    // variable is not defined, because they can implicitly define the\n    // variable.\n    if (n.isAssign()) {\n      defineLhs(n.getFirstChild(), parent, scope);\n      return;\n    }\n\n    // Handle object destructuring assignments.\n    if (n.isStringKey() && n.hasChildren()) {\n      defineLhs(n.getFirstChild(), parent, scope);\n      return;\n    } else if (n.isArrayPattern() || n.isObjectPattern()) {\n      Node c = n.getFirstChild();\n      while (c != null) {\n        defineLhs(c, parent, scope);\n        c = c.getNext();\n      }\n      return;\n    }\n\n    int assignOpType = NodeUtil.getAssignmentOpType(n);\n    if (assignOpType != -1) {\n      defineLhs(n.getFirstChild(), parent, scope);\n      return;\n    }\n\n    // Handle other left hand sides, such as properties of variables treated\n    // as namespaces.\n    if (NodeUtil.isLhsByDestructuring(n)) {\n      return;\n    }\n    defineLhs(n, parent, scope);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..c9437979 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1448,21 +1448,87 @@ final class TypedScopeCreator implements ScopeCreator {\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n+    attachLiteralTypes(n);\n+    if (n.isFunction()) {\n+      if (parent.isExprResult()) {\n+        // Named function expression, named function, or anonymous function def.\n+        if (n.getFirstChild().getToken() == Token.NAME) {\n+          defineVar(n.getFirstChild(),\n+              n.isFromExterns() ? scope.getGlobalScope() : scope);\n+        } else if (parent.isVar()) {\n           defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n+        } else {\n+          defineExpressionInScope(n, scope);\n+        }\n+      } else if (!parent.isBlock() ||\n+          parent.isFunction() && NodeUtil.getFunctionBody(n) == parent) {\n+        // Anonymous function expression, function expression or function def.\n+        // Don't treat a standalone function expression as a declaration.\n+        // Also don't treat a function expression in a block as a declaration\n+        // so that it can be used as an rvalue following a var declaration.\n+        defineExpressionInScope(n, scope);\n+      }\n+      return;\n+    }\n+\n+    if (n.getType() == Token.CATCH) {\n+      defineCatch(n, parent);\n+      return;\n+    }\n+\n+    if (n.isVar()) {\n+      defineVar(n, parent);\n+      return;\n+    }\n+\n+    if (n.isClass()) {\n+      defineClass(n, scope);\n+      return;\n+    }\n+\n+    if (n.isLet() || n.isConst()) {\n+      defineLetConst(n, parent, scope);\n+      return;\n+    }\n+\n+    if (NodeUtil.isNameDeclaration(n) && parent.isFor()) {\n+      defineVar(n, scope);\n+      return;\n+    }\n+\n+    // Simple and compound assignmnts need to be treated as writes even if the\n+    // variable is not defined, because they can implicitly define the\n+    // variable.\n+    if (n.isAssign()) {\n+      defineLhs(n.getFirstChild(), parent, scope);\n+      return;\n+    }\n+\n+    // Handle object destructuring assignments.\n+    if (n.isStringKey() && n.hasChildren()) {\n+      defineLhs(n.getFirstChild(), parent, scope);\n+      return;\n+    } else if (n.isArrayPattern() || n.isObjectPattern()) {\n+      Node c = n.getFirstChild();\n+      while (c != null) {\n+        defineLhs(c, parent, scope);\n+        c = c.getNext();\n       }\n+      return;\n+    }\n+\n+    int assignOpType = NodeUtil.getAssignmentOpType(n);\n+    if (assignOpType != -1) {\n+      defineLhs(n.getFirstChild(), parent, scope);\n+      return;\n+    }\n+\n+    // Handle other left hand sides, such as properties of variables treated\n+    // as namespaces.\n+    if (NodeUtil.isLhsByDestructuring(n)) {\n+      return;\n+    }\n+    defineLhs(n, parent, scope);\n     }\n \n     /** Handle bleeding functions and function parameters. */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}