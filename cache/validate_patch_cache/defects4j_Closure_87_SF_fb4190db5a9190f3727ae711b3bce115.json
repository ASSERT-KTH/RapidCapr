{
    "patch": "private boolean isFoldableExpressBlock(Node n) {\n  if (n.getType() == Token.BLOCK) {\n    if (n.hasOneChild()) {\n      Node maybeExpr = n.getFirstChild();\n      if (NodeUtil.isExpressionNode(maybeExpr)) {\n        return canFoldExpression(maybeExpr, false);\n      } else if (maybeExpr.getType() == Token.EXPR_RESULT) {\n        return canFoldExpression(maybeExpr.getFirstChild(), true);\n      }\n    }\n  }\n  return false;\n}\n\nprivate boolean canFoldExpression(Node expr, boolean inExprResult) {\n  if (expr.getType() == Token.FUNCTION && !expr.getFirstChild().getNext().hasChildren()) {\n    // function() { } can always be folded\n    return true;\n  } else if (!NodeUtil.isStatementBlock(expr) && !inExprResult && NodeUtil.isControlStructure(expr)) {\n    // The expression is a control structure and not within an expression result,\n    // so it cannot be folded\n    return false;\n  } else {\n    boolean canFold = true;\n    Node child;\n    for (child = expr.getFirstChild(); canFold && child != null; child = child.getNext()) {\n      switch (child.getType()) {\n        case Token.NAME:\n          // The expression contains a name, so it cannot be folded if it is an event handler\n          String name = child.getString();\n          if (!inExprResult && name.startsWith(\"on\")) {\n            canFold = false;\n          }\n          break;\n\n        case Token.GETPROP:\n          // The expression contains a property access, so it cannot be folded in certain cases\n          // For example, x.returnValue can be folded unless it is within an event handler\n          child = child.getFirstChild();\n          name = child.getString();\n          if (!inExprResult && name.startsWith(\"on\")) {\n            canFold = false;\n          }\n          break;\n\n        case Token.NOT:\n          // The expression contains a negation, so it cannot be folded if it is negating an event handler name\n          child = child.getFirstChild();\n          if (child.getType() == Token.NAME) {\n            name = child.getString();\n            if (!inExprResult && name.startsWith(\"on\")) {\n              canFold = false;\n            }\n          }\n          break;\n\n        case Token.HOOK:\n          // The expression contains a conditional expression, so it can be folded if both the true and false cases can be folded\n          Node trueExpr = child.getNext();\n          Node falseExpr = trueExpr.getNext();\n          canFold = canFoldExpression(trueExpr, false) && canFoldExpression(falseExpr, false);\n          break;\n\n        case Token.OR:\n        case Token.AND:\n        case Token.EQ:\n        case Token.NE:\n          // The expression is a logical or comparison expression, so it can be folded if both operands can be folded\n          Node left = child.getFirstChild();\n          Node right = left.getNext();\n          canFold = canFoldExpression(left, false) && canFoldExpression(right, false);\n          break;\n\n        case Token.COMMA:\n          // The expression is a comma expression, so it can be folded if its last operand can be folded\n          while (child.getNext() != null) {\n            child = child.getNext();\n          }\n          canFold = canFoldExpression(child, false);\n          break;\n\n        case Token.CALL:\n          // The expression is a function call, so it can be folded if the function is not an event handler\n          Node callee = child.getFirstChild();\n          if (callee.getType() == Token.NAME) {\n            String calleeName = callee.getString();\n            if (inExprResult || !calleeName.startsWith(\"on\")) {\n              canFold = canFoldExpression(callee, false);\n            } else {\n              canFold = false;\n            }\n          } else if (!inExprResult) {\n            canFold = canFoldExpression(callee, false);\n          }\n          break;\n\n        case Token.FUNCTION:\n          // The expression contains a function, so it can be folded if the function does not contain a return statement\n          Node functionBody = child.getLastChild();\n          if (functionBody.getLastChild() != null && functionBody.getLastChild().getType() == Token.RETURN) {\n            canFold = false;\n          } else {\n            canFold = canFoldExpression(functionBody, false);\n          }\n          break;\n\n        case Token.NUMBER:\n        case Token.STRING:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n          // The expression contains a literal, so it can be folded\n          break;\n\n        default:\n          // The expression contains an unsupported statement or a statement block, so it cannot be folded\n          if (!NodeUtil.isStatement(child) || NodeUtil.isStatementBlock(child)) {\n            canFold = false;\n          }\n          break;\n      }\n    }\n    return canFold;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..b0dc1831 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,26 +516,131 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+private boolean isFoldableExpressBlock(Node n) {\n+  if (n.getType() == Token.BLOCK) {\n+    if (n.hasOneChild()) {\n+      Node maybeExpr = n.getFirstChild();\n+      if (NodeUtil.isExpressionNode(maybeExpr)) {\n+        return canFoldExpression(maybeExpr, false);\n+      } else if (maybeExpr.getType() == Token.EXPR_RESULT) {\n+        return canFoldExpression(maybeExpr.getFirstChild(), true);\n       }\n     }\n+  }\n+  return false;\n+}\n \n+private boolean canFoldExpression(Node expr, boolean inExprResult) {\n+  if (expr.getType() == Token.FUNCTION && !expr.getFirstChild().getNext().hasChildren()) {\n+    // function() { } can always be folded\n+    return true;\n+  } else if (!NodeUtil.isStatementBlock(expr) && !inExprResult && NodeUtil.isControlStructure(expr)) {\n+    // The expression is a control structure and not within an expression result,\n+    // so it cannot be folded\n     return false;\n+  } else {\n+    boolean canFold = true;\n+    Node child;\n+    for (child = expr.getFirstChild(); canFold && child != null; child = child.getNext()) {\n+      switch (child.getType()) {\n+        case Token.NAME:\n+          // The expression contains a name, so it cannot be folded if it is an event handler\n+          String name = child.getString();\n+          if (!inExprResult && name.startsWith(\"on\")) {\n+            canFold = false;\n+          }\n+          break;\n+\n+        case Token.GETPROP:\n+          // The expression contains a property access, so it cannot be folded in certain cases\n+          // For example, x.returnValue can be folded unless it is within an event handler\n+          child = child.getFirstChild();\n+          name = child.getString();\n+          if (!inExprResult && name.startsWith(\"on\")) {\n+            canFold = false;\n+          }\n+          break;\n+\n+        case Token.NOT:\n+          // The expression contains a negation, so it cannot be folded if it is negating an event handler name\n+          child = child.getFirstChild();\n+          if (child.getType() == Token.NAME) {\n+            name = child.getString();\n+            if (!inExprResult && name.startsWith(\"on\")) {\n+              canFold = false;\n+            }\n+          }\n+          break;\n+\n+        case Token.HOOK:\n+          // The expression contains a conditional expression, so it can be folded if both the true and false cases can be folded\n+          Node trueExpr = child.getNext();\n+          Node falseExpr = trueExpr.getNext();\n+          canFold = canFoldExpression(trueExpr, false) && canFoldExpression(falseExpr, false);\n+          break;\n+\n+        case Token.OR:\n+        case Token.AND:\n+        case Token.EQ:\n+        case Token.NE:\n+          // The expression is a logical or comparison expression, so it can be folded if both operands can be folded\n+          Node left = child.getFirstChild();\n+          Node right = left.getNext();\n+          canFold = canFoldExpression(left, false) && canFoldExpression(right, false);\n+          break;\n+\n+        case Token.COMMA:\n+          // The expression is a comma expression, so it can be folded if its last operand can be folded\n+          while (child.getNext() != null) {\n+            child = child.getNext();\n+          }\n+          canFold = canFoldExpression(child, false);\n+          break;\n+\n+        case Token.CALL:\n+          // The expression is a function call, so it can be folded if the function is not an event handler\n+          Node callee = child.getFirstChild();\n+          if (callee.getType() == Token.NAME) {\n+            String calleeName = callee.getString();\n+            if (inExprResult || !calleeName.startsWith(\"on\")) {\n+              canFold = canFoldExpression(callee, false);\n+            } else {\n+              canFold = false;\n+            }\n+          } else if (!inExprResult) {\n+            canFold = canFoldExpression(callee, false);\n+          }\n+          break;\n+\n+        case Token.FUNCTION:\n+          // The expression contains a function, so it can be folded if the function does not contain a return statement\n+          Node functionBody = child.getLastChild();\n+          if (functionBody.getLastChild() != null && functionBody.getLastChild().getType() == Token.RETURN) {\n+            canFold = false;\n+          } else {\n+            canFold = canFoldExpression(functionBody, false);\n+          }\n+          break;\n+\n+        case Token.NUMBER:\n+        case Token.STRING:\n+        case Token.TRUE:\n+        case Token.FALSE:\n+        case Token.NULL:\n+          // The expression contains a literal, so it can be folded\n+          break;\n+\n+        default:\n+          // The expression contains an unsupported statement or a statement block, so it cannot be folded\n+          if (!NodeUtil.isStatement(child) || NodeUtil.isStatementBlock(child)) {\n+            canFold = false;\n+          }\n+          break;\n+      }\n+    }\n+    return canFold;\n   }\n+}\n \n   /**\n    * @return The expression node.",
    "result_reason": "junit.framework.AssertionFailedError:",
    "test_result": "FAIL"
}