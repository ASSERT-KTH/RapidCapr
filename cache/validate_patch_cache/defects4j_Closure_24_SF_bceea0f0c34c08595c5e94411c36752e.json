{
    "patch": "/**\n * Scans the nodes in the provided NodeTraversal and populates the 'aliases'\n * dictionary with every valid alias mapping encountered.\n *\n * <p>An alias is defined as a node that is a var with a direct child that is a qualified name.\n *\n * <p>A valid alias is determined by checking that the VAR node has a parent function, that the\n * child qualified name is not null, and that the child qualified name corresponds to a VARIABLE\n * definition in the scope (otherwise the alias isn't valid).\n *\n * <p>For every valid alias the map 'aliases' is updated with an entry whose key is the alias name\n * and whose value is the corresponding variable definition. This is used later to replace all\n * usages of the alias with the fully-qualified name.\n *\n * <p>If a node represents a local variable (i.e. it's not an alias or a parameter of the scope\n * function) then it is declared as a private variable with a call to the 'report' function.\n */\nprivate void findAliases(NodeTraversal t) {\n    Scope scope = t.getScope();\n\n    // First, get all the function params and add them to the visitedNodes set.\n    Set<Node> visitedNodes = new HashSet<>();\n    Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n    NodeUtil.visitPreOrder(\n            enclosingFunction.getFirstChild(), (NodeTraversal unused) -> true, visitedNodes);\n\n    // Iterate over each 'var' node and add to the aliases map if it is a real alias.\n    for (Var v : scope.getVarIterable()) {\n        Node n = v.getNode();\n        Node parent = n.getParent();\n        boolean isFunctionParamOrVar = parent.isParamList() || visitedNodes.contains(n);\n\n        if (parent.isVar() && parent.getParent().isFunction() && !isFunctionParamOrVar) {\n            // Var has a qualified name as child, add it to aliases.\n            Node qualifiedNameNode = n.getFirstChild();\n            if (qualifiedNameNode != null && qualifiedNameNode.isQualifiedName()) {\n                String aliasName = n.getString();\n                Var aliasVar = scope.getVar(aliasName);\n                if (aliasVar != null) {\n                    Node aliasVarNode = aliasVar.getNode();\n\n                    if (aliasVarNode != null\n                            && aliasVarNode.isName()\n                            && aliasVarNode.getFirstChild() == null) {\n                        // The alias corresponds to a valid, undefined variable.\n                        // Emit an error but don't add the alias as the variable is not usable.\n                        report(t, aliasVarNode, VarCheck.UNDEFINED_VAR_ERROR, aliasName);\n                    } else if (aliasVarNode != null\n                            && aliasVarNode.isFunction()\n                            && !nodeIsBleedingFunction(aliasVarNode)) {\n                        // Don't add the alias as it just refers to a bleeding function.\n                        // Bleeding functions are already checked by other means and don't need\n                        // aliases.\n                        // Don't complain about missing parameter warnings on bleeding functions\n                        // as they're not parameters in the traditional sense.\n                        // Parameters of the scope function are checked by other means as well,\n                        // don't need aliases.\n                    } else {\n                        aliases.put(aliasName, aliasVar);\n                        transformation.addAlias(\n                                aliasName, aliasVar.getInitialValue().getQualifiedName());\n                    }\n                }\n            } else {\n                // Not a valid alias, report it as private.\n                report(t, n, GOOG_SCOPE_PRIVATE_VAR, n.getString());\n            }\n        } else if (parent.isFunction() && !nodeIsBleedingFunction(n)) {\n            // Don't complain about missing parameter warnings on functions as they're not normal\n            // parameters and are already checked in makeFunction private.\n        } else if (parent.isBlock() || parent.isScript()) {\n            // Not a parameter or an alias, must be a private.\n            report(t, n, GOOG_SCOPE_PRIVATE_VAR, n.getString());\n        }\n    }\n}\n\n/**\n * Returns true if the given node is a FUNCTION node and is a bleeding function, otherwise\n * false.\n *\n * @param node the node to check.\n * @return true if the given node is a FUNCTION node and is a bleeding function, otherwise\n *     false.\n */\nprivate boolean nodeIsBleedingFunction(Node node) {\n    // Find the index of the last child of the last param in the function decl.\n    // Functions that define params beyond this point are marked as bleeding functions.\n    Node parameterList = NodeUtil.getFunctionParameters(node);\n    int lastParamIndex = parameterList.getChildCount() - 1;\n    if (node.getLastChild().isBlock()) {\n        // Check all the children of the block of the last child of the node that aren't the last\n        // child.\n        Iterable<Node> children = Iterables.limit(node.getLastChild().children(), lastParamIndex);\n        return Iterables.any(\n                children,\n                c ->\n                        (c.isFunction() || c.isClass())\n                                && nodeIsBleedingFunction(c)\n                                && NodeUtil.hasBlock(c));\n    }\n    return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex 30d29d0a..c4a1ead5 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -269,32 +269,109 @@ class ScopedAliases implements HotSwapCompilerPass {\n       hasErrors = true;\n     }\n \n-    private void findAliases(NodeTraversal t) {\n-      Scope scope = t.getScope();\n-      for (Var v : scope.getVarIterable()) {\n+/**\n+ * Scans the nodes in the provided NodeTraversal and populates the 'aliases'\n+ * dictionary with every valid alias mapping encountered.\n+ *\n+ * <p>An alias is defined as a node that is a var with a direct child that is a qualified name.\n+ *\n+ * <p>A valid alias is determined by checking that the VAR node has a parent function, that the\n+ * child qualified name is not null, and that the child qualified name corresponds to a VARIABLE\n+ * definition in the scope (otherwise the alias isn't valid).\n+ *\n+ * <p>For every valid alias the map 'aliases' is updated with an entry whose key is the alias name\n+ * and whose value is the corresponding variable definition. This is used later to replace all\n+ * usages of the alias with the fully-qualified name.\n+ *\n+ * <p>If a node represents a local variable (i.e. it's not an alias or a parameter of the scope\n+ * function) then it is declared as a private variable with a call to the 'report' function.\n+ */\n+private void findAliases(NodeTraversal t) {\n+    Scope scope = t.getScope();\n+\n+    // First, get all the function params and add them to the visitedNodes set.\n+    Set<Node> visitedNodes = new HashSet<>();\n+    Node enclosingFunction = NodeUtil.getEnclosingFunction(t.getScopeRoot());\n+    NodeUtil.visitPreOrder(\n+            enclosingFunction.getFirstChild(), (NodeTraversal unused) -> true, visitedNodes);\n+\n+    // Iterate over each 'var' node and add to the aliases map if it is a real alias.\n+    for (Var v : scope.getVarIterable()) {\n         Node n = v.getNode();\n-        int type = n.getType();\n         Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+        boolean isFunctionParamOrVar = parent.isParamList() || visitedNodes.contains(n);\n+\n+        if (parent.isVar() && parent.getParent().isFunction() && !isFunctionParamOrVar) {\n+            // Var has a qualified name as child, add it to aliases.\n+            Node qualifiedNameNode = n.getFirstChild();\n+            if (qualifiedNameNode != null && qualifiedNameNode.isQualifiedName()) {\n+                String aliasName = n.getString();\n+                Var aliasVar = scope.getVar(aliasName);\n+                if (aliasVar != null) {\n+                    Node aliasVarNode = aliasVar.getNode();\n+\n+                    if (aliasVarNode != null\n+                            && aliasVarNode.isName()\n+                            && aliasVarNode.getFirstChild() == null) {\n+                        // The alias corresponds to a valid, undefined variable.\n+                        // Emit an error but don't add the alias as the variable is not usable.\n+                        report(t, aliasVarNode, VarCheck.UNDEFINED_VAR_ERROR, aliasName);\n+                    } else if (aliasVarNode != null\n+                            && aliasVarNode.isFunction()\n+                            && !nodeIsBleedingFunction(aliasVarNode)) {\n+                        // Don't add the alias as it just refers to a bleeding function.\n+                        // Bleeding functions are already checked by other means and don't need\n+                        // aliases.\n+                        // Don't complain about missing parameter warnings on bleeding functions\n+                        // as they're not parameters in the traditional sense.\n+                        // Parameters of the scope function are checked by other means as well,\n+                        // don't need aliases.\n+                    } else {\n+                        aliases.put(aliasName, aliasVar);\n+                        transformation.addAlias(\n+                                aliasName, aliasVar.getInitialValue().getQualifiedName());\n+                    }\n+                }\n+            } else {\n+                // Not a valid alias, report it as private.\n+                report(t, n, GOOG_SCOPE_PRIVATE_VAR, n.getString());\n+            }\n+        } else if (parent.isFunction() && !nodeIsBleedingFunction(n)) {\n+            // Don't complain about missing parameter warnings on functions as they're not normal\n+            // parameters and are already checked in makeFunction private.\n+        } else if (parent.isBlock() || parent.isScript()) {\n+            // Not a parameter or an alias, must be a private.\n+            report(t, n, GOOG_SCOPE_PRIVATE_VAR, n.getString());\n         }\n-        }\n-      }\n     }\n+}\n+\n+/**\n+ * Returns true if the given node is a FUNCTION node and is a bleeding function, otherwise\n+ * false.\n+ *\n+ * @param node the node to check.\n+ * @return true if the given node is a FUNCTION node and is a bleeding function, otherwise\n+ *     false.\n+ */\n+private boolean nodeIsBleedingFunction(Node node) {\n+    // Find the index of the last child of the last param in the function decl.\n+    // Functions that define params beyond this point are marked as bleeding functions.\n+    Node parameterList = NodeUtil.getFunctionParameters(node);\n+    int lastParamIndex = parameterList.getChildCount() - 1;\n+    if (node.getLastChild().isBlock()) {\n+        // Check all the children of the block of the last child of the node that aren't the last\n+        // child.\n+        Iterable<Node> children = Iterables.limit(node.getLastChild().children(), lastParamIndex);\n+        return Iterables.any(\n+                children,\n+                c ->\n+                        (c.isFunction() || c.isClass())\n+                                && nodeIsBleedingFunction(c)\n+                                && NodeUtil.hasBlock(c));\n+    }\n+    return false;\n+}\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}