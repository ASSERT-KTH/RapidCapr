{
    "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n        case Token.NAME:\n            scope.inferSlotType(node.getString(), type);\n            break;\n\n        case Token.GETPROP:\n            String qualifiedName = node.getQualifiedName();\n            Preconditions.checkNotNull(qualifiedName);\n\n            JSType origType = node.getJSType();\n            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n            scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n            break;\n\n        case Token.THIS:            \n            JSType thisType = scope.getTypeOfThis();\n            if (thisType != null) {\n                scope.inferSlotType(\"this\", thisType);\n            } else {\n                // Infer type of \"this\" as OBJECT if the `this` keyword occurs outside of a function.\n                scope.inferSlotType(\"this\", getNativeObjectType());\n            }\n            break;\n\n        case Token.FUNCTION:\n            Node fnNameNode = node.getFirstChild();\n            if (fnNameNode.getType() == Token.NAME) {\n                String fnName = fnNameNode.getString();\n                if (!fnName.isEmpty() && !fnName.equals(\"undefined\")) {\n                    scope.inferSlotType(fnName, type);\n                }\n            }\n            break;\n\n        default:\n            throw new IllegalArgumentException(\"Invalid node type: \" + node.toStringTree());\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..11251aed 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,28 +154,45 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n     switch (node.getType()) {\n-      case Token.NAME:\n-        scope.inferSlotType(node.getString(), type);\n-        break;\n-\n-      case Token.GETPROP:\n-        String qualifiedName = node.getQualifiedName();\n-        Preconditions.checkNotNull(qualifiedName);\n-\n-        JSType origType = node.getJSType();\n-        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n-        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n-        break;\n-\n-        // \"this\" references aren't currently modeled in the CFG.\n-\n-      default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n+        case Token.NAME:\n+            scope.inferSlotType(node.getString(), type);\n+            break;\n+\n+        case Token.GETPROP:\n+            String qualifiedName = node.getQualifiedName();\n+            Preconditions.checkNotNull(qualifiedName);\n+\n+            JSType origType = node.getJSType();\n+            origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n+            scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n+            break;\n+\n+        case Token.THIS:            \n+            JSType thisType = scope.getTypeOfThis();\n+            if (thisType != null) {\n+                scope.inferSlotType(\"this\", thisType);\n+            } else {\n+                // Infer type of \"this\" as OBJECT if the `this` keyword occurs outside of a function.\n+                scope.inferSlotType(\"this\", getNativeObjectType());\n+            }\n+            break;\n+\n+        case Token.FUNCTION:\n+            Node fnNameNode = node.getFirstChild();\n+            if (fnNameNode.getType() == Token.NAME) {\n+                String fnName = fnNameNode.getString();\n+                if (!fnName.isEmpty() && !fnName.equals(\"undefined\")) {\n+                    scope.inferSlotType(fnName, type);\n+                }\n+            }\n+            break;\n+\n+        default:\n+            throw new IllegalArgumentException(\"Invalid node type: \" + node.toStringTree());\n     }\n-  }\n+}\n \n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}