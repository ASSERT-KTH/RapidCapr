{
    "patch": "          boolean selfReferential = false;\n          for (Reference t : refs) {\n            if (t.getNode() == childVal) {\n              selfReferential = true;\n              break;\n            }\n            Node refNode = t.getParent();\n            while (!NodeUtil.isStatementBlock(refNode)) {\n              if (refNode == childVal) {\n                // There's a self-referential assignment\n                selfReferential = true;\n                break;\n              }\n              refNode = refNode.getParent();\n            }\n            if (selfReferential) {\n              break;\n            }\n          }\n          if (selfReferential) {\n            return false;\n          }\n\n          validProperties.add(child.getString());\n\n          // Do not inline if any of the properties are\n          // have their definitions removed.\n          if (!child.isQuotedString()) {\n            String propName = child.getString();\n            if (NodeUtil.mayHaveSideEffects(childVal)) {\n              // This may not have been added to the graph yet if we are\n              // processing an object inside a conditional expression. In that\n              // case we don't know whether this property is safe to inline.\n              return false;\n            } else if (!childVal.getBooleanValue()\n                       && NodeUtil.referencesOwnProperty(val, propName)) {",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineObjectLiterals.java b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\nindex 2b85d84f..b452484a 100644\n--- a/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n+++ b/src/com/google/javascript/jscomp/InlineObjectLiterals.java\n@@ -173,6 +173,42 @@ class InlineObjectLiterals implements CompilerPass {\n \n           // Deleting a property has different semantics from deleting\n           // a variable, so deleted properties should not be inlined.\n+          boolean selfReferential = false;\n+          for (Reference t : refs) {\n+            if (t.getNode() == childVal) {\n+              selfReferential = true;\n+              break;\n+            }\n+            Node refNode = t.getParent();\n+            while (!NodeUtil.isStatementBlock(refNode)) {\n+              if (refNode == childVal) {\n+                // There's a self-referential assignment\n+                selfReferential = true;\n+                break;\n+              }\n+              refNode = refNode.getParent();\n+            }\n+            if (selfReferential) {\n+              break;\n+            }\n+          }\n+          if (selfReferential) {\n+            return false;\n+          }\n+\n+          validProperties.add(child.getString());\n+\n+          // Do not inline if any of the properties are\n+          // have their definitions removed.\n+          if (!child.isQuotedString()) {\n+            String propName = child.getString();\n+            if (NodeUtil.mayHaveSideEffects(childVal)) {\n+              // This may not have been added to the graph yet if we are\n+              // processing an object inside a conditional expression. In that\n+              // case we don't know whether this property is safe to inline.\n+              return false;\n+            } else if (!childVal.getBooleanValue()\n+                       && NodeUtil.referencesOwnProperty(val, propName)) {\n \n           // NOTE(nicksantos): This pass's object-splitting algorithm has\n           // a blind spot. It assumes that if a property isn't defined on an",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}