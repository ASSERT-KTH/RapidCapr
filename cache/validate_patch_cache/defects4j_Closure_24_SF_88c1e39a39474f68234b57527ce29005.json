{
    "patch": "private void findAliases(NodeTraversal t) {\n    Scope topScope = t.getScope();\n    Scope.VarIterable vars = topScope.getVarIterable(false);\n    for (Var v : vars) {\n      Node n = v.getNode();\n      Node parent = n.getParent();\n      if (isAliasDefinition(n)) {\n        String name = n.getString();\n        Var aliasVar = topScope.getVar(name);\n        Node initialValue = aliasVar.getInitialValue();\n        String qualifiedName = null;\n        if (initialValue != null && initialValue.isQualifiedName()) {\n          qualifiedName = initialValue.getQualifiedName();\n        }\n        aliases.put(name, aliasVar);\n        transformation.addAlias(name, qualifiedName);\n      } else if (isVariableDeclarationInForLoop(parent)) {\n        // In the case of variables declared in for-loop headers, they are\n        // considered aliases of the global scope. Ideally we would scope them\n        // to the for-loop block, but since we don't convert statement blocks\n        // to functions in this pass, we can't do that. This isn't a big deal\n        // since most of the code here will use the variable's short name and\n        // not the full alias.\n        // Assignment without declaration is not handled here, which means\n        // that the code can incorrectly mark such assignments as errors,\n        // so we deliberately leave it unhandled.\n        String name = n.getString();\n        Var aliasVar = topScope.getVar(name);\n        aliases.put(name, aliasVar);\n      } else {\n        // TODO: Support using locals for private variables.\n        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n      }\n    }\n  }\n\n  private static boolean isAliasDefinition(Node n) {\n    if (n.isName()) {\n      Node value = n.getFirstChild();\n      return value != null && value.isQualifiedName();\n    }\n    if (n.isDestructuringLhs()) {\n      for (Node child : n.children()) {\n        if (child.isName()) {\n          Node value = child.getFirstChild();\n          if (value != null && value.isQualifiedName()) {\n            return true;\n          }\n        }\n      }\n    }\n    return false;\n  }\n\n  private boolean isVariableDeclarationInForLoop(Node parent) {\n    return parent != null\n        && parent.isFor()\n        && parent.getFirstChild().isVar();\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ScopedAliases.java b/src/com/google/javascript/jscomp/ScopedAliases.java\nindex 30d29d0a..8b21ec08 100644\n--- a/src/com/google/javascript/jscomp/ScopedAliases.java\n+++ b/src/com/google/javascript/jscomp/ScopedAliases.java\n@@ -269,32 +269,65 @@ class ScopedAliases implements HotSwapCompilerPass {\n       hasErrors = true;\n     }\n \n-    private void findAliases(NodeTraversal t) {\n-      Scope scope = t.getScope();\n-      for (Var v : scope.getVarIterable()) {\n-        Node n = v.getNode();\n-        int type = n.getType();\n-        Node parent = n.getParent();\n-        if (parent.isVar()) {\n-          if (n.hasChildren() && n.getFirstChild().isQualifiedName()) {\n-          String name = n.getString();\n-          Var aliasVar = scope.getVar(name);\n-          aliases.put(name, aliasVar);\n-\n-          String qualifiedName =\n-              aliasVar.getInitialValue().getQualifiedName();\n-          transformation.addAlias(name, qualifiedName);\n-          // Bleeding functions already get a BAD_PARAMETERS error, so just\n-          // do nothing.\n-          // Parameters of the scope function also get a BAD_PARAMETERS\n-          // error.\n-        } else {\n-          // TODO(robbyw): Support using locals for private variables.\n-          report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+private void findAliases(NodeTraversal t) {\n+    Scope topScope = t.getScope();\n+    Scope.VarIterable vars = topScope.getVarIterable(false);\n+    for (Var v : vars) {\n+      Node n = v.getNode();\n+      Node parent = n.getParent();\n+      if (isAliasDefinition(n)) {\n+        String name = n.getString();\n+        Var aliasVar = topScope.getVar(name);\n+        Node initialValue = aliasVar.getInitialValue();\n+        String qualifiedName = null;\n+        if (initialValue != null && initialValue.isQualifiedName()) {\n+          qualifiedName = initialValue.getQualifiedName();\n         }\n+        aliases.put(name, aliasVar);\n+        transformation.addAlias(name, qualifiedName);\n+      } else if (isVariableDeclarationInForLoop(parent)) {\n+        // In the case of variables declared in for-loop headers, they are\n+        // considered aliases of the global scope. Ideally we would scope them\n+        // to the for-loop block, but since we don't convert statement blocks\n+        // to functions in this pass, we can't do that. This isn't a big deal\n+        // since most of the code here will use the variable's short name and\n+        // not the full alias.\n+        // Assignment without declaration is not handled here, which means\n+        // that the code can incorrectly mark such assignments as errors,\n+        // so we deliberately leave it unhandled.\n+        String name = n.getString();\n+        Var aliasVar = topScope.getVar(name);\n+        aliases.put(name, aliasVar);\n+      } else {\n+        // TODO: Support using locals for private variables.\n+        report(t, n, GOOG_SCOPE_NON_ALIAS_LOCAL, n.getString());\n+      }\n+    }\n+  }\n+\n+  private static boolean isAliasDefinition(Node n) {\n+    if (n.isName()) {\n+      Node value = n.getFirstChild();\n+      return value != null && value.isQualifiedName();\n+    }\n+    if (n.isDestructuringLhs()) {\n+      for (Node child : n.children()) {\n+        if (child.isName()) {\n+          Node value = child.getFirstChild();\n+          if (value != null && value.isQualifiedName()) {\n+            return true;\n+          }\n         }\n       }\n     }\n+    return false;\n+  }\n+\n+  private boolean isVariableDeclarationInForLoop(Node parent) {\n+    return parent != null\n+        && parent.isFor()\n+        && parent.getFirstChild().isVar();\n+  }\n \n     private void validateScopeCall(NodeTraversal t, Node n, Node parent) {\n       if (preprocessorSymbolTable != null) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}