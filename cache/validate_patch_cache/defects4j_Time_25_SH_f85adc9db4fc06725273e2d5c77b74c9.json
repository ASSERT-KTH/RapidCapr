{
    "patch": "                long prevAdjusted = previousTransition(instantAdjusted);\n                // If there is a gap between instantLocal and prevAdjusted, then\n                // adjust instantLocal to the end of the gap.\n                long endGapLocal = nextTransition(prevAdjusted);\n                if (instantLocal - offsetLocal < endGapLocal) {\n                    instantLocal = endGapLocal + offsetLocal;\n                }\n                // Recalculate the offset at the adjusted time.\n                int endOffsetLocal = getOffset(instantLocal);\n                if (offsetLocal == endOffsetLocal) {\n                    // We are still in the same wall time.\n                    return offsetLocal;\n                }\n                // Handle overlap.\n                instantLocal = endGapLocal + endOffsetLocal;\n                int offsetBeforeGap = getOffset(instantLocal - 1);\n                if (instantLocal - 1 < nextTransition(instantAdjusted)) {\n                    // The instant is in a gap because the end of the previous\n                    // overlap is still before instantAdjusted.\n                    return offsetAdjusted;\n                }\n                // The instant is in an overlap because it is after the\n                // transition at the end of the gap.\n                return (offsetLocal < offsetBeforeGap) ? offsetAdjusted : offsetLocal;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..fa9173e1 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,30 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+                long prevAdjusted = previousTransition(instantAdjusted);\n+                // If there is a gap between instantLocal and prevAdjusted, then\n+                // adjust instantLocal to the end of the gap.\n+                long endGapLocal = nextTransition(prevAdjusted);\n+                if (instantLocal - offsetLocal < endGapLocal) {\n+                    instantLocal = endGapLocal + offsetLocal;\n+                }\n+                // Recalculate the offset at the adjusted time.\n+                int endOffsetLocal = getOffset(instantLocal);\n+                if (offsetLocal == endOffsetLocal) {\n+                    // We are still in the same wall time.\n+                    return offsetLocal;\n+                }\n+                // Handle overlap.\n+                instantLocal = endGapLocal + endOffsetLocal;\n+                int offsetBeforeGap = getOffset(instantLocal - 1);\n+                if (instantLocal - 1 < nextTransition(instantAdjusted)) {\n+                    // The instant is in a gap because the end of the previous\n+                    // overlap is still before instantAdjusted.\n+                    return offsetAdjusted;\n+                }\n+                // The instant is in an overlap because it is after the\n+                // transition at the end of the gap.\n+                return (offsetLocal < offsetBeforeGap) ? offsetAdjusted : offsetLocal;\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.AssertionFailedError: expected:<false> but was:<true>",
    "test_result": "FAIL"
}