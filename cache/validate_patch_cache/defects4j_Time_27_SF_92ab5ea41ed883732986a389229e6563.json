{
    "patch": "private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n    if(notPrinter && notParser) {\n        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n    }\n    // If there are no element pairs then return a formatter with null printer and parser\n    if(elementPairs.isEmpty()) {\n        return new PeriodFormatter(null, null);\n    }\n    int size = elementPairs.size();\n    // If there is only one element pair\n    if(size == 1) {\n        Object obj = elementPairs.get(0);\n        if(obj instanceof Separator) {\n            Separator sep = (Separator)obj;\n            // If the only element pair is a separator then return a formatter with that separator as both the printer and parser\n            return new PeriodFormatter(sep, sep);\n        } else {\n            // Otherwise, create a formatter using the createComposite method\n            Object[] comp = createComposite(elementPairs);\n            if(notPrinter) {\n                return new PeriodFormatter(null, (PeriodParser)comp[1]);\n            } else if(notParser) {\n                return new PeriodFormatter((PeriodPrinter)comp[0], null);\n            } else {\n                return new PeriodFormatter((PeriodPrinter)comp[0], (PeriodParser)comp[1]);\n            }\n        }\n    }\n    // If there is more than one element pair\n    Object firstObj = elementPairs.get(0);\n    Separator sep = null;\n    if(firstObj instanceof Separator) {\n        sep = (Separator)firstObj;\n    }\n    // Split the list of element pairs into subarrays wherever a Separator is found\n    List<List<Object>> subarrays = new ArrayList<>();\n    List<Object> sublist = new ArrayList<>();\n    boolean isSeparator = sep != null;\n    for(int i = 0; i < size; i++) {\n        Object obj = elementPairs.get(i);\n        boolean objIsSeparator = obj instanceof Separator;\n        if(isSeparator == objIsSeparator) {\n            // If the group of element pairs is either all Separators or all non-Separators then add to the current sublist\n            sublist.add(obj);\n        } else {\n            // Otherwise start a new sublist\n            subarrays.add(sublist);\n            sublist = new ArrayList<>();\n            sublist.add(obj);\n            isSeparator = objIsSeparator;\n        }\n        if(i == size - 1) {\n            subarrays.add(sublist);\n        }\n    }\n    if(subarrays.size() == 1) {\n        // If there is only one non-empty sublist then create a formatter for that sublist\n        List<Object> sublistElements = subarrays.get(0);\n        Object[] comp = createComposite(sublistElements);\n        if(sep == null) {\n            sep = Separator.getDefaultInstance();\n        }\n        return new PeriodFormatter(sep.finish((PeriodPrinter)comp[0], (PeriodParser)comp[1]), sep);\n    } else {\n        // Otherwise, calculate the formatter for each sublist recursively, and combine them with the separator in between.\n        List<PeriodFormatter> formatters = new ArrayList<>();\n        for(List<Object> arr : subarrays) {\n            if(!(arr.get(0) instanceof Separator)) {\n                formatters.add(toFormatter(arr, false, notParser));\n            }\n        }\n        List<PeriodFormatter> subformatters = new ArrayList<>();\n        for(int i = 0; i < formatters.size(); i++) {\n            if(i == 0 && sep != null) {\n                subformatters.add(formatters.get(i));\n                subformatters.add(formatters.get(i));\n            } else {\n                subformatters.add(formatters.get(i));\n                if(i != formatters.size() - 1) {\n                    subformatters.add(new PeriodFormatter(sep, sep));\n                }\n            }\n        }\n        while(subformatters.size() > 1) {\n            List<PeriodFormatter> newSubformatters = new ArrayList<>();\n            for(int i = 0; i < subformatters.size() - 1; i += 2) {\n                PeriodFormatter f1 = subformatters.get(i);\n                PeriodFormatter f2 = subformatters.get(i+1);\n                PeriodFormatter f = new PeriodFormatter(\n                        new CompositePrinter(f1.getPrinter(), f2.getPrinter()),\n                        new CompositeParser(f1.getParser(), f2.getParser())\n                );\n                newSubformatters.add(f);\n            }\n            if(subformatters.size() % 2 == 1) {\n                newSubformatters.add(subformatters.get(subformatters.size()-1));\n            }\n            subformatters = newSubformatters;\n        }\n        return subformatters.get(0);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\nindex 15332284..2f3229db 100644\n--- a/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n+++ b/src/main/java/org/joda/time/format/PeriodFormatterBuilder.java\n@@ -791,26 +791,108 @@ public class PeriodFormatterBuilder {\n     }\n \n     //-----------------------------------------------------------------------\n-    private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n-        if (notPrinter && notParser) {\n-            throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n-        }\n-        int size = elementPairs.size();\n-        if (size >= 2 && elementPairs.get(0) instanceof Separator) {\n-            Separator sep = (Separator) elementPairs.get(0);\n-                PeriodFormatter f = toFormatter(elementPairs.subList(2, size), notPrinter, notParser);\n-                sep = sep.finish(f.getPrinter(), f.getParser());\n-                return new PeriodFormatter(sep, sep);\n-        }\n-        Object[] comp = createComposite(elementPairs);\n-        if (notPrinter) {\n-            return new PeriodFormatter(null, (PeriodParser) comp[1]);\n-        } else if (notParser) {\n-            return new PeriodFormatter((PeriodPrinter) comp[0], null);\n+private static PeriodFormatter toFormatter(List<Object> elementPairs, boolean notPrinter, boolean notParser) {\n+    if(notPrinter && notParser) {\n+        throw new IllegalStateException(\"Builder has created neither a printer nor a parser\");\n+    }\n+    // If there are no element pairs then return a formatter with null printer and parser\n+    if(elementPairs.isEmpty()) {\n+        return new PeriodFormatter(null, null);\n+    }\n+    int size = elementPairs.size();\n+    // If there is only one element pair\n+    if(size == 1) {\n+        Object obj = elementPairs.get(0);\n+        if(obj instanceof Separator) {\n+            Separator sep = (Separator)obj;\n+            // If the only element pair is a separator then return a formatter with that separator as both the printer and parser\n+            return new PeriodFormatter(sep, sep);\n         } else {\n-            return new PeriodFormatter((PeriodPrinter) comp[0], (PeriodParser) comp[1]);\n+            // Otherwise, create a formatter using the createComposite method\n+            Object[] comp = createComposite(elementPairs);\n+            if(notPrinter) {\n+                return new PeriodFormatter(null, (PeriodParser)comp[1]);\n+            } else if(notParser) {\n+                return new PeriodFormatter((PeriodPrinter)comp[0], null);\n+            } else {\n+                return new PeriodFormatter((PeriodPrinter)comp[0], (PeriodParser)comp[1]);\n+            }\n+        }\n+    }\n+    // If there is more than one element pair\n+    Object firstObj = elementPairs.get(0);\n+    Separator sep = null;\n+    if(firstObj instanceof Separator) {\n+        sep = (Separator)firstObj;\n+    }\n+    // Split the list of element pairs into subarrays wherever a Separator is found\n+    List<List<Object>> subarrays = new ArrayList<>();\n+    List<Object> sublist = new ArrayList<>();\n+    boolean isSeparator = sep != null;\n+    for(int i = 0; i < size; i++) {\n+        Object obj = elementPairs.get(i);\n+        boolean objIsSeparator = obj instanceof Separator;\n+        if(isSeparator == objIsSeparator) {\n+            // If the group of element pairs is either all Separators or all non-Separators then add to the current sublist\n+            sublist.add(obj);\n+        } else {\n+            // Otherwise start a new sublist\n+            subarrays.add(sublist);\n+            sublist = new ArrayList<>();\n+            sublist.add(obj);\n+            isSeparator = objIsSeparator;\n+        }\n+        if(i == size - 1) {\n+            subarrays.add(sublist);\n         }\n     }\n+    if(subarrays.size() == 1) {\n+        // If there is only one non-empty sublist then create a formatter for that sublist\n+        List<Object> sublistElements = subarrays.get(0);\n+        Object[] comp = createComposite(sublistElements);\n+        if(sep == null) {\n+            sep = Separator.getDefaultInstance();\n+        }\n+        return new PeriodFormatter(sep.finish((PeriodPrinter)comp[0], (PeriodParser)comp[1]), sep);\n+    } else {\n+        // Otherwise, calculate the formatter for each sublist recursively, and combine them with the separator in between.\n+        List<PeriodFormatter> formatters = new ArrayList<>();\n+        for(List<Object> arr : subarrays) {\n+            if(!(arr.get(0) instanceof Separator)) {\n+                formatters.add(toFormatter(arr, false, notParser));\n+            }\n+        }\n+        List<PeriodFormatter> subformatters = new ArrayList<>();\n+        for(int i = 0; i < formatters.size(); i++) {\n+            if(i == 0 && sep != null) {\n+                subformatters.add(formatters.get(i));\n+                subformatters.add(formatters.get(i));\n+            } else {\n+                subformatters.add(formatters.get(i));\n+                if(i != formatters.size() - 1) {\n+                    subformatters.add(new PeriodFormatter(sep, sep));\n+                }\n+            }\n+        }\n+        while(subformatters.size() > 1) {\n+            List<PeriodFormatter> newSubformatters = new ArrayList<>();\n+            for(int i = 0; i < subformatters.size() - 1; i += 2) {\n+                PeriodFormatter f1 = subformatters.get(i);\n+                PeriodFormatter f2 = subformatters.get(i+1);\n+                PeriodFormatter f = new PeriodFormatter(\n+                        new CompositePrinter(f1.getPrinter(), f2.getPrinter()),\n+                        new CompositeParser(f1.getParser(), f2.getParser())\n+                );\n+                newSubformatters.add(f);\n+            }\n+            if(subformatters.size() % 2 == 1) {\n+                newSubformatters.add(subformatters.get(subformatters.size()-1));\n+            }\n+            subformatters = newSubformatters;\n+        }\n+        return subformatters.get(0);\n+    }\n+}\n \n     private static Object[] createComposite(List<Object> elementPairs) {\n         switch (elementPairs.size()) {",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}