{
    "patch": "public double solve(final UnivariateRealFunction f,\n                    final double min, final double max, final double initial)\n        throws MaxIterationsExceededException, FunctionEvaluationException {\n\n    clearResult();\n    verifySequence(min, initial, max);\n\n    double yMin = f.value(min);\n    double yMax = f.value(max);\n    double yInitial = f.value(initial);\n\n    // check if the root lies at one of the endpoints\n    if (Math.abs(yMin) <= functionValueAccuracy) {\n        setResult(min, 0);\n        return result;\n    }\n    if (Math.abs(yMax) <= functionValueAccuracy) {\n        setResult(max, 0);\n        return result;\n    }\n\n    // check that min and max bracket the root, if not throw an exception\n    if (yMin * yMax > 0) {\n        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n    }\n\n    double xMid = initial;\n    double yMid = yInitial;\n    double oldDelta = Math.abs(max - min);\n    double delta = oldDelta;\n\n    int i;\n    for (i = 0; i < maximalIterationCount; ++i) {\n        // if the distance between the two endpoints is suppressed then stop iteration\n        if (Math.abs(delta) <= absoluteAccuracy || Math.abs(yMid) <= functionValueAccuracy) {\n            setResult(xMid, i);\n            return result;\n        }\n\n        // Need a higher precision than 64bit floating point\n        if (i == 0 || Math.abs(oldDelta) <= relativeAccuracy * Math.abs(xMid)) {\n            delta = (max - min) / 2;\n            xMid = min + delta;\n        } else {\n            double r3 = yMid / yMin;\n            double r4 = yMid / yMax;\n            double xEst = xMid - ((xMid - min) * r4) / (r3 - r4) + ((max - xMid) * r3) / (r3 - r4);\n            if (Math.abs(xEst - xMid) <= absoluteAccuracy) {\n                setResult(xEst, i);\n                return result;\n            }\n            xMid = xEst;\n        }\n\n        // calculate function value in the middle point and its sign\n        yMid = f.value(xMid);\n        if (yMid == 0) { // if mid-point is a root then terminate the method\n            setResult(xMid, i);\n            return result;\n        } else if (yMid * yMin < 0) { // change sign of max if root is between mid and max\n            max = xMid;\n            yMax = yMid;\n        } else { // change sign of min otherwise\n            min = xMid;\n            yMin = yMid;\n        }\n\n        if (Math.abs(yMin) < Math.abs(yMax)) { // If min is closer to zero\n            double temp = min;\n            min = max;\n            max = temp;\n            temp = yMin;\n            yMin = yMax;\n            yMax = temp;\n        }\n\n        oldDelta = delta;\n        delta = Math.abs(max - min);\n    }\n\n    throw new MaxIterationsExceededException(maximalIterationCount);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex e0cb42714..df741ed9b 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -95,54 +95,89 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n      * @throws IllegalArgumentException if initial is not between min and max\n      * (even if it <em>is</em> a root)\n      */\n-    public double solve(final UnivariateRealFunction f,\n-                        final double min, final double max, final double initial)\n+public double solve(final UnivariateRealFunction f,\n+                    final double min, final double max, final double initial)\n         throws MaxIterationsExceededException, FunctionEvaluationException {\n \n-        clearResult();\n-        verifySequence(min, initial, max);\n+    clearResult();\n+    verifySequence(min, initial, max);\n \n-        // return the initial guess if it is good enough\n-        double yInitial = f.value(initial);\n-        if (Math.abs(yInitial) <= functionValueAccuracy) {\n-            setResult(initial, 0);\n-            return result;\n-        }\n+    double yMin = f.value(min);\n+    double yMax = f.value(max);\n+    double yInitial = f.value(initial);\n \n-        // return the first endpoint if it is good enough\n-        double yMin = f.value(min);\n-        if (Math.abs(yMin) <= functionValueAccuracy) {\n-            setResult(yMin, 0);\n-            return result;\n-        }\n+    // check if the root lies at one of the endpoints\n+    if (Math.abs(yMin) <= functionValueAccuracy) {\n+        setResult(min, 0);\n+        return result;\n+    }\n+    if (Math.abs(yMax) <= functionValueAccuracy) {\n+        setResult(max, 0);\n+        return result;\n+    }\n \n-        // reduce interval if min and initial bracket the root\n-        if (yInitial * yMin < 0) {\n-            return solve(f, min, yMin, initial, yInitial, min, yMin);\n-        }\n+    // check that min and max bracket the root, if not throw an exception\n+    if (yMin * yMax > 0) {\n+        throw MathRuntimeException.createIllegalArgumentException(NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+    }\n \n-        // return the second endpoint if it is good enough\n-        double yMax = f.value(max);\n-        if (Math.abs(yMax) <= functionValueAccuracy) {\n-            setResult(yMax, 0);\n+    double xMid = initial;\n+    double yMid = yInitial;\n+    double oldDelta = Math.abs(max - min);\n+    double delta = oldDelta;\n+\n+    int i;\n+    for (i = 0; i < maximalIterationCount; ++i) {\n+        // if the distance between the two endpoints is suppressed then stop iteration\n+        if (Math.abs(delta) <= absoluteAccuracy || Math.abs(yMid) <= functionValueAccuracy) {\n+            setResult(xMid, i);\n             return result;\n         }\n \n-        // reduce interval if initial and max bracket the root\n-        if (yInitial * yMax < 0) {\n-            return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n+        // Need a higher precision than 64bit floating point\n+        if (i == 0 || Math.abs(oldDelta) <= relativeAccuracy * Math.abs(xMid)) {\n+            delta = (max - min) / 2;\n+            xMid = min + delta;\n+        } else {\n+            double r3 = yMid / yMin;\n+            double r4 = yMid / yMax;\n+            double xEst = xMid - ((xMid - min) * r4) / (r3 - r4) + ((max - xMid) * r3) / (r3 - r4);\n+            if (Math.abs(xEst - xMid) <= absoluteAccuracy) {\n+                setResult(xEst, i);\n+                return result;\n+            }\n+            xMid = xEst;\n         }\n \n-        if (yMin * yMax > 0) {\n-            throw MathRuntimeException.createIllegalArgumentException(\n-                  NON_BRACKETING_MESSAGE, min, max, yMin, yMax);\n+        // calculate function value in the middle point and its sign\n+        yMid = f.value(xMid);\n+        if (yMid == 0) { // if mid-point is a root then terminate the method\n+            setResult(xMid, i);\n+            return result;\n+        } else if (yMid * yMin < 0) { // change sign of max if root is between mid and max\n+            max = xMid;\n+            yMax = yMid;\n+        } else { // change sign of min otherwise\n+            min = xMid;\n+            yMin = yMid;\n         }\n \n-        // full Brent algorithm starting with provided initial guess\n-        return solve(f, min, yMin, max, yMax, initial, yInitial);\n+        if (Math.abs(yMin) < Math.abs(yMax)) { // If min is closer to zero\n+            double temp = min;\n+            min = max;\n+            max = temp;\n+            temp = yMin;\n+            yMin = yMax;\n+            yMax = temp;\n+        }\n \n+        oldDelta = delta;\n+        delta = Math.abs(max - min);\n     }\n \n+    throw new MaxIterationsExceededException(maximalIterationCount);\n+}\n+\n     /**\n      * Find a zero in the given interval.\n      * <p>",
    "result_reason": "error: final parameter max may not be assigned",
    "test_result": "ERROR"
}