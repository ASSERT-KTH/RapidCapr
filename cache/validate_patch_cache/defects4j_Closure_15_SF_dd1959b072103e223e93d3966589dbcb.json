{
    "patch": "    public boolean apply(Node n) {\n        // When the node is null it means, we reached the implicit return\n        // where the function returns (possibly without an return statement)\n        if (n == null) {\n            return false;\n        }\n\n        if (n.isCall() || n.isNew()) {\n            boolean calleeSideEffectFree = false;\n            Node callee = n.getFirstChild();\n            if (callee.isOr()) {\n                callee = callee.getFirstChild();\n            }\n            if (callee.isFunction()) {\n                calleeSideEffectFree = !mayHaveSideEffects(callee.getLastChild());\n            } else if (callee.isQualifiedName()) {\n                // Get the type information of the callee.\n                TypedVar calleeVar = getScope().getVar(callee.getQualifiedName());\n                if (calleeVar == null) {\n                    // Callee may require a global scope lookup.\n                    calleeVar = getGlobalScope().getVar(callee.getQualifiedName());\n                }\n                if (calleeVar != null && calleeVar.getType() != null) {\n                    JSType calleeType = calleeVar.getType();\n                    if (calleeType.isFunctionType()) {\n                        FunctionType functionType = calleeType.toMaybeFunctionType();\n                        if (functionType != null && functionType.isSideEffectFree()) {\n                            calleeSideEffectFree = true;\n                        }\n                    }\n                }\n            }\n            if (!calleeSideEffectFree) {\n                for (Node arg = callee.getNext(); arg != null; arg = arg.getNext()) {\n                    if (isDependentVariable(arg)) {\n                        return true;\n                    }\n                }\n            }\n        }\n\n        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n            if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n                return true;\n            }\n        }\n\n        return false;\n    }\n\n    private boolean mayHaveSideEffects(Node n) {\n        if (n.isFunction()) {\n            // For function literals,\n            // the result depends on whether the body\n            // has an effectful statement or not.\n            Node block = n.getLastChild();\n            for (Node stmt = block.getFirstChild(); stmt != null; stmt = stmt.getNext()) {\n                if (NodeUtil.mayHaveSideEffects(stmt)) {\n                    return true;\n                }\n            }\n            // If there is no effectful statement, assume side effect free.\n            return false;\n        } else {\n            return NodeUtil.mayHaveSideEffects(n);\n        }\n    }\n\n    private boolean isDependentVariable(Node n) {\n        if (n.isName()) {\n            String name = n.getString();\n            return dependentVariables.contains(name);\n        } else if (n.isGetProp()) {\n            // Check if the object of the property access is a dependent variable.\n            Node obj = n.getFirstChild();\n            if (obj.isName()) {\n                String objName = obj.getString();\n                return dependentVariables.contains(objName);\n            } else {\n                // Object of the property access is not a simple name, so treat it as a dependent variable.\n                return true;\n            }\n        } else if (n.isFunction() || n.isObjectLit() || n.isArrayLit()) {\n            // Some object literals, array literals and function literals may contain dependent variables.\n            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n                if (isDependentVariable(child)) {\n                    return true;\n                }\n            }\n            return false;\n        } else {\n            // Other types of nodes are not dependent variables.\n            return false;\n        }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\nindex a8e92fcc..98d9584f 100644\n--- a/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n+++ b/src/com/google/javascript/jscomp/FlowSensitiveInlineVariables.java\n@@ -81,32 +81,101 @@ class FlowSensitiveInlineVariables extends AbstractPostOrderCallback\n   private static final Predicate<Node> SIDE_EFFECT_PREDICATE =\n     new Predicate<Node>() {\n       @Override\n-      public boolean apply(Node n) {\n+    public boolean apply(Node n) {\n         // When the node is null it means, we reached the implicit return\n         // where the function returns (possibly without an return statement)\n         if (n == null) {\n-          return false;\n+            return false;\n         }\n \n-        // TODO(user): We only care about calls to functions that\n-        // passes one of the dependent variable to a non-side-effect free\n-        // function.\n-        if (n.isCall() && NodeUtil.functionCallHasSideEffects(n)) {\n-          return true;\n+        if (n.isCall() || n.isNew()) {\n+            boolean calleeSideEffectFree = false;\n+            Node callee = n.getFirstChild();\n+            if (callee.isOr()) {\n+                callee = callee.getFirstChild();\n+            }\n+            if (callee.isFunction()) {\n+                calleeSideEffectFree = !mayHaveSideEffects(callee.getLastChild());\n+            } else if (callee.isQualifiedName()) {\n+                // Get the type information of the callee.\n+                TypedVar calleeVar = getScope().getVar(callee.getQualifiedName());\n+                if (calleeVar == null) {\n+                    // Callee may require a global scope lookup.\n+                    calleeVar = getGlobalScope().getVar(callee.getQualifiedName());\n+                }\n+                if (calleeVar != null && calleeVar.getType() != null) {\n+                    JSType calleeType = calleeVar.getType();\n+                    if (calleeType.isFunctionType()) {\n+                        FunctionType functionType = calleeType.toMaybeFunctionType();\n+                        if (functionType != null && functionType.isSideEffectFree()) {\n+                            calleeSideEffectFree = true;\n+                        }\n+                    }\n+                }\n+            }\n+            if (!calleeSideEffectFree) {\n+                for (Node arg = callee.getNext(); arg != null; arg = arg.getNext()) {\n+                    if (isDependentVariable(arg)) {\n+                        return true;\n+                    }\n+                }\n+            }\n         }\n \n-        if (n.isNew() && NodeUtil.constructorCallHasSideEffects(n)) {\n-          return true;\n+        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+            if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n+                return true;\n+            }\n         }\n \n+        return false;\n+    }\n \n-        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (!ControlFlowGraph.isEnteringNewCfgNode(c) && apply(c)) {\n-            return true;\n-          }\n+    private boolean mayHaveSideEffects(Node n) {\n+        if (n.isFunction()) {\n+            // For function literals,\n+            // the result depends on whether the body\n+            // has an effectful statement or not.\n+            Node block = n.getLastChild();\n+            for (Node stmt = block.getFirstChild(); stmt != null; stmt = stmt.getNext()) {\n+                if (NodeUtil.mayHaveSideEffects(stmt)) {\n+                    return true;\n+                }\n+            }\n+            // If there is no effectful statement, assume side effect free.\n+            return false;\n+        } else {\n+            return NodeUtil.mayHaveSideEffects(n);\n         }\n-        return false;\n-      }\n+    }\n+\n+    private boolean isDependentVariable(Node n) {\n+        if (n.isName()) {\n+            String name = n.getString();\n+            return dependentVariables.contains(name);\n+        } else if (n.isGetProp()) {\n+            // Check if the object of the property access is a dependent variable.\n+            Node obj = n.getFirstChild();\n+            if (obj.isName()) {\n+                String objName = obj.getString();\n+                return dependentVariables.contains(objName);\n+            } else {\n+                // Object of the property access is not a simple name, so treat it as a dependent variable.\n+                return true;\n+            }\n+        } else if (n.isFunction() || n.isObjectLit() || n.isArrayLit()) {\n+            // Some object literals, array literals and function literals may contain dependent variables.\n+            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+                if (isDependentVariable(child)) {\n+                    return true;\n+                }\n+            }\n+            return false;\n+        } else {\n+            // Other types of nodes are not dependent variables.\n+            return false;\n+        }\n+    }\n   };\n \n   public FlowSensitiveInlineVariables(AbstractCompiler compiler) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}