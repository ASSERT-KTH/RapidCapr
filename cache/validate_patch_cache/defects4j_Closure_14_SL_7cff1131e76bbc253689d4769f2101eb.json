{
    "patch": "    Deque<Node> stack = new ArrayDeque<>();\n    Node current = node;\n    Node parent = null;\n    while (current != null) {\n      parent = current.getParent();\n      if (parent == null || parent.isFunction()\n          || (cfa != null && current == cfa.root)) {\n        current = null;\n      } else {\n        switch (parent.getType()) {\n          case Token.IF:\n            current = parent;\n            break;\n          case Token.CASE:\n          case Token.DEFAULT_CASE:\n            if (parent.getNext() != null) {\n              if (parent.getNext().isCase()) {\n                current = parent.getNext().getFirstChild().getNext();\n              } else if (parent.getNext().isDefaultCase()) {\n                current = parent.getNext().getFirstChild();\n              } else {\n                Preconditions.checkState(false, \"Not reachable\");\n              }\n            } else {\n              current = parent;\n            }\n            break;\n          case Token.FOR:\n            if (NodeUtil.isForIn(parent)) {\n              current = parent;\n            } else {\n              current = parent.getFirstChild().getNext().getNext();\n            }\n            break;\n          case Token.WHILE:\n          case Token.DO:\n            current = parent;\n            break;\n          case Token.TRY:\n            if (parent.getFirstChild() == current) {\n              if (NodeUtil.hasFinally(parent)) {\n                stack.push(NodeUtil.getFinallyBlock(parent));\n              } else {\n                current = parent;\n              }\n            } else if (NodeUtil.getCatchBlock(parent) == current) {\n              if (NodeUtil.hasFinally(parent)) {\n                stack.push(NodeUtil.getFinallyBlock(parent));\n              } else {\n                current = parent;\n              }\n            } else if (parent.getLastChild() == current) {\n              if (cfa != null) {\n                List<Node> finallyNodes = cfa.finallyMap.getOrDefault(parent, ImmutableList.of());\n                for (int i = finallyNodes.size() - 1; i >= 0; i--) {\n                  stack.push(finallyNodes.get(i));\n                }\n              }\n              current = parent;\n            } else {\n              Preconditions.checkState(false, \"Not reachable\");\n            }\n            break;\n          default:\n            Node nextSibling = current.getNext();\n            while (nextSibling != null && nextSibling.isFunction()) {\n              nextSibling = nextSibling.getNext();\n            }\n            if (nextSibling != null) {\n              current = nextSibling;\n            } else {\n              current = parent;\n            }\n            break;\n        }\n      }\n    }\n\n    Node followNode = null;\n    while (!stack.isEmpty()) {\n      Node finallyNode = stack.pop();\n      followNode = computeFollowNode(fromNode, finallyNode.getNext(), cfa);\n      if (followNode != null) {\n        cfa.createEdge(fromNode, Branch.UNCOND, followNode);\n      }\n    }\n    if (followNode == null) {\n      followNode = computeFollowNode(fromNode, parent, cfa);\n    }\n    return followNode;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..1f2c14e4 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,96 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+    Deque<Node> stack = new ArrayDeque<>();\n+    Node current = node;\n+    Node parent = null;\n+    while (current != null) {\n+      parent = current.getParent();\n+      if (parent == null || parent.isFunction()\n+          || (cfa != null && current == cfa.root)) {\n+        current = null;\n+      } else {\n+        switch (parent.getType()) {\n+          case Token.IF:\n+            current = parent;\n+            break;\n+          case Token.CASE:\n+          case Token.DEFAULT_CASE:\n+            if (parent.getNext() != null) {\n+              if (parent.getNext().isCase()) {\n+                current = parent.getNext().getFirstChild().getNext();\n+              } else if (parent.getNext().isDefaultCase()) {\n+                current = parent.getNext().getFirstChild();\n+              } else {\n+                Preconditions.checkState(false, \"Not reachable\");\n+              }\n+            } else {\n+              current = parent;\n+            }\n+            break;\n+          case Token.FOR:\n+            if (NodeUtil.isForIn(parent)) {\n+              current = parent;\n+            } else {\n+              current = parent.getFirstChild().getNext().getNext();\n+            }\n+            break;\n+          case Token.WHILE:\n+          case Token.DO:\n+            current = parent;\n+            break;\n+          case Token.TRY:\n+            if (parent.getFirstChild() == current) {\n+              if (NodeUtil.hasFinally(parent)) {\n+                stack.push(NodeUtil.getFinallyBlock(parent));\n+              } else {\n+                current = parent;\n+              }\n+            } else if (NodeUtil.getCatchBlock(parent) == current) {\n+              if (NodeUtil.hasFinally(parent)) {\n+                stack.push(NodeUtil.getFinallyBlock(parent));\n+              } else {\n+                current = parent;\n+              }\n+            } else if (parent.getLastChild() == current) {\n+              if (cfa != null) {\n+                List<Node> finallyNodes = cfa.finallyMap.getOrDefault(parent, ImmutableList.of());\n+                for (int i = finallyNodes.size() - 1; i >= 0; i--) {\n+                  stack.push(finallyNodes.get(i));\n+                }\n+              }\n+              current = parent;\n+            } else {\n+              Preconditions.checkState(false, \"Not reachable\");\n+            }\n+            break;\n+          default:\n+            Node nextSibling = current.getNext();\n+            while (nextSibling != null && nextSibling.isFunction()) {\n+              nextSibling = nextSibling.getNext();\n+            }\n+            if (nextSibling != null) {\n+              current = nextSibling;\n+            } else {\n+              current = parent;\n+            }\n+            break;\n+        }\n+      }\n+    }\n+\n+    Node followNode = null;\n+    while (!stack.isEmpty()) {\n+      Node finallyNode = stack.pop();\n+      followNode = computeFollowNode(fromNode, finallyNode.getNext(), cfa);\n+      if (followNode != null) {\n+        cfa.createEdge(fromNode, Branch.UNCOND, followNode);\n+      }\n+    }\n+    if (followNode == null) {\n+      followNode = computeFollowNode(fromNode, parent, cfa);\n+    }\n+    return followNode;\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}