{
    "patch": "try {\n    for (int i = 0; i < count; i++) {\n        long newMillis = savedFields[i].set(millis, resetFields);\n        if (millis > 0 && newMillis < 0) {\n            throw new IllegalArgumentException(\"The datetime is too large to be represented\");\n        } else if (millis < 0 && newMillis > 0) {\n            throw new IllegalArgumentException(\"The datetime is too small to be represented\");\n        } else if (newMillis != millis) {\n            if (iSavedFieldsShared) {\n                iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n                iSavedFieldsShared = false;\n            }\n            savedFields[i].save();\n            int j = i + 1;\n            while (j < count && savedFields[j].set(newMillis, false) == newMillis) {\n                savedFields[j++].save();\n            }\n            sort(savedFields, j);\n            if (j > i + 1) {\n                long minMillis = savedFields[i].getField().getMinimumValue();\n                long gap = savedFields[i + 1].getMillis() - minMillis;\n                gap = (gap / savedFields[i].getUnitMillis()) * savedFields[i].getUnitMillis();\n                if (resetFields) {\n                    gap = savedFields[i].getField().roundFloor(gap);\n                }\n                savedFields[i].add(gap);\n                for (int k = i + 1; k < j; k++) {\n                    savedFields[k].set(minMillis + (savedFields[k].getMillis() - minMillis) % savedFields[k].getUnitMillis(), false);\n                }\n            }\n            i = j - 1;\n        }\n        millis = newMillis;\n    }\n} catch (IllegalFieldValueException e) {\n    if (text != null) {\n        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n    }\n    throw e;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..8d6e1517 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,46 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+try {\n+    for (int i = 0; i < count; i++) {\n+        long newMillis = savedFields[i].set(millis, resetFields);\n+        if (millis > 0 && newMillis < 0) {\n+            throw new IllegalArgumentException(\"The datetime is too large to be represented\");\n+        } else if (millis < 0 && newMillis > 0) {\n+            throw new IllegalArgumentException(\"The datetime is too small to be represented\");\n+        } else if (newMillis != millis) {\n+            if (iSavedFieldsShared) {\n+                iSavedFields = savedFields = (SavedField[])iSavedFields.clone();\n+                iSavedFieldsShared = false;\n+            }\n+            savedFields[i].save();\n+            int j = i + 1;\n+            while (j < count && savedFields[j].set(newMillis, false) == newMillis) {\n+                savedFields[j++].save();\n+            }\n+            sort(savedFields, j);\n+            if (j > i + 1) {\n+                long minMillis = savedFields[i].getField().getMinimumValue();\n+                long gap = savedFields[i + 1].getMillis() - minMillis;\n+                gap = (gap / savedFields[i].getUnitMillis()) * savedFields[i].getUnitMillis();\n+                if (resetFields) {\n+                    gap = savedFields[i].getField().roundFloor(gap);\n+                }\n+                savedFields[i].add(gap);\n+                for (int k = i + 1; k < j; k++) {\n+                    savedFields[k].set(minMillis + (savedFields[k].getMillis() - minMillis) % savedFields[k].getUnitMillis(), false);\n+                }\n+            }\n+            i = j - 1;\n+        }\n+        millis = newMillis;\n+    }\n+} catch (IllegalFieldValueException e) {\n+    if (text != null) {\n+        e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+    }\n+    throw e;\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}