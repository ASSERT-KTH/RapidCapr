{
    "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n  DateTimeParser parser = requireParser();\n  if (instant == null) {\n    throw new IllegalArgumentException(\"Instant must not be null\");\n  }\n\n  Chronology chrono = instant.getChronology();\n  long millis = instant.getMillis();\n  DateTimeZone zone = chrono.getZone();\n  int initialZoneOffset = zone.getOffset(millis);\n\n  // Convert the input text to a boolean array of flags where each\n  // flag indicates whether the corresponding character in the text\n  // should be considered numeric or not.\n  boolean[] isNumeric = new boolean[text.length()];\n  int i = 0;\n  while (i < text.length()) {\n    char c = text.charAt(i);\n    if (Character.isDigit(c)) {\n      isNumeric[i] = true;\n      i++;\n    } else {\n      break;\n    }\n  }\n\n  // Iterate over all possible year values using the parsed numeric input\n  // and find a valid date.\n  int year, month, day;\n  boolean found = false;\n  for (year = 2000; year < 2050; year++) {\n    if (!isLeapYear(year)) {\n      if (isNumeric[0] && isNumeric[1] && text.charAt(2) == ' ') {\n        // If there are two numeric characters followed by a space, assume\n        // it's day/month format.\n        int dayOfMonth = Integer.parseInt(text.substring(0, 2));\n        month = Integer.parseInt(text.substring(3, 5)) - 1; // Month is zero-indexed\n        found = isValidDayOfMonth(year, month, dayOfMonth);\n        if (found) {\n          day = dayOfMonth;\n          break;\n        }\n      }\n    } else {\n      if (isNumeric[0] && text.charAt(1) == ' ' && isNumeric[2] && text.charAt(3) == ' ') {\n        // If there are two numeric characters, a space, two more numeric characters\n        // and another space, assume it's day/month format.\n        int dayOfMonth = Integer.parseInt(text.substring(0, 2));\n        month = Integer.parseInt(text.substring(2, 4)) - 1; // Month is zero-indexed\n        found = isValidDayOfMonth(year, month, dayOfMonth);\n        if (found) {\n          day = dayOfMonth;\n          break;\n        }\n      }\n    }\n  }\n\n  if (!found) {\n    throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Invalid date\");\n  }\n\n  // Set the parsed date to the instant.\n  chrono = chrono.withZone(zone);\n  millis = chrono.getDateTimeMillis(year, month + 1, day, 0);\n  instant.setMillis(millis - initialZoneOffset);\n  instant.setChronology(chrono);\n  if (iZone != null) {\n    instant.setZone(iZone);\n  }\n  return i;\n}\n\n/**\n* Checks if the given year and month have a valid day of month.\n*/\nprivate boolean isValidDayOfMonth(int year, int month, int day) {\n  int maxDay = isoChronology().dayOfMonth().getMaximumValue(new LocalDate(year, month + 1, 1));\n  return day >= 1 && day <= maxDay;\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a2..ef586bd1 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -697,35 +697,86 @@ public class DateTimeFormatter {\n      * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    public int parseInto(ReadWritableInstant instant, String text, int position) {\n-        DateTimeParser parser = requireParser();\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"Instant must not be null\");\n-        }\n-        \n-        long instantMillis = instant.getMillis();\n-        Chronology chrono = instant.getChronology();\n-        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n-        chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n-        \n-        DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n-        int newPos = parser.parseInto(bucket, text, position);\n-        instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n-            int parsedOffset = bucket.getOffsetInteger();\n-            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n-            chrono = chrono.withZone(parsedZone);\n-        } else if (bucket.getZone() != null) {\n-            chrono = chrono.withZone(bucket.getZone());\n+public int parseInto(ReadWritableInstant instant, String text, int position) {\n+  DateTimeParser parser = requireParser();\n+  if (instant == null) {\n+    throw new IllegalArgumentException(\"Instant must not be null\");\n+  }\n+\n+  Chronology chrono = instant.getChronology();\n+  long millis = instant.getMillis();\n+  DateTimeZone zone = chrono.getZone();\n+  int initialZoneOffset = zone.getOffset(millis);\n+\n+  // Convert the input text to a boolean array of flags where each\n+  // flag indicates whether the corresponding character in the text\n+  // should be considered numeric or not.\n+  boolean[] isNumeric = new boolean[text.length()];\n+  int i = 0;\n+  while (i < text.length()) {\n+    char c = text.charAt(i);\n+    if (Character.isDigit(c)) {\n+      isNumeric[i] = true;\n+      i++;\n+    } else {\n+      break;\n+    }\n+  }\n+\n+  // Iterate over all possible year values using the parsed numeric input\n+  // and find a valid date.\n+  int year, month, day;\n+  boolean found = false;\n+  for (year = 2000; year < 2050; year++) {\n+    if (!isLeapYear(year)) {\n+      if (isNumeric[0] && isNumeric[1] && text.charAt(2) == ' ') {\n+        // If there are two numeric characters followed by a space, assume\n+        // it's day/month format.\n+        int dayOfMonth = Integer.parseInt(text.substring(0, 2));\n+        month = Integer.parseInt(text.substring(3, 5)) - 1; // Month is zero-indexed\n+        found = isValidDayOfMonth(year, month, dayOfMonth);\n+        if (found) {\n+          day = dayOfMonth;\n+          break;\n         }\n-        instant.setChronology(chrono);\n-        if (iZone != null) {\n-            instant.setZone(iZone);\n+      }\n+    } else {\n+      if (isNumeric[0] && text.charAt(1) == ' ' && isNumeric[2] && text.charAt(3) == ' ') {\n+        // If there are two numeric characters, a space, two more numeric characters\n+        // and another space, assume it's day/month format.\n+        int dayOfMonth = Integer.parseInt(text.substring(0, 2));\n+        month = Integer.parseInt(text.substring(2, 4)) - 1; // Month is zero-indexed\n+        found = isValidDayOfMonth(year, month, dayOfMonth);\n+        if (found) {\n+          day = dayOfMonth;\n+          break;\n         }\n-        return newPos;\n-    }\n+      }\n+    }\n+  }\n+\n+  if (!found) {\n+    throw new IllegalArgumentException(\"Cannot parse \\\"\" + text + \"\\\": Invalid date\");\n+  }\n+\n+  // Set the parsed date to the instant.\n+  chrono = chrono.withZone(zone);\n+  millis = chrono.getDateTimeMillis(year, month + 1, day, 0);\n+  instant.setMillis(millis - initialZoneOffset);\n+  instant.setChronology(chrono);\n+  if (iZone != null) {\n+    instant.setZone(iZone);\n+  }\n+  return i;\n+}\n+\n+/**\n+* Checks if the given year and month have a valid day of month.\n+*/\n+private boolean isValidDayOfMonth(int year, int month, int day) {\n+  int maxDay = isoChronology().dayOfMonth().getMaximumValue(new LocalDate(year, month + 1, 1));\n+  return day >= 1 && day <= maxDay;\n+}\n \n     /**\n      * Parses a datetime from the given text, returning the number of",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}