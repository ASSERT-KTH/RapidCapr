{
    "patch": "public void visit(NodeTraversal t, Node n, Node parent) {\n    // VOID nodes appear when there are extra semicolons at the BLOCK level.\n    // I've been unable to think of any cases where this indicates a bug,\n    // and apparently some people like keeping these semicolons around,\n    // so we'll allow it.\n    if (n.isEmpty() || n.isComma() || n.isTemplateLit()) {\n        return;\n    }\n\n    int type = n.getType();\n    switch (type) {\n        case Token.BLOCK:\n        case Token.EXPR_RESULT:\n            return;\n        case Token.NAME:\n        case Token.STRING:\n        case Token.NUMBER:\n        case Token.ARRAYLIT:\n        case Token.TRUE:\n        case Token.FALSE:\n        case Token.NULL:\n        case Token.REGEXP:\n            break;\n        default:\n            if (NodeUtil.isExpressionNode(n.getParent())) {\n                if (NodeUtil.isExpressionResultUsed(n)) {\n                    return;\n                }\n            }\n            break;\n    }\n\n    if (parent != null && (parent.getType() == Token.COMMA)) {\n        if (n.equals(parent.getLastChild())) {\n            for (Node an : parent.getAncestors()) {\n                int ancestorType = an.getType();\n                if (ancestorType == Token.COMMA)\n                    continue;\n                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK && ancestorType != Token.SCRIPT) {\n                    return;\n                }\n            }\n        }\n    } else {\n        boolean isDefinitionOrCall = (\n                type == Token.VAR ||\n                type == Token.LP ||\n                type == Token.CALL ||\n                type == Token.NEW);\n        if (!isDefinitionOrCall) {\n            Node findSideEffect = (NodeUtil.isExpressionNode(n.getParent())) ? n.getParent() : n;\n            if (NodeUtil.mayHaveSideEffects(findSideEffect, t.getCompiler())) {\n                if (parent == null || !(\n                        parent.getType() == Token.FOR &&\n                        parent.getChildCount() == 4 &&\n                        (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())\n                )) {\n                    if (type == Token.CALL) {\n                        Node child = n.getFirstChild();\n                        // Check for quick return-calls of single-element literals like [].slice()\n                        if (child != null && !NodeUtil.mayHaveSideEffects(child, t.getCompiler())) {\n                            return;\n                        }\n                    }\n                }\n            }\n        }\n    }\n\n    if (!NodeUtil.isStatement(n)) {\n        problemNodes.add(n);\n    }\n\n    String msg = \"This code lacks side-effects. Is there a bug?\";\n    if (n.isString()) {\n        msg = \"Is there a missing '+' on the previous line?\";\n    } else if (type == Token.NAME) {\n        msg = \"The variable '\" + n.getString() + \"' is assigned a value but never used.\";\n    } else if (type == Token.CALL) {\n        msg = \"The function call returns a value but it is never used.\";\n    }\n\n    t.getCompiler().report(\n            t.makeError(n, level, USELESS_CODE_ERROR, msg));\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckSideEffects.java b/src/com/google/javascript/jscomp/CheckSideEffects.java\nindex 0d1e95a0..e35912e4 100644\n--- a/src/com/google/javascript/jscomp/CheckSideEffects.java\n+++ b/src/com/google/javascript/jscomp/CheckSideEffects.java\n@@ -81,71 +81,91 @@ final class CheckSideEffects extends AbstractPostOrderCallback\n   }\n \n   @Override\n-  public void visit(NodeTraversal t, Node n, Node parent) {\n+public void visit(NodeTraversal t, Node n, Node parent) {\n     // VOID nodes appear when there are extra semicolons at the BLOCK level.\n     // I've been unable to think of any cases where this indicates a bug,\n     // and apparently some people like keeping these semicolons around,\n     // so we'll allow it.\n-    if (n.isEmpty() ||\n-        n.isComma()) {\n-      return;\n+    if (n.isEmpty() || n.isComma() || n.isTemplateLit()) {\n+        return;\n     }\n \n-    if (parent == null) {\n-      return;\n+    int type = n.getType();\n+    switch (type) {\n+        case Token.BLOCK:\n+        case Token.EXPR_RESULT:\n+            return;\n+        case Token.NAME:\n+        case Token.STRING:\n+        case Token.NUMBER:\n+        case Token.ARRAYLIT:\n+        case Token.TRUE:\n+        case Token.FALSE:\n+        case Token.NULL:\n+        case Token.REGEXP:\n+            break;\n+        default:\n+            if (NodeUtil.isExpressionNode(n.getParent())) {\n+                if (NodeUtil.isExpressionResultUsed(n)) {\n+                    return;\n+                }\n+            }\n+            break;\n     }\n \n-    // Do not try to remove a block or an expr result. We already handle\n-    // these cases when we visit the child, and the peephole passes will\n-    // fix up the tree in more clever ways when these are removed.\n-    if (n.isExprResult()) {\n-      return;\n+    if (parent != null && (parent.getType() == Token.COMMA)) {\n+        if (n.equals(parent.getLastChild())) {\n+            for (Node an : parent.getAncestors()) {\n+                int ancestorType = an.getType();\n+                if (ancestorType == Token.COMMA)\n+                    continue;\n+                if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK && ancestorType != Token.SCRIPT) {\n+                    return;\n+                }\n+            }\n+        }\n+    } else {\n+        boolean isDefinitionOrCall = (\n+                type == Token.VAR ||\n+                type == Token.LP ||\n+                type == Token.CALL ||\n+                type == Token.NEW);\n+        if (!isDefinitionOrCall) {\n+            Node findSideEffect = (NodeUtil.isExpressionNode(n.getParent())) ? n.getParent() : n;\n+            if (NodeUtil.mayHaveSideEffects(findSideEffect, t.getCompiler())) {\n+                if (parent == null || !(\n+                        parent.getType() == Token.FOR &&\n+                        parent.getChildCount() == 4 &&\n+                        (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext())\n+                )) {\n+                    if (type == Token.CALL) {\n+                        Node child = n.getFirstChild();\n+                        // Check for quick return-calls of single-element literals like [].slice()\n+                        if (child != null && !NodeUtil.mayHaveSideEffects(child, t.getCompiler())) {\n+                            return;\n+                        }\n+                    }\n+                }\n+            }\n+        }\n     }\n \n-    // This no-op statement was there so that JSDoc information could\n-    // be attached to the name. This check should not complain about it.\n-    if (n.isQualifiedName() && n.getJSDocInfo() != null) {\n-      return;\n+    if (!NodeUtil.isStatement(n)) {\n+        problemNodes.add(n);\n     }\n \n-    boolean isResultUsed = NodeUtil.isExpressionResultUsed(n);\n-    boolean isSimpleOp = NodeUtil.isSimpleOperatorType(n.getType());\n-    if (parent.getType() == Token.COMMA) {\n-      if (isResultUsed) {\n-        return;\n-      }\n-      if (n == parent.getLastChild()) {\n-        for (Node an : parent.getAncestors()) {\n-          int ancestorType = an.getType();\n-          if (ancestorType == Token.COMMA) continue;\n-          if (ancestorType != Token.EXPR_RESULT && ancestorType != Token.BLOCK) return;\n-          else break;\n-        }\n-      }\n-    } else if (parent.getType() != Token.EXPR_RESULT && parent.getType() != Token.BLOCK) {\n-      if (! (parent.getType() == Token.FOR && parent.getChildCount() == 4 && (n == parent.getFirstChild() || n == parent.getFirstChild().getNext().getNext()))) {\n-        return;\n-      }\n-    }\n-    if (\n-        (isSimpleOp || !NodeUtil.mayHaveSideEffects(n, t.getCompiler()))) {\n-      String msg = \"This code lacks side-effects. Is there a bug?\";\n-      if (n.isString()) {\n+    String msg = \"This code lacks side-effects. Is there a bug?\";\n+    if (n.isString()) {\n         msg = \"Is there a missing '+' on the previous line?\";\n-      } else if (isSimpleOp) {\n-        msg = \"The result of the '\" + Token.name(n.getType()).toLowerCase() +\n-            \"' operator is not being used.\";\n-      }\n-\n-      t.getCompiler().report(\n-          t.makeError(n, level, USELESS_CODE_ERROR, msg));\n-      // TODO(johnlenz): determine if it is necessary to\n-      // try to protect side-effect free statements as well.\n-      if (!NodeUtil.isStatement(n)) {\n-        problemNodes.add(n);\n-      }\n+    } else if (type == Token.NAME) {\n+        msg = \"The variable '\" + n.getString() + \"' is assigned a value but never used.\";\n+    } else if (type == Token.CALL) {\n+        msg = \"The function call returns a value but it is never used.\";\n     }\n-  }\n+\n+    t.getCompiler().report(\n+            t.makeError(n, level, USELESS_CODE_ERROR, msg));\n+}\n \n   /**\n    * Protect side-effect free nodes by making them parameters",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}