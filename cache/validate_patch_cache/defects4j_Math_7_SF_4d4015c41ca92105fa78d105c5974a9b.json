{
    "patch": "            final PriorityQueue<EventState> queue = new PriorityQueue<>(64, new Comparator<EventState>() {\n                public int compare(EventState es0, EventState es1) {\n                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                }\n            });\n\n            for (final EventState state : eventsStates) {\n                if (state.evaluateStep(interpolator)) {\n                    // the event occurs during the current step\n                    occuringEvents.add(state);\n                }\n            }\n\n            while (!occuringEvents.isEmpty()) {\n\n                // handle the chronologically first event\n                final Iterator<EventState> iterator = occuringEvents.iterator();\n                final EventState currentEvent = iterator.next();\n                iterator.remove();\n\n                // restrict the interpolator to the first part of the step, up to the event\n                final double eventT = currentEvent.getEventTime();\n                interpolator.setSoftPreviousTime(previousT);\n                interpolator.setSoftCurrentTime(eventT);\n\n                // get state at event time\n                interpolator.setInterpolatedTime(eventT);\n                final double[] eventY = interpolator.getInterpolatedState().clone();\n\n                // advance all event states to current time\n                currentEvent.stepAccepted(eventT, eventY);\n                isLastStep = currentEvent.stop();\n\n                // handle the first part of the step, up to the event\n                for (final StepHandler handler : stepHandlers) {\n                    handler.handleStep(interpolator, isLastStep);\n                }\n\n                // update occurring events\n                for (final EventState state : eventsStates) {\n                    final boolean wasInList = occuringEvents.remove(state); // also removes it from the list\n                    if (state.evaluateStep(interpolator)) {\n                        if (wasInList) {\n                            // already in the list, decrease index (in the queue) to preserve ordering\n                            queue.remove(state);\n                        }\n                        queue.add(state);\n                        occuringEvents.add(state);\n                    }\n                }\n\n                // handle the event, update the states\n                currentEvent.handleStep(interpolator);\n            }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..b84d89e51 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,10 +313,10 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n+            final PriorityQueue<EventState> queue = new PriorityQueue<>(64, new Comparator<EventState>() {\n                 public int compare(EventState es0, EventState es1) {\n                     return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n                 }\n-\n             });\n \n             for (final EventState state : eventsStates) {\n@@ -351,6 +351,23 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n                     handler.handleStep(interpolator, isLastStep);\n                 }\n \n+                // update occurring events\n+                for (final EventState state : eventsStates) {\n+                    final boolean wasInList = occuringEvents.remove(state); // also removes it from the list\n+                    if (state.evaluateStep(interpolator)) {\n+                        if (wasInList) {\n+                            // already in the list, decrease index (in the queue) to preserve ordering\n+                            queue.remove(state);\n+                        }\n+                        queue.add(state);\n+                        occuringEvents.add(state);\n+                    }\n+                }\n+\n+                // handle the event, update the states\n+                currentEvent.handleStep(interpolator);\n+            }\n+\n                 if (isLastStep) {\n                     // the event asked to stop integration\n                     System.arraycopy(eventY, 0, y, 0, y.length);",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}