{
    "patch": "private boolean isDirective(Node n) {\n  if (n == null) return false;\n\n  int nType = n.getType();\n  return nType == Token.EXPR_RESULT &&\n      n.getFirstChild().isString() &&\n      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n}\n\n@Override\nNode processBlock(Block blockNode) {\n  return processGeneric(blockNode);\n}\n\n@Override\nNode processBreakStatement(BreakStatement statementNode) {\n  Node node = IRFactory.newNode(Token.BREAK);\n  if (statementNode.getBreakLabel() != null) {\n    Node labelName = transform(statementNode.getBreakLabel());\n    labelName.setType(Token.LABEL_NAME);\n    node.addChildToBack(labelName);\n  }\n  return node;\n}\n\n@Override\nNode processCatchClause(CatchClause clauseNode) {\n  AstNode catchVar = clauseNode.getVarName();\n  Node node = IRFactory.newNode(Token.CATCH, transform(catchVar));\n  if (clauseNode.getCatchCondition() != null) {\n    errorReporter.error(\n        \"Catch clauses are not supported\",\n        sourceName,\n        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n  }\n  node.addChildToBack(transformBlock(clauseNode.getBody()));\n  return node;\n}\n\n@Override\nNode processConditionalExpression(ConditionalExpression exprNode) {\n  return IRFactory.newNode(\n      Token.HOOK,\n      transform(exprNode.getTestExpression()),\n      transform(exprNode.getTrueExpression()),\n      transform(exprNode.getFalseExpression()));\n}\n\n@Override\nNode processContinueStatement(ContinueStatement statementNode) {\n  Node node = IRFactory.newNode(Token.CONTINUE);\n  if (statementNode.getLabel() != null) {\n    Node labelName = transform(statementNode.getLabel());\n    labelName.setType(Token.LABEL_NAME);\n    node.addChildToBack(labelName);\n  }\n  return node;\n}\n\n@Override\nNode processDoLoop(DoLoop loopNode) {\n  return IRFactory.newNode(\n      Token.DO,\n      transformBlock(loopNode.getBody()),\n      transform(loopNode.getCondition()));\n}\n\n@Override\nNode processElementGet(ElementGet getNode) {\n  return IRFactory.newNode(\n      Token.GETELEM,\n      transform(getNode.getTarget()),\n      transform(getNode.getElement()));\n}\n\n@Override\nNode processEmptyExpression(EmptyExpression exprNode) {\n  Node node = IRFactory.newNode(Token.EMPTY);\n  return node;\n}\n\n@Override\nNode processExpressionStatement(ExpressionStatement statementNode) {\n  Node node = IRFactory.newNode(getNodeType(statementNode));\n  node.addChildToBack(transform(statementNode.getExpression()));\n  return node;\n}\n\n@Override\nNode processForInLoop(ForInLoop loopNode) {\n  AstNode iterNode = loopNode.getIterator();\n  AstNode objNode = loopNode.getIteratedObject();\n  Node lhs, rhs;\n  if (iterNode instanceof DestructuringForm) {\n    checkForViolation(Parser.Config.StrictMode.under((Node) iterNode), ((DestructuringForm) iterNode).getLeft());\n    lhs = transform(iterNode);\n    rhs = transform(objNode);\n  } else {\n    lhs = transform(iterNode);\n    rhs =\n        IRFactory.newNode(\n            Token.CALL,\n            IRFactory.newNode(Token.NAME, IRFactory.getPropCoded(REGEXP = IRFactory.name(\"RegExp\"), \"prototype\")),\n            transform(objNode));\n    rhs.putProp(Node.REGEXP_PROP, Boolean.TRUE);\n  }\n  Node forNode = IRFactory.newNode(Token.FOR, lhs, rhs, transformBlock(loopNode.getBody()));\n  return forNode;\n}\n\n@Override\nNode processForLoop(ForLoop loopNode) {\n  Node node;\n\n  AstNode init = loopNode.getInitializer();\n  Node initNode = null;\n  if (init != null) {\n    if (init instanceof VariableDeclaration) {\n      initNode = transform(init);\n    } else {\n      initNode = transformToExpression(init);\n    }\n  }\n\n  AstNode condition = loopNode.getCondition();\n  Node condNode = null;\n  if (condition != null) {\n    condNode = transformToBoolean(condition);\n  }\n\n  AstNode incr = loopNode.getIncrement();\n  Node incrNode = null;\n  if (incr != null) {\n    incrNode = transformToExpression(incr);\n  }\n\n  node = IRFactory.newNode(Token.FOR, initNode, condNode, incrNode, transformBlock(loopNode.getBody()));\n\n  return node;\n}\n\n@Override\nNode processFunctionCall(FunctionCall callNode) {\n  Node call = transform(callNode.getTarget());\n  for (AstNode arg : callNode.getArguments()) {\n    call.addChildToBack(transform(arg));\n  }\n  return call;\n}\n\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  int functionType;\n  switch (functionNode.getFunctionType()) {\n    case FunctionNode.FUNCTION_EXPRESSION:\n      functionType = Token.FUNCTION;\n      break;\n    case FunctionNode.FUNCTION_STATEMENT:\n      functionType = Token.FUNCTION;\n      break;\n    case FunctionNode.GETTER_FUNCTION:\n      functionType = Token.GETTER_DEF;\n      break;\n    case FunctionNode.SETTER_FUNCTION:\n      functionType = Token.SETTER_DEF;\n      break;\n    case FunctionNode.ARROW_FUNCTION:\n      functionType = Token.ARROWFUNCTION;\n      break;\n    default:\n      throw new RuntimeException(\"Unknown function type: \" + functionNode.getFunctionType());\n  }\n\n  Node functionObj = IRFactory.newNode(functionType);\n\n  if (functionNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {\n    // Functions declared as statements in scripts are marked \"exported\",\n    // so that they can be renamed by the variable renaming pass. Note\n    // that functions declared in blocks can be exported, since the grammar\n    // does not allow statements to follow the function declaration.\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(functionNode);\n    if (info != null && info.isExport()) {\n      functionObj.putProp(Node.EXPORT_WAS_SET, Boolean.TRUE);\n    }\n  }\n\n  AstNode nameNode = functionNode.getFunctionName();\n  nameNode = nameNode == null ? null : transform(nameNode);\n  functionObj.addChildToBack(newStringNode(Token.FUNCTION_NAME, nameNode));\n\n  AstNode args = functionNode.getParams();\n  Node parameterList = IRFactory.newNode(Token.PARAM_LIST);\n  while (args != null && args.getType() == Token.PARAM_LIST) {\n    for (int i = 0; i < args.getLength(); i++) {\n      AstNode arg = args.getChildAtIndex(i);\n      Node name = IRFactory.newString(Token.NAME, arg.getString());\n      // In case of destructuring, the name is converted to VAR.\n      if (arg instanceof DestructuringForm) {\n        // Destructuring is usually in the LHS of an assignment (or for/in LHS),\n        // but can also occur as a function parameter, in which case it is\n        // treated as a VAR declaration and the new name created for it is a VAR.\n        if (astHandlingPolicy != AstHandlingPolicy.CONSERVATIVE || NodeUtil.isNameDeclaration(arg.getParent())) {\n          if (arg.getParent().getType() == Token.ARRAY_PATTERN || arg.getParent().getType() == Token.OBJECT_PATTERN) {\n            name.setType(Token.ARRAY_PATTERN);\n          } else {\n            name.setType(Token.OBJECT_PATTERN);\n          }\n        }\n        name.putProp(Node.DESTRUCTURING_LHS, arg);\n        arg = ((DestructuringForm) arg).getLeft();\n      }\n      parameterList.addChildToBack(name);\n    }\n    args = args.getNext();\n  }\n\n  functionObj.addChildToBack(parameterList);\n\n  functionObj.addChildToBack(transform(functionNode.getBody()));\n\n  if (functionNode.getLineno() != -1 && functionNode.getCharno() != -1) {\n    functionObj.putProp(Node.SOURCENAME_PROP, sourceName);\n    functionObj.putProp(Node.START_LINE_PROP, functionNode.getLineno());\n    functionObj.putProp(Node.START_COLUMN_PROP, functionNode.getCharno());\n  }\n\n  // set common function properties\n  if (functionNode.getFunctionType() != FunctionNode.FUNCTION_STATEMENT) {\n    JSDocInfo info = NodeUtil.getBestJSDocInfo(functionNode);\n    if (info != null) {\n      boolean suppressions = info.hasTypeAnnotations() ||\n          info.hasReturnType() ||\n          info.isConstructor() ||\n          info.isInterface() ||\n          !info.getImplementedInterfaces().isEmpty();\n\n      if (suppressions) {\n        // functions with type annotations, interfaces, constructors or @return\n        // do not receive ASSUME_* properties\n        // because compiler does additional validation on their parameters and returns\n        // which may not be correct.\n        functionObj.putBooleanProp(Node.SUPPRESS_WARNINGS, true);\n      }\n      functionObj.setJSDocInfo(info);\n    }\n\n    Node parent = functionNode.getParent();\n    if (parent == null) {\n      checkForViolations(Parser.Config.StrictMode.under(functionObj), functionNode);\n    } else if (parent.getType() == Token.CATCH) {\n      // the catch block will check for its own violations\n    } else if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n      checkForViolations(Parser.Config.StrictMode.under(functionObj), functionNode.getParent());\n    }\n  }\n\n  return functionObj;\n}\n\n@Override\nNode processInfixExpression(InfixExpression exprNode) {\n  int type = rewriteInfixOperator(exprNode.getType());\n  if (type == -1) {\n    type = exprNode.getType();\n  }\n\n  // For all operators other than OR and AND, we need to rewrite the left\n  // and right values to boolean.\n  if (type != Token.AND && type != Token.OR) {\n    return createBinary(type, transformToBoolean(exprNode.getLeft()), transformToBoolean(exprNode.getRight()));\n  }\n\n  // For OR and AND, we only need to do the short circuiting if the other\n  // operand is not a side-effect free boolean.\n  Node leftNode = transform(exprNode.getLeft());\n  Node rightNode = transform(exprNode.getRight());\n  if (type == Token.AND) {\n    return optimizeLogicalAnd(leftNode, rightNode);\n  } else {\n    return optimizeLogicalOr(leftNode, rightNode);\n  }\n}\n\n@Override\nNode processKeywordLiteral(KeywordLiteral literalNode) {\n  Node n = newNode(literalNode.getType());\n  switch (literalNode.getType()) {\n    case Token.NULL:\n    case Token.THIS:\n      break;\n    case Token.FALSE:\n    case Token.TRUE:\n      n.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n      break;\n    case Token.DEBUGGER:\n      n.putBooleanProp(Node.DEBUGGER_GROUP, true);\n      break;\n  }\n  return n;\n}\n\n@Override\nNode processName(Name nameNode) {\n  return processNameHelper(nameNode);\n}\n\n@Override\nNode processNumber(NumberLiteral numberNode) {\n  Node n = IRFactory.newNumber(numberNode.getNumber());\n  n.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n  return n;\n}\n\n@Override\nNode processObjectLiteral(ObjectLiteral objectNode) {\n  Node objectLitNode = IRFactory.newNode(Token.OBJECTLIT);\n\n  for (Node propNode : transformObjectLiteral(objectNode)) {\n    objectLitNode.addChildToBack(propNode);\n  }\n\n  return objectLitNode;\n}\n\n@Override\nNode processParenthesizedExpression(ParenthesizedExpression node) {\n  // Parentheses can be safely dropped if the child is side-effect free.\n  Node child = transform(node.getExpression());\n  if (child.isSideEffectFree()) {\n    return maybeUnrollLoops(child);\n  }\n\n  Node n = newNode(Token.WITH);\n  n.setIsSyntheticBlock(true);\n  // var $jscomp$with = ( <expr> , expr );\n  // $jscomp$with is required so we can drop the trailing expression onto it.\n  Node varNode = IRFactory.newNode(Token.VAR, IRFactory.newName(\"$jscomp$with\"), child);\n  n.addChildToBack(varNode);\n  // {$jscomp$with: <expr>, <next-statement>}\n  Node withBlockNode = IRFactory.newNode(Token.BLOCK);\n  withBlockNode.addChildToBack(\n      IRFactory.newString(Token.STRING_KEY, \"$jscomp$with\"),\n      IRFactory.newName(\"$jscomp$with\"));\n  Node nextStatement = stripBlock(transform(node.getExpression()));\n  if (nextStatement.getType() == Token.BLOCK) {\n    for (Node child2 : nextStatement.children()) {\n      withBlockNode.addChildToBack(child2);\n    }\n  } else {\n    withBlockNode.addChildToBack(nextStatement);\n  }\n  n.addChildToBack(withBlockNode);\n\n  return n;\n}\n\n@Override\nNode processRegExpLiteral(RegExpLiteral literalNode) {\n  Node node = IRFactory.newRegexp(literalNode.getValue(), literalNode.getFlags());\n  node.putProp(Node.REGEXP_PROP, Boolean.TRUE);\n  node.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n  return node;\n}\n\n@Override\nNode processReturnStatement(ReturnStatement statementNode) {\n  Node node = IRFactory.newNode(Token.RETURN);\n  if (statementNode.getReturnValue() != null) {\n    node.addChildToBack(transform(statementNode.getReturnValue()));\n  }\n  return node;\n}\n\n@Override\nNode processString(StringLiteral stringNode) {\n  Node n = IRFactory.newString(stringNode.getValue());\n  n.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n  return n;\n}\n\n@Override\nNode processSwitchCase(SwitchCase caseNode) {\n  Node caseObj = IRFactory.newNode(Token.CASE, transform(caseNode.getExpression()));\n  for (AstNode statement : caseNode.getStatements()) {\n    caseObj.addChildToBack(transform(statement));\n  }\n  return caseObj;\n}\n\n@Override\nNode processSwitchStatement(SwitchStatement statementNode) {\n  Node switchObj = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n  for (SwitchCase caseNode : statementNode.getCases()) {\n    switchObj.addChildToBack(transform(caseNode));\n  }\n  return switchObj;\n}\n\n@Override\nNode processThrowStatement(ThrowStatement statementNode) {\n  return IRFactory.newNode(Token.THROW, transform(statementNode.getExpression()));\n}\n\n@Override\nNode processTryStatement(TryStatement statementNode) {\n  Node node = IRFactory.newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n  if (statementNode.getCatchClauses() != null) {\n    for (CatchClause catchClause : statementNode.getCatchClauses()) {\n      node.addChildToBack(transform(catchClause));\n    }\n  }\n  if (statementNode.getFinallyBlock() != null) {\n    node.addChildToBack(newNode(Token.FINALLY, transformBlock(statementNode.getFinallyBlock())));\n  }\n  return node;\n}\n\n@Override\nNode processUnaryExpression(UnaryExpression exprNode) {\n  int typ",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..59e5f5dc 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,426 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+private boolean isDirective(Node n) {\n+  if (n == null) return false;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  int nType = n.getType();\n+  return nType == Token.EXPR_RESULT &&\n+      n.getFirstChild().isString() &&\n+      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+}\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+@Override\n+Node processBlock(Block blockNode) {\n+  return processGeneric(blockNode);\n+}\n+\n+@Override\n+Node processBreakStatement(BreakStatement statementNode) {\n+  Node node = IRFactory.newNode(Token.BREAK);\n+  if (statementNode.getBreakLabel() != null) {\n+    Node labelName = transform(statementNode.getBreakLabel());\n+    labelName.setType(Token.LABEL_NAME);\n+    node.addChildToBack(labelName);\n+  }\n+  return node;\n+}\n+\n+@Override\n+Node processCatchClause(CatchClause clauseNode) {\n+  AstNode catchVar = clauseNode.getVarName();\n+  Node node = IRFactory.newNode(Token.CATCH, transform(catchVar));\n+  if (clauseNode.getCatchCondition() != null) {\n+    errorReporter.error(\n+        \"Catch clauses are not supported\",\n+        sourceName,\n+        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  }\n+  node.addChildToBack(transformBlock(clauseNode.getBody()));\n+  return node;\n+}\n+\n+@Override\n+Node processConditionalExpression(ConditionalExpression exprNode) {\n+  return IRFactory.newNode(\n+      Token.HOOK,\n+      transform(exprNode.getTestExpression()),\n+      transform(exprNode.getTrueExpression()),\n+      transform(exprNode.getFalseExpression()));\n+}\n+\n+@Override\n+Node processContinueStatement(ContinueStatement statementNode) {\n+  Node node = IRFactory.newNode(Token.CONTINUE);\n+  if (statementNode.getLabel() != null) {\n+    Node labelName = transform(statementNode.getLabel());\n+    labelName.setType(Token.LABEL_NAME);\n+    node.addChildToBack(labelName);\n+  }\n+  return node;\n+}\n+\n+@Override\n+Node processDoLoop(DoLoop loopNode) {\n+  return IRFactory.newNode(\n+      Token.DO,\n+      transformBlock(loopNode.getBody()),\n+      transform(loopNode.getCondition()));\n+}\n+\n+@Override\n+Node processElementGet(ElementGet getNode) {\n+  return IRFactory.newNode(\n+      Token.GETELEM,\n+      transform(getNode.getTarget()),\n+      transform(getNode.getElement()));\n+}\n+\n+@Override\n+Node processEmptyExpression(EmptyExpression exprNode) {\n+  Node node = IRFactory.newNode(Token.EMPTY);\n+  return node;\n+}\n+\n+@Override\n+Node processExpressionStatement(ExpressionStatement statementNode) {\n+  Node node = IRFactory.newNode(getNodeType(statementNode));\n+  node.addChildToBack(transform(statementNode.getExpression()));\n+  return node;\n+}\n+\n+@Override\n+Node processForInLoop(ForInLoop loopNode) {\n+  AstNode iterNode = loopNode.getIterator();\n+  AstNode objNode = loopNode.getIteratedObject();\n+  Node lhs, rhs;\n+  if (iterNode instanceof DestructuringForm) {\n+    checkForViolation(Parser.Config.StrictMode.under((Node) iterNode), ((DestructuringForm) iterNode).getLeft());\n+    lhs = transform(iterNode);\n+    rhs = transform(objNode);\n+  } else {\n+    lhs = transform(iterNode);\n+    rhs =\n+        IRFactory.newNode(\n+            Token.CALL,\n+            IRFactory.newNode(Token.NAME, IRFactory.getPropCoded(REGEXP = IRFactory.name(\"RegExp\"), \"prototype\")),\n+            transform(objNode));\n+    rhs.putProp(Node.REGEXP_PROP, Boolean.TRUE);\n+  }\n+  Node forNode = IRFactory.newNode(Token.FOR, lhs, rhs, transformBlock(loopNode.getBody()));\n+  return forNode;\n+}\n+\n+@Override\n+Node processForLoop(ForLoop loopNode) {\n+  Node node;\n+\n+  AstNode init = loopNode.getInitializer();\n+  Node initNode = null;\n+  if (init != null) {\n+    if (init instanceof VariableDeclaration) {\n+      initNode = transform(init);\n+    } else {\n+      initNode = transformToExpression(init);\n     }\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  AstNode condition = loopNode.getCondition();\n+  Node condNode = null;\n+  if (condition != null) {\n+    condNode = transformToBoolean(condition);\n+  }\n+\n+  AstNode incr = loopNode.getIncrement();\n+  Node incrNode = null;\n+  if (incr != null) {\n+    incrNode = transformToExpression(incr);\n+  }\n+\n+  node = IRFactory.newNode(Token.FOR, initNode, condNode, incrNode, transformBlock(loopNode.getBody()));\n+\n+  return node;\n+}\n+\n+@Override\n+Node processFunctionCall(FunctionCall callNode) {\n+  Node call = transform(callNode.getTarget());\n+  for (AstNode arg : callNode.getArguments()) {\n+    call.addChildToBack(transform(arg));\n+  }\n+  return call;\n+}\n+\n+@Override\n+Node processFunctionNode(FunctionNode functionNode) {\n+  int functionType;\n+  switch (functionNode.getFunctionType()) {\n+    case FunctionNode.FUNCTION_EXPRESSION:\n+      functionType = Token.FUNCTION;\n+      break;\n+    case FunctionNode.FUNCTION_STATEMENT:\n+      functionType = Token.FUNCTION;\n+      break;\n+    case FunctionNode.GETTER_FUNCTION:\n+      functionType = Token.GETTER_DEF;\n+      break;\n+    case FunctionNode.SETTER_FUNCTION:\n+      functionType = Token.SETTER_DEF;\n+      break;\n+    case FunctionNode.ARROW_FUNCTION:\n+      functionType = Token.ARROWFUNCTION;\n+      break;\n+    default:\n+      throw new RuntimeException(\"Unknown function type: \" + functionNode.getFunctionType());\n+  }\n+\n+  Node functionObj = IRFactory.newNode(functionType);\n+\n+  if (functionNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT) {\n+    // Functions declared as statements in scripts are marked \"exported\",\n+    // so that they can be renamed by the variable renaming pass. Note\n+    // that functions declared in blocks can be exported, since the grammar\n+    // does not allow statements to follow the function declaration.\n+    JSDocInfo info = NodeUtil.getBestJSDocInfo(functionNode);\n+    if (info != null && info.isExport()) {\n+      functionObj.putProp(Node.EXPORT_WAS_SET, Boolean.TRUE);\n     }\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  AstNode nameNode = functionNode.getFunctionName();\n+  nameNode = nameNode == null ? null : transform(nameNode);\n+  functionObj.addChildToBack(newStringNode(Token.FUNCTION_NAME, nameNode));\n+\n+  AstNode args = functionNode.getParams();\n+  Node parameterList = IRFactory.newNode(Token.PARAM_LIST);\n+  while (args != null && args.getType() == Token.PARAM_LIST) {\n+    for (int i = 0; i < args.getLength(); i++) {\n+      AstNode arg = args.getChildAtIndex(i);\n+      Node name = IRFactory.newString(Token.NAME, arg.getString());\n+      // In case of destructuring, the name is converted to VAR.\n+      if (arg instanceof DestructuringForm) {\n+        // Destructuring is usually in the LHS of an assignment (or for/in LHS),\n+        // but can also occur as a function parameter, in which case it is\n+        // treated as a VAR declaration and the new name created for it is a VAR.\n+        if (astHandlingPolicy != AstHandlingPolicy.CONSERVATIVE || NodeUtil.isNameDeclaration(arg.getParent())) {\n+          if (arg.getParent().getType() == Token.ARRAY_PATTERN || arg.getParent().getType() == Token.OBJECT_PATTERN) {\n+            name.setType(Token.ARRAY_PATTERN);\n+          } else {\n+            name.setType(Token.OBJECT_PATTERN);\n+          }\n+        }\n+        name.putProp(Node.DESTRUCTURING_LHS, arg);\n+        arg = ((DestructuringForm) arg).getLeft();\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+      parameterList.addChildToBack(name);\n     }\n+    args = args.getNext();\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+  functionObj.addChildToBack(parameterList);\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  functionObj.addChildToBack(transform(functionNode.getBody()));\n+\n+  if (functionNode.getLineno() != -1 && functionNode.getCharno() != -1) {\n+    functionObj.putProp(Node.SOURCENAME_PROP, sourceName);\n+    functionObj.putProp(Node.START_LINE_PROP, functionNode.getLineno());\n+    functionObj.putProp(Node.START_COLUMN_PROP, functionNode.getCharno());\n+  }\n+\n+  // set common function properties\n+  if (functionNode.getFunctionType() != FunctionNode.FUNCTION_STATEMENT) {\n+    JSDocInfo info = NodeUtil.getBestJSDocInfo(functionNode);\n+    if (info != null) {\n+      boolean suppressions = info.hasTypeAnnotations() ||\n+          info.hasReturnType() ||\n+          info.isConstructor() ||\n+          info.isInterface() ||\n+          !info.getImplementedInterfaces().isEmpty();\n+\n+      if (suppressions) {\n+        // functions with type annotations, interfaces, constructors or @return\n+        // do not receive ASSUME_* properties\n+        // because compiler does additional validation on their parameters and returns\n+        // which may not be correct.\n+        functionObj.putBooleanProp(Node.SUPPRESS_WARNINGS, true);\n       }\n-      return node;\n+      functionObj.setJSDocInfo(info);\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    Node parent = functionNode.getParent();\n+    if (parent == null) {\n+      checkForViolations(Parser.Config.StrictMode.under(functionObj), functionNode);\n+    } else if (parent.getType() == Token.CATCH) {\n+      // the catch block will check for its own violations\n+    } else if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION) {\n+      checkForViolations(Parser.Config.StrictMode.under(functionObj), functionNode.getParent());\n     }\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n+  return functionObj;\n+}\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+@Override\n+Node processInfixExpression(InfixExpression exprNode) {\n+  int type = rewriteInfixOperator(exprNode.getType());\n+  if (type == -1) {\n+    type = exprNode.getType();\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n-    }\n+  // For all operators other than OR and AND, we need to rewrite the left\n+  // and right values to boolean.\n+  if (type != Token.AND && type != Token.OR) {\n+    return createBinary(type, transformToBoolean(exprNode.getLeft()), transformToBoolean(exprNode.getRight()));\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  // For OR and AND, we only need to do the short circuiting if the other\n+  // operand is not a side-effect free boolean.\n+  Node leftNode = transform(exprNode.getLeft());\n+  Node rightNode = transform(exprNode.getRight());\n+  if (type == Token.AND) {\n+    return optimizeLogicalAnd(leftNode, rightNode);\n+  } else {\n+    return optimizeLogicalOr(leftNode, rightNode);\n+  }\n+}\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+@Override\n+Node processKeywordLiteral(KeywordLiteral literalNode) {\n+  Node n = newNode(literalNode.getType());\n+  switch (literalNode.getType()) {\n+    case Token.NULL:\n+    case Token.THIS:\n+      break;\n+    case Token.FALSE:\n+    case Token.TRUE:\n+      n.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n+      break;\n+    case Token.DEBUGGER:\n+      n.putBooleanProp(Node.DEBUGGER_GROUP, true);\n+      break;\n+  }\n+  return n;\n+}\n+\n+@Override\n+Node processName(Name nameNode) {\n+  return processNameHelper(nameNode);\n+}\n+\n+@Override\n+Node processNumber(NumberLiteral numberNode) {\n+  Node n = IRFactory.newNumber(numberNode.getNumber());\n+  n.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n+  return n;\n+}\n+\n+@Override\n+Node processObjectLiteral(ObjectLiteral objectNode) {\n+  Node objectLitNode = IRFactory.newNode(Token.OBJECTLIT);\n+\n+  for (Node propNode : transformObjectLiteral(objectNode)) {\n+    objectLitNode.addChildToBack(propNode);\n+  }\n+\n+  return objectLitNode;\n+}\n+\n+@Override\n+Node processParenthesizedExpression(ParenthesizedExpression node) {\n+  // Parentheses can be safely dropped if the child is side-effect free.\n+  Node child = transform(node.getExpression());\n+  if (child.isSideEffectFree()) {\n+    return maybeUnrollLoops(child);\n+  }\n+\n+  Node n = newNode(Token.WITH);\n+  n.setIsSyntheticBlock(true);\n+  // var $jscomp$with = ( <expr> , expr );\n+  // $jscomp$with is required so we can drop the trailing expression onto it.\n+  Node varNode = IRFactory.newNode(Token.VAR, IRFactory.newName(\"$jscomp$with\"), child);\n+  n.addChildToBack(varNode);\n+  // {$jscomp$with: <expr>, <next-statement>}\n+  Node withBlockNode = IRFactory.newNode(Token.BLOCK);\n+  withBlockNode.addChildToBack(\n+      IRFactory.newString(Token.STRING_KEY, \"$jscomp$with\"),\n+      IRFactory.newName(\"$jscomp$with\"));\n+  Node nextStatement = stripBlock(transform(node.getExpression()));\n+  if (nextStatement.getType() == Token.BLOCK) {\n+    for (Node child2 : nextStatement.children()) {\n+      withBlockNode.addChildToBack(child2);\n+    }\n+  } else {\n+    withBlockNode.addChildToBack(nextStatement);\n+  }\n+  n.addChildToBack(withBlockNode);\n+\n+  return n;\n+}\n+\n+@Override\n+Node processRegExpLiteral(RegExpLiteral literalNode) {\n+  Node node = IRFactory.newRegexp(literalNode.getValue(), literalNode.getFlags());\n+  node.putProp(Node.REGEXP_PROP, Boolean.TRUE);\n+  node.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n+  return node;\n+}\n+\n+@Override\n+Node processReturnStatement(ReturnStatement statementNode) {\n+  Node node = IRFactory.newNode(Token.RETURN);\n+  if (statementNode.getReturnValue() != null) {\n+    node.addChildToBack(transform(statementNode.getReturnValue()));\n+  }\n+  return node;\n+}\n+\n+@Override\n+Node processString(StringLiteral stringNode) {\n+  Node n = IRFactory.newString(stringNode.getValue());\n+  n.putBooleanProp(Node.SIDE_EFFECT_FREE, true);\n+  return n;\n+}\n+\n+@Override\n+Node processSwitchCase(SwitchCase caseNode) {\n+  Node caseObj = IRFactory.newNode(Token.CASE, transform(caseNode.getExpression()));\n+  for (AstNode statement : caseNode.getStatements()) {\n+    caseObj.addChildToBack(transform(statement));\n+  }\n+  return caseObj;\n+}\n+\n+@Override\n+Node processSwitchStatement(SwitchStatement statementNode) {\n+  Node switchObj = newNode(Token.SWITCH, transform(statementNode.getExpression()));\n+  for (SwitchCase caseNode : statementNode.getCases()) {\n+    switchObj.addChildToBack(transform(caseNode));\n+  }\n+  return switchObj;\n+}\n+\n+@Override\n+Node processThrowStatement(ThrowStatement statementNode) {\n+  return IRFactory.newNode(Token.THROW, transform(statementNode.getExpression()));\n+}\n+\n+@Override\n+Node processTryStatement(TryStatement statementNode) {\n+  Node node = IRFactory.newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+  if (statementNode.getCatchClauses() != null) {\n+    for (CatchClause catchClause : statementNode.getCatchClauses()) {\n+      node.addChildToBack(transform(catchClause));\n     }\n+  }\n+  if (statementNode.getFinallyBlock() != null) {\n+    node.addChildToBack(newNode(Token.FINALLY, transformBlock(statementNode.getFinallyBlock())));\n+  }\n+  return node;\n+}\n+\n+@Override\n+Node processUnaryExpression(UnaryExpression exprNode) {\n+  int typ\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}