{
    "patch": "protected UnivariatePointValuePair doOptimize() {\n        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n        final double lo = getMin();\n        final double mid = getStartValue();\n        final double hi = getMax();\n\n        // Optional additional convergence criteria.\n        final ConvergenceChecker<UnivariatePointValuePair> checker\n            = getConvergenceChecker();\n\n        double a;\n        double b;\n        if (lo < hi) {\n            a = lo;\n            b = hi;\n        } else {\n            a = hi;\n            b = lo;\n        }\n\n        double x = mid;\n        double v = x;\n        double w = x;\n        double d = 0;\n        double e = 0;\n        double fx = computeObjectiveValue(x);\n        if (!isMinim) {\n            fx = -fx;\n        }\n        double fv = fx;\n        double fw = fx;\n\n        UnivariatePointValuePair previous = null;\n        UnivariatePointValuePair current\n            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n\n        UnivariatePointValuePair best = current;\n\n        int iter = 0;\n        while (true) {\n            final double m = 0.5 * (a + b);\n            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n            final double tol2 = 2 * tol1;\n\n            // Determine which pseudo step to take\n            double next;\n            if (FastMath.abs(e) > tol1) { // Fit quadratic\n                final double r = (x - w) * (fx - fv);\n                final double q = (x - v) * (fx - fw);\n                final double p = (x - v) * q - (x - w) * r;\n                q *= 2;\n                if (p > 0) {\n                    q = -q;\n                }\n                p = FastMath.abs(p);\n                final double etemp = e;\n                e = d;\n                if (p >= FastMath.abs(0.5 * q * etemp) ||\n                        p <= q * (a - x) ||\n                        p >= q * (b - x)) {\n                    // Take golden section step\n                    if (x >= m) {\n                        e = a - x;\n                    } else {\n                        e = b - x;\n                    }\n                    d = GOLDEN_SECTION * e;\n                } else {\n                    // Take parabolic step\n                    d = p / q;\n                    next = x + d;\n                    if (next - a < tol2 || b - next < tol2) {\n                        if (x >= m) {\n                            d = -tol1;\n                        } else {\n                            d = tol1;\n                        }\n                    }\n                }\n            } else {\n                // Take golden section step\n                if (x >= m) {\n                    e = a - x;\n                } else {\n                    e = b - x;\n                }\n                d = GOLDEN_SECTION * e;\n            }\n\n            if (FastMath.abs(d) >= tol1) {\n                next = x + d;\n            } else {\n                if (d > 0) {\n                    next = x + tol1;\n                } else {\n                    next = x - tol1;\n                }\n            }\n\n            final double fnext = computeObjectiveValue(next);\n            if (!isMinim) {\n                fx = -fx;\n            }\n\n            previous = current;\n            current = new UnivariatePointValuePair(next, isMinim ? fnext : -fnext);\n\n            // Update the best point found so far\n            if (current.getValue() < best.getValue()) {\n                best = current;\n            }\n\n            if (checker != null) {\n                if (checker.converged(iter, previous, current)) {\n                    return best;\n                }\n            }\n\n            if (next > x) {\n                a = x;\n            } else {\n                b = x;\n            }\n\n            if (fnext <= fv) {\n                if (next > x) {\n                    w = x;\n                } else {\n                    v = x;\n                }\n                fv = fw;\n                fw = fx;\n                x = next;\n                fx = fnext;\n            } else {\n                if (next > x) {\n                    v = next;\n                } else {\n                    w = next;\n                }\n                if (fnext <= fw || FastMath.abs(w - x) < Precision.SAFE_MIN) {\n                    fv = fw;\n                    fw = fnext;\n                } else if (fnext <= fv || FastMath.abs(v - x) < Precision.SAFE_MIN ||\n                        FastMath.abs(v - w) < Precision.SAFE_MIN) {\n                    fv = fnext;\n                }\n            }\n\n            iter++;\n        }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex b6ce68ef3..cae29d83d 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -106,7 +106,7 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariatePointValuePair doOptimize() {\n+protected UnivariatePointValuePair doOptimize() {\n         final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n         final double lo = getMin();\n         final double mid = getStartValue();\n@@ -142,131 +142,120 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n         UnivariatePointValuePair current\n             = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n \n+        UnivariatePointValuePair best = current;\n+\n         int iter = 0;\n         while (true) {\n             final double m = 0.5 * (a + b);\n             final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n             final double tol2 = 2 * tol1;\n \n-            // Default stopping criterion.\n-            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n-            if (!stop) {\n-                double p = 0;\n-                double q = 0;\n-                double r = 0;\n-                double u = 0;\n-\n-                if (FastMath.abs(e) > tol1) { // Fit parabola.\n-                    r = (x - w) * (fx - fv);\n-                    q = (x - v) * (fx - fw);\n-                    p = (x - v) * q - (x - w) * r;\n-                    q = 2 * (q - r);\n-\n-                    if (q > 0) {\n-                        p = -p;\n+            // Determine which pseudo step to take\n+            double next;\n+            if (FastMath.abs(e) > tol1) { // Fit quadratic\n+                final double r = (x - w) * (fx - fv);\n+                final double q = (x - v) * (fx - fw);\n+                final double p = (x - v) * q - (x - w) * r;\n+                q *= 2;\n+                if (p > 0) {\n+                    q = -q;\n+                }\n+                p = FastMath.abs(p);\n+                final double etemp = e;\n+                e = d;\n+                if (p >= FastMath.abs(0.5 * q * etemp) ||\n+                        p <= q * (a - x) ||\n+                        p >= q * (b - x)) {\n+                    // Take golden section step\n+                    if (x >= m) {\n+                        e = a - x;\n                     } else {\n-                        q = -q;\n+                        e = b - x;\n                     }\n-\n-                    r = e;\n-                    e = d;\n-\n-                    if (p > q * (a - x) &&\n-                        p < q * (b - x) &&\n-                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n-                        // Parabolic interpolation step.\n-                        d = p / q;\n-                        u = x + d;\n-\n-                        // f must not be evaluated too close to a or b.\n-                        if (u - a < tol2 || b - u < tol2) {\n-                            if (x <= m) {\n-                                d = tol1;\n-                            } else {\n-                                d = -tol1;\n-                            }\n-                        }\n-                    } else {\n-                        // Golden section step.\n-                        if (x < m) {\n-                            e = b - x;\n+                    d = GOLDEN_SECTION * e;\n+                } else {\n+                    // Take parabolic step\n+                    d = p / q;\n+                    next = x + d;\n+                    if (next - a < tol2 || b - next < tol2) {\n+                        if (x >= m) {\n+                            d = -tol1;\n                         } else {\n-                            e = a - x;\n+                            d = tol1;\n                         }\n-                        d = GOLDEN_SECTION * e;\n                     }\n+                }\n+            } else {\n+                // Take golden section step\n+                if (x >= m) {\n+                    e = a - x;\n                 } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n+                    e = b - x;\n                 }\n+                d = GOLDEN_SECTION * e;\n+            }\n \n-                // Update by at least \"tol1\".\n-                if (FastMath.abs(d) < tol1) {\n-                    if (d >= 0) {\n-                        u = x + tol1;\n-                    } else {\n-                        u = x - tol1;\n-                    }\n+            if (FastMath.abs(d) >= tol1) {\n+                next = x + d;\n+            } else {\n+                if (d > 0) {\n+                    next = x + tol1;\n                 } else {\n-                    u = x + d;\n+                    next = x - tol1;\n                 }\n+            }\n \n-                double fu = computeObjectiveValue(u);\n-                if (!isMinim) {\n-                    fu = -fu;\n-                }\n+            final double fnext = computeObjectiveValue(next);\n+            if (!isMinim) {\n+                fx = -fx;\n+            }\n \n-                // User-defined convergence checker.\n-                previous = current;\n-                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+            previous = current;\n+            current = new UnivariatePointValuePair(next, isMinim ? fnext : -fnext);\n \n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return current;\n-                    }\n+            // Update the best point found so far\n+            if (current.getValue() < best.getValue()) {\n+                best = current;\n+            }\n+\n+            if (checker != null) {\n+                if (checker.converged(iter, previous, current)) {\n+                    return best;\n                 }\n+            }\n \n-                // Update a, b, v, w and x.\n-                if (fu <= fx) {\n-                    if (u < x) {\n-                        b = x;\n-                    } else {\n-                        a = x;\n-                    }\n-                    v = w;\n-                    fv = fw;\n+            if (next > x) {\n+                a = x;\n+            } else {\n+                b = x;\n+            }\n+\n+            if (fnext <= fv) {\n+                if (next > x) {\n                     w = x;\n-                    fw = fx;\n-                    x = u;\n-                    fx = fu;\n                 } else {\n-                    if (u < x) {\n-                        a = u;\n-                    } else {\n-                        b = u;\n-                    }\n-                    if (fu <= fw ||\n-                        Precision.equals(w, x)) {\n-                        v = w;\n-                        fv = fw;\n-                        w = u;\n-                        fw = fu;\n-                    } else if (fu <= fv ||\n-                               Precision.equals(v, x) ||\n-                               Precision.equals(v, w)) {\n-                        v = u;\n-                        fv = fu;\n-                    }\n+                    v = x;\n+                }\n+                fv = fw;\n+                fw = fx;\n+                x = next;\n+                fx = fnext;\n+            } else {\n+                if (next > x) {\n+                    v = next;\n+                } else {\n+                    w = next;\n+                }\n+                if (fnext <= fw || FastMath.abs(w - x) < Precision.SAFE_MIN) {\n+                    fv = fw;\n+                    fw = fnext;\n+                } else if (fnext <= fv || FastMath.abs(v - x) < Precision.SAFE_MIN ||\n+                        FastMath.abs(v - w) < Precision.SAFE_MIN) {\n+                    fv = fnext;\n                 }\n-            } else { // Default termination (Brent's criterion).\n-                return current;\n             }\n-            ++iter;\n+\n+            iter++;\n         }\n     }\n ",
    "result_reason": "error: cannot assign a value to final variable q",
    "test_result": "ERROR"
}