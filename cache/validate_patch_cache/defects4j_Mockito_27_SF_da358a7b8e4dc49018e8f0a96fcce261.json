{
    "patch": "import org.mockito.internal.creation.bytebuddy.MocksBytecodeGenerator;\nimport org.mockito.internal.handler.MockHandlerInterface;\nimport org.mockito.internal.handler.MockHandler;\nimport org.mockito.internal.creation.bytebuddy.MockAccess;\nimport org.mockito.internal.invocation.InvocationDispatcher;\nimport org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\nimport org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker;\nimport org.mockito.internal.util.MockUtil;\nimport org.mockito.invocation.InvocationOnMock;\nimport org.mockito.invocation.Location;\nimport org.mockito.invocation.MockHandlerFactory;\nimport org.mockito.plugins.MockMaker;\nimport org.mockito.stubbing.Answer;\nimport org.mockito.stubbing.InvocationOnMockImpl;\nimport org.mockito.internal.stubbing.answers.Returns;\nimport org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\nimport org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;\nimport org.mockito.internal.stubbing.defaultanswers.TriesToReturnSelf;\nimport org.mockito.internal.stubbing.defaultanswers.ThrowsException;\nimport net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\nimport net.bytebuddy.DynamicType.Builder;\nimport net.bytebuddy.asm.Advice;\nimport net.bytebuddy.matcher.ElementMatchers;\nimport net.bytebuddy.ByteBuddy;\nimport net.bytebuddy.TypeCache;\nimport net.bytebuddy.description.type.TypeDescription;\nimport net.bytebuddy.implementation.MethodDelegation;\nimport net.bytebuddy.implementation.FixedValue;\nimport net.bytebuddy.implementation.MethodCall;\nimport net.bytebuddy.implementation.bytecode.ByteCodeAppender;\nimport net.bytebuddy.implementation.bytecode.member.MethodInvocation;\nimport net.bytebuddy.matcher.ElementMatcher;\nimport net.bytebuddy.matcher.ElementMatchers;\n\npublic <T> void resetMock(T mock, InvocationListener invocationListener) throws Exception {\n    MockUtil mockUtil = new MockUtil();\n    if (!mockUtil.isMock(mock)) {\n        throw new IllegalArgumentException(\"Object is not a mock!\");\n    }\n    MockHandlerInterface<T> oldMockHandler = mockUtil.getMockHandler(mock);\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    newMockHandler.setInvocationListener(invocationListener);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n    MockBytecodeGenerator bytecodeGenerator = new MockBytecodeGenerator();\n    Class<? extends T> mockClass = bytecodeGenerator.generateMockClass(mock);\n    ((MockAccess<T>) mock).setMockitoInterceptor(newFilter);\n    ((MockAccess<T>) mock).setMockitoInterceptorChain(newFilter);\n}\n\nclass MockBytecodeGenerator extends MocksBytecodeGenerator {\n    private final ByteBuddy byteBuddy;\n    private final MockMaker.MatcherAndResult mockClassCache;\n    private final TypeCache<Object> typeCache;\n    public MockBytecodeGenerator() {\n        typeCache = new TypeCache<Object>(TypeCache.Sort.WEAKEST);\n        mockClassCache = new MockMaker.MatcherAndResult();\n        byteBuddy = new ByteBuddy()\n            .with(new ByteBuddy()\n                .with(ClassLoadingStrategy.Default.INJECTION)\n                .with(new ListenerInjection())\n            );\n    }\n\n    @SuppressWarnings(\"unchecked\")\n    <T> Class<? extends T> generateMockClass(T mock) {\n        MockMaker.MatcherAndResult existing = mockClassCache.get(TypeDescription.ForLoadedType.of(mock.getClass()));\n        if (existing != null && existing.matches(TypeDescription.ForLoadedType.of(mock.getClass()))) {\n            return (Class<? extends T>) existing.result;\n        }\n        return generate(mock);\n    }\n\n    private <T> Class<? extends T> generate(T mock) {\n        TypeDescription rawType = TypeDescription.ForLoadedType.of(mock.getClass()).asRawType();\n        ElementMatcher.Junction<TypeDescription> matcher = ElementMatchers.is(rawType);\n        Builder<T> builder = byteBuddy.subclass(mock.getClass())\n                .method(MockMethodInterceptor.METHOD_INTERCEPTOR_METHOD)\n                .intercept(MethodDelegation.to(MockMethodInterceptor.class))\n                .implement(MockAccess.class)\n                .intercept(MethodDelegation.to(new MockAccessImplementation<T>()) );\n\n        Class<? extends T> dynamicType = builder\n                .make()\n                .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n                .getLoaded();\n\n        mockClassCache.add(mock.getClass(), matcher, dynamicType);\n        return dynamicType;\n    }\n\n    private static class MockAccessImplementation<T> {\n        @SuppressWarnings(\"unused\")\n        public static MockHandler<T> getMockitoHandler(T mock) {\n            MockAccess<T> access = (MockAccess<T>) mock;\n            return (MockHandler<T>) access.getMockitoInterceptor();\n        }\n\n        @SuppressWarnings(\"unused\")\n        public static void setMockitoHandler(T mock, MockHandler<T> newHandler) {\n            MockAccess<T> access = (MockAccess<T>) mock;\n            access.setMockitoInterceptor(newHandler);\n        }\n\n        @SuppressWarnings(\"unused\")\n        public static void setInvocationListener(T mock, InvocationListener listener) {\n            MockHandler<T> handler = getMockitoHandler(mock);\n            handler.setInvocationListener(listener);\n        }\n    }\n}\n\nclass MockMethodInterceptor {\n    public static final String METHOD_INTERCEPTOR_METHOD = \"intercept\";\n    public static final String METHOD_INTERCEPTOR_SIGNATURE = \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;Lorg/mockito/internal/invocation/RealMethod;Ljava/lang/Object;)Ljava/lang/Object;\";\n\n    @SuppressWarnings({\"unused\", \"rawtypes\"})\n    @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)\n    public static Object enter(\n            @Advice.This(optional = true) Object mock,\n            @Advice.AllArguments Object[] arguments,\n            @Advice.FieldValue(\"mockHandler\") MockHandler mockHandler,\n            @Advice.Origin Method origin,\n            @Advice.FieldValue(\"globalConfiguration\") GlobalConfiguration globalConfiguration,\n            @Advice.FieldValue(\"dispatcher\") InvocationDispatcher dispatcher,\n            @Advice.Argument(0) boolean isStatic,\n            @Advice.Argument(1) Class<?> declaringClass,\n            @Advice.Argument(2) String methodName,\n            @Advice.Argument(3) String methodDesc,\n            @Advice.Argument(4) Object[] methodArgs) throws Throwable {\n\n        MockitoSession session = Mockito.framework().session();\n        Location location = session.getMockitoContext().getLocation();\n        org.mockito.invocation.MockInvocation invocation = new InvocationOnMockImpl(\n                mockHandler, origin, arguments, location\n        );\n        if (mockHandler.getInvocationListener() != null) {\n            Object returnValue = dispatcher.handle(invocation);\n            org.mockito.invocation.InvocationMatcher matcher = new org.mockito.internal.invocation.MatchersBinder()\n                    .bindMatchers(\n                            declaringClass.getName() + \".\" + methodName +\n                            mockHandler.getInvocationNumber(), mockHandler.getMatchers()\n                    );\n            org.mockito.invocation.Invocation tempInvocation = new org.mockito.internal.invocation.InvocationImpl(\n                    invocation.getMock(),\n                    matcher,\n                    invocation.rawArguments(),\n                    invocation.getRealMethod(),\n                    invocation.getLocation());\n            org.mockito.internal.reporting.InvocationReporter invocationReporter =\n                    new org.mockito.internal.reporting.InvocationReporter(\n                            mockHandler.getMockSettings().getMockCreationSettings().isPrintStackTrace()\n                    );\n            invocationReporter.invocationReported(tempInvocation, returnValue);\n            Object[] args = {new MethodInvocationReport(\n                    invocation.getMock(),\n                    tempInvocation,\n                    returnValue,\n                    null\n            )};\n            mockHandler.getInvocationListener().reportInvocation((MethodInvocationReport)args[0]);\n            return returnValue;\n        }\n        return null;\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..43f9e51e5 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,172 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.internal.creation.bytebuddy.MocksBytecodeGenerator;\n+import org.mockito.internal.handler.MockHandlerInterface;\n+import org.mockito.internal.handler.MockHandler;\n+import org.mockito.internal.creation.bytebuddy.MockAccess;\n+import org.mockito.internal.invocation.InvocationDispatcher;\n+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\n+import org.mockito.internal.creation.bytebuddy.ByteBuddyMockMaker;\n+import org.mockito.internal.util.MockUtil;\n+import org.mockito.invocation.InvocationOnMock;\n+import org.mockito.invocation.Location;\n+import org.mockito.invocation.MockHandlerFactory;\n+import org.mockito.plugins.MockMaker;\n+import org.mockito.stubbing.Answer;\n+import org.mockito.stubbing.InvocationOnMockImpl;\n+import org.mockito.internal.stubbing.answers.Returns;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsEmptyValues;\n+import org.mockito.internal.stubbing.defaultanswers.ReturnsMoreEmptyValues;\n+import org.mockito.internal.stubbing.defaultanswers.TriesToReturnSelf;\n+import org.mockito.internal.stubbing.defaultanswers.ThrowsException;\n+import net.bytebuddy.dynamic.loading.ClassLoadingStrategy;\n+import net.bytebuddy.DynamicType.Builder;\n+import net.bytebuddy.asm.Advice;\n+import net.bytebuddy.matcher.ElementMatchers;\n+import net.bytebuddy.ByteBuddy;\n+import net.bytebuddy.TypeCache;\n+import net.bytebuddy.description.type.TypeDescription;\n+import net.bytebuddy.implementation.MethodDelegation;\n+import net.bytebuddy.implementation.FixedValue;\n+import net.bytebuddy.implementation.MethodCall;\n+import net.bytebuddy.implementation.bytecode.ByteCodeAppender;\n+import net.bytebuddy.implementation.bytecode.member.MethodInvocation;\n+import net.bytebuddy.matcher.ElementMatcher;\n+import net.bytebuddy.matcher.ElementMatchers;\n+\n+public <T> void resetMock(T mock, InvocationListener invocationListener) throws Exception {\n+    MockUtil mockUtil = new MockUtil();\n+    if (!mockUtil.isMock(mock)) {\n+        throw new IllegalArgumentException(\"Object is not a mock!\");\n+    }\n+    MockHandlerInterface<T> oldMockHandler = mockUtil.getMockHandler(mock);\n+    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n+    newMockHandler.setInvocationListener(invocationListener);\n+    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n+    MockBytecodeGenerator bytecodeGenerator = new MockBytecodeGenerator();\n+    Class<? extends T> mockClass = bytecodeGenerator.generateMockClass(mock);\n+    ((MockAccess<T>) mock).setMockitoInterceptor(newFilter);\n+    ((MockAccess<T>) mock).setMockitoInterceptorChain(newFilter);\n+}\n+\n+class MockBytecodeGenerator extends MocksBytecodeGenerator {\n+    private final ByteBuddy byteBuddy;\n+    private final MockMaker.MatcherAndResult mockClassCache;\n+    private final TypeCache<Object> typeCache;\n+    public MockBytecodeGenerator() {\n+        typeCache = new TypeCache<Object>(TypeCache.Sort.WEAKEST);\n+        mockClassCache = new MockMaker.MatcherAndResult();\n+        byteBuddy = new ByteBuddy()\n+            .with(new ByteBuddy()\n+                .with(ClassLoadingStrategy.Default.INJECTION)\n+                .with(new ListenerInjection())\n+            );\n+    }\n+\n+    @SuppressWarnings(\"unchecked\")\n+    <T> Class<? extends T> generateMockClass(T mock) {\n+        MockMaker.MatcherAndResult existing = mockClassCache.get(TypeDescription.ForLoadedType.of(mock.getClass()));\n+        if (existing != null && existing.matches(TypeDescription.ForLoadedType.of(mock.getClass()))) {\n+            return (Class<? extends T>) existing.result;\n+        }\n+        return generate(mock);\n+    }\n+\n+    private <T> Class<? extends T> generate(T mock) {\n+        TypeDescription rawType = TypeDescription.ForLoadedType.of(mock.getClass()).asRawType();\n+        ElementMatcher.Junction<TypeDescription> matcher = ElementMatchers.is(rawType);\n+        Builder<T> builder = byteBuddy.subclass(mock.getClass())\n+                .method(MockMethodInterceptor.METHOD_INTERCEPTOR_METHOD)\n+                .intercept(MethodDelegation.to(MockMethodInterceptor.class))\n+                .implement(MockAccess.class)\n+                .intercept(MethodDelegation.to(new MockAccessImplementation<T>()) );\n+\n+        Class<? extends T> dynamicType = builder\n+                .make()\n+                .load(getClass().getClassLoader(), ClassLoadingStrategy.Default.WRAPPER)\n+                .getLoaded();\n+\n+        mockClassCache.add(mock.getClass(), matcher, dynamicType);\n+        return dynamicType;\n+    }\n+\n+    private static class MockAccessImplementation<T> {\n+        @SuppressWarnings(\"unused\")\n+        public static MockHandler<T> getMockitoHandler(T mock) {\n+            MockAccess<T> access = (MockAccess<T>) mock;\n+            return (MockHandler<T>) access.getMockitoInterceptor();\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        public static void setMockitoHandler(T mock, MockHandler<T> newHandler) {\n+            MockAccess<T> access = (MockAccess<T>) mock;\n+            access.setMockitoInterceptor(newHandler);\n+        }\n+\n+        @SuppressWarnings(\"unused\")\n+        public static void setInvocationListener(T mock, InvocationListener listener) {\n+            MockHandler<T> handler = getMockitoHandler(mock);\n+            handler.setInvocationListener(listener);\n+        }\n+    }\n+}\n+\n+class MockMethodInterceptor {\n+    public static final String METHOD_INTERCEPTOR_METHOD = \"intercept\";\n+    public static final String METHOD_INTERCEPTOR_SIGNATURE = \"(Ljava/lang/Object;Ljava/lang/reflect/Method;[Ljava/lang/Object;Lorg/mockito/internal/invocation/RealMethod;Ljava/lang/Object;)Ljava/lang/Object;\";\n+\n+    @SuppressWarnings({\"unused\", \"rawtypes\"})\n+    @Advice.OnMethodEnter(skipOn = Advice.OnNonDefaultValue.class)\n+    public static Object enter(\n+            @Advice.This(optional = true) Object mock,\n+            @Advice.AllArguments Object[] arguments,\n+            @Advice.FieldValue(\"mockHandler\") MockHandler mockHandler,\n+            @Advice.Origin Method origin,\n+            @Advice.FieldValue(\"globalConfiguration\") GlobalConfiguration globalConfiguration,\n+            @Advice.FieldValue(\"dispatcher\") InvocationDispatcher dispatcher,\n+            @Advice.Argument(0) boolean isStatic,\n+            @Advice.Argument(1) Class<?> declaringClass,\n+            @Advice.Argument(2) String methodName,\n+            @Advice.Argument(3) String methodDesc,\n+            @Advice.Argument(4) Object[] methodArgs) throws Throwable {\n+\n+        MockitoSession session = Mockito.framework().session();\n+        Location location = session.getMockitoContext().getLocation();\n+        org.mockito.invocation.MockInvocation invocation = new InvocationOnMockImpl(\n+                mockHandler, origin, arguments, location\n+        );\n+        if (mockHandler.getInvocationListener() != null) {\n+            Object returnValue = dispatcher.handle(invocation);\n+            org.mockito.invocation.InvocationMatcher matcher = new org.mockito.internal.invocation.MatchersBinder()\n+                    .bindMatchers(\n+                            declaringClass.getName() + \".\" + methodName +\n+                            mockHandler.getInvocationNumber(), mockHandler.getMatchers()\n+                    );\n+            org.mockito.invocation.Invocation tempInvocation = new org.mockito.internal.invocation.InvocationImpl(\n+                    invocation.getMock(),\n+                    matcher,\n+                    invocation.rawArguments(),\n+                    invocation.getRealMethod(),\n+                    invocation.getLocation());\n+            org.mockito.internal.reporting.InvocationReporter invocationReporter =\n+                    new org.mockito.internal.reporting.InvocationReporter(\n+                            mockHandler.getMockSettings().getMockCreationSettings().isPrintStackTrace()\n+                    );\n+            invocationReporter.invocationReported(tempInvocation, returnValue);\n+            Object[] args = {new MethodInvocationReport(\n+                    invocation.getMock(),\n+                    tempInvocation,\n+                    returnValue,\n+                    null\n+            )};\n+            mockHandler.getInvocationListener().reportInvocation((MethodInvocationReport)args[0]);\n+            return returnValue;\n+        }\n+        return null;\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}