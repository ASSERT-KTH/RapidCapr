{
    "patch": "public static String unescape(String s){\n    StringBuffer sbuf = new StringBuffer ();    \n    int l  = s.length();\n    int ch = -1;\n    int b, sumb = 0;    \n    for (int i = 0, more = -1; i < l; i++) { /* loop over all characters in the string */\n      /* Fill the byte or character array \"buf\" for whatever\n         encoding scheme is desired */\n      switch (ch = s.charAt(i)) {\n        case '%':\n          ch = s.charAt (++i);\n          int hb = (Character.isDigit ((char) ch)\n                        ? ch - '0'\n                        : 10+Character.toLowerCase((char) ch) - 'a') & 0xF;\n          ch = s.charAt (++i);\n          int lb = (Character.isDigit ((char) ch)\n                        ? ch - '0'\n                        : 10+Character.toLowerCase((char) ch) - 'a') & 0xF;\n          b = (hb << 4) | lb;\n          break;\n          /* Handle those characters that should be escaped\n             to avoid detection as a delimiter */\n        case '+':\n          b = ' ';\n          break;\n        case '\\\\':\n          ch = s.charAt (++i);\n          if (ch == 'n') {\n            b = '\\n';\n          } else if (ch == 'r') {\n            b = '\\r';\n          } else if (ch == 't') {\n            b = '\\t';\n          } else if (ch == 'f') {\n            b = '\\f';\n          } else if (ch == '\\r') {\n            if (s.charAt(i + 1) == '\\n') {\n              i++;\n            }\n            b = -1;\n          } else if (ch == '\\n') {\n            b = -1;\n          } else {\n            b = ch;\n          }\n          break;\n        default:\n          b = ch;\n          break;\n      }\n      /* Decode byte b as UTF-16 character c */\n      if ((b & 0xc0) == 0x80) {          // 10xxxxxx (continuation byte)\n        sumb = (sumb << 6) | (b & 0x3f); // Add 6 bits to sumb\n        if (--more == 0) {\n          sbuf.append ((char) sumb); // Add character to sbuf\n        }\n      } else if ((b & 0x80) == 0x00) {   // 0xxxxxxx (yields 7 bits)\n        sbuf.append ((char) b);         // Store in sbuf\n      } else if ((b & 0xe0) == 0xc0) {   // 110xxxxx (yields 5 bits)\n        sumb = b & 0x1f;\n        more = 1;                       // Expect 1 more byte\n      } else if ((b & 0xf0) == 0xe0) {   // 1110xxxx (yields 4 bits)\n        sumb = b & 0x0f;\n        more = 2;                       // Expect 2 more bytes\n      } else if ((b & 0xf8) == 0xf0) {   // 11110xxx (yields 3 bits)\n        sumb = b & 0x07;\n        more = 3;                       // Expect 3 more bytes\n      } else if ((b & 0xfc) == 0xf8) {   // 111110xx (yields 2 bits)\n        sumb = b & 0x03;\n        more = 4;                       // Expect 4 more bytes\n      } else /*if ((b & 0xfe) == 0xfc)*/ { // 1111110x (yields 1 bit)\n        sumb = b & 0x01;\n        more = 5;                       // Expect 5 more bytes\n      }\n      /* We don't test if the UTF-16 encoding is well-formed */\n    }\n    return sbuf.toString ();\n  }  ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\nindex 8caca580..5033afe0 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/EntityArrays.java\n@@ -27,7 +27,7 @@ package org.apache.commons.lang3.text.translate;\n  */\n public class EntityArrays {\n \n-    public static String[][] ISO8859_1_ESCAPE() { return ISO8859_1_ESCAPE.clone(); }\n+\n     private static final String[][] ISO8859_1_ESCAPE = {\n         {\"\\u00A0\", \"&nbsp;\"}, // non-breaking space\n         {\"\\u00A1\", \"&iexcl;\"}, // inverted exclamation mark",
    "result_reason": "error: operand expected (error token is \"=\")",
    "test_result": "ERROR"
}