{
    "patch": "        double x0 = min;\n        double y0 = yMin;\n        double x2 = max;\n        double y2 = yMax;\n        double x1 = initial;\n        double y1 = yInitial;\n        double ydiff = y2 - y1;\n        double xdiff = x2 - x1;\n        double tolerance = getAbsoluteAccuracy() + getRelativeAccuracy() * Math.max(Math.abs(x1), Math.abs(x2));\n        double delta = oldDelta;\n        while (true) {\n            if (Math.abs(ydiff) < Math.abs(y1 - y0)) {\n                // Start with the secant rule and, if near enough to root, use\n                // the bisection routine;\n                if (xdiff != oldDiff && oldX != x0) {\n                    delta = xdiff * y1 / (ydiff - y1);\n                } else {\n                    delta = (x1 - x0) / 2.0;\n                }\n                xdiff = oldDiff;\n                oldDiff = delta;\n            } else {\n                // The modified regula falsi method:\n                delta = (x1 - x0) / 2.0;\n                xdiff = oldDiff;\n                oldDiff = delta;\n            }\n            double x = x1 + delta;\n            double y = f.value(x);\n            ++evaluations;\n            if (Math.abs(y) < functionValueAccuracy) {\n                setResult(x, evaluations);\n                return result;\n            }\n            if (y * y1 < 0) {\n                x0 = x1;\n                y0 = y1;\n                oldX = x1;\n                ydiff = y1 - y;\n            } else {\n                if (y * y0 < 0) {\n                    x1 = x0;\n                    y1 = y0;\n                    oldX = x0;\n                    ydiff = y - y0;\n                } else {\n                    if (ydiff * y < 0) {\n                        y0 = y1;\n                        x0 = x1;\n                        y1 = y;\n                        x1 = x;\n                    } else {\n                        if (xdiff < tolerance) {\n                            setResult(x1, evaluations);\n                            return result;\n                        }\n                        oldDiff = xdiff;\n                        xdiff = x1 - oldX;\n                        oldX = x1;\n                        ydiff = y1 - y;\n                    }\n                }\n            }\n            if (++count > maximalIterationCount) {\n                throw new MaxIterationsExceededException(maximalIterationCount);\n            }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..ef470afbb 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,72 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        double x0 = min;\n+        double y0 = yMin;\n+        double x2 = max;\n+        double y2 = yMax;\n+        double x1 = initial;\n+        double y1 = yInitial;\n+        double ydiff = y2 - y1;\n+        double xdiff = x2 - x1;\n+        double tolerance = getAbsoluteAccuracy() + getRelativeAccuracy() * Math.max(Math.abs(x1), Math.abs(x2));\n+        double delta = oldDelta;\n+        while (true) {\n+            if (Math.abs(ydiff) < Math.abs(y1 - y0)) {\n+                // Start with the secant rule and, if near enough to root, use\n+                // the bisection routine;\n+                if (xdiff != oldDiff && oldX != x0) {\n+                    delta = xdiff * y1 / (ydiff - y1);\n+                } else {\n+                    delta = (x1 - x0) / 2.0;\n+                }\n+                xdiff = oldDiff;\n+                oldDiff = delta;\n+            } else {\n+                // The modified regula falsi method:\n+                delta = (x1 - x0) / 2.0;\n+                xdiff = oldDiff;\n+                oldDiff = delta;\n+            }\n+            double x = x1 + delta;\n+            double y = f.value(x);\n+            ++evaluations;\n+            if (Math.abs(y) < functionValueAccuracy) {\n+                setResult(x, evaluations);\n+                return result;\n+            }\n+            if (y * y1 < 0) {\n+                x0 = x1;\n+                y0 = y1;\n+                oldX = x1;\n+                ydiff = y1 - y;\n+            } else {\n+                if (y * y0 < 0) {\n+                    x1 = x0;\n+                    y1 = y0;\n+                    oldX = x0;\n+                    ydiff = y - y0;\n+                } else {\n+                    if (ydiff * y < 0) {\n+                        y0 = y1;\n+                        x0 = x1;\n+                        y1 = y;\n+                        x1 = x;\n+                    } else {\n+                        if (xdiff < tolerance) {\n+                            setResult(x1, evaluations);\n+                            return result;\n+                        }\n+                        oldDiff = xdiff;\n+                        xdiff = x1 - oldX;\n+                        oldX = x1;\n+                        ydiff = y1 - y;\n+                    }\n+                }\n+            }\n+            if (++count > maximalIterationCount) {\n+                throw new MaxIterationsExceededException(maximalIterationCount);\n+            }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}