{
    "patch": "          switch (parent.getType()) {\n              // The follow() of any of the path from IF would be what follows IF.\n            case Token.IF:\n              return computeFollowNode(fromNode, parent, cfa);\n            case Token.CASE:\n            case Token.DEFAULT_CASE:\n              // After the body of a CASE, the control goes to the body of the next\n              // case, without having to go to the case condition.\n              if (parent.getNext() != null) {\n                if (parent.getNext().isCase()) {\n                  return parent.getNext().getFirstChild().getNext();\n                } else if (parent.getNext().isDefaultCase()) {\n                  return parent.getNext().getFirstChild();\n                } else {\n                  Preconditions.checkState(false, \"Not reachable\");\n                }\n              } else {\n                return computeFollowNode(fromNode, parent, cfa);\n              }\n            case Token.FOR:\n              Node grandparent = parent.getParent();\n              if (grandparent != null && grandparent.isVanillaFor()) {\n                return grandparent.getLastChild();\n              } else if (NodeUtil.isForIn(parent)) {\n                return parent;\n              } else {\n                return parent.getFirstChild().getNext().getNext();\n              }\n            case Token.WHILE:\n            case Token.DO:\n              return parent;\n            case Token.TRY:\n              // If we are coming out of the TRY block...\n              if (parent.getFirstChild() == node) {\n                if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n                  return computeFallThrough(parent.getLastChild());\n                } else { // and have no FINALLY.\n                  return computeFollowNode(fromNode, parent, cfa);\n                }\n              // CATCH block.\n              } else if (NodeUtil.getCatchBlock(parent) == node){\n                if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n                  return computeFallThrough(node.getNext());\n                } else {\n                  return computeFollowNode(fromNode, parent, cfa);\n                }\n              // If we are coming out of the FINALLY block...\n              } else if (parent.getLastChild() == node){\n                if (cfa != null) {\n                  for (Node finallyNode : cfa.finallyMap.get(parent)) {\n                    cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n                    computeFollowNode(fromNode, finallyNode, cfa);\n                  }\n                }\n                return computeFollowNode(fromNode, parent, cfa);\n              }\n          }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\nindex 5c6927f9..b8b4f7e9 100644\n--- a/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n+++ b/src/com/google/javascript/jscomp/ControlFlowAnalysis.java\n@@ -764,7 +764,63 @@ final class ControlFlowAnalysis implements Callback, CompilerPass {\n         } else if (parent.getLastChild() == node){\n           if (cfa != null) {\n             for (Node finallyNode : cfa.finallyMap.get(parent)) {\n-              cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+          switch (parent.getType()) {\n+              // The follow() of any of the path from IF would be what follows IF.\n+            case Token.IF:\n+              return computeFollowNode(fromNode, parent, cfa);\n+            case Token.CASE:\n+            case Token.DEFAULT_CASE:\n+              // After the body of a CASE, the control goes to the body of the next\n+              // case, without having to go to the case condition.\n+              if (parent.getNext() != null) {\n+                if (parent.getNext().isCase()) {\n+                  return parent.getNext().getFirstChild().getNext();\n+                } else if (parent.getNext().isDefaultCase()) {\n+                  return parent.getNext().getFirstChild();\n+                } else {\n+                  Preconditions.checkState(false, \"Not reachable\");\n+                }\n+              } else {\n+                return computeFollowNode(fromNode, parent, cfa);\n+              }\n+            case Token.FOR:\n+              Node grandparent = parent.getParent();\n+              if (grandparent != null && grandparent.isVanillaFor()) {\n+                return grandparent.getLastChild();\n+              } else if (NodeUtil.isForIn(parent)) {\n+                return parent;\n+              } else {\n+                return parent.getFirstChild().getNext().getNext();\n+              }\n+            case Token.WHILE:\n+            case Token.DO:\n+              return parent;\n+            case Token.TRY:\n+              // If we are coming out of the TRY block...\n+              if (parent.getFirstChild() == node) {\n+                if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n+                  return computeFallThrough(parent.getLastChild());\n+                } else { // and have no FINALLY.\n+                  return computeFollowNode(fromNode, parent, cfa);\n+                }\n+              // CATCH block.\n+              } else if (NodeUtil.getCatchBlock(parent) == node){\n+                if (NodeUtil.hasFinally(parent)) { // and have FINALLY block.\n+                  return computeFallThrough(node.getNext());\n+                } else {\n+                  return computeFollowNode(fromNode, parent, cfa);\n+                }\n+              // If we are coming out of the FINALLY block...\n+              } else if (parent.getLastChild() == node){\n+                if (cfa != null) {\n+                  for (Node finallyNode : cfa.finallyMap.get(parent)) {\n+                    cfa.createEdge(fromNode, Branch.UNCOND, finallyNode);\n+                    computeFollowNode(fromNode, finallyNode, cfa);\n+                  }\n+                }\n+                return computeFollowNode(fromNode, parent, cfa);\n+              }\n+          }\n             }\n           }\n           return computeFollowNode(fromNode, parent, cfa);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}