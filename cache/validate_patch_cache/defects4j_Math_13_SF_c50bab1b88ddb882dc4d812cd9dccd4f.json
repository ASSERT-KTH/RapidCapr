{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final int n = m.getRowDimension();\n    final int threshold = 1000;\n\n    if (n > threshold) {\n        // divide the matrix into smaller sub-matrices\n        final EigenDecomposition[] decomposition = new EigenDecomposition[n / threshold + 1];\n        for (int i = 0; i < n; i += threshold) {\n            final int size = Math.min(threshold, n - i);\n            final RealMatrix subMatrix = m.getSubMatrix(i, i + size - 1, i, i + size - 1);\n            decomposition[i / threshold] = new EigenDecomposition(subMatrix);\n        }\n\n        RealMatrix result = MatrixUtils.createRealMatrix(n, n);\n        for (int i = 0; i < n; i += threshold) {\n            final int size = Math.min(threshold, n - i);\n            final RealMatrix subResult = MatrixUtils.createRealMatrix(size, size);\n            for (int j = i; j < i + size; j++) {\n                for (int k = j; k < i + size; k++) {\n                    double sum = 0.0;\n                    for (int l = i / threshold; l <= (i + size - 1) / threshold; l++) {\n                        sum += decomposition[l].getVT().getEntry(j - i, k - i) *\n                            Math.sqrt(decomposition[l].getRealEigenvalue(j - i)) *\n                            decomposition[l].getV().getEntry(j - i, l * threshold + k - i);\n                    }\n                    subResult.setEntry(j - i, k - i, sum);\n                    subResult.setEntry(k - i, j - i, sum);\n                }\n            }\n            result.setSubMatrix(subResult.getData(), i, i);\n        }\n        return result;\n    } else {\n        // perform Schur decomposition directly\n        final SchurTransformer st = new SchurTransformer(m);\n        final RealMatrix t = st.getT();\n        final RealMatrix z = st.getZ();\n        final int max = (int) FastMath.sqrt(t.getRowDimension() * t.getColumnDimension());\n\n        for (int i = 0; i < max; i++) {\n            if (t.getEntry(i, i) < 0) {\n                t.setEntry(i, i, -t.getEntry(i, i));\n                for (int j = 0; j < t.getRowDimension(); j++) {\n                    z.setEntry(j, i, -z.getEntry(j, i));\n                }\n            }\n        }\n\n        final RealMatrix sqrtT = MatrixUtils.createRealMatrix(n, n);\n        for (int i = 0; i < n; i++) {\n            for (int j = 0; j < n; j++) {\n                double sum = 0.0;\n                for (int k = 0; k < n; k++) {\n                    if (k == j) {\n                        if (FastMath.abs(t.getEntry(k, k)) > 1e-15) {\n                            sum += z.getEntry(i, k) * FastMath.sqrt(t.getEntry(k, k));\n                        }\n                    } else {\n                        sum += z.getEntry(i, k) * z.getEntry(j, k) * t.getEntry(j, j);\n                    }\n                }\n                sqrtT.setEntry(i, j, sum);\n            }\n        }\n\n        return z.multiply(sqrtT).multiply(z.transpose());\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..7a9b2d28c 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,72 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final int n = m.getRowDimension();\n+    final int threshold = 1000;\n+\n+    if (n > threshold) {\n+        // divide the matrix into smaller sub-matrices\n+        final EigenDecomposition[] decomposition = new EigenDecomposition[n / threshold + 1];\n+        for (int i = 0; i < n; i += threshold) {\n+            final int size = Math.min(threshold, n - i);\n+            final RealMatrix subMatrix = m.getSubMatrix(i, i + size - 1, i, i + size - 1);\n+            decomposition[i / threshold] = new EigenDecomposition(subMatrix);\n+        }\n+\n+        RealMatrix result = MatrixUtils.createRealMatrix(n, n);\n+        for (int i = 0; i < n; i += threshold) {\n+            final int size = Math.min(threshold, n - i);\n+            final RealMatrix subResult = MatrixUtils.createRealMatrix(size, size);\n+            for (int j = i; j < i + size; j++) {\n+                for (int k = j; k < i + size; k++) {\n+                    double sum = 0.0;\n+                    for (int l = i / threshold; l <= (i + size - 1) / threshold; l++) {\n+                        sum += decomposition[l].getVT().getEntry(j - i, k - i) *\n+                            Math.sqrt(decomposition[l].getRealEigenvalue(j - i)) *\n+                            decomposition[l].getV().getEntry(j - i, l * threshold + k - i);\n+                    }\n+                    subResult.setEntry(j - i, k - i, sum);\n+                    subResult.setEntry(k - i, j - i, sum);\n+                }\n+            }\n+            result.setSubMatrix(subResult.getData(), i, i);\n+        }\n+        return result;\n+    } else {\n+        // perform Schur decomposition directly\n+        final SchurTransformer st = new SchurTransformer(m);\n+        final RealMatrix t = st.getT();\n+        final RealMatrix z = st.getZ();\n+        final int max = (int) FastMath.sqrt(t.getRowDimension() * t.getColumnDimension());\n+\n+        for (int i = 0; i < max; i++) {\n+            if (t.getEntry(i, i) < 0) {\n+                t.setEntry(i, i, -t.getEntry(i, i));\n+                for (int j = 0; j < t.getRowDimension(); j++) {\n+                    z.setEntry(j, i, -z.getEntry(j, i));\n+                }\n+            }\n+        }\n+\n+        final RealMatrix sqrtT = MatrixUtils.createRealMatrix(n, n);\n+        for (int i = 0; i < n; i++) {\n+            for (int j = 0; j < n; j++) {\n+                double sum = 0.0;\n+                for (int k = 0; k < n; k++) {\n+                    if (k == j) {\n+                        if (FastMath.abs(t.getEntry(k, k)) > 1e-15) {\n+                            sum += z.getEntry(i, k) * FastMath.sqrt(t.getEntry(k, k));\n+                        }\n+                    } else {\n+                        sum += z.getEntry(i, k) * z.getEntry(j, k) * t.getEntry(j, j);\n+                    }\n+                }\n+                sqrtT.setEntry(i, j, sum);\n+            }\n+        }\n+\n+        return z.multiply(sqrtT).multiply(z.transpose());\n     }\n }\n+}",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}