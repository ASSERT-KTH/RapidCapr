{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    final RealMatrix v = dec.getV();\n    final RealMatrix d = dec.getD();\n    final int n = m.getRowDimension();\n    final double eps = Math.pow(2.0, -52);\n\n    // Check if the matrix is positive semidefinite\n    boolean isPositiveSemidefinite = true;\n    for (int i = 0; i < n; i++) {\n        double eigenvalue = d.getEntry(i, i);\n        if (eigenvalue < -eps) {\n            throw new IllegalArgumentException(\"Matrix is not positive definite\");\n        }\n        if (eigenvalue < 0.0) {\n            isPositiveSemidefinite = false;\n            break;\n        }\n    }\n\n    if (isPositiveSemidefinite) {\n        // Matrix is positive semidefinite\n        final RealMatrix dSqrt = MatrixUtils.createRealMatrix(n, n);\n\n        // Compute the square root of the diagonal matrix\n        for (int i = 0; i < n; i++) {\n            double eigenvalue = d.getEntry(i, i);\n\n            if (eigenvalue < eps) {\n                dSqrt.setEntry(i, i, 0.0);\n            } else {\n                dSqrt.setEntry(i, i, Math.sqrt(eigenvalue));\n            }\n        }\n\n        // Compute the square root of the matrix\n        return v.multiply(dSqrt).multiply(v.transpose());\n    } else {\n        // Matrix is not positive semidefinite\n        final double criterion = eps * v.getNorm();\n        final RealMatrix eVec = MatrixUtils.createRealIdentityMatrix(n);\n\n        for (int i = 0; i < n; i++) {\n            double eigenvalue = d.getEntry(i, i);\n            if (eigenvalue > -eps && eigenvalue < eps) {\n                eVec.setRowVector(i, v.getRowVector(i).scalarMultiply(Math.sqrt(0.5)));\n            } else {\n                RealVector tmp = v.getRowVector(i);\n                for (int j = 0; j < n; j++) {\n                    if (tmp.getEntry(j) < criterion) {\n                        tmp.setEntry(j, 0.0);\n                    } else {\n                        tmp.setEntry(j, tmp.getEntry(j) / Math.sqrt(2 * eigenvalue));\n                    }\n                }\n                eVec.setRowVector(i, tmp);\n            }\n        }\n\n        // Compute the square root of the matrix\n        RealMatrix aSqrt = eVec.multiply(d).multiply(eVec.transpose());\n        dec = new EigenDecomposition(aSqrt);\n\n        // Check if the matrix is positive semidefinite\n        isPositiveSemidefinite = true;\n        for (int i = 0; i < n; i++) {\n            double eigenvalue = dec.getD().getEntry(i, i);\n            if (eigenvalue < -eps) {\n                throw new IllegalArgumentException(\"Matrix is not positive definite\");\n            }\n            if (eigenvalue < 0.0) {\n                isPositiveSemidefinite = false;\n                break;\n            }\n        }\n\n        if (isPositiveSemidefinite) {\n            final RealMatrix dSqrt = MatrixUtils.createRealMatrix(n, n);\n\n            // Compute the square root of the diagonal matrix\n            for (int i = 0; i < n; i++) {\n                double eigenvalue = dec.getD().getEntry(i, i);\n\n                if (eigenvalue < eps) {\n                    dSqrt.setEntry(i, i, 0.0);\n                } else {\n                    dSqrt.setEntry(i, i, Math.sqrt(eigenvalue));\n                }\n            }\n\n            // Compute the square root of the matrix\n            return dec.getV().multiply(dSqrt).multiply(dec.getV().transpose());\n        } else {\n            throw new IllegalArgumentException(\"Matrix is not positive semidefinite\");\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..17936e7a1 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,101 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    final EigenDecomposition dec = new EigenDecomposition(m);\n+    final RealMatrix v = dec.getV();\n+    final RealMatrix d = dec.getD();\n+    final int n = m.getRowDimension();\n+    final double eps = Math.pow(2.0, -52);\n+\n+    // Check if the matrix is positive semidefinite\n+    boolean isPositiveSemidefinite = true;\n+    for (int i = 0; i < n; i++) {\n+        double eigenvalue = d.getEntry(i, i);\n+        if (eigenvalue < -eps) {\n+            throw new IllegalArgumentException(\"Matrix is not positive definite\");\n+        }\n+        if (eigenvalue < 0.0) {\n+            isPositiveSemidefinite = false;\n+            break;\n+        }\n     }\n+\n+    if (isPositiveSemidefinite) {\n+        // Matrix is positive semidefinite\n+        final RealMatrix dSqrt = MatrixUtils.createRealMatrix(n, n);\n+\n+        // Compute the square root of the diagonal matrix\n+        for (int i = 0; i < n; i++) {\n+            double eigenvalue = d.getEntry(i, i);\n+\n+            if (eigenvalue < eps) {\n+                dSqrt.setEntry(i, i, 0.0);\n+            } else {\n+                dSqrt.setEntry(i, i, Math.sqrt(eigenvalue));\n+            }\n+        }\n+\n+        // Compute the square root of the matrix\n+        return v.multiply(dSqrt).multiply(v.transpose());\n+    } else {\n+        // Matrix is not positive semidefinite\n+        final double criterion = eps * v.getNorm();\n+        final RealMatrix eVec = MatrixUtils.createRealIdentityMatrix(n);\n+\n+        for (int i = 0; i < n; i++) {\n+            double eigenvalue = d.getEntry(i, i);\n+            if (eigenvalue > -eps && eigenvalue < eps) {\n+                eVec.setRowVector(i, v.getRowVector(i).scalarMultiply(Math.sqrt(0.5)));\n+            } else {\n+                RealVector tmp = v.getRowVector(i);\n+                for (int j = 0; j < n; j++) {\n+                    if (tmp.getEntry(j) < criterion) {\n+                        tmp.setEntry(j, 0.0);\n+                    } else {\n+                        tmp.setEntry(j, tmp.getEntry(j) / Math.sqrt(2 * eigenvalue));\n+                    }\n+                }\n+                eVec.setRowVector(i, tmp);\n+            }\n+        }\n+\n+        // Compute the square root of the matrix\n+        RealMatrix aSqrt = eVec.multiply(d).multiply(eVec.transpose());\n+        dec = new EigenDecomposition(aSqrt);\n+\n+        // Check if the matrix is positive semidefinite\n+        isPositiveSemidefinite = true;\n+        for (int i = 0; i < n; i++) {\n+            double eigenvalue = dec.getD().getEntry(i, i);\n+            if (eigenvalue < -eps) {\n+                throw new IllegalArgumentException(\"Matrix is not positive definite\");\n+            }\n+            if (eigenvalue < 0.0) {\n+                isPositiveSemidefinite = false;\n+                break;\n+            }\n+        }\n+\n+        if (isPositiveSemidefinite) {\n+            final RealMatrix dSqrt = MatrixUtils.createRealMatrix(n, n);\n+\n+            // Compute the square root of the diagonal matrix\n+            for (int i = 0; i < n; i++) {\n+                double eigenvalue = dec.getD().getEntry(i, i);\n+\n+                if (eigenvalue < eps) {\n+                    dSqrt.setEntry(i, i, 0.0);\n+                } else {\n+                    dSqrt.setEntry(i, i, Math.sqrt(eigenvalue));\n+                }\n+            }\n+\n+            // Compute the square root of the matrix\n+            return dec.getV().multiply(dSqrt).multiply(dec.getV().transpose());\n+        } else {\n+            throw new IllegalArgumentException(\"Matrix is not positive semidefinite\");\n+        }\n+    }\n+}\n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}