{
    "patch": "import org.mockito.internal.creation.bytebuddy.MockAccess;\nimport java.lang.reflect.Proxy;\nimport net.bytebuddy.implementation.FieldAccessor;\nimport org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\nimport org.mockito.internal.creation.bytebuddy.MockMethodAdvice.Prepare;\nimport org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.FilteredMock;\nimport org.mockito.mock.MockSettings;\nimport org.mockito.plugins.MockMaker;\n\n@SuppressWarnings(\"unchecked\")\npublic class ResetMockHelper implements MockMaker {\n    @Override\n    public <T> T createMock(MockSettings<T> settings, MockCreationSettings<T> creationSettings) {\n        Class<?> type = creationSettings.getTypeToMock();\n        if (type.isInterface()) {\n            return (T) Proxy.newProxyInstance(\n                type.getClassLoader(),\n                new Class<?>[]{type},\n                new FilteredMock(\n                    creationSettings.getHandler(),\n                    new Prepare(\n                        new MockMethodInterceptor(\n                            creationSettings.getHandler(),\n                            creationSettings.getMockName(),\n                            type,\n                            creationSettings.getSerializableMode(),\n                            settings.getSpiedInstanceCreator()\n                        )\n                    )\n                )\n            );\n        }\n        throw new IllegalArgumentException(\"Type \" + type + \" is not an interface\");\n    }\n\n    @Override\n    public MockHandler getHandler(Object mock) {\n        if (mock instanceof MockAccess) {\n            return ((MockAccess) mock).getMockitoInterceptor();\n        }\n        throw new IllegalArgumentException(\"Not a Mockito mock: \" + mock);\n    }\n\n    @Override\n    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {\n        if (mock instanceof MockAccess) {\n            ((MockAccess) mock).setMockitoInterceptor(newHandler);\n        } else {\n            throw new IllegalArgumentException(\"Not a Mockito mock: \" + mock);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..400405d41 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,59 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.internal.creation.bytebuddy.MockAccess;\n+import java.lang.reflect.Proxy;\n+import net.bytebuddy.implementation.FieldAccessor;\n+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor;\n+import org.mockito.internal.creation.bytebuddy.MockMethodAdvice.Prepare;\n+import org.mockito.internal.creation.bytebuddy.MockMethodInterceptor.FilteredMock;\n+import org.mockito.mock.MockSettings;\n+import org.mockito.plugins.MockMaker;\n+\n+@SuppressWarnings(\"unchecked\")\n+public class ResetMockHelper implements MockMaker {\n+    @Override\n+    public <T> T createMock(MockSettings<T> settings, MockCreationSettings<T> creationSettings) {\n+        Class<?> type = creationSettings.getTypeToMock();\n+        if (type.isInterface()) {\n+            return (T) Proxy.newProxyInstance(\n+                type.getClassLoader(),\n+                new Class<?>[]{type},\n+                new FilteredMock(\n+                    creationSettings.getHandler(),\n+                    new Prepare(\n+                        new MockMethodInterceptor(\n+                            creationSettings.getHandler(),\n+                            creationSettings.getMockName(),\n+                            type,\n+                            creationSettings.getSerializableMode(),\n+                            settings.getSpiedInstanceCreator()\n+                        )\n+                    )\n+                )\n+            );\n+        }\n+        throw new IllegalArgumentException(\"Type \" + type + \" is not an interface\");\n+    }\n+\n+    @Override\n+    public MockHandler getHandler(Object mock) {\n+        if (mock instanceof MockAccess) {\n+            return ((MockAccess) mock).getMockitoInterceptor();\n+        }\n+        throw new IllegalArgumentException(\"Not a Mockito mock: \" + mock);\n+    }\n+\n+    @Override\n+    public void resetMock(Object mock, MockHandler newHandler, MockCreationSettings settings) {\n+        if (mock instanceof MockAccess) {\n+            ((MockAccess) mock).setMockitoInterceptor(newHandler);\n+        } else {\n+            throw new IllegalArgumentException(\"Not a Mockito mock: \" + mock);\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}