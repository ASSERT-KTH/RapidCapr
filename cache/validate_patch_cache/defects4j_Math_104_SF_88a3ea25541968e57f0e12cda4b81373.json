{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.FastMath;\n\npublic class MyMath {\n\n    public static double myRegularizedGammaQ(double a, double x) {\n        double eps = 10e-15;\n        double gin = Gamma.regularizedGammaQ(a, x);\n\n        if (x < 0.0 || a <= 0.0) {\n            return Double.NaN;\n        } else if (x == 0.0) {\n            if (a < 1.0) {\n                return Double.NaN;\n            } else if (a > 1.0) {\n                return 1.0;\n            } else {\n                return Double.POSITIVE_INFINITY;\n            }\n        } else if (x < a + 1.0) {\n            double g = Gamma.gamma(a);\n            double p = 1.0 / g;\n            double d = 1.0 / (1.0 - a);\n            double s = myGammaSer(a, x, eps);\n\n            return p * s * FastMath.pow(x, a);\n        } else {\n            double gcf = myGammaCf(a, x, eps);\n\n            return gcf;\n        }\n    }\n\n    private static double myGammaSer(double a, double x, double eps) {\n        double sum = 1.0 / a;\n        double t = sum;\n        double aj = a;\n\n        for (int j = 1; j <= 100; j++) {\n            aj += 1.0;\n            t *= x / aj;\n            sum += t;\n\n            if (FastMath.abs(t / sum) < eps) {\n                return sum * FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a));\n            }\n        }\n\n        return sum * FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a));\n    }\n\n    private static double myGammaCf(double a, double x, double eps) {\n        int maxIters = 100;\n        double gln = Gamma.logGamma(a);\n        double g = 0.0;\n        double gOld = 0.0;\n        double a0 = 1.0;\n        double a1 = x;\n        double b0 = 0.0;\n        double b1 = 1.0;\n        double fac = 1.0;\n\n        for (int i = 1; i <= maxIters; i++) {\n            double a2 = (i + 1 - a) * a1 + (i + 1 - x) * a0;\n            double b2 = (i + 1 - a) * b1 + (i + 1 - x) * b0;\n            if (b2 != 0.0) {\n                fac = a1 / b2;\n                g = b1 * fac;\n                if (FastMath.abs((g - gOld) / g) < eps) {\n                    return FastMath.exp(-x + a * FastMath.log(x) - gln) * g;\n                }\n                gOld = g;\n                a0 = a1;\n                a1 = a2;\n                b0 = b1;\n                b1 = b2;\n            } else {\n                return FastMath.exp(-x + a * FastMath.log(x) - gln) * g;\n            }\n        }\n\n        return FastMath.exp(-x + a * FastMath.log(x) - gln) * g;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..01d157e9a 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,90 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.FastMath;\n+\n+public class MyMath {\n+\n+    public static double myRegularizedGammaQ(double a, double x) {\n+        double eps = 10e-15;\n+        double gin = Gamma.regularizedGammaQ(a, x);\n+\n+        if (x < 0.0 || a <= 0.0) {\n+            return Double.NaN;\n+        } else if (x == 0.0) {\n+            if (a < 1.0) {\n+                return Double.NaN;\n+            } else if (a > 1.0) {\n+                return 1.0;\n+            } else {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        } else if (x < a + 1.0) {\n+            double g = Gamma.gamma(a);\n+            double p = 1.0 / g;\n+            double d = 1.0 / (1.0 - a);\n+            double s = myGammaSer(a, x, eps);\n+\n+            return p * s * FastMath.pow(x, a);\n+        } else {\n+            double gcf = myGammaCf(a, x, eps);\n+\n+            return gcf;\n+        }\n+    }\n+\n+    private static double myGammaSer(double a, double x, double eps) {\n+        double sum = 1.0 / a;\n+        double t = sum;\n+        double aj = a;\n+\n+        for (int j = 1; j <= 100; j++) {\n+            aj += 1.0;\n+            t *= x / aj;\n+            sum += t;\n+\n+            if (FastMath.abs(t / sum) < eps) {\n+                return sum * FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a));\n+            }\n+        }\n+\n+        return sum * FastMath.exp(-x + a * FastMath.log(x) - Gamma.logGamma(a));\n+    }\n+\n+    private static double myGammaCf(double a, double x, double eps) {\n+        int maxIters = 100;\n+        double gln = Gamma.logGamma(a);\n+        double g = 0.0;\n+        double gOld = 0.0;\n+        double a0 = 1.0;\n+        double a1 = x;\n+        double b0 = 0.0;\n+        double b1 = 1.0;\n+        double fac = 1.0;\n+\n+        for (int i = 1; i <= maxIters; i++) {\n+            double a2 = (i + 1 - a) * a1 + (i + 1 - x) * a0;\n+            double b2 = (i + 1 - a) * b1 + (i + 1 - x) * b0;\n+            if (b2 != 0.0) {\n+                fac = a1 / b2;\n+                g = b1 * fac;\n+                if (FastMath.abs((g - gOld) / g) < eps) {\n+                    return FastMath.exp(-x + a * FastMath.log(x) - gln) * g;\n+                }\n+                gOld = g;\n+                a0 = a1;\n+                a1 = a2;\n+                b0 = b1;\n+                b1 = b2;\n+            } else {\n+                return FastMath.exp(-x + a * FastMath.log(x) - gln) * g;\n+            }\n+        }\n+\n+        return FastMath.exp(-x + a * FastMath.log(x) - gln) * g;\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}