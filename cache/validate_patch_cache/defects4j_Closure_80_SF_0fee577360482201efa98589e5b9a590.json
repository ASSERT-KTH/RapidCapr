{
    "patch": "import java.util.function.Predicate;\nimport com.google.javascript.rhino.NodeUtil;\nimport com.google.javascript.rhino.Token;\n\n// ...\n\nstatic boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n  switch (value.getType()) {\n    case Token.ASSIGN:\n      return NodeUtil.isImmutableValue(value.getLastChild())\n          || (locals.test(value.getFirstChild())\n          && evaluatesToLocalValue(value.getLastChild(), locals));\n    case Token.COMMA:\n      return evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.AND:\n    case Token.OR:\n      return evaluatesToLocalValue(value.getFirstChild(), locals)\n          && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.HOOK:\n      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n          && evaluatesToLocalValue(value.getLastChild(), locals);\n    case Token.INC:\n    case Token.DEC:\n      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n        return evaluatesToLocalValue(value.getFirstChild(), locals);\n      } else {\n        return true;\n      }\n    case Token.THIS:\n      return locals.test(value);\n    case Token.NAME:\n      return isImmutableValue(value) || locals.test(value);\n    case Token.GETELEM:\n    case Token.GETPROP:\n      return locals.test(value);\n    case Token.CALL:\n      return callHasLocalResult(value)\n          || isToStringMethodCall(value)\n          || locals.test(value);\n    case Token.NEW:\n      return newHasLocalResult(value)\n          || locals.test(value);\n    case Token.FUNCTION:\n    case Token.REGEXP:\n    case Token.ARRAYLIT:\n    case Token.OBJECTLIT:\n      return true;\n    case Token.DELETE:\n      return NodeUtil.isImmutableValue(value.getFirstChild())\n          || evaluatesToLocalValue(value.getFirstChild(), locals);\n    default:\n      if (isAssignmentOp(value)\n          || isSimpleOperator(value)\n          || isImmutableValue(value)) {\n        return true;\n      }\n\n      throw new IllegalStateException(\n          \"Unexpected expression node\" + value +\n          \"\\n parent:\" + value.getParent());\n  }\n}\n\nprivate static boolean isImmutableValue(Node n) {\n  switch (n.getType()) {\n    case Token.NUMBER:\n    case Token.STRING:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.NULL:\n    case Token.VOID:\n      return true;\n    case Token.NAME:\n      String name = n.getString();\n      // Because of hoisting and other things, undefined is sometimes\n      // mutable.\n      return name.equals(\"undefined\")\n          || name.equals(\"Infinity\")\n          || name.equals(\"NaN\");\n    default:\n      return false;\n  }\n}\n\nprivate static boolean isAssignmentOp(Node n) {\n  int type = n.getType();\n  return type == Token.ASSIGN\n      || type == Token.ASSIGN_ADD\n      || type == Token.ASSIGN_SUB\n      || type == Token.ASSIGN_MUL\n      || type == Token.ASSIGN_DIV\n      || type == Token.ASSIGN_MOD\n      || type == Token.ASSIGN_BITOR\n      || type == Token.ASSIGN_BITXOR\n      || type == Token.ASSIGN_BITAND\n      || type == Token.ASSIGN_LSH\n      || type == Token.ASSIGN_RSH\n      || type == Token.ASSIGN_URSH;\n}\n\nprivate static boolean isSimpleOperator(Node n) {\n  int type = n.getType();\n  return type == Token.NOT\n      || type == Token.BITNOT\n      || type == Token.POS\n      || type == Token.NEG\n      || type == Token.TYPEOF\n      || type == Token.INSTANCEOF;\n}\n\nprivate static boolean callHasLocalResult(Node callNode) {\n  Node callee = callNode.getFirstChild();\n  return callee.getType() == Token.NAME\n      && callee.getString().equals(\"eval\");  // eval has a local result.\n}\n\nprivate static boolean newHasLocalResult(Node callNode) {\n  Node callee = callNode.getFirstChild();\n  int type = callee.getType();\n  return type == Token.NAME\n      && callee.getString().equals(\"Object\")\n      && callNode.getParent().getType() == Token.EXPR_RESULT;\n}\n\nprivate static boolean isToStringMethodCall(Node callNode) {\n  Node callee = callNode.getFirstChild();\n  return callee.getType() == Token.GETPROP\n      && callee.getLastChild().getString().equals(\"toString\")\n      && callNode.getParent().getType() == Token.EXPR_RESULT;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex 08fb954f..b7b703cf 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -1239,70 +1239,136 @@ public final class NodeUtil {\n     return valueCheck(n, BOOLEAN_RESULT_PREDICATE);\n   }\n \n-  static boolean isBooleanResultHelper(Node n) {\n-    switch (n.getType()) {\n-      // Primitives\n-      case Token.TRUE:\n-      case Token.FALSE:\n-      // Comparisons\n-      case Token.EQ:\n-      case Token.NE:\n-      case Token.SHEQ:\n-      case Token.SHNE:\n-      case Token.LT:\n-      case Token.GT:\n-      case Token.LE:\n-      case Token.GE:\n-      // Queryies\n-      case Token.IN:\n-      case Token.INSTANCEOF:\n-      // Inversion\n-      case Token.NOT:\n-      // delete operator returns a boolean.\n-        return true;\n-      default:\n-        return false;\n-    }\n-  }\n+import java.util.function.Predicate;\n+import com.google.javascript.rhino.NodeUtil;\n+import com.google.javascript.rhino.Token;\n \n-  static boolean isUndefined(Node n) {\n-    switch (n.getType()) {\n-      case Token.VOID:\n+// ...\n+\n+static boolean evaluatesToLocalValue(Node value, Predicate<Node> locals) {\n+  switch (value.getType()) {\n+    case Token.ASSIGN:\n+      return NodeUtil.isImmutableValue(value.getLastChild())\n+          || (locals.test(value.getFirstChild())\n+          && evaluatesToLocalValue(value.getLastChild(), locals));\n+    case Token.COMMA:\n+      return evaluatesToLocalValue(value.getLastChild(), locals);\n+    case Token.AND:\n+    case Token.OR:\n+      return evaluatesToLocalValue(value.getFirstChild(), locals)\n+          && evaluatesToLocalValue(value.getLastChild(), locals);\n+    case Token.HOOK:\n+      return evaluatesToLocalValue(value.getFirstChild().getNext(), locals)\n+          && evaluatesToLocalValue(value.getLastChild(), locals);\n+    case Token.INC:\n+    case Token.DEC:\n+      if (value.getBooleanProp(Node.INCRDECR_PROP)) {\n+        return evaluatesToLocalValue(value.getFirstChild(), locals);\n+      } else {\n         return true;\n-      case Token.NAME:\n-        return n.getString().equals(\"undefined\");\n-    }\n-    return false;\n-  }\n+      }\n+    case Token.THIS:\n+      return locals.test(value);\n+    case Token.NAME:\n+      return isImmutableValue(value) || locals.test(value);\n+    case Token.GETELEM:\n+    case Token.GETPROP:\n+      return locals.test(value);\n+    case Token.CALL:\n+      return callHasLocalResult(value)\n+          || isToStringMethodCall(value)\n+          || locals.test(value);\n+    case Token.NEW:\n+      return newHasLocalResult(value)\n+          || locals.test(value);\n+    case Token.FUNCTION:\n+    case Token.REGEXP:\n+    case Token.ARRAYLIT:\n+    case Token.OBJECTLIT:\n+      return true;\n+    case Token.DELETE:\n+      return NodeUtil.isImmutableValue(value.getFirstChild())\n+          || evaluatesToLocalValue(value.getFirstChild(), locals);\n+    default:\n+      if (isAssignmentOp(value)\n+          || isSimpleOperator(value)\n+          || isImmutableValue(value)) {\n+        return true;\n+      }\n \n-  static boolean isNull(Node n) {\n-    return n.getType() == Token.NULL;\n+      throw new IllegalStateException(\n+          \"Unexpected expression node\" + value +\n+          \"\\n parent:\" + value.getParent());\n   }\n+}\n \n-  static boolean isNullOrUndefined(Node n) {\n-    return isNull(n) || isUndefined(n);\n+private static boolean isImmutableValue(Node n) {\n+  switch (n.getType()) {\n+    case Token.NUMBER:\n+    case Token.STRING:\n+    case Token.TRUE:\n+    case Token.FALSE:\n+    case Token.NULL:\n+    case Token.VOID:\n+      return true;\n+    case Token.NAME:\n+      String name = n.getString();\n+      // Because of hoisting and other things, undefined is sometimes\n+      // mutable.\n+      return name.equals(\"undefined\")\n+          || name.equals(\"Infinity\")\n+          || name.equals(\"NaN\");\n+    default:\n+      return false;\n   }\n+}\n \n-  static class MayBeStringResultPredicate implements Predicate<Node> {\n-    public boolean apply(Node n) {\n-      return mayBeStringHelper(n);\n-    }\n-  }\n+private static boolean isAssignmentOp(Node n) {\n+  int type = n.getType();\n+  return type == Token.ASSIGN\n+      || type == Token.ASSIGN_ADD\n+      || type == Token.ASSIGN_SUB\n+      || type == Token.ASSIGN_MUL\n+      || type == Token.ASSIGN_DIV\n+      || type == Token.ASSIGN_MOD\n+      || type == Token.ASSIGN_BITOR\n+      || type == Token.ASSIGN_BITXOR\n+      || type == Token.ASSIGN_BITAND\n+      || type == Token.ASSIGN_LSH\n+      || type == Token.ASSIGN_RSH\n+      || type == Token.ASSIGN_URSH;\n+}\n \n-  static final MayBeStringResultPredicate MAY_BE_STRING_PREDICATE =\n-      new MayBeStringResultPredicate();\n+private static boolean isSimpleOperator(Node n) {\n+  int type = n.getType();\n+  return type == Token.NOT\n+      || type == Token.BITNOT\n+      || type == Token.POS\n+      || type == Token.NEG\n+      || type == Token.TYPEOF\n+      || type == Token.INSTANCEOF;\n+}\n \n-  /**\n-   * @returns Whether the results is possibly a string.\n-   */\n-  static boolean mayBeString(Node n) {\n-    return mayBeString(n, true);\n-  }\n+private static boolean callHasLocalResult(Node callNode) {\n+  Node callee = callNode.getFirstChild();\n+  return callee.getType() == Token.NAME\n+      && callee.getString().equals(\"eval\");  // eval has a local result.\n+}\n \n-  static boolean mayBeString(Node n, boolean recurse) {\n-    if (recurse) {\n-      return valueCheck(n, MAY_BE_STRING_PREDICATE);\n-    } else {\n+private static boolean newHasLocalResult(Node callNode) {\n+  Node callee = callNode.getFirstChild();\n+  int type = callee.getType();\n+  return type == Token.NAME\n+      && callee.getString().equals(\"Object\")\n+      && callNode.getParent().getType() == Token.EXPR_RESULT;\n+}\n+\n+private static boolean isToStringMethodCall(Node callNode) {\n+  Node callee = callNode.getFirstChild();\n+  return callee.getType() == Token.GETPROP\n+      && callee.getLastChild().getString().equals(\"toString\")\n+      && callNode.getParent().getType() == Token.EXPR_RESULT;\n+}\n       return mayBeStringHelper(n);\n     }\n   }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}