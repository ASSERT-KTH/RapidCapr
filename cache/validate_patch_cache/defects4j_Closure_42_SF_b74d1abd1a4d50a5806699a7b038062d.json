{
    "patch": "import com.google.common.collect.ImmutableSet;\nimport org.mozilla.javascript.*;\nimport java.util.LinkedList;\n\nclass IRFactory {\n\n  // Immutable set of all allowed \"use strict\" directives\n  private static final ImmutableSet<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n\n  // Wraps a given statement or expression in an ExpressionStatement node. If the node is already\n  // an ExpressionStatement, will return the node untouched.\n  private static Node wrapInExpressionStatement(Node n) {\n    return n.getType() == Token.EXPR_RESULT ? n : new Node(Token.EXPR_RESULT, n);\n  }\n\n  public static Node transformTree(AstNode rootNode, String sourceName, ErrorReporter errorReporter) {\n    TransformDispatcher dispatcher = new TransformDispatcher(sourceName, errorReporter);\n    return dispatcher.transform(rootNode);\n  }\n\n  // Returns a new name node with the given identifier\n  private static Node newName(String identifier) {\n    return new Node(Token.NAME, new Node(Token.STRING, identifier));\n  }\n\n  // Returns a new variable declaration of the given name with no initializer\n  private static Node newVar(String name) {\n    return new Node(Token.VAR, newName(name), new Node(Token.EMPTY));\n  }\n\n  private static class TransformDispatcher extends IRFactory.TypeSafeDispatcher<Node> {\n\n    private String sourceName;\n    private ErrorReporter errorReporter;\n\n    public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n      this.sourceName = sourceName;\n      this.errorReporter = errorReporter;\n    }\n\n    // We override this dispatch method to throw an exception if we are passed an ASTNode that we\n    // don't know how to transform.\n    @Override\n    public Node visit(AstNode node) {\n      throw new UnsupportedOperationException(\"visit(\" + node.getClass().getName() + \")\");\n    }\n\n    @Override\n    public Node visitArrayComprehension(ArrayComprehension node) {\n      // Array comprehensions are not supported.\n      return null;\n    }\n\n    @Override\n    public Node visitArrayLiteral(ArrayLiteral node) {\n      Node newNode = new Node(Token.ARRAYLIT);\n      for (AstNode child : node.getElements()) {\n        if (child instanceof EmptyExpression) {\n          // Transform EmptyExpression to a hole (null).\n          newNode.addChildToBack(new Node(Token.NULL));\n        } else {\n          newNode.addChildToBack(transform(child));\n        }\n      }\n      return newNode;\n    }\n\n    @Override\n    public Node visitAssignment(Assignment node) {\n      Node target = transform(node.getLeft());\n      Node value = transform(node.getRight());\n      return new Node(node.getType(), target, value);\n    }\n\n    @Override\n    public Node visitAstRoot(AstRoot node) {\n      LinkedList<Node> children = new LinkedList<>();\n      for (AstNode n : node) {\n        Node child = transform(n);\n        if (child != null) {\n          children.addLast(child);\n        }\n      }\n\n      if (children.size() == 1) {\n        // Optimization: if the file only has a single statement, return it directly instead of\n        // wrapping it up in a block.\n        return children.getFirst();\n      }\n\n      Node blockNode = new Node(Token.BLOCK);\n      for (Node child : children) {\n        blockNode.addChildToBack(child);\n      }\n      return blockNode;\n    }\n\n    @Override\n    public Node visitBlock(Block node) {\n      Node result = new Node(Token.BLOCK);\n      for (Node child : node) {\n        result.addChildToBack(transform(child));\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitBreakStatement(BreakStatement node) {\n      Node result = new Node(Token.BREAK);\n      if (node.getBreakLabel() != null) {\n        Node labelName = transform(node.getBreakLabel());\n        labelName.setType(Token.LABEL_NAME);\n        result.addChildToBack(labelName);\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitConditionalExpression(ConditionalExpression node) {\n      return new Node(\n          Token.HOOK, transform(node.getTestExpression()), transform(node.getTrueExpression()), transform(node.getFalseExpression()));\n    }\n\n    @Override\n    public Node visitContinueStatement(ContinueStatement node) {\n      Node result = new Node(Token.CONTINUE);\n      if (node.getLabel() != null) {\n        Node labelName = transform(node.getLabel());\n        labelName.setType(Token.LABEL_NAME);\n        result.addChildToBack(labelName);\n      }\n      return result;\n    }\n\n    @Override\n    public Node visitDoLoop(DoLoop node) {\n      return new Node(Token.DO, transform(node.getBody()), transform(nod",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..ed2c477c 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,143 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import com.google.common.collect.ImmutableSet;\n+import org.mozilla.javascript.*;\n+import java.util.LinkedList;\n+\n+class IRFactory {\n+\n+  // Immutable set of all allowed \"use strict\" directives\n+  private static final ImmutableSet<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\"use strict\");\n+\n+  // Wraps a given statement or expression in an ExpressionStatement node. If the node is already\n+  // an ExpressionStatement, will return the node untouched.\n+  private static Node wrapInExpressionStatement(Node n) {\n+    return n.getType() == Token.EXPR_RESULT ? n : new Node(Token.EXPR_RESULT, n);\n+  }\n+\n+  public static Node transformTree(AstNode rootNode, String sourceName, ErrorReporter errorReporter) {\n+    TransformDispatcher dispatcher = new TransformDispatcher(sourceName, errorReporter);\n+    return dispatcher.transform(rootNode);\n+  }\n+\n+  // Returns a new name node with the given identifier\n+  private static Node newName(String identifier) {\n+    return new Node(Token.NAME, new Node(Token.STRING, identifier));\n+  }\n+\n+  // Returns a new variable declaration of the given name with no initializer\n+  private static Node newVar(String name) {\n+    return new Node(Token.VAR, newName(name), new Node(Token.EMPTY));\n+  }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private static class TransformDispatcher extends IRFactory.TypeSafeDispatcher<Node> {\n+\n+    private String sourceName;\n+    private ErrorReporter errorReporter;\n+\n+    public TransformDispatcher(String sourceName, ErrorReporter errorReporter) {\n+      this.sourceName = sourceName;\n+      this.errorReporter = errorReporter;\n     }\n \n+    // We override this dispatch method to throw an exception if we are passed an ASTNode that we\n+    // don't know how to transform.\n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node visit(AstNode node) {\n+      throw new UnsupportedOperationException(\"visit(\" + node.getClass().getName() + \")\");\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node visitArrayComprehension(ArrayComprehension node) {\n+      // Array comprehensions are not supported.\n+      return null;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    public Node visitArrayLiteral(ArrayLiteral node) {\n+      Node newNode = new Node(Token.ARRAYLIT);\n+      for (AstNode child : node.getElements()) {\n+        if (child instanceof EmptyExpression) {\n+          // Transform EmptyExpression to a hole (null).\n+          newNode.addChildToBack(new Node(Token.NULL));\n+        } else {\n+          newNode.addChildToBack(transform(child));\n+        }\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+      return newNode;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public Node visitAssignment(Assignment node) {\n+      Node target = transform(node.getLeft());\n+      Node value = transform(node.getRight());\n+      return new Node(node.getType(), target, value);\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public Node visitAstRoot(AstRoot node) {\n+      LinkedList<Node> children = new LinkedList<>();\n+      for (AstNode n : node) {\n+        Node child = transform(n);\n+        if (child != null) {\n+          children.addLast(child);\n+        }\n       }\n-      return node;\n+\n+      if (children.size() == 1) {\n+        // Optimization: if the file only has a single statement, return it directly instead of\n+        // wrapping it up in a block.\n+        return children.getFirst();\n+      }\n+\n+      Node blockNode = new Node(Token.BLOCK);\n+      for (Node child : children) {\n+        blockNode.addChildToBack(child);\n+      }\n+      return blockNode;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node visitBlock(Block node) {\n+      Node result = new Node(Token.BLOCK);\n+      for (Node child : node) {\n+        result.addChildToBack(transform(child));\n+      }\n+      return result;\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node visitBreakStatement(BreakStatement node) {\n+      Node result = new Node(Token.BREAK);\n+      if (node.getBreakLabel() != null) {\n+        Node labelName = transform(node.getBreakLabel());\n+        labelName.setType(Token.LABEL_NAME);\n+        result.addChildToBack(labelName);\n+      }\n+      return result;\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node visitConditionalExpression(ConditionalExpression node) {\n+      return new Node(\n+          Token.HOOK, transform(node.getTestExpression()), transform(node.getTrueExpression()), transform(node.getFalseExpression()));\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node visitContinueStatement(ContinueStatement node) {\n+      Node result = new Node(Token.CONTINUE);\n+      if (node.getLabel() != null) {\n+        Node labelName = transform(node.getLabel());\n+        labelName.setType(Token.LABEL_NAME);\n+        result.addChildToBack(labelName);\n+      }\n+      return result;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-\n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n-    }\n+    public Node visitDoLoop(DoLoop node) {\n+      return new Node(Token.DO, transform(node.getBody()), transform(nod\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}