{
    "patch": "import static java.lang.Math.*;\n\npublic class GammaFunction {\n    public static double gamma(double x) {\n        if (x < 0.5) {\n            return PI / (sin(PI * x) * gamma(1 - x));\n        } else {\n            double s = 1;\n            double p = 1;\n            double z = x;\n            while (z > 2) {\n                z--;\n                p *= z;\n            }\n            if (z == 1.5) {\n                s += 0.5704094715181625;\n                z -= 0.5;\n            }\n            if (z != 1) {\n                z--;\n                while (z > 2) {\n                    z--;\n                    p *= z;\n                }\n                s += z + 1;\n                double t = z * log(x) - x - log(s);\n                if (t < -709.78271289338399) {\n                    return 0;\n                }\n                return exp(t + log(p));\n            }\n            return s + log(sqrt(PI) * erf(sqrt(x)));\n        }\n    }\n\n    public static double gammaP(double a, double x) {\n        double result;\n        if (x <= 0) {\n            result = 0;\n        } else if (x < a + 1) {\n            double t = 1;\n            double s = x + 1 - a;\n            while (true) {\n                a++;\n                t *= x / a;\n                s += t;\n                if (t / s < 1e-15) {\n                    break;\n                }\n            }\n            result = s * exp(-x + log(x) * a - logGamma(a));\n        } else  {\n            double t;\n            double b = x + 1 - a;\n            double C = 1 / 1.0e-30;\n            double D = 1 / C;\n            double hPrev = 1;\n            double hCurr = x;\n            double qPrev = 0;\n            double qCurr = 1;\n            double aPlus2N = a;\n            for (int n = 1; n < 1000; ++n) {\n                aPlus2N += 2;\n                double aPlus2nMinus1 = aPlus2N - 1;\n                double aPlus2nGPow2 = aPlus2N * aPlus2N;\n                double aPlus2nMinus1GPow2 = aPlus2nMinus1 * aPlus2nMinus1;\n                t = b * hCurr - aPlus2nMinus1 * hPrev;\n                double qNext = b * qCurr - aPlus2nMinus1 * qPrev;\n                if (abs(qNext) > D) {\n                    qPrev /= D;\n                    qCurr /= D;\n                    C /= D;\n                    D = 1;\n                }\n                D = (aPlus2nGPow2 * C + aPlus2nMinus1GPow2 * D);\n                C = (aPlus2nGPow2 + b * C) + aPlus2nMinus1GPow2 * hPrev;\n                hPrev = hCurr;\n                hCurr = t / D;\n                qPrev = qCurr;\n                qCurr = qNext / D;\n                if (abs(t) < abs(hCurr * 1e-15)) {\n                    break;\n                }\n            }\n            result = 1 - exp(-x + a * log(x) - logGamma(a)) * qCurr;\n        }\n        return result;\n    }\n\n    public static double gammaQ(double a, double x) {\n        return 1 - gammaP(a, x);\n    }\n\n    public static double logGamma(double x) {\n        if (x <= 0) {\n            throw new IllegalArgumentException(\"Invalid input argument. The argument should be greater than zero\");\n        }\n        double t = x + 6.5;\n        t -= (x - 0.5) * log(t);\n        double res = 1.000000000190015 + 76.18009172947146 / (x + 1.0);\n        res -= 86.50532032941677 / (x + 2.0);\n        res += 24.01409824083091 / (x + 3.0);\n        res -= 1.231739572450155 / (x + 4.0);\n        res += 0.001208650973866179 / (x + 5.0);\n        res -= 0.000005395239384953 / (x + 6.0);\n        return log(2.5066282746310007 * res / x) - t;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..a7cf0f900 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,114 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import static java.lang.Math.*;\n+\n+public class GammaFunction {\n+    public static double gamma(double x) {\n+        if (x < 0.5) {\n+            return PI / (sin(PI * x) * gamma(1 - x));\n+        } else {\n+            double s = 1;\n+            double p = 1;\n+            double z = x;\n+            while (z > 2) {\n+                z--;\n+                p *= z;\n+            }\n+            if (z == 1.5) {\n+                s += 0.5704094715181625;\n+                z -= 0.5;\n+            }\n+            if (z != 1) {\n+                z--;\n+                while (z > 2) {\n+                    z--;\n+                    p *= z;\n+                }\n+                s += z + 1;\n+                double t = z * log(x) - x - log(s);\n+                if (t < -709.78271289338399) {\n+                    return 0;\n+                }\n+                return exp(t + log(p));\n+            }\n+            return s + log(sqrt(PI) * erf(sqrt(x)));\n+        }\n+    }\n+\n+    public static double gammaP(double a, double x) {\n+        double result;\n+        if (x <= 0) {\n+            result = 0;\n+        } else if (x < a + 1) {\n+            double t = 1;\n+            double s = x + 1 - a;\n+            while (true) {\n+                a++;\n+                t *= x / a;\n+                s += t;\n+                if (t / s < 1e-15) {\n+                    break;\n+                }\n+            }\n+            result = s * exp(-x + log(x) * a - logGamma(a));\n+        } else  {\n+            double t;\n+            double b = x + 1 - a;\n+            double C = 1 / 1.0e-30;\n+            double D = 1 / C;\n+            double hPrev = 1;\n+            double hCurr = x;\n+            double qPrev = 0;\n+            double qCurr = 1;\n+            double aPlus2N = a;\n+            for (int n = 1; n < 1000; ++n) {\n+                aPlus2N += 2;\n+                double aPlus2nMinus1 = aPlus2N - 1;\n+                double aPlus2nGPow2 = aPlus2N * aPlus2N;\n+                double aPlus2nMinus1GPow2 = aPlus2nMinus1 * aPlus2nMinus1;\n+                t = b * hCurr - aPlus2nMinus1 * hPrev;\n+                double qNext = b * qCurr - aPlus2nMinus1 * qPrev;\n+                if (abs(qNext) > D) {\n+                    qPrev /= D;\n+                    qCurr /= D;\n+                    C /= D;\n+                    D = 1;\n+                }\n+                D = (aPlus2nGPow2 * C + aPlus2nMinus1GPow2 * D);\n+                C = (aPlus2nGPow2 + b * C) + aPlus2nMinus1GPow2 * hPrev;\n+                hPrev = hCurr;\n+                hCurr = t / D;\n+                qPrev = qCurr;\n+                qCurr = qNext / D;\n+                if (abs(t) < abs(hCurr * 1e-15)) {\n+                    break;\n+                }\n+            }\n+            result = 1 - exp(-x + a * log(x) - logGamma(a)) * qCurr;\n+        }\n+        return result;\n+    }\n+\n+    public static double gammaQ(double a, double x) {\n+        return 1 - gammaP(a, x);\n+    }\n+\n+    public static double logGamma(double x) {\n+        if (x <= 0) {\n+            throw new IllegalArgumentException(\"Invalid input argument. The argument should be greater than zero\");\n+        }\n+        double t = x + 6.5;\n+        t -= (x - 0.5) * log(t);\n+        double res = 1.000000000190015 + 76.18009172947146 / (x + 1.0);\n+        res -= 86.50532032941677 / (x + 2.0);\n+        res += 24.01409824083091 / (x + 3.0);\n+        res -= 1.231739572450155 / (x + 4.0);\n+        res += 0.001208650973866179 / (x + 5.0);\n+        res -= 0.000005395239384953 / (x + 6.0);\n+        return log(2.5066282746310007 * res / x) - t;\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}