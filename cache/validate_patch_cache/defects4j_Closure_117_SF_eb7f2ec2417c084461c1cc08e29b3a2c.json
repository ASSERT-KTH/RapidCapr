{
    "patch": "  static String getReadableJSTypeName(Node n, boolean dereference) {\n    String suffix = \"\";\n    if (n.isNew()) {\n      suffix = \".<init>\";\n    }\n    JSType type = getJSType(n);\n    if (dereference) {\n      ObjectType objectType = type.dereference();\n      if (objectType != null) {\n        // If we're analyzing a GETPROP, the property may be inherited by the\n        // prototype chain. So climb the prototype chain and find out where\n        // the property was originally defined.\n        if (n.isGetProp()) {\n          String propName = n.getLastChild().getString();\n          if (objectType.getConstructor() != null &&\n              objectType.getConstructor().isInterface()) {\n            objectType = FunctionType.getTopDefiningInterface(\n                objectType, propName);\n          } else {\n            // classes\n            while (objectType != null &&\n                !objectType.hasOwnProperty(propName)) {\n              objectType = objectType.getImplicitPrototype();\n            }\n          }\n        }\n        // Don't show complex function names or anonymous types.\n        // Instead, try to get a human-readable type name.\n        if (objectType != null) {\n          if (objectType.getConstructor() != null ||\n              objectType.isFunctionPrototypeType()) {\n            String name = objectType.toString();\n            return name.replace(\"[]\", \"Array\").replace(\"[object \", \"\") + suffix;\n          } else if (objectType.isRecordType()) {\n            return \"Object\" + suffix;\n          } else {\n            return objectType.toString() + suffix;\n          }\n        }\n      }\n    }\n    if (type.isNamedType()) {\n      String typeName = type.toString();\n      if (typeName.isEmpty()) {\n        typeName = \"<empty>\";\n      }\n      if (type.isEnumType()) {\n        typeName = \"Enum.\" + typeName;\n      }\n      return typeName + suffix;\n    }\n    if (type.isUnionType()) {\n      return \"Union\" + suffix;\n    }\n    if (type.isVoidType()) {\n      return \"void\" + suffix;\n    }\n    if (type.isAnyType()) {\n      return \"any\" + suffix;\n    }\n    if (type.isNoType()) {\n      return \"<NOTYPE>\" + suffix;\n    }\n    if (type.isUnknownType()) {\n      return \"<UNKNOWN>\" + suffix;\n    }\n    if (type.isAllType()) {\n      return \"<ALL>\" + suffix;\n    }\n    if (type.isUnionType()) {\n      return \"Union\" + suffix;\n    }\n    if (type.isFunctionType()) {\n      return \"function\" + suffix;\n    }\n    String qualifiedName = n.getQualifiedName();\n    if (qualifiedName != null) {\n      return qualifiedName + suffix;\n    }\n    if (type.isConstructor()) {\n      return type.toString() + suffix;\n    }\n    ObjectType objectType = type.toObjectType();\n    if (objectType != null &&\n        objectType.getConstructor() != null) {\n      return objectType.toString() + suffix;\n    }\n    if (type.isEnumType()) {\n      String typeName = n.getLastChild().getString();\n      return \"Enum.\" + typeName + suffix;\n    }\n    return type.toString() + suffix;\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeValidator.java b/src/com/google/javascript/jscomp/TypeValidator.java\nindex bcd024ac..7e91597f 100644\n--- a/src/com/google/javascript/jscomp/TypeValidator.java\n+++ b/src/com/google/javascript/jscomp/TypeValidator.java\n@@ -721,59 +721,98 @@ class TypeValidator {\n    * @param dereference If true, the type of the node will be dereferenced\n    *     to an Object type, if possible.\n    */\n-  String getReadableJSTypeName(Node n, boolean dereference) {\n-\n-    // The best type name is the actual type name.\n-\n-    // If we're analyzing a GETPROP, the property may be inherited by the\n-    // prototype chain. So climb the prototype chain and find out where\n-    // the property was originally defined.\n-    if (n.isGetProp()) {\n-      ObjectType objectType = getJSType(n.getFirstChild()).dereference();\n+  static String getReadableJSTypeName(Node n, boolean dereference) {\n+    String suffix = \"\";\n+    if (n.isNew()) {\n+      suffix = \".<init>\";\n+    }\n+    JSType type = getJSType(n);\n+    if (dereference) {\n+      ObjectType objectType = type.dereference();\n       if (objectType != null) {\n-        String propName = n.getLastChild().getString();\n-        if (objectType.getConstructor() != null &&\n-            objectType.getConstructor().isInterface()) {\n-          objectType = FunctionType.getTopDefiningInterface(\n-              objectType, propName);\n-        } else {\n-          // classes\n-          while (objectType != null && !objectType.hasOwnProperty(propName)) {\n-            objectType = objectType.getImplicitPrototype();\n+        // If we're analyzing a GETPROP, the property may be inherited by the\n+        // prototype chain. So climb the prototype chain and find out where\n+        // the property was originally defined.\n+        if (n.isGetProp()) {\n+          String propName = n.getLastChild().getString();\n+          if (objectType.getConstructor() != null &&\n+              objectType.getConstructor().isInterface()) {\n+            objectType = FunctionType.getTopDefiningInterface(\n+                objectType, propName);\n+          } else {\n+            // classes\n+            while (objectType != null &&\n+                !objectType.hasOwnProperty(propName)) {\n+              objectType = objectType.getImplicitPrototype();\n+            }\n           }\n         }\n-\n         // Don't show complex function names or anonymous types.\n         // Instead, try to get a human-readable type name.\n-        if (objectType != null &&\n-            (objectType.getConstructor() != null ||\n-             objectType.isFunctionPrototypeType())) {\n-          return objectType.toString() + \".\" + propName;\n+        if (objectType != null) {\n+          if (objectType.getConstructor() != null ||\n+              objectType.isFunctionPrototypeType()) {\n+            String name = objectType.toString();\n+            return name.replace(\"[]\", \"Array\").replace(\"[object \", \"\") + suffix;\n+          } else if (objectType.isRecordType()) {\n+            return \"Object\" + suffix;\n+          } else {\n+            return objectType.toString() + suffix;\n+          }\n         }\n       }\n     }\n-\n-    JSType type = getJSType(n);\n-    if (dereference) {\n-      ObjectType dereferenced = type.dereference();\n-      if (dereferenced != null) {\n-        type = dereferenced;\n+    if (type.isNamedType()) {\n+      String typeName = type.toString();\n+      if (typeName.isEmpty()) {\n+        typeName = \"<empty>\";\n+      }\n+      if (type.isEnumType()) {\n+        typeName = \"Enum.\" + typeName;\n       }\n+      return typeName + suffix;\n     }\n-    if (type.isFunctionPrototypeType() ||\n-        (type.toObjectType() != null &&\n-         type.toObjectType().getConstructor() != null)) {\n-      return type.toString();\n+    if (type.isUnionType()) {\n+      return \"Union\" + suffix;\n+    }\n+    if (type.isVoidType()) {\n+      return \"void\" + suffix;\n+    }\n+    if (type.isAnyType()) {\n+      return \"any\" + suffix;\n+    }\n+    if (type.isNoType()) {\n+      return \"<NOTYPE>\" + suffix;\n+    }\n+    if (type.isUnknownType()) {\n+      return \"<UNKNOWN>\" + suffix;\n+    }\n+    if (type.isAllType()) {\n+      return \"<ALL>\" + suffix;\n+    }\n+    if (type.isUnionType()) {\n+      return \"Union\" + suffix;\n+    }\n+    if (type.isFunctionType()) {\n+      return \"function\" + suffix;\n     }\n     String qualifiedName = n.getQualifiedName();\n     if (qualifiedName != null) {\n-      return qualifiedName;\n-    } else if (type.isFunctionType()) {\n-      // Don't show complex function names.\n-      return \"function\";\n-    } else {\n-      return type.toString();\n+      return qualifiedName + suffix;\n+    }\n+    if (type.isConstructor()) {\n+      return type.toString() + suffix;\n+    }\n+    ObjectType objectType = type.toObjectType();\n+    if (objectType != null &&\n+        objectType.getConstructor() != null) {\n+      return objectType.toString() + suffix;\n+    }\n+    if (type.isEnumType()) {\n+      String typeName = n.getLastChild().getString();\n+      return \"Enum.\" + typeName + suffix;\n     }\n+    return type.toString() + suffix;\n   }\n \n   /**",
    "result_reason": "error: non-static method getJSType(Node) cannot be referenced from a static context",
    "test_result": "ERROR"
}