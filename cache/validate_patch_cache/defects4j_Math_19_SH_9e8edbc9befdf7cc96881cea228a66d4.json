{
    "patch": "                    throw new NumberIsTooLargeException(\n                            LocalizedFormats.INFINITE_BOUND,\n                            lB[i], Double.NEGATIVE_INFINITY, true);\n                }\n            }\n            // Convert API to internal handling of boundaries.\n            boundaries = new double[2][];\n            boundaries[0] = lB;\n            boundaries[1] = uB;\n\n            // Abort early if the normalization will overflow (cf. \"encode\" method).\n            for (int i = 0; i < init.length; ++i) {\n                // even with infinite bounds, too large or small values are prohibited\n                if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n                    final double normalized = (init[i] - lB[i]) / (uB[i] - lB[i]);\n                    if (normalized > 1.0 || normalized < 0.0) {\n                        throw new NumberIsTooLargeException(\n                                LocalizedFormats.OUT_OF_BOUNDS_NORMALIZED,\n                                normalized, 0, 1, true);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\nindex 51d1c6428..ad4b45325 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/direct/CMAESOptimizer.java\n@@ -537,6 +537,25 @@ public class CMAESOptimizer\n                 boundaries[1] = uB;\n \n                 // Abort early if the normalization will overflow (cf. \"encode\" method).\n+                    throw new NumberIsTooLargeException(\n+                            LocalizedFormats.INFINITE_BOUND,\n+                            lB[i], Double.NEGATIVE_INFINITY, true);\n+                }\n+            }\n+            // Convert API to internal handling of boundaries.\n+            boundaries = new double[2][];\n+            boundaries[0] = lB;\n+            boundaries[1] = uB;\n+\n+            // Abort early if the normalization will overflow (cf. \"encode\" method).\n+            for (int i = 0; i < init.length; ++i) {\n+                // even with infinite bounds, too large or small values are prohibited\n+                if (!Double.isInfinite(lB[i]) && !Double.isInfinite(uB[i])) {\n+                    final double normalized = (init[i] - lB[i]) / (uB[i] - lB[i]);\n+                    if (normalized > 1.0 || normalized < 0.0) {\n+                        throw new NumberIsTooLargeException(\n+                                LocalizedFormats.OUT_OF_BOUNDS_NORMALIZED,\n+                                normalized, 0, 1, true);\n             }\n         } else {\n             // Convert API to internal handling of boundaries.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}