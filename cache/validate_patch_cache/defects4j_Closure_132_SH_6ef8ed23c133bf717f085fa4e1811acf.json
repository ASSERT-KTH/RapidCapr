{
    "patch": "              if (NodeUtil.mayBeObjectLitKey(lhs)) {\n                // don't convert something like \"({x:1})[a]=2;\" to\n                // \"({x:1}?({x:1}[a]=2):({})[a]=2)\", because the equivalence\n                // only holds when the object literal is evaluated only once.\n\n                // don't convert `a().b = 1, a().b = 2;` to\n                // `(temp = a()).b = 1, temp.b = 2;` because it can cause an early\n                // `a()` evaluation. This syntax is rare so the impact on code size\n                // is negligible\n                Node name = lhs.getFirstChild();\n                if (!NodeUtil.mayHaveSideEffects(lhs.getLastChild()) &&\n                    name.isString() &&\n                    !NodeUtil.isLhsOfAssign(name)) {\n                  n.removeChild(cond);\n                  Node thenExpr = thenOp.removeFirstChild();\n                  Node elseExpr = elseOp.getLastChild().detachFromParent();\n                  Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n                  Node objlit = lhs.removeFirstChild().srcref(lhs);\n                  Node ternaryNode = new Node(Token.HOOK, objlit, hookNode)\n                                         .srcref(lhs);\n                  Node assignmentNode = new Node(lhs.getType(), ternaryNode,\n                                                 elseOp.removeFirstChild())\n                                            .srcref(lhs);\n                  Node expr = NodeUtil.newExpr(assignmentNode);\n                  parent.replaceChild(n, expr);\n                  reportCodeChange();\n\n                  return expr;\n                }\n              } else if (!(NodeUtil.mayHaveSideEffects(lhs) ||\n                           NodeUtil.mayHaveSideEffects(elseOp.getFirstChild()))) {",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..2bd00ae1 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,37 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              if (NodeUtil.mayBeObjectLitKey(lhs)) {\n+                // don't convert something like \"({x:1})[a]=2;\" to\n+                // \"({x:1}?({x:1}[a]=2):({})[a]=2)\", because the equivalence\n+                // only holds when the object literal is evaluated only once.\n+\n+                // don't convert `a().b = 1, a().b = 2;` to\n+                // `(temp = a()).b = 1, temp.b = 2;` because it can cause an early\n+                // `a()` evaluation. This syntax is rare so the impact on code size\n+                // is negligible\n+                Node name = lhs.getFirstChild();\n+                if (!NodeUtil.mayHaveSideEffects(lhs.getLastChild()) &&\n+                    name.isString() &&\n+                    !NodeUtil.isLhsOfAssign(name)) {\n+                  n.removeChild(cond);\n+                  Node thenExpr = thenOp.removeFirstChild();\n+                  Node elseExpr = elseOp.getLastChild().detachFromParent();\n+                  Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n+                  Node objlit = lhs.removeFirstChild().srcref(lhs);\n+                  Node ternaryNode = new Node(Token.HOOK, objlit, hookNode)\n+                                         .srcref(lhs);\n+                  Node assignmentNode = new Node(lhs.getType(), ternaryNode,\n+                                                 elseOp.removeFirstChild())\n+                                            .srcref(lhs);\n+                  Node expr = NodeUtil.newExpr(assignmentNode);\n+                  parent.replaceChild(n, expr);\n+                  reportCodeChange();\n+\n+                  return expr;\n+                }\n+              } else if (!(NodeUtil.mayHaveSideEffects(lhs) ||\n+                           NodeUtil.mayHaveSideEffects(elseOp.getFirstChild()))) {\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}