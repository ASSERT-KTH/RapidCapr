{
    "patch": "if (offsetLocal > offsetAdjusted) {\n     long prevLocal = previousTransition(instantAdjusted);\n     long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n     if (prevLocal != prevAdjusted) {\n          return offsetLocal;\n     } else {\n          // if the previous transition before instantLocal-adjusted is \n          // the same as previousTransition(instantAdjusted), then we need\n          // to check whether instantAdjusted is in an overlap and if it \n          // is, we need to use the earlier (standard) offset.\n          long prevOverlapEndLocal = previousTransition(prevLocal);\n          if (prevOverlapEndLocal > instantLocal - offsetAdjusted) {\n               return getStandardOffset(prevLocal);\n          }\n     }\n} else if (offsetLocal < offsetAdjusted) {\n     long nextLocal = nextTransition(instantAdjusted);\n     long nextAdjusted = nextTransition(instantLocal - offsetLocal);\n     // Ensure that time is always after the DST gap\n     if (nextLocal == nextAdjusted) {\n          if (offsetLocal < 0) {\n               long prevLocal = previousTransition(instantAdjusted);\n               long prevAdjusted = previousTransition(instantLocal - offsetLocal);\n               if (prevAdjusted < instantAdjusted && prevLocal > instantAdjusted) {\n                    // if so, use the earlier offset\n                    return getOffset(prevLocal);\n               }\n          }\n          return offsetLocal;\n     }\n     // if we just return offsetAdjusted then the time is pushed\n     // back before the transition, whereas it should be\n     // on or after the transition\n     if ((nextLocal - instantAdjusted) <= (nextAdjusted - instantLocal)) {\n          return offsetLocal;\n     } else {\n          int beforeDstOffset = offsetLocal - getStandardOffset(nextAdjusted);\n          int afterDstOffset = getOffset(nextAdjusted);\n          if (beforeDstOffset < afterDstOffset) {\n               return offsetLocal;\n          }\n     }\n}\nreturn offsetAdjusted; ",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..5dcc457d 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,50 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal > offsetAdjusted) {\n+     long prevLocal = previousTransition(instantAdjusted);\n+     long prevAdjusted = previousTransition(instantLocal - offsetAdjusted);\n+     if (prevLocal != prevAdjusted) {\n+          return offsetLocal;\n+     } else {\n+          // if the previous transition before instantLocal-adjusted is \n+          // the same as previousTransition(instantAdjusted), then we need\n+          // to check whether instantAdjusted is in an overlap and if it \n+          // is, we need to use the earlier (standard) offset.\n+          long prevOverlapEndLocal = previousTransition(prevLocal);\n+          if (prevOverlapEndLocal > instantLocal - offsetAdjusted) {\n+               return getStandardOffset(prevLocal);\n+          }\n+     }\n+} else if (offsetLocal < offsetAdjusted) {\n+     long nextLocal = nextTransition(instantAdjusted);\n+     long nextAdjusted = nextTransition(instantLocal - offsetLocal);\n+     // Ensure that time is always after the DST gap\n+     if (nextLocal == nextAdjusted) {\n+          if (offsetLocal < 0) {\n+               long prevLocal = previousTransition(instantAdjusted);\n+               long prevAdjusted = previousTransition(instantLocal - offsetLocal);\n+               if (prevAdjusted < instantAdjusted && prevLocal > instantAdjusted) {\n+                    // if so, use the earlier offset\n+                    return getOffset(prevLocal);\n+               }\n+          }\n+          return offsetLocal;\n+     }\n+     // if we just return offsetAdjusted then the time is pushed\n+     // back before the transition, whereas it should be\n+     // on or after the transition\n+     if ((nextLocal - instantAdjusted) <= (nextAdjusted - instantLocal)) {\n+          return offsetLocal;\n+     } else {\n+          int beforeDstOffset = offsetLocal - getStandardOffset(nextAdjusted);\n+          int afterDstOffset = getOffset(nextAdjusted);\n+          if (beforeDstOffset < afterDstOffset) {\n+               return offsetLocal;\n+          }\n+     }\n+}\n+return offsetAdjusted; \n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.AssertionFailedError: expected:<false> but was:<true>",
    "test_result": "FAIL"
}