{
    "patch": "    Node function = fnScope.getRootNode();\n    Preconditions.checkState(NodeUtil.isFunctionDeclaration(function), function);\n\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    // To remove an argument, we simply detach it from the tree. We can't\n    // just hide it in case the function is accessed through arguments\n    // (this could happen if arguments is passed around as a first class\n    // object). As an example:\n    //    function f() { return arguments[0]; }\n    // The function will still return its first argument even if the\n    // arguments object is passed around.\n    //\n    // To remove a parameter, we must replace all references to it with a\n    // substitute value. We need to create a substitute value that will\n    // be branch-merged in every reference's dominator chain. We choose\n    // the shortest dominator chain, and create a VAR node with that name.\n    //\n    // It is unlikely that any production source code will create too deep\n    // a branch structure, and the variable substitution rate should usually\n    // be very low.\n    boolean isVarArgs = NodeUtil.isVarArgsFunction(function);\n    FunctionTypeI functionType = JSType.toFunctionType(function.getType());\n    ImmutableList.Builder<Node> argNodes = ImmutableList.builder();\n    for (Node arg = function.getLastChild().getFirstChild();\n             arg != null; arg = arg.getNext()) {\n      if (!arg.isRest() || (arg.isRest() && isVarArgs)) {\n        argNodes.add(arg);\n      }\n    }\n\n    List<Boolean> removed = ImmutableList.copyOf(Iterators.cycle(false));\n    int arity = argNodes.build().size();\n    List<Var> params = fnScope.getParameters();\n\n    for (int i = 0, len = Math.min(arity, params.size());\n             i < len; i++) {\n      String argName = params.get(i).getName();\n      Node argNode = argNodes.build().get(i);\n      if (!referenced.contains(params.get(i))) {\n        removed = ImmutableList.builder()\n            .addAll(Iterators.cycle(false))\n            .build()\n            .subList(0, arity);\n        Node newBlock = irFactory.createBlock();\n        ajv.runPasses(ImmutableList.of(\n            new ConditionSimplifier(),\n            new ControlFlowAnalysis(compiler, true, false),\n            new FindDominators(compiler, true),\n            new LiveVariablesAnalysis(compiler, true),\n            new PeepholeOptimizationsPass(),\n            new UnreachableCodeElimination(compiler)));\n        ajv.substituteVars(argName, newBlock, argNode, functionType,\n            fnScope, removed, params.size() > argNodes.build().size());\n        updated = true;\n        if (!Collections.disjoint(removed, referenced)) {\n          // There are some noise variables that might not have been\n          // eliminated. Remove them explicitly from the parameter list.\n          List<Var> newParams = Lists.newArrayListWithCapacity(arity - 1);\n          for (int j = 0; j < arity; j++) {\n            boolean removePar = removed.get(j) && !params.get(j).getName().isEmpty();\n            if (!removePar) {\n              newParams.add(params.get(j));\n            }\n          }\n          fnScope.setParameters(newParams);\n        }\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..784edd4b 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,78 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+    Preconditions.checkState(NodeUtil.isFunctionDeclaration(function), function);\n+\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    // To remove an argument, we simply detach it from the tree. We can't\n+    // just hide it in case the function is accessed through arguments\n+    // (this could happen if arguments is passed around as a first class\n+    // object). As an example:\n+    //    function f() { return arguments[0]; }\n+    // The function will still return its first argument even if the\n+    // arguments object is passed around.\n+    //\n+    // To remove a parameter, we must replace all references to it with a\n+    // substitute value. We need to create a substitute value that will\n+    // be branch-merged in every reference's dominator chain. We choose\n+    // the shortest dominator chain, and create a VAR node with that name.\n+    //\n+    // It is unlikely that any production source code will create too deep\n+    // a branch structure, and the variable substitution rate should usually\n+    // be very low.\n+    boolean isVarArgs = NodeUtil.isVarArgsFunction(function);\n+    FunctionTypeI functionType = JSType.toFunctionType(function.getType());\n+    ImmutableList.Builder<Node> argNodes = ImmutableList.builder();\n+    for (Node arg = function.getLastChild().getFirstChild();\n+             arg != null; arg = arg.getNext()) {\n+      if (!arg.isRest() || (arg.isRest() && isVarArgs)) {\n+        argNodes.add(arg);\n+      }\n+    }\n+\n+    List<Boolean> removed = ImmutableList.copyOf(Iterators.cycle(false));\n+    int arity = argNodes.build().size();\n+    List<Var> params = fnScope.getParameters();\n+\n+    for (int i = 0, len = Math.min(arity, params.size());\n+             i < len; i++) {\n+      String argName = params.get(i).getName();\n+      Node argNode = argNodes.build().get(i);\n+      if (!referenced.contains(params.get(i))) {\n+        removed = ImmutableList.builder()\n+            .addAll(Iterators.cycle(false))\n+            .build()\n+            .subList(0, arity);\n+        Node newBlock = irFactory.createBlock();\n+        ajv.runPasses(ImmutableList.of(\n+            new ConditionSimplifier(),\n+            new ControlFlowAnalysis(compiler, true, false),\n+            new FindDominators(compiler, true),\n+            new LiveVariablesAnalysis(compiler, true),\n+            new PeepholeOptimizationsPass(),\n+            new UnreachableCodeElimination(compiler)));\n+        ajv.substituteVars(argName, newBlock, argNode, functionType,\n+            fnScope, removed, params.size() > argNodes.build().size());\n+        updated = true;\n+        if (!Collections.disjoint(removed, referenced)) {\n+          // There are some noise variables that might not have been\n+          // eliminated. Remove them explicitly from the parameter list.\n+          List<Var> newParams = Lists.newArrayListWithCapacity(arity - 1);\n+          for (int j = 0; j < arity; j++) {\n+            boolean removePar = removed.get(j) && !params.get(j).getName().isEmpty();\n+            if (!removePar) {\n+              newParams.add(params.get(j));\n+            }\n+          }\n+          fnScope.setParameters(newParams);\n+        }\n+      }\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}