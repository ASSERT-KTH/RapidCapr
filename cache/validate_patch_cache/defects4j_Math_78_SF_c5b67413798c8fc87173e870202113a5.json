{
    "patch": "public boolean evaluateStep(final StepInterpolator interpolator)\n    throws DerivativeException, EventException, ConvergenceException {\n\n  try {\n    forward         = interpolator.isForward();\n    final double t1 = interpolator.getCurrentTime();\n    final int n     = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n    final double h  = (t1 - t0) / n;\n\n    double ta = t0;\n    double ga = g0;\n    double tb = forward ? t0 + h : t0 - h;\n\n    for (int i = 0; i < n; ++i) {\n\n      tb += forward ? h : -h;\n\n      // Evaluate handler value at the end of the substep.\n      interpolator.setInterpolatedTime(tb);\n      final double gb = handler.g(tb, interpolator.getInterpolatedState());\n\n      // Check events occurrence.\n      if (g0Positive ^ (gb >= 0)) {\n\n        // There is a sign change: an event is expected during this step.\n\n        final UnivariateRealFunction f = new UnivariateRealFunction() {\n          public double value(final double t) throws FunctionEvaluationException {\n            try {\n              interpolator.setInterpolatedTime(t);\n              return handler.g(t, interpolator.getInterpolatedState());\n            } catch (DerivativeException e) {\n              throw new FunctionEvaluationException(e, t);\n            } catch (EventException e) {\n              throw new FunctionEvaluationException(e, t);\n            }\n          }\n        };\n\n        // To avoid the wide hole issue, we check for a sign change within a shorter interval\n        // before falling back to the default interval.\n        double newTb = tb;\n        int newN;\n        boolean foundRoot = false;\n        do {\n          newTb += forward ? -convergence : convergence;\n          final double gb2 = handler.g(newTb, interpolator.getInterpolatedState());\n          if (g0Positive ^ (gb2 >= 0)) {\n            foundRoot = true;\n            break;\n          }\n          newN = Math.max(1, (int) Math.ceil(Math.abs(newTb - ta) / maxCheckInterval));\n        } while (newN == n && Math.abs(newTb - t1) > convergence);\n\n        double root;\n\n        if (foundRoot) {\n          // Interval with sign change\n          root = newTb;\n        } else {\n          // default interval with sign change\n          closing = null;\n          int signChangeIndex = -1;\n          double ap = ga;\n          for (int ii = 0; ii <= n; ii++) {\n            final double t2 = t0 + ii * h;\n            interpolator.setInterpolatedTime(t2);\n            final double gp = handler.g(t2, interpolator.getInterpolatedState());\n            if ((ii > 0) && (g0Positive ^ (gp >= 0))) {\n              signChangeIndex = ii - 1;\n              closing = new ClosestToRoot(bracketAndSolve(f, ta, t2, ga, gp));\n              break;\n            }\n            ta = t2;\n            ga = gp;\n          }\n\n          if (closing == null) {\n            // This should never happen.\n            return false;\n          }\n\n          root = closing.getClosestToRoot();\n          if ((Double.isNaN(previousEventTime) || (Math.abs(root - previousEventTime) > convergence)) &&\n              (Math.abs(root - t0) > convergence) && (Math.abs(root - t1) > convergence)) {\n            pendingEventTime = root;\n            pendingEvent = true;\n            return true;\n          }\n          ta = tb;\n          ga = gb;\n        }\n\n        if ((Math.abs(root - previousEventTime) <= convergence)) {\n          // We have already found an event at this point in time, move on to the next sub-step.\n          ta = tb;\n          ga = gb;\n        } else if ((Math.abs(root - t0) <= convergence) || (Math.abs(root - t1) <= convergence)) {\n          pendingEventTime = root;\n          pendingEvent     = true;\n          return true;\n        } else {\n          tb = root;\n          interpolator.setInterpolatedTime(tb);\n          ga = handler.g(tb, interpolator.getInterpolatedState());\n          pendingEventTime = Double.NaN;\n          pendingEvent     = false;\n        }\n\n      } else {\n        ta = tb;\n        ga = gb;\n      }\n\n    }\n\n    // No event during the whole step.\n    pendingEvent     = false;\n    pendingEventTime = Double.NaN;\n    return false;\n\n  } catch (FunctionEvaluationException e) {\n    final Throwable cause = e.getCause();\n    if ((cause != null) && (cause instanceof DerivativeException)) {\n      throw (DerivativeException) cause;\n    } else if ((cause != null) && (cause instanceof EventException)) {\n      throw (EventException) cause;\n    }\n    throw new EventException(e);\n  }\n\n}\n\nprivate class ClosestToRoot implements UnivariateRealSolver {\n  private final double root;\n  private final double functionValue;\n\n  public ClosestToRoot(final double[] solution) {\n    if (solution == null || solution.length != 2) {\n      throw new ArithmeticException(\"Invalid solution array length: \" + solution);\n    }\n\n    // store the solution\n    root = solution[0];\n    functionValue = solution[1];\n  }\n\n  public double getClosestToRoot() {\n    return root;\n  }\n\n  public double getFunctionValue() {\n    return functionValue;\n  }\n\n  @Override\n  public double solve(Function f, double min, double max, double startValue) throws MaxCountExceededException, FunctionEvaluationException {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public double solve(Function f, double min, double max) throws MaxCountExceededException, FunctionEvaluationException {\n    throw new UnsupportedOperationException();\n  }\n\n  @Override\n  public double solve(double min, double max, double initial) throws MaxCountExceededException, FunctionEvaluationException {\n    throw new UnsupportedOperationException();\n  }\n\n  public double solve(UnivariateRealFunction f, double min, double max, double startValue) throws MaxCountExceededException, FunctionEvaluationException {\n\n    // Reuse already identified root if min and max bracket the root.\n    if (functionValue == 0 ||\n        (Math.abs(max - root) <= convergence) ||\n        (Math.abs(min - root) <= convergence)) {\n      return root;\n    }\n\n    // Determine which bound is closest to the root.\n    final double fmin = f.value(min);\n    final double fmax = f.value(max);\n    double closestBound = min;\n    double closestBoundValue = fmin;\n    if (Math.abs(fmax) < Math.abs(fmin)) {\n      closestBound = max;\n      closestBoundValue = fmax;\n    }\n\n    // If the sign of the root and the closest bound differ, do not proceed with bisection.\n    // This avoids a hole in the event detection.\n    if (functionValue >= 0 && closestBoundValue < 0 ||\n        functionValue < 0 && closestBoundValue >= 0) {\n      return root;\n    }\n\n    return new BrentSolver(convergence).solve(f, Math.min(root, closestBound), Math.max(root, closestBound));\n  }\n\n  @Override\n  public double solve(UnivariateRealFunction f, double min, double max) throws MaxCountExceededException, FunctionEvaluationException {\n    return solve(f, min, max, min + 0.5 * (max - min));\n  }\n}\n\nprivate double[] bracketAndSolve(final UnivariateRealFunction f, final double a, final double b, final double ga, final double gb)\n    throws FunctionEvaluationException, ConvergenceException {\n  // This implementation is a modified version of Brent's implementation from org.apache.commons.math.analysis.solvers.BrentSolver.\n  final double eps = convergence;\n  double fa = ga;\n  double fb = gb;\n  if (fa * fb >= 0.0) {\n    throw new ConvergenceException(LocalizedFormats.SAME_SIGN_BRACKETING);\n  }\n  double c = a;\n  double fc = fa;\n  double d = b - c;\n  double e = d;\n  double minTol = 2.0 * FastMath.sqrt(eps) * FastMath.abs(c) + 0.5 * eps;\n  while (fb != 0 && FastMath.abs(d) > minTol) {\n    if (fa == fc) {\n      // Rename a, b, c and adjust bounding interval d.\n      a = c;\n      fa = fc;\n      d = b - c;\n      e = d;\n    }\n    if (FastMath.abs(fa) < FastMath.abs(fb)) {\n      // Swap roles of a and b so that b is the best approximation.\n      final double temp = a;\n      a = b;\n      b = temp;\n      temp = fa;\n      fa = fb;\n      fb = temp;\n    }\n    // Decide if the current approximation is acceptable.\n    final double m = 0.5 * (c - b);\n    if (FastMath.abs(m) <= minTol || fb == 0) {\n      // Absolute error tolerance met, or run out of iterations.\n      break;\n    }\n    if (FastMath.abs(e) < minTol ||\n        FastMath.abs(fc) <= FastMath.abs(f",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/events/EventState.java b/src/main/java/org/apache/commons/math/ode/events/EventState.java\nindex 50060650e..e50a22686 100644\n--- a/src/main/java/org/apache/commons/math/ode/events/EventState.java\n+++ b/src/main/java/org/apache/commons/math/ode/events/EventState.java\n@@ -164,103 +164,250 @@ public class EventState {\n      * cannot be evaluated\n      * @exception ConvergenceException if an event cannot be located\n      */\n-    public boolean evaluateStep(final StepInterpolator interpolator)\n-        throws DerivativeException, EventException, ConvergenceException {\n-\n-        try {\n-\n-            forward = interpolator.isForward();\n-            final double t1 = interpolator.getCurrentTime();\n-            final int    n  = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n-            final double h  = (t1 - t0) / n;\n-\n-            double ta = t0;\n-            double ga = g0;\n-            double tb = t0 + (interpolator.isForward() ? convergence : -convergence);\n-            for (int i = 0; i < n; ++i) {\n-\n-                // evaluate handler value at the end of the substep\n-                tb += h;\n-                interpolator.setInterpolatedTime(tb);\n-                final double gb = handler.g(tb, interpolator.getInterpolatedState());\n-\n-                // check events occurrence\n-                if (g0Positive ^ (gb >= 0)) {\n-                    // there is a sign change: an event is expected during this step\n-\n-                        // this is a corner case:\n-                        // - there was an event near ta,\n-                        // - there is another event between ta and tb\n-                        // - when ta was computed, convergence was reached on the \"wrong side\" of the interval\n-                        // this implies that the real sign of ga is the same as gb, so we need to slightly\n-                        // shift ta to make sure ga and gb get opposite signs and the solver won't complain\n-                        // about bracketing\n-                            // this should never happen\n-                         \n-                    // variation direction, with respect to the integration direction\n-                    increasing = gb >= ga;\n-\n-                    final UnivariateRealFunction f = new UnivariateRealFunction() {\n-                        public double value(final double t) throws FunctionEvaluationException {\n-                            try {\n-                                interpolator.setInterpolatedTime(t);\n-                                return handler.g(t, interpolator.getInterpolatedState());\n-                            } catch (DerivativeException e) {\n-                                throw new FunctionEvaluationException(e, t);\n-                            } catch (EventException e) {\n-                                throw new FunctionEvaluationException(e, t);\n-                            }\n-                        }\n-                    };\n-                    final BrentSolver solver = new BrentSolver();\n-                    solver.setAbsoluteAccuracy(convergence);\n-                    solver.setMaximalIterationCount(maxIterationCount);\n-                    final double root = (ta <= tb) ? solver.solve(f, ta, tb) : solver.solve(f, tb, ta);\n-                    if ((Math.abs(root - ta) <= convergence) &&\n-                         (Math.abs(root - previousEventTime) <= convergence)) {\n-                        // we have either found nothing or found (again ?) a past event, we simply ignore it\n-                        ta = tb;\n-                        ga = gb;\n-                    } else if (Double.isNaN(previousEventTime) ||\n-                               (Math.abs(previousEventTime - root) > convergence)) {\n-                        pendingEventTime = root;\n-                        if (pendingEvent && (Math.abs(t1 - pendingEventTime) <= convergence)) {\n-                            // we were already waiting for this event which was\n-                            // found during a previous call for a step that was\n-                            // rejected, this step must now be accepted since it\n-                            // properly ends exactly at the event occurrence\n-                            return false;\n-                        }\n-                        // either we were not waiting for the event or it has\n-                        // moved in such a way the step cannot be accepted\n-                        pendingEvent = true;\n-                        return true;\n-                    }\n-\n-                } else {\n-                    // no sign change: there is no event for now\n-                    ta = tb;\n-                    ga = gb;\n-                }\n+public boolean evaluateStep(final StepInterpolator interpolator)\n+    throws DerivativeException, EventException, ConvergenceException {\n \n+  try {\n+    forward         = interpolator.isForward();\n+    final double t1 = interpolator.getCurrentTime();\n+    final int n     = Math.max(1, (int) Math.ceil(Math.abs(t1 - t0) / maxCheckInterval));\n+    final double h  = (t1 - t0) / n;\n+\n+    double ta = t0;\n+    double ga = g0;\n+    double tb = forward ? t0 + h : t0 - h;\n+\n+    for (int i = 0; i < n; ++i) {\n+\n+      tb += forward ? h : -h;\n+\n+      // Evaluate handler value at the end of the substep.\n+      interpolator.setInterpolatedTime(tb);\n+      final double gb = handler.g(tb, interpolator.getInterpolatedState());\n+\n+      // Check events occurrence.\n+      if (g0Positive ^ (gb >= 0)) {\n+\n+        // There is a sign change: an event is expected during this step.\n+\n+        final UnivariateRealFunction f = new UnivariateRealFunction() {\n+          public double value(final double t) throws FunctionEvaluationException {\n+            try {\n+              interpolator.setInterpolatedTime(t);\n+              return handler.g(t, interpolator.getInterpolatedState());\n+            } catch (DerivativeException e) {\n+              throw new FunctionEvaluationException(e, t);\n+            } catch (EventException e) {\n+              throw new FunctionEvaluationException(e, t);\n+            }\n+          }\n+        };\n+\n+        // To avoid the wide hole issue, we check for a sign change within a shorter interval\n+        // before falling back to the default interval.\n+        double newTb = tb;\n+        int newN;\n+        boolean foundRoot = false;\n+        do {\n+          newTb += forward ? -convergence : convergence;\n+          final double gb2 = handler.g(newTb, interpolator.getInterpolatedState());\n+          if (g0Positive ^ (gb2 >= 0)) {\n+            foundRoot = true;\n+            break;\n+          }\n+          newN = Math.max(1, (int) Math.ceil(Math.abs(newTb - ta) / maxCheckInterval));\n+        } while (newN == n && Math.abs(newTb - t1) > convergence);\n+\n+        double root;\n+\n+        if (foundRoot) {\n+          // Interval with sign change\n+          root = newTb;\n+        } else {\n+          // default interval with sign change\n+          closing = null;\n+          int signChangeIndex = -1;\n+          double ap = ga;\n+          for (int ii = 0; ii <= n; ii++) {\n+            final double t2 = t0 + ii * h;\n+            interpolator.setInterpolatedTime(t2);\n+            final double gp = handler.g(t2, interpolator.getInterpolatedState());\n+            if ((ii > 0) && (g0Positive ^ (gp >= 0))) {\n+              signChangeIndex = ii - 1;\n+              closing = new ClosestToRoot(bracketAndSolve(f, ta, t2, ga, gp));\n+              break;\n             }\n+            ta = t2;\n+            ga = gp;\n+          }\n \n-            // no event during the whole step\n-            pendingEvent     = false;\n-            pendingEventTime = Double.NaN;\n+          if (closing == null) {\n+            // This should never happen.\n             return false;\n+          }\n+\n+          root = closing.getClosestToRoot();\n+          if ((Double.isNaN(previousEventTime) || (Math.abs(root - previousEventTime) > convergence)) &&\n+              (Math.abs(root - t0) > convergence) && (Math.abs(root - t1) > convergence)) {\n+            pendingEventTime = root;\n+            pendingEvent = true;\n+            return true;\n+          }\n+          ta = tb;\n+          ga = gb;\n+        }\n \n-        } catch (FunctionEvaluationException e) {\n-            final Throwable cause = e.getCause();\n-            if ((cause != null) && (cause instanceof DerivativeException)) {\n-                throw (DerivativeException) cause;\n-            } else if ((cause != null) && (cause instanceof EventException)) {\n-                throw (EventException) cause;\n-            }\n-            throw new EventException(e);\n+        if ((Math.abs(root - previousEventTime) <= convergence)) {\n+          // We have already found an event at this point in time, move on to the next sub-step.\n+          ta = tb;\n+          ga = gb;\n+        } else if ((Math.abs(root - t0) <= convergence) || (Math.abs(root - t1) <= convergence)) {\n+          pendingEventTime = root;\n+          pendingEvent     = true;\n+          return true;\n+        } else {\n+          tb = root;\n+          interpolator.setInterpolatedTime(tb);\n+          ga = handler.g(tb, interpolator.getInterpolatedState());\n+          pendingEventTime = Double.NaN;\n+          pendingEvent     = false;\n         }\n \n+      } else {\n+        ta = tb;\n+        ga = gb;\n+      }\n+\n+    }\n+\n+    // No event during the whole step.\n+    pendingEvent     = false;\n+    pendingEventTime = Double.NaN;\n+    return false;\n+\n+  } catch (FunctionEvaluationException e) {\n+    final Throwable cause = e.getCause();\n+    if ((cause != null) && (cause instanceof DerivativeException)) {\n+      throw (DerivativeException) cause;\n+    } else if ((cause != null) && (cause instanceof EventException)) {\n+      throw (EventException) cause;\n+    }\n+    throw new EventException(e);\n+  }\n+\n+}\n+\n+private class ClosestToRoot implements UnivariateRealSolver {\n+  private final double root;\n+  private final double functionValue;\n+\n+  public ClosestToRoot(final double[] solution) {\n+    if (solution == null || solution.length != 2) {\n+      throw new ArithmeticException(\"Invalid solution array length: \" + solution);\n+    }\n+\n+    // store the solution\n+    root = solution[0];\n+    functionValue = solution[1];\n+  }\n+\n+  public double getClosestToRoot() {\n+    return root;\n+  }\n+\n+  public double getFunctionValue() {\n+    return functionValue;\n+  }\n+\n+  @Override\n+  public double solve(Function f, double min, double max, double startValue) throws MaxCountExceededException, FunctionEvaluationException {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public double solve(Function f, double min, double max) throws MaxCountExceededException, FunctionEvaluationException {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  @Override\n+  public double solve(double min, double max, double initial) throws MaxCountExceededException, FunctionEvaluationException {\n+    throw new UnsupportedOperationException();\n+  }\n+\n+  public double solve(UnivariateRealFunction f, double min, double max, double startValue) throws MaxCountExceededException, FunctionEvaluationException {\n+\n+    // Reuse already identified root if min and max bracket the root.\n+    if (functionValue == 0 ||\n+        (Math.abs(max - root) <= convergence) ||\n+        (Math.abs(min - root) <= convergence)) {\n+      return root;\n+    }\n+\n+    // Determine which bound is closest to the root.\n+    final double fmin = f.value(min);\n+    final double fmax = f.value(max);\n+    double closestBound = min;\n+    double closestBoundValue = fmin;\n+    if (Math.abs(fmax) < Math.abs(fmin)) {\n+      closestBound = max;\n+      closestBoundValue = fmax;\n+    }\n+\n+    // If the sign of the root and the closest bound differ, do not proceed with bisection.\n+    // This avoids a hole in the event detection.\n+    if (functionValue >= 0 && closestBoundValue < 0 ||\n+        functionValue < 0 && closestBoundValue >= 0) {\n+      return root;\n+    }\n+\n+    return new BrentSolver(convergence).solve(f, Math.min(root, closestBound), Math.max(root, closestBound));\n+  }\n+\n+  @Override\n+  public double solve(UnivariateRealFunction f, double min, double max) throws MaxCountExceededException, FunctionEvaluationException {\n+    return solve(f, min, max, min + 0.5 * (max - min));\n+  }\n+}\n+\n+private double[] bracketAndSolve(final UnivariateRealFunction f, final double a, final double b, final double ga, final double gb)\n+    throws FunctionEvaluationException, ConvergenceException {\n+  // This implementation is a modified version of Brent's implementation from org.apache.commons.math.analysis.solvers.BrentSolver.\n+  final double eps = convergence;\n+  double fa = ga;\n+  double fb = gb;\n+  if (fa * fb >= 0.0) {\n+    throw new ConvergenceException(LocalizedFormats.SAME_SIGN_BRACKETING);\n+  }\n+  double c = a;\n+  double fc = fa;\n+  double d = b - c;\n+  double e = d;\n+  double minTol = 2.0 * FastMath.sqrt(eps) * FastMath.abs(c) + 0.5 * eps;\n+  while (fb != 0 && FastMath.abs(d) > minTol) {\n+    if (fa == fc) {\n+      // Rename a, b, c and adjust bounding interval d.\n+      a = c;\n+      fa = fc;\n+      d = b - c;\n+      e = d;\n+    }\n+    if (FastMath.abs(fa) < FastMath.abs(fb)) {\n+      // Swap roles of a and b so that b is the best approximation.\n+      final double temp = a;\n+      a = b;\n+      b = temp;\n+      temp = fa;\n+      fa = fb;\n+      fb = temp;\n+    }\n+    // Decide if the current approximation is acceptable.\n+    final double m = 0.5 * (c - b);\n+    if (FastMath.abs(m) <= minTol || fb == 0) {\n+      // Absolute error tolerance met, or run out of iterations.\n+      break;\n     }\n+    if (FastMath.abs(e) < minTol ||\n+        FastMath.abs(fc) <= FastMath.abs(f\n \n     /** Get the occurrence time of the event triggered in the current\n      * step.",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}