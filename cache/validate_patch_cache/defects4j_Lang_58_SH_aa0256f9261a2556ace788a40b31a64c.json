{
    "patch": "if (Character.isDigit(lastChar) || (lastChar == 'l' || lastChar == 'L')) {\n    String numeric;\n    if (lastChar == 'l' || lastChar == 'L') {\n        if (str.length() == 1)\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        numeric = str.substring(0, str.length() - 1);\n    }\n    else {\n        numeric = str;\n    }\n    if (StringUtils.isBlank(numeric)\n            || !Character.isDigit(numeric.charAt(0))\n            && !(numeric.charAt(0) == '-' && StringUtils.isNotBlank(numeric.substring(1))))\n        throw new NumberFormatException(str + \" is not a valid number.\");\n\n    // The following vars are used to determine whether the number is a\n    // BigInteger, a Long\n    // or a plain Integer.  They must be declared as Object to\n    // distinguish between null\n    // and 0 length.\n    Object number = null;\n    Object dec = null;\n    Object exp = null;\n    int last = numeric.length() - 1;\n    char chr = numeric.charAt(last);\n\n    // Check for a decimal point\n    int decimalPlace = str.indexOf(\".\");\n    if (decimalPlace > -1) {\n        dec = str.substring(decimalPlace + 1);\n        number = str.substring(0, decimalPlace);\n    } else {\n        number = numeric;\n    }\n\n    // Check for an exponent section\n    int exponentPos = StringUtils.indexOfAny(str, new char[]{'e', 'E'});\n    if (exponentPos > -1) {\n        if (decimalPlace > -1 && exponentPos < decimalPlace) {\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        }\n        exp = str.substring(exponentPos + 1, last + 1);\n        number = getMantissa(str.substring(0, exponentPos));\n    }\n    else if (decimalPlace > -1) {\n        char lastDigit;\n        if (dec instanceof String)\n            lastDigit = ((String) dec).charAt(((String) dec).length() - 1);\n        else\n            lastDigit = ((String) number).charAt(((String) number).length() - 1);\n\n        if (lastDigit == 'f' || lastDigit == 'F')\n            number = getFloat(numeric);\n        else if (lastDigit == 'd' || lastDigit == 'D' || dec != null)\n            number = getDouble(numeric);\n        else if (!isDigits((String) number))\n            throw new NumberFormatException(str + \" is not a valid number.\");\n    }\n\n    // If there is just a number with no '.' or 'e'/'E' parse it as an\n    // integer.  This must be\n    // done separately from the previous otherwise malformed input such\n    // as \"1f4\" will\n    // allow a NumberFormatException later on.\n    if (dec == null && exp == null) {\n        // Do we have a number in hex notation?\n        if (number instanceof String && ((String) number).toLowerCase(Locale.ROOT).startsWith(\"0x\")) {\n            number = createInteger((String) number);\n        } else {\n            number = createInteger(numeric);\n        }\n    }\n\n    // 1.0e-4 || 1.0e+4\n    if (exp != null) {\n        String expStr = (String) exp;\n        boolean isExpNegative = false;\n        if (expStr.charAt(0) == '+') {\n            expStr = expStr.substring(1);\n        } else if (expStr.charAt(0) == '-') {\n            expStr = expStr.substring(1);\n            isExpNegative = true;\n        }\n        if (!isAllDigits(expStr))\n            throw new NumberFormatException(str + \" is not a valid number.\");\n        int expValue = Integer.parseInt(expStr);\n        if (expValue > 0) {\n            if (number instanceof BigDecimal) {\n                number = ((BigDecimal) number).movePointRight(expValue);\n            } else if (number instanceof BigInteger) {\n                number = new BigDecimal((BigInteger) number,\n                        expValue);\n            } else {\n                number = getPrimitiveType(number, decimalPlace).multiply(\n                        BigDecimal.valueOf(10).pow(expValue));\n            }\n        } else if (expValue < 0) {\n            if (number instanceof BigDecimal) {\n                number = ((BigDecimal) number).movePointLeft(-expValue);\n            } else if (number instanceof BigInteger) {\n                number = BigDecimal.valueOf(((BigInteger) number).intValue()).movePointLeft(-expValue);\n            } else {\n                number = BigDecimal.valueOf(getPrimitiveType(number, decimalPlace).doubleValue() /\n                        Math.pow(10, -expValue));\n            }\n        }\n        if (isExpNegative) {\n            if (number instanceof BigDecimal) {\n                number = ((BigDecimal) number).multiply(BigDecimal.valueOf(\n                        1).divide(BigDecimal.valueOf(10).pow(expValue)));\n            } else if (number instanceof BigInteger) {\n                number = BigDecimal.valueOf(((BigInteger) number).intValue()).movePointLeft(-expValue);\n            } else {\n                number = BigDecimal.valueOf(getPrimitiveType(number, decimalPlace).doubleValue() /\n                        Math.pow(10, expValue));\n            }\n        }\n    }\n\n    if (number instanceof BigInteger) {\n        BigInteger bigInt = (BigInteger) number;\n        if (bigInt.bitLength() <= 31) {\n            number = Integer.valueOf(bigInt.intValue());\n        } else if (bigInt.bitLength() <= 63) {\n            number = Long.valueOf(bigInt.longValue());\n        }\n    }\n    return getPrimitiveType(number, decimalPlace);\n}\nelse {\n    throw new NumberFormatException(str + \" is not a valid number.\");\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/lang/math/NumberUtils.java b/src/java/org/apache/commons/lang/math/NumberUtils.java\nindex c0f06a47..597e5152 100644\n--- a/src/java/org/apache/commons/lang/math/NumberUtils.java\n+++ b/src/java/org/apache/commons/lang/math/NumberUtils.java\n@@ -451,8 +451,138 @@ public class NumberUtils {\n                 case 'L' :\n                     if (dec == null\n                         && exp == null\n-                        && isDigits(numeric.substring(1))\n-                        && (numeric.charAt(0) == '-' || Character.isDigit(numeric.charAt(0)))) {\n+if (Character.isDigit(lastChar) || (lastChar == 'l' || lastChar == 'L')) {\n+    String numeric;\n+    if (lastChar == 'l' || lastChar == 'L') {\n+        if (str.length() == 1)\n+            throw new NumberFormatException(str + \" is not a valid number.\");\n+        numeric = str.substring(0, str.length() - 1);\n+    }\n+    else {\n+        numeric = str;\n+    }\n+    if (StringUtils.isBlank(numeric)\n+            || !Character.isDigit(numeric.charAt(0))\n+            && !(numeric.charAt(0) == '-' && StringUtils.isNotBlank(numeric.substring(1))))\n+        throw new NumberFormatException(str + \" is not a valid number.\");\n+\n+    // The following vars are used to determine whether the number is a\n+    // BigInteger, a Long\n+    // or a plain Integer.  They must be declared as Object to\n+    // distinguish between null\n+    // and 0 length.\n+    Object number = null;\n+    Object dec = null;\n+    Object exp = null;\n+    int last = numeric.length() - 1;\n+    char chr = numeric.charAt(last);\n+\n+    // Check for a decimal point\n+    int decimalPlace = str.indexOf(\".\");\n+    if (decimalPlace > -1) {\n+        dec = str.substring(decimalPlace + 1);\n+        number = str.substring(0, decimalPlace);\n+    } else {\n+        number = numeric;\n+    }\n+\n+    // Check for an exponent section\n+    int exponentPos = StringUtils.indexOfAny(str, new char[]{'e', 'E'});\n+    if (exponentPos > -1) {\n+        if (decimalPlace > -1 && exponentPos < decimalPlace) {\n+            throw new NumberFormatException(str + \" is not a valid number.\");\n+        }\n+        exp = str.substring(exponentPos + 1, last + 1);\n+        number = getMantissa(str.substring(0, exponentPos));\n+    }\n+    else if (decimalPlace > -1) {\n+        char lastDigit;\n+        if (dec instanceof String)\n+            lastDigit = ((String) dec).charAt(((String) dec).length() - 1);\n+        else\n+            lastDigit = ((String) number).charAt(((String) number).length() - 1);\n+\n+        if (lastDigit == 'f' || lastDigit == 'F')\n+            number = getFloat(numeric);\n+        else if (lastDigit == 'd' || lastDigit == 'D' || dec != null)\n+            number = getDouble(numeric);\n+        else if (!isDigits((String) number))\n+            throw new NumberFormatException(str + \" is not a valid number.\");\n+    }\n+\n+    // If there is just a number with no '.' or 'e'/'E' parse it as an\n+    // integer.  This must be\n+    // done separately from the previous otherwise malformed input such\n+    // as \"1f4\" will\n+    // allow a NumberFormatException later on.\n+    if (dec == null && exp == null) {\n+        // Do we have a number in hex notation?\n+        if (number instanceof String && ((String) number).toLowerCase(Locale.ROOT).startsWith(\"0x\")) {\n+            number = createInteger((String) number);\n+        } else {\n+            number = createInteger(numeric);\n+        }\n+    }\n+\n+    // 1.0e-4 || 1.0e+4\n+    if (exp != null) {\n+        String expStr = (String) exp;\n+        boolean isExpNegative = false;\n+        if (expStr.charAt(0) == '+') {\n+            expStr = expStr.substring(1);\n+        } else if (expStr.charAt(0) == '-') {\n+            expStr = expStr.substring(1);\n+            isExpNegative = true;\n+        }\n+        if (!isAllDigits(expStr))\n+            throw new NumberFormatException(str + \" is not a valid number.\");\n+        int expValue = Integer.parseInt(expStr);\n+        if (expValue > 0) {\n+            if (number instanceof BigDecimal) {\n+                number = ((BigDecimal) number).movePointRight(expValue);\n+            } else if (number instanceof BigInteger) {\n+                number = new BigDecimal((BigInteger) number,\n+                        expValue);\n+            } else {\n+                number = getPrimitiveType(number, decimalPlace).multiply(\n+                        BigDecimal.valueOf(10).pow(expValue));\n+            }\n+        } else if (expValue < 0) {\n+            if (number instanceof BigDecimal) {\n+                number = ((BigDecimal) number).movePointLeft(-expValue);\n+            } else if (number instanceof BigInteger) {\n+                number = BigDecimal.valueOf(((BigInteger) number).intValue()).movePointLeft(-expValue);\n+            } else {\n+                number = BigDecimal.valueOf(getPrimitiveType(number, decimalPlace).doubleValue() /\n+                        Math.pow(10, -expValue));\n+            }\n+        }\n+        if (isExpNegative) {\n+            if (number instanceof BigDecimal) {\n+                number = ((BigDecimal) number).multiply(BigDecimal.valueOf(\n+                        1).divide(BigDecimal.valueOf(10).pow(expValue)));\n+            } else if (number instanceof BigInteger) {\n+                number = BigDecimal.valueOf(((BigInteger) number).intValue()).movePointLeft(-expValue);\n+            } else {\n+                number = BigDecimal.valueOf(getPrimitiveType(number, decimalPlace).doubleValue() /\n+                        Math.pow(10, expValue));\n+            }\n+        }\n+    }\n+\n+    if (number instanceof BigInteger) {\n+        BigInteger bigInt = (BigInteger) number;\n+        if (bigInt.bitLength() <= 31) {\n+            number = Integer.valueOf(bigInt.intValue());\n+        } else if (bigInt.bitLength() <= 63) {\n+            number = Long.valueOf(bigInt.longValue());\n+        }\n+    }\n+    return getPrimitiveType(number, decimalPlace);\n+}\n+else {\n+    throw new NumberFormatException(str + \" is not a valid number.\");\n+}\n                         try {\n                             return createLong(numeric);\n                         } catch (NumberFormatException nfe) {",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}