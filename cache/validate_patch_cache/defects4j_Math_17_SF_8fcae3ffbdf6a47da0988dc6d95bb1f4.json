{
    "patch": "    public Dfp multiply(final int x) {\n        if (isNaN()) {\n            return newInstance(this);\n        }\n        final Dfp result = newInstance(this);\n        result.exp += x;\n        if (result.exp < getMinExponent() || result.exp > getMaxExponent()) {\n            result.getField().setIEEEFlagsBits(IEEEFlags.FLAG_INEXACT);\n            if (result.exp > getMaxExponent()) {\n                result = newInstance(getZero());\n                result.getField().setIEEEFlagsBits(IEEEFlags.FLAG_OVERFLOW);\n            } else {\n                result = newInstance(getZero());\n                result.getField().setIEEEFlagsBits(IEEEFlags.FLAG_UNDERFLOW);\n            }\n            return result;\n        }\n        result.sign = sign == NEG ? NEG : POS;\n        if (x == 0) {\n            return result;\n        }\n        long rh = (long) mant[(digits-1)] << 32;\n        long rl = 0;\n        Dfp t;\n        int top;\n        int bot;\n        int i = digits-2;\n        if (x > 0) {\n            while (x > 0 && i >= 0) {\n                t = result.multiplyFast(mant[i]);\n                rh += (long)t.mant[(digits<<1)-2] << 32;\n                rl += (long)t.mant[(digits<<1)-1] << 32 >>> 32;\n                if (rl > rh) {\n                    rh++;\n                }\n                rl <<= 1;\n                if ((rh & 0x8000000000000000L) != 0) {\n                    bot = (int)(rl & DIG_MASK);\n                    rl >>>= digits;\n                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n                    rh >>>= digits;\n                    if (bot >= HALF_DIGIT) {\n                        rl++;\n                    }\n                    top = (int)(rl >>> (32-digits));\n                    if (top >= TWO_HALF_DIGITS) {\n                        rh++;\n                    }\n                    result.mant[i+2] = (int)(rh >>> (32-digits));\n                } else {\n                    bot = (int)(rl & DIG_MASK);\n                    rl >>>= digits;\n                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n                    rh >>>= digits;\n                    if (bot >= HALF_DIGIT) {\n                        rl++;\n                    }\n                    top = (int)(rl >>> (32-digits));\n                    if (top >= TWO_HALF_DIGITS) {\n                        rl++;\n                    }\n                    result.mant[i+2] = (int)(rl >>> (32-digits));\n                }\n                i--;\n                x--;\n            }\n        } else {\n            x = -x;\n            while (x > 0 && rh != 0) {\n                if ((rl & 1) != 0L) {\n                    rh |= 0x8000000000000000L;\n                }\n                rl >>>= 1;\n                if ((rh & 1) != 0L) {\n                    rl |= 0x8000000000000000L;\n                }\n                rh >>>= 1;\n                x--;\n            }\n            while (x > 0 && i >= 0) {\n                t = result.multiplyFast(mant[i]);\n                rh += (long)t.mant[(digits<<1)-2] << 32;\n                rl += (long)t.mant[(digits<<1)-1] << 32 >>> 32;\n                if (rl > rh) {\n                    rh++;\n                }\n                rl <<= 1;\n                if ((rh & 0x8000000000000000L) != 0) {\n                    bot = (int)(rl & DIG_MASK);\n                    rl >>>= digits;\n                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n                    rh >>>= digits;\n                    if (bot >= HALF_DIGIT) {\n                        rl++;\n                    }\n                    top = (int)(rl >>> (32-digits));\n                    if (top >= TWO_HALF_DIGITS) {\n                        rh++;\n                    }\n                    result.mant[i+2] = (int)(rh >>> (32-digits));\n                } else {\n                    bot = (int)(rl & DIG_MASK);\n                    rl >>>= digits;\n                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n                    rh >>>= digits;\n                    if (bot >= HALF_DIGIT) {\n                        rl++;\n                    }\n                    top = (int)(rl >>> (32-digits));\n                    if (top >= TWO_HALF_DIGITS) {\n                        rl++;\n                    }\n                    result.mant[i+2] = (int)(rl >>> (32-digits));\n                }\n                i--;\n                x--;\n            }\n            if (rh != 0) {\n                int count = (digits<<1)-2;\n                t = newInstance(getZero());\n                while (count >= 0) {\n                    t.mant[count] = (int)rh;\n                    rh >>>= 32;\n                    t.mant[count] |= (int)rl << 32 >>> 32;\n                    rl <<= 32;\n                    count--;\n                }\n                result = t;\n            }\n        }\n        if (result.mant[(digits<<1)-1] != 0) {\n            result.shiftRight();\n            result.exp++;\n        }\n        return result;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..554475054 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1600,7 +1600,140 @@ public class Dfp implements FieldElement<Dfp> {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n+        if (isNaN()) {\n+            return newInstance(this);\n+        }\n+        final Dfp result = newInstance(this);\n+        result.exp += x;\n+        if (result.exp < getMinExponent() || result.exp > getMaxExponent()) {\n+            result.getField().setIEEEFlagsBits(IEEEFlags.FLAG_INEXACT);\n+            if (result.exp > getMaxExponent()) {\n+                result = newInstance(getZero());\n+                result.getField().setIEEEFlagsBits(IEEEFlags.FLAG_OVERFLOW);\n+            } else {\n+                result = newInstance(getZero());\n+                result.getField().setIEEEFlagsBits(IEEEFlags.FLAG_UNDERFLOW);\n+            }\n+            return result;\n+        }\n+        result.sign = sign == NEG ? NEG : POS;\n+        if (x == 0) {\n+            return result;\n+        }\n+        long rh = (long) mant[(digits-1)] << 32;\n+        long rl = 0;\n+        Dfp t;\n+        int top;\n+        int bot;\n+        int i = digits-2;\n+        if (x > 0) {\n+            while (x > 0 && i >= 0) {\n+                t = result.multiplyFast(mant[i]);\n+                rh += (long)t.mant[(digits<<1)-2] << 32;\n+                rl += (long)t.mant[(digits<<1)-1] << 32 >>> 32;\n+                if (rl > rh) {\n+                    rh++;\n+                }\n+                rl <<= 1;\n+                if ((rh & 0x8000000000000000L) != 0) {\n+                    bot = (int)(rl & DIG_MASK);\n+                    rl >>>= digits;\n+                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n+                    rh >>>= digits;\n+                    if (bot >= HALF_DIGIT) {\n+                        rl++;\n+                    }\n+                    top = (int)(rl >>> (32-digits));\n+                    if (top >= TWO_HALF_DIGITS) {\n+                        rh++;\n+                    }\n+                    result.mant[i+2] = (int)(rh >>> (32-digits));\n+                } else {\n+                    bot = (int)(rl & DIG_MASK);\n+                    rl >>>= digits;\n+                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n+                    rh >>>= digits;\n+                    if (bot >= HALF_DIGIT) {\n+                        rl++;\n+                    }\n+                    top = (int)(rl >>> (32-digits));\n+                    if (top >= TWO_HALF_DIGITS) {\n+                        rl++;\n+                    }\n+                    result.mant[i+2] = (int)(rl >>> (32-digits));\n+                }\n+                i--;\n+                x--;\n+            }\n+        } else {\n+            x = -x;\n+            while (x > 0 && rh != 0) {\n+                if ((rl & 1) != 0L) {\n+                    rh |= 0x8000000000000000L;\n+                }\n+                rl >>>= 1;\n+                if ((rh & 1) != 0L) {\n+                    rl |= 0x8000000000000000L;\n+                }\n+                rh >>>= 1;\n+                x--;\n+            }\n+            while (x > 0 && i >= 0) {\n+                t = result.multiplyFast(mant[i]);\n+                rh += (long)t.mant[(digits<<1)-2] << 32;\n+                rl += (long)t.mant[(digits<<1)-1] << 32 >>> 32;\n+                if (rl > rh) {\n+                    rh++;\n+                }\n+                rl <<= 1;\n+                if ((rh & 0x8000000000000000L) != 0) {\n+                    bot = (int)(rl & DIG_MASK);\n+                    rl >>>= digits;\n+                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n+                    rh >>>= digits;\n+                    if (bot >= HALF_DIGIT) {\n+                        rl++;\n+                    }\n+                    top = (int)(rl >>> (32-digits));\n+                    if (top >= TWO_HALF_DIGITS) {\n+                        rh++;\n+                    }\n+                    result.mant[i+2] = (int)(rh >>> (32-digits));\n+                } else {\n+                    bot = (int)(rl & DIG_MASK);\n+                    rl >>>= digits;\n+                    rl |= (long)(rh & DIG_MASK) << (32-digits);\n+                    rh >>>= digits;\n+                    if (bot >= HALF_DIGIT) {\n+                        rl++;\n+                    }\n+                    top = (int)(rl >>> (32-digits));\n+                    if (top >= TWO_HALF_DIGITS) {\n+                        rl++;\n+                    }\n+                    result.mant[i+2] = (int)(rl >>> (32-digits));\n+                }\n+                i--;\n+                x--;\n+            }\n+            if (rh != 0) {\n+                int count = (digits<<1)-2;\n+                t = newInstance(getZero());\n+                while (count >= 0) {\n+                    t.mant[count] = (int)rh;\n+                    rh >>>= 32;\n+                    t.mant[count] |= (int)rl << 32 >>> 32;\n+                    rl <<= 32;\n+                    count--;\n+                }\n+                result = t;\n+            }\n+        }\n+        if (result.mant[(digits<<1)-1] != 0) {\n+            result.shiftRight();\n+            result.exp++;\n+        }\n+        return result;\n     }\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}