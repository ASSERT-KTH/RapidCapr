{
    "patch": "    if (left.isGetProp() || left.isGetElem()) {\n      Node leftFirstChild = left.getFirstChild();\n      Node leftGrandchild = leftFirstChild.getFirstChild();\n      if (left.getFirstChild().isName()\n          && (leftGrandchild == null || leftGrandchild.isNumber())) {\n        String arrayName = left.getFirstChild().getString();\n        int arrayIndex = -1;\n        if (leftGrandchild != null) {\n          arrayIndex = (int) leftGrandchild.getDouble();\n        }\n        if (parent.isAssign() && parent.getFirstChild() == n) {\n          return n;\n        }\n        Var arrayVar = getScope().getVar(arrayName);\n        if (arrayVar != null && arrayVar.getInitialValue() != null\n            && arrayVar.getInitialValue().isArrayLit()\n            && arrayVar.getInitialValue().getFirstChild().getIntProp(Node.ARRAY_LENGTH_PROP, 0)\n                > arrayIndex\n            && arrayIndex >= 0) {\n          Node replacement = arrayVar.getNameNode();\n          for (int i = 0; i < arrayIndex + 1; i++) {\n            replacement = replacement.getNext();\n          }\n          n.getParent().replaceChild(n, replacement.detach());\n          reportCodeChange();\n          return replacement;\n        }\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex 0b2636f4..93111804 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -1280,6 +1280,35 @@ class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n     // If GETPROP/GETELEM is used as assignment target the array literal is\n     // acting as a temporary we can't fold it here:\n     //    \"[][0] += 1\"\n+    if (left.isGetProp() || left.isGetElem()) {\n+      Node leftFirstChild = left.getFirstChild();\n+      Node leftGrandchild = leftFirstChild.getFirstChild();\n+      if (left.getFirstChild().isName()\n+          && (leftGrandchild == null || leftGrandchild.isNumber())) {\n+        String arrayName = left.getFirstChild().getString();\n+        int arrayIndex = -1;\n+        if (leftGrandchild != null) {\n+          arrayIndex = (int) leftGrandchild.getDouble();\n+        }\n+        if (parent.isAssign() && parent.getFirstChild() == n) {\n+          return n;\n+        }\n+        Var arrayVar = getScope().getVar(arrayName);\n+        if (arrayVar != null && arrayVar.getInitialValue() != null\n+            && arrayVar.getInitialValue().isArrayLit()\n+            && arrayVar.getInitialValue().getFirstChild().getIntProp(Node.ARRAY_LENGTH_PROP, 0)\n+                > arrayIndex\n+            && arrayIndex >= 0) {\n+          Node replacement = arrayVar.getNameNode();\n+          for (int i = 0; i < arrayIndex + 1; i++) {\n+            replacement = replacement.getNext();\n+          }\n+          n.getParent().replaceChild(n, replacement.detach());\n+          reportCodeChange();\n+          return replacement;\n+        }\n+      }\n+    }\n \n     if (right.getType() != Token.NUMBER) {\n       // Sometimes people like to use complex expressions to index into",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}