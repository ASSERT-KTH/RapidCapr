{
    "patch": "    Node block = function.getLastChild();\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }\n\n    // Remove unreferenced parameters from function definition.\n    Node param = argList.getFirstChild();\n    if (param == null) {\n      return;\n    }\n    Node paramParent = param.getParent();\n    boolean atLeastOneParam = false;\n    while (param != null) {\n      Var var = fnScope.getVar(param.getString());\n      if (!referenced.contains(var) && !NodeUtil.isVarArgs(param)) {\n        if (!atLeastOneParam) {\n          atLeastOneParam = true;\n        }\n        Node nextParam = param.getNext();\n        paramParent.removeChild(param);\n        compiler.reportCodeChange();\n        param = nextParam;\n      } else {\n        paramParent = param;\n        param = param.getNext();\n      }\n    }\n\n    // If we have removed unused parameters we must also update the \"length\" property\n    // of the function. We update the length property in the function node and any site\n    // that is using the length property in an assignment.\n    if (atLeastOneParam) {\n      Node name = function.getFirstChild();\n      Preconditions.checkState(name.isName());\n      boolean isDeclaration = function.getParent().isStatementBlock();\n      NodeUtil.setJsDocInfo(name, null);\n      int numParams = countParameters(argList);\n      if (isDeclaration) {\n        function.setParameterCount(numParams);\n      }\n      function.setIsVarArgs(NodeUtil.getFunctionParameters(function).hasRest());\n      Node lengthName = IR.string(\"length\");\n      Node lengthVal = IR.number(numParams);\n      Node lengthAssign = IR.assign(lengthName.cloneNode(), lengthVal);\n      Node lValue = name.cloneNode();\n      lValue.addChildToFront(lengthName);\n      Node rValue = isDeclaration ? lengthVal : IR.comma(lengthVal, name.cloneNode());\n      Node statement;\n      // We update the length property both in the function and at any site that has a reference to this property.\n      if (modifyCallers) {\n        NodeUtil.getAllFunctionCalls(function).forEach(call -> {\n          if (compiler.hasHaltingErrors()) {\n            return;\n          }\n          Node getter = NodeUtil.getObjectLitKeyName(call.getNext(), \"GETTER\");\n          if (getter != null) {\n            // The getter is assigned only once in case it is used by several sites.\n            Node nameNode = IR.name(getter.getString());\n            Node assignNode = IR.assign(nameNode.cloneTree(), lengthName.cloneTree());\n            NodeUtil.getEnclosingStatement(getter).getParent().addChildToFront(assignNode);\n            compiler.reportCodeChange();\n          } else {\n            Node lengthNode = IR.getprop(call, lengthName.cloneTree());\n            if (lengthNode != null) {\n              call.replaceChild(lengthNode, lengthVal.cloneTree());\n              compiler.reportCodeChange();\n            }\n          }\n        });\n      }\n      Node lengthDecl = IR.declaration(lValue, rValue);\n      if (isDeclaration) {\n        lengthDecl.putBooleanProp(Node.IS_NAMESPACE, true);\n        NodeUtil.initializeVarName(lengthAssign);\n        // In non-global scopes variables are added as VAR declarations.\n        lengthDecl.getFirstChild().addChildToBack(lengthAssign);\n        InsertionPoint point = new BeforeNodeInsertionPoint(function);\n        point.insert(compiler, lengthDecl);\n      } else {\n        NodeUtil.initializeVarName(lengthAssign);\n        statement = IR.exprResult(\n            IR.comma(lengthAssign, IR.trueNode()));\n        statement.useSourceInfoIfMissingFromForTree(function);\n        List<Node> nodes = ImmutableList.of(function,statement);\n        Node blockWithFunction = IR.block(nodes).srcrefTree(function);\n        function.replaceWith(blockWithFunction);\n        compiler.reportCodeChange();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..44283d7b 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,111 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node block = function.getLastChild();\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+      // Strip unreferenced args off the end of the function declaration.\n+      Node lastArg;\n+      while ((lastArg = argList.getLastChild()) != null) {\n+        Var var = fnScope.getVar(lastArg.getString());\n+        if (!referenced.contains(var)) {\n+          argList.removeChild(lastArg);\n+          compiler.reportCodeChange();\n+        } else {\n+          break;\n+        }\n+      }\n+    } else {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n+\n+    // Remove unreferenced parameters from function definition.\n+    Node param = argList.getFirstChild();\n+    if (param == null) {\n+      return;\n+    }\n+    Node paramParent = param.getParent();\n+    boolean atLeastOneParam = false;\n+    while (param != null) {\n+      Var var = fnScope.getVar(param.getString());\n+      if (!referenced.contains(var) && !NodeUtil.isVarArgs(param)) {\n+        if (!atLeastOneParam) {\n+          atLeastOneParam = true;\n+        }\n+        Node nextParam = param.getNext();\n+        paramParent.removeChild(param);\n+        compiler.reportCodeChange();\n+        param = nextParam;\n+      } else {\n+        paramParent = param;\n+        param = param.getNext();\n+      }\n+    }\n+\n+    // If we have removed unused parameters we must also update the \"length\" property\n+    // of the function. We update the length property in the function node and any site\n+    // that is using the length property in an assignment.\n+    if (atLeastOneParam) {\n+      Node name = function.getFirstChild();\n+      Preconditions.checkState(name.isName());\n+      boolean isDeclaration = function.getParent().isStatementBlock();\n+      NodeUtil.setJsDocInfo(name, null);\n+      int numParams = countParameters(argList);\n+      if (isDeclaration) {\n+        function.setParameterCount(numParams);\n+      }\n+      function.setIsVarArgs(NodeUtil.getFunctionParameters(function).hasRest());\n+      Node lengthName = IR.string(\"length\");\n+      Node lengthVal = IR.number(numParams);\n+      Node lengthAssign = IR.assign(lengthName.cloneNode(), lengthVal);\n+      Node lValue = name.cloneNode();\n+      lValue.addChildToFront(lengthName);\n+      Node rValue = isDeclaration ? lengthVal : IR.comma(lengthVal, name.cloneNode());\n+      Node statement;\n+      // We update the length property both in the function and at any site that has a reference to this property.\n+      if (modifyCallers) {\n+        NodeUtil.getAllFunctionCalls(function).forEach(call -> {\n+          if (compiler.hasHaltingErrors()) {\n+            return;\n+          }\n+          Node getter = NodeUtil.getObjectLitKeyName(call.getNext(), \"GETTER\");\n+          if (getter != null) {\n+            // The getter is assigned only once in case it is used by several sites.\n+            Node nameNode = IR.name(getter.getString());\n+            Node assignNode = IR.assign(nameNode.cloneTree(), lengthName.cloneTree());\n+            NodeUtil.getEnclosingStatement(getter).getParent().addChildToFront(assignNode);\n+            compiler.reportCodeChange();\n+          } else {\n+            Node lengthNode = IR.getprop(call, lengthName.cloneTree());\n+            if (lengthNode != null) {\n+              call.replaceChild(lengthNode, lengthVal.cloneTree());\n+              compiler.reportCodeChange();\n+            }\n+          }\n+        });\n+      }\n+      Node lengthDecl = IR.declaration(lValue, rValue);\n+      if (isDeclaration) {\n+        lengthDecl.putBooleanProp(Node.IS_NAMESPACE, true);\n+        NodeUtil.initializeVarName(lengthAssign);\n+        // In non-global scopes variables are added as VAR declarations.\n+        lengthDecl.getFirstChild().addChildToBack(lengthAssign);\n+        InsertionPoint point = new BeforeNodeInsertionPoint(function);\n+        point.insert(compiler, lengthDecl);\n+      } else {\n+        NodeUtil.initializeVarName(lengthAssign);\n+        statement = IR.exprResult(\n+            IR.comma(lengthAssign, IR.trueNode()));\n+        statement.useSourceInfoIfMissingFromForTree(function);\n+        List<Node> nodes = ImmutableList.of(function,statement);\n+        Node blockWithFunction = IR.block(nodes).srcrefTree(function);\n+        function.replaceWith(blockWithFunction);\n+        compiler.reportCodeChange();\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}