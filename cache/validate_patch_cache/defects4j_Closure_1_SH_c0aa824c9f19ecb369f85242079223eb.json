{
    "patch": "Node function = fnScope.getRootNode();\nPreconditions.checkState(function.isFunction());\nif (NodeUtil.isGetOrSetKey(function.getParent())) {\n  // The parameters object literal setters can not be removed.\n  return;\n}\n\nNode argList = getFunctionArgList(function);\nboolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(fnScope);\nif (!modifyCallers) {\n   // Strip unreferenced args off the end of the function declaration.\n   Node lastArg = argList.getLastChild();\n   while (lastArg != null) {\n     Var var = fnScope.getVar(lastArg.getString());\n     if (!referenced.contains(var)) {\n       argList.removeChild(lastArg);\n       if (lastArg.hasChildren()) {\n         Node defaultVal = lastArg.getFirstChild();\n         lastArg.removeChild(defaultVal);\n         defaultValsToRemove.add(defaultVal);\n       }\n       compiler.reportCodeChange();\n       // Because we just removed the last argument to a function, we\n       // know that any calls relying on the last argument aren't modifying\n       // it or using it, and we can therefore remove the last argument(s)\n       // from those calls.\n       callSiteOptimizer.optimizeCallsReferencingNode(argList);\n       lastArg = argList.getLastChild();\n     } else {\n       break;\n     }\n   }\n} else {\n   callSiteOptimizer.optimize(fnScope, referenced);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..d3e87caf 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,41 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+Node function = fnScope.getRootNode();\n+Preconditions.checkState(function.isFunction());\n+if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+  // The parameters object literal setters can not be removed.\n+  return;\n+}\n+\n+Node argList = getFunctionArgList(function);\n+boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(fnScope);\n+if (!modifyCallers) {\n+   // Strip unreferenced args off the end of the function declaration.\n+   Node lastArg = argList.getLastChild();\n+   while (lastArg != null) {\n+     Var var = fnScope.getVar(lastArg.getString());\n+     if (!referenced.contains(var)) {\n+       argList.removeChild(lastArg);\n+       if (lastArg.hasChildren()) {\n+         Node defaultVal = lastArg.getFirstChild();\n+         lastArg.removeChild(defaultVal);\n+         defaultValsToRemove.add(defaultVal);\n+       }\n+       compiler.reportCodeChange();\n+       // Because we just removed the last argument to a function, we\n+       // know that any calls relying on the last argument aren't modifying\n+       // it or using it, and we can therefore remove the last argument(s)\n+       // from those calls.\n+       callSiteOptimizer.optimizeCallsReferencingNode(argList);\n+       lastArg = argList.getLastChild();\n+     } else {\n+       break;\n+     }\n+   }\n+} else {\n+   callSiteOptimizer.optimize(fnScope, referenced);\n+}\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: method canModifyCallers in class CallSiteOptimizer cannot be applied to given types;",
    "test_result": "ERROR"
}