{
    "patch": "public Dfp multiply(final int x) {\n        if (isNaN()) {\n            return newInstance(this);\n        }\n        if (x == 0) {\n            return getZero();\n        }\n        if (x == 1) {\n            return newInstance(this);\n        }\n        final DfpField field = getField();\n        final int[] product = new int[2];\n        Dfp wp = newInstance(this);\n        Dfp r = newInstance(getZero());\n        int xi = Math.abs(x);\n        int[] productHigh = new int[2];\n        int q = 0;\n        while (xi > 0) {\n            q = xi % 10000;\n            xi /= 10000;\n            split(q);\n            product[0] = (int)split[0];\n            product[1] = (int)(split[0] - product[0]);\n            split(q * split[0]);\n            productHigh[0] = (int)split[0];\n            productHigh[1] = (int)(split[0] - productHigh[0]);\n            wp.split(product[1]);\n            r.selfAdd(wp.selfMultiply(productHigh[1]));\n            r.selfShiftLeft(4);\n            wp.set(split[1]);\n            r.selfAdd(wp.selfMultiply(productHigh[0]));\n            if (xi == 0) {\n                break;\n            }\n            wp.split(product[0]);\n            r.selfAdd(wp.selfMultiply(productHigh[1]));\n            r.selfShiftLeft(4);\n            wp.set(split[1]);\n            r.selfAdd(wp.selfMultiply(productHigh[0]));\n            r.selfShiftLeft(4);\n        }\n        r.sign = (x < 0) ^ (sign < 0);\n        r.round(r.getRounding());\n        return r;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..8eb21bfdb 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1599,8 +1599,50 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param x multiplicand\n      * @return product of this and x\n      */\n-    public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n+public Dfp multiply(final int x) {\n+        if (isNaN()) {\n+            return newInstance(this);\n+        }\n+        if (x == 0) {\n+            return getZero();\n+        }\n+        if (x == 1) {\n+            return newInstance(this);\n+        }\n+        final DfpField field = getField();\n+        final int[] product = new int[2];\n+        Dfp wp = newInstance(this);\n+        Dfp r = newInstance(getZero());\n+        int xi = Math.abs(x);\n+        int[] productHigh = new int[2];\n+        int q = 0;\n+        while (xi > 0) {\n+            q = xi % 10000;\n+            xi /= 10000;\n+            split(q);\n+            product[0] = (int)split[0];\n+            product[1] = (int)(split[0] - product[0]);\n+            split(q * split[0]);\n+            productHigh[0] = (int)split[0];\n+            productHigh[1] = (int)(split[0] - productHigh[0]);\n+            wp.split(product[1]);\n+            r.selfAdd(wp.selfMultiply(productHigh[1]));\n+            r.selfShiftLeft(4);\n+            wp.set(split[1]);\n+            r.selfAdd(wp.selfMultiply(productHigh[0]));\n+            if (xi == 0) {\n+                break;\n+            }\n+            wp.split(product[0]);\n+            r.selfAdd(wp.selfMultiply(productHigh[1]));\n+            r.selfShiftLeft(4);\n+            wp.set(split[1]);\n+            r.selfAdd(wp.selfMultiply(productHigh[0]));\n+            r.selfShiftLeft(4);\n+        }\n+        r.sign = (x < 0) ^ (sign < 0);\n+        r.round(r.getRounding());\n+        return r;\n     }\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}