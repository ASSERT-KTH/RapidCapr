{
    "patch": "      if (name.globalSets > 0 ||\n          (name.aliasingGets > 0 && name.localSets > 0)) {\n        // If this is an object literal that is referenced only once, we\n        // will leave it be. We convert the object lit into an object\n        // so that CollapseProperties has a better chance of removing\n        // properties -> collapse object -> redefine properties.\n        if (name.type == NameType.OBJECTLIT && name.getRefs().size() == 1) {\n          this.objectLitsToCollapse.add(name);\n          continue;\n        }\n\n        // If this is an object literal that is used as part of an\n        // assignment to a variable (but not used as a standalone variable), copy\n        // any properties on the object literal onto the variable.\n        if (name.type == NameType.OBJECTLIT && name.props != null &&\n            name.getRefs().size() == 2) {\n          Iterator<Ref> iter = name.getRefs().iterator();\n          Ref objectRef = iter.next();\n          Ref nameRef = iter.next();\n          if (nameRef.type == Ref.Type.SET_FROM_GLOBAL &&\n              nameRef.getTwin().type == Ref.Type.ALIASING_GET) {\n            inlineObjectLiteralsOntoOwner(name, objectRef, namespace);\n          }\n        }\n        continue;\n      }\n",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..c4c4987a 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,33 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+      if (name.globalSets > 0 ||\n+          (name.aliasingGets > 0 && name.localSets > 0)) {\n+        // If this is an object literal that is referenced only once, we\n+        // will leave it be. We convert the object lit into an object\n+        // so that CollapseProperties has a better chance of removing\n+        // properties -> collapse object -> redefine properties.\n+        if (name.type == NameType.OBJECTLIT && name.getRefs().size() == 1) {\n+          this.objectLitsToCollapse.add(name);\n+          continue;\n+        }\n+\n+        // If this is an object literal that is used as part of an\n+        // assignment to a variable (but not used as a standalone variable), copy\n+        // any properties on the object literal onto the variable.\n+        if (name.type == NameType.OBJECTLIT && name.props != null &&\n+            name.getRefs().size() == 2) {\n+          Iterator<Ref> iter = name.getRefs().iterator();\n+          Ref objectRef = iter.next();\n+          Ref nameRef = iter.next();\n+          if (nameRef.type == Ref.Type.SET_FROM_GLOBAL &&\n+              nameRef.getTwin().type == Ref.Type.ALIASING_GET) {\n+            inlineObjectLiteralsOntoOwner(name, objectRef, namespace);\n+          }\n+        }\n+        continue;\n+      }\n+\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: not a statement",
    "test_result": "ERROR"
}