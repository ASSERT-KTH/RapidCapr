{
    "patch": "  private Node tryMinimizeIf(Node n) {\n\n    Node parent = n.getParent();\n\n    Node cond = n.getFirstChild();\n\n    /* If the condition is a literal, we'll let other\n     * optimizations try to remove useless code.\n     */\n    if (NodeUtil.isLiteralValue(cond, true)) {\n      return n;\n    }\n\n    Node thenBranch = cond.getNext();\n    Node elseBranch = thenBranch.getNext();\n\n    if (elseBranch == null) {\n      if (isFoldableExpressBlock(thenBranch)) {\n        Node expr = getBlockExpression(thenBranch);\n        if (!late && isPropertyAssignmentInExpression(expr)) {\n          // Keep opportunities for CollapseProperties such as\n          // a.longIdentifier || a.longIdentifier = ... -> var a = ...;\n          // until CollapseProperties has been run.\n          return n;\n        }\n\n        if (cond.isNot()) {\n          // if(!x)bar(); -> x||bar();\n          if (isLowerPrecedenceInExpression(cond, OR_PRECEDENCE) &&\n              isLowerPrecedenceInExpression(expr.getFirstChild(),\n                  OR_PRECEDENCE)) {\n            // It's not okay to add two sets of parentheses.\n            return n;\n          }\n\n          Node or = IR.or(\n              cond.removeFirstChild(),\n              expr.removeFirstChild()).srcref(n);\n          Node newExpr = NodeUtil.newExpr(or);\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n\n          return newExpr;\n        }\n\n        // if(x)foo(); -> x&&foo();\n        if (isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n            isLowerPrecedenceInExpression(expr.getFirstChild(),\n                AND_PRECEDENCE)) {\n          // One additional set of parentheses is worth the change even if\n          // there is no immediate code size win. However, two extra pair of\n          // {}, we would have to think twice. (unless we know for sure the\n          // we can further optimize its parent.\n          return n;\n        }\n\n        n.removeChild(cond);\n        Node and = IR.and(cond, expr.removeFirstChild()).srcref(n);\n        Node newExpr = NodeUtil.newExpr(and);\n        parent.replaceChild(n, newExpr);\n        reportCodeChange();\n\n        return newExpr;\n      } else {\n\n        // Try to combine two IF-ELSE\n        if (NodeUtil.isStatementBlock(thenBranch) &&\n            thenBranch.hasOneChild()) {\n          Node innerIf = thenBranch.getFirstChild();\n\n          if (innerIf.isIf()) {\n            Node innerCond = innerIf.getFirstChild();\n            Node innerThenBranch = innerCond.getNext();\n            Node innerElseBranch = innerThenBranch.getNext();\n\n            if (innerElseBranch == null &&\n                 !(isLowerPrecedenceInExpression(cond, AND_PRECEDENCE) &&\n                   isLowerPrecedenceInExpression(innerCond, AND_PRECEDENCE))) {\n              n.detachChildren();\n              n.addChildToBack(\n                  IR.and(\n                      cond,\n                      innerCond.detachFromParent())\n                      .srcref(cond));\n              n.addChildrenToBack(innerThenBranch.detachFromParent());\n              reportCodeChange();\n              // Not worth trying to fold the current IF-ELSE into && because\n              // the inner IF-ELSE wasn't able to be folded into && anyways.\n              return n;\n            }\n          }\n        }\n      }\n\n      return n;\n    }\n\n    /* TODO(dcc) This modifies the siblings of n, which is undesirable for a\n     * peephole optimization. This should probably get moved to another pass.\n     */\n    tryRemoveRepeatedStatements(n);\n\n    // if(!x)foo();else bar(); -> if(x)bar();else foo();\n    // An additional set of curly braces isn't worth it.\n    if (cond.isNot() && !consumesDanglingElse(elseBranch)) {\n      n.replaceChild(cond, cond.removeFirstChild());\n      n.removeChild(thenBranch);\n      n.addChildToBack(thenBranch);\n      reportCodeChange();\n      return n;\n\n    } else if (cond.isAnd() && !consumesDanglingElse(elseBranch)) {\n      // if (x && y) { ... } else { ... }\n      // ->\n      // if (!x || !y) { ... } else { ... }\n      int numAnds = 0;\n      while (cond.isAnd()) {\n        ++numAnds;\n        cond = cond.getFirstChild();\n      }\n      Node notCond = IR.not(cond.detach());\n      for (int i = 1; i < numAnds; ++i) {\n        notCond = IR.or(notCond, IR.not(cond.detach()));\n      }\n      Node condBranch = IR.ifNode(notCond, elseBranch.detach(), null)\n                             .maker(n.getAstNode()).srcref(n);\n      n.removeChild(cond);\n      n.removeChild(elseBranch);\n      n.addChildToFront(condBranch);\n      condBranch.addChildToBack(thenBranch.detach());\n      reportCodeChange();\n      return condBranch;\n\n    } else if (cond.isOr() && thenBranch.isBlock() &&\n        thenBranch.hasChildren()) {\n      // if (x || y) { z(); } -> x || (z(), y);\n      // Must also make sure that y ends with a semicolon.\n      // See ECMA-262 11.11, third bullet point.\n      Node lhs = cond.getFirstChild();\n      Node rhs = cond.getLastChild();\n      Node expr = getNonEmptyExpression(rhs);\n      if (lhs != null && !NodeUtil.mayHaveSideEffects(lhs) && expr != null &&\n          NodeUtil.isStatementBlock(thenBranch)) {\n        Node lastChild = getLastStatement(thenBranch);\n        if (lastChild == null) {\n          // Empty block, can remove.\n          parent.replaceChild(n, rhs.detach());\n          return rhs;\n        } else if (lastChild.isExprResult() &&\n            lastChild.getFirstChild().isComma()) {\n          // Use existing comma expression.\n          lastChild.getFirstChild().addChildToBack(expr.detach());\n          parent.replaceChild(n, IR.or(lhs.detach(), thenBranch.detach()));\n          reportCodeChange();\n          return n;\n        } else {\n          // Create a new comma expression and set its result to the last\n          // statement in thenBranch.\n          Node newExpr = createIfElseExpression(\n              n, IR.comma(lhs.detach(), IR.seq(thenBranch.detach(), expr)));\n          parent.replaceChild(n, newExpr);\n          reportCodeChange();\n          return newExpr;\n        }\n      }\n    } else if (isTwoStatementIf(elseBranch)) {\n      // As a special case, recognize a two-statement sequence as\n      // a legal consequence of a then-if-branch to change this\n      // code pattern:\n      //\n      // if (cond)\n      //   single_stmt;\n      // else\n      //   two_stmt_sequence;\n      //\n      // to this code pattern:\n      //\n      // if (!cond)\n      //  two_stmt_sequence;\n      // else\n      //   single_stmt;\n      Node stmt1 = elseBranch.getFirstChild();\n      Node stmt2 = elseBranch.getLastChild();\n      Node newElse = IR.block(IR.empty()).srcref(elseBranch);\n      elseBranch.removeChild(stmt2);\n      elseBranch.replaceWith(newElse);\n      Node notCond = IR.not(cond.detach());\n      Node ifNode = IR.ifNode(notCond, elseBranch, null)\n                         .maker(n.getAstNode()).srcref(n);\n      n.replaceChildren(cond, stmt1);\n      newElse.addChildrenToFront(stmt2);\n      n.addChildToBack(ifNode);\n      reportCodeChange();\n      return ifNode;\n    }\n\n    // if(x)return 1;else return 2; -> return x?1:2;\n    if (isReturnExpressBlock(thenBranch) && isReturnExpressBlock(elseBranch)) {\n      Node thenExpr = getBlockReturnExpression(thenBranch);\n      Node elseExpr = getBlockReturnExpression(elseBranch);\n      n.removeChild(cond);\n      thenExpr.detachFromParent();\n      elseExpr.detachFromParent();\n\n      // note - we ignore any cases with \"return;\", technically this\n      // can be converted to \"return undefined;\" or some variant, but\n      // that does not help code size.\n      Node returnNode = IR.returnNode(\n                            IR.hook(cond, thenExpr, elseExpr)\n                                .srcref(n));\n      parent.replaceChild(n, returnNode);\n      reportCodeChange();\n      return returnNode;\n    }\n\n    boolean thenBranchIsExpressionBlock = isFoldableExpressBlock(thenBranch);\n    boolean elseBranchIsExpressionBlock = isFoldableExpressBlock(elseBranch);\n\n    if (thenBranchIsExpressionBlock && elseBranchIsExpressionBlock) {\n      Node thenOp = getBlockExpression(thenBranch).getFirstChild();\n      Node elseOp = getBlockExpression(elseBranch).getFirstChild();\n      if (thenOp.getType() == elseOp.getType()) {\n        // if(x)a=1;else a=2; -> a=x?1:2;\n        if (NodeUtil.isAssignmentOp(thenOp)) {\n          Node lhs = thenOp.getFirstChild();\n          if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n              // if LHS has side effects, don'",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..b0c7a607 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -743,6 +743,90 @@ class PeepholeSubstituteAlternateSyntax\n       n.addChildToBack(thenBranch);\n       reportCodeChange();\n       return n;\n+\n+    } else if (cond.isAnd() && !consumesDanglingElse(elseBranch)) {\n+      // if (x && y) { ... } else { ... }\n+      // ->\n+      // if (!x || !y) { ... } else { ... }\n+      int numAnds = 0;\n+      while (cond.isAnd()) {\n+        ++numAnds;\n+        cond = cond.getFirstChild();\n+      }\n+      Node notCond = IR.not(cond.detach());\n+      for (int i = 1; i < numAnds; ++i) {\n+        notCond = IR.or(notCond, IR.not(cond.detach()));\n+      }\n+      Node condBranch = IR.ifNode(notCond, elseBranch.detach(), null)\n+                             .maker(n.getAstNode()).srcref(n);\n+      n.removeChild(cond);\n+      n.removeChild(elseBranch);\n+      n.addChildToFront(condBranch);\n+      condBranch.addChildToBack(thenBranch.detach());\n+      reportCodeChange();\n+      return condBranch;\n+\n+    } else if (cond.isOr() && thenBranch.isBlock() &&\n+        thenBranch.hasChildren()) {\n+      // if (x || y) { z(); } -> x || (z(), y);\n+      // Must also make sure that y ends with a semicolon.\n+      // See ECMA-262 11.11, third bullet point.\n+      Node lhs = cond.getFirstChild();\n+      Node rhs = cond.getLastChild();\n+      Node expr = getNonEmptyExpression(rhs);\n+      if (lhs != null && !NodeUtil.mayHaveSideEffects(lhs) && expr != null &&\n+          NodeUtil.isStatementBlock(thenBranch)) {\n+        Node lastChild = getLastStatement(thenBranch);\n+        if (lastChild == null) {\n+          // Empty block, can remove.\n+          parent.replaceChild(n, rhs.detach());\n+          return rhs;\n+        } else if (lastChild.isExprResult() &&\n+            lastChild.getFirstChild().isComma()) {\n+          // Use existing comma expression.\n+          lastChild.getFirstChild().addChildToBack(expr.detach());\n+          parent.replaceChild(n, IR.or(lhs.detach(), thenBranch.detach()));\n+          reportCodeChange();\n+          return n;\n+        } else {\n+          // Create a new comma expression and set its result to the last\n+          // statement in thenBranch.\n+          Node newExpr = createIfElseExpression(\n+              n, IR.comma(lhs.detach(), IR.seq(thenBranch.detach(), expr)));\n+          parent.replaceChild(n, newExpr);\n+          reportCodeChange();\n+          return newExpr;\n+        }\n+      }\n+    } else if (isTwoStatementIf(elseBranch)) {\n+      // As a special case, recognize a two-statement sequence as\n+      // a legal consequence of a then-if-branch to change this\n+      // code pattern:\n+      //\n+      // if (cond)\n+      //   single_stmt;\n+      // else\n+      //   two_stmt_sequence;\n+      //\n+      // to this code pattern:\n+      //\n+      // if (!cond)\n+      //  two_stmt_sequence;\n+      // else\n+      //   single_stmt;\n+      Node stmt1 = elseBranch.getFirstChild();\n+      Node stmt2 = elseBranch.getLastChild();\n+      Node newElse = IR.block(IR.empty()).srcref(elseBranch);\n+      elseBranch.removeChild(stmt2);\n+      elseBranch.replaceWith(newElse);\n+      Node notCond = IR.not(cond.detach());\n+      Node ifNode = IR.ifNode(notCond, elseBranch, null)\n+                         .maker(n.getAstNode()).srcref(n);\n+      n.replaceChildren(cond, stmt1);\n+      newElse.addChildrenToFront(stmt2);\n+      n.addChildToBack(ifNode);\n+      reportCodeChange();\n+      return ifNode;\n     }\n \n     // if(x)return 1;else return 2; -> return x?1:2;\n@@ -775,97 +859,7 @@ class PeepholeSubstituteAlternateSyntax\n         if (NodeUtil.isAssignmentOp(thenOp)) {\n           Node lhs = thenOp.getFirstChild();\n           if (areNodesEqualForInlining(lhs, elseOp.getFirstChild()) &&\n-              // if LHS has side effects, don't proceed [since the optimization\n-              // evaluates LHS before cond]\n-              // NOTE - there are some circumstances where we can\n-              // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n-\n-            n.removeChild(cond);\n-            Node assignName = thenOp.removeFirstChild();\n-            Node thenExpr = thenOp.removeFirstChild();\n-            Node elseExpr = elseOp.getLastChild();\n-            elseOp.removeChild(elseExpr);\n-\n-            Node hookNode = IR.hook(cond, thenExpr, elseExpr).srcref(n);\n-            Node assign = new Node(thenOp.getType(), assignName, hookNode)\n-                              .srcref(thenOp);\n-            Node expr = NodeUtil.newExpr(assign);\n-            parent.replaceChild(n, expr);\n-            reportCodeChange();\n-\n-            return expr;\n-          }\n-        }\n-      }\n-      // if(x)foo();else bar(); -> x?foo():bar()\n-      n.removeChild(cond);\n-      thenOp.detachFromParent();\n-      elseOp.detachFromParent();\n-      Node expr = IR.exprResult(\n-          IR.hook(cond, thenOp, elseOp).srcref(n));\n-      parent.replaceChild(n, expr);\n-      reportCodeChange();\n-      return expr;\n-    }\n-\n-    boolean thenBranchIsVar = isVarBlock(thenBranch);\n-    boolean elseBranchIsVar = isVarBlock(elseBranch);\n-\n-    // if(x)var y=1;else y=2  ->  var y=x?1:2\n-    if (thenBranchIsVar && elseBranchIsExpressionBlock &&\n-        getBlockExpression(elseBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(thenBranch);\n-      Node elseAssign = getBlockExpression(elseBranch).getFirstChild();\n-\n-      Node name1 = var.getFirstChild();\n-      Node maybeName2 = elseAssign.getFirstChild();\n-\n-      if (name1.hasChildren()\n-          && maybeName2.isName()\n-          && name1.getString().equals(maybeName2.getString())) {\n-        Node thenExpr = name1.removeChildren();\n-        Node elseExpr = elseAssign.getLastChild().detachFromParent();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name1.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n-        return var;\n-      }\n-\n-    // if(x)y=1;else var y=2  ->  var y=x?1:2\n-    } else if (elseBranchIsVar && thenBranchIsExpressionBlock &&\n-        getBlockExpression(thenBranch).getFirstChild().isAssign()) {\n-\n-      Node var = getBlockVar(elseBranch);\n-      Node thenAssign = getBlockExpression(thenBranch).getFirstChild();\n-\n-      Node maybeName1 = thenAssign.getFirstChild();\n-      Node name2 = var.getFirstChild();\n-\n-      if (name2.hasChildren()\n-          && maybeName1.isName()\n-          && maybeName1.getString().equals(name2.getString())) {\n-        Node thenExpr = thenAssign.getLastChild().detachFromParent();\n-        Node elseExpr = name2.removeChildren();\n-        cond.detachFromParent();\n-        Node hookNode = IR.hook(cond, thenExpr, elseExpr)\n-                            .srcref(n);\n-        var.detachFromParent();\n-        name2.addChildrenToBack(hookNode);\n-        parent.replaceChild(n, var);\n-        reportCodeChange();\n-\n-        return var;\n-      }\n-    }\n-\n-    return n;\n-  }\n+              // if LHS has side effects, don'\n \n   /**\n    * Try to remove duplicate statements from IF blocks. For example:",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}