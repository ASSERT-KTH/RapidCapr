{
    "patch": "import org.mockito.cglib.proxy.Factory;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\nimport org.mockito.internal.configuration.MockSettingsImpl;\nimport org.mockito.internal.handler.MockHandlerImpl;\nimport org.mockito.internal.progress.MockingProgress;\nimport org.mockito.internal.progress.ThreadSafeMockingProgress;\n\nimport java.lang.reflect.Method;\nimport java.util.List;\nimport java.util.concurrent.ConcurrentHashMap;\nimport java.util.concurrent.ConcurrentMap;\n\npublic class MockHandler<T> extends MockHandlerImpl<T> {\n\n    private final ConcurrentMap<Method, List<MethodInvocationReport>> methodInvocations = new ConcurrentHashMap<>();\n    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n    private InvocationListener invocationListener;\n\n    public MockHandler(T t) {\n        super(t);\n    }\n\n    public void setInvocationListener(InvocationListener invocationListener) {\n        this.invocationListener = invocationListener;\n    }\n\n    @Override\n    public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\n        Object result;\n        mockingProgress.validateState();\n        MethodInvocationReport invocationReport = new MethodInvocationReport(method, args, this.getClass());\n        try {\n            result = super.invoke(obj, method, args);\n        } catch (Throwable t) {\n            invocationReport.setException(t);\n            if (invocationListener != null) {\n                invocationListener.reportInvocation(invocationReport);\n            }\n            throw t;\n        }\n        invocationReport.setResult(result);\n        if (invocationListener != null) {\n            invocationListener.reportInvocation(invocationReport);\n        }\n        return result;\n    }\n\n    @Override\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        Object result;\n        mockingProgress.validateState();\n        MethodInvocationReport invocationReport = new MethodInvocationReport(method, args, this.getClass());\n        try {\n            result = super.intercept(obj, method, args, proxy);\n        } catch (Throwable t) {\n            invocationReport.setException(t);\n            if (invocationListener != null) {\n                invocationListener.reportInvocation(invocationReport);\n            }\n            throw t;\n        }\n        invocationReport.setResult(result);\n        if (invocationListener != null) {\n            invocationListener.reportInvocation(invocationReport);\n        }\n        return result;\n    }\n\n    public static <T> MockHandler<T> getMockHandler(T mock) {\n        return (MockHandler<T>) org.mockito.internal.util.MockUtil.getMockHandler(mock);\n    }\n\n    public static <T> void setMockHandler(T mock, MockHandler<T> mockHandler) {\n        org.mockito.internal.util.MockUtil.getMockSettings(mock).getMockHandler().set(mock, mockHandler);\n    }\n\n    public static <T> void resetMock(T mock) {\n        MockHandler<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler.getMockSettings().getDefaultAnswer().answer(null), mock, oldMockHandler.getMockSettings(), oldMockHandler.getRegisteredInvocations(), oldMockHandler.getInterceptorChain());\n        newMockHandler.setInvocationListener(oldMockHandler.invocationListener);\n        if (mock instanceof Factory) {\n            ((Factory) mock).setCallback(0, newMockHandler);\n        } else {\n            mock = (T) getMockHandler(mock).createMock(newMockHandler);\n        }\n        setMockHandler(mock, newMockHandler);\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..ede8310af 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,96 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.configuration.MockSettingsImpl;\n+import org.mockito.internal.handler.MockHandlerImpl;\n+import org.mockito.internal.progress.MockingProgress;\n+import org.mockito.internal.progress.ThreadSafeMockingProgress;\n+\n+import java.lang.reflect.Method;\n+import java.util.List;\n+import java.util.concurrent.ConcurrentHashMap;\n+import java.util.concurrent.ConcurrentMap;\n+\n+public class MockHandler<T> extends MockHandlerImpl<T> {\n+\n+    private final ConcurrentMap<Method, List<MethodInvocationReport>> methodInvocations = new ConcurrentHashMap<>();\n+    private final MockingProgress mockingProgress = new ThreadSafeMockingProgress();\n+    private InvocationListener invocationListener;\n+\n+    public MockHandler(T t) {\n+        super(t);\n+    }\n+\n+    public void setInvocationListener(InvocationListener invocationListener) {\n+        this.invocationListener = invocationListener;\n+    }\n+\n+    @Override\n+    public Object invoke(Object obj, Method method, Object[] args) throws Throwable {\n+        Object result;\n+        mockingProgress.validateState();\n+        MethodInvocationReport invocationReport = new MethodInvocationReport(method, args, this.getClass());\n+        try {\n+            result = super.invoke(obj, method, args);\n+        } catch (Throwable t) {\n+            invocationReport.setException(t);\n+            if (invocationListener != null) {\n+                invocationListener.reportInvocation(invocationReport);\n+            }\n+            throw t;\n+        }\n+        invocationReport.setResult(result);\n+        if (invocationListener != null) {\n+            invocationListener.reportInvocation(invocationReport);\n+        }\n+        return result;\n+    }\n+\n+    @Override\n+    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+        Object result;\n+        mockingProgress.validateState();\n+        MethodInvocationReport invocationReport = new MethodInvocationReport(method, args, this.getClass());\n+        try {\n+            result = super.intercept(obj, method, args, proxy);\n+        } catch (Throwable t) {\n+            invocationReport.setException(t);\n+            if (invocationListener != null) {\n+                invocationListener.reportInvocation(invocationReport);\n+            }\n+            throw t;\n+        }\n+        invocationReport.setResult(result);\n+        if (invocationListener != null) {\n+            invocationListener.reportInvocation(invocationReport);\n+        }\n+        return result;\n+    }\n+\n+    public static <T> MockHandler<T> getMockHandler(T mock) {\n+        return (MockHandler<T>) org.mockito.internal.util.MockUtil.getMockHandler(mock);\n+    }\n+\n+    public static <T> void setMockHandler(T mock, MockHandler<T> mockHandler) {\n+        org.mockito.internal.util.MockUtil.getMockSettings(mock).getMockHandler().set(mock, mockHandler);\n+    }\n+\n+    public static <T> void resetMock(T mock) {\n+        MockHandler<T> oldMockHandler = getMockHandler(mock);\n+        MockHandler<T> newMockHandler = new MockHandler<>(oldMockHandler.getMockSettings().getDefaultAnswer().answer(null), mock, oldMockHandler.getMockSettings(), oldMockHandler.getRegisteredInvocations(), oldMockHandler.getInterceptorChain());\n+        newMockHandler.setInvocationListener(oldMockHandler.invocationListener);\n+        if (mock instanceof Factory) {\n+            ((Factory) mock).setCallback(0, newMockHandler);\n+        } else {\n+            mock = (T) getMockHandler(mock).createMock(newMockHandler);\n+        }\n+        setMockHandler(mock, newMockHandler);\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}