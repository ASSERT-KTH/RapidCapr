{
    "patch": "import com.google.javascript.jscomp.AbstractCompiler;\nimport com.google.javascript.jscomp.ChainableReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.CompilerOptions;\nimport com.google.javascript.jscomp.NodeTraversal;\nimport com.google.javascript.jscomp.ReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;\nimport com.google.javascript.jscomp.TypedScope;\nimport com.google.javascript.jscomp.colors.StandardColors;\nimport com.google.javascript.jscomp.parsing.parser.util.format.SimpleFormatContext;\nimport com.google.javascript.rhino.Node;\n\nimport java.util.logging.Logger;\n\npublic class MyCompiler extends AbstractCompiler {\n\n  private ReverseAbstractInterpreter abstractInterpreter = null;\n  private TypeValidator typeValidator = null;\n\n  public MyCompiler(CompilerOptions options) {\n    super();\n    initOptions(options);\n  }\n\n  @Override\n  public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n    if (abstractInterpreter == null) {\n      ChainableReverseAbstractInterpreter interpreter =\n              new SemanticReverseAbstractInterpreter(\n                      getCodingConvention(), getTypeRegistry(), StandardColors.instance());\n      if (options.closurePass) {\n        interpreter = new ClosureReverseAbstractInterpreter(\n                getCodingConvention(), getTypeRegistry())\n                .append(interpreter).getFirst();\n      }\n      abstractInterpreter = interpreter;\n    }\n    return abstractInterpreter;\n  }\n\n  @Override\n  TypeValidator getTypeValidator() {\n    if (typeValidator == null) {\n      typeValidator = new TypeValidator(this);\n    }\n    return typeValidator;\n  }\n\n  @Override\n  TypedScope getTopScope() {\n    TypedScope topScope = super.getTopScope();\n    // Include \"unknown\" as a declared type so that it can be used as an\n    // implicit return type for functions without explicit return types.\n    topScope.declareType(\"unknown\", null, null,\n        SimpleFormatContext.getDefaultInstance());\n    return topScope;\n  }\n\n  /** This function runs after each pass. */\n  @Override\n  protected void afterPass(PassFactory factory, NodeTraversal t) {\n    if (tracker != null) {\n      tracker.recordPassEnd(factory.getName());\n    }\n    for (ChangeListener changeListener : changeListeners) {\n      changeListener.handleChange();\n    }\n    if (options.getParseJsDocDocumentation()) {\n      docInfoHandler.finish();\n    }\n    for (TypeCheckingPass.PassCompleted pass : typeCheckingHasRun) {\n      pass.passCompleted(factory);\n    }\n\n    // For the first run, we assume there's no reference to \"$jscomp\".\n    // For the second run, however, that would cause rewrites not to happen.\n    // Hence, we eagerly rewrite reference to \"$jscomp\" during the second run.\n    if (options.isIdeMode() && factory.isSecondRun()) {\n      NodeTraversal.traverse(this, t.getScopeRoot(), new EagerRewriter());\n    }\n  }\n\n  /**\n   * @return Whether JSCompiler is in the middle of a parse of a file\n   *     containing a string literal of the form \"use strict\" or 'use strict'.\n   */\n  public boolean isParsingStrictMode() {\n    return currentFile != null ? currentFile.isOnLoadStrict() : false;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex b76bbb5c..d9ddb66d 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -1199,16 +1199,40 @@ public class Compiler extends AbstractCompiler {\n     return getPassConfig().getTopScope();\n   }\n \n+  @Override\n+import com.google.javascript.jscomp.AbstractCompiler;\n+import com.google.javascript.jscomp.ChainableReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.CompilerOptions;\n+import com.google.javascript.jscomp.NodeTraversal;\n+import com.google.javascript.jscomp.ReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.SemanticReverseAbstractInterpreter;\n+import com.google.javascript.jscomp.TypedScope;\n+import com.google.javascript.jscomp.colors.StandardColors;\n+import com.google.javascript.jscomp.parsing.parser.util.format.SimpleFormatContext;\n+import com.google.javascript.rhino.Node;\n+\n+import java.util.logging.Logger;\n+\n+public class MyCompiler extends AbstractCompiler {\n+\n+  private ReverseAbstractInterpreter abstractInterpreter = null;\n+  private TypeValidator typeValidator = null;\n+\n+  public MyCompiler(CompilerOptions options) {\n+    super();\n+    initOptions(options);\n+  }\n+\n   @Override\n   public ReverseAbstractInterpreter getReverseAbstractInterpreter() {\n     if (abstractInterpreter == null) {\n       ChainableReverseAbstractInterpreter interpreter =\n-          new SemanticReverseAbstractInterpreter(\n-              getCodingConvention(), getTypeRegistry());\n+              new SemanticReverseAbstractInterpreter(\n+                      getCodingConvention(), getTypeRegistry(), StandardColors.instance());\n       if (options.closurePass) {\n         interpreter = new ClosureReverseAbstractInterpreter(\n-            getCodingConvention(), getTypeRegistry())\n-            .append(interpreter).getFirst();\n+                getCodingConvention(), getTypeRegistry())\n+                .append(interpreter).getFirst();\n       }\n       abstractInterpreter = interpreter;\n     }\n@@ -1223,169 +1247,49 @@ public class Compiler extends AbstractCompiler {\n     return typeValidator;\n   }\n \n-  //------------------------------------------------------------------------\n-  // Parsing\n-  //------------------------------------------------------------------------\n-\n-  /**\n-   * Parses the externs and main inputs.\n-   *\n-   * @return A synthetic root node whose two children are the externs root\n-   *     and the main root\n-   */\n-  Node parseInputs() {\n-    boolean devMode = options.devMode != DevMode.OFF;\n+  @Override\n+  TypedScope getTopScope() {\n+    TypedScope topScope = super.getTopScope();\n+    // Include \"unknown\" as a declared type so that it can be used as an\n+    // implicit return type for functions without explicit return types.\n+    topScope.declareType(\"unknown\", null, null,\n+        SimpleFormatContext.getDefaultInstance());\n+    return topScope;\n+  }\n \n-    // If old roots exist (we are parsing a second time), detach each of the\n-    // individual file parse trees.\n-    if (externsRoot != null) {\n-      externsRoot.detachChildren();\n+  /** This function runs after each pass. */\n+  @Override\n+  protected void afterPass(PassFactory factory, NodeTraversal t) {\n+    if (tracker != null) {\n+      tracker.recordPassEnd(factory.getName());\n     }\n-    if (jsRoot != null) {\n-      jsRoot.detachChildren();\n+    for (ChangeListener changeListener : changeListeners) {\n+      changeListener.handleChange();\n     }\n-\n-    // Parse main js sources.\n-    jsRoot = IR.block();\n-    jsRoot.setIsSyntheticBlock(true);\n-\n-    externsRoot = IR.block();\n-    externsRoot.setIsSyntheticBlock(true);\n-\n-    externAndJsRoot = IR.block(externsRoot, jsRoot);\n-    externAndJsRoot.setIsSyntheticBlock(true);\n-\n-    if (options.tracer.isOn()) {\n-      tracker = new PerformanceTracker(jsRoot, options.tracer);\n-      addChangeHandler(tracker.getCodeChangeHandler());\n+    if (options.getParseJsDocDocumentation()) {\n+      docInfoHandler.finish();\n+    }\n+    for (TypeCheckingPass.PassCompleted pass : typeCheckingHasRun) {\n+      pass.passCompleted(factory);\n     }\n \n-    Tracer tracer = newTracer(\"parseInputs\");\n-\n-    try {\n-      // Parse externs sources.\n-      for (CompilerInput input : externs) {\n-        Node n = input.getAstRoot(this);\n-        if (hasErrors()) {\n-          return null;\n-        }\n-        externsRoot.addChildToBack(n);\n-      }\n-\n-      // Modules inferred in ProcessCommonJS pass.\n-      if (options.transformAMDToCJSModules || options.processCommonJSModules) {\n-        processAMDAndCommonJSModules();\n-      }\n-\n-      // Check if inputs need to be rebuilt from modules.\n-      boolean staleInputs = false;\n-\n-      // Check if the sources need to be re-ordered.\n-      if (options.dependencyOptions.needsManagement() &&\n-          !options.skipAllPasses &&\n-          options.closurePass) {\n-        for (CompilerInput input : inputs) {\n-          // Forward-declare all the provided types, so that they\n-          // are not flagged even if they are dropped from the process.\n-          for (String provide : input.getProvides()) {\n-            getTypeRegistry().forwardDeclareType(provide);\n-          }\n-        }\n-\n-        try {\n-          inputs =\n-              (moduleGraph == null ? new JSModuleGraph(modules) : moduleGraph)\n-              .manageDependencies(options.dependencyOptions, inputs);\n-          staleInputs = true;\n-        } catch (CircularDependencyException e) {\n-          report(JSError.make(\n-              JSModule.CIRCULAR_DEPENDENCY_ERROR, e.getMessage()));\n-\n-          // If in IDE mode, we ignore the error and keep going.\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        } catch (MissingProvideException e) {\n-          report(JSError.make(\n-              MISSING_ENTRY_ERROR, e.getMessage()));\n-\n-          // If in IDE mode, we ignore the error and keep going.\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        }\n-      }\n-\n-      for (CompilerInput input : inputs) {\n-        Node n = input.getAstRoot(this);\n-\n-        // Inputs can have a null AST during initial parse.\n-        if (n == null) {\n-          continue;\n-        }\n-\n-        if (n.getJSDocInfo() != null) {\n-          JSDocInfo info = n.getJSDocInfo();\n-          if (info.isExterns()) {\n-            // If the input file is explicitly marked as an externs file, then\n-            // assume the programmer made a mistake and throw it into\n-            // the externs pile anyways.\n-            externsRoot.addChildToBack(n);\n-            input.setIsExtern(true);\n-\n-            input.getModule().remove(input);\n-\n-            externs.add(input);\n-            staleInputs = true;\n-          } else if (info.isNoCompile()) {\n-            input.getModule().remove(input);\n-            staleInputs = true;\n-          }\n-        }\n-      }\n-\n-      if (staleInputs) {\n-        fillEmptyModules(modules);\n-        rebuildInputsFromModules();\n-      }\n-\n-      // Build the AST.\n-      for (CompilerInput input : inputs) {\n-        Node n = input.getAstRoot(this);\n-        if (n == null) {\n-          continue;\n-        }\n-\n-        if (devMode) {\n-          runSanityCheck();\n-          if (hasErrors()) {\n-            return null;\n-          }\n-        }\n-\n-        if (options.sourceMapOutputPath != null ||\n-            options.nameReferenceReportPath != null) {\n-\n-          // Annotate the nodes in the tree with information from the\n-          // input file. This information is used to construct the SourceMap.\n-          SourceInformationAnnotator sia =\n-              new SourceInformationAnnotator(\n-                  input.getName(), options.devMode != DevMode.OFF);\n-          NodeTraversal.traverse(this, n, sia);\n-        }\n-\n-        jsRoot.addChildToBack(n);\n-      }\n-\n-      if (hasErrors()) {\n-        return null;\n-      }\n-      return externAndJsRoot;\n-    } finally {\n-      stopTracer(tracer, \"parseInputs\");\n+    // For the first run, we assume there's no reference to \"$jscomp\".\n+    // For the second run, however, that would cause rewrites not to happen.\n+    // Hence, we eagerly rewrite reference to \"$jscomp\" during the second run.\n+    if (options.isIdeMode() && factory.isSecondRun()) {\n+      NodeTraversal.traverse(this, t.getScopeRoot(), new EagerRewriter());\n     }\n   }\n \n+  /**\n+   * @return Whether JSCompiler is in the middle of a parse of a file\n+   *     containing a string literal of the form \"use strict\" or 'use strict'.\n+   */\n+  public boolean isParsingStrictMode() {\n+    return currentFile != null ? currentFile.isOnLoadStrict() : false;\n+  }\n+}\n+\n   /**\n    * Transforms AMD and CJS modules to something closure compiler can\n    * process and creates JSModules and the corresponding dependency tree",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}