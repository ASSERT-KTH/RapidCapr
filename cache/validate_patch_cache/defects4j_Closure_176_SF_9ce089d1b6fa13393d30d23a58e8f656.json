{
    "patch": "  /**\n   * Declares a variable type and jumps to the end of the VAR declaration\n   * list for interprocedural analysis.\n   * @param scope The current scope.\n   * @param left The LEFT node of the assignment expression.\n   * @param resultType The type of the right-hand side of the assignment.\n   */\n  private void redeclareSimpleVar(\n      FlowScope scope,\n      Node left,\n      JSType resultType) {\n    Preconditions.checkState(left.getType() == Token.NAME);\n    String varName = left.getString();\n    Var var = syntacticScope.getVar(varName);\n    JSType oldType = getJSType(left);\n    // We might not yet know the previous type of the variable. For example,\n    // it may have been defined inside an 'if' block that we previously\n    // skipped.\n    if (oldType == null) {\n      oldType = JSType.UNKNOWN;\n    }\n    // Switching from inferred to declared. Clear out any back-propagated types.\n    if (var != null && !var.isTypeInferred()) {\n      var.clearType();\n    }\n\n    if (syntacticScope.isKnownFunction()) {\n      definitionScope.addDeclaredLocalVar(varName);\n    }\n\n    if (var != null) {\n      var.addReference(left);\n    } else {\n      codingConvention.checkVariableReference(left);\n    }\n\n    // Autobox primitives\n    if (!resultType.isUnknownType()) {\n      if (var != null && var.isGlobal()) { // Don't autobox globals\n        if (oldType.isUnknownType()) {\n          var.setType(resultType);\n          return;\n        }\n      } else if (resultType.isNumberValueType() && oldType.isUnknownType()) {\n        boolean isConstant = NodeUtil.isConstantName(left, scope);\n        JSType boxedResultType = commonTypes.getNumberInstance(\n            isConstant ? null : JSType.Nullability.NULLABLE);\n        resultType = boxedResultType;\n      } else if (resultType.isBooleanValueType() && oldType.isUnknownType()) {\n        resultType = commonTypes.getBooleanInstance();\n      }\n    }\n    boolean isConstant = NodeUtil.isConstantName(left, scope);\n    if (isConstant) {\n      resultType = resultType.withoutTypeProtector();\n    }\n    // Backward infer a more specific type for this variable.\n    JSType newType = oldType.getGreatestSubtype(resultType);\n    if (newType.isBottom()) {\n      warnInvalidAnnotation(\"@const\", NULLABLE_DEREFERENCE, left);\n    }\n    if (!newType.equals(oldType) || isConstant) {\n      if (var != null) {\n        var.setType(newType);\n        var.setMarkAssigned();\n      }\n      Node lValueRoot = NodeUtil.getLValueRoot(left);\n      Node rValueRoot = NodeUtil.getRValueOfLValue(left);\n\n      if (isConstant && !newType.isUnknownType() &&\n          (canExposeConstantAnnotations || !Result.isCheckableErrorCode(warningLevel, FAILED_TO_UNWRAP))) {\n        // Only warn if warning level is strict or higher.\n        // Also, probationary types are stripped in the constructor.\n        String message = null;\n        if (rValueRoot != null && rValueRoot.isObjectLit()) {\n          message = OBJECT_LITERAL_WITH_TYPE;\n        } else if (rValueRoot != null && rValueRoot.isArrayLit()) {\n          message = ARRAY_LITERAL_WITH_TYPE;\n        }\n        if (message != null) {\n          mode.isTypeCheckSuppressedSuppressionExemption();\n          warnings.add(JSError.make(\n              left,\n              FAILED_TO_UNWRAP,\n              message,\n              varName));\n        }\n      }\n    }\n  }\n\n  /**\n   * Defines a property if the property has not been defined yet.\n   */\n  private void ensurePropertyDefined(Node getprop, JSType rightType) {\n    String propName = getprop.getLastChild().getString();\n    Node obj = getprop.getFirstChild();\n    JSType nodeType = getJSType(obj);\n    ObjectType objectType = ObjectType.cast(nodeType.restrictByNotNullOrUndefined());\n    boolean propCreationInConstructor =\n        obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor();\n\n    if (objectType == null) {\n      registry.registerPropertyOnType(propName, nodeType);\n    } else if (nodeType.isStruct()) {\n      if (propCreationInConstructor) {\n        objectType.defineInferredProperty(propName, rightType, getprop);\n      } else if (NodeUtil.isPrototypePropertyDeclaration(getprop.getParent().getParent())) {\n        Node declarationNode = getprop.getParent().getParent();\n        Node enclosingFn = NodeUtil.getEnclosingFunction(declarationNode);\n        if (enclosingFn == null || !NodeUtil.referencesThis(enclosingFn.getLastChild())) {\n          return;\n        }\n        if (objectType.getSlot(propName) != null) {\n          objectType.defineInferredProperty(propName, rightType, getprop);\n        }\n      }\n      JSError error = objectType.isValidStructPropertyName(propName);\n      if (error != null) {\n        warnings.add(error);\n      }\n    } else {\n      // We make a distinction between objects and non-objects and\n      // whether or not propName is declared on the object. The comments\n      // in the code block below reflect this.\n      JSType declaredType = objectType.getPropertyType(propName);\n      ObjectType.PropertyAccessKind accessType =\n          objectType.isPropertyTypeDeclared(propName)\n              ? ObjectType.PropertyAccessKind.DECLARED\n              : ObjectType.PropertyAccessKind.UNDECLARED;\n      if (declaredType == null) {\n        accessType = ObjectType.PropertyAccessKind.UNDECLARED;\n        declaredType = rightType;\n      } else if (declaredType.isUnknownType()) {\n        // This can happen in cases where the getter is known, but not the\n        // setter.  The real type is more specific than unknown, so in\n        // that sense, it's safe to ignore the unknown type.\n        declaredType = rightType;\n      } else if (rightType.isUnknownType()) {\n        // Don't overwrite what we know about this property.\n        // Note that if the declared type is nullable, e.g. \"string|null\",\n        // we may not want to overwrite it with just \"string\".\n        // That's why we're being careful with the call to union().\n        JSType oldNewTypeUnion = declaredType.getGreatestSubtype(rightType);\n        if (oldNewTypeUnion.isBottom()) {\n          JSError warning =\n              accessType == ObjectType.PropertyAccessKind.DECLARED\n                  ? EXPLICITLY_DEFINED_GENERIC_TYPE\n                  : OBJECT_LITERAL_WITH_UNKNOWN_TYPE;\n          warnInvalidAnnotation(\"@type\", NULLABLE_DEREFERENCE, getprop, warning);\n          declaredType = rightType;\n        } else {\n          declaredType = oldNewTypeUnion;\n        }\n      } else if (!declaredType.isSubtype(rightType)) {\n        JSError warning =\n            accessType == ObjectType.PropertyAccessKind.DECLARED\n                ? EXPLICITLY_DEFINED_GENERIC_TYPE\n                : NEW_INSTALLED_GETTER_SETTER_TYPE;\n        warnInvalidAnnotation(\"@type\", NULLABLE_DEREFERENCE, getprop, warning);\n        declaredType = declaredType.getLeastSupertype(rightType);\n      }\n      if (NodeUtil.isAssignmentOp(getprop.getParent())) {\n        objectType.defineInferredProperty(propName, declaredType, getprop);\n      } else if (accessType == ObjectType.PropertyAccessKind.UNDECLARED) {\n        objectType.defineDeclaredProperty(\n            propName,\n            declaredType.withoutTypeProtector(), // Strip type protector type.\n            getprop);\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex c43a7d1a..9329ec9d 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -521,66 +521,94 @@ class TypeInference\n    * an assignment or a type cast.\n    */\n   private void updateScopeForTypeChange(\n-      FlowScope scope, Node left, JSType leftType, JSType resultType) {\n-    Preconditions.checkNotNull(resultType);\n-    switch (left.getType()) {\n-      case Token.NAME:\n-        String varName = left.getString();\n-        Var var = syntacticScope.getVar(varName);\n-        boolean isVarDeclaration = left.hasChildren();\n+  /**\n+   * Declares a variable type and jumps to the end of the VAR declaration\n+   * list for interprocedural analysis.\n+   * @param scope The current scope.\n+   * @param left The LEFT node of the assignment expression.\n+   * @param resultType The type of the right-hand side of the assignment.\n+   */\n+  private void redeclareSimpleVar(\n+      FlowScope scope,\n+      Node left,\n+      JSType resultType) {\n+    Preconditions.checkState(left.getType() == Token.NAME);\n+    String varName = left.getString();\n+    Var var = syntacticScope.getVar(varName);\n+    JSType oldType = getJSType(left);\n+    // We might not yet know the previous type of the variable. For example,\n+    // it may have been defined inside an 'if' block that we previously\n+    // skipped.\n+    if (oldType == null) {\n+      oldType = JSType.UNKNOWN;\n+    }\n+    // Switching from inferred to declared. Clear out any back-propagated types.\n+    if (var != null && !var.isTypeInferred()) {\n+      var.clearType();\n+    }\n \n-        // When looking at VAR initializers for declared VARs, we tend\n-        // to use the declared type over the type it's being\n-        // initialized to in the global scope.\n-        //\n-        // For example,\n-        // /** @param {number} */ var f = goog.abstractMethod;\n-        // it's obvious that the programmer wants you to use\n-        // the declared function signature, not the inferred signature.\n-        //\n-        // Or,\n-        // /** @type {Object.<string>} */ var x = {};\n-        // the one-time anonymous object on the right side\n-        // is as narrow as it can possibly be, but we need to make\n-        // sure we back-infer the <string> element constraint on\n-        // the left hand side, so we use the left hand side.\n-\n-        boolean isVarTypeBetter = !isVarDeclaration || var == null || var.isTypeInferred();\n-            // Makes it easier to check for NPEs.\n-\n-        // TODO(nicksantos): This might be a better check once we have\n-        // back-inference of object/array constraints.  It will probably\n-        // introduce more type warnings.  It uses the result type iff it's\n-        // strictly narrower than the declared var type.\n-        //\n-        //boolean isVarTypeBetter = isVarDeclaration &&\n-        //    (varType.restrictByNotNullOrUndefined().isSubtype(resultType)\n-        //     || !resultType.isSubtype(varType));\n+    if (syntacticScope.isKnownFunction()) {\n+      definitionScope.addDeclaredLocalVar(varName);\n+    }\n \n+    if (var != null) {\n+      var.addReference(left);\n+    } else {\n+      codingConvention.checkVariableReference(left);\n+    }\n \n-        if (isVarTypeBetter) {\n-          redeclareSimpleVar(scope, left, resultType);\n+    // Autobox primitives\n+    if (!resultType.isUnknownType()) {\n+      if (var != null && var.isGlobal()) { // Don't autobox globals\n+        if (oldType.isUnknownType()) {\n+          var.setType(resultType);\n+          return;\n         }\n-        left.setJSType(isVarDeclaration || leftType == null ?\n-            resultType : null);\n-\n-        if (var != null && var.isTypeInferred()) {\n-          JSType oldType = var.getType();\n-          var.setType(oldType == null ?\n-              resultType : oldType.getLeastSupertype(resultType));\n+      } else if (resultType.isNumberValueType() && oldType.isUnknownType()) {\n+        boolean isConstant = NodeUtil.isConstantName(left, scope);\n+        JSType boxedResultType = commonTypes.getNumberInstance(\n+            isConstant ? null : JSType.Nullability.NULLABLE);\n+        resultType = boxedResultType;\n+      } else if (resultType.isBooleanValueType() && oldType.isUnknownType()) {\n+        resultType = commonTypes.getBooleanInstance();\n+      }\n+    }\n+    boolean isConstant = NodeUtil.isConstantName(left, scope);\n+    if (isConstant) {\n+      resultType = resultType.withoutTypeProtector();\n+    }\n+    // Backward infer a more specific type for this variable.\n+    JSType newType = oldType.getGreatestSubtype(resultType);\n+    if (newType.isBottom()) {\n+      warnInvalidAnnotation(\"@const\", NULLABLE_DEREFERENCE, left);\n+    }\n+    if (!newType.equals(oldType) || isConstant) {\n+      if (var != null) {\n+        var.setType(newType);\n+        var.setMarkAssigned();\n+      }\n+      Node lValueRoot = NodeUtil.getLValueRoot(left);\n+      Node rValueRoot = NodeUtil.getRValueOfLValue(left);\n+\n+      if (isConstant && !newType.isUnknownType() &&\n+          (canExposeConstantAnnotations || !Result.isCheckableErrorCode(warningLevel, FAILED_TO_UNWRAP))) {\n+        // Only warn if warning level is strict or higher.\n+        // Also, probationary types are stripped in the constructor.\n+        String message = null;\n+        if (rValueRoot != null && rValueRoot.isObjectLit()) {\n+          message = OBJECT_LITERAL_WITH_TYPE;\n+        } else if (rValueRoot != null && rValueRoot.isArrayLit()) {\n+          message = ARRAY_LITERAL_WITH_TYPE;\n         }\n-        break;\n-      case Token.GETPROP:\n-        String qualifiedName = left.getQualifiedName();\n-        if (qualifiedName != null) {\n-          scope.inferQualifiedSlot(left, qualifiedName,\n-              leftType == null ? unknownType : leftType,\n-              resultType);\n+        if (message != null) {\n+          mode.isTypeCheckSuppressedSuppressionExemption();\n+          warnings.add(JSError.make(\n+              left,\n+              FAILED_TO_UNWRAP,\n+              message,\n+              varName));\n         }\n-\n-        left.setJSType(resultType);\n-        ensurePropertyDefined(left, resultType);\n-        break;\n+      }\n     }\n   }\n \n@@ -591,39 +619,80 @@ class TypeInference\n     String propName = getprop.getLastChild().getString();\n     Node obj = getprop.getFirstChild();\n     JSType nodeType = getJSType(obj);\n-    ObjectType objectType = ObjectType.cast(\n-        nodeType.restrictByNotNullOrUndefined());\n-    boolean propCreationInConstructor = obj.isThis() &&\n-        getJSType(syntacticScope.getRootNode()).isConstructor();\n+    ObjectType objectType = ObjectType.cast(nodeType.restrictByNotNullOrUndefined());\n+    boolean propCreationInConstructor =\n+        obj.isThis() && getJSType(syntacticScope.getRootNode()).isConstructor();\n \n     if (objectType == null) {\n       registry.registerPropertyOnType(propName, nodeType);\n-    } else {\n-      if (nodeType.isStruct() && !objectType.hasProperty(propName)) {\n-        // In general, we don't want to define a property on a struct object,\n-        // b/c TypeCheck will later check for improper property creation on\n-        // structs. There are two exceptions.\n-        // 1) If it's a property created inside the constructor, on the newly\n-        //    created instance, allow it.\n-        // 2) If it's a prototype property, allow it. For example:\n-        //    Foo.prototype.bar = baz;\n-        //    where Foo.prototype is a struct and the assignment happens at the\n-        //    top level and the constructor Foo is defined in the same file.\n-        boolean staticPropCreation = false;\n-        Node maybeAssignStm = getprop.getParent().getParent();\n-        if (syntacticScope.isGlobal() &&\n-            NodeUtil.isPrototypePropertyDeclaration(maybeAssignStm)) {\n-          String propCreationFilename = maybeAssignStm.getSourceFileName();\n-          Node ctor = objectType.getOwnerFunction().getSource();\n-          if (ctor != null &&\n-              ctor.getSourceFileName().equals(propCreationFilename)) {\n-            staticPropCreation = true;\n-          }\n+    } else if (nodeType.isStruct()) {\n+      if (propCreationInConstructor) {\n+        objectType.defineInferredProperty(propName, rightType, getprop);\n+      } else if (NodeUtil.isPrototypePropertyDeclaration(getprop.getParent().getParent())) {\n+        Node declarationNode = getprop.getParent().getParent();\n+        Node enclosingFn = NodeUtil.getEnclosingFunction(declarationNode);\n+        if (enclosingFn == null || !NodeUtil.referencesThis(enclosingFn.getLastChild())) {\n+          return;\n         }\n-        if (!propCreationInConstructor && !staticPropCreation) {\n-          return; // Early return to avoid creating the property below.\n+        if (objectType.getSlot(propName) != null) {\n+          objectType.defineInferredProperty(propName, rightType, getprop);\n         }\n       }\n+      JSError error = objectType.isValidStructPropertyName(propName);\n+      if (error != null) {\n+        warnings.add(error);\n+      }\n+    } else {\n+      // We make a distinction between objects and non-objects and\n+      // whether or not propName is declared on the object. The comments\n+      // in the code block below reflect this.\n+      JSType declaredType = objectType.getPropertyType(propName);\n+      ObjectType.PropertyAccessKind accessType =\n+          objectType.isPropertyTypeDeclared(propName)\n+              ? ObjectType.PropertyAccessKind.DECLARED\n+              : ObjectType.PropertyAccessKind.UNDECLARED;\n+      if (declaredType == null) {\n+        accessType = ObjectType.PropertyAccessKind.UNDECLARED;\n+        declaredType = rightType;\n+      } else if (declaredType.isUnknownType()) {\n+        // This can happen in cases where the getter is known, but not the\n+        // setter.  The real type is more specific than unknown, so in\n+        // that sense, it's safe to ignore the unknown type.\n+        declaredType = rightType;\n+      } else if (rightType.isUnknownType()) {\n+        // Don't overwrite what we know about this property.\n+        // Note that if the declared type is nullable, e.g. \"string|null\",\n+        // we may not want to overwrite it with just \"string\".\n+        // That's why we're being careful with the call to union().\n+        JSType oldNewTypeUnion = declaredType.getGreatestSubtype(rightType);\n+        if (oldNewTypeUnion.isBottom()) {\n+          JSError warning =\n+              accessType == ObjectType.PropertyAccessKind.DECLARED\n+                  ? EXPLICITLY_DEFINED_GENERIC_TYPE\n+                  : OBJECT_LITERAL_WITH_UNKNOWN_TYPE;\n+          warnInvalidAnnotation(\"@type\", NULLABLE_DEREFERENCE, getprop, warning);\n+          declaredType = rightType;\n+        } else {\n+          declaredType = oldNewTypeUnion;\n+        }\n+      } else if (!declaredType.isSubtype(rightType)) {\n+        JSError warning =\n+            accessType == ObjectType.PropertyAccessKind.DECLARED\n+                ? EXPLICITLY_DEFINED_GENERIC_TYPE\n+                : NEW_INSTALLED_GETTER_SETTER_TYPE;\n+        warnInvalidAnnotation(\"@type\", NULLABLE_DEREFERENCE, getprop, warning);\n+        declaredType = declaredType.getLeastSupertype(rightType);\n+      }\n+      if (NodeUtil.isAssignmentOp(getprop.getParent())) {\n+        objectType.defineInferredProperty(propName, declaredType, getprop);\n+      } else if (accessType == ObjectType.PropertyAccessKind.UNDECLARED) {\n+        objectType.defineDeclaredProperty(\n+            propName,\n+            declaredType.withoutTypeProtector(), // Strip type protector type.\n+            getprop);\n+      }\n+    }\n+  }\n \n       if (ensurePropertyDeclaredHelper(getprop, objectType)) {\n         return;",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}