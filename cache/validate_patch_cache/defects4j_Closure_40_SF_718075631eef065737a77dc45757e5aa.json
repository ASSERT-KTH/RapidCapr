{
    "patch": "    public void visit(NodeTraversal t, Node n, Node parent) {\n\n      // Record global variable and function declarations\n      if (t.inGlobalScope()) {\n        if (NodeUtil.isVarDeclaration(n)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          Preconditions.checkNotNull(ns);\n          recordSet(ns.name, n);\n        } else if (NodeUtil.isFunctionDeclaration(n)) {\n          Node nameNode = n.getFirstChild();\n          NameInformation ns = createNameInformation(t, nameNode, n);\n          if (ns != null) {\n            JsName nameInfo = getName(nameNode.getString(), true);\n            recordSet(nameInfo.name, nameNode);\n          }\n        } else if (NodeUtil.isObjectLitKey(n, parent)) {\n          NameInformation ns = createNameInformation(t, n, parent);\n          if (ns != null) {\n            recordSet(ns.name, n);\n          }\n        }\n      }\n\n      // Record assignments and call sites\n      if (n.isAssign()) {\n        Node nameNode = n.getFirstChild();\n\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null) {\n          if (ns.isPrototype) {\n            recordPrototypeSet(ns.prototypeClass, ns.prototypeProperty, n);\n          } else {\n            recordSet(ns.name, nameNode);\n          }\n        }\n      } else if (n.isCall()) {\n        Node nameNode = n.getFirstChild();\n        NameInformation ns = createNameInformation(t, nameNode, n);\n        if (ns != null && ns.onlyAffectsClassDef) {\n          JsName name = getName(ns.name, false);\n          if (name != null) {\n          refNodes.add(new ClassDefiningFunctionNode(\n              name, n, parent, parent.getParent()));\n          }\n        }\n      }\n    }\n\n    private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n      if (!NodeUtil.isName(n)) {\n        return null;\n      }\n\n      String name = n.getString();\n      if (\"prototype\".equals(name)) {\n        Node gramps = t.getAncestor(3);\n        if (gramps != null && gramps.isGetProp()) {\n          String propName = gramps.getLastChild().getString();\n          if (NodeUtil.isValidSimpleName(propName)) {\n            if (gramps.getFirstChild().isName()) {\n              String className = gramps.getFirstChild().getString();\n              if (NodeUtil.isValidQualifiedName(className)) {\n                return new NameInformation(className, propName, true, false, false, null);\n              }\n            }\n          }\n        }\n      }\n\n      Scope.Var var = t.getScope().getVar(name);\n      if (var == null) {\n        return null;\n      }\n\n      // Class name declaration\n      if (var.isClass()) {\n        String className = var.getName();\n        String property = \"\";\n        if (parent.isAssign()) {\n          Node gran = parent.getFirstChild();\n          if (gran.isGetProp() && gran.getLastChild().getString().equals(\"prototype\")) {\n            property = gran.getLastChild().getNext().getString();\n          }\n        }\n        return new NameInformation(className, property, false, true, false, null);\n      }\n\n      Node enclosingFunction = t.getEnclosingFunction();\n      if (enclosingFunction == null) {\n        return null;\n      }\n\n      // Class definition with identifier\n      Node parentNode = n.getParent();\n      if (parentNode.isClass()) {\n        if (parentNode.getFirstChild().equals(n)) {\n          NameInformation classInfo = new NameInformation(name,\n              \"\", true, false, true, parentNode);\n          classInfo.onlyAffectsClassDef = true;\n          return classInfo;\n        }\n      }\n\n      // Property reference inside a class definition\n      if (NodeUtil.isExpressionNode(parentNode)\n          && parentNode.getParent().isClass()) {\n        String className = parentNode.getParent().getFirstChild().getString();\n        String propName = n.getString();\n        if (NodeUtil.isValidSimpleName(propName)\n            && NodeUtil.isValidQualifiedName(className)) {\n          return new NameInformation(className, propName, true, false, false, null);\n        }\n      }\n\n      // Normal reference\n      return new NameInformation(name, \"\", false, false, false, null);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NameAnalyzer.java b/src/com/google/javascript/jscomp/NameAnalyzer.java\nindex 088a9933..fcb8cf2a 100644\n--- a/src/com/google/javascript/jscomp/NameAnalyzer.java\n+++ b/src/com/google/javascript/jscomp/NameAnalyzer.java\n@@ -641,6 +641,76 @@ final class NameAnalyzer implements CompilerPass {\n       }\n     }\n \n+    private NameInformation createNameInformation(NodeTraversal t, Node n, Node parent) {\n+      if (!NodeUtil.isName(n)) {\n+        return null;\n+      }\n+\n+      String name = n.getString();\n+      if (\"prototype\".equals(name)) {\n+        Node gramps = t.getAncestor(3);\n+        if (gramps != null && gramps.isGetProp()) {\n+          String propName = gramps.getLastChild().getString();\n+          if (NodeUtil.isValidSimpleName(propName)) {\n+            if (gramps.getFirstChild().isName()) {\n+              String className = gramps.getFirstChild().getString();\n+              if (NodeUtil.isValidQualifiedName(className)) {\n+                return new NameInformation(className, propName, true, false, false, null);\n+              }\n+            }\n+          }\n+        }\n+      }\n+\n+      Scope.Var var = t.getScope().getVar(name);\n+      if (var == null) {\n+        return null;\n+      }\n+\n+      // Class name declaration\n+      if (var.isClass()) {\n+        String className = var.getName();\n+        String property = \"\";\n+        if (parent.isAssign()) {\n+          Node gran = parent.getFirstChild();\n+          if (gran.isGetProp() && gran.getLastChild().getString().equals(\"prototype\")) {\n+            property = gran.getLastChild().getNext().getString();\n+          }\n+        }\n+        return new NameInformation(className, property, false, true, false, null);\n+      }\n+\n+      Node enclosingFunction = t.getEnclosingFunction();\n+      if (enclosingFunction == null) {\n+        return null;\n+      }\n+\n+      // Class definition with identifier\n+      Node parentNode = n.getParent();\n+      if (parentNode.isClass()) {\n+        if (parentNode.getFirstChild().equals(n)) {\n+          NameInformation classInfo = new NameInformation(name,\n+              \"\", true, false, true, parentNode);\n+          classInfo.onlyAffectsClassDef = true;\n+          return classInfo;\n+        }\n+      }\n+\n+      // Property reference inside a class definition\n+      if (NodeUtil.isExpressionNode(parentNode)\n+          && parentNode.getParent().isClass()) {\n+        String className = parentNode.getParent().getFirstChild().getString();\n+        String propName = n.getString();\n+        if (NodeUtil.isValidSimpleName(propName)\n+            && NodeUtil.isValidQualifiedName(className)) {\n+          return new NameInformation(className, propName, true, false, false, null);\n+        }\n+      }\n+\n+      // Normal reference\n+      return new NameInformation(name, \"\", false, false, false, null);\n+    }\n+\n     /**\n      * Records the assignment of a value to a global name.\n      *",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}