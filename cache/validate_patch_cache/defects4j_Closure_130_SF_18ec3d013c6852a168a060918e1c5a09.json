{
    "patch": " private void process(Node externs, Node root) {\n    process(externs);\n    if (!options.skipAllPasses) {\n      for (InlineCostEstimator estimator : costEstimators) {\n        estimator.prepareCosts(root);\n      }\n\n      NodeTraversal.traverse(compiler, root, new AbstractPostOrderCallback() {\n        @Override\n        public void visit(NodeTraversal t, Node n, Node parent) {\n          // We only consider inlining global names.\n          if (!t.getScope().isGlobal()) {\n            return;\n          }\n\n          Ref ref = t.getScope().getVar(t.getSymbolTable().get(n));\n          if (ref == null) {\n            return;\n          }\n\n          Name name = ref.getName();\n          if (name == null) {\n            return;\n          }\n\n          // Check if this name is a candidate for inlining.\n          if (name.inlinable != Name.Inlinability.CAN_INLINE) {\n            return;\n          }\n\n          // Check if the name has exactly one global set.\n          if (name.globalSets != 1 || name.localSets > 0) {\n            name.inlinable = Name.Inlinability.NOT_GLOBAL_OR_HAS_SETTER;\n            return;\n          }\n\n          // Only inline simple variable assignments. Object lit assignments can be very\n          // large and result in performance regression.\n          if (!name.isSimpleType()) {\n            name.inlinable = Name.Inlinability.NOT_SIMPLE_TYPE;\n            return;\n          }\n\n          // Check if the cost of inlining the reference is within the threshold.\n          InlineCost inlineCost = estimateInliningCost(name, t.getNode(), t);\n          if (inlineCost.cost > options.getMaximumCost()) {\n            name.inlinable = Name.Inlinability.EXCEEDS_SIZE_THRESHOLD;\n            return;\n          }\n\n          // Check if the name has a single function or object literal assigned\n          // to it and mark all children as inline candidates.\n          if (name.refCount() == 1 &&\n              (name.type == Name.Type.OBJECTLIT ||\n               name.type == Name.Type.FUNCTION)) {\n            for (Name propName : name.props) {\n              propName.inlinable = Name.Inlinability.CAN_INLINE;\n            }\n          }\n\n          // Mark all aliasing gets as inline candidates.\n          for (Ref refToName : name.getRefs()) {\n            if (refToName.type == Ref.Type.ALIASING_GET) {\n              Name aliasingName = refToName.getNode().getFirstChild().getQualifiedName();\n              aliasingName.inlinable = Name.Inlinability.CAN_INLINE;\n            }\n          }\n        }\n      });\n    }\n\n    inlineFunctions(root);\n    renameVars(externs, root);\n    scopeCreator.detachFromParent();\n\n    if (compiler.hasHaltingErrors()) {\n      // Don't summarize results in the presence of errors, as some errors\n      // may be caused by the inliner itself.\n      return;\n    }\n\n    int inlinedFunctionCount = 0;\n    int inlinedVariableCount = 0;\n    long inlinedBytesCount = 0;\n    int notInlinableFunctionCount = 0;\n    int notInlinableVariableCount = 0;\n    long notInlinableBytesCount = 0;\n\n    for (Scope s : getAllMemoizedScopes()) {\n      for (Var v : s.getVars()) {\n        if (!v.isInlined()) {\n          continue;\n        }\n        if (!v.isLValue()) {\n          ++inlinedFunctionCount;\n          inlinedBytesCount += getFunctionLength(v.getNode());\n        } else {\n          ++inlinedVariableCount;\n          inlinedBytesCount += getVariableLength(v.getNode());\n        }\n      }\n    }\n\n    for (Scope s : getAllMemoizedScopes()) {\n      for (Var v : s.getVars()) {\n        if (v.isInlined()) {\n          continue;\n        }\n        if (!v.isLValue()) {\n          ++notInlinableFunctionCount;\n          notInlinableBytesCount += getFunctionLength(v.getNode());\n        } else {\n          ++notInlinableVariableCount;\n          notInlinableBytesCount += getVariableLength(v.getNode());\n        }\n      }\n    }\n\n    logResults(inlinedFunctionCount, inlinedVariableCount, inlinedBytesCount,\n        notInlinableFunctionCount, notInlinableVariableCount, notInlinableBytesCount);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..eb23918d 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -158,43 +158,126 @@ class CollapseProperties implements CompilerPass {\n    *    inlineable.\n    * @see InlineVariables\n    */\n-  private void inlineAliases(GlobalNamespace namespace) {\n-    // Invariant: All the names in the worklist meet condition (a).\n-    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n-    while (!workList.isEmpty()) {\n-      Name name = workList.pop();\n-\n-      // Don't attempt to inline a getter or setter property as a variable.\n-      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n-        continue;\n+ private void process(Node externs, Node root) {\n+    process(externs);\n+    if (!options.skipAllPasses) {\n+      for (InlineCostEstimator estimator : costEstimators) {\n+        estimator.prepareCosts(root);\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+      NodeTraversal.traverse(compiler, root, new AbstractPostOrderCallback() {\n+        @Override\n+        public void visit(NodeTraversal t, Node n, Node parent) {\n+          // We only consider inlining global names.\n+          if (!t.getScope().isGlobal()) {\n+            return;\n+          }\n+\n+          Ref ref = t.getScope().getVar(t.getSymbolTable().get(n));\n+          if (ref == null) {\n+            return;\n+          }\n+\n+          Name name = ref.getName();\n+          if (name == null) {\n+            return;\n+          }\n+\n+          // Check if this name is a candidate for inlining.\n+          if (name.inlinable != Name.Inlinability.CAN_INLINE) {\n+            return;\n+          }\n+\n+          // Check if the name has exactly one global set.\n+          if (name.globalSets != 1 || name.localSets > 0) {\n+            name.inlinable = Name.Inlinability.NOT_GLOBAL_OR_HAS_SETTER;\n+            return;\n+          }\n+\n+          // Only inline simple variable assignments. Object lit assignments can be very\n+          // large and result in performance regression.\n+          if (!name.isSimpleType()) {\n+            name.inlinable = Name.Inlinability.NOT_SIMPLE_TYPE;\n+            return;\n+          }\n+\n+          // Check if the cost of inlining the reference is within the threshold.\n+          InlineCost inlineCost = estimateInliningCost(name, t.getNode(), t);\n+          if (inlineCost.cost > options.getMaximumCost()) {\n+            name.inlinable = Name.Inlinability.EXCEEDS_SIZE_THRESHOLD;\n+            return;\n+          }\n+\n+          // Check if the name has a single function or object literal assigned\n+          // to it and mark all children as inline candidates.\n+          if (name.refCount() == 1 &&\n+              (name.type == Name.Type.OBJECTLIT ||\n+               name.type == Name.Type.FUNCTION)) {\n+            for (Name propName : name.props) {\n+              propName.inlinable = Name.Inlinability.CAN_INLINE;\n+            }\n+          }\n+\n+          // Mark all aliasing gets as inline candidates.\n+          for (Ref refToName : name.getRefs()) {\n+            if (refToName.type == Ref.Type.ALIASING_GET) {\n+              Name aliasingName = refToName.getNode().getFirstChild().getQualifiedName();\n+              aliasingName.inlinable = Name.Inlinability.CAN_INLINE;\n             }\n           }\n         }\n+      });\n+    }\n+\n+    inlineFunctions(root);\n+    renameVars(externs, root);\n+    scopeCreator.detachFromParent();\n+\n+    if (compiler.hasHaltingErrors()) {\n+      // Don't summarize results in the presence of errors, as some errors\n+      // may be caused by the inliner itself.\n+      return;\n+    }\n+\n+    int inlinedFunctionCount = 0;\n+    int inlinedVariableCount = 0;\n+    long inlinedBytesCount = 0;\n+    int notInlinableFunctionCount = 0;\n+    int notInlinableVariableCount = 0;\n+    long notInlinableBytesCount = 0;\n+\n+    for (Scope s : getAllMemoizedScopes()) {\n+      for (Var v : s.getVars()) {\n+        if (!v.isInlined()) {\n+          continue;\n+        }\n+        if (!v.isLValue()) {\n+          ++inlinedFunctionCount;\n+          inlinedBytesCount += getFunctionLength(v.getNode());\n+        } else {\n+          ++inlinedVariableCount;\n+          inlinedBytesCount += getVariableLength(v.getNode());\n+        }\n       }\n+    }\n \n-      // Check if {@code name} has any aliases left after the\n-      // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n-           name.type == Name.Type.FUNCTION) &&\n-          name.aliasingGets == 0 && name.props != null) {\n-        // All of {@code name}'s children meet condition (a), so they can be\n-        // added to the worklist.\n-        workList.addAll(name.props);\n+    for (Scope s : getAllMemoizedScopes()) {\n+      for (Var v : s.getVars()) {\n+        if (v.isInlined()) {\n+          continue;\n+        }\n+        if (!v.isLValue()) {\n+          ++notInlinableFunctionCount;\n+          notInlinableBytesCount += getFunctionLength(v.getNode());\n+        } else {\n+          ++notInlinableVariableCount;\n+          notInlinableBytesCount += getVariableLength(v.getNode());\n+        }\n       }\n     }\n-  }\n+\n+    logResults(inlinedFunctionCount, inlinedVariableCount, inlinedBytesCount,\n+        notInlinableFunctionCount, notInlinableVariableCount, notInlinableBytesCount);\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n     // Ensure that the alias is assigned to a local variable at that",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}