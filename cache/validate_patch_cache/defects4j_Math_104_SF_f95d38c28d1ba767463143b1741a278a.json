{
    "patch": "import org.apache.commons.math3.special.Gamma;\n\npublic class GammaDistribution {\n    \n    private final double shape;\n    private final double scale;\n    \n    /**\n     * Constructs a new instance of the GammaDistribution with the given shape and scale.\n     * \n     * @param shape the shape parameter\n     * @param scale the scale parameter\n     */\n    public GammaDistribution(double shape, double scale) {\n        if (shape <= 0.0) {\n            throw new IllegalArgumentException(\"Shape parameter must be positive.\");\n        }\n        if (scale <= 0.0) {\n            throw new IllegalArgumentException(\"Scale parameter must be positive.\");\n        }\n        this.shape = shape;\n        this.scale = scale;\n    }\n    \n    /**\n     * Computes the probability density function for this distribution evaluated at {@code x}.\n     * \n     * @param x the point at which to evaluate the probability density function\n     * @return the value of the probability density function for this distribution evaluated at {@code x}\n     */\n    public double density(double x) {\n        if (x < 0.0) {\n            return 0.0;\n        }\n        final double logDensity = (shape - 1.0) * Math.log(x / scale) - x / scale - Gamma.logGamma(shape) - Math.log(scale);\n        return Math.exp(logDensity);\n    }\n    \n    /**\n     * Computes the cumulative distribution function for this distribution evaluated at {@code x}.\n     * \n     * @param x the point at which to evaluate the cumulative distribution function\n     * @return the value of the cumulative distribution function for this distribution evaluated at {@code x}\n     */\n    public double cumulativeProbability(double x) {\n        if (x <= 0.0) {\n            return 0.0;\n        }\n        return Gamma.regularizedGammaQ(shape, x / scale);\n    }\n    \n    /**\n     * Computes the inverse of the cumulative distribution function for this distribution evaluated at {@code p}.\n     * \n     * @param p the point at which to evaluate the inverse cumulative distribution function\n     * @return the value <code>x<sub>0.95</sub></code> such that <code>P[X &le; x<sub>0.95</sub>] = p</code>\n     */\n    public double inverseCumulativeProbability(double p) {\n        if (p < 0.0 || p > 1.0) {\n            throw new IllegalArgumentException(\"Probability must be between 0.0 and 1.0 inclusive.\");\n        }\n        return scale * Gamma.inverseRegularizedGammaQ(shape, p);\n    }\n    \n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..ce31f6e6e 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,71 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+\n+public class GammaDistribution {\n+    \n+    private final double shape;\n+    private final double scale;\n+    \n+    /**\n+     * Constructs a new instance of the GammaDistribution with the given shape and scale.\n+     * \n+     * @param shape the shape parameter\n+     * @param scale the scale parameter\n+     */\n+    public GammaDistribution(double shape, double scale) {\n+        if (shape <= 0.0) {\n+            throw new IllegalArgumentException(\"Shape parameter must be positive.\");\n+        }\n+        if (scale <= 0.0) {\n+            throw new IllegalArgumentException(\"Scale parameter must be positive.\");\n+        }\n+        this.shape = shape;\n+        this.scale = scale;\n+    }\n+    \n+    /**\n+     * Computes the probability density function for this distribution evaluated at {@code x}.\n+     * \n+     * @param x the point at which to evaluate the probability density function\n+     * @return the value of the probability density function for this distribution evaluated at {@code x}\n+     */\n+    public double density(double x) {\n+        if (x < 0.0) {\n+            return 0.0;\n+        }\n+        final double logDensity = (shape - 1.0) * Math.log(x / scale) - x / scale - Gamma.logGamma(shape) - Math.log(scale);\n+        return Math.exp(logDensity);\n+    }\n+    \n+    /**\n+     * Computes the cumulative distribution function for this distribution evaluated at {@code x}.\n+     * \n+     * @param x the point at which to evaluate the cumulative distribution function\n+     * @return the value of the cumulative distribution function for this distribution evaluated at {@code x}\n+     */\n+    public double cumulativeProbability(double x) {\n+        if (x <= 0.0) {\n+            return 0.0;\n+        }\n+        return Gamma.regularizedGammaQ(shape, x / scale);\n+    }\n+    \n+    /**\n+     * Computes the inverse of the cumulative distribution function for this distribution evaluated at {@code p}.\n+     * \n+     * @param p the point at which to evaluate the inverse cumulative distribution function\n+     * @return the value <code>x<sub>0.95</sub></code> such that <code>P[X &le; x<sub>0.95</sub>] = p</code>\n+     */\n+    public double inverseCumulativeProbability(double p) {\n+        if (p < 0.0 || p > 1.0) {\n+            throw new IllegalArgumentException(\"Probability must be between 0.0 and 1.0 inclusive.\");\n+        }\n+        return scale * Gamma.inverseRegularizedGammaQ(shape, p);\n+    }\n+    \n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}