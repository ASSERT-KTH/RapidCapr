{
    "patch": "        if (Precision.equals(y[1], 0)) {\n            // return the initial guess if it is a perfect root.\n            return x[1];\n        }\n\n        // evaluate first  endpoint\n        y[0] = computeObjectiveValue(x[0]);\n        if (Precision.equals(y[0], 0)) {\n            // return the first endpoint if it is a perfect root.\n            return x[0];\n        }\n\n        int nbPoints;\n        int signChangeIndex;\n        if (y[0] * y[1] < 0) {\n            // reduce interval if it brackets the root\n            nbPoints = 2;\n            signChangeIndex = 1;\n        } else {\n            // evaluate second endpoint\n            y[2] = computeObjectiveValue(x[2]);\n            if (Precision.equals(y[2], 0)) {\n                // return the second endpoint if it is a perfect root.\n                return x[2];\n            }\n            if (y[1] * y[2] < 0) {\n                // use all computed point as a start sampling array for solving\n                nbPoints = 3;\n                signChangeIndex = 2;\n            } else {\n                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n            }\n        }\n\n        // prepare a work array for inverse polynomial interpolation\n        final double[] tmpX = new double[x.length];\n\n        // current tightest bracketing of the root\n        double xA = x[signChangeIndex - 1];\n        double yA = y[signChangeIndex - 1];\n        double absYA = FastMath.abs(yA);\n        int agingA = 0;\n        double xB = x[signChangeIndex];\n        double yB = y[signChangeIndex];\n        double absYB = FastMath.abs(yB);\n        int agingB = 0;\n\n        // search loop\n        while (true) {\n\n            final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA),\n                    FastMath.abs(xB));\n            if (FastMath.abs(xB - xA) <= xTol) {\n                switch (allowed) {\n                case ANY_SIDE:\n                    return absYA < absYB ? xA : xB;\n                case LEFT_SIDE:\n                    return xA;\n                case RIGHT_SIDE:\n                    return xB;\n                case BELOW_SIDE:\n                    return yA <= 0 ? xA : xB;\n                case ABOVE_SIDE:\n                    return yA < 0 ? xB : xA;\n                default:\n                    // this should never happen\n                    throw new MathInternalError();\n                }\n            }\n            if (nbPoints == x.length) {\n                // we have to drop one point in order to insert the new one\n                nbPoints--;\n                if (signChangeIndex >= (x.length + 1) / 2) {\n                    // we drop the lowest point, we have to shift the arrays and the index\n                    System.arraycopy(x, 1, x, 0, nbPoints);\n                    System.arraycopy(y, 1, y, 0, nbPoints);\n                    --signChangeIndex;\n                } else {\n                    // we drop the highest point, no need to move the signChangeIndex index\n                    System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n                    System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n                }\n            } else if (signChangeIndex == 0) {\n                // we have to add a point ad the lower end of the interval\n                if (nbPoints >= x.length) {\n                    // we have to drop one point in order to insert the new one\n                    nbPoints--;\n                    // shift the arrays, no need to move the signChangeIndex index\n                    System.arraycopy(x, 0, x, 1, nbPoints);\n                    System.arraycopy(y, 0, y, 1, nbPoints);\n                }\n                // expand the bracket downwards\n                ++nbPoints;\n                --signChangeIndex;\n                x[0] = xA + 0.5 * (xB - xA);\n                y[0] = computeObjectiveValue(x[0]);\n                if (Precision.equals(y[0], 0)) {\n                    return x[0];\n                }\n            } else if (signChangeIndex == nbPoints - 1) {\n                // we have to add a point ad the upper end of the interval\n                if (nbPoints >= x.length) {\n                    // we have to drop one point in order to insert the new one\n                    nbPoints--;\n                }\n                // expand the bracket upwards\n                ++nbPoints;\n                x[nbPoints - 1] = xB - 0.5 * (xB - xA);\n                y[nbPoints - 1] = computeObjectiveValue(x[nbPoints - 1]);\n                if (Precision.equals(y[nbPoints - 1], 0)) {\n                    return x[nbPoints - 1];\n                }\n                if (nbPoints == 3) {\n                    // we now have 3 points, setup the tightest bracketing interval\n                    signChangeIndex = y[0] * y[1] < 0 ? 1 : 2;\n                    xA = x[signChangeIndex - 1];\n                    yA = y[signChangeIndex - 1];\n                    absYA = FastMath.abs(yA);\n                    agingA = 0;\n                    xB = x[signChangeIndex];\n                    yB = y[signChangeIndex];\n                    absYB = FastMath.abs(yB);\n                    agingB = 0;\n                    continue;\n                }\n            } else {\n                // we increase smoothly the number of points\n                ++nbPoints;\n            }\n\n            // guess the new point abscissa with respect to the tightest bracketing interval\n            final int start = signChangeIndex > 1 ? signChangeIndex - 2 : 0;\n            final int end = signChangeIndex < nbPoints - 2 ? signChangeIndex + 2 : nbPoints - 1;\n            final double targetY = 0;\n            System.arraycopy(x, start, tmpX, 0, end - start + 1);\n            tmpX[end - start + 1] = xA + (xB - xA) * 0.5;\n            double nextX = tmpX[end - start + 1];\n            double nextY = computeObjectiveValue(nextX);\n            for (int i = 0; i < maxIter; i++) {\n                // update the tightest bracketing interval\n                boolean tight;\n                if (nextY * yA < 0) {\n                    xB = nextX;\n                    yB = nextY;\n                    absYB = FastMath.abs(yB);\n                    agingB = 0;\n                    if (absYB < absYA) {\n                        final double oldA = xA;\n                        final double oldYA = yA;\n                        xA = nextX;\n                        yA = nextY;\n                        absYA = FastMath.abs(yA);\n                        tight = false;\n                        for (int j = end; j >= start; --j) {\n                            if (FastMath.abs(xA - tmpX[j]) <= FastMath.abs(xB - tmpX[j])) {\n                                nextX = xA - (xB - xA) * (xA - tmpX[j]) / (xB - xA);\n                            } else {\n                                nextX = xB - (xB - xA) * (xB - tmpX[j]) / (xB - xA);\n                            }\n                            final double previousX = tmpX[j];\n                            final double previousY = y[j];\n                            tmpX[j] = nextX;\n                            tmpX[j + 1] = previousX;\n                            y[j] = nextY = computeObjectiveValue(nextX);\n                            y[j + 1] = previousY;\n                        }\n                    } else {\n                        agingA++;\n                        tight = agingA < MAXIMAL_AGING;\n                    }\n                } else if (yB * nextY < 0) {\n                    xA = nextX;\n                    yA = nextY;\n                    absYA = FastMath.abs(yA);\n                    agingA = 0;\n                    if (absYB < absYA) {\n                        final double oldB = xB;\n                        final double oldYB = yB;\n                        xB = nextX;\n                        yB = nextY;\n                        absYB = FastMath.abs(yB);\n                        tight = false;\n                        for (int j = start; j <= end; ++j) {\n                            if (FastMath.abs(xA - tmpX[j]) <= FastMath.abs(xB - tmpX[j])) {\n                                nextX = xA - (xB - xA) * (xA - tmpX[j]) / (xB - xA);\n                            } else {\n                                nextX = xB - (xB - xA) * (xB - tmpX[j]) / (xB - xA);\n                            }\n                            final double previousX = tmpX[j];\n                            final double previousY = y[j];\n                            tmpX[j] = nextX;\n                            tmpX[j + 1] = previousX;\n                            y[j] = nextY = computeObjectiveValue(nextX);\n                            y[j + 1] = previousY;\n                        }\n                    } else {\n                        agingB++;\n                        tight = agingB < MAXIMAL_AGING;\n                    }\n                } else { // signChangeInde",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..e846152b1 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,26 +140,14 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n+        if (Precision.equals(y[1], 0)) {\n             // return the initial guess if it is a perfect root.\n             return x[1];\n         }\n \n         // evaluate first  endpoint\n         y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n+        if (Precision.equals(y[0], 0)) {\n             // return the first endpoint if it is a perfect root.\n             return x[0];\n         }\n@@ -167,182 +155,191 @@ public class BracketingNthOrderBrentSolver\n         int nbPoints;\n         int signChangeIndex;\n         if (y[0] * y[1] < 0) {\n-\n             // reduce interval if it brackets the root\n-            nbPoints        = 2;\n+            nbPoints = 2;\n             signChangeIndex = 1;\n-\n         } else {\n-\n             // evaluate second endpoint\n             y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n+            if (Precision.equals(y[2], 0)) {\n                 // return the second endpoint if it is a perfect root.\n                 return x[2];\n             }\n-\n             if (y[1] * y[2] < 0) {\n                 // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n+                nbPoints = 3;\n                 signChangeIndex = 2;\n             } else {\n                 throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n             }\n-\n         }\n \n         // prepare a work array for inverse polynomial interpolation\n         final double[] tmpX = new double[x.length];\n \n         // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n+        double xA = x[signChangeIndex - 1];\n+        double yA = y[signChangeIndex - 1];\n         double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n+        int agingA = 0;\n+        double xB = x[signChangeIndex];\n+        double yB = y[signChangeIndex];\n         double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n+        int agingB = 0;\n \n         // search loop\n         while (true) {\n \n-            // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n+            final double xTol = getAbsoluteAccuracy() + getRelativeAccuracy() * FastMath.max(FastMath.abs(xA),\n+                    FastMath.abs(xB));\n+            if (FastMath.abs(xB - xA) <= xTol) {\n                 switch (allowed) {\n-                case ANY_SIDE :\n+                case ANY_SIDE:\n                     return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n+                case LEFT_SIDE:\n                     return xA;\n-                case RIGHT_SIDE :\n+                case RIGHT_SIDE:\n                     return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n+                case BELOW_SIDE:\n+                    return yA <= 0 ? xA : xB;\n+                case ABOVE_SIDE:\n+                    return yA < 0 ? xB : xA;\n+                default:\n                     // this should never happen\n-                    throw new MathInternalError(null);\n-                }\n-            }\n-\n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n-            } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n-            }\n-\n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n-                    }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n+                    throw new MathInternalError();\n                 }\n-\n-            } while (Double.isNaN(nextX) && (end - start > 1));\n-\n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n-            }\n-\n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n             }\n-\n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n-\n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n+            if (nbPoints == x.length) {\n                 // we have to drop one point in order to insert the new one\n                 nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n                 if (signChangeIndex >= (x.length + 1) / 2) {\n                     // we drop the lowest point, we have to shift the arrays and the index\n                     System.arraycopy(x, 1, x, 0, nbPoints);\n                     System.arraycopy(y, 1, y, 0, nbPoints);\n                     --signChangeIndex;\n+                } else {\n+                    // we drop the highest point, no need to move the signChangeIndex index\n+                    System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n+                    System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n+                }\n+            } else if (signChangeIndex == 0) {\n+                // we have to add a point ad the lower end of the interval\n+                if (nbPoints >= x.length) {\n+                    // we have to drop one point in order to insert the new one\n+                    nbPoints--;\n+                    // shift the arrays, no need to move the signChangeIndex index\n+                    System.arraycopy(x, 0, x, 1, nbPoints);\n+                    System.arraycopy(y, 0, y, 1, nbPoints);\n+                }\n+                // expand the bracket downwards\n+                ++nbPoints;\n+                --signChangeIndex;\n+                x[0] = xA + 0.5 * (xB - xA);\n+                y[0] = computeObjectiveValue(x[0]);\n+                if (Precision.equals(y[0], 0)) {\n+                    return x[0];\n+                }\n+            } else if (signChangeIndex == nbPoints - 1) {\n+                // we have to add a point ad the upper end of the interval\n+                if (nbPoints >= x.length) {\n+                    // we have to drop one point in order to insert the new one\n+                    nbPoints--;\n+                }\n+                // expand the bracket upwards\n+                ++nbPoints;\n+                x[nbPoints - 1] = xB - 0.5 * (xB - xA);\n+                y[nbPoints - 1] = computeObjectiveValue(x[nbPoints - 1]);\n+                if (Precision.equals(y[nbPoints - 1], 0)) {\n+                    return x[nbPoints - 1];\n+                }\n+                if (nbPoints == 3) {\n+                    // we now have 3 points, setup the tightest bracketing interval\n+                    signChangeIndex = y[0] * y[1] < 0 ? 1 : 2;\n+                    xA = x[signChangeIndex - 1];\n+                    yA = y[signChangeIndex - 1];\n+                    absYA = FastMath.abs(yA);\n+                    agingA = 0;\n+                    xB = x[signChangeIndex];\n+                    yB = y[signChangeIndex];\n+                    absYB = FastMath.abs(yB);\n+                    agingB = 0;\n+                    continue;\n                 }\n-\n-            }\n-\n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n             } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n+                // we increase smoothly the number of points\n+                ++nbPoints;\n             }\n \n-        }\n-\n-    }\n+            // guess the new point abscissa with respect to the tightest bracketing interval\n+            final int start = signChangeIndex > 1 ? signChangeIndex - 2 : 0;\n+            final int end = signChangeIndex < nbPoints - 2 ? signChangeIndex + 2 : nbPoints - 1;\n+            final double targetY = 0;\n+            System.arraycopy(x, start, tmpX, 0, end - start + 1);\n+            tmpX[end - start + 1] = xA + (xB - xA) * 0.5;\n+            double nextX = tmpX[end - start + 1];\n+            double nextY = computeObjectiveValue(nextX);\n+            for (int i = 0; i < maxIter; i++) {\n+                // update the tightest bracketing interval\n+                boolean tight;\n+                if (nextY * yA < 0) {\n+                    xB = nextX;\n+                    yB = nextY;\n+                    absYB = FastMath.abs(yB);\n+                    agingB = 0;\n+                    if (absYB < absYA) {\n+                        final double oldA = xA;\n+                        final double oldYA = yA;\n+                        xA = nextX;\n+                        yA = nextY;\n+                        absYA = FastMath.abs(yA);\n+                        tight = false;\n+                        for (int j = end; j >= start; --j) {\n+                            if (FastMath.abs(xA - tmpX[j]) <= FastMath.abs(xB - tmpX[j])) {\n+                                nextX = xA - (xB - xA) * (xA - tmpX[j]) / (xB - xA);\n+                            } else {\n+                                nextX = xB - (xB - xA) * (xB - tmpX[j]) / (xB - xA);\n+                            }\n+                            final double previousX = tmpX[j];\n+                            final double previousY = y[j];\n+                            tmpX[j] = nextX;\n+                            tmpX[j + 1] = previousX;\n+                            y[j] = nextY = computeObjectiveValue(nextX);\n+                            y[j + 1] = previousY;\n+                        }\n+                    } else {\n+                        agingA++;\n+                        tight = agingA < MAXIMAL_AGING;\n+                    }\n+                } else if (yB * nextY < 0) {\n+                    xA = nextX;\n+                    yA = nextY;\n+                    absYA = FastMath.abs(yA);\n+                    agingA = 0;\n+                    if (absYB < absYA) {\n+                        final double oldB = xB;\n+                        final double oldYB = yB;\n+                        xB = nextX;\n+                        yB = nextY;\n+                        absYB = FastMath.abs(yB);\n+                        tight = false;\n+                        for (int j = start; j <= end; ++j) {\n+                            if (FastMath.abs(xA - tmpX[j]) <= FastMath.abs(xB - tmpX[j])) {\n+                                nextX = xA - (xB - xA) * (xA - tmpX[j]) / (xB - xA);\n+                            } else {\n+                                nextX = xB - (xB - xA) * (xB - tmpX[j]) / (xB - xA);\n+                            }\n+                            final double previousX = tmpX[j];\n+                            final double previousY = y[j];\n+                            tmpX[j] = nextX;\n+                            tmpX[j + 1] = previousX;\n+                            y[j] = nextY = computeObjectiveValue(nextX);\n+                            y[j + 1] = previousY;\n+                        }\n+                    } else {\n+                        agingB++;\n+                        tight = agingB < MAXIMAL_AGING;\n+                    }\n+                } else { // signChangeInde\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}