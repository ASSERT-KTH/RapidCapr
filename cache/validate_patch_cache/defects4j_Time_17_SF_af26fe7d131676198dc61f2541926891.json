{
    "patch": "public long adjustOffset(long instant, boolean earlierOrLater) {\n    long local = convertUTCToLocal(instant);\n    Long instantBefore = null;\n    Long instantAfter = null;\n    boolean gap = false;\n    boolean overlap = false;\n    \n    for (int i = -1; i <= 1; i++) {\n        if (i != 0) {\n            long candidate = convertLocalToUTC(local, false, instant + i * DateTimeConstants.MILLIS_PER_HOUR);\n            long candidateLocal = convertUTCToLocal(candidate);\n            if (candidateLocal == local) {\n                overlap = true;\n                if (i < 0 && (instantBefore == null || candidate > instantBefore)) {\n                    instantBefore = candidate;\n                }\n                if (i > 0 && (instantAfter == null || candidate < instantAfter)) {\n                    instantAfter = candidate;\n                }\n            } else if (candidateLocal > local) {\n                gap = true;\n                if (instantBefore == null || candidate > instantBefore) {\n                    instantBefore = candidate;\n                }\n            } else {\n                gap = true;\n                if (instantAfter == null || candidate < instantAfter) {\n                    instantAfter = candidate;\n                }\n            }\n        }\n    }\n    \n    if (!gap && overlap) {\n        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n    } else {\n        return instant;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 74a3802a..4e707884 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1160,24 +1160,45 @@ public abstract class DateTimeZone implements Serializable {\n      * @param earlierOrLater  false for earlier, true for later\n      * @return the adjusted instant millis\n      */\n-    public long adjustOffset(long instant, boolean earlierOrLater) {\n-        // a bit messy, but will work in all non-pathological cases\n-        \n-        // evaluate 3 hours before and after to work out if anything is happening\n-        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n+public long adjustOffset(long instant, boolean earlierOrLater) {\n+    long local = convertUTCToLocal(instant);\n+    Long instantBefore = null;\n+    Long instantAfter = null;\n+    boolean gap = false;\n+    boolean overlap = false;\n+    \n+    for (int i = -1; i <= 1; i++) {\n+        if (i != 0) {\n+            long candidate = convertLocalToUTC(local, false, instant + i * DateTimeConstants.MILLIS_PER_HOUR);\n+            long candidateLocal = convertUTCToLocal(candidate);\n+            if (candidateLocal == local) {\n+                overlap = true;\n+                if (i < 0 && (instantBefore == null || candidate > instantBefore)) {\n+                    instantBefore = candidate;\n+                }\n+                if (i > 0 && (instantAfter == null || candidate < instantAfter)) {\n+                    instantAfter = candidate;\n+                }\n+            } else if (candidateLocal > local) {\n+                gap = true;\n+                if (instantBefore == null || candidate > instantBefore) {\n+                    instantBefore = candidate;\n+                }\n+            } else {\n+                gap = true;\n+                if (instantAfter == null || candidate < instantAfter) {\n+                    instantAfter = candidate;\n+                }\n+            }\n         }\n-        \n-        // work out range of instants that have duplicate local times\n-        long local = convertUTCToLocal(instant);\n+    }\n+    \n+    if (!gap && overlap) {\n         return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n-        \n-        // calculate result\n-          // currently in later offset\n-          // currently in earlier offset\n+    } else {\n+        return instant;\n     }\n+}\n //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n \n     //-----------------------------------------------------------------------",
    "result_reason": "all tests passed",
    "test_result": "PASS"
}