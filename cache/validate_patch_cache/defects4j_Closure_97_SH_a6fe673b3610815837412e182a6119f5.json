{
    "patch": "// check ranges.  We do not do anything that would clip the double to\n// a 32-bit range, since the user likely does not intend that.\nif (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n    error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n    return n;\n}\n\n// only the lower 5 bits are used when shifting, so don't do anything\n// if the shift amount is outside [0,32)\nif (!(rval >= 0 && rval < 32)) {\n    error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n    return n;\n}\n\nif (n.getType() == Token.URSH && lval < 0) {\n    // Perform an unsigned shift on a signed value by converting it to a long\n    result = ((long) Integer.toUnsignedLong(lval)) >>> rvalInt;\n} else {\n    // Perform a signed or unsigned shift on a signed value\n    switch (n.getType()) {\n        case Token.LSH:\n            result = lval << rvalInt;\n            break;\n        case Token.RSH:\n            result = lval >> rvalInt;\n            break;\n        case Token.URSH:\n            result = Integer.toUnsignedLong(lval) >>> rvalInt;\n            break;\n        default:\n            throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\n    }\n}\n\nNode newNumber = Node.newNumber(result);\nn.getParent().replaceChild(n, newNumber);\nreportCodeChange();\n\nreturn newNumber;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\nindex d6c194a3..08fa782e 100644\n--- a/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n+++ b/src/com/google/javascript/jscomp/PeepholeFoldConstants.java\n@@ -695,7 +695,45 @@ public class PeepholeFoldConstants extends AbstractPeepholeOptimization {\n           // JavaScript handles zero shifts on signed numbers differently than\n           // Java as an Java int can not represent the unsigned 32-bit number\n           // where JavaScript can so use a long here.\n-          result = lvalInt >>> rvalInt;\n+// check ranges.  We do not do anything that would clip the double to\n+// a 32-bit range, since the user likely does not intend that.\n+if (!(lval >= Integer.MIN_VALUE && lval <= Integer.MAX_VALUE)) {\n+    error(BITWISE_OPERAND_OUT_OF_RANGE, left);\n+    return n;\n+}\n+\n+// only the lower 5 bits are used when shifting, so don't do anything\n+// if the shift amount is outside [0,32)\n+if (!(rval >= 0 && rval < 32)) {\n+    error(SHIFT_AMOUNT_OUT_OF_BOUNDS, right);\n+    return n;\n+}\n+\n+if (n.getType() == Token.URSH && lval < 0) {\n+    // Perform an unsigned shift on a signed value by converting it to a long\n+    result = ((long) Integer.toUnsignedLong(lval)) >>> rvalInt;\n+} else {\n+    // Perform a signed or unsigned shift on a signed value\n+    switch (n.getType()) {\n+        case Token.LSH:\n+            result = lval << rvalInt;\n+            break;\n+        case Token.RSH:\n+            result = lval >> rvalInt;\n+            break;\n+        case Token.URSH:\n+            result = Integer.toUnsignedLong(lval) >>> rvalInt;\n+            break;\n+        default:\n+            throw new AssertionError(\"Unknown shift operator: \" + Node.tokenToName(n.getType()));\n+    }\n+}\n+\n+Node newNumber = Node.newNumber(result);\n+n.getParent().replaceChild(n, newNumber);\n+reportCodeChange();\n+\n+return newNumber;\n           break;\n         default:\n           throw new AssertionError(\"Unknown shift operator: \" +",
    "result_reason": "error: method toUnsignedLong in class Integer cannot be applied to given types;",
    "test_result": "ERROR"
}