{
    "patch": "private void inlineAliases(GlobalNamespace namespace) {\n    Multimap<Name, Ref> globalSets = LinkedHashMultimap.create();\n    Multimap<Name, Ref> localSets = LinkedHashMultimap.create();\n    Multimap<Name, Ref> aliasingGets = LinkedHashMultimap.create();\n    Map<Name, Integer> propsNumMap = new HashMap<>();\n\n    for (Name name : namespace.getNameForest()) {\n      propsNumMap.put(name, name.props != null ? name.props.size() : 0);\n\n      for (Ref ref : name.getRefs()) {\n        switch (ref.type) {\n          case SET_FROM_GLOBAL:\n            globalSets.put(name, ref);\n            break;\n\n          case SET_FROM_LOCAL:\n            localSets.put(name, ref);\n            break;\n\n          case ALIASING_GET:\n            aliasingGets.put(name, ref);\n            break;\n        }\n      }\n    }\n\n    boolean workDone = true;\n    while (workDone) {\n      workDone = false;\n\n      for (Name name : namespace.getAllNames()) {\n        if (name.type != null || propsNumMap.get(name) > 0) {\n          continue;\n        }\n\n        Collection<Ref> globalSetRefs = globalSets.get(name);\n        Collection<Ref> localSetRefs = localSets.get(name);\n        Collection<Ref> aliasingGetRefs = aliasingGets.get(name);\n\n        if (globalSetRefs.size() == 1 && localSetRefs.isEmpty() && aliasingGetRefs.size() > 0) {\n          Ref globalSetRef = Iterables.getOnlyElement(globalSetRefs);\n          Node valueNode = globalSetRef.getNode();\n\n          if (valueNode.canBeSideEffected()) {\n            continue;\n          }\n\n          for (Ref aliasingGetRef : aliasingGetRefs) {\n            Name aliasingGetName = aliasingGetRef.getName();\n            if (!aliasingGetRef.isGetSameName() || !name.canEliminateGet(aliasingGetRef)) {\n              continue;\n            }\n\n            int aliasingGetTypeCount =\n                aliasingGetName.getDerivedVariablesCount(Name.Type.ALIASING_GET);\n            if (aliasingGetTypeCount != 1 || !aliasingGetRef.scope.isLocal()) {\n              continue;\n            }\n\n            Node aliasingGetNode = aliasingGetRef.getNode();\n            if (aliasingGetNode.canBeSideEffected()) {\n              continue;\n            }\n\n            Node parentNode = aliasingGetNode.getParent();\n            if (!NodeUtil.isExpressionResultUsed(parentNode) && !NodeUtil.isNameDeclaration(parentNode)) {\n              continue;\n            }\n\n            Node valuesParent = valueNode.getParent();\n            Node valueNodesParent = valueNode.getParent();\n\n            // Don't inline if the name node is a parameter value in a function or a function declaration.\n            // Don't inline if the name is used in a FOR / FOR IN loop.\n            if ((valuesParent.hasOneChild() && NodeUtil.isNameDeclaration(valuesParent.getFirstChild())) ||\n                NodeUtil.isNameDeclaration(valuesParent) ||\n                NodeUtil.isFunctionExpression(valuesParent) ||\n                NodeUtil.isFunctionDeclaration(valuesParent) ||\n                NodeUtil.isForIn(valuesParent) ||\n                NodeUtil.isVanillaFor(valuesParent)) {\n              continue;\n            }\n\n            AliasInliner ai = new AliasInliner(\n                getNameNode(aliasingGetNode),\n                valueNode.detach(),\n                namespace.getScope());\n            NodeUtil.markFunctionsDeleted(ai.getMarkedFunctions());\n            Node newRoot = ai.maybeGetOptimizedResultNode();\n            if (newRoot == null) {\n              continue;\n            }\n\n            Node replacementNode;\n\n            if (NodeUtil.isExpressionResultUsed(parentNode)) {\n              replacementNode = newRoot;\n            } else {\n              replacementNode = newRoot.getFirstChild();\n              while (replacementNode.isExprResult()) {\n                replacementNode = replacementNode.getFirstChild();\n              }\n            }\n\n            aliasingGetRef.getScope().getClosestHoistScope().getScopeRoot().addChildToBack(newRoot);\n            replaceAliasNode(aliasingGetNode, replacementNode, aliasingGetRef.getScope());\n\n            for (Ref otherRef : aliasingGetName.getRefs()) {\n              switch (otherRef.type) {\n                case SET_FROM_GLOBAL:\n                  globalSets.put(otherRef.getName(), otherRef);\n                  break;\n\n                case SET_FROM_LOCAL:\n                  localSets.put(otherRef.getName(), otherRef);\n                  break;\n              }\n            }\n\n            workDone = true;\n          }\n        }\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..32ae4da9 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,131 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+private void inlineAliases(GlobalNamespace namespace) {\n+    Multimap<Name, Ref> globalSets = LinkedHashMultimap.create();\n+    Multimap<Name, Ref> localSets = LinkedHashMultimap.create();\n+    Multimap<Name, Ref> aliasingGets = LinkedHashMultimap.create();\n+    Map<Name, Integer> propsNumMap = new HashMap<>();\n+\n+    for (Name name : namespace.getNameForest()) {\n+      propsNumMap.put(name, name.props != null ? name.props.size() : 0);\n+\n+      for (Ref ref : name.getRefs()) {\n+        switch (ref.type) {\n+          case SET_FROM_GLOBAL:\n+            globalSets.put(name, ref);\n+            break;\n+\n+          case SET_FROM_LOCAL:\n+            localSets.put(name, ref);\n+            break;\n+\n+          case ALIASING_GET:\n+            aliasingGets.put(name, ref);\n+            break;\n+        }\n+      }\n+    }\n+\n+    boolean workDone = true;\n+    while (workDone) {\n+      workDone = false;\n+\n+      for (Name name : namespace.getAllNames()) {\n+        if (name.type != null || propsNumMap.get(name) > 0) {\n+          continue;\n+        }\n+\n+        Collection<Ref> globalSetRefs = globalSets.get(name);\n+        Collection<Ref> localSetRefs = localSets.get(name);\n+        Collection<Ref> aliasingGetRefs = aliasingGets.get(name);\n+\n+        if (globalSetRefs.size() == 1 && localSetRefs.isEmpty() && aliasingGetRefs.size() > 0) {\n+          Ref globalSetRef = Iterables.getOnlyElement(globalSetRefs);\n+          Node valueNode = globalSetRef.getNode();\n+\n+          if (valueNode.canBeSideEffected()) {\n+            continue;\n+          }\n+\n+          for (Ref aliasingGetRef : aliasingGetRefs) {\n+            Name aliasingGetName = aliasingGetRef.getName();\n+            if (!aliasingGetRef.isGetSameName() || !name.canEliminateGet(aliasingGetRef)) {\n+              continue;\n+            }\n+\n+            int aliasingGetTypeCount =\n+                aliasingGetName.getDerivedVariablesCount(Name.Type.ALIASING_GET);\n+            if (aliasingGetTypeCount != 1 || !aliasingGetRef.scope.isLocal()) {\n+              continue;\n+            }\n+\n+            Node aliasingGetNode = aliasingGetRef.getNode();\n+            if (aliasingGetNode.canBeSideEffected()) {\n+              continue;\n+            }\n+\n+            Node parentNode = aliasingGetNode.getParent();\n+            if (!NodeUtil.isExpressionResultUsed(parentNode) && !NodeUtil.isNameDeclaration(parentNode)) {\n+              continue;\n+            }\n+\n+            Node valuesParent = valueNode.getParent();\n+            Node valueNodesParent = valueNode.getParent();\n+\n+            // Don't inline if the name node is a parameter value in a function or a function declaration.\n+            // Don't inline if the name is used in a FOR / FOR IN loop.\n+            if ((valuesParent.hasOneChild() && NodeUtil.isNameDeclaration(valuesParent.getFirstChild())) ||\n+                NodeUtil.isNameDeclaration(valuesParent) ||\n+                NodeUtil.isFunctionExpression(valuesParent) ||\n+                NodeUtil.isFunctionDeclaration(valuesParent) ||\n+                NodeUtil.isForIn(valuesParent) ||\n+                NodeUtil.isVanillaFor(valuesParent)) {\n+              continue;\n+            }\n+\n+            AliasInliner ai = new AliasInliner(\n+                getNameNode(aliasingGetNode),\n+                valueNode.detach(),\n+                namespace.getScope());\n+            NodeUtil.markFunctionsDeleted(ai.getMarkedFunctions());\n+            Node newRoot = ai.maybeGetOptimizedResultNode();\n+            if (newRoot == null) {\n+              continue;\n+            }\n+\n+            Node replacementNode;\n+\n+            if (NodeUtil.isExpressionResultUsed(parentNode)) {\n+              replacementNode = newRoot;\n+            } else {\n+              replacementNode = newRoot.getFirstChild();\n+              while (replacementNode.isExprResult()) {\n+                replacementNode = replacementNode.getFirstChild();\n+              }\n+            }\n+\n+            aliasingGetRef.getScope().getClosestHoistScope().getScopeRoot().addChildToBack(newRoot);\n+            replaceAliasNode(aliasingGetNode, replacementNode, aliasingGetRef.getScope());\n+\n+            for (Ref otherRef : aliasingGetName.getRefs()) {\n+              switch (otherRef.type) {\n+                case SET_FROM_GLOBAL:\n+                  globalSets.put(otherRef.getName(), otherRef);\n+                  break;\n+\n+                case SET_FROM_LOCAL:\n+                  localSets.put(otherRef.getName(), otherRef);\n+                  break;\n+              }\n+            }\n+\n+            workDone = true;\n+          }\n+        }\n+      }\n+    }\n+  }\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}