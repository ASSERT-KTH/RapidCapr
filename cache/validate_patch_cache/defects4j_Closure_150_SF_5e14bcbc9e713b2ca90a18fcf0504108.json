{
    "patch": "       if (n == scope.getRootNode()) return;\n\n       switch (n.getToken()) {\n         case FUNCTION:\n           if (NodeUtil.isFunctionDeclaration(n)) {\n             defineDeclaredFunction(n, parent);\n           }\n           break;\n         case CATCH:\n           defineCatch(n, parent);\n           break;\n         case VAR:\n           defineVar(n, parent);\n           break;\n         case ASSIGN:\n           // This is a special case to handle goog.module.\n           if (n.getFirstChild().getToken() == Token.GETPROP\n               && n.getFirstFirstChild().matchesQualifiedName(\"goog\")\n               && n.getFirstChild().getLastChild().getString().equals(\"module\")) {\n             handleModuleExport(n);\n           }\n           break;\n         case CALL:\n           if (parent == null\n               || (parent.getToken() != Token.EXPR_RESULT && parent.getToken() != Token.VAR)) {\n             // Skip rewriting anything other than a top-level statement or in a var statement i.e\n             // the result is not used to assign or call something else.\n             break;\n           }\n           Node callee = n.getFirstChild();\n           if (callee.matchesQualifiedName(ModuleLoader.LOAD_MODULE_FN)) {\n             setSafeTraversalMode();\n             handleModuleImport(n, t.getInputId());\n             setUnsafeTraversalMode();\n           }\n           if (callee.matchesQualifiedName(ModuleLoader.DECLARE_LEGACY_NAMESPACE_FN)) {\n             handleModuleDeclareLegacyNamespace(n);\n           }\n           break;\n         case RETURN:\n           if (parent.isBlock()) {\n             // Rewrite the END statement to include the new return statement in order to avoid dead\n             // code after a `return` statement and allow optimizing by removing unnecessary code.\n             Node block = n.getAncestor(2);\n             Node insertAfter = NodeUtil.getFunctionBody(block.getParent());\n             insertAfter.addChildAfter(IR.exprResult(IR.name(\":\")).srcref(insertAfter), insertAfter.getLastChild());\n           }\n           break;\n         default:\n           attachLiteralTypes(n);\n           break;\n       }\n     }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..3ab12398 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1440,30 +1440,59 @@ final class TypedScopeCreator implements ScopeCreator {\n      * @param n The node being visited.\n      * @param parent The parent of n\n      */\n-    @Override public void visit(NodeTraversal t, Node n, Node parent) {\n-      if (n == scope.getRootNode()) return;\n-\n-      if (n.getType() == Token.LP && parent == scope.getRootNode()) {\n-        handleFunctionInputs(parent);\n-        return;\n-      }\n-\n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n-          }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n-    }\n+       if (n == scope.getRootNode()) return;\n+\n+       switch (n.getToken()) {\n+         case FUNCTION:\n+           if (NodeUtil.isFunctionDeclaration(n)) {\n+             defineDeclaredFunction(n, parent);\n+           }\n+           break;\n+         case CATCH:\n+           defineCatch(n, parent);\n+           break;\n+         case VAR:\n+           defineVar(n, parent);\n+           break;\n+         case ASSIGN:\n+           // This is a special case to handle goog.module.\n+           if (n.getFirstChild().getToken() == Token.GETPROP\n+               && n.getFirstFirstChild().matchesQualifiedName(\"goog\")\n+               && n.getFirstChild().getLastChild().getString().equals(\"module\")) {\n+             handleModuleExport(n);\n+           }\n+           break;\n+         case CALL:\n+           if (parent == null\n+               || (parent.getToken() != Token.EXPR_RESULT && parent.getToken() != Token.VAR)) {\n+             // Skip rewriting anything other than a top-level statement or in a var statement i.e\n+             // the result is not used to assign or call something else.\n+             break;\n+           }\n+           Node callee = n.getFirstChild();\n+           if (callee.matchesQualifiedName(ModuleLoader.LOAD_MODULE_FN)) {\n+             setSafeTraversalMode();\n+             handleModuleImport(n, t.getInputId());\n+             setUnsafeTraversalMode();\n+           }\n+           if (callee.matchesQualifiedName(ModuleLoader.DECLARE_LEGACY_NAMESPACE_FN)) {\n+             handleModuleDeclareLegacyNamespace(n);\n+           }\n+           break;\n+         case RETURN:\n+           if (parent.isBlock()) {\n+             // Rewrite the END statement to include the new return statement in order to avoid dead\n+             // code after a `return` statement and allow optimizing by removing unnecessary code.\n+             Node block = n.getAncestor(2);\n+             Node insertAfter = NodeUtil.getFunctionBody(block.getParent());\n+             insertAfter.addChildAfter(IR.exprResult(IR.name(\":\")).srcref(insertAfter), insertAfter.getLastChild());\n+           }\n+           break;\n+         default:\n+           attachLiteralTypes(n);\n+           break;\n+       }\n+     }\n \n     /** Handle bleeding functions and function parameters. */\n     private void handleFunctionInputs(Node fnNode) {",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}