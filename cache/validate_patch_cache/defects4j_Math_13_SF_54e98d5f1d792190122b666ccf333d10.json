{
    "patch": "        EigenDecomposition eigen = new EigenDecomposition(m);\n        RealMatrix v = eigen.getV();\n        RealMatrix d = eigen.getD();\n        \n        int n = m.getColumnDimension();\n        RealMatrix sqrtD = MatrixUtils.createRealMatrix(n, n);\n        for(int i=0; i<n; ++i) {\n            sqrtD.setEntry(i, i, FastMath.sqrt(d.getEntry(i, i)));\n        }\n        \n        RealMatrix vT = v.transpose();\n        RealMatrix invSqrtD = new LUDecomposition(sqrtD).getSolver().getInverse();\n        RealMatrix vTV = vT.multiply(invSqrtD);\n        \n        int threads = Runtime.getRuntime().availableProcessors();\n        ExecutorService executor = Executors.newFixedThreadPool(threads);\n        List<Future<RealMatrix>> futures = new ArrayList<>();\n        \n        for(int i=0; i<n; ++i) {\n            int row = i;\n            futures.add(executor.submit(() -> {\n                RealMatrix vi = v.getRowMatrix(row);\n                RealMatrix sqrtDi = sqrtD.getSubMatrix(row, row, 0, n-1);\n                RealMatrix viT = vi.transpose();\n                RealMatrix dvi = diag(viT, sqrtDi);\n                RealMatrix viDV = dvi.multiply(vTV);\n                RealMatrix col = MatrixUtils.createRealMatrix(n, 1);\n                for(int j=0; j<n; ++j) {\n                    col.setEntry(j, 0, viDV.getEntry(j, row));\n                }\n                return col;\n            }));\n        }\n        \n        RealMatrix sqrtM = MatrixUtils.createRealMatrix(n, n);\n        try {\n            for(int i=0; i<n; ++i) {\n                RealMatrix col = futures.get(i).get(timeout, TimeUnit.SECONDS);\n                sqrtM.setColumnMatrix(i, col);\n            }\n        } catch (Exception e) {\n            throw new RuntimeException(e);\n        } finally {\n            executor.shutdownNow();\n        }\n        \n        return sqrtM.multiply(sqrtM.transpose());\n    }\n    \n    private static RealMatrix diag(RealMatrix a, RealMatrix b) {\n        RealMatrix result = MatrixUtils.createRealMatrix(a.getRowDimension(), b.getColumnDimension());\n        for(int i=0; i<a.getRowDimension(); ++i) {\n            for(int j=0; j<b.getColumnDimension(); ++j) {\n                result.setEntry(i, j, a.getEntry(i, 0) * b.getEntry(0, j));\n            }\n        }\n        return result;\n    }\n    \n    private static final int timeout = 60; // seconds",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..dd7a4bf60 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,64 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+        EigenDecomposition eigen = new EigenDecomposition(m);\n+        RealMatrix v = eigen.getV();\n+        RealMatrix d = eigen.getD();\n+        \n+        int n = m.getColumnDimension();\n+        RealMatrix sqrtD = MatrixUtils.createRealMatrix(n, n);\n+        for(int i=0; i<n; ++i) {\n+            sqrtD.setEntry(i, i, FastMath.sqrt(d.getEntry(i, i)));\n+        }\n+        \n+        RealMatrix vT = v.transpose();\n+        RealMatrix invSqrtD = new LUDecomposition(sqrtD).getSolver().getInverse();\n+        RealMatrix vTV = vT.multiply(invSqrtD);\n+        \n+        int threads = Runtime.getRuntime().availableProcessors();\n+        ExecutorService executor = Executors.newFixedThreadPool(threads);\n+        List<Future<RealMatrix>> futures = new ArrayList<>();\n+        \n+        for(int i=0; i<n; ++i) {\n+            int row = i;\n+            futures.add(executor.submit(() -> {\n+                RealMatrix vi = v.getRowMatrix(row);\n+                RealMatrix sqrtDi = sqrtD.getSubMatrix(row, row, 0, n-1);\n+                RealMatrix viT = vi.transpose();\n+                RealMatrix dvi = diag(viT, sqrtDi);\n+                RealMatrix viDV = dvi.multiply(vTV);\n+                RealMatrix col = MatrixUtils.createRealMatrix(n, 1);\n+                for(int j=0; j<n; ++j) {\n+                    col.setEntry(j, 0, viDV.getEntry(j, row));\n+                }\n+                return col;\n+            }));\n+        }\n+        \n+        RealMatrix sqrtM = MatrixUtils.createRealMatrix(n, n);\n+        try {\n+            for(int i=0; i<n; ++i) {\n+                RealMatrix col = futures.get(i).get(timeout, TimeUnit.SECONDS);\n+                sqrtM.setColumnMatrix(i, col);\n+            }\n+        } catch (Exception e) {\n+            throw new RuntimeException(e);\n+        } finally {\n+            executor.shutdownNow();\n+        }\n+        \n+        return sqrtM.multiply(sqrtM.transpose());\n+    }\n+    \n+    private static RealMatrix diag(RealMatrix a, RealMatrix b) {\n+        RealMatrix result = MatrixUtils.createRealMatrix(a.getRowDimension(), b.getColumnDimension());\n+        for(int i=0; i<a.getRowDimension(); ++i) {\n+            for(int j=0; j<b.getColumnDimension(); ++j) {\n+                result.setEntry(i, j, a.getEntry(i, 0) * b.getEntry(0, j));\n+            }\n+        }\n+        return result;\n     }\n+    \n+    private static final int timeout = 60; // seconds\n }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}