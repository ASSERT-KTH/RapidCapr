{
    "patch": "        if (block.isFunction) {\n          break;\n        } else if (block.isLoop) {\n          // if the assignment is in a loop, we need to check if it's assigned repeatedly\n          List<BasicBlock> visitedBlocks = new ArrayList<>();\n          visitedBlocks.add(block);\n          for (BasicBlock successor : block.getSuccessors()) {\n            if (successor.isLoopHeader() && visitedBlocks.contains(successor)) {\n              // if it's a loop header we have visited before, we have already checked for repeated assignments\n              continue;\n            }\n            visitedBlocks.add(successor);\n            if (!successor.isUnreachable()) {\n              for (Node statement : successor.getStatements()) {\n                for (Reference assignmentRef : statement.getAssignments()) {\n                  if (assignmentRef.canBeAssignedOnce() && assignmentRef.getReferencedName().equals(getReferencedName())) {\n                    // the current reference is a potential assignment for the variable, so we return false\n                    return false;\n                  }\n                }\n              }\n            }\n          }\n          return true;\n        }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..c34fd429 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,31 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+        if (block.isFunction) {\n+          break;\n+        } else if (block.isLoop) {\n+          // if the assignment is in a loop, we need to check if it's assigned repeatedly\n+          List<BasicBlock> visitedBlocks = new ArrayList<>();\n+          visitedBlocks.add(block);\n+          for (BasicBlock successor : block.getSuccessors()) {\n+            if (successor.isLoopHeader() && visitedBlocks.contains(successor)) {\n+              // if it's a loop header we have visited before, we have already checked for repeated assignments\n+              continue;\n+            }\n+            visitedBlocks.add(successor);\n+            if (!successor.isUnreachable()) {\n+              for (Node statement : successor.getStatements()) {\n+                for (Reference assignmentRef : statement.getAssignments()) {\n+                  if (assignmentRef.canBeAssignedOnce() && assignmentRef.getReferencedName().equals(getReferencedName())) {\n+                    // the current reference is a potential assignment for the variable, so we return false\n+                    return false;\n+                  }\n+                }\n+              }\n+            }\n+          }\n+          return true;\n+        }\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}