{
    "patch": "public static String infixToPostfix(String expression) {\n    StringBuilder result = new StringBuilder();\n    Stack<String> stack = new Stack<>();\n    Context lhsContext = Context.INIT;\n\n    for (int i = 0; i < expression.length(); i++) {\n        Context rhsContext = getContext(expression, i);\n        String token = getToken(expression, i);\n\n        if (isNumber(token)) {\n            if (lhsContext == Context.NUM_OR_VAR ||\n                    lhsContext == Context.CLOSED_PAREN ||\n                    lhsContext == Context.INIT) {\n                result.append(token).append(\" \");\n            } else {\n                result = new StringBuilder(\"Error: Invalid syntax\");\n                break;\n            }\n        } else if (isOperator(token)) {\n            if (lhsContext == Context.NUM_OR_VAR || lhsContext == Context.CLOSED_PAREN) {\n                if (token.equals(\"u-\") && (i == 0 || !isNumber(getToken(expression, i - 1)) || getToken(expression, i - 1).equals(\")\"))) {\n                    stack.push(token);\n                } else {\n                    while (!stack.empty() && !stack.peek().equals(\"(\") && getPrecedence(token, rhsContext, Context.LEFT) <= getPrecedence(stack.peek(), rhsContext, Context.RIGHT)) {\n                        result.append(stack.pop()).append(\" \");\n                    }\n                    stack.push(token);\n                }\n            } else if (lhsContext != Context.OTHER && token.equals(\"-\")) {\n                token = \"u-\";\n                stack.push(token);\n            } else {\n                result = new StringBuilder(\"Error: Invalid syntax\");\n                break;\n            }\n        } else if (isFunction(token)) {\n            stack.push(token);\n        } else if (token.equals(\",\")) {\n            while (!stack.empty() && !stack.peek().equals(\"(\")) {\n                result.append(stack.pop()).append(\" \");\n            }\n            if (stack.empty()) {\n                result = new StringBuilder(\"Error: Mismatched parentheses\");\n                break;\n            }\n        } else if (token.equals(\"(\")) {\n            if ((lhsContext == Context.NUM_OR_VAR || lhsContext == Context.CLOSED_PAREN || lhsContext == Context.INIT) && !isOperator(getToken(expression, i - 1))) {\n                stack.push(token);\n            } else {\n                result = new StringBuilder(\"Error: Invalid syntax\");\n                break;\n            }\n        } else if (token.equals(\")\")) {\n            if (lhsContext == Context.OTHER || lhsContext == Context.OPEN_PAREN) {\n                while (!stack.empty() && !stack.peek().equals(\"(\")) {\n                    result.append(stack.pop()).append(\" \");\n                }\n                if (stack.empty()) {\n                    result = new StringBuilder(\"Error: Mismatched parentheses\");\n                    break;\n                }\n                stack.pop();\n            } else {\n                result = new StringBuilder(\"Error: Invalid syntax\");\n                break;\n            }\n        } else if (isVariable(token)) {\n            if (lhsContext == Context.NUM_OR_VAR || lhsContext == Context.CLOSED_PAREN || lhsContext == Context.INIT) {\n                result.append(token).append(\" \");\n            } else {\n                result = new StringBuilder(\"Error: Invalid syntax\");\n                break;\n            }\n        } else {\n            result = new StringBuilder(\"Error: Invalid syntax\");\n            break;\n        }\n\n        lhsContext = rhsContext;\n    }\n\n    while (!stack.empty()) {\n        if (stack.peek().equals(\"(\")) {\n            result = new StringBuilder(\"Error: Mismatched parentheses\");\n            break;\n        }\n        result.append(stack.pop()).append(\" \");\n    }\n\n    if (result.toString().contains(\"Error\")) {\n        return result.toString();\n    } else {\n        return result.toString().trim();\n    }\n}\n\nprivate static Context getContext(String expression, int index) {\n    if (index == 0) {\n        return Context.INIT;\n    }\n    String prev = getToken(expression, index - 1);\n    if (isNumber(prev) || isVariable(prev) || prev.equals(\")\")) {\n        return Context.NUM_OR_VAR;\n    } else if (prev.equals(\"(\")) {\n        return Context.OPEN_PAREN;\n    } else {\n        Context rhsContext = Context.OTHER;\n        for (int i = index; i < expression.length(); i++) {\n            String next = getToken(expression, i);\n            if (isFunction(next)) {\n                rhsContext = Context.IN_FUN;\n            } else if (next.equals(\"(\")) {\n                rhsContext = Context.IN_ARG;\n            } else if (next.equals(\")\")) {\n                rhsContext = Context.OUT_ARG;\n                break;\n            }\n        }\n        return rhsContext;\n    }\n}\n\nprivate static String getToken(String expression, int index) {\n    String token;\n    char c = expression.charAt(index);\n    if (c == 'e' && index + 4 < expression.length() && expression.substring(index, index + 5).equals(\"exp()\")) {\n        token = \"exp\";\n    } else if (c == 'p' && index + 2 < expression.length() && expression.substring(index, index + 3).equals(\"pi\")) {\n        token = \"3.14159\";\n    } else {\n        token = Character.toString(c);\n    }\n    if (isDigit(c) || c == '.') {\n        int i = index + 1;\n        while (i < expression.length() && (isDigit(expression.charAt(i)) || expression.charAt(i) == '.')) {\n            token += expression.charAt(i);\n            i++;\n        }\n    } else if (isLetter(c)) {\n        int i = index + 1;\n        while (i < expression.length() && isVariable(Character.toString(expression.charAt(i)))) {\n            token += expression.charAt(i);\n            i++;\n        }\n    }\n    return token;\n}\n\nprivate static boolean isNumber(String token) {\n    return token.matches(\"^\\\\d+(\\\\.\\\\d+)?$\");\n}\n\nprivate static boolean isOperator(String token) {\n    return token.equals(\"+\") || token.equals(\"-\") || token.equals(\"*\") || token.equals(\"/\") || token.equals(\"^\");\n}\n\nprivate static boolean isFunction(String token) {\n    return token.equals(\"cos\") || token.equals(\"sin\") || token.equals(\"tan\") || token.equals(\"exp\") || token.equals(\"sqrt\");\n}\n\nprivate static boolean isVariable(String token) {\n    return token.matches(\"^[a-zA-Z_][a-zA-Z0-9_]*$\");\n}\n\npublic static double evaluatePostfix(String expression) {\n    try {\n        Stack<Double> stack = new Stack<>();\n        String[] tokens = expression.split(\" \");\n        for (String token : tokens) {\n            if (isNumber(token)) {\n                stack.push(Double.parseDouble(token));\n            } else if (isOperator(token)) {\n                double num2 = stack.pop();\n                double num1 = stack.pop();\n                if (token.equals(\"+\")) {\n                    stack.push(num1 + num2);\n                } else if (token.equals(\"-\")) {\n                    stack.push(num1 - num2);\n                } else if (token.equals(\"*\")) {\n                    stack.push(num1 * num2);\n                } else if (token.equals(\"/\")) {\n                    stack.push(num1 / num2);\n                } else {\n                    stack.push(Math.pow(num1, num2));\n                }\n            } else if (isFunction(token)) {\n                double num = stack.pop();\n                if (token.equals(\"cos\")) {\n                    stack.push(Math.cos(num));\n                } else if (token.equals(\"sin\")) {\n                    stack.push(Math.sin(num));\n                } else if (token.equals(\"tan\")) {\n                    stack.push(Math.tan(num));\n                } else if (token.equals(\"exp\")) {\n                    stack.push(Math.exp(num));\n                } else {\n                    stack.push(Math.sqrt(num));\n                }\n            }\n        }\n        return stack.pop();\n    } catch (Exception e) {\n        return Double.NaN;\n    }\n}\n\nprivate static int getPrecedence(String operator, Context context, Associativity associativity) {\n    if (context == Context.IN_ARG || context == Context.OUT_ARG) {\n        return 10;\n    } else if (context == Context.IN_FUN) {\n        if (operator.equals(\"^\")) {\n            return 9;\n        } else {\n            return 10;\n        }\n    }\n    switch (operator) {\n        case \"+\":\n        case \"-\":\n            return 1;\n        case \"*\":\n        case \"/\":\n            return 2;\n        case \"^\":\n            if (associativity == Context.LEFT) {\n                return 3;\n            } else {\n                return 4;\n            }\n        default:\n            return -1;\n    }\n}\n\nprivate enum Context {\n    INIT,\n    NUM_OR_VAR,\n    OPEN_PAREN,\n    CLOSE_PAREN,\n    IN_ARG,\n    OUT_ARG,\n    IN_FUN,\n    OTHER\n}\n",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 54eb5cf8..6267f6c9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -104,7 +104,7 @@ class CodeGenerator {\n     add(n, Context.OTHER);\n   }\n \n-  void add(Node n, Context context) {\n+\n     if (!cc.continueProcessing()) {\n       return;\n     }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}