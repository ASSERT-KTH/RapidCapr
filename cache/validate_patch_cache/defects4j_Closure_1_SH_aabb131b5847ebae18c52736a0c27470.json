{
    "patch": "    // Find all parameters that are not referenced.\n    List<Node> unreferencedParams = new ArrayList<>();\n    for (Node arg : argList.children()) {\n      if (arg.isName()) {\n        Var var = fnScope.getVar(arg.getString());\n        if (!referenced.contains(var)) {\n          unreferencedParams.add(arg);\n        }\n      }\n    }\n\n    if (unreferencedParams.isEmpty()) {\n      return;\n    }\n\n    // If we're removing parameters on a function with no body, create an empty one\n    // so we can add a CALL node that references it and not cause runtime errors.\n    Node newScript = null;\n    if (function.getLastChild() == null) {\n      newScript = IR.script();\n      Node block = IR.block();\n      newScript.addChildToBack(block);\n      function.addChildToBack(block);\n    }\n\n    // Remove all unreferenced parameters\n    for (Node param : unreferencedParams) {\n      argList.removeChild(param);\n      compiler.reportCodeChange();\n    }\n\n    // Create a new node representing the body of the function, so we can use it\n    // as a call node. This node should have no side effects, so we are wrapping\n    // it in a BLOCK node to prevent code motion of actual side effects.\n    Node newFunctionBody = IR.block();\n    for (Node n = function.getFirstChild(); n != null; n = n.getNext()) {\n      if (n != argList) {\n        newFunctionBody.addChildToBack(n.detach());\n      }\n    }\n\n    // Get rid of the function entirely if it's now empty,\n    // otherwise, use the edited AST.\n    boolean hasBody = newFunctionBody.hasChildren();\n    Node resultNode = hasBody ? newFunctionBody : IR.number(0);\n    NodeUtil.markFunctionsDeleted(resultNode, compiler);\n    if (newScript != null) {\n      NodeUtil.markFunctionsDeleted(newScript, compiler);\n    }\n\n    Node call;\n    if (modifyCallers) {\n      callSiteOptimizer.optimize(fnScope, referenced);\n      call = callSiteOptimizer.getOptimizedCallNode(function, resultNode);\n      if (call == null) {\n        // We still need a node to replace 'function' with when removing callers.\n        // Otherwise, we leave an undeleted function object in the AST.\n        call = IR.call(IR.name(\"fictitiousFunctionConstructor\"), resultNode);\n      }\n    } else {\n      call = IR.call(function.cloneTree(), resultNode);\n    }\n\n    function.getParent().replaceChild(function, call);\n    if (newScript != null) {\n      newScript.removeFirstChild();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..39ffc9e7 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,72 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    // Find all parameters that are not referenced.\n+    List<Node> unreferencedParams = new ArrayList<>();\n+    for (Node arg : argList.children()) {\n+      if (arg.isName()) {\n+        Var var = fnScope.getVar(arg.getString());\n+        if (!referenced.contains(var)) {\n+          unreferencedParams.add(arg);\n+        }\n+      }\n+    }\n+\n+    if (unreferencedParams.isEmpty()) {\n+      return;\n+    }\n+\n+    // If we're removing parameters on a function with no body, create an empty one\n+    // so we can add a CALL node that references it and not cause runtime errors.\n+    Node newScript = null;\n+    if (function.getLastChild() == null) {\n+      newScript = IR.script();\n+      Node block = IR.block();\n+      newScript.addChildToBack(block);\n+      function.addChildToBack(block);\n+    }\n+\n+    // Remove all unreferenced parameters\n+    for (Node param : unreferencedParams) {\n+      argList.removeChild(param);\n+      compiler.reportCodeChange();\n+    }\n+\n+    // Create a new node representing the body of the function, so we can use it\n+    // as a call node. This node should have no side effects, so we are wrapping\n+    // it in a BLOCK node to prevent code motion of actual side effects.\n+    Node newFunctionBody = IR.block();\n+    for (Node n = function.getFirstChild(); n != null; n = n.getNext()) {\n+      if (n != argList) {\n+        newFunctionBody.addChildToBack(n.detach());\n+      }\n+    }\n+\n+    // Get rid of the function entirely if it's now empty,\n+    // otherwise, use the edited AST.\n+    boolean hasBody = newFunctionBody.hasChildren();\n+    Node resultNode = hasBody ? newFunctionBody : IR.number(0);\n+    NodeUtil.markFunctionsDeleted(resultNode, compiler);\n+    if (newScript != null) {\n+      NodeUtil.markFunctionsDeleted(newScript, compiler);\n+    }\n+\n+    Node call;\n+    if (modifyCallers) {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+      call = callSiteOptimizer.getOptimizedCallNode(function, resultNode);\n+      if (call == null) {\n+        // We still need a node to replace 'function' with when removing callers.\n+        // Otherwise, we leave an undeleted function object in the AST.\n+        call = IR.call(IR.name(\"fictitiousFunctionConstructor\"), resultNode);\n+      }\n+    } else {\n+      call = IR.call(function.cloneTree(), resultNode);\n+    }\n+\n+    function.getParent().replaceChild(function, call);\n+    if (newScript != null) {\n+      newScript.removeFirstChild();\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}