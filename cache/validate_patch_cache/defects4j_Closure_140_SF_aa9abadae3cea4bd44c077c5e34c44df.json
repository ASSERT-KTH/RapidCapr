{
    "patch": "    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {\n      inputs = m.getInputs();\n      if (inputs.size() > 0) {\n        Node node = inputs.get(0).getAstRoot(this);\n        if (!getNodeForCodeChange(node)) {\n          return node;\n        }\n      }\n    }\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n  \n  private boolean getNodeForCodeChange(Node root) {\n    root.getInputId().setVersion(root.getInputId().getVersion() + 1);\n    boolean changed = false;\n    try {\n      JSErrorReporter oldReporter = getErrorReporter();\n      getJSModuleGraph().clearInliningPassNumber();\n      setErrorReporter(\n          (JSError error) -> {\n            if (oldReporter != null) {\n              oldReporter.recordError(error);\n            }\n            changed = true;\n          });\n      performChangeAnalysis();\n      if (changed) {\n        reportCodeChange();\n      }\n    } finally {\n      setErrorReporter(null);\n    }\n    return changed;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..6fe8e009 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,39 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n-\n-    checkFirstModule(modules);\n-\n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n+    for (JSModule m : getModuleGraph().getTransitiveDepsDeepestFirst(module)) {\n+      inputs = m.getInputs();\n+      if (inputs.size() > 0) {\n+        Node node = inputs.get(0).getAstRoot(this);\n+        if (!getNodeForCodeChange(node)) {\n+          return node;\n+        }\n+      }\n     }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n-\n-    initInputsByNameMap();\n+    throw new IllegalStateException(\"Root module has no inputs\");\n   }\n-\n-  /**\n-   * Do any initialization that is dependent on the compiler options.\n-   */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+  \n+  private boolean getNodeForCodeChange(Node root) {\n+    root.getInputId().setVersion(root.getInputId().getVersion() + 1);\n+    boolean changed = false;\n+    try {\n+      JSErrorReporter oldReporter = getErrorReporter();\n+      getJSModuleGraph().clearInliningPassNumber();\n+      setErrorReporter(\n+          (JSError error) -> {\n+            if (oldReporter != null) {\n+              oldReporter.recordError(error);\n+            }\n+            changed = true;\n+          });\n+      performChangeAnalysis();\n+      if (changed) {\n+        reportCodeChange();\n+      }\n+    } finally {\n+      setErrorReporter(null);\n     }\n-  }\n-\n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n+    return changed;\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}