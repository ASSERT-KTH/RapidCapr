{
    "patch": "// Don't traverse functions that are getting lent to a prototype or written to 'this'.\nboolean isAssignmentToThis = false;\nboolean isPrototypeAssignment = false;\n\nif (parent != null && parent.getType() == Token.ASSIGN) {\n  Node lhs = parent.getFirstChild();\n  if (lhs.getType() == Token.THIS) {\n    isAssignmentToThis = true;\n  } else if (NodeUtil.isGet(lhs)) {\n    if (lhs.getType() == Token.GETPROP &&\n        lhs.getLastChild().getString().equals(\"prototype\")) {\n      isPrototypeAssignment = true;\n    }\n    Node llhs = lhs.getFirstChild();\n    if (llhs.getType() == Token.GETPROP &&\n        llhs.getLastChild().getString().equals(\"prototype\")) {\n      isPrototypeAssignment = true;\n    }\n  }\n  if (isPrototypeAssignment && isAssignmentToThis) {\n    return false;\n  }\n}\n\nif (n.getParent().getType() == Token.GETPROP) {\n  if (n.getParent().getLastChild().getString().equals(\"prototype\")) {\n    return false;\n  }\n}\n\nif (NodeUtil.isPrototypeProperty(parent)) {\n  return false;\n}\n\nif (parent != null && parent.getType() == Token.ASSIGN) {\n  Node lhs = parent.getFirstChild();\n  Node rhs = lhs.getNext();\n\n  if (n == lhs) {\n    // Always traverse the left side of the assignment. To handle\n    // nested assignments properly (e.g., (a = this).property = c;),\n    // assignLhsChild should not be overridden.\n    if (assignLhsChild == null) {\n      assignLhsChild = lhs;\n    }\n  } else {\n    // Only traverse the right side if it's not a potentially dangerous assignment.\n    boolean isPotentiallyDangerous = false;\n    if (NodeUtil.isGet(lhs)) {\n      if (lhs.getType() == Token.GETPROP &&\n          lhs.getLastChild().getString().equals(\"prototype\")) {\n        isPotentiallyDangerous = true;\n      }\n      Node llhs = lhs.getFirstChild();\n      if (llhs.getType() == Token.GETPROP &&\n          llhs.getLastChild().getString().equals(\"prototype\")) {\n        isPotentiallyDangerous = true;\n      }\n    }\n    if (!isPotentiallyDangerous) {\n      return true;\n    }\n  }\n} else {\n  return true;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..c68f94b3 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,72 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+// Don't traverse functions that are getting lent to a prototype or written to 'this'.\n+boolean isAssignmentToThis = false;\n+boolean isPrototypeAssignment = false;\n+\n+if (parent != null && parent.getType() == Token.ASSIGN) {\n+  Node lhs = parent.getFirstChild();\n+  if (lhs.getType() == Token.THIS) {\n+    isAssignmentToThis = true;\n+  } else if (NodeUtil.isGet(lhs)) {\n+    if (lhs.getType() == Token.GETPROP &&\n+        lhs.getLastChild().getString().equals(\"prototype\")) {\n+      isPrototypeAssignment = true;\n+    }\n+    Node llhs = lhs.getFirstChild();\n+    if (llhs.getType() == Token.GETPROP &&\n+        llhs.getLastChild().getString().equals(\"prototype\")) {\n+      isPrototypeAssignment = true;\n+    }\n+  }\n+  if (isPrototypeAssignment && isAssignmentToThis) {\n+    return false;\n+  }\n+}\n+\n+if (n.getParent().getType() == Token.GETPROP) {\n+  if (n.getParent().getLastChild().getString().equals(\"prototype\")) {\n+    return false;\n+  }\n+}\n+\n+if (NodeUtil.isPrototypeProperty(parent)) {\n+  return false;\n+}\n+\n+if (parent != null && parent.getType() == Token.ASSIGN) {\n+  Node lhs = parent.getFirstChild();\n+  Node rhs = lhs.getNext();\n+\n+  if (n == lhs) {\n+    // Always traverse the left side of the assignment. To handle\n+    // nested assignments properly (e.g., (a = this).property = c;),\n+    // assignLhsChild should not be overridden.\n+    if (assignLhsChild == null) {\n+      assignLhsChild = lhs;\n+    }\n+  } else {\n+    // Only traverse the right side if it's not a potentially dangerous assignment.\n+    boolean isPotentiallyDangerous = false;\n+    if (NodeUtil.isGet(lhs)) {\n+      if (lhs.getType() == Token.GETPROP &&\n+          lhs.getLastChild().getString().equals(\"prototype\")) {\n+        isPotentiallyDangerous = true;\n+      }\n+      Node llhs = lhs.getFirstChild();\n+      if (llhs.getType() == Token.GETPROP &&\n+          llhs.getLastChild().getString().equals(\"prototype\")) {\n+        isPotentiallyDangerous = true;\n+      }\n+    }\n+    if (!isPotentiallyDangerous) {\n+      return true;\n+    }\n+  }\n+} else {\n+  return true;\n+}\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "junit.framework.AssertionFailedError: Unexpected error(s): JSC_USED_GLOBAL_THIS. dangerous use of the global this object at testcode line 1 : 110 expected:<0> but was:<1>",
    "test_result": "FAIL"
}