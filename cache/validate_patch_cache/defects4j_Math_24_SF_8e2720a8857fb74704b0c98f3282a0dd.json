{
    "patch": "protected UnivariatePointValuePair doOptimize() {\n    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n    final double lo = getMin();\n    final double mid = getStartValue();\n    final double hi = getMax();\n\n    // Optional additional convergence criteria.\n    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n\n    double a, b, d, e, v, w, x, fx, fv, fw;\n    a = b = d = e = v = w = x = fx = fv = fw = Double.NaN;\n\n    x = mid;\n    v = x;\n    w = x;\n    d = 0;\n    e = 0;\n\n    final double fxInit = computeObjectiveValue(x);\n    if (!isMinim) {\n        fxInit = -fxInit;\n    }\n    fx = fxInit;\n    fv = fxInit;\n    fw = fxInit;\n\n    final UnivariatePointValuePair previous = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n    UnivariatePointValuePair current = previous;\n\n    double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n    double tol2 = 2 * tol1;\n\n    while (true) {\n        final double m = 0.5 * (lo + hi);\n        final double tolCurrent = 2 * tol2;\n        boolean isBounded = false;\n\n        final boolean isEqualTol = FastMath.abs(x - m) <= (tolCurrent - 0.5 * (hi - lo));\n        if (!isEqualTol && (FastMath.abs(e) > tol1)) {\n            final double r = (x - w) * (fx - fv);\n            final double q = (x - v) * (fx - fw);\n            final double p = (x - v) * q - (x - w) * r;\n            q.mul(2);\n\n            if (q > 0) {\n                p.negate();\n            } else {\n                q.negate();\n            }\n\n            final double etemp = e;\n\n            e = d;\n\n            boolean isWithinBounds = false;\n\n            if ((FastMath.abs(p) >= FastMath.abs(0.5 * q * etemp)) || (p <= (q * (lo - x))) || (p >= (q * (hi - x)))) {\n                d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n            } else {\n                d = p / q;\n                u = x + d;\n\n                if ((((u - lo) < tolCurrent) || ((hi - u) < tolCurrent))) {\n                    if (x <= m) {\n                        d = tol1;\n                    } else {\n                        d = -tol1;\n                    }\n                    isWithinBounds = true;\n                }\n            }\n\n            if (!isWithinBounds) {\n                isBounded = (lo < u) && (u < hi);\n\n                if ((p * p) >= (q * p * tol1.abs())) {\n                    d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n                } else {\n                    d = p / q;\n                    isBounded = (lo < (u = x + d)) && (u < hi);\n\n                    if (!isBounded) {\n                        d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n                    }\n                }\n            }\n        } else {\n            d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n        }\n\n        if (FastMath.abs(d) >= tol1) {\n            u = x + d;\n        } else if (d > 0) {\n            u = x + tol1;\n        } else {\n            u = x - tol1;\n        }\n\n        final double fu = computeObjectiveValue(u);\n        if (!isMinim) {\n            fv = -fv;\n        }\n\n        if (checker != null) {\n            if (checker.converged(iter, current, previous)) {\n                return current;\n            }\n        }\n\n        if (fu <= fx) {\n            if (u < x) {\n                hi = x;\n            } else {\n                lo = x;\n            }\n\n            v = w;\n            fv = fw;\n            w = x;\n            fw = fx;\n            x = u;\n\n            final boolean isBest = (fu <= fx) ? u : x;\n            current = new UnivariatePointValuePair(isBest, isMinim ? fu : -fu);\n\n            previous = current;\n            fx = fu;\n        } else {\n            if (u < x) {\n                lo = u;\n            } else {\n                hi = u;\n            }\n\n            if ((fu <= fw) || (w == x)) {\n                v = w;\n                fv = fw;\n                w = u;\n                fw = fu;\n            } else if ((fu < fv) || (v == x) || (v == w)) {\n                v = u;\n                fv = fu;\n            }\n        }\n\n        if (hi - lo <= (tol2 * FastMath.max(x.abs(), 1))) {\n            return current;\n        }\n\n        iter++;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\nindex b6ce68ef3..6f256f480 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/univariate/BrentOptimizer.java\n@@ -106,169 +106,158 @@ public class BrentOptimizer extends BaseAbstractUnivariateOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected UnivariatePointValuePair doOptimize() {\n-        final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n-        final double lo = getMin();\n-        final double mid = getStartValue();\n-        final double hi = getMax();\n-\n-        // Optional additional convergence criteria.\n-        final ConvergenceChecker<UnivariatePointValuePair> checker\n-            = getConvergenceChecker();\n-\n-        double a;\n-        double b;\n-        if (lo < hi) {\n-            a = lo;\n-            b = hi;\n-        } else {\n-            a = hi;\n-            b = lo;\n-        }\n+protected UnivariatePointValuePair doOptimize() {\n+    final boolean isMinim = getGoalType() == GoalType.MINIMIZE;\n+    final double lo = getMin();\n+    final double mid = getStartValue();\n+    final double hi = getMax();\n \n-        double x = mid;\n-        double v = x;\n-        double w = x;\n-        double d = 0;\n-        double e = 0;\n-        double fx = computeObjectiveValue(x);\n-        if (!isMinim) {\n-            fx = -fx;\n-        }\n-        double fv = fx;\n-        double fw = fx;\n-\n-        UnivariatePointValuePair previous = null;\n-        UnivariatePointValuePair current\n-            = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n-\n-        int iter = 0;\n-        while (true) {\n-            final double m = 0.5 * (a + b);\n-            final double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n-            final double tol2 = 2 * tol1;\n-\n-            // Default stopping criterion.\n-            final boolean stop = FastMath.abs(x - m) <= tol2 - 0.5 * (b - a);\n-            if (!stop) {\n-                double p = 0;\n-                double q = 0;\n-                double r = 0;\n-                double u = 0;\n-\n-                if (FastMath.abs(e) > tol1) { // Fit parabola.\n-                    r = (x - w) * (fx - fv);\n-                    q = (x - v) * (fx - fw);\n-                    p = (x - v) * q - (x - w) * r;\n-                    q = 2 * (q - r);\n-\n-                    if (q > 0) {\n-                        p = -p;\n-                    } else {\n-                        q = -q;\n-                    }\n+    // Optional additional convergence criteria.\n+    final ConvergenceChecker<UnivariatePointValuePair> checker = getConvergenceChecker();\n \n-                    r = e;\n-                    e = d;\n-\n-                    if (p > q * (a - x) &&\n-                        p < q * (b - x) &&\n-                        FastMath.abs(p) < FastMath.abs(0.5 * q * r)) {\n-                        // Parabolic interpolation step.\n-                        d = p / q;\n-                        u = x + d;\n-\n-                        // f must not be evaluated too close to a or b.\n-                        if (u - a < tol2 || b - u < tol2) {\n-                            if (x <= m) {\n-                                d = tol1;\n-                            } else {\n-                                d = -tol1;\n-                            }\n-                        }\n-                    } else {\n-                        // Golden section step.\n-                        if (x < m) {\n-                            e = b - x;\n-                        } else {\n-                            e = a - x;\n-                        }\n-                        d = GOLDEN_SECTION * e;\n-                    }\n-                } else {\n-                    // Golden section step.\n-                    if (x < m) {\n-                        e = b - x;\n-                    } else {\n-                        e = a - x;\n-                    }\n-                    d = GOLDEN_SECTION * e;\n-                }\n+    double a, b, d, e, v, w, x, fx, fv, fw;\n+    a = b = d = e = v = w = x = fx = fv = fw = Double.NaN;\n \n-                // Update by at least \"tol1\".\n-                if (FastMath.abs(d) < tol1) {\n-                    if (d >= 0) {\n-                        u = x + tol1;\n-                    } else {\n-                        u = x - tol1;\n-                    }\n-                } else {\n-                    u = x + d;\n-                }\n+    x = mid;\n+    v = x;\n+    w = x;\n+    d = 0;\n+    e = 0;\n \n-                double fu = computeObjectiveValue(u);\n-                if (!isMinim) {\n-                    fu = -fu;\n-                }\n+    final double fxInit = computeObjectiveValue(x);\n+    if (!isMinim) {\n+        fxInit = -fxInit;\n+    }\n+    fx = fxInit;\n+    fv = fxInit;\n+    fw = fxInit;\n \n-                // User-defined convergence checker.\n-                previous = current;\n-                current = new UnivariatePointValuePair(u, isMinim ? fu : -fu);\n+    final UnivariatePointValuePair previous = new UnivariatePointValuePair(x, isMinim ? fx : -fx);\n+    UnivariatePointValuePair current = previous;\n \n-                if (checker != null) {\n-                    if (checker.converged(iter, previous, current)) {\n-                        return current;\n-                    }\n-                }\n+    double tol1 = relativeThreshold * FastMath.abs(x) + absoluteThreshold;\n+    double tol2 = 2 * tol1;\n+\n+    while (true) {\n+        final double m = 0.5 * (lo + hi);\n+        final double tolCurrent = 2 * tol2;\n+        boolean isBounded = false;\n \n-                // Update a, b, v, w and x.\n-                if (fu <= fx) {\n-                    if (u < x) {\n-                        b = x;\n+        final boolean isEqualTol = FastMath.abs(x - m) <= (tolCurrent - 0.5 * (hi - lo));\n+        if (!isEqualTol && (FastMath.abs(e) > tol1)) {\n+            final double r = (x - w) * (fx - fv);\n+            final double q = (x - v) * (fx - fw);\n+            final double p = (x - v) * q - (x - w) * r;\n+            q.mul(2);\n+\n+            if (q > 0) {\n+                p.negate();\n+            } else {\n+                q.negate();\n+            }\n+\n+            final double etemp = e;\n+\n+            e = d;\n+\n+            boolean isWithinBounds = false;\n+\n+            if ((FastMath.abs(p) >= FastMath.abs(0.5 * q * etemp)) || (p <= (q * (lo - x))) || (p >= (q * (hi - x)))) {\n+                d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n+            } else {\n+                d = p / q;\n+                u = x + d;\n+\n+                if ((((u - lo) < tolCurrent) || ((hi - u) < tolCurrent))) {\n+                    if (x <= m) {\n+                        d = tol1;\n                     } else {\n-                        a = x;\n+                        d = -tol1;\n                     }\n-                    v = w;\n-                    fv = fw;\n-                    w = x;\n-                    fw = fx;\n-                    x = u;\n-                    fx = fu;\n+                    isWithinBounds = true;\n+                }\n+            }\n+\n+            if (!isWithinBounds) {\n+                isBounded = (lo < u) && (u < hi);\n+\n+                if ((p * p) >= (q * p * tol1.abs())) {\n+                    d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n                 } else {\n-                    if (u < x) {\n-                        a = u;\n-                    } else {\n-                        b = u;\n-                    }\n-                    if (fu <= fw ||\n-                        Precision.equals(w, x)) {\n-                        v = w;\n-                        fv = fw;\n-                        w = u;\n-                        fw = fu;\n-                    } else if (fu <= fv ||\n-                               Precision.equals(v, x) ||\n-                               Precision.equals(v, w)) {\n-                        v = u;\n-                        fv = fu;\n+                    d = p / q;\n+                    isBounded = (lo < (u = x + d)) && (u < hi);\n+\n+                    if (!isBounded) {\n+                        d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n                     }\n                 }\n-            } else { // Default termination (Brent's criterion).\n+            }\n+        } else {\n+            d = GOLDEN_SECTION * (e = ((x < m) ? hi - x : lo - x));\n+        }\n+\n+        if (FastMath.abs(d) >= tol1) {\n+            u = x + d;\n+        } else if (d > 0) {\n+            u = x + tol1;\n+        } else {\n+            u = x - tol1;\n+        }\n+\n+        final double fu = computeObjectiveValue(u);\n+        if (!isMinim) {\n+            fv = -fv;\n+        }\n+\n+        if (checker != null) {\n+            if (checker.converged(iter, current, previous)) {\n                 return current;\n             }\n-            ++iter;\n         }\n+\n+        if (fu <= fx) {\n+            if (u < x) {\n+                hi = x;\n+            } else {\n+                lo = x;\n+            }\n+\n+            v = w;\n+            fv = fw;\n+            w = x;\n+            fw = fx;\n+            x = u;\n+\n+            final boolean isBest = (fu <= fx) ? u : x;\n+            current = new UnivariatePointValuePair(isBest, isMinim ? fu : -fu);\n+\n+            previous = current;\n+            fx = fu;\n+        } else {\n+            if (u < x) {\n+                lo = u;\n+            } else {\n+                hi = u;\n+            }\n+\n+            if ((fu <= fw) || (w == x)) {\n+                v = w;\n+                fv = fw;\n+                w = u;\n+                fw = fu;\n+            } else if ((fu < fv) || (v == x) || (v == w)) {\n+                v = u;\n+                fv = fu;\n+            }\n+        }\n+\n+        if (hi - lo <= (tol2 * FastMath.max(x.abs(), 1))) {\n+            return current;\n+        }\n+\n+        iter++;\n     }\n+}\n \n     /**\n      * Selects the best of two points.",
    "result_reason": "error: cannot assign a value to final variable fxInit",
    "test_result": "ERROR"
}