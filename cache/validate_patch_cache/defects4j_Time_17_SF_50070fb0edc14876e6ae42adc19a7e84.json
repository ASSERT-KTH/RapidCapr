{
    "patch": "        long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n        \n        int cmp = compare(instantBefore, instantAfter);\n        if (cmp == 0) {\n            // not an overlap (less than is a gap, equal is normal case)\n            return instant;\n        }\n        \n        // work out range of instants that have duplicate local times\n        long local = convertUTCToLocal(instant);\n        long end = (cmp < 0 ? instantAfter : instantBefore);\n        long aligned = getPreviousTransition(local, end);\n        if (aligned == local) {\n            aligned = getNextTransition(local, end);\n        }\n        \n        // calculate result\n        boolean invert = (cmp < 0 ? !earlierOrLater : earlierOrLater);\n        return convertLocalToUTC(aligned, invert, instant);\n    }\n    \n    private int compare(long instant1, long instant2) {\n        if (instant1 < instant2) {\n            return -1;\n        } else if (instant1 > instant2) {\n            return 1;\n        } else {\n            return 0;\n        }\n    }\n    \n    private long getPreviousTransition(long localInstant, long end) {\n        long nextTransition = getZone().previousTransition(localInstant);\n        return (nextTransition > end ? localInstant : nextTransition);\n    }\n    \n    private long getNextTransition(long localInstant, long end) {\n        long nextTransition = getZone().nextTransition(localInstant);\n        return (nextTransition <= end ? nextTransition : localInstant);",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex 74a3802a..d822eeab 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -1160,24 +1160,46 @@ public abstract class DateTimeZone implements Serializable {\n      * @param earlierOrLater  false for earlier, true for later\n      * @return the adjusted instant millis\n      */\n-    public long adjustOffset(long instant, boolean earlierOrLater) {\n-        // a bit messy, but will work in all non-pathological cases\n-        \n-        // evaluate 3 hours before and after to work out if anything is happening\n         long instantBefore = convertUTCToLocal(instant - 3 * DateTimeConstants.MILLIS_PER_HOUR);\n         long instantAfter = convertUTCToLocal(instant + 3 * DateTimeConstants.MILLIS_PER_HOUR);\n-        if (instantBefore == instantAfter) {\n-            return instant;  // not an overlap (less than is a gap, equal is normal case)\n+        \n+        int cmp = compare(instantBefore, instantAfter);\n+        if (cmp == 0) {\n+            // not an overlap (less than is a gap, equal is normal case)\n+            return instant;\n         }\n         \n         // work out range of instants that have duplicate local times\n         long local = convertUTCToLocal(instant);\n-        return convertLocalToUTC(local, false, earlierOrLater ? instantAfter : instantBefore);\n+        long end = (cmp < 0 ? instantAfter : instantBefore);\n+        long aligned = getPreviousTransition(local, end);\n+        if (aligned == local) {\n+            aligned = getNextTransition(local, end);\n+        }\n         \n         // calculate result\n-          // currently in later offset\n-          // currently in earlier offset\n+        boolean invert = (cmp < 0 ? !earlierOrLater : earlierOrLater);\n+        return convertLocalToUTC(aligned, invert, instant);\n+    }\n+    \n+    private int compare(long instant1, long instant2) {\n+        if (instant1 < instant2) {\n+            return -1;\n+        } else if (instant1 > instant2) {\n+            return 1;\n+        } else {\n+            return 0;\n+        }\n     }\n+    \n+    private long getPreviousTransition(long localInstant, long end) {\n+        long nextTransition = getZone().previousTransition(localInstant);\n+        return (nextTransition > end ? localInstant : nextTransition);\n+    }\n+    \n+    private long getNextTransition(long localInstant, long end) {\n+        long nextTransition = getZone().nextTransition(localInstant);\n+        return (nextTransition <= end ? nextTransition : localInstant);\n //    System.out.println(new DateTime(transitionStart, DateTimeZone.UTC) + \" \" + new DateTime(transitionStart, this));\n \n     //-----------------------------------------------------------------------",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}