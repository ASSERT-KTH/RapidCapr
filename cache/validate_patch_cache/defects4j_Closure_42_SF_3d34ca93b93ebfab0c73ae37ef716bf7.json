{
    "patch": "public class IRFactory {\n    // other methods...\n    \n    private abstract class TransformDispatcher implements TypeSafeDispatcher {\n        @Override\n        public Node dispatch(AstNode node) {\n            switch (node.getType()) {\n                case Token.ARRAYLIT:\n                    return processArrayLiteral((ArrayLiteral) node);\n                case Token.OBJECTLIT:\n                    return processObjectLiteral((ObjectLiteral) node);\n                case Token.NAME:\n                    return processName((Name) node);\n                case Token.STRING:\n                    return processString((StringLiteral) node);\n                case Token.NUMBER:\n                    return processNumber((NumberLiteral) node);\n                case Token.REGEXP:\n                    return processRegExp((RegExpLiteral) node);\n                case Token.TRUE:\n                case Token.FALSE:\n                    return processBoolean((BooleanLiteral) node);\n                case Token.NULL:\n                    return processNull((NullLiteral) node);\n                case Token.THIS:\n                    return processThis((ThisLiteral) node);\n                case Token.TRY:\n                    return processTry((TryStatement) node);\n                case Token.TYPEOF:\n                    return processTypeOf((UnaryExpression) node);\n                case Token.POS:\n                    return processUnaryPlus((UnaryExpression) node);\n                case Token.NEG:\n                    return processUnaryMinus((UnaryExpression) node);\n                case Token.NOT:\n                    return processUnaryNot((UnaryExpression) node);\n                case Token.BITNOT:\n                    return processBitNot((UnaryExpression) node);\n                case Token.EXPR_RESULT:\n                    return processExpressionStatement((ExpressionStatement) node);\n                default:\n                    throw new RuntimeException(\"Not implemented yet: \" + node);\n            }\n        }\n        \n        protected Node processArrayLiteral(ArrayLiteral node) {\n            Node array = newArrayLiteral(null, node.getElements().size());\n            for (AstNode element : node.getElements()) {\n                array.addChildToBack(transform(element));\n            }\n            return array;\n        }\n\n        protected Node processObjectLiteral(ObjectLiteral node) {\n            Node object = newObjectLiteral();\n            for (ObjectProperty property : node.getElements()) {\n                Node value = property.isGetter() || property.isSetter()\n                             ? transformFunction(property)\n                             : transform(property.getRight());\n                object.addChildToBack(newProperty(\n                    transform(property.getLeft()), value));\n            }\n            return object;\n        }\n\n        protected Node processName(Name node) {\n            // Since we're only processing statements, we don't really\n            // care about non-local names\n            return newName(node.getIdentifier());\n        }\n\n        protected Node processString(StringLiteral node) {\n            return newString(node.getValue());\n        }\n\n        protected Node processNumber(NumberLiteral node) {\n            return newNumber(node.getValue());\n        }\n\n        protected Node processRegExp(RegExpLiteral node) {\n            // We don't really support RegExp literals, so we'll\n            // just return a string literal\n            return newString(node.getValue());\n        }\n\n        protected Node processBoolean(BooleanLiteral node) {\n            return newBoolean(node.getValue());\n        }\n\n        protected Node processNull(NullLiteral node) {\n            return newKeyword(Token.NULL);\n        }\n\n        protected Node processThis(ThisLiteral node) {\n            return newKeyword(Token.THIS);\n        }\n\n        protected Node processTry(TryStatement node) {\n            Node body = transform(node.getTryBlock());\n            Node finallyBlock = null;\n            if (node.getFinallyBlock() != null) {\n                finallyBlock = transform(node.getFinallyBlock());\n            }\n            List<CatchClause> catchClauses = node.getCatchClauses();\n            if (!catchClauses.isEmpty()) {\n                // Transform the last catch clause first, then add the previous one as an enclosing scope\n                CatchClause lastClause = catchClauses.get(catchClauses.size() - 1);\n                Node catchRoot = transform(lastClause);\n                for (int i = catchClauses.size() - 2; i >= 0; i--) {\n                    CatchClause catchClause = catchClauses.get(i);\n                    Node innerCatchRoot = transform(catchClause);\n                    innerCatchRoot.setLineno(catchRoot.getLineno());\n                    innerCatchRoot.setCharno(catchRoot.getCharno());\n                    catchRoot.addChildToFront(innerCatchRoot);\n                    lastClause = catchClause;\n                }\n                // Set the enclosing try block as the parent of the first catch root\n                catchRoot.setParent(body);\n                body.addChildToFront(catchRoot);\n            }\n            Node tryStatement = newNode(Token.TRY, body);\n            if (!catchClauses.isEmpty()) {\n                tryStatement.addChildToBack(new Node(Token.BLOCK));\n            }\n            if (finallyBlock != null) {\n                tryStatement.addChildToBack(new Node(Token.BLOCK, finallyBlock));\n            }\n            return tryStatement;\n        }\n\n        protected Node processTypeOf(UnaryExpression node) {\n            Node operandNode = transform(node.getOperand());\n            return createUnary(Token.TYPEOF, operandNode);\n        }\n\n        protected Node processUnaryPlus(UnaryExpression node) {\n            Node operandNode = transform(node.getOperand());\n            return createUnary(Token.POS, operandNode);\n        }\n\n        protected Node processUnaryMinus(UnaryExpression node) {\n            Node operandNode = transform(node.getOperand());\n            return createUnary(Token.NEG, operandNode);\n        }\n\n        protected Node processUnaryNot(UnaryExpression node) {\n            Node operandNode = transform(node.getOperand());\n            return createUnary(Token.NOT, operandNode);\n        }\n\n        protected Node processBitNot(UnaryExpression node) {\n            Node operandNode = transform(node.getOperand());\n            return createUnary(Token.BITNOT, operandNode);\n        }\n\n        protected abstract Node processExpressionStatement(ExpressionStatement statementNode);\n    }\n\n    // other methods...\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..a24ba6fd 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,167 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory {\n+    // other methods...\n+    \n+    private abstract class TransformDispatcher implements TypeSafeDispatcher {\n+        @Override\n+        public Node dispatch(AstNode node) {\n+            switch (node.getType()) {\n+                case Token.ARRAYLIT:\n+                    return processArrayLiteral((ArrayLiteral) node);\n+                case Token.OBJECTLIT:\n+                    return processObjectLiteral((ObjectLiteral) node);\n+                case Token.NAME:\n+                    return processName((Name) node);\n+                case Token.STRING:\n+                    return processString((StringLiteral) node);\n+                case Token.NUMBER:\n+                    return processNumber((NumberLiteral) node);\n+                case Token.REGEXP:\n+                    return processRegExp((RegExpLiteral) node);\n+                case Token.TRUE:\n+                case Token.FALSE:\n+                    return processBoolean((BooleanLiteral) node);\n+                case Token.NULL:\n+                    return processNull((NullLiteral) node);\n+                case Token.THIS:\n+                    return processThis((ThisLiteral) node);\n+                case Token.TRY:\n+                    return processTry((TryStatement) node);\n+                case Token.TYPEOF:\n+                    return processTypeOf((UnaryExpression) node);\n+                case Token.POS:\n+                    return processUnaryPlus((UnaryExpression) node);\n+                case Token.NEG:\n+                    return processUnaryMinus((UnaryExpression) node);\n+                case Token.NOT:\n+                    return processUnaryNot((UnaryExpression) node);\n+                case Token.BITNOT:\n+                    return processBitNot((UnaryExpression) node);\n+                case Token.EXPR_RESULT:\n+                    return processExpressionStatement((ExpressionStatement) node);\n+                default:\n+                    throw new RuntimeException(\"Not implemented yet: \" + node);\n+            }\n+        }\n+        \n+        protected Node processArrayLiteral(ArrayLiteral node) {\n+            Node array = newArrayLiteral(null, node.getElements().size());\n+            for (AstNode element : node.getElements()) {\n+                array.addChildToBack(transform(element));\n+            }\n+            return array;\n+        }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+        protected Node processObjectLiteral(ObjectLiteral node) {\n+            Node object = newObjectLiteral();\n+            for (ObjectProperty property : node.getElements()) {\n+                Node value = property.isGetter() || property.isSetter()\n+                             ? transformFunction(property)\n+                             : transform(property.getRight());\n+                object.addChildToBack(newProperty(\n+                    transform(property.getLeft()), value));\n+            }\n+            return object;\n+        }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+        protected Node processName(Name node) {\n+            // Since we're only processing statements, we don't really\n+            // care about non-local names\n+            return newName(node.getIdentifier());\n+        }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+        protected Node processString(StringLiteral node) {\n+            return newString(node.getValue());\n+        }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n+        protected Node processNumber(NumberLiteral node) {\n+            return newNumber(node.getValue());\n+        }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+        protected Node processRegExp(RegExpLiteral node) {\n+            // We don't really support RegExp literals, so we'll\n+            // just return a string literal\n+            return newString(node.getValue());\n+        }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+        protected Node processBoolean(BooleanLiteral node) {\n+            return newBoolean(node.getValue());\n+        }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+        protected Node processNull(NullLiteral node) {\n+            return newKeyword(Token.NULL);\n+        }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n+        protected Node processThis(ThisLiteral node) {\n+            return newKeyword(Token.THIS);\n+        }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+        protected Node processTry(TryStatement node) {\n+            Node body = transform(node.getTryBlock());\n+            Node finallyBlock = null;\n+            if (node.getFinallyBlock() != null) {\n+                finallyBlock = transform(node.getFinallyBlock());\n+            }\n+            List<CatchClause> catchClauses = node.getCatchClauses();\n+            if (!catchClauses.isEmpty()) {\n+                // Transform the last catch clause first, then add the previous one as an enclosing scope\n+                CatchClause lastClause = catchClauses.get(catchClauses.size() - 1);\n+                Node catchRoot = transform(lastClause);\n+                for (int i = catchClauses.size() - 2; i >= 0; i--) {\n+                    CatchClause catchClause = catchClauses.get(i);\n+                    Node innerCatchRoot = transform(catchClause);\n+                    innerCatchRoot.setLineno(catchRoot.getLineno());\n+                    innerCatchRoot.setCharno(catchRoot.getCharno());\n+                    catchRoot.addChildToFront(innerCatchRoot);\n+                    lastClause = catchClause;\n+                }\n+                // Set the enclosing try block as the parent of the first catch root\n+                catchRoot.setParent(body);\n+                body.addChildToFront(catchRoot);\n+            }\n+            Node tryStatement = newNode(Token.TRY, body);\n+            if (!catchClauses.isEmpty()) {\n+                tryStatement.addChildToBack(new Node(Token.BLOCK));\n+            }\n+            if (finallyBlock != null) {\n+                tryStatement.addChildToBack(new Node(Token.BLOCK, finallyBlock));\n+            }\n+            return tryStatement;\n+        }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n-    }\n+        protected Node processTypeOf(UnaryExpression node) {\n+            Node operandNode = transform(node.getOperand());\n+            return createUnary(Token.TYPEOF, operandNode);\n+        }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+        protected Node processUnaryPlus(UnaryExpression node) {\n+            Node operandNode = transform(node.getOperand());\n+            return createUnary(Token.POS, operandNode);\n+        }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+        protected Node processUnaryMinus(UnaryExpression node) {\n+            Node operandNode = transform(node.getOperand());\n+            return createUnary(Token.NEG, operandNode);\n+        }\n+\n+        protected Node processUnaryNot(UnaryExpression node) {\n+            Node operandNode = transform(node.getOperand());\n+            return createUnary(Token.NOT, operandNode);\n+        }\n+\n+        protected Node processBitNot(UnaryExpression node) {\n+            Node operandNode = transform(node.getOperand());\n+            return createUnary(Token.BITNOT, operandNode);\n+        }\n+\n+        protected abstract Node processExpressionStatement(ExpressionStatement statementNode);\n     }\n \n+    // other methods...\n+}\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: class IRFactory is already defined in package com.google.javascript.jscomp.parsing",
    "test_result": "ERROR"
}