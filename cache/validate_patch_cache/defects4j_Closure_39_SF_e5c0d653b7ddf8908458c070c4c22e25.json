{
    "patch": "  private boolean isCyclic(ObjectType current, ObjectType parent) {\n    if (current.equals(parent)) {\n      return true;\n    }\n    ObjectType prototype = current.getImplicitPrototype();\n    while (prototype != null) {\n      if (prototype.equals(current)) {\n        // if there is a cycle in the prototype chain, return true\n        return true;\n      }\n      prototype = prototype.getImplicitPrototype();\n    }\n    return false;\n  }\n\n  private String formatOutput(StringBuilder sb, int i, String property, Type propertyType) {\n    if (i > 0) {\n      sb.append(\", \");\n    }\n\n    sb.append(property);\n    sb.append(\": \");\n\n    if (propertyType instanceof ObjectType) {\n      ObjectType objectType = (ObjectType) propertyType;\n      if (isCyclic(objectType, this)) {\n        sb.append(\"{...}\");\n      } else {\n        sb.append(objectType.toStringHelper(false));\n      }\n    } else {\n      sb.append(propertyType.toString());\n    }\n\n    return sb.toString();\n  }\n\n  @Override\n  String toStringHelper(boolean forAnnotations) {\n    if (hasReferenceName()) {\n      return getReferenceName();\n    } else if (prettyPrint) {\n      // Don't pretty print recursively.\n      prettyPrint = false;\n\n      // Use a tree set so that the properties are sorted.\n      Set<String> propertyNames = Sets.newTreeSet();\n      for (ObjectType current = this;\n           current != null && !current.isNativeObjectType() &&\n               propertyNames.size() <= MAX_PRETTY_PRINTED_PROPERTIES;\n           current = current.getImplicitPrototype()) {\n        propertyNames.addAll(current.getOwnPropertyNames());\n      }\n\n      StringBuilder sb = new StringBuilder();\n      sb.append(\"{\");\n\n      int i = 0;\n      for (String property : propertyNames) {\n        Type propertyType = getPropertyType(property);\n\n        if (i < MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb = new StringBuilder(formatOutput(sb, i, property, propertyType));\n        } else if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n          sb.append(\", ...\");\n          sb = new StringBuilder(formatOutput(sb, i, property, propertyType));\n        }\n\n        i++;\n      }\n\n      sb.append(\"}\");\n\n      prettyPrint = true;\n      return sb.toString();\n    } else {\n      return \"{...}\";\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex dffe3a54..54226549 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -345,8 +345,41 @@ class PrototypeObjectType extends ObjectType {\n   }\n \n   @Override\n-  public boolean canBeCalled() {\n-    return isRegexpType();\n+  private boolean isCyclic(ObjectType current, ObjectType parent) {\n+    if (current.equals(parent)) {\n+      return true;\n+    }\n+    ObjectType prototype = current.getImplicitPrototype();\n+    while (prototype != null) {\n+      if (prototype.equals(current)) {\n+        // if there is a cycle in the prototype chain, return true\n+        return true;\n+      }\n+      prototype = prototype.getImplicitPrototype();\n+    }\n+    return false;\n+  }\n+\n+  private String formatOutput(StringBuilder sb, int i, String property, Type propertyType) {\n+    if (i > 0) {\n+      sb.append(\", \");\n+    }\n+\n+    sb.append(property);\n+    sb.append(\": \");\n+\n+    if (propertyType instanceof ObjectType) {\n+      ObjectType objectType = (ObjectType) propertyType;\n+      if (isCyclic(objectType, this)) {\n+        sb.append(\"{...}\");\n+      } else {\n+        sb.append(objectType.toStringHelper(false));\n+      }\n+    } else {\n+      sb.append(propertyType.toString());\n+    }\n+\n+    return sb.toString();\n   }\n \n   @Override\n@@ -371,19 +404,16 @@ class PrototypeObjectType extends ObjectType {\n \n       int i = 0;\n       for (String property : propertyNames) {\n-        if (i > 0) {\n-          sb.append(\", \");\n-        }\n+        Type propertyType = getPropertyType(property);\n \n-        sb.append(property);\n-        sb.append(\": \");\n-        sb.append(getPropertyType(property).toString());\n-\n-        ++i;\n-        if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n+        if (i < MAX_PRETTY_PRINTED_PROPERTIES) {\n+          sb = new StringBuilder(formatOutput(sb, i, property, propertyType));\n+        } else if (i == MAX_PRETTY_PRINTED_PROPERTIES) {\n           sb.append(\", ...\");\n-          break;\n+          sb = new StringBuilder(formatOutput(sb, i, property, propertyType));\n         }\n+\n+        i++;\n       }\n \n       sb.append(\"}\");",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}