{
    "patch": "import org.apache.commons.math3.special.Gamma;\nimport org.apache.commons.math3.util.MathUtils;\nimport org.apache.commons.math3.util.Precision;\nimport org.apache.commons.math3.exception.NotStrictlyPositiveException;\n\npublic class GammaFunction {\n    public static double gamma(double x) {\n        if (x <= 0.0) {\n            if (Math.abs(x % 1.0) < Precision.EPSILON) {\n                throw new NotStrictlyPositiveException(\"Invalid gamma argument: \" + x);\n            } else {\n                return Double.NaN;\n            }\n        } else if (x == 1.0) {\n            return 1.0;\n        } else if (x < 2.0) {\n            return gamma(x + 1.0) / x;\n        } else if (x < 10.0) {\n            double prod = 1.0;\n            double t = x;\n            while (t > 2.5) {\n                t -= 1.0;\n                prod *= t;\n            }\n            return prod / Gamma.coefficients(t - 2.0);\n        } else {\n            double y = Gamma.lanczos(x);\n            double tmp = (x - 0.5) * Math.log(x + Gamma.LANCZOS_G + 0.5);\n            double ser = MathUtils.SQRT2PI + 1.0 / (12.0 * x) - 1.0 / (360.0 * Math.pow(x, 3.0)) + 1.0 / (1260.0 * Math.pow(x, 5.0)) - 1.0 / (1680.0 * Math.pow(x, 7.0));\n            return Math.exp(tmp) * ser / y;\n        }\n    }\n\n    public static double logGamma(double x) {\n        if (x <= 0.0) {\n            if (Math.abs(x % 1.0) < Precision.EPSILON) {\n                throw new NotStrictlyPositiveException(\"Invalid log gamma argument: \" + x);\n            } else {\n                return Double.NaN;\n            }\n        } else if (x == 1.0) {\n            return 0.0;\n        } else if (x < 2.0) {\n            return logGamma(x + 1.0) - Math.log(x);\n        } else if (x < 10.0) {\n            return Math.log(gamma(x));\n        } else {\n            double q = (x - 0.5) * Math.log(x) - x + MathUtils.SQRT2PI / 2.0;\n            return q + Math.log(lanczos(x));\n        }\n    }\n\n    private static double lanczos(double x) {\n        double sum = 0.0;\n        for (int i = Gamma.LANCZOS.length - 1; i > 0; --i) {\n            sum += Gamma.LANCZOS[i] / (x + i);\n        }\n        return sum + Gamma.LANCZOS[0];\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..19eb5a894 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,66 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import org.apache.commons.math3.special.Gamma;\n+import org.apache.commons.math3.util.MathUtils;\n+import org.apache.commons.math3.util.Precision;\n+import org.apache.commons.math3.exception.NotStrictlyPositiveException;\n+\n+public class GammaFunction {\n+    public static double gamma(double x) {\n+        if (x <= 0.0) {\n+            if (Math.abs(x % 1.0) < Precision.EPSILON) {\n+                throw new NotStrictlyPositiveException(\"Invalid gamma argument: \" + x);\n+            } else {\n+                return Double.NaN;\n+            }\n+        } else if (x == 1.0) {\n+            return 1.0;\n+        } else if (x < 2.0) {\n+            return gamma(x + 1.0) / x;\n+        } else if (x < 10.0) {\n+            double prod = 1.0;\n+            double t = x;\n+            while (t > 2.5) {\n+                t -= 1.0;\n+                prod *= t;\n+            }\n+            return prod / Gamma.coefficients(t - 2.0);\n+        } else {\n+            double y = Gamma.lanczos(x);\n+            double tmp = (x - 0.5) * Math.log(x + Gamma.LANCZOS_G + 0.5);\n+            double ser = MathUtils.SQRT2PI + 1.0 / (12.0 * x) - 1.0 / (360.0 * Math.pow(x, 3.0)) + 1.0 / (1260.0 * Math.pow(x, 5.0)) - 1.0 / (1680.0 * Math.pow(x, 7.0));\n+            return Math.exp(tmp) * ser / y;\n+        }\n+    }\n+\n+    public static double logGamma(double x) {\n+        if (x <= 0.0) {\n+            if (Math.abs(x % 1.0) < Precision.EPSILON) {\n+                throw new NotStrictlyPositiveException(\"Invalid log gamma argument: \" + x);\n+            } else {\n+                return Double.NaN;\n+            }\n+        } else if (x == 1.0) {\n+            return 0.0;\n+        } else if (x < 2.0) {\n+            return logGamma(x + 1.0) - Math.log(x);\n+        } else if (x < 10.0) {\n+            return Math.log(gamma(x));\n+        } else {\n+            double q = (x - 0.5) * Math.log(x) - x + MathUtils.SQRT2PI / 2.0;\n+            return q + Math.log(lanczos(x));\n+        }\n+    }\n+\n+    private static double lanczos(double x) {\n+        double sum = 0.0;\n+        for (int i = Gamma.LANCZOS.length - 1; i > 0; --i) {\n+            sum += Gamma.LANCZOS[i] / (x + i);\n+        }\n+        return sum + Gamma.LANCZOS[0];\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}