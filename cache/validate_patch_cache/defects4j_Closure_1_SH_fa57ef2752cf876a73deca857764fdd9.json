{
    "patch": "    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node fnBlock = function.getLastChild();\n    Node argList = function.getFirstChild().getNext();\n    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          compiler.reportCodeChange();\n        } else {\n          break;\n        }\n      }\n\n      // Remove arguments nodes without names.\n      Node arg;\n      for (arg = argList.getFirstChild(); arg != null; arg = arg.getNext()) {\n        if (arg.isEmpty()) {\n          argList.removeChild(arg);\n          compiler.reportCodeChange();\n        }\n      }\n\n      boolean firstParamRemoved = false;\n      // Traverse the BODY nodes to remove unreferenced arguments from\n      // functions expressions and arrow functions.\n      for (Node n = fnBlock.getFirstChild(); n != null; n = n.getNext()) {\n        if (!firstParamRemoved && NodeUtil.isFunctionDeclaration(n)) {\n          Node newArgList = n.getFirstChild().getNext();\n          int numFormalParams = countFormals(argList);\n          if (numFormalParams < newArgList.getChildCount()) {\n            firstParamRemoved = true;\n          } else {\n            continue;\n          }\n        }\n        if (n.isParamList()) {\n          Node argNode = n.getFirstChild();\n          while (argNode != null && !argNode.isEmpty()) {\n            String argName = argNode.getString();\n            Var var = fnScope.getVar(argName);\n\n            if (!referenced.contains(var)) {\n              n.removeChild(argNode);\n              compiler.reportCodeChange();\n            }\n            argNode = argNode.getNext();\n          }\n        } else if (n.isFunction()) {\n          Preconditions.checkState(!NodeUtil.isFunctionExpression(n));\n          Scope childScope = scopes.get(n);\n          Set<Var> childReferenced = referencedMap.get(childScope);\n          removeUnreferencedFunctionArgs(childScope, childReferenced);\n        } else {\n          Preconditions.checkState(!n.isParamList());\n        }\n      }\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n      fnBlock = function.getLastChild();\n      argList = function.getFirstChild().getNext();\n      if (callSiteOptimizer.getFirstRemovedParam() >= 0) {\n        int firstRemovedParam = callSiteOptimizer.getFirstRemovedParam();\n\n        // Remove arguments nodes that needs to be removed.\n        int childCount = argList.getChildCount();\n        for (int i = firstRemovedParam; i < childCount; i++) {\n          Node arg = argList.getLastChild();\n          argList.removeChild(arg);\n          compiler.reportCodeChange();\n        }\n\n        // Remove param nodes without names.\n        Node arg;\n        for (arg = argList.getFirstChild(); arg != null; arg = arg.getNext()) {\n          if (arg.isEmpty()) {\n            argList.removeChild(arg);\n            compiler.reportCodeChange();\n          }\n        }\n\n        // Traverse the BODY nodes to remove unreferenced arguments from\n        // functions expressions and arrow functions.\n        boolean firstParamRemoved = false;\n        for (Node n = fnBlock.getFirstChild(); n != null; n = n.getNext()) {\n          if (!firstParamRemoved && NodeUtil.isFunctionDeclaration(n)) {\n            Node newArgList = n.getFirstChild().getNext();\n            int numFormalParams = countFormals(argList);\n            if (numFormalParams < newArgList.getChildCount()) {\n              firstParamRemoved = true;\n            } else {\n              continue;\n            }\n          }\n          // ParamList should always be the first child of a FUNCTION node, so a\n          // FUNCTION node that hsa any children other than a PARAM_LIST is assumed\n          // to have a inline SCRIPT inside of it.\n          if (n.isFunction()) {\n            Preconditions.checkState(!NodeUtil.isFunctionExpression(n));\n            Scope childScope = scopes.get(n);\n            Set<Var> childReferenced = referencedMap.get(childScope);\n            removeUnreferencedFunctionArgs(childScope, childReferenced);\n          } else if (!n.isParamList()) {\n            Preconditions.checkState(n.canBeStatement());\n            for (Node child = n.getFirstChild(); child != null;) {\n              Node next = child.getNext();\n              if (child.isName()) {\n                Var var = fnScope.getVar(child.getString());\n                if (!referenced.contains(var)) {\n                  n.removeChild(child);\n                  compiler.reportCodeChange();\n                }\n              } else if (child.isAssign()) {\n                Node lhs = child.getFirstChild();\n                if (lhs.isName()) {\n                  Var var = fnScope.getVar(lhs.getString());\n                  if (!referenced.contains(var)) {\n                    n.removeChild(child);\n                    compiler.reportCodeChange();\n                  }\n                }\n              }\n              child = next;\n            }\n          }\n        }\n      }\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..2a617ea0 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,144 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node fnBlock = function.getLastChild();\n+    Node argList = function.getFirstChild().getNext();\n+    boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+      // Strip unreferenced args off the end of the function declaration.\n+      Node lastArg;\n+      while ((lastArg = argList.getLastChild()) != null) {\n+        Var var = fnScope.getVar(lastArg.getString());\n+        if (!referenced.contains(var)) {\n+          argList.removeChild(lastArg);\n+          compiler.reportCodeChange();\n+        } else {\n+          break;\n+        }\n+      }\n+\n+      // Remove arguments nodes without names.\n+      Node arg;\n+      for (arg = argList.getFirstChild(); arg != null; arg = arg.getNext()) {\n+        if (arg.isEmpty()) {\n+          argList.removeChild(arg);\n+          compiler.reportCodeChange();\n+        }\n+      }\n+\n+      boolean firstParamRemoved = false;\n+      // Traverse the BODY nodes to remove unreferenced arguments from\n+      // functions expressions and arrow functions.\n+      for (Node n = fnBlock.getFirstChild(); n != null; n = n.getNext()) {\n+        if (!firstParamRemoved && NodeUtil.isFunctionDeclaration(n)) {\n+          Node newArgList = n.getFirstChild().getNext();\n+          int numFormalParams = countFormals(argList);\n+          if (numFormalParams < newArgList.getChildCount()) {\n+            firstParamRemoved = true;\n+          } else {\n+            continue;\n+          }\n+        }\n+        if (n.isParamList()) {\n+          Node argNode = n.getFirstChild();\n+          while (argNode != null && !argNode.isEmpty()) {\n+            String argName = argNode.getString();\n+            Var var = fnScope.getVar(argName);\n+\n+            if (!referenced.contains(var)) {\n+              n.removeChild(argNode);\n+              compiler.reportCodeChange();\n+            }\n+            argNode = argNode.getNext();\n+          }\n+        } else if (n.isFunction()) {\n+          Preconditions.checkState(!NodeUtil.isFunctionExpression(n));\n+          Scope childScope = scopes.get(n);\n+          Set<Var> childReferenced = referencedMap.get(childScope);\n+          removeUnreferencedFunctionArgs(childScope, childReferenced);\n+        } else {\n+          Preconditions.checkState(!n.isParamList());\n+        }\n+      }\n+    } else {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+      fnBlock = function.getLastChild();\n+      argList = function.getFirstChild().getNext();\n+      if (callSiteOptimizer.getFirstRemovedParam() >= 0) {\n+        int firstRemovedParam = callSiteOptimizer.getFirstRemovedParam();\n+\n+        // Remove arguments nodes that needs to be removed.\n+        int childCount = argList.getChildCount();\n+        for (int i = firstRemovedParam; i < childCount; i++) {\n+          Node arg = argList.getLastChild();\n+          argList.removeChild(arg);\n+          compiler.reportCodeChange();\n+        }\n+\n+        // Remove param nodes without names.\n+        Node arg;\n+        for (arg = argList.getFirstChild(); arg != null; arg = arg.getNext()) {\n+          if (arg.isEmpty()) {\n+            argList.removeChild(arg);\n+            compiler.reportCodeChange();\n+          }\n+        }\n+\n+        // Traverse the BODY nodes to remove unreferenced arguments from\n+        // functions expressions and arrow functions.\n+        boolean firstParamRemoved = false;\n+        for (Node n = fnBlock.getFirstChild(); n != null; n = n.getNext()) {\n+          if (!firstParamRemoved && NodeUtil.isFunctionDeclaration(n)) {\n+            Node newArgList = n.getFirstChild().getNext();\n+            int numFormalParams = countFormals(argList);\n+            if (numFormalParams < newArgList.getChildCount()) {\n+              firstParamRemoved = true;\n+            } else {\n+              continue;\n+            }\n+          }\n+          // ParamList should always be the first child of a FUNCTION node, so a\n+          // FUNCTION node that hsa any children other than a PARAM_LIST is assumed\n+          // to have a inline SCRIPT inside of it.\n+          if (n.isFunction()) {\n+            Preconditions.checkState(!NodeUtil.isFunctionExpression(n));\n+            Scope childScope = scopes.get(n);\n+            Set<Var> childReferenced = referencedMap.get(childScope);\n+            removeUnreferencedFunctionArgs(childScope, childReferenced);\n+          } else if (!n.isParamList()) {\n+            Preconditions.checkState(n.canBeStatement());\n+            for (Node child = n.getFirstChild(); child != null;) {\n+              Node next = child.getNext();\n+              if (child.isName()) {\n+                Var var = fnScope.getVar(child.getString());\n+                if (!referenced.contains(var)) {\n+                  n.removeChild(child);\n+                  compiler.reportCodeChange();\n+                }\n+              } else if (child.isAssign()) {\n+                Node lhs = child.getFirstChild();\n+                if (lhs.isName()) {\n+                  Var var = fnScope.getVar(lhs.getString());\n+                  if (!referenced.contains(var)) {\n+                    n.removeChild(child);\n+                    compiler.reportCodeChange();\n+                  }\n+                }\n+              }\n+              child = next;\n+            }\n+          }\n+        }\n+      }\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}