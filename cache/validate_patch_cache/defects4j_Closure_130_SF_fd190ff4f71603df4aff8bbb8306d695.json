{
    "patch": "private void inlineAliases(GlobalNamespace namespace) {\n    Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n    // Invariant: All the names in the worklist meet condition (a).\n    while (!workList.isEmpty()) {\n        Name name = workList.pop();\n        // Don't attempt to inline a getter or setter property as a variable.\n        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n            continue;\n        }\n        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\n            // {@code name} meets condition (b). \n            // Find all of its local aliases and try to inline them.\n            List<Ref> refs = Lists.newArrayList(name.getRefs());\n            for (Ref ref : refs) {\n                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n                    // {@code name} meets condition (c). \n                    // Try to inline it and update its aliases' references\n                    if (inlineAliasIfPossible(ref, namespace)) {\n                        for (Ref alias : name.getAliasedRefs()) {\n                            if (alias.type == Ref.Type.ALIASING_GET && alias != ref) {\n                                alias.type = Ref.Type.ASSIGN;\n                                alias.node.getParent().replaceChild(alias.node, ref.node.getFirstChild().cloneNode());\n                                alias.getSymbol().removeRef(alias);\n                                ref.getSymbol().addRef(alias);\n                                alias.node = ref.node.getFirstChild();\n                            }\n                        }\n                        name.removeRef(ref);\n                    }\n                }\n            }\n        }\n        // Check if {@code name} has any aliases left after the \n        // local-alias-inlining above.\n        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\n            // All of {@code name}'s children meet condition (a), so they can be \n            // added to the worklist.\n            workList.addAll(name.props);\n        }\n    }\n}\n\nprivate boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n    Preconditions.checkState(ref.type == Type.ALIASING_GET);\n    Name name = ref.getSymbol();\n    Preconditions.checkState(name != null);\n\n    // We don't inline symbols with prototype properties, as they can't be\n    // referenced directly.\n    if (hasPrototypeProperty(name)) {\n        return false;\n    }\n\n    // Check to make sure there is only one definition of the variable.\n    if (name.getGlobalSets() != 1 || name.getLocalSets() != 0) {\n        return false;\n    }\n\n    Node assignNode = name.getDeclaration().getNode();\n    Node valueNode = assignNode.getLastChild();\n    if (!NodeUtil.mayBeObjectLitKey(valueNode)) {\n        return false;\n    }\n    // Don't attempt to inline a var declaration if its initializer is an unsafe\n    // reference to the var itself.\n    Var var = namespace.getVar(name.getFullName());\n    if (var != null && var.isFromExterns()) {\n        return false;\n    }\n    if (name.type == Name.Type.FUNCTION) {\n        for (Ref fref : name.getRefs()) {\n            if (fref == ref || !fref.canBeRenamed()) {\n                return false;\n            }\n\n            // Don't inline a function named in a prototype property assignment.\n            if (fref.getParent() != null && NodeUtil.isObjectLitKey(fref.getParent())) {\n                return false;\n            }\n\n            // Don't inline a free function name.\n            // A free function name can be detected by checking if\n            // the function reference has the same name as the function source.\n            // (see the `x === foo` check in `createDeclarationNodes_`).\n            if (fref.parent != null && fref.getSymbol() != null &&\n                    fref.parent.getType() == Token.CALL &&\n                    fref.getSymbol().getName().equals(\n                            fref.parent.getFirstChild().getOriginalQualifiedName())) {\n                return false;\n            }\n        }\n    }\n\n    // Check to make sure there are no references\n    List<Ref> refs = Lists.newArrayList(name.getRefs());\n    for (Ref nref : refs) {\n        if (nref == ref) {\n            continue;\n        }\n        if (nref.getNode().getOriginalQualifiedName() != null) {\n            return false;\n        }\n        if (nref.type == Ref.Type.WRITE) {\n            return false;\n        }\n        if (nref.getParent() == valueNode) {\n            continue;\n        }\n        if (!nref.canBeDeleted()\n                && (NodeUtil.isExpressionResultUsed(nref.getNode())\n                || nref.getParent().getType() == Token.NAME)) {\n            return false;\n        }\n    }\n    if (name.type == Name.Type.FUNCTION && name.getDeclaration().getOriginalName() != null) {\n        name.getDeclaration().setName(name.getIdentifier());\n\n        // Update the original name reference if it exists.\n        Node fnNameNode = name.getDeclaration().getFirstChild();\n        NodeUtil.tryGetName(fnNameNode, name.getOriginalName());\n    }\n    if (isLegalToInlineExpression(valueNode)) {\n        // Remove the original name definition if possible\n        NodeUtil.removeChild(assignNode.getParent(), assignNode);\n        // Inline the expression\n        ref.type = Ref.Type.DIRECT_GET;\n        ref.node.getParent().replaceChild(ref.node, valueNode.cloneTree());\n        ref.getSymbol().removeRef(ref);\n        NodeUtil.markFunctionsDeleted(valueNode, compiler);\n        compiler.reportChangeToEnclosingScope(valueNode);\n        return true;\n    }\n    return false;\n}\n\nprivate boolean isLegalToInlineExpression(Node n) {\n    if (n == null) {\n        return false;\n    }\n\n    // We can't inline a conditional expression because its value might be an\n    // l-value or a non-constant expression.\n    if (NodeUtil.isConditionalExpression(n)) {\n        return false;\n    }\n\n    // We can't inline a value that has a non-trivial CFG.\n    if (NodeUtil.mayHaveSideEffects(n)) {\n        ControlFlowGraph<Node> cfg = new ControlFlowAnalysis(compiler, true, false)\n                .createControlFlowGraph(n);\n        if (cfg.isGraphStructured() && !cfg.hasExceptionHandlers()) {\n            return true;\n        }\n        return false;\n    }\n    return true;\n}\n\nprivate boolean hasPrototypeProperty(Name name) {\n    if (name.type != Name.Type.OBJECTLIT) {\n        return false;\n    }\n    return hasOwnProperty(name, \"prototype\");\n}\n\nprivate boolean hasOwnProperty(Name name, String prop) {\n    if (name.props == null) {\n        return false;\n    }\n    for (Name pname : name.props) {\n        if (pname.identifier.equals(prop)) {\n            return true;\n        }\n    }\n    return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..476b7504 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -158,43 +158,182 @@ class CollapseProperties implements CompilerPass {\n    *    inlineable.\n    * @see InlineVariables\n    */\n-  private void inlineAliases(GlobalNamespace namespace) {\n-    // Invariant: All the names in the worklist meet condition (a).\n+private void inlineAliases(GlobalNamespace namespace) {\n     Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n+    // Invariant: All the names in the worklist meet condition (a).\n     while (!workList.isEmpty()) {\n-      Name name = workList.pop();\n+        Name name = workList.pop();\n+        // Don't attempt to inline a getter or setter property as a variable.\n+        if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n+            continue;\n+        }\n+        if (name.globalSets == 1 && name.localSets == 0 && name.aliasingGets > 0) {\n+            // {@code name} meets condition (b). \n+            // Find all of its local aliases and try to inline them.\n+            List<Ref> refs = Lists.newArrayList(name.getRefs());\n+            for (Ref ref : refs) {\n+                if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n+                    // {@code name} meets condition (c). \n+                    // Try to inline it and update its aliases' references\n+                    if (inlineAliasIfPossible(ref, namespace)) {\n+                        for (Ref alias : name.getAliasedRefs()) {\n+                            if (alias.type == Ref.Type.ALIASING_GET && alias != ref) {\n+                                alias.type = Ref.Type.ASSIGN;\n+                                alias.node.getParent().replaceChild(alias.node, ref.node.getFirstChild().cloneNode());\n+                                alias.getSymbol().removeRef(alias);\n+                                ref.getSymbol().addRef(alias);\n+                                alias.node = ref.node.getFirstChild();\n+                            }\n+                        }\n+                        name.removeRef(ref);\n+                    }\n+                }\n+            }\n+        }\n+        // Check if {@code name} has any aliases left after the \n+        // local-alias-inlining above.\n+        if ((name.type == Name.Type.OBJECTLIT || name.type == Name.Type.FUNCTION) && name.aliasingGets == 0 && name.props != null) {\n+            // All of {@code name}'s children meet condition (a), so they can be \n+            // added to the worklist.\n+            workList.addAll(name.props);\n+        }\n+    }\n+}\n \n-      // Don't attempt to inline a getter or setter property as a variable.\n-      if (name.type == Name.Type.GET || name.type == Name.Type.SET) {\n-        continue;\n-      }\n+private boolean inlineAliasIfPossible(Ref ref, GlobalNamespace namespace) {\n+    Preconditions.checkState(ref.type == Type.ALIASING_GET);\n+    Name name = ref.getSymbol();\n+    Preconditions.checkState(name != null);\n+\n+    // We don't inline symbols with prototype properties, as they can't be\n+    // referenced directly.\n+    if (hasPrototypeProperty(name)) {\n+        return false;\n+    }\n+\n+    // Check to make sure there is only one definition of the variable.\n+    if (name.getGlobalSets() != 1 || name.getLocalSets() != 0) {\n+        return false;\n+    }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n-          name.aliasingGets > 0) {\n-        // {@code name} meets condition (b). Find all of its local aliases\n-        // and try to inline them.\n-        List<Ref> refs = Lists.newArrayList(name.getRefs());\n-        for (Ref ref : refs) {\n-          if (ref.type == Type.ALIASING_GET && ref.scope.isLocal()) {\n-            // {@code name} meets condition (c). Try to inline it.\n-            if (inlineAliasIfPossible(ref, namespace)) {\n-              name.removeRef(ref);\n+    Node assignNode = name.getDeclaration().getNode();\n+    Node valueNode = assignNode.getLastChild();\n+    if (!NodeUtil.mayBeObjectLitKey(valueNode)) {\n+        return false;\n+    }\n+    // Don't attempt to inline a var declaration if its initializer is an unsafe\n+    // reference to the var itself.\n+    Var var = namespace.getVar(name.getFullName());\n+    if (var != null && var.isFromExterns()) {\n+        return false;\n+    }\n+    if (name.type == Name.Type.FUNCTION) {\n+        for (Ref fref : name.getRefs()) {\n+            if (fref == ref || !fref.canBeRenamed()) {\n+                return false;\n+            }\n+\n+            // Don't inline a function named in a prototype property assignment.\n+            if (fref.getParent() != null && NodeUtil.isObjectLitKey(fref.getParent())) {\n+                return false;\n+            }\n+\n+            // Don't inline a free function name.\n+            // A free function name can be detected by checking if\n+            // the function reference has the same name as the function source.\n+            // (see the `x === foo` check in `createDeclarationNodes_`).\n+            if (fref.parent != null && fref.getSymbol() != null &&\n+                    fref.parent.getType() == Token.CALL &&\n+                    fref.getSymbol().getName().equals(\n+                            fref.parent.getFirstChild().getOriginalQualifiedName())) {\n+                return false;\n             }\n-          }\n         }\n-      }\n+    }\n \n-      // Check if {@code name} has any aliases left after the\n-      // local-alias-inlining above.\n-      if ((name.type == Name.Type.OBJECTLIT ||\n-           name.type == Name.Type.FUNCTION) &&\n-          name.aliasingGets == 0 && name.props != null) {\n-        // All of {@code name}'s children meet condition (a), so they can be\n-        // added to the worklist.\n-        workList.addAll(name.props);\n-      }\n+    // Check to make sure there are no references\n+    List<Ref> refs = Lists.newArrayList(name.getRefs());\n+    for (Ref nref : refs) {\n+        if (nref == ref) {\n+            continue;\n+        }\n+        if (nref.getNode().getOriginalQualifiedName() != null) {\n+            return false;\n+        }\n+        if (nref.type == Ref.Type.WRITE) {\n+            return false;\n+        }\n+        if (nref.getParent() == valueNode) {\n+            continue;\n+        }\n+        if (!nref.canBeDeleted()\n+                && (NodeUtil.isExpressionResultUsed(nref.getNode())\n+                || nref.getParent().getType() == Token.NAME)) {\n+            return false;\n+        }\n     }\n-  }\n+    if (name.type == Name.Type.FUNCTION && name.getDeclaration().getOriginalName() != null) {\n+        name.getDeclaration().setName(name.getIdentifier());\n+\n+        // Update the original name reference if it exists.\n+        Node fnNameNode = name.getDeclaration().getFirstChild();\n+        NodeUtil.tryGetName(fnNameNode, name.getOriginalName());\n+    }\n+    if (isLegalToInlineExpression(valueNode)) {\n+        // Remove the original name definition if possible\n+        NodeUtil.removeChild(assignNode.getParent(), assignNode);\n+        // Inline the expression\n+        ref.type = Ref.Type.DIRECT_GET;\n+        ref.node.getParent().replaceChild(ref.node, valueNode.cloneTree());\n+        ref.getSymbol().removeRef(ref);\n+        NodeUtil.markFunctionsDeleted(valueNode, compiler);\n+        compiler.reportChangeToEnclosingScope(valueNode);\n+        return true;\n+    }\n+    return false;\n+}\n+\n+private boolean isLegalToInlineExpression(Node n) {\n+    if (n == null) {\n+        return false;\n+    }\n+\n+    // We can't inline a conditional expression because its value might be an\n+    // l-value or a non-constant expression.\n+    if (NodeUtil.isConditionalExpression(n)) {\n+        return false;\n+    }\n+\n+    // We can't inline a value that has a non-trivial CFG.\n+    if (NodeUtil.mayHaveSideEffects(n)) {\n+        ControlFlowGraph<Node> cfg = new ControlFlowAnalysis(compiler, true, false)\n+                .createControlFlowGraph(n);\n+        if (cfg.isGraphStructured() && !cfg.hasExceptionHandlers()) {\n+            return true;\n+        }\n+        return false;\n+    }\n+    return true;\n+}\n+\n+private boolean hasPrototypeProperty(Name name) {\n+    if (name.type != Name.Type.OBJECTLIT) {\n+        return false;\n+    }\n+    return hasOwnProperty(name, \"prototype\");\n+}\n+\n+private boolean hasOwnProperty(Name name, String prop) {\n+    if (name.props == null) {\n+        return false;\n+    }\n+    for (Name pname : name.props) {\n+        if (pname.identifier.equals(prop)) {\n+            return true;\n+        }\n+    }\n+    return false;\n+}\n \n   private boolean inlineAliasIfPossible(Ref alias, GlobalNamespace namespace) {\n     // Ensure that the alias is assigned to a local variable at that",
    "result_reason": "error: method inlineAliasIfPossible(Ref,GlobalNamespace) is already defined in class CollapseProperties",
    "test_result": "ERROR"
}