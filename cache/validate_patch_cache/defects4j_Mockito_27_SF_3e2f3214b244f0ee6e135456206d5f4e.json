{
    "patch": "import org.mockito.cglib.proxy.Callback;\nimport org.mockito.cglib.proxy.Enhancer;\nimport org.mockito.cglib.proxy.MethodInterceptor;\nimport org.mockito.cglib.proxy.MethodProxy;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.listeners.InvocationListener;\nimport org.mockito.listeners.MethodInvocationReport;\n\nimport java.lang.reflect.Method;\n\npublic class ResetMock<T> {\n\n    static class MockHandler<T> implements MethodInterceptor {\n\n        private final Object mock;\n        private final InvocationListener invocationListener;\n\n        public MockHandler(Object mock, InvocationListener invocationListener) {\n            this.mock = mock;\n            this.invocationListener = invocationListener;\n        }\n\n        @Override\n        public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n            MethodInvocationReport report = new MethodInvocationReport(obj, method, args);\n            try {\n                Object result = methodProxy.invoke(mock, args);\n                report.setReturned(result);\n                return result;\n            } catch (Throwable t) {\n                report.setThrown(t);\n                throw t;\n            } finally {\n                invocationListener.reportInvocation(report);\n            }\n        }\n    }\n\n    public void resetMock(T mock, InvocationListener invocationListener) {\n        Enhancer enhancer = new Enhancer();\n        enhancer.setSuperclass(mock.getClass());\n        Callback[] callbacks = new Callback[]{new MockHandler<>(mock, invocationListener)};\n        enhancer.setCallbacks(callbacks);\n        enhancer.setCallbackFilter(new MethodInterceptorFilter());\n        T newMock = (T) enhancer.create();\n        MockUtil.copyMockDetails(mock, newMock);\n    }\n\n    private class MethodInterceptorFilter implements org.mockito.cglib.proxy.CallbackFilter {\n        @Override\n        public int accept(Method method) {\n            return 0;\n        }\n    }\n\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..3bee41a29 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,63 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Enhancer;\n+import org.mockito.cglib.proxy.MethodInterceptor;\n+import org.mockito.cglib.proxy.MethodProxy;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+\n+import java.lang.reflect.Method;\n+\n+public class ResetMock<T> {\n+\n+    static class MockHandler<T> implements MethodInterceptor {\n+\n+        private final Object mock;\n+        private final InvocationListener invocationListener;\n+\n+        public MockHandler(Object mock, InvocationListener invocationListener) {\n+            this.mock = mock;\n+            this.invocationListener = invocationListener;\n+        }\n+\n+        @Override\n+        public Object intercept(Object obj, Method method, Object[] args, MethodProxy methodProxy) throws Throwable {\n+            MethodInvocationReport report = new MethodInvocationReport(obj, method, args);\n+            try {\n+                Object result = methodProxy.invoke(mock, args);\n+                report.setReturned(result);\n+                return result;\n+            } catch (Throwable t) {\n+                report.setThrown(t);\n+                throw t;\n+            } finally {\n+                invocationListener.reportInvocation(report);\n+            }\n+        }\n+    }\n+\n+    public void resetMock(T mock, InvocationListener invocationListener) {\n+        Enhancer enhancer = new Enhancer();\n+        enhancer.setSuperclass(mock.getClass());\n+        Callback[] callbacks = new Callback[]{new MockHandler<>(mock, invocationListener)};\n+        enhancer.setCallbacks(callbacks);\n+        enhancer.setCallbackFilter(new MethodInterceptorFilter());\n+        T newMock = (T) enhancer.create();\n+        MockUtil.copyMockDetails(mock, newMock);\n+    }\n+\n+    private class MethodInterceptorFilter implements org.mockito.cglib.proxy.CallbackFilter {\n+        @Override\n+        public int accept(Method method) {\n+            return 0;\n+        }\n+    }\n+\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}