{
    "patch": "private Type getMostSpecificType(Type[] types) {\n    Type mostSpecific = null;\n    for (Type type : types) {\n        if (type instanceof Class) {\n            if (mostSpecific == null || Class.class.isAssignableFrom((Class<?>) type)) {\n                mostSpecific = type;\n            }\n        } else if (type instanceof ParameterizedType) {\n            Type rawType = ((ParameterizedType) type).getRawType();\n            if (mostSpecific == null || Class.class.isAssignableFrom((Class<?>) rawType)) {\n                mostSpecific = type;\n            }\n        } else if (type instanceof TypeVariable) {\n            Type[] bounds = ((TypeVariable<?>) type).getBounds();\n            Type candidate = getMostSpecificType(bounds);\n            if (mostSpecific == null || isMoreSpecificThan(candidate, mostSpecific)) {\n                mostSpecific = candidate;\n            }\n        }\n    }\n    return mostSpecific;\n}\n\nprivate boolean isMoreSpecificThan(Type type, Type otherType) {\n    if (type == null || otherType == null) {\n        return false;\n    }\n    if (type.equals(otherType)) {\n        return false;\n    }\n    if (type instanceof Class) {\n        return Class.class.isAssignableFrom((Class<?>) otherType) && !Class.class.isAssignableFrom((Class<?>) type);\n    } else if (type instanceof ParameterizedType) {\n        if (otherType instanceof Class) {\n            return Class.class.isAssignableFrom((Class<?>) otherType);\n        } else if (otherType instanceof ParameterizedType) {\n            Type rawType = ((ParameterizedType) type).getRawType();\n            Type otherRawType = ((ParameterizedType) otherType).getRawType();\n            if (!isMoreSpecificThan(rawType, otherRawType)) {\n                return false;\n            }\n            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n            Type[] otherTypeArguments = ((ParameterizedType) otherType).getActualTypeArguments();\n            for (int i = 0; i < typeArguments.length; i++) {\n                Type typeArg = typeArguments[i];\n                Type otherTypeArg = otherTypeArguments[i];\n                if (!isMoreSpecificThan(typeArg, otherTypeArg)) {\n                    return false;\n                }\n            }\n            return true;\n        }\n    } else if (type instanceof TypeVariable) {\n        Type[] bounds = ((TypeVariable<?>) type).getBounds();\n        for (Type bound : bounds) {\n            if (!isMoreSpecificThan(bound, otherType)) {\n                return false;\n            }\n        }\n        return true;\n    }\n    return false;\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nindex 2d6c07b17..d03781f9d 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -372,10 +372,74 @@ public abstract class GenericMetadataSupport {\n             registerTypeParametersOn(typeParameters);\n         }\n \n+\n         private void readTypeVariables() {\n             for (Type type : typeVariable.getBounds()) {\n                 registerTypeVariablesOn(type);\n             }\n+private Type getMostSpecificType(Type[] types) {\n+    Type mostSpecific = null;\n+    for (Type type : types) {\n+        if (type instanceof Class) {\n+            if (mostSpecific == null || Class.class.isAssignableFrom((Class<?>) type)) {\n+                mostSpecific = type;\n+            }\n+        } else if (type instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            if (mostSpecific == null || Class.class.isAssignableFrom((Class<?>) rawType)) {\n+                mostSpecific = type;\n+            }\n+        } else if (type instanceof TypeVariable) {\n+            Type[] bounds = ((TypeVariable<?>) type).getBounds();\n+            Type candidate = getMostSpecificType(bounds);\n+            if (mostSpecific == null || isMoreSpecificThan(candidate, mostSpecific)) {\n+                mostSpecific = candidate;\n+            }\n+        }\n+    }\n+    return mostSpecific;\n+}\n+\n+private boolean isMoreSpecificThan(Type type, Type otherType) {\n+    if (type == null || otherType == null) {\n+        return false;\n+    }\n+    if (type.equals(otherType)) {\n+        return false;\n+    }\n+    if (type instanceof Class) {\n+        return Class.class.isAssignableFrom((Class<?>) otherType) && !Class.class.isAssignableFrom((Class<?>) type);\n+    } else if (type instanceof ParameterizedType) {\n+        if (otherType instanceof Class) {\n+            return Class.class.isAssignableFrom((Class<?>) otherType);\n+        } else if (otherType instanceof ParameterizedType) {\n+            Type rawType = ((ParameterizedType) type).getRawType();\n+            Type otherRawType = ((ParameterizedType) otherType).getRawType();\n+            if (!isMoreSpecificThan(rawType, otherRawType)) {\n+                return false;\n+            }\n+            Type[] typeArguments = ((ParameterizedType) type).getActualTypeArguments();\n+            Type[] otherTypeArguments = ((ParameterizedType) otherType).getActualTypeArguments();\n+            for (int i = 0; i < typeArguments.length; i++) {\n+                Type typeArg = typeArguments[i];\n+                Type otherTypeArg = otherTypeArguments[i];\n+                if (!isMoreSpecificThan(typeArg, otherTypeArg)) {\n+                    return false;\n+                }\n+            }\n+            return true;\n+        }\n+    } else if (type instanceof TypeVariable) {\n+        Type[] bounds = ((TypeVariable<?>) type).getBounds();\n+        for (Type bound : bounds) {\n+            if (!isMoreSpecificThan(bound, otherType)) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+    return false;\n+}\n             registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n         }\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}