{
    "patch": "class IRFactory implements NodeTransformer, NodeVisitor {\n  private final ScriptOrFnNode root;\n  private final Source source;\n  private final String sourceName;\n  private final Map<String, Source> moduleSourcesByName;\n  private final CompilerOptions options;\n  private final ErrorReporter errorReporter;\n  private final boolean warningsGuardedByDiagnosticGroups;\n  private final boolean useBlockScope;\n  private final boolean emitUseStrict;\n  private IRFactory.TypeSafeDispatcher dispatcher;\n\n  interface TypeSafeDispatcher {\n    Node processBlock(Block block);\n    Node processBreakStatement(BreakStatement statement);\n    Node processCatchClause(CatchClause catchClause);\n    Node processConditionalExpression(ConditionalExpression expr);\n    Node processContinueStatement(ContinueStatement statement);\n    Node processDoLoop(DoLoop loop);\n    Node processElementGet(ElementGet getNode);\n    Node processEmptyExpression(EmptyExpression expr);\n    Node processExpressionStatement(ExpressionStatement statement);\n    Node processForInLoop(ForInLoop loop);\n    Node processForLoop(ForLoop loop);\n    Node processFunctionCall(FunctionCall call);\n    Node processFunctionNode(FunctionNode function);\n    Node processIfStatement(IfStatement statement);\n    Node processInfixExpression(InfixExpression infix);\n    Node processKeywordLiteral(KeywordLiteral keyword);\n    Node processName(Name name);\n    Node processNewExpression(NewExpression newExpr);\n    Node processNumberLiteral(NumberLiteral number);\n    Node processObjectLiteral(ObjectLiteral object);\n    Node processParenthesizedExpression(ParenthesizedExpression parenthesized);\n    Node processPropertyGet(PropertyGet getProp);\n    Node processRegExpLiteral(RegExpLiteral regexp);\n    Node processReturnStatement(ReturnStatement statement);\n    Node processStringLiteral(StringLiteral string);\n    Node processSwitchCase(SwitchCase switchCase);\n    Node processSwitchStatement(SwitchStatement statement);\n    Node processThrowStatement(ThrowStatement statement);\n    Node processTryStatement(TryStatement statement);\n    Node processUnaryExpression(UnaryExpression unary);\n    Node processVariableDeclaration(VariableDeclaration declaration);\n    Node processVariableInitializer(VariableInitializer initializer);\n    Node processWhileLoop(WhileLoop loop);\n    Node processWithStatement(WithStatement statement);\n  }\n\n  static class TransformDispatcher implements IRFactory.TypeSafeDispatcher {\n\n    private final IRFactory parent;\n\n    TransformDispatcher(IRFactory irFactory) {\n      parent = irFactory;\n    }\n\n    @Override\n    Node processBlock(Block block) {\n      return parent.processBlock(block);\n    }\n\n    @Override\n    Node processBreakStatement(BreakStatement statement) {\n      return parent.processBreakStatement(statement);\n    }\n\n    @Override\n    Node processCatchClause(CatchClause catchClause) {\n      return parent.processCatchClause(catchClause);\n    }\n\n    @Override\n    Node processConditionalExpression(ConditionalExpression expr) {\n      return parent.processConditionalExpression(expr);\n    }\n\n    @Override\n    Node processContinueStatement(ContinueStatement statement) {\n      return parent.processContinueStatement(statement);\n    }\n\n    @Override\n    Node processDoLoop(DoLoop loop) {\n      return parent.processDoLoop(loop);\n    }\n\n    @Override\n    Node processElementGet(ElementGet getNode) {\n      return parent.processElementGet(getNode);\n    }\n\n    @Override\n    Node processEmptyExpression(EmptyExpression expr) {\n      return parent.processEmptyExpression(expr);\n    }\n\n    @Override\n    Node processExpressionStatement(ExpressionStatement statement) {\n      return parent.processExpressionStatement(statement);\n    }\n\n    @Override\n    Node processForInLoop(ForInLoop loop) {\n      return parent.processForInLoop(loop);\n    }\n\n    @Override\n    Node processForLoop(ForLoop loop) {\n      return parent.processForLoop(loop);\n    }\n\n    @Override\n    Node processFunctionCall(FunctionCall call) {\n      return parent.processFunctionCall(call);\n    }\n\n    @Override\n    Node processFunctionNode(FunctionNode function) {\n      return parent.processFunctionNode(function);\n    }\n\n    @Override\n    Node processIfStatement(IfStatement statement) {\n      return parent.processIfStatement(statement);\n    }\n\n    @Override\n    Node processInfixExpression(InfixExpression infix) {\n      return parent.processInfixExpression(infix);\n    }\n\n    @Override\n    Node processKeywordLiteral(KeywordLiteral keyword) {\n      return parent.processKeywordLiteral(keyword);\n    }\n\n    @Override\n    Node processName(Name name) {\n      return parent.processName(name);\n    }\n\n    @Override\n    Node processNewExpression(NewExpression newExpr) {\n      return parent.processNewExpression(newExpr);\n    }\n\n    @Override\n    Node processNumberLiteral(NumberLiteral number) {\n      return parent.processNumberLiteral(number);\n    }\n\n    @Override\n    Node processObjectLiteral(ObjectLiteral object) {\n      return parent.processObjectLiteral(object);\n    }\n\n    @Override\n    Node processParenthesizedExpression(ParenthesizedExpression parenthesized) {\n      return parent.processParenthesizedExpression(parenthesized);\n    }\n\n    @Override\n    Node processPropertyGet(PropertyGet getProp) {\n      return parent.processPropertyGet(getProp);\n    }\n\n    @Override\n    Node processRegExpLiteral(RegExpLiteral regexp) {\n      return parent.processRegExpLiteral(regexp);\n    }\n\n    @Override\n    Node processReturnStatement(ReturnStatement statement) {\n      return parent.processReturnStatement(statement);\n    }\n\n    @Override\n    Node processStringLiteral(StringLiteral string) {\n      return parent.processStringLiteral(string);\n    }\n\n    @Override\n    Node processSwitchCase(SwitchCase switchCase) {\n      return parent.processSwitchCase(switchCase);\n    }\n\n    @Override\n    Node processSwitchStatement(SwitchStatement statement) {\n      return parent.processSwitchStatement(statement);\n    }\n\n    @Override\n    Node processThrowStatement(ThrowStatement statement) {\n      return parent.processThrowStatement(statement);\n    }\n\n    @Override\n    Node processTryStatement(TryStatement statement) {\n      return parent.processTryStatement(statement);\n    }\n\n    @Override\n    Node processUnaryExpression(UnaryExpression unary) {\n      return parent.processUnaryExpression(unary);\n    }\n\n    @Override\n    Node processVariableDeclaration(VariableDeclaration declaration) {\n      return parent.processVariableDeclaration(declaration);\n    }\n\n    @Override\n    Node processVariableInitializer(VariableInitializer initializer) {\n      return parent.processVariableInitializer(initializer);\n    }\n\n    @Override\n    Node processWhileLoop(WhileLoop loop) {\n      return parent.processWhileLoop(loop);\n    }\n\n    @Override\n    Node processWithStatement(WithStatement statement) {\n      return parent.processWithStatement(statement);\n    }\n  }\n\n  IRFactory(\n      CompilerOptions options,\n      ErrorReporter errorReporter,\n      boolean useBlockScope,\n      boolean warningsGuardedByDiagnosticGroups,\n      String sourceName,\n      String sourceString) {\n    this(\n        options,\n        errorReporter,\n        useBlockScope,\n        warningsGuardedByDiagnosticGroups,\n        sourceName,\n        sourceString,\n        null);\n  }\n\n  IRFactory(\n      CompilerOptions options,\n      ErrorReporter errorReporter,\n      boolean useBlockScope,\n      boolean warningsGuardedByDiagnosticGroups,\n      String sourceName,\n      String sourceString,\n      Map<String, Source> moduleSourcesByName) {\n    this.options = options;\n    this.errorReporter = errorReporter;\n    this.useBlockScope = useBlockScope;\n    this.sourceName = sourceName;\n    this.source = new Source(sourceName);\n    this.source.length(sourceString.length());\n    this.source.setOriginalCode(sourceString);\n    this.source.setKind(SourceKind.STRONG);\n    this.warningsGuardedByDiagnosticGroups = warningsGuardedByDiagnosticGroups;\n    this.moduleSourcesByName = moduleSourcesByName == null\n        ? ImmutableMap.<String, Source>of()\n        : ImmutableMap.copyOf(moduleSourcesByName); \n    this.emitUseStrict = options.needsEmitUseStrict();\n    this.root = new Parser(options, errorReporter)\n                   .parse(source, sourceString, 1);\n    this.dispatcher = new TransformDispatcher(this);\n  }\n\n  @Override\n  public Node transform(Node n) {\n    return (Node) n.visit(this.dispatcher);\n  }\n\n  @Override\n  public boolean canContinueTraversal() {\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal traversal, Node n, Node parent) {\n    // Nothing to do.\n  }\n\n  private Scope getEnclosingScope(NormalScope s) {\n    Scope scope = s.getParentScope();\n    return (scope instanceof NormalScope) ? scope : null;\n  }\n\n  private Block createBlock(Node n) {\n    return new Block(n);\n  }\n\n  Node processBreakStatement(BreakStatement statement) {\n    Node nameNode = null;\n    Label label = statement.getLabel();\n    if (label != null) {\n      Node name = name(label.getName());\n      nameNode = transform(name);\n    }\n    Node breakNode = new Node(Token.BREAK, nameNode);\n    breakNode.setLineno(statement.getLineno());\n    breakNode.setCharno(position2charno(statement.getAbsolutePosition()));\n    return breakNode;\n  }\n\n  Node processContinueStatement(ContinueStatement statement) {\n    Node nameNode = null;\n    Label label = statement.getLabel();\n    if (label != null) {\n      Node name = name(label.getName());\n      nameNode = transform(name);\n    }\n    Node continueNode = new Node(Token.CONTINUE, nameNode);\n    continueNode.setLineno(statement.getLineno());\n    continueNode.setCharno(position2charno(statement.getAbsolutePosition()));\n    return continueNode;\n  }\n\n  private Node createBinary(int type, Node left, Node right) {\n    Node node = new Node(type);\n    node.addChildToBack(left);\n    node.addChildToBack(right);\n    return node;\n  }\n\n  private Node createString(String value) {\n    return new Node(Token.STRING, Node.newString(value));\n  }\n\n  private Node createNumber(double value) {\n    return new Node(Token.NUMBER, Node.newNumber(value));\n  }\n\n  private Node createFunction(String name, Node params, Block body) {\n    Node function = new Node(Token.FUNCTION,\n                             createName(name),\n                             params,\n                             body);\n    function.setIsArrowFunction(false);\n    return function;\n  }\n\n  private Node createName(String name) {\n    return new Node(Token.NAME, Node.newString(name));\n  }\n\n  private Node name(String name) {\n    return createName(name);\n  }\n\n  private Node createVarNodes(List<VarDeclaration> vars) {\n    Node var = new Node(Token.VAR);\n    for (VarDeclaration varDecl : vars) {\n      Node name = createName(varDecl.getTarget().getIdentifier());\n      Node value = null;\n      if (varDecl.getInitializer() != null) {\n        value = transform(varDecl.getInitializer());\n      }\n      Node varNode = (value == null) ? name : createBinary(Token.ASSIGN, name, value);\n      var.addChildToBack(varNode);\n    }\n    return var;\n  }\n\n  private Node createObjectNodes(List<ObjectProperty> props) {\n    Node object = new Node(Token.OBJECTLIT);\n    for (ObjectProperty prop : props) {\n      if (prop.isGetter()) {\n        Node getProp =\n            new Node(Token.GETTER_DEF, createName(prop.getKey().getIdentifier()), makeBody(prop));\n        object.addChildToBack(getProp);\n      } else if (prop.isSetter()) {\n        Node setProp = new Node(Token.SETTER_DEF,\n                                createName(prop.getKey().getIdentifier()),\n                                makeParams(prop),\n                                makeBody(prop));\n        object.addChildToBack(setProp);\n      } else {\n        Node value = transform(prop.getRight());\n        Node key = transform(prop.getLeft());\n        Node objProp = new Node(Token.OBJECT_PROP_DEF, key, value);\n        if (!prop.isShorthand()) {\n          if (prop.isKindOf(ObjectProperty.Kind.GET)) {\n            objProp.putProp(Node.IS_GETTER_PROP, prop);\n          } else if (prop.isKindOf(ObjectProperty.Kind.SET)) {\n            objProp.putProp(Node.IS_SETTER_PROP, prop);\n          }\n        }\n        object.addChildToBack(objProp);\n      }\n    }\n    return object;\n  }\n\n  private Node makeParams(ObjectProperty prop) {\n    Node param = createName(prop.getParamName().getIdentifier());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 4a733cda..0e7dbc9c 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -385,181 +385,405 @@ public class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class IRFactory implements NodeTransformer, NodeVisitor {\n+  private final ScriptOrFnNode root;\n+  private final Source source;\n+  private final String sourceName;\n+  private final Map<String, Source> moduleSourcesByName;\n+  private final CompilerOptions options;\n+  private final ErrorReporter errorReporter;\n+  private final boolean warningsGuardedByDiagnosticGroups;\n+  private final boolean useBlockScope;\n+  private final boolean emitUseStrict;\n+  private IRFactory.TypeSafeDispatcher dispatcher;\n+\n+  interface TypeSafeDispatcher {\n+    Node processBlock(Block block);\n+    Node processBreakStatement(BreakStatement statement);\n+    Node processCatchClause(CatchClause catchClause);\n+    Node processConditionalExpression(ConditionalExpression expr);\n+    Node processContinueStatement(ContinueStatement statement);\n+    Node processDoLoop(DoLoop loop);\n+    Node processElementGet(ElementGet getNode);\n+    Node processEmptyExpression(EmptyExpression expr);\n+    Node processExpressionStatement(ExpressionStatement statement);\n+    Node processForInLoop(ForInLoop loop);\n+    Node processForLoop(ForLoop loop);\n+    Node processFunctionCall(FunctionCall call);\n+    Node processFunctionNode(FunctionNode function);\n+    Node processIfStatement(IfStatement statement);\n+    Node processInfixExpression(InfixExpression infix);\n+    Node processKeywordLiteral(KeywordLiteral keyword);\n+    Node processName(Name name);\n+    Node processNewExpression(NewExpression newExpr);\n+    Node processNumberLiteral(NumberLiteral number);\n+    Node processObjectLiteral(ObjectLiteral object);\n+    Node processParenthesizedExpression(ParenthesizedExpression parenthesized);\n+    Node processPropertyGet(PropertyGet getProp);\n+    Node processRegExpLiteral(RegExpLiteral regexp);\n+    Node processReturnStatement(ReturnStatement statement);\n+    Node processStringLiteral(StringLiteral string);\n+    Node processSwitchCase(SwitchCase switchCase);\n+    Node processSwitchStatement(SwitchStatement statement);\n+    Node processThrowStatement(ThrowStatement statement);\n+    Node processTryStatement(TryStatement statement);\n+    Node processUnaryExpression(UnaryExpression unary);\n+    Node processVariableDeclaration(VariableDeclaration declaration);\n+    Node processVariableInitializer(VariableInitializer initializer);\n+    Node processWhileLoop(WhileLoop loop);\n+    Node processWithStatement(WithStatement statement);\n+  }\n+\n+  static class TransformDispatcher implements IRFactory.TypeSafeDispatcher {\n+\n+    private final IRFactory parent;\n \n-      int nType = n.getType();\n-      return (nType == Token.EXPR_RESULT || nType == Token.EXPR_VOID) &&\n-          n.getFirstChild().getType() == Token.STRING &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    TransformDispatcher(IRFactory irFactory) {\n+      parent = irFactory;\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    Node processBlock(Block block) {\n+      return parent.processBlock(block);\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    Node processBreakStatement(BreakStatement statement) {\n+      return parent.processBreakStatement(statement);\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    Node processCatchClause(CatchClause catchClause) {\n+      return parent.processCatchClause(catchClause);\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    Node processConditionalExpression(ConditionalExpression expr) {\n+      return parent.processConditionalExpression(expr);\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    Node processContinueStatement(ContinueStatement statement) {\n+      return parent.processContinueStatement(statement);\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    Node processDoLoop(DoLoop loop) {\n+      return parent.processDoLoop(loop);\n     }\n \n     @Override\n     Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+      return parent.processElementGet(getNode);\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    Node processEmptyExpression(EmptyExpression expr) {\n+      return parent.processEmptyExpression(expr);\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    Node processExpressionStatement(ExpressionStatement statement) {\n+      return parent.processExpressionStatement(statement);\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    Node processForInLoop(ForInLoop loop) {\n+      return parent.processForInLoop(loop);\n     }\n \n     @Override\n-    Node processForLoop(ForLoop loopNode) {\n-      Node node = newNode(\n-          Token.FOR,\n-          transform(loopNode.getInitializer()),\n-          transform(loopNode.getCondition()),\n-          transform(loopNode.getIncrement()));\n-      node.addChildToBack(transformBlock(loopNode.getBody()));\n-      return node;\n+    Node processForLoop(ForLoop loop) {\n+      return parent.processForLoop(loop);\n     }\n \n     @Override\n-    Node processFunctionCall(FunctionCall callNode) {\n-      Node node = newNode(transformTokenType(callNode.getType()),\n-                           transform(callNode.getTarget()));\n-      for (AstNode child : callNode.getArguments()) {\n-        node.addChildToBack(transform(child));\n-      }\n+    Node processFunctionCall(FunctionCall call) {\n+      return parent.processFunctionCall(call);\n+    }\n \n-      int leftParamPos = callNode.getAbsolutePosition() + callNode.getLp();\n-      node.setLineno(callNode.getLineno());\n-      node.setCharno(position2charno(leftParamPos));\n-      return node;\n+    @Override\n+    Node processFunctionNode(FunctionNode function) {\n+      return parent.processFunctionNode(function);\n     }\n \n     @Override\n-    Node processFunctionNode(FunctionNode functionNode) {\n-      Name name = functionNode.getFunctionName();\n-      Boolean isUnnamedFunction = false;\n-      if (name == null) {\n-        name = new Name();\n-        name.setIdentifier(\"\");\n-        isUnnamedFunction = true;\n-      }\n-      Node node = newNode(Token.FUNCTION);\n-      Node newName = transform(name);\n-      if (isUnnamedFunction) {\n-        // Old Rhino tagged the empty name node with the line number of the\n-        // declaration.\n-        newName.setLineno(functionNode.getLineno());\n-        // TODO(bowdidge) Mark line number of paren correctly.\n-        // Same problem as below - the left paren might not be on the\n-        // same line as the function keyword.\n-        int lpColumn = functionNode.getAbsolutePosition() +\n-            functionNode.getLp();\n-        newName.setCharno(position2charno(lpColumn));\n-      }\n+    Node processIfStatement(IfStatement statement) {\n+      return parent.processIfStatement(statement);\n+    }\n \n-      node.addChildToBack(newName);\n-      Node lp = newNode(Token.LP);\n-      // The left paren's complicated because it's not represented by an\n-      // AstNode, so there's nothing that has the actual line number that it\n-      // appeared on.  We know the paren has to appear on the same line as the\n-      // function name (or else a semicolon will be inserted.)  If there's no\n-      // function name, assume the paren was on the same line as the function.\n-      // TODO(bowdidge): Mark line number of paren correctly.\n-      Name fnName = functionNode.getFunctionName();\n-      if (fnName != null) {\n-        lp.setLineno(fnName.getLineno());\n-      } else {\n-        lp.setLineno(functionNode.getLineno());\n-      }\n-      int lparenCharno = functionNode.getLp() +\n-          functionNode.getAbsolutePosition();\n+    @Override\n+    Node processInfixExpression(InfixExpression infix) {\n+      return parent.processInfixExpression(infix);\n+    }\n+\n+    @Override\n+    Node processKeywordLiteral(KeywordLiteral keyword) {\n+      return parent.processKeywordLiteral(keyword);\n+    }\n+\n+    @Override\n+    Node processName(Name name) {\n+      return parent.processName(name);\n+    }\n+\n+    @Override\n+    Node processNewExpression(NewExpression newExpr) {\n+      return parent.processNewExpression(newExpr);\n+    }\n+\n+    @Override\n+    Node processNumberLiteral(NumberLiteral number) {\n+      return parent.processNumberLiteral(number);\n+    }\n+\n+    @Override\n+    Node processObjectLiteral(ObjectLiteral object) {\n+      return parent.processObjectLiteral(object);\n+    }\n+\n+    @Override\n+    Node processParenthesizedExpression(ParenthesizedExpression parenthesized) {\n+      return parent.processParenthesizedExpression(parenthesized);\n+    }\n+\n+    @Override\n+    Node processPropertyGet(PropertyGet getProp) {\n+      return parent.processPropertyGet(getProp);\n+    }\n+\n+    @Override\n+    Node processRegExpLiteral(RegExpLiteral regexp) {\n+      return parent.processRegExpLiteral(regexp);\n+    }\n+\n+    @Override\n+    Node processReturnStatement(ReturnStatement statement) {\n+      return parent.processReturnStatement(statement);\n+    }\n+\n+    @Override\n+    Node processStringLiteral(StringLiteral string) {\n+      return parent.processStringLiteral(string);\n+    }\n+\n+    @Override\n+    Node processSwitchCase(SwitchCase switchCase) {\n+      return parent.processSwitchCase(switchCase);\n+    }\n \n-      lp.setCharno(position2charno(lparenCharno));\n-      for (AstNode param : functionNode.getParams()) {\n-        lp.addChildToBack(transform(param));\n+    @Override\n+    Node processSwitchStatement(SwitchStatement statement) {\n+      return parent.processSwitchStatement(statement);\n+    }\n+\n+    @Override\n+    Node processThrowStatement(ThrowStatement statement) {\n+      return parent.processThrowStatement(statement);\n+    }\n+\n+    @Override\n+    Node processTryStatement(TryStatement statement) {\n+      return parent.processTryStatement(statement);\n+    }\n+\n+    @Override\n+    Node processUnaryExpression(UnaryExpression unary) {\n+      return parent.processUnaryExpression(unary);\n+    }\n+\n+    @Override\n+    Node processVariableDeclaration(VariableDeclaration declaration) {\n+      return parent.processVariableDeclaration(declaration);\n+    }\n+\n+    @Override\n+    Node processVariableInitializer(VariableInitializer initializer) {\n+      return parent.processVariableInitializer(initializer);\n+    }\n+\n+    @Override\n+    Node processWhileLoop(WhileLoop loop) {\n+      return parent.processWhileLoop(loop);\n+    }\n+\n+    @Override\n+    Node processWithStatement(WithStatement statement) {\n+      return parent.processWithStatement(statement);\n+    }\n+  }\n+\n+  IRFactory(\n+      CompilerOptions options,\n+      ErrorReporter errorReporter,\n+      boolean useBlockScope,\n+      boolean warningsGuardedByDiagnosticGroups,\n+      String sourceName,\n+      String sourceString) {\n+    this(\n+        options,\n+        errorReporter,\n+        useBlockScope,\n+        warningsGuardedByDiagnosticGroups,\n+        sourceName,\n+        sourceString,\n+        null);\n+  }\n+\n+  IRFactory(\n+      CompilerOptions options,\n+      ErrorReporter errorReporter,\n+      boolean useBlockScope,\n+      boolean warningsGuardedByDiagnosticGroups,\n+      String sourceName,\n+      String sourceString,\n+      Map<String, Source> moduleSourcesByName) {\n+    this.options = options;\n+    this.errorReporter = errorReporter;\n+    this.useBlockScope = useBlockScope;\n+    this.sourceName = sourceName;\n+    this.source = new Source(sourceName);\n+    this.source.length(sourceString.length());\n+    this.source.setOriginalCode(sourceString);\n+    this.source.setKind(SourceKind.STRONG);\n+    this.warningsGuardedByDiagnosticGroups = warningsGuardedByDiagnosticGroups;\n+    this.moduleSourcesByName = moduleSourcesByName == null\n+        ? ImmutableMap.<String, Source>of()\n+        : ImmutableMap.copyOf(moduleSourcesByName); \n+    this.emitUseStrict = options.needsEmitUseStrict();\n+    this.root = new Parser(options, errorReporter)\n+                   .parse(source, sourceString, 1);\n+    this.dispatcher = new TransformDispatcher(this);\n+  }\n+\n+  @Override\n+  public Node transform(Node n) {\n+    return (Node) n.visit(this.dispatcher);\n+  }\n+\n+  @Override\n+  public boolean canContinueTraversal() {\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal traversal, Node n, Node parent) {\n+    // Nothing to do.\n+  }\n+\n+  private Scope getEnclosingScope(NormalScope s) {\n+    Scope scope = s.getParentScope();\n+    return (scope instanceof NormalScope) ? scope : null;\n+  }\n+\n+  private Block createBlock(Node n) {\n+    return new Block(n);\n+  }\n+\n+  Node processBreakStatement(BreakStatement statement) {\n+    Node nameNode = null;\n+    Label label = statement.getLabel();\n+    if (label != null) {\n+      Node name = name(label.getName());\n+      nameNode = transform(name);\n+    }\n+    Node breakNode = new Node(Token.BREAK, nameNode);\n+    breakNode.setLineno(statement.getLineno());\n+    breakNode.setCharno(position2charno(statement.getAbsolutePosition()));\n+    return breakNode;\n+  }\n+\n+  Node processContinueStatement(ContinueStatement statement) {\n+    Node nameNode = null;\n+    Label label = statement.getLabel();\n+    if (label != null) {\n+      Node name = name(label.getName());\n+      nameNode = transform(name);\n+    }\n+    Node continueNode = new Node(Token.CONTINUE, nameNode);\n+    continueNode.setLineno(statement.getLineno());\n+    continueNode.setCharno(position2charno(statement.getAbsolutePosition()));\n+    return continueNode;\n+  }\n+\n+  private Node createBinary(int type, Node left, Node right) {\n+    Node node = new Node(type);\n+    node.addChildToBack(left);\n+    node.addChildToBack(right);\n+    return node;\n+  }\n+\n+  private Node createString(String value) {\n+    return new Node(Token.STRING, Node.newString(value));\n+  }\n+\n+  private Node createNumber(double value) {\n+    return new Node(Token.NUMBER, Node.newNumber(value));\n+  }\n+\n+  private Node createFunction(String name, Node params, Block body) {\n+    Node function = new Node(Token.FUNCTION,\n+                             createName(name),\n+                             params,\n+                             body);\n+    function.setIsArrowFunction(false);\n+    return function;\n+  }\n+\n+  private Node createName(String name) {\n+    return new Node(Token.NAME, Node.newString(name));\n+  }\n+\n+  private Node name(String name) {\n+    return createName(name);\n+  }\n+\n+  private Node createVarNodes(List<VarDeclaration> vars) {\n+    Node var = new Node(Token.VAR);\n+    for (VarDeclaration varDecl : vars) {\n+      Node name = createName(varDecl.getTarget().getIdentifier());\n+      Node value = null;\n+      if (varDecl.getInitializer() != null) {\n+        value = transform(varDecl.getInitializer());\n       }\n-      node.addChildToBack(lp);\n+      Node varNode = (value == null) ? name : createBinary(Token.ASSIGN, name, value);\n+      var.addChildToBack(varNode);\n+    }\n+    return var;\n+  }\n \n-      Node bodyNode = transform(functionNode.getBody());\n-      parseDirectives(bodyNode);\n-      node.addChildToBack(bodyNode);\n-     return node;\n+  private Node createObjectNodes(List<ObjectProperty> props) {\n+    Node object = new Node(Token.OBJECTLIT);\n+    for (ObjectProperty prop : props) {\n+      if (prop.isGetter()) {\n+        Node getProp =\n+            new Node(Token.GETTER_DEF, createName(prop.getKey().getIdentifier()), makeBody(prop));\n+        object.addChildToBack(getProp);\n+      } else if (prop.isSetter()) {\n+        Node setProp = new Node(Token.SETTER_DEF,\n+                                createName(prop.getKey().getIdentifier()),\n+                                makeParams(prop),\n+                                makeBody(prop));\n+        object.addChildToBack(setProp);\n+      } else {\n+        Node value = transform(prop.getRight());\n+        Node key = transform(prop.getLeft());\n+        Node objProp = new Node(Token.OBJECT_PROP_DEF, key, value);\n+        if (!prop.isShorthand()) {\n+          if (prop.isKindOf(ObjectProperty.Kind.GET)) {\n+            objProp.putProp(Node.IS_GETTER_PROP, prop);\n+          } else if (prop.isKindOf(ObjectProperty.Kind.SET)) {\n+            objProp.putProp(Node.IS_SETTER_PROP, prop);\n+          }\n+        }\n+        object.addChildToBack(objProp);\n+      }\n     }\n+    return object;\n+  }\n+\n+  private Node makeParams(ObjectProperty prop) {\n+    Node param = createName(prop.getParamName().getIdentifier());\n \n     @Override\n     Node processIfStatement(IfStatement statementNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}