{
    "patch": "    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    Node argList = getFunctionArgList(function);\n    boolean modifyCallers = modifyCallSites\n        && callSiteOptimizer.canModifyCallers(function);\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      if (!argList.hasChildren()) {\n        return;\n      }\n      Node currentNode = argList.getFirstChild();\n      Node lastReferencedNode = null;\n      Map<String, Node> referencedArgMap = Maps.newHashMap();\n      while (currentNode != null) {\n        Var var = fnScope.getVar(currentNode.getString());\n        boolean isReferenced = referenced.contains(var);\n        if (isReferenced) {\n          lastReferencedNode = currentNode;\n          // Remove from referenced list to simplify other logic below.\n          referenced.remove(var);\n        }\n        referencedArgMap.put(currentNode.getString(), currentNode);\n        currentNode = currentNode.getNext();\n        if (isReferenced && currentNode != null) {\n          // All args after the last referenced one and have no default value can be removed.\n          while (currentNode != null && !NodeUtil.mayHaveSideEffects(currentNode.getNext()) && !currentNode.getNext().isDefaultParam()) {\n            Node toRemove = currentNode;\n            currentNode = currentNode.getNext();\n            argList.removeChild(toRemove);\n            compiler.reportCodeChange();\n          }\n        }\n      }\n\n      // If there are still referenced args left, remove any unreferenced ones at the end of the list.\n      if (lastReferencedNode != null) {\n        currentNode = lastReferencedNode.getNext();\n        while (currentNode != null && !NodeUtil.mayHaveSideEffects(currentNode.getNext()) && !currentNode.getNext().isDefaultParam()) {\n          Node toRemove = currentNode;\n          currentNode = currentNode.getNext();\n          argList.removeChild(toRemove);\n          compiler.reportCodeChange();\n        }\n        // If the last referenced args are optional and have no default value, remove also any trailing args like the loop function of the for-loop pattern.\n        int numLastReferencedNodes = lastReferencedNode.getIndex() + 1;\n        if (numLastReferencedNodes < argList.getChildCount()) {\n          Node lastReferencedArg = argList.getChildAtIndex(numLastReferencedNodes - 1);\n          Node lastOptionalArg = argList.getChildAtIndex(argList.getChildCount() - 1);\n          if (!lastOptionalArg.hasChildren() && lastOptionalArg.isOptionalArg() && lastOptionalArg.hasChildren() == lastReferencedArg.hasChildren()) {\n            Node lraRemoved = false;\n            while (lastOptionalArg != null && !lastOptionalArg.isVarArgs() && !lastOptionalArg.isRest() && (lastOptionalArg.hasChildren() == lastReferencedArg.hasChildren())) {\n              Node toRemove = lastOptionalArg;\n              lastOptionalArg = lastOptionalArg.getPrevious();\n              argList.removeChild(toRemove);\n              lraRemoved = true;\n              compiler.reportCodeChange();\n            }\n            if (lraRemoved) {\n              // We removed the loop variable. Now let's test if we need to remove the iteration index variable.\n              if (argList.getChildCount() > 1) {\n                Node secondToLastNode = argList.getChildAtIndex(argList.getChildCount() - 2);\n                if (!secondToLastNode.hasChildren() && secondToLastNode.isOptionalArg() && secondToLastNode.hasNext() && secondToLastNode.getNext().isRest()) {\n                  Node toRemove = secondToLastNode;\n                  argList.removeChild(toRemove);\n                  compiler.reportCodeChange();\n                }\n              }\n            }\n          }\n        }\n      }\n\n      // Make sure that no parameter reference is broken.\n      fixParameterReferences(function, referencedArgMap, argList);\n    } else {\n      callSiteOptimizer.optimize(fnScope, referenced);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..7e2c5a4f 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,89 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    Node argList = getFunctionArgList(function);\n+    boolean modifyCallers = modifyCallSites\n+        && callSiteOptimizer.canModifyCallers(function);\n+    if (!modifyCallers) {\n+      // Strip unreferenced args off the end of the function declaration.\n+      if (!argList.hasChildren()) {\n+        return;\n+      }\n+      Node currentNode = argList.getFirstChild();\n+      Node lastReferencedNode = null;\n+      Map<String, Node> referencedArgMap = Maps.newHashMap();\n+      while (currentNode != null) {\n+        Var var = fnScope.getVar(currentNode.getString());\n+        boolean isReferenced = referenced.contains(var);\n+        if (isReferenced) {\n+          lastReferencedNode = currentNode;\n+          // Remove from referenced list to simplify other logic below.\n+          referenced.remove(var);\n+        }\n+        referencedArgMap.put(currentNode.getString(), currentNode);\n+        currentNode = currentNode.getNext();\n+        if (isReferenced && currentNode != null) {\n+          // All args after the last referenced one and have no default value can be removed.\n+          while (currentNode != null && !NodeUtil.mayHaveSideEffects(currentNode.getNext()) && !currentNode.getNext().isDefaultParam()) {\n+            Node toRemove = currentNode;\n+            currentNode = currentNode.getNext();\n+            argList.removeChild(toRemove);\n+            compiler.reportCodeChange();\n+          }\n+        }\n+      }\n+\n+      // If there are still referenced args left, remove any unreferenced ones at the end of the list.\n+      if (lastReferencedNode != null) {\n+        currentNode = lastReferencedNode.getNext();\n+        while (currentNode != null && !NodeUtil.mayHaveSideEffects(currentNode.getNext()) && !currentNode.getNext().isDefaultParam()) {\n+          Node toRemove = currentNode;\n+          currentNode = currentNode.getNext();\n+          argList.removeChild(toRemove);\n+          compiler.reportCodeChange();\n+        }\n+        // If the last referenced args are optional and have no default value, remove also any trailing args like the loop function of the for-loop pattern.\n+        int numLastReferencedNodes = lastReferencedNode.getIndex() + 1;\n+        if (numLastReferencedNodes < argList.getChildCount()) {\n+          Node lastReferencedArg = argList.getChildAtIndex(numLastReferencedNodes - 1);\n+          Node lastOptionalArg = argList.getChildAtIndex(argList.getChildCount() - 1);\n+          if (!lastOptionalArg.hasChildren() && lastOptionalArg.isOptionalArg() && lastOptionalArg.hasChildren() == lastReferencedArg.hasChildren()) {\n+            Node lraRemoved = false;\n+            while (lastOptionalArg != null && !lastOptionalArg.isVarArgs() && !lastOptionalArg.isRest() && (lastOptionalArg.hasChildren() == lastReferencedArg.hasChildren())) {\n+              Node toRemove = lastOptionalArg;\n+              lastOptionalArg = lastOptionalArg.getPrevious();\n+              argList.removeChild(toRemove);\n+              lraRemoved = true;\n+              compiler.reportCodeChange();\n+            }\n+            if (lraRemoved) {\n+              // We removed the loop variable. Now let's test if we need to remove the iteration index variable.\n+              if (argList.getChildCount() > 1) {\n+                Node secondToLastNode = argList.getChildAtIndex(argList.getChildCount() - 2);\n+                if (!secondToLastNode.hasChildren() && secondToLastNode.isOptionalArg() && secondToLastNode.hasNext() && secondToLastNode.getNext().isRest()) {\n+                  Node toRemove = secondToLastNode;\n+                  argList.removeChild(toRemove);\n+                  compiler.reportCodeChange();\n+                }\n+              }\n+            }\n+          }\n+        }\n+      }\n+\n+      // Make sure that no parameter reference is broken.\n+      fixParameterReferences(function, referencedArgMap, argList);\n+    } else {\n+      callSiteOptimizer.optimize(fnScope, referenced);\n+    }\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}