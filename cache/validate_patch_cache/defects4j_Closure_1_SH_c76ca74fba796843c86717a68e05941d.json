{
    "patch": "Node function = fnScope.getRootNode();\nPreconditions.checkState(function.isFunction());\n\nif (NodeUtil.isGetOrSetKey(function.getParent())) {\n  // The parameters object literal setters can not be removed.\n  return;\n}\n\nNode argList = getFunctionArgList(function);\n\nSet<String> referencedArgs = new HashSet<>();\n// Collect the referenced argument names.\n// Since function types are flattened, if we see a GETELEM or similar\n// that is directly indexing using a string literal which is a function\n// argument, add it to the referenced set also, since that argument is\n// effectively used in the function body code.\nNodeTraversal.traverseEs6(compiler, function, new NodeTraversal.AbstractScopedCallback() {\n  @Override\n  public void enterScope(NodeTraversal t) {}\n\n  @Override\n  public void exitScope(NodeTraversal t) {}\n\n  @Override\n  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n    if (parent != null && parent.isTemplateLit()) {\n      // Do not traverse into template literals, since they may contain potentially ambiguous\n      // referenced free variables. Consider the expression: `$` + x + `_`. We do not know at\n      // compile time whether that is a free variable reference or not.\n      return false;\n    }\n    return true;\n  }\n\n  @Override\n  public void visit(NodeTraversal t, Node n, Node parent) {\n    switch (n.getToken()) {\n      case FUNCTION:\n        // Do not traverse into inner functions.\n        if (n == function) {\n          break;\n        }\n        return;\n\n      case TEMPLATELIT: {\n        // Terminate traversal when encountering a template literal, for the same\n        // reasons that we do not traverse into template literals.\n        Node templateExpression = n.getFirstChild();\n        for (; templateExpression != null; templateExpression = templateExpression.getNext()) {\n          t.reportCodeChange(templateExpression);\n        }\n        // Template literals do not have references to function arguments or variables.\n        return;\n      }\n\n      case NAME:\n        // If a name is a reference to a parameter, add that parameter to the referenced set.\n        String varName = n.getString();\n        Var var = t.getScope().getVar(varName);\n        if (var != null && var.getParentNode() == argList) {\n          referencedArgs.add(varName);\n        }\n        return;\n\n      case GETPROP:\n      case OPTCHAIN_GETPROP:\n        if (n.getFirstChild().isName()) {\n          String propName = n.getLastChild().getString();\n          if (propName.equals(\"prototype\") || propName.equals(\"length\")) {\n            // Access to \"prototype\" or \"length\" does not reference the args.\n            return;\n          }\n        }\n        break;\n\n      case GETELEM:\n      case OPTCHAIN_GETELEM:\n        if (n.getFirstChild().isName()) {\n          Node key = n.getLastChild();\n          if (key.isString()) {\n            String keyName = key.getString();\n            if (NodeUtil.isLValue(n)) {\n              // If this GETELEM is actually a SETELEM, then we can't safely remove the argument,\n              // since doing so will cause the argument values to be undef for any CALLs to this\n              // function afterwards.\n              return;\n            }\n            Var var = t.getScope().getVar(keyName);\n            if (var == null) {\n              // The var is not defined, so it is not an argument.\n              return;\n            }\n            if (!var.getParentNode().isParamList() || referencedArgs.contains(keyName)) {\n              // The var is not a function parameter, or it has already been referenced in the code.\n              return;\n            }\n            // Add the argument to the referenced set.\n            referencedArgs.add(keyName);\n            return;\n          }\n        }\n        break;\n\n      default:\n        break;\n    }\n  }\n});\n\n// Strip unreferenced args off the end of the function declaration.\nNode lastArg = argList.getLastChild();\nwhile (lastArg != null && !referencedArgs.contains(lastArg.getString())) {\n  argList.removeChild(lastArg);\n  compiler.reportCodeChange();\n  lastArg = argList.getLastChild();\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..9019ecb3 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,122 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+Node function = fnScope.getRootNode();\n+Preconditions.checkState(function.isFunction());\n+\n+if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+  // The parameters object literal setters can not be removed.\n+  return;\n+}\n+\n+Node argList = getFunctionArgList(function);\n+\n+Set<String> referencedArgs = new HashSet<>();\n+// Collect the referenced argument names.\n+// Since function types are flattened, if we see a GETELEM or similar\n+// that is directly indexing using a string literal which is a function\n+// argument, add it to the referenced set also, since that argument is\n+// effectively used in the function body code.\n+NodeTraversal.traverseEs6(compiler, function, new NodeTraversal.AbstractScopedCallback() {\n+  @Override\n+  public void enterScope(NodeTraversal t) {}\n+\n+  @Override\n+  public void exitScope(NodeTraversal t) {}\n+\n+  @Override\n+  public boolean shouldTraverse(NodeTraversal t, Node n, Node parent) {\n+    if (parent != null && parent.isTemplateLit()) {\n+      // Do not traverse into template literals, since they may contain potentially ambiguous\n+      // referenced free variables. Consider the expression: `$` + x + `_`. We do not know at\n+      // compile time whether that is a free variable reference or not.\n+      return false;\n+    }\n+    return true;\n+  }\n+\n+  @Override\n+  public void visit(NodeTraversal t, Node n, Node parent) {\n+    switch (n.getToken()) {\n+      case FUNCTION:\n+        // Do not traverse into inner functions.\n+        if (n == function) {\n+          break;\n+        }\n+        return;\n+\n+      case TEMPLATELIT: {\n+        // Terminate traversal when encountering a template literal, for the same\n+        // reasons that we do not traverse into template literals.\n+        Node templateExpression = n.getFirstChild();\n+        for (; templateExpression != null; templateExpression = templateExpression.getNext()) {\n+          t.reportCodeChange(templateExpression);\n+        }\n+        // Template literals do not have references to function arguments or variables.\n+        return;\n+      }\n+\n+      case NAME:\n+        // If a name is a reference to a parameter, add that parameter to the referenced set.\n+        String varName = n.getString();\n+        Var var = t.getScope().getVar(varName);\n+        if (var != null && var.getParentNode() == argList) {\n+          referencedArgs.add(varName);\n+        }\n+        return;\n+\n+      case GETPROP:\n+      case OPTCHAIN_GETPROP:\n+        if (n.getFirstChild().isName()) {\n+          String propName = n.getLastChild().getString();\n+          if (propName.equals(\"prototype\") || propName.equals(\"length\")) {\n+            // Access to \"prototype\" or \"length\" does not reference the args.\n+            return;\n+          }\n+        }\n+        break;\n+\n+      case GETELEM:\n+      case OPTCHAIN_GETELEM:\n+        if (n.getFirstChild().isName()) {\n+          Node key = n.getLastChild();\n+          if (key.isString()) {\n+            String keyName = key.getString();\n+            if (NodeUtil.isLValue(n)) {\n+              // If this GETELEM is actually a SETELEM, then we can't safely remove the argument,\n+              // since doing so will cause the argument values to be undef for any CALLs to this\n+              // function afterwards.\n+              return;\n+            }\n+            Var var = t.getScope().getVar(keyName);\n+            if (var == null) {\n+              // The var is not defined, so it is not an argument.\n+              return;\n+            }\n+            if (!var.getParentNode().isParamList() || referencedArgs.contains(keyName)) {\n+              // The var is not a function parameter, or it has already been referenced in the code.\n+              return;\n+            }\n+            // Add the argument to the referenced set.\n+            referencedArgs.add(keyName);\n+            return;\n+          }\n+        }\n+        break;\n+\n+      default:\n+        break;\n+    }\n+  }\n+});\n+\n+// Strip unreferenced args off the end of the function declaration.\n+Node lastArg = argList.getLastChild();\n+while (lastArg != null && !referencedArgs.contains(lastArg.getString())) {\n+  argList.removeChild(lastArg);\n+  compiler.reportCodeChange();\n+  lastArg = argList.getLastChild();\n+}\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}