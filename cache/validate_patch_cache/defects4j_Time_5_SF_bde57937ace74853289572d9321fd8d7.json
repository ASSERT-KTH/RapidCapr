{
    "patch": "public Period normalizedStandard(PeriodType type) {\n    // Compute the total duration in milliseconds\n    long millis = getMillis();\n    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n    \n    // Split the input period into years, months, and days to handle normalization\n    int inputYears = getYears() + (getMonths() / 12);\n    int inputMonths = getMonths() % 12;\n    int inputDays = getDays();\n\n    // Remove the years and months from the duration by creating a temporary period\n    Period temp = new Period(millis, type, ISOChronology.getInstanceUTC())\n            .withYears(0)\n            .withMonths(0);\n\n    // Recursively add back the years and months until the period is normalized\n    return addYearsAndMonths(temp, inputYears, inputMonths, inputDays, type);\n}\n\nprivate Period addYearsAndMonths(Period period, int years, int months, int days, PeriodType type) {\n    Period result = period;\n    int currentYears = result.getYears() + years;\n    int currentMonths = result.getMonths() + months;\n    // Normalize months to have a value between 0 and 11\n    int normalizedMonths = (currentMonths % 12 + 12) % 12;\n    int overflowMonths = (currentMonths / 12) + (currentYears < 0 ? -1 : 0);\n    int overflowYears = (currentYears - overflowMonths) / FieldUtils.safeToInt(DateTimeConstants.YEARS_PER_PERIOD);\n    int newYears = FieldUtils.safeAdd(currentYears, overflowYears);\n    int newMonths = FieldUtils.safeAdd(normalizedMonths, overflowMonths * 12);\n    result = result.withYears(newYears).withMonths(newMonths);\n    // If the result has changed, repeat the process recursively\n    if (result != period) {\n        return addYearsAndMonths(result, 0, 0, days, type);\n    }\n    // Otherwise, add the remaining days and return the normalized period\n    return result.withDays(FieldUtils.safeAdd(result.getDays(), days)).normalizedStandard(type);\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/Period.java b/src/main/java/org/joda/time/Period.java\nindex f4047933..5d58b68c 100644\n--- a/src/main/java/org/joda/time/Period.java\n+++ b/src/main/java/org/joda/time/Period.java\n@@ -1613,28 +1613,46 @@ public final class Period\n      *  years or months but the specified period type does not support them\n      * @since 1.5\n      */\n-    public Period normalizedStandard(PeriodType type) {\n-        type = DateTimeUtils.getPeriodType(type);\n-        long millis = getMillis();  // no overflow can happen, even with Integer.MAX_VALUEs\n-        millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n-        millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n-        millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n-        millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n-        millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n-        Period result = new Period(millis, type, ISOChronology.getInstanceUTC());\n-        int years = getYears();\n-        int months = getMonths();\n-        if (years != 0 || months != 0) {\n-            years = FieldUtils.safeAdd(years, months / 12);\n-            months = months % 12;\n-            if (years != 0) {\n-                result = result.withYears(years);\n-            }\n-            if (months != 0) {\n-                result = result.withMonths(months);\n-            }\n-        }\n-        return result;\n-    }\n+public Period normalizedStandard(PeriodType type) {\n+    // Compute the total duration in milliseconds\n+    long millis = getMillis();\n+    millis += (((long) getSeconds()) * ((long) DateTimeConstants.MILLIS_PER_SECOND));\n+    millis += (((long) getMinutes()) * ((long) DateTimeConstants.MILLIS_PER_MINUTE));\n+    millis += (((long) getHours()) * ((long) DateTimeConstants.MILLIS_PER_HOUR));\n+    millis += (((long) getDays()) * ((long) DateTimeConstants.MILLIS_PER_DAY));\n+    millis += (((long) getWeeks()) * ((long) DateTimeConstants.MILLIS_PER_WEEK));\n+    \n+    // Split the input period into years, months, and days to handle normalization\n+    int inputYears = getYears() + (getMonths() / 12);\n+    int inputMonths = getMonths() % 12;\n+    int inputDays = getDays();\n+\n+    // Remove the years and months from the duration by creating a temporary period\n+    Period temp = new Period(millis, type, ISOChronology.getInstanceUTC())\n+            .withYears(0)\n+            .withMonths(0);\n+\n+    // Recursively add back the years and months until the period is normalized\n+    return addYearsAndMonths(temp, inputYears, inputMonths, inputDays, type);\n+}\n+\n+private Period addYearsAndMonths(Period period, int years, int months, int days, PeriodType type) {\n+    Period result = period;\n+    int currentYears = result.getYears() + years;\n+    int currentMonths = result.getMonths() + months;\n+    // Normalize months to have a value between 0 and 11\n+    int normalizedMonths = (currentMonths % 12 + 12) % 12;\n+    int overflowMonths = (currentMonths / 12) + (currentYears < 0 ? -1 : 0);\n+    int overflowYears = (currentYears - overflowMonths) / FieldUtils.safeToInt(DateTimeConstants.YEARS_PER_PERIOD);\n+    int newYears = FieldUtils.safeAdd(currentYears, overflowYears);\n+    int newMonths = FieldUtils.safeAdd(normalizedMonths, overflowMonths * 12);\n+    result = result.withYears(newYears).withMonths(newMonths);\n+    // If the result has changed, repeat the process recursively\n+    if (result != period) {\n+        return addYearsAndMonths(result, 0, 0, days, type);\n+    }\n+    // Otherwise, add the remaining days and return the normalized period\n+    return result.withDays(FieldUtils.safeAdd(result.getDays(), days)).normalizedStandard(type);\n+}\n \n }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}