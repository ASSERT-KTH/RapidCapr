{
    "patch": "    Node function = fnScope.getRootNode();\n\n    Preconditions.checkState(function.isFunction());\n    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n      // The parameters object literal setters can not be removed.\n      return;\n    }\n\n    // visited will be populated with vars that are referenced,\n    // so we can ignore them. instead of walking the function\n    // body, because that's slow, we use the compiler's scope\n    // analysis to avoid var lookups\n    Set<Var> visited = Sets.newIdentityHashSet();\n    visited.addAll(referenced);\n\n    List<Node> argsToRemove = Lists.newArrayList();\n\n    Node param = getFunctionParamFirstChild(function);\n    while (param != null) {\n      boolean found = false;\n      String paramName = param.getString();\n\n      for (Var v : visited) {\n        if (v.getName().equals(paramName)) {\n          found = true;\n          break;\n        }\n      }\n\n      if (!found) {\n        argsToRemove.add(param);\n      } else {\n        // if we've found a used param, then all later params\n        // are used as well\n        visited.addAll(fnScope.getVar(paramName).getReferences());\n      }\n\n      param = param.getNext();\n    }\n\n    for (Node arg : argsToRemove) {\n      NodeUtil.removeChild(getFunctionArgs(function), arg);\n      compiler.reportCodeChange();\n    }\n\n    assertNode(function);",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..5a1ef229 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,52 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    Node function = fnScope.getRootNode();\n+\n+    Preconditions.checkState(function.isFunction());\n+    if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+      // The parameters object literal setters can not be removed.\n+      return;\n+    }\n+\n+    // visited will be populated with vars that are referenced,\n+    // so we can ignore them. instead of walking the function\n+    // body, because that's slow, we use the compiler's scope\n+    // analysis to avoid var lookups\n+    Set<Var> visited = Sets.newIdentityHashSet();\n+    visited.addAll(referenced);\n+\n+    List<Node> argsToRemove = Lists.newArrayList();\n+\n+    Node param = getFunctionParamFirstChild(function);\n+    while (param != null) {\n+      boolean found = false;\n+      String paramName = param.getString();\n+\n+      for (Var v : visited) {\n+        if (v.getName().equals(paramName)) {\n+          found = true;\n+          break;\n+        }\n+      }\n+\n+      if (!found) {\n+        argsToRemove.add(param);\n+      } else {\n+        // if we've found a used param, then all later params\n+        // are used as well\n+        visited.addAll(fnScope.getVar(paramName).getReferences());\n+      }\n+\n+      param = param.getNext();\n+    }\n+\n+    for (Node arg : argsToRemove) {\n+      NodeUtil.removeChild(getFunctionArgs(function), arg);\n+      compiler.reportCodeChange();\n+    }\n+\n+    assertNode(function);\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}