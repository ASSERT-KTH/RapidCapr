{
    "patch": "private Calendar toCalendar(Date date) {\n    Calendar calendar = Calendar.getInstance(getTimeZone(), getLocale());\n    calendar.setTime(date);\n    return calendar;\n}\n\npublic Date parse(String input) throws ParseException {\n    SimpleDateFormatter sdf = new SimpleDateFormatter();\n    Date parsedDate = sdf.parse(input);\n    if (parsedDate == null) {\n        return null;\n    }\n    Calendar calendar = toCalendar(parsedDate);\n   \tint year = calendar.get(Calendar.YEAR);\n    if (year > thisYear + 3 || year < thisYear - 80) {\n        return null;\n    }\n    KeyValue[] parsedValues = new KeyValue[strategies.length];\n    Matcher matcher = parsePattern.matcher(input);\n    if (!matcher.matches()) {\n        return null;\n    }\n    for (int i = 0; i < strategies.length; i++) {\n        parsedValues[i] = strategies[i].parse(this, matcher.group(i + 1));\n    }\n    int nameIndex = matcher.groupCount() - 1;\n    if (nameIndex > 0 && nameValues.containsKey(year)) {\n        KeyValue[] values = nameValues.get(year);\n        for (KeyValue value : values) {\n            if (value.value.equals(matcher.group(nameIndex))) {\n                for (int i = 0; i < parsedValues.length; i++) {\n                    if (value.key.fields.contains(parsedValues[i].key)) {\n                        parsedValues[i] = new KeyValue(parsedValues[i].key, value.key.matchingValue);\n                    }\n                }\n            }\n        }\n    }\n    return toCalendar(new CompositeKey(parsedValues).toDate(this)).getTime();\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\nindex 8df302f9..6ffc7fc8 100644\n--- a/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n+++ b/src/main/java/org/apache/commons/lang3/time/FastDateParser.java\n@@ -112,42 +112,46 @@ public class FastDateParser implements DateParser, Serializable {\n      * Initialize derived fields from defining fields.\n      * This is called from constructor and from readObject (de-serialization)\n      */\n-    private void init() {\n-        thisYear= Calendar.getInstance(timeZone, locale).get(Calendar.YEAR);\n-\n-        nameValues= new ConcurrentHashMap<Integer, KeyValue[]>();\n-\n-        StringBuilder regex= new StringBuilder();\n-        List<Strategy> collector = new ArrayList<Strategy>();\n-\n-        Matcher patternMatcher= formatPattern.matcher(pattern);\n-        if(!patternMatcher.lookingAt()) {\n-            throw new IllegalArgumentException(\"Invalid pattern\");\n-        }\n+private Calendar toCalendar(Date date) {\n+    Calendar calendar = Calendar.getInstance(getTimeZone(), getLocale());\n+    calendar.setTime(date);\n+    return calendar;\n+}\n \n-        currentFormatField= patternMatcher.group();\n-        Strategy currentStrategy= getStrategy(currentFormatField);\n-        for(;;) {\n-            patternMatcher.region(patternMatcher.end(), patternMatcher.regionEnd());\n-            if(!patternMatcher.lookingAt()) {\n-                nextStrategy = null;\n-                break;\n-            }\n-            String nextFormatField= patternMatcher.group();\n-            nextStrategy = getStrategy(nextFormatField);\n-            if(currentStrategy.addRegex(this, regex)) {\n-                collector.add(currentStrategy);\n+public Date parse(String input) throws ParseException {\n+    SimpleDateFormatter sdf = new SimpleDateFormatter();\n+    Date parsedDate = sdf.parse(input);\n+    if (parsedDate == null) {\n+        return null;\n+    }\n+    Calendar calendar = toCalendar(parsedDate);\n+   \tint year = calendar.get(Calendar.YEAR);\n+    if (year > thisYear + 3 || year < thisYear - 80) {\n+        return null;\n+    }\n+    KeyValue[] parsedValues = new KeyValue[strategies.length];\n+    Matcher matcher = parsePattern.matcher(input);\n+    if (!matcher.matches()) {\n+        return null;\n+    }\n+    for (int i = 0; i < strategies.length; i++) {\n+        parsedValues[i] = strategies[i].parse(this, matcher.group(i + 1));\n+    }\n+    int nameIndex = matcher.groupCount() - 1;\n+    if (nameIndex > 0 && nameValues.containsKey(year)) {\n+        KeyValue[] values = nameValues.get(year);\n+        for (KeyValue value : values) {\n+            if (value.value.equals(matcher.group(nameIndex))) {\n+                for (int i = 0; i < parsedValues.length; i++) {\n+                    if (value.key.fields.contains(parsedValues[i].key)) {\n+                        parsedValues[i] = new KeyValue(parsedValues[i].key, value.key.matchingValue);\n+                    }\n+                }\n             }\n-            currentFormatField= nextFormatField;\n-            currentStrategy= nextStrategy;\n-        }\n-        if(currentStrategy.addRegex(this, regex)) {\n-            collector.add(currentStrategy);\n         }\n-        currentFormatField= null;\n-        strategies= collector.toArray(new Strategy[collector.size()]);\n-        parsePattern= Pattern.compile(regex.toString());\n     }\n+    return toCalendar(new CompositeKey(parsedValues).toDate(this)).getTime();\n+}\n \n     // Accessors\n     //-----------------------------------------------------------------------",
    "result_reason": "error: method parse(String) is already defined in class FastDateParser",
    "test_result": "ERROR"
}