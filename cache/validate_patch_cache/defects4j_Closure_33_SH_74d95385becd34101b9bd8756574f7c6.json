{
    "patch": "    if (getType().isObjectLiteral()) {\n\n      // Handle the case where the constraint object is a record type.\n      //\n      // param constraintObj {{prop: (number|undefined)}}\n      // function f(constraintObj) {}\n      // f({});\n      //\n      // We want to modify the object literal to match the constraint, by\n      // taking each property on the record and trying to match\n      // properties on this object.\n      if (constraintObj.isRecordType()) {\n        for (String prop : constraintObj.getOwnPropertyNames()) {\n          JSType propType = constraintObj.getPropertyType(prop);\n          if (!isPropertyTypeDeclared(prop)) {\n            JSType typeToInfer = propType;\n            if (!hasProperty(prop)) {\n              typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n                  .getLeastSupertype(propType);\n            }\n            if (getDeclaredPropertyNames().contains(prop)) {\n              // If a property already exists with this name, it may need\n              // to have its type updated. For example, if we have:\n              //\n              //     /**\n              //      * @param {{prop: boolean}} obj\n              //      */\n              //     function f(obj) {\n              //       obj.prop = 123;\n              //     }\n              //\n              // then we want to warn that obj.prop is not being inferred\n              // as a boolean:\n              //\n              //     warning: assignment to property prop of obj\n              //              with inferred type number,\n              //              which does not satisfy declared type boolean\n              //\n              // so we need to ensure that obj.prop is set to its least\n              // supertype.\n              JSType originalType = getDeclaredPropertyType(prop);\n              if (!originalType.isSubtype(propType)) {\n                JSType leastSupertype =\n                    originalType.getLeastSupertype(propType);\n                // We don't want to update declared types to UNKNOWN or\n                // BOTTOM, because this can lead to false positives if the\n                // property is later used in a type-sensitive context.\n                if (leastSupertype.isUnknownType()\n                    || leastSupertype.isBottom()) {\n                  leastSupertype = originalType;\n                }\n                updateDeclaredPropertyType(prop, leastSupertype);\n              }\n            } else {\n              defineInferredProperty(prop, typeToInfer, null);\n            }\n          }\n        }\n      }\n\n      // Handle the case where the constraint object is a union of types.\n      //\n      // param constraintObj {(string|null)} or {function(new:?)}\n      // function f(constraintObj) {}\n      // f('');\n      // f(Math.random)\n      // We want to add all types in the union to this object.\n      JSType thisType = getType();\n      if (constraintObj.isUnionType()) {\n        for (JSType unionType : constraintObj.getUnionMembers()) {\n          if (!unionType.isUnknownType() && !unionType.isBottom()) {\n            JSType typeToInfer =\n                thisType.getLeastSupertypeWithUndefinedAndNull(unionType);\n            thisType = thisType.getGreatestSubtype(typeToInfer);\n            setType(thisType);\n          }\n        }\n      } else if (!constraintObj.isUnknownType() && !constraintObj.isBottom()) {\n        JSType typeToInfer =\n            thisType.getLeastSupertypeWithUndefinedAndNull(constraintObj);\n        thisType = thisType.getGreatestSubtype(typeToInfer);\n        setType(thisType);",
    "patch_diff": "diff --git a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\nindex b6e3fc78..26c550e5 100644\n--- a/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n+++ b/src/com/google/javascript/rhino/jstype/PrototypeObjectType.java\n@@ -554,6 +554,88 @@ class PrototypeObjectType extends ObjectType {\n   @Override\n   public void matchConstraint(ObjectType constraintObj) {\n     // We only want to match contraints on anonymous types.\n+    if (getType().isObjectLiteral()) {\n+\n+      // Handle the case where the constraint object is a record type.\n+      //\n+      // param constraintObj {{prop: (number|undefined)}}\n+      // function f(constraintObj) {}\n+      // f({});\n+      //\n+      // We want to modify the object literal to match the constraint, by\n+      // taking each property on the record and trying to match\n+      // properties on this object.\n+      if (constraintObj.isRecordType()) {\n+        for (String prop : constraintObj.getOwnPropertyNames()) {\n+          JSType propType = constraintObj.getPropertyType(prop);\n+          if (!isPropertyTypeDeclared(prop)) {\n+            JSType typeToInfer = propType;\n+            if (!hasProperty(prop)) {\n+              typeToInfer = getNativeType(JSTypeNative.VOID_TYPE)\n+                  .getLeastSupertype(propType);\n+            }\n+            if (getDeclaredPropertyNames().contains(prop)) {\n+              // If a property already exists with this name, it may need\n+              // to have its type updated. For example, if we have:\n+              //\n+              //     /**\n+              //      * @param {{prop: boolean}} obj\n+              //      */\n+              //     function f(obj) {\n+              //       obj.prop = 123;\n+              //     }\n+              //\n+              // then we want to warn that obj.prop is not being inferred\n+              // as a boolean:\n+              //\n+              //     warning: assignment to property prop of obj\n+              //              with inferred type number,\n+              //              which does not satisfy declared type boolean\n+              //\n+              // so we need to ensure that obj.prop is set to its least\n+              // supertype.\n+              JSType originalType = getDeclaredPropertyType(prop);\n+              if (!originalType.isSubtype(propType)) {\n+                JSType leastSupertype =\n+                    originalType.getLeastSupertype(propType);\n+                // We don't want to update declared types to UNKNOWN or\n+                // BOTTOM, because this can lead to false positives if the\n+                // property is later used in a type-sensitive context.\n+                if (leastSupertype.isUnknownType()\n+                    || leastSupertype.isBottom()) {\n+                  leastSupertype = originalType;\n+                }\n+                updateDeclaredPropertyType(prop, leastSupertype);\n+              }\n+            } else {\n+              defineInferredProperty(prop, typeToInfer, null);\n+            }\n+          }\n+        }\n+      }\n+\n+      // Handle the case where the constraint object is a union of types.\n+      //\n+      // param constraintObj {(string|null)} or {function(new:?)}\n+      // function f(constraintObj) {}\n+      // f('');\n+      // f(Math.random)\n+      // We want to add all types in the union to this object.\n+      JSType thisType = getType();\n+      if (constraintObj.isUnionType()) {\n+        for (JSType unionType : constraintObj.getUnionMembers()) {\n+          if (!unionType.isUnknownType() && !unionType.isBottom()) {\n+            JSType typeToInfer =\n+                thisType.getLeastSupertypeWithUndefinedAndNull(unionType);\n+            thisType = thisType.getGreatestSubtype(typeToInfer);\n+            setType(thisType);\n+          }\n+        }\n+      } else if (!constraintObj.isUnknownType() && !constraintObj.isBottom()) {\n+        JSType typeToInfer =\n+            thisType.getLeastSupertypeWithUndefinedAndNull(constraintObj);\n+        thisType = thisType.getGreatestSubtype(typeToInfer);\n+        setType(thisType);\n \n     // Handle the case where the constraint object is a record type.\n     //",
    "result_reason": "error: reached end of file while parsing",
    "test_result": "ERROR"
}