{
    "patch": "import org.apache.commons.math3.util.FastMath;\n\npublic class GammaFunction {\n\n    private static final double DEFAULT_EPSILON = 1e-9;\n\n    public static double regularizedGamma(double a, double x) {\n        return regularizedGamma(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n\n    public static double regularizedGamma(double a, double x, double epsilon, int maxIterations) {\n        if (Double.isNaN(a) || Double.isNaN(x) || FastMath.abs(a) < 1e-5) {\n            return Double.NaN;\n        }\n\n        if (x <= 0.0) {\n            return 0.0;\n        }\n\n        if (x >= a + 1.0) {\n            return 1.0 - regularizedGammaComplement(a, x, epsilon, maxIterations);\n        }\n\n        double n = 0.0; // nth term of the infinite series representation\n        double an = x / a; // nth term of the infinite series representation\n        double sum = an; // sum of series up until nth term\n        while (FastMath.abs(an / sum) > epsilon && n < maxIterations - 1) {\n            n += 1.0;\n            an *= x / (a + n);\n            sum += an;\n        }\n\n        return FastMath.exp(-x + a * FastMath.log(x) - logGamma(a)) * sum / a;\n    }\n\n    public static double regularizedGammaComplement(final double a, final double x) {\n        return regularizedGammaComplement(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n\n    public static double regularizedGammaComplement(double a, double x, double epsilon, int maxIterations) {\n        if (Double.isNaN(a) || Double.isNaN(x) || FastMath.abs(a) < 1e-5) {\n            return Double.NaN;\n        }\n\n        if (x <= 0.0) {\n            return 1.0;\n        }\n\n        if (x < a + 1.0) {\n            return 1.0 - regularizedGamma(a, x, epsilon, maxIterations);\n        }\n\n        // Continued fraction representation\n        double f = continuedFraction(a, x, epsilon, maxIterations);\n        return FastMath.exp(-x + a * FastMath.log(x) - logGamma(a)) / f;\n    }\n\n    public static double logGamma(double x) {\n        if (Double.isNaN(x) || x <= 0.0) {\n            return Double.NaN;\n        }\n\n        if (x < 0.5) {\n            return logGamma1p(x) - FastMath.log(x);\n        }\n\n        if (x <= 2.5) {\n            return logGamma1p((x - 0.5) - 0.5);\n        }\n\n        if (x <= 8.0) {\n            int n = (int)(FastMath.floor(x - 1.5));\n            double prod = 1.0;\n            for (int i = 1; i <= n; i++) {\n                prod *= (x - i) / (i + 0.5);\n            }\n\n            return logGamma1p(x - (n + 1.5)) + FastMath.log(prod);\n        }\n\n        double sum = lanczos(x);\n        double tmp = x + LANCZOS_G + .5;\n        return ((x + .5) * FastMath.log(tmp)) - tmp + HALF_LOG_2_PI + FastMath.log(sum / x);\n    }\n\n    public static double logGamma1p(double x) {\n        double ret;\n        if (x < -0.5 || x > 1.5) {\n            return FastMath.log(GammaFunction.gamma1p(x));\n        }\n        ret = Gamma.logGamma(x + 1.0);\n        if (Double.isNaN(ret)) {\n            return ret;\n        }\n        return ret;\n    }\n\n    private static final double[] LANCZOS = {\n            0.99999999999999709182,\n            57.156235665862923517,\n            -59.597960355475491248,\n            14.136097974741747174,\n            -0.49191381609762019978,\n            .33994649984811888699e-4,\n            .46523628927048575665e-4,\n            -.98374475304879564677e-4,\n            .15808870322491248884e-3,\n            -.21026444172410488319e-3,\n            .21743961811521264320e-3,\n            -.16431810653676389022e-3,\n            .84418223983852743293e-4,\n            -.26190838401581408670e-4,\n            .36899182659531622704e-5,\n    };\n    private static final double HALF_LOG_2_PI = FastMath.log(Math.PI) / 2.0;\n\n    private static final double LANCZOS_G = 607.0 / 128.0;\n\n    public static double lanczos(double x) {\n        double sum = 0.0;\n        for (int i = LANCZOS.length - 1; i > 0; --i) {\n            sum += LANCZOS[i] / (x + i);\n        }\n        return sum + LANCZOS[0];\n    }\n\n    public static double gamma1p(double x) {\n\n        /* split up integration to avoid sharp peak */\n        if (x < -0.5) {\n            return Math.PI / (FastMath.sin(Math.PI * x) * GammaFunction.gamma1p(1.0 + x));\n        }\n        if (x < 1.5) {\n            return GAMMA + ((x - 0.5) * GammaFunction.gamma1p(x + 0.5));\n        }\n        if (x > 2.5) {\n            return (x - 1.0) * GammaFunction.gamma1p(x - 1.0);\n        }\n\n        double t = x - 1.0;\n        double resul = 0.0;\n        double fact = 1.0;\n        double inc = 1.0;\n\n        /* continued fraction */\n        for (int i = 0; i < 6; i++) {\n            inc *= t;\n            fact *= (i + 1);\n            resul += inc / fact;\n        }\n        resul *= t;\n        resul += 1.0;\n        resul = -Math.log(resul);\n\n        return resul;\n    }\n\n    public static double continuedFraction(final double a, final double x, final double epsilon, final int maxIterations) {\n        double small = 1e-50;\n        double hPrev = 1.0;\n        double aPrev = x;\n        double bPrev = x + 1 - a;\n        double aCurr = bPrev * x;\n        double bCurr = bPrev + 1;\n        double n = 2.0;\n        while (n <= maxIterations) {\n            final double aNext = bCurr * aCurr + n * aPrev;\n            final double bNext = bCurr * bPrev + n * bPrev * (x + n - a);\n            if (aNext * bPrev < bNext * small) {\n                bNext = bNext * small;\n                aNext = aNext * small;\n            }\n            if (aNext * bPrev <= bNext * epsilon) {\n                return aNext / bNext;\n            }\n            aPrev = aCurr;\n            bPrev = bCurr;\n            aCurr = aNext;\n            bCurr = bNext;\n            n += 1.0;\n        }\n        return aCurr / bCurr;\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}