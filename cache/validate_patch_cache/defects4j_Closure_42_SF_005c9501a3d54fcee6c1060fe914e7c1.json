{
    "patch": "import org.mozilla.javascript.ErrorReporter;\nimport org.mozilla.javascript.Node;\nimport org.mozilla.javascript.Token;\nimport org.mozilla.javascript.ast.*;\n\nimport java.util.ArrayList;\nimport java.util.List;\n\nclass TransformDispatcher implements NodeVisitor {\n\n    private static final String ALLOWED_DIRECTIVES = \"__allow_directive__\";\n    private static final String SECRET_FLAG_PREFIX = \"zj\";\n\n    private final ErrorReporter errorReporter;\n    private final String sourceName;\n\n    public TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n        this.errorReporter = errorReporter;\n        this.sourceName = sourceName;\n    }\n\n    protected Node newNode(int type) {\n        return new Node(type);\n    }\n\n    protected Node newNode(int type, AstNode child) {\n        Node n = new Node(type);\n        n.addChildToBack(transform(child));\n        return n;\n    }\n\n    protected Node newNode(int type, AstNode child1, AstNode child2) {\n        Node n = new Node(type);\n        n.addChildToBack(transform(child1));\n        n.addChildToBack(transform(child2));\n        return n;\n    }\n\n    protected Node newNode(int type, AstNode child1, AstNode child2, AstNode child3) {\n        Node n = new Node(type);\n        n.addChildToBack(transform(child1));\n        n.addChildToBack(transform(child2));\n        n.addChildToBack(transform(child3));\n        return n;\n    }\n\n    protected Node transformGeneric(AstNode n) {\n        if (n == null) return newNode(Token.EMPTY);\n\n        if (n instanceof Name) {\n            Name name = (Name)n;\n            Node node = new Node(Token.NAME, name.getIdentifier());\n\n            if (isDirective(n.getParent())) {\n                node.putIntProp(Node.IS_DIRECTIVE, 1);\n            }\n            \n            return node;\n        }\n\n        if (n instanceof ParenthesizedExpression) {\n            return transform(((ParenthesizedExpression)n).getExpression());\n        }\n\n        if (n instanceof StringLiteral) return new Node(Token.STRING, n.getString());\n        if (n instanceof NumberLiteral) return Node.newNumber(n.getDouble());\n        if (n instanceof FunctionNode) return processFunction((FunctionNode) n);\n        if (n instanceof ReturnStatement) return processReturnStatement((ReturnStatement) n);\n        if (n instanceof IfStatement) return processIfStatement((IfStatement) n);\n        if (n instanceof SwitchStatement) return processSwitchStatement((SwitchStatement) n);\n        if (n instanceof SwitchCase) return processSwitchCase((SwitchCase) n);\n        if (n instanceof BreakStatement) return processBreakStatement((BreakStatement) n);\n        if (n instanceof ContinueStatement) return processContinueStatement((ContinueStatement) n);\n        if (n instanceof TryStatement) return processTryStatement((TryStatement) n);\n        if (n instanceof Block) return processBlock((Block) n);\n        if (n instanceof ExpressionStatement) return processExpressionStatement((ExpressionStatement) n);\n        if (n instanceof WhileLoop) return processWhileLoop((WhileLoop) n);\n        if (n instanceof DoLoop) return processDoLoop((DoLoop) n);\n        if (n instanceof ForLoop) return processForLoop((ForLoop) n);\n        if (n instanceof ForInLoop) return processForInLoop((ForInLoop) n);\n        if (n instanceof InfixExpression) return processInfixExpression((InfixExpression) n);\n        if (n instanceof UnaryExpression) return processUnaryExpression((UnaryExpression) n);\n        if (n instanceof ConditionalExpression) return processConditionalExpression((ConditionalExpression) n);\n        if (n instanceof ObjectLiteral) return processObjectLiteral((ObjectLiteral) n);\n        if (n instanceof ArrayLiteral) return processArrayLiteral((ArrayLiteral) n);\n        if (n instanceof PropertyGet) return processPropertyGet((PropertyGet) n);\n        if (n instanceof PropertySet) return processPropertySet((PropertySet) n);\n        if (n instanceof ElementGet) return processElementGet((ElementGet) n);\n        if (n instanceof Label) return processLabel((Label) n);\n        if (n instanceof WithStatement) return processWithStatement((WithStatement) n);\n        if (n instanceof FunctionCall) return processFunctionCall((FunctionCall) n);\n        if (n instanceof NewExpression) return processNewExpression((NewExpression) n);\n        if (n instanceof Target) return processTarget((Target) n);\n\n        errorReporter.error(\n                \"Unknown node type: \" + n.getClass().getName(),\n                sourceName,\n                n.getLineno(),\n                n.getLength(),\n                null,\n                0);\n        return newNode(Token.EMPTY);\n    }\n\n    protected Node transform(AstNode n) {\n        Node result;\n        try {\n            result = transformGeneric(n);\n        } catch (Exception e) {\n            errorReporter.error(\n                    \"Internal Error: \" + e.toString(),\n                    sourceName,\n                    n.getLineno(),\n                    \"\",\n                    0);\n            result = newNode(Token.EMPTY);\n        }\n        result.copyInformation(n);\n        return result;\n    }\n\n    protected Node processFunction(FunctionNode fn) {\n        int functionType = fn.getFunctionType();\n        boolean isExpression = fn.getParent() != null && fn.getParent().getType() == Token.EXPR_RESULT;\n\n        if (fn.getFunctionName() != null) {\n            Node name = newNode(Token.NAME, fn.getFunctionName());\n            if (!isExpression) {\n                name = newNode(Token.FUNCTION_NAME, name);\n            }\n            return newNode(\n                    functionType == FunctionNode.FUNCTION_EXPRESSION ? Token.FUNCTION : Token.FUNCTION_DECL,\n                    name,\n                    transform(fn.getParams()),\n                    transform(fn.getBody()));\n        } else {\n            return newNode(\n                    functionType == FunctionNode.FUNCTION_EXPRESSION ? Token.FUNCTION : Token.FUNCTION_DECL,\n                    transform(fn.getParams()),\n                    transform(fn.getBody()));\n        }\n    }\n\n    @Override\n    public boolean visit(AstNode node) {\n        errorReporter.error(\n                \"Internal Error: TransformDispatcher visited a node (\" + node.getClass().getName() + \")\",\n                sourceName,\n                node.getLineno(),\n                \"\",\n                0);\n        return true;\n    }\n\n    List<Node> transform(Node node) {\n        return transform(node, null);\n    }\n\n    List<Node> transform(Node node, String name) {\n        List<Node> nodes = new ArrayList<>();\n        Node child = node.getFirstChild();\n\n        while (child != null) {\n            // Change \"let\" variables to \"var\" variables.\n            if (child.getType() == Token.LET) {\n                child.setType(Token.VAR);\n            }\n\n            if (name == null) {\n                nodes.add(transform(child));\n            } else {\n                nodes.add(newNode(Token.LABEL_NAME, createSecretFlag(name), transform(child)));\n            }\n            child = child.getNext();\n        }\n\n        return nodes;\n    }\n\n    protected Node processReturnStatement(ReturnStatement statementNode) {\n        Node node = newNode(Token.RETURN);\n        if (statementNode.getReturnValue() != null) {\n            node.addChildToBack(transform(statementNode.getReturnValue()));\n        }\n        return node;\n    }\n\n    protected Node processIfStatement(IfStatement statementNode) {\n        if (statementNode.getElsePart() == null) {\n            return newNode(\n                    Token.IF,\n                    transform(statementNode.getCondition()),\n                    transform(statementNode.getThenPart()));\n        } else {\n            return newNode(\n                    Token.IF,\n                    transform(statementNode.getCondition()),\n                    transform(statementNode.getThenPart()),\n                    transform(statementNode.getElsePart()));\n        }\n    }\n\n    protected Node processSwitchStatement(SwitchStatement statementNode) {\n        Node node = newNode(\n                Token.SWITCH,\n                transform(statementNode.getExpression()));\n\n        SwitchCase caseNode = statementNode.getCaseNodes();\n        while (caseNode != null) {\n            if (!caseNode.getType().equals(\"default\")) {\n                node.addChildToBack(newNode(\n                        Token.CASE,\n                        transform(caseNode.getExpression())));\n            } else {\n                node.addChildToBack(newNode(Token.DEFAULT));\n            }\n\n            List<Node> children = transform(caseNode);\n            for (Node n : children) {\n                node.addChildToBack(n);\n            }\n\n            caseNode = caseNode.getNext();\n        }\n\n        return node;\n    }\n\n    protected Node processSwitchCase(SwitchCase caseNode) {\n        return newNode(\n                Token.BLOCK,\n                transform(caseNode.getStatements()));\n    }\n\n    private boolean isDirective(Node n) {\n        if (n == null) return false;\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n                n.getFirstChild().isString() &&\n                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n\n    protected Node processBlock(Block blockNode) {\n        return newNode(Token.BLOCK, transform(blockNode));\n    }\n\n    protected Node processExpressionStatement(ExpressionStatement statementNode) {\n        return transform(statementNode.getExpression());\n    }\n\n    protected Node processBreakStatement(BreakStatement statementNode) {\n        Node node = newNode(Token.BREAK);\n        if (statementNode.getBreakLabel() != null) {\n            Node labelName = transform(statementNode.getBreakLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    protected Node processContinueStatement(ContinueStatement statementNode) {\n        Node node = newNode(Token.CONTINUE);\n        if (statementNode.getLabel() != null) {\n            Node labelName = transform(statementNode.getLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    protected Node processTryStatement(TryStatement statementNode) {\n        Node tryBlock = transformBlock(statementNode.getTryBlock());\n        Node finallyBlock = statementNode.getFinallyBlock() != null\n                ? transformBlock(statementNode.getFinallyBlock())\n                : null;\n\n        CatchClause catchClause = statementNode.getCatchClauses();\n        while (catchClause != null) {\n            tryBlock.addChildToBack(transform(catchClause));\n            catchClause = catchClause.getNext();\n        }\n\n        if (finallyBlock != null) {\n            return newNode(Token.TRYFINALLY, tryBlock, finallyBlock);\n        } else {\n            return newNode(Token.TRY, tryBlock);\n        }\n    }\n\n    protected Node processWhileLoop(WhileLoop loopNode) {\n        return newNode(\n                Token.WHILE,\n                transform(loopNode.getCondition()),\n                transformBlock(loopNode.getBody()));\n    }\n\n    protected Node processDoLoop(DoLoop loopNode) {\n        return newNode(\n                Token.DO,\n                transformBlock(loopNode.getBody()),\n                transform(loopNode.getCondition()));\n    }\n\n    protected Node processForLoop(ForLoop loopNode) {\n        Node init = loopNode.getInitializer() != null\n                ? transform(loopNode.getInitializer())\n                : newNode(Token.EMPTY);\n\n        Node condition = loopNode.getCondition() != null\n                ? transform(loopNode.getCondition())\n                : newNode(Token.TRUE);\n\n        Node increment = loopNode.getIncrement() != null\n                ? transform(loopNode.getIncrement())\n                : newNode(Token.EMPTY);\n\n        return newNode(\n                Token.FOR,\n                init,\n                condition,\n                increment,\n                transformBlock(loopNode.getBody()));\n    }\n\n    protected Node processForInLoop(ForInLoop loopNode) {\n        Node left, right;\n        if (loopNode.isForEach()) {\n            return newNode(\n                    Token.FOR,\n                    newNode(Token.LET, newNode(Token.NAME, loopNode.getIterator())),\n                    transform(loopNode.getIteratedObject()),\n                    transformBlock(loopNode.getBody()));\n        } else {\n            left = transform(loopNode.getIterator());\n            right = transform(loopNode.getIteratedObject());\n\n            if (left.getType() == Token.VAR) {\n                left.setType(Token.SETNAME);\n            }\n\n            return newNode(\n                    Token.FOR_IN,\n                    left,\n                    right,\n                    transformBlock(loopNode.getBody()),\n                    true);\n        }\n    }\n\n    protected Node processInfixExpression(InfixExpression exprNode) {\n        return newNode(\n                exprNode.getType(),\n                transform(exprNode.getLeft()),\n                transform(exprNode.getRight()));\n    }\n\n    protected Node processUnaryExpression(UnaryExpression exprNode) {\n        return newNode(exprNode.getType(), transform(exprNode.getOperand()));\n    }\n\n    protected Node processConditionalExpression(ConditionalExpression exprNode) {\n        return newNode(\n                Token.HOOK,\n                transform(exprNode.getTestExpression()),\n                transform(exprNode.getTrueExpression()),\n                transform(exprNode.getFalseExpression()));\n    }\n\n    protected Node processObjectLiteral(ObjectLiteral objNode) {\n        Node node = newNode(Token.OBJECTLIT);\n        for (ObjectProperty prop : objNode.getElements()) {\n            node.addChildToBack(transform(prop));\n        }\n        return node;\n    }\n\n    protected Node processPropertyGet(PropertyGet propNode) {\n        return newNode(\n                Token.GETPROP,\n                transform(propNode.getTarget()),\n                newNode(Token.STRING, propNode.getProperty().getIdentifier()));\n    }\n\n    protected Node processPropertySet(PropertySet propNode) {\n        return newNode(\n                Token.SETPROP,\n                transform(propNode.getTarget()),\n                newNode(Token.STRING, propNode.getProperty().getIdentifier()),\n                transform(propNode.getRight()));\n    }\n\n    protected Node processArrayLiteral(ArrayLiteral literalNode) {\n        Node node = newNode(Token.ARRAYLIT);\n        for (AstNode element : literalNode.getElements()) {\n            if (element == null) {\n                node.addChildToBack(newNode(Token.NULL));\n            } else {\n                node.addChildToBack(transform(element));\n            }\n        }\n        return node;\n    }\n\n    protected Node processLabel(Label labelNode) {\n        return newNode(Token.LABEL, labelNode.getName(), transform(labelNode.getStatement()));\n    }\n\n    protected Node processWithStatement(WithStatement withNode) {\n        return newNode(Token.WITH",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..6159beda 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,419 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+import org.mozilla.javascript.ErrorReporter;\n+import org.mozilla.javascript.Node;\n+import org.mozilla.javascript.Token;\n+import org.mozilla.javascript.ast.*;\n+\n+import java.util.ArrayList;\n+import java.util.List;\n+\n+class TransformDispatcher implements NodeVisitor {\n+\n+    private static final String ALLOWED_DIRECTIVES = \"__allow_directive__\";\n+    private static final String SECRET_FLAG_PREFIX = \"zj\";\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    private final ErrorReporter errorReporter;\n+    private final String sourceName;\n+\n+    public TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+        this.errorReporter = errorReporter;\n+        this.sourceName = sourceName;\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    protected Node newNode(int type) {\n+        return new Node(type);\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    protected Node newNode(int type, AstNode child) {\n+        Node n = new Node(type);\n+        n.addChildToBack(transform(child));\n+        return n;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n+    protected Node newNode(int type, AstNode child1, AstNode child2) {\n+        Node n = new Node(type);\n+        n.addChildToBack(transform(child1));\n+        n.addChildToBack(transform(child2));\n+        return n;\n+    }\n+\n+    protected Node newNode(int type, AstNode child1, AstNode child2, AstNode child3) {\n+        Node n = new Node(type);\n+        n.addChildToBack(transform(child1));\n+        n.addChildToBack(transform(child2));\n+        n.addChildToBack(transform(child3));\n+        return n;\n+    }\n+\n+    protected Node transformGeneric(AstNode n) {\n+        if (n == null) return newNode(Token.EMPTY);\n+\n+        if (n instanceof Name) {\n+            Name name = (Name)n;\n+            Node node = new Node(Token.NAME, name.getIdentifier());\n+\n+            if (isDirective(n.getParent())) {\n+                node.putIntProp(Node.IS_DIRECTIVE, 1);\n+            }\n+            \n+            return node;\n+        }\n+\n+        if (n instanceof ParenthesizedExpression) {\n+            return transform(((ParenthesizedExpression)n).getExpression());\n+        }\n+\n+        if (n instanceof StringLiteral) return new Node(Token.STRING, n.getString());\n+        if (n instanceof NumberLiteral) return Node.newNumber(n.getDouble());\n+        if (n instanceof FunctionNode) return processFunction((FunctionNode) n);\n+        if (n instanceof ReturnStatement) return processReturnStatement((ReturnStatement) n);\n+        if (n instanceof IfStatement) return processIfStatement((IfStatement) n);\n+        if (n instanceof SwitchStatement) return processSwitchStatement((SwitchStatement) n);\n+        if (n instanceof SwitchCase) return processSwitchCase((SwitchCase) n);\n+        if (n instanceof BreakStatement) return processBreakStatement((BreakStatement) n);\n+        if (n instanceof ContinueStatement) return processContinueStatement((ContinueStatement) n);\n+        if (n instanceof TryStatement) return processTryStatement((TryStatement) n);\n+        if (n instanceof Block) return processBlock((Block) n);\n+        if (n instanceof ExpressionStatement) return processExpressionStatement((ExpressionStatement) n);\n+        if (n instanceof WhileLoop) return processWhileLoop((WhileLoop) n);\n+        if (n instanceof DoLoop) return processDoLoop((DoLoop) n);\n+        if (n instanceof ForLoop) return processForLoop((ForLoop) n);\n+        if (n instanceof ForInLoop) return processForInLoop((ForInLoop) n);\n+        if (n instanceof InfixExpression) return processInfixExpression((InfixExpression) n);\n+        if (n instanceof UnaryExpression) return processUnaryExpression((UnaryExpression) n);\n+        if (n instanceof ConditionalExpression) return processConditionalExpression((ConditionalExpression) n);\n+        if (n instanceof ObjectLiteral) return processObjectLiteral((ObjectLiteral) n);\n+        if (n instanceof ArrayLiteral) return processArrayLiteral((ArrayLiteral) n);\n+        if (n instanceof PropertyGet) return processPropertyGet((PropertyGet) n);\n+        if (n instanceof PropertySet) return processPropertySet((PropertySet) n);\n+        if (n instanceof ElementGet) return processElementGet((ElementGet) n);\n+        if (n instanceof Label) return processLabel((Label) n);\n+        if (n instanceof WithStatement) return processWithStatement((WithStatement) n);\n+        if (n instanceof FunctionCall) return processFunctionCall((FunctionCall) n);\n+        if (n instanceof NewExpression) return processNewExpression((NewExpression) n);\n+        if (n instanceof Target) return processTarget((Target) n);\n+\n         errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+                \"Unknown node type: \" + n.getClass().getName(),\n+                sourceName,\n+                n.getLineno(),\n+                n.getLength(),\n+                null,\n+                0);\n+        return newNode(Token.EMPTY);\n+    }\n+\n+    protected Node transform(AstNode n) {\n+        Node result;\n+        try {\n+            result = transformGeneric(n);\n+        } catch (Exception e) {\n+            errorReporter.error(\n+                    \"Internal Error: \" + e.toString(),\n+                    sourceName,\n+                    n.getLineno(),\n+                    \"\",\n+                    0);\n+            result = newNode(Token.EMPTY);\n+        }\n+        result.copyInformation(n);\n+        return result;\n+    }\n+\n+    protected Node processFunction(FunctionNode fn) {\n+        int functionType = fn.getFunctionType();\n+        boolean isExpression = fn.getParent() != null && fn.getParent().getType() == Token.EXPR_RESULT;\n+\n+        if (fn.getFunctionName() != null) {\n+            Node name = newNode(Token.NAME, fn.getFunctionName());\n+            if (!isExpression) {\n+                name = newNode(Token.FUNCTION_NAME, name);\n+            }\n+            return newNode(\n+                    functionType == FunctionNode.FUNCTION_EXPRESSION ? Token.FUNCTION : Token.FUNCTION_DECL,\n+                    name,\n+                    transform(fn.getParams()),\n+                    transform(fn.getBody()));\n+        } else {\n+            return newNode(\n+                    functionType == FunctionNode.FUNCTION_EXPRESSION ? Token.FUNCTION : Token.FUNCTION_DECL,\n+                    transform(fn.getParams()),\n+                    transform(fn.getBody()));\n+        }\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public boolean visit(AstNode node) {\n+        errorReporter.error(\n+                \"Internal Error: TransformDispatcher visited a node (\" + node.getClass().getName() + \")\",\n+                sourceName,\n+                node.getLineno(),\n+                \"\",\n+                0);\n+        return true;\n     }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    List<Node> transform(Node node) {\n+        return transform(node, null);\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    List<Node> transform(Node node, String name) {\n+        List<Node> nodes = new ArrayList<>();\n+        Node child = node.getFirstChild();\n+\n+        while (child != null) {\n+            // Change \"let\" variables to \"var\" variables.\n+            if (child.getType() == Token.LET) {\n+                child.setType(Token.VAR);\n+            }\n+\n+            if (name == null) {\n+                nodes.add(transform(child));\n+            } else {\n+                nodes.add(newNode(Token.LABEL_NAME, createSecretFlag(name), transform(child)));\n+            }\n+            child = child.getNext();\n+        }\n+\n+        return nodes;\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    protected Node processReturnStatement(ReturnStatement statementNode) {\n+        Node node = newNode(Token.RETURN);\n+        if (statementNode.getReturnValue() != null) {\n+            node.addChildToBack(transform(statementNode.getReturnValue()));\n+        }\n+        return node;\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    protected Node processIfStatement(IfStatement statementNode) {\n+        if (statementNode.getElsePart() == null) {\n+            return newNode(\n+                    Token.IF,\n+                    transform(statementNode.getCondition()),\n+                    transform(statementNode.getThenPart()));\n+        } else {\n+            return newNode(\n+                    Token.IF,\n+                    transform(statementNode.getCondition()),\n+                    transform(statementNode.getThenPart()),\n+                    transform(statementNode.getElsePart()));\n+        }\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    protected Node processSwitchStatement(SwitchStatement statementNode) {\n+        Node node = newNode(\n+                Token.SWITCH,\n+                transform(statementNode.getExpression()));\n+\n+        SwitchCase caseNode = statementNode.getCaseNodes();\n+        while (caseNode != null) {\n+            if (!caseNode.getType().equals(\"default\")) {\n+                node.addChildToBack(newNode(\n+                        Token.CASE,\n+                        transform(caseNode.getExpression())));\n+            } else {\n+                node.addChildToBack(newNode(Token.DEFAULT));\n+            }\n+\n+            List<Node> children = transform(caseNode);\n+            for (Node n : children) {\n+                node.addChildToBack(n);\n+            }\n+\n+            caseNode = caseNode.getNext();\n+        }\n+\n+        return node;\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    protected Node processSwitchCase(SwitchCase caseNode) {\n+        return newNode(\n+                Token.BLOCK,\n+                transform(caseNode.getStatements()));\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    private boolean isDirective(Node n) {\n+        if (n == null) return false;\n+\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+                n.getFirstChild().isString() &&\n+                ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    }\n+\n+    protected Node processBlock(Block blockNode) {\n+        return newNode(Token.BLOCK, transform(blockNode));\n+    }\n+\n+    protected Node processExpressionStatement(ExpressionStatement statementNode) {\n+        return transform(statementNode.getExpression());\n+    }\n+\n+    protected Node processBreakStatement(BreakStatement statementNode) {\n+        Node node = newNode(Token.BREAK);\n+        if (statementNode.getBreakLabel() != null) {\n+            Node labelName = transform(statementNode.getBreakLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n+    }\n+\n+    protected Node processContinueStatement(ContinueStatement statementNode) {\n+        Node node = newNode(Token.CONTINUE);\n+        if (statementNode.getLabel() != null) {\n+            Node labelName = transform(statementNode.getLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n+    }\n+\n+    protected Node processTryStatement(TryStatement statementNode) {\n+        Node tryBlock = transformBlock(statementNode.getTryBlock());\n+        Node finallyBlock = statementNode.getFinallyBlock() != null\n+                ? transformBlock(statementNode.getFinallyBlock())\n+                : null;\n+\n+        CatchClause catchClause = statementNode.getCatchClauses();\n+        while (catchClause != null) {\n+            tryBlock.addChildToBack(transform(catchClause));\n+            catchClause = catchClause.getNext();\n+        }\n+\n+        if (finallyBlock != null) {\n+            return newNode(Token.TRYFINALLY, tryBlock, finallyBlock);\n+        } else {\n+            return newNode(Token.TRY, tryBlock);\n+        }\n+    }\n+\n+    protected Node processWhileLoop(WhileLoop loopNode) {\n+        return newNode(\n+                Token.WHILE,\n+                transform(loopNode.getCondition()),\n+                transformBlock(loopNode.getBody()));\n+    }\n+\n+    protected Node processDoLoop(DoLoop loopNode) {\n+        return newNode(\n+                Token.DO,\n+                transformBlock(loopNode.getBody()),\n+                transform(loopNode.getCondition()));\n+    }\n+\n+    protected Node processForLoop(ForLoop loopNode) {\n+        Node init = loopNode.getInitializer() != null\n+                ? transform(loopNode.getInitializer())\n+                : newNode(Token.EMPTY);\n+\n+        Node condition = loopNode.getCondition() != null\n+                ? transform(loopNode.getCondition())\n+                : newNode(Token.TRUE);\n+\n+        Node increment = loopNode.getIncrement() != null\n+                ? transform(loopNode.getIncrement())\n+                : newNode(Token.EMPTY);\n+\n+        return newNode(\n+                Token.FOR,\n+                init,\n+                condition,\n+                increment,\n+                transformBlock(loopNode.getBody()));\n+    }\n+\n+    protected Node processForInLoop(ForInLoop loopNode) {\n+        Node left, right;\n+        if (loopNode.isForEach()) {\n+            return newNode(\n+                    Token.FOR,\n+                    newNode(Token.LET, newNode(Token.NAME, loopNode.getIterator())),\n+                    transform(loopNode.getIteratedObject()),\n+                    transformBlock(loopNode.getBody()));\n+        } else {\n+            left = transform(loopNode.getIterator());\n+            right = transform(loopNode.getIteratedObject());\n+\n+            if (left.getType() == Token.VAR) {\n+                left.setType(Token.SETNAME);\n+            }\n+\n+            return newNode(\n+                    Token.FOR_IN,\n+                    left,\n+                    right,\n+                    transformBlock(loopNode.getBody()),\n+                    true);\n+        }\n     }\n \n+    protected Node processInfixExpression(InfixExpression exprNode) {\n+        return newNode(\n+                exprNode.getType(),\n+                transform(exprNode.getLeft()),\n+                transform(exprNode.getRight()));\n+    }\n+\n+    protected Node processUnaryExpression(UnaryExpression exprNode) {\n+        return newNode(exprNode.getType(), transform(exprNode.getOperand()));\n+    }\n+\n+    protected Node processConditionalExpression(ConditionalExpression exprNode) {\n+        return newNode(\n+                Token.HOOK,\n+                transform(exprNode.getTestExpression()),\n+                transform(exprNode.getTrueExpression()),\n+                transform(exprNode.getFalseExpression()));\n+    }\n+\n+    protected Node processObjectLiteral(ObjectLiteral objNode) {\n+        Node node = newNode(Token.OBJECTLIT);\n+        for (ObjectProperty prop : objNode.getElements()) {\n+            node.addChildToBack(transform(prop));\n+        }\n+        return node;\n+    }\n+\n+    protected Node processPropertyGet(PropertyGet propNode) {\n+        return newNode(\n+                Token.GETPROP,\n+                transform(propNode.getTarget()),\n+                newNode(Token.STRING, propNode.getProperty().getIdentifier()));\n+    }\n+\n+    protected Node processPropertySet(PropertySet propNode) {\n+        return newNode(\n+                Token.SETPROP,\n+                transform(propNode.getTarget()),\n+                newNode(Token.STRING, propNode.getProperty().getIdentifier()),\n+                transform(propNode.getRight()));\n+    }\n+\n+    protected Node processArrayLiteral(ArrayLiteral literalNode) {\n+        Node node = newNode(Token.ARRAYLIT);\n+        for (AstNode element : literalNode.getElements()) {\n+            if (element == null) {\n+                node.addChildToBack(newNode(Token.NULL));\n+            } else {\n+                node.addChildToBack(transform(element));\n+            }\n+        }\n+        return node;\n+    }\n+\n+    protected Node processLabel(Label labelNode) {\n+        return newNode(Token.LABEL, labelNode.getName(), transform(labelNode.getStatement()));\n+    }\n+\n+    protected Node processWithStatement(WithStatement withNode) {\n+        return newNode(Token.WITH\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}