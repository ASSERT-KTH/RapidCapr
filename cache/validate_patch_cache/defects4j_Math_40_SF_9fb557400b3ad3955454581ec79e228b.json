{
    "patch": "protected double doSolve() {\n    double min = getMin();\n    double max = getMax();\n    double startValue = getStartValue();\n    double functionValueAccuracy = getFunctionValueAccuracy();\n    int maximalIterationCount = getMaximalIterationCount();\n    int maxEval = getMaxEvaluations();\n    verifySequence(min, startValue, max);\n\n    double xA = min;\n    double yA = computeObjectiveValue(xA);\n    double xB = startValue;\n    double yB = computeObjectiveValue(xB);\n    if (Precision.sign(yA) == Precision.sign(yB)) {\n        xA = xB;\n        yA = yB;\n        xB = min;\n        yB = computeObjectiveValue(xB);\n        if (Precision.sign(yA) == Precision.sign(yB)) {\n            throw new NoBracketingException(xA, xB, yA, yB);\n        }\n    }\n\n    // prepare actual evaluation loop\n    double x = xB;\n    double y = computeObjectiveValue(x);\n    int i = 0;\n    while (true) {\n\n        // calculate the new point as the intersection point\n        // of the x-axis and the line between the two points\n        final double x1 = xA;\n        final double y1 = yA;\n        final double x2 = xB;\n        final double y2 = yB;\n        final double denominator = (y2 - y1);\n        if (denominator == 0.0) {\n            // Due to insufficient precision, the root found is not different\n            // from either a or b. This may happen only if MPFR is used and is a\n            // consequence of MPFR's method of computing roots.\n            if (y == 0.0) {\n                return x;\n            }\n            if (Precision.sign(y) != Precision.sign(y1)) {\n                xB = x;\n                yB = y;\n            } else if (Precision.sign(y) != Precision.sign(y2)) {\n                xA = x;\n                yA = y;\n            } else {\n                // Both brackets have different signs. Therefore a root was not\n                // found although bracketing was achieved (e.g. when f(x) = x^2).\n                final double minDelta = FastMath.min(FastMath.abs(x - x1), FastMath.abs(x2 - x));\n                if (Precision.equals(minDelta, 0d, functionValueAccuracy)) {\n                    return x;\n                }\n                return Double.NaN;\n            }\n            final double dx = xB - xA;\n            final double tolerance = FastMath.max(getAbsoluteAccuracy(), getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB)));\n            if (FastMath.abs(dx) <= tolerance) {\n                switch (getAllowedSolutions()) {\n                    case ANY_SIDE :\n                        return y < 0 ? x : ((y == 0) ? FastMath.min(xA, xB) : x);\n                    case LEFT_SIDE :\n                        return FastMath.min(xA, xB);\n                    case RIGHT_SIDE :\n                        return FastMath.max(xA, xB);\n                    case BELOW_SIDE :\n                        return (y <= 0) ? x : getX(0);\n                    case ABOVE_SIDE :\n                        return (y >= 0) ? x : getX(0);\n                    default :\n                        throw new MathInternalError(null);\n                }\n            }\n            x = FastMath.max(getMin(), FastMath.min(getMax(), 0.5 * (xA + xB)));\n            y = computeObjectiveValue(x);\n            if (++i >= maxEval) {\n                throw new TooManyEvaluationsException(maxEval);\n            }\n            continue;\n        }\n        final double dx = (x2 - x1) / denominator;\n        final double dy = computeObjectiveValue(x1) * (x2 - x) / denominator\n                + computeObjectiveValue(x2) * (x - x1) / denominator\n                + y;\n        if (dy == 0.0) {\n            // Simple case, dy == 0.\n            if (x < xB) {\n                xA = x;\n                yA = dy;\n            } else {\n                xB = x;\n                yB = dy;\n            }\n            if (++i >= maxEval) {\n                throw new TooManyEvaluationsException(maxEval);\n            }\n            continue;\n        }\n        final double newX;\n        final double newY;\n        final double oldX = x;\n        if (Precision.sign(y) == Precision.sign(y1)) {\n            xA = x;\n            yA = y;\n            newX = xB - dx * FastMath.abs(yB / dy);\n            newY = computeObjectiveValue(newX);\n        } else if (Precision.sign(y) == Precision.sign(y2)) {\n            xB = x;\n            yB = y;\n            newX = xA + dx * FastMath.abs(yA / dy);\n            newY = computeObjectiveValue(newX);\n        } else {\n            newX = x - y / dy;\n            newY = computeObjectiveValue(newX);\n            if (Precision.equals(newY, 0d, functionValueAccuracy)) {\n                return newX;\n            }\n            // Update brackets.\n            if (newY < 0) {\n                xA = newX;\n                yA = newY;\n                xB = oldX;\n                yB = y;\n            } else {\n                xA = oldX;\n                yA = y;\n                xB = newX;\n                yB = newY;\n            }\n        }\n\n        // If the root has not been found yet and the maximum number of iterations\n        // has not been exceeded, repeat the loop.\n        if (Precision.equals(newX, x, functionValueAccuracy)) {\n            if (++i >= maxEval) {\n                throw new TooManyEvaluationsException(maxEval);\n            }\n            continue;\n        }\n        x = newX;\n        y = newY;\n        if (++i >= maxEval) {\n            throw new TooManyEvaluationsException(maxEval);\n        }\n        if (FastMath.abs(y) <= functionValueAccuracy) {\n            // The function value is close enough to zero.\n            return x;\n        }\n        if (FastMath.abs(x - oldX) <= getAbsoluteAccuracy()) {\n            // The root is accurate enough or we cannot further improve it due\n            // to insufficient accuracy.\n            return x;\n        }\n        if (i >= maximalIterationCount) {\n            // Maximum number of iterations reached.\n            return getX(i);\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\nindex 93dd3bbdd..1f6d1fd15 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BracketingNthOrderBrentSolver.java\n@@ -140,209 +140,168 @@ public class BracketingNthOrderBrentSolver\n      * {@inheritDoc}\n      */\n     @Override\n-    protected double doSolve() {\n-\n-        // prepare arrays with the first points\n-        final double[] x = new double[maximalOrder + 1];\n-        final double[] y = new double[maximalOrder + 1];\n-        x[0] = getMin();\n-        x[1] = getStartValue();\n-        x[2] = getMax();\n-        verifySequence(x[0], x[1], x[2]);\n-\n-        // evaluate initial guess\n-        y[1] = computeObjectiveValue(x[1]);\n-        if (Precision.equals(y[1], 0.0, 1)) {\n-            // return the initial guess if it is a perfect root.\n-            return x[1];\n-        }\n-\n-        // evaluate first  endpoint\n-        y[0] = computeObjectiveValue(x[0]);\n-        if (Precision.equals(y[0], 0.0, 1)) {\n-            // return the first endpoint if it is a perfect root.\n-            return x[0];\n+protected double doSolve() {\n+    double min = getMin();\n+    double max = getMax();\n+    double startValue = getStartValue();\n+    double functionValueAccuracy = getFunctionValueAccuracy();\n+    int maximalIterationCount = getMaximalIterationCount();\n+    int maxEval = getMaxEvaluations();\n+    verifySequence(min, startValue, max);\n+\n+    double xA = min;\n+    double yA = computeObjectiveValue(xA);\n+    double xB = startValue;\n+    double yB = computeObjectiveValue(xB);\n+    if (Precision.sign(yA) == Precision.sign(yB)) {\n+        xA = xB;\n+        yA = yB;\n+        xB = min;\n+        yB = computeObjectiveValue(xB);\n+        if (Precision.sign(yA) == Precision.sign(yB)) {\n+            throw new NoBracketingException(xA, xB, yA, yB);\n         }\n+    }\n \n-        int nbPoints;\n-        int signChangeIndex;\n-        if (y[0] * y[1] < 0) {\n-\n-            // reduce interval if it brackets the root\n-            nbPoints        = 2;\n-            signChangeIndex = 1;\n-\n-        } else {\n-\n-            // evaluate second endpoint\n-            y[2] = computeObjectiveValue(x[2]);\n-            if (Precision.equals(y[2], 0.0, 1)) {\n-                // return the second endpoint if it is a perfect root.\n-                return x[2];\n+    // prepare actual evaluation loop\n+    double x = xB;\n+    double y = computeObjectiveValue(x);\n+    int i = 0;\n+    while (true) {\n+\n+        // calculate the new point as the intersection point\n+        // of the x-axis and the line between the two points\n+        final double x1 = xA;\n+        final double y1 = yA;\n+        final double x2 = xB;\n+        final double y2 = yB;\n+        final double denominator = (y2 - y1);\n+        if (denominator == 0.0) {\n+            // Due to insufficient precision, the root found is not different\n+            // from either a or b. This may happen only if MPFR is used and is a\n+            // consequence of MPFR's method of computing roots.\n+            if (y == 0.0) {\n+                return x;\n             }\n-\n-            if (y[1] * y[2] < 0) {\n-                // use all computed point as a start sampling array for solving\n-                nbPoints        = 3;\n-                signChangeIndex = 2;\n+            if (Precision.sign(y) != Precision.sign(y1)) {\n+                xB = x;\n+                yB = y;\n+            } else if (Precision.sign(y) != Precision.sign(y2)) {\n+                xA = x;\n+                yA = y;\n             } else {\n-                throw new NoBracketingException(x[0], x[2], y[0], y[2]);\n+                // Both brackets have different signs. Therefore a root was not\n+                // found although bracketing was achieved (e.g. when f(x) = x^2).\n+                final double minDelta = FastMath.min(FastMath.abs(x - x1), FastMath.abs(x2 - x));\n+                if (Precision.equals(minDelta, 0d, functionValueAccuracy)) {\n+                    return x;\n+                }\n+                return Double.NaN;\n             }\n-\n-        }\n-\n-        // prepare a work array for inverse polynomial interpolation\n-        final double[] tmpX = new double[x.length];\n-\n-        // current tightest bracketing of the root\n-        double xA    = x[signChangeIndex - 1];\n-        double yA    = y[signChangeIndex - 1];\n-        double absYA = FastMath.abs(yA);\n-        int agingA   = 0;\n-        double xB    = x[signChangeIndex];\n-        double yB    = y[signChangeIndex];\n-        double absYB = FastMath.abs(yB);\n-        int agingB   = 0;\n-\n-        // search loop\n-        while (true) {\n-\n-            // check convergence of bracketing interval\n-            final double xTol = getAbsoluteAccuracy() +\n-                                getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB));\n-            if (((xB - xA) <= xTol) || (FastMath.max(absYA, absYB) < getFunctionValueAccuracy())) {\n-                switch (allowed) {\n-                case ANY_SIDE :\n-                    return absYA < absYB ? xA : xB;\n-                case LEFT_SIDE :\n-                    return xA;\n-                case RIGHT_SIDE :\n-                    return xB;\n-                case BELOW_SIDE :\n-                    return (yA <= 0) ? xA : xB;\n-                case ABOVE_SIDE :\n-                    return (yA <  0) ? xB : xA;\n-                default :\n-                    // this should never happen\n-                    throw new MathInternalError(null);\n+            final double dx = xB - xA;\n+            final double tolerance = FastMath.max(getAbsoluteAccuracy(), getRelativeAccuracy() * FastMath.max(FastMath.abs(xA), FastMath.abs(xB)));\n+            if (FastMath.abs(dx) <= tolerance) {\n+                switch (getAllowedSolutions()) {\n+                    case ANY_SIDE :\n+                        return y < 0 ? x : ((y == 0) ? FastMath.min(xA, xB) : x);\n+                    case LEFT_SIDE :\n+                        return FastMath.min(xA, xB);\n+                    case RIGHT_SIDE :\n+                        return FastMath.max(xA, xB);\n+                    case BELOW_SIDE :\n+                        return (y <= 0) ? x : getX(0);\n+                    case ABOVE_SIDE :\n+                        return (y >= 0) ? x : getX(0);\n+                    default :\n+                        throw new MathInternalError(null);\n                 }\n             }\n-\n-            // target for the next evaluation point\n-            double targetY;\n-            if (agingA >= MAXIMAL_AGING) {\n-                // we keep updating the high bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yB;\n-            } else if (agingB >= MAXIMAL_AGING) {\n-                // we keep updating the low bracket, try to compensate this\n-                targetY = -REDUCTION_FACTOR * yA;\n-            } else {\n-                // bracketing is balanced, try to find the root itself\n-                targetY = 0;\n+            x = FastMath.max(getMin(), FastMath.min(getMax(), 0.5 * (xA + xB)));\n+            y = computeObjectiveValue(x);\n+            if (++i >= maxEval) {\n+                throw new TooManyEvaluationsException(maxEval);\n             }\n-\n-            // make a few attempts to guess a root,\n-            double nextX;\n-            int start = 0;\n-            int end   = nbPoints;\n-            do {\n-\n-                // guess a value for current target, using inverse polynomial interpolation\n-                System.arraycopy(x, start, tmpX, start, end - start);\n-                nextX = guessX(targetY, tmpX, y, start, end);\n-\n-                if (!((nextX > xA) && (nextX < xB))) {\n-                    // the guessed root is not strictly inside of the tightest bracketing interval\n-\n-                    // the guessed root is either not strictly inside the interval or it\n-                    // is a NaN (which occurs when some sampling points share the same y)\n-                    // we try again with a lower interpolation order\n-                    if (signChangeIndex - start >= end - signChangeIndex) {\n-                        // we have more points before the sign change, drop the lowest point\n-                        ++start;\n-                    } else {\n-                        // we have more points after sign change, drop the highest point\n-                        --end;\n-                    }\n-\n-                    // we need to do one more attempt\n-                    nextX = Double.NaN;\n-\n-                }\n-\n-            } while (Double.isNaN(nextX) && (end - start > 1));\n-\n-            if (Double.isNaN(nextX)) {\n-                // fall back to bisection\n-                nextX = xA + 0.5 * (xB - xA);\n-                start = signChangeIndex - 1;\n-                end   = signChangeIndex;\n+            continue;\n+        }\n+        final double dx = (x2 - x1) / denominator;\n+        final double dy = computeObjectiveValue(x1) * (x2 - x) / denominator\n+                + computeObjectiveValue(x2) * (x - x1) / denominator\n+                + y;\n+        if (dy == 0.0) {\n+            // Simple case, dy == 0.\n+            if (x < xB) {\n+                xA = x;\n+                yA = dy;\n+            } else {\n+                xB = x;\n+                yB = dy;\n             }\n-\n-            // evaluate the function at the guessed root\n-            final double nextY = computeObjectiveValue(nextX);\n-            if (Precision.equals(nextY, 0.0, 1)) {\n-                // we have found an exact root, since it is not an approximation\n-                // we don't need to bother about the allowed solutions setting\n-                return nextX;\n+            if (++i >= maxEval) {\n+                throw new TooManyEvaluationsException(maxEval);\n             }\n-\n-            if ((nbPoints > 2) && (end - start != nbPoints)) {\n-\n-                // we have been forced to ignore some points to keep bracketing,\n-                // they are probably too far from the root, drop them from now on\n-                nbPoints = end - start;\n-                System.arraycopy(x, start, x, 0, nbPoints);\n-                System.arraycopy(y, start, y, 0, nbPoints);\n-                signChangeIndex -= start;\n-\n-            } else  if (nbPoints == x.length) {\n-\n-                // we have to drop one point in order to insert the new one\n-                nbPoints--;\n-\n-                // keep the tightest bracketing interval as centered as possible\n-                if (signChangeIndex >= (x.length + 1) / 2) {\n-                    // we drop the lowest point, we have to shift the arrays and the index\n-                    System.arraycopy(x, 1, x, 0, nbPoints);\n-                    System.arraycopy(y, 1, y, 0, nbPoints);\n-                    --signChangeIndex;\n-                }\n-\n+            continue;\n+        }\n+        final double newX;\n+        final double newY;\n+        final double oldX = x;\n+        if (Precision.sign(y) == Precision.sign(y1)) {\n+            xA = x;\n+            yA = y;\n+            newX = xB - dx * FastMath.abs(yB / dy);\n+            newY = computeObjectiveValue(newX);\n+        } else if (Precision.sign(y) == Precision.sign(y2)) {\n+            xB = x;\n+            yB = y;\n+            newX = xA + dx * FastMath.abs(yA / dy);\n+            newY = computeObjectiveValue(newX);\n+        } else {\n+            newX = x - y / dy;\n+            newY = computeObjectiveValue(newX);\n+            if (Precision.equals(newY, 0d, functionValueAccuracy)) {\n+                return newX;\n             }\n-\n-            // insert the last computed point\n-            //(by construction, we know it lies inside the tightest bracketing interval)\n-            System.arraycopy(x, signChangeIndex, x, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            x[signChangeIndex] = nextX;\n-            System.arraycopy(y, signChangeIndex, y, signChangeIndex + 1, nbPoints - signChangeIndex);\n-            y[signChangeIndex] = nextY;\n-            ++nbPoints;\n-\n-            // update the bracketing interval\n-            if (nextY * yA <= 0) {\n-                // the sign change occurs before the inserted point\n-                xB = nextX;\n-                yB = nextY;\n-                absYB = FastMath.abs(yB);\n-                ++agingA;\n-                agingB = 0;\n+            // Update brackets.\n+            if (newY < 0) {\n+                xA = newX;\n+                yA = newY;\n+                xB = oldX;\n+                yB = y;\n             } else {\n-                // the sign change occurs after the inserted point\n-                xA = nextX;\n-                yA = nextY;\n-                absYA = FastMath.abs(yA);\n-                agingA = 0;\n-                ++agingB;\n-\n-                // update the sign change index\n-                signChangeIndex++;\n-\n+                xA = oldX;\n+                yA = y;\n+                xB = newX;\n+                yB = newY;\n             }\n-\n         }\n \n+        // If the root has not been found yet and the maximum number of iterations\n+        // has not been exceeded, repeat the loop.\n+        if (Precision.equals(newX, x, functionValueAccuracy)) {\n+            if (++i >= maxEval) {\n+                throw new TooManyEvaluationsException(maxEval);\n+            }\n+            continue;\n+        }\n+        x = newX;\n+        y = newY;\n+        if (++i >= maxEval) {\n+            throw new TooManyEvaluationsException(maxEval);\n+        }\n+        if (FastMath.abs(y) <= functionValueAccuracy) {\n+            // The function value is close enough to zero.\n+            return x;\n+        }\n+        if (FastMath.abs(x - oldX) <= getAbsoluteAccuracy()) {\n+            // The root is accurate enough or we cannot further improve it due\n+            // to insufficient accuracy.\n+            return x;\n+        }\n+        if (i >= maximalIterationCount) {\n+            // Maximum number of iterations reached.\n+            return getX(i);\n+        }\n     }\n+}\n \n     /** Guess an x value by n<sup>th</sup> order inverse polynomial interpolation.\n      * <p>",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}