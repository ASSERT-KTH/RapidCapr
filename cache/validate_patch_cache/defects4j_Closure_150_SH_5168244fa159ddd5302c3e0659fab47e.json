{
    "patch": "switch(n.getType()) {\n    case Token.FUNCTION: {\n        Node firstChild = n.getFirstChild();\n        boolean isExpression = NodeUtil.isFunctionExpression(n);\n        Node nameNode = null;\n        if (!isExpression) {\n            Node secondChild = firstChild.getNext();\n            if (secondChild.getType() == Token.NAME) {\n                nameNode = secondChild;\n            }\n        }\n\n        if (nameNode != null) {\n            if (nameNode.getString().contains(\"$jscomp$\") ||\n                // Do not add names for constructors since native super calls are not available in the old\n                // browser versions. And it is not required for type inference since it assumes a constructor\n                // and short instead of full names are used for type inference.\n                NodeUtil.isConstructorDeclaration(n)) {\n              return; // identifier refers to a synthesized identifier or synthesizeable, default ctor\n            }\n\n            String name = nameNode.getString();\n            JSType typeOfThis = getJSTypeOfThis(n);\n            if (es6Module && !inExterns && !isLegacyScript &&\n                NodeUtil.isTopLevel(n.getParent())) {\n                // The export annotation is written next to the function declaration in ES6 modules.\n                JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(n);\n                if (jsdoc != null && jsdoc.isExport()) {\n                    JSType requiredType = registry.getType(name);\n                    if (requiredType == null) {\n                        requiredType = registry.createFunctionType(\n                            typeOfThis, null, null, unknownType);\n                    }\n                    registry.setExportedVarType(name, requiredType,\n                        compiler.getCodingConvention());\n                }\n            }\n\n            if (!isLegacyScript) {\n                // If the function is anonymous, don't make its name available for\n                // typchecking - there's no way to reference it.\n                if (isExpression) {\n                    registry.declareType(getTypeDeclaration(nameNode, typeOfThis));\n                } else {\n                    registry.declareType(getTypeDeclaration(nameNode, n.getJSType(), typeOfThis));\n                }\n            }\n            if (typeOfThis.isUnknownType() || typeOfThis.isAllType()) {\n                registry.setNoninjectableType(name);\n            }\n        }\n        break;\n    }\n    case Token.VAR:\n        defineVar(n, parent);\n        break;\n    case Token.LET:\n        defineLet(n, parent);\n        break;\n    case Token.CONST:\n        defineConst(n, parent);\n        break;\n    case Token.CATCH:\n        if (NodeUtil.getEnclosingScope(n).isDeclared(parent.getString(), true)) {\n            // typed catch parameters must be declared ahead of time,\n            // as with var declarations\n            // record the type of the catch variable before declaring it.\n            JSType type = getJSTypeOfCatchScopeVariable(n, parent);\n            registry.declareType(getTypeDeclaration(parent, type));\n        }\n        defineCatch(n, parent);\n        break;\n    case Token.CLASS:\n        defineClass(n, parent);\n        break;\n    case Token.FOR: {\n        Node initializer = n.getFirstChild();\n        while (initializer != null && initializer.getType() != Token.VAR &&\n            initializer.getType() != Token.LET &&\n            initializer.getType() != Token.CONST) {\n            initializer = initializer.getNext();\n        }\n        if (initializer != null) {\n            defineVar(initializer, n);\n        }\n        break;\n    }\n    default:\n        if (NodeUtil.isStatement(n)) {\n            if (parent != null) {\n                if (parent.getType() == Token.FOR &&\n                    parent.getFirstChild() == n) {\n                    // for (var foo in ...) is handled by FOR-IN/OF\n                    // so we do not need to process the variable declaration here\n                    return;\n                } else if (parent.getType() == Token.FUNCTION) {\n                    // This is a generated node used only in the TypeScript rewrite (possibly others?)\n                    // and is not part of the actual JS program.\n                    return;\n              }\n          }\n            // Always allow simple var declarations in loose JS.\n            if (!(loose && n.getType() == Token.VAR && !n.hasTwoChildren())) {\n                t.report(n, VAR_ARGS_LENGTH_MISMATCH);\n            }\n            defineVar(n, parent);\n        }\n        break;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypedScopeCreator.java b/src/com/google/javascript/jscomp/TypedScopeCreator.java\nindex 4b841ae8..6b480e9e 100644\n--- a/src/com/google/javascript/jscomp/TypedScopeCreator.java\n+++ b/src/com/google/javascript/jscomp/TypedScopeCreator.java\n@@ -1448,21 +1448,115 @@ final class TypedScopeCreator implements ScopeCreator {\n         return;\n       }\n \n-      attachLiteralTypes(n);\n-      switch (n.getType()) {\n-        case Token.FUNCTION:\n-          if (parent.getType() == Token.NAME) {\n-            return;\n+switch(n.getType()) {\n+    case Token.FUNCTION: {\n+        Node firstChild = n.getFirstChild();\n+        boolean isExpression = NodeUtil.isFunctionExpression(n);\n+        Node nameNode = null;\n+        if (!isExpression) {\n+            Node secondChild = firstChild.getNext();\n+            if (secondChild.getType() == Token.NAME) {\n+                nameNode = secondChild;\n+            }\n+        }\n+\n+        if (nameNode != null) {\n+            if (nameNode.getString().contains(\"$jscomp$\") ||\n+                // Do not add names for constructors since native super calls are not available in the old\n+                // browser versions. And it is not required for type inference since it assumes a constructor\n+                // and short instead of full names are used for type inference.\n+                NodeUtil.isConstructorDeclaration(n)) {\n+              return; // identifier refers to a synthesized identifier or synthesizeable, default ctor\n+            }\n+\n+            String name = nameNode.getString();\n+            JSType typeOfThis = getJSTypeOfThis(n);\n+            if (es6Module && !inExterns && !isLegacyScript &&\n+                NodeUtil.isTopLevel(n.getParent())) {\n+                // The export annotation is written next to the function declaration in ES6 modules.\n+                JSDocInfo jsdoc = NodeUtil.getBestJSDocInfo(n);\n+                if (jsdoc != null && jsdoc.isExport()) {\n+                    JSType requiredType = registry.getType(name);\n+                    if (requiredType == null) {\n+                        requiredType = registry.createFunctionType(\n+                            typeOfThis, null, null, unknownType);\n+                    }\n+                    registry.setExportedVarType(name, requiredType,\n+                        compiler.getCodingConvention());\n+                }\n+            }\n+\n+            if (!isLegacyScript) {\n+                // If the function is anonymous, don't make its name available for\n+                // typchecking - there's no way to reference it.\n+                if (isExpression) {\n+                    registry.declareType(getTypeDeclaration(nameNode, typeOfThis));\n+                } else {\n+                    registry.declareType(getTypeDeclaration(nameNode, n.getJSType(), typeOfThis));\n+                }\n+            }\n+            if (typeOfThis.isUnknownType() || typeOfThis.isAllType()) {\n+                registry.setNoninjectableType(name);\n+            }\n+        }\n+        break;\n+    }\n+    case Token.VAR:\n+        defineVar(n, parent);\n+        break;\n+    case Token.LET:\n+        defineLet(n, parent);\n+        break;\n+    case Token.CONST:\n+        defineConst(n, parent);\n+        break;\n+    case Token.CATCH:\n+        if (NodeUtil.getEnclosingScope(n).isDeclared(parent.getString(), true)) {\n+            // typed catch parameters must be declared ahead of time,\n+            // as with var declarations\n+            // record the type of the catch variable before declaring it.\n+            JSType type = getJSTypeOfCatchScopeVariable(n, parent);\n+            registry.declareType(getTypeDeclaration(parent, type));\n+        }\n+        defineCatch(n, parent);\n+        break;\n+    case Token.CLASS:\n+        defineClass(n, parent);\n+        break;\n+    case Token.FOR: {\n+        Node initializer = n.getFirstChild();\n+        while (initializer != null && initializer.getType() != Token.VAR &&\n+            initializer.getType() != Token.LET &&\n+            initializer.getType() != Token.CONST) {\n+            initializer = initializer.getNext();\n+        }\n+        if (initializer != null) {\n+            defineVar(initializer, n);\n+        }\n+        break;\n+    }\n+    default:\n+        if (NodeUtil.isStatement(n)) {\n+            if (parent != null) {\n+                if (parent.getType() == Token.FOR &&\n+                    parent.getFirstChild() == n) {\n+                    // for (var foo in ...) is handled by FOR-IN/OF\n+                    // so we do not need to process the variable declaration here\n+                    return;\n+                } else if (parent.getType() == Token.FUNCTION) {\n+                    // This is a generated node used only in the TypeScript rewrite (possibly others?)\n+                    // and is not part of the actual JS program.\n+                    return;\n+              }\n           }\n-          defineDeclaredFunction(n, parent);\n-          break;\n-        case Token.CATCH:\n-          defineCatch(n, parent);\n-          break;\n-        case Token.VAR:\n-          defineVar(n, parent);\n-          break;\n-      }\n+            // Always allow simple var declarations in loose JS.\n+            if (!(loose && n.getType() == Token.VAR && !n.hasTwoChildren())) {\n+                t.report(n, VAR_ARGS_LENGTH_MISMATCH);\n+            }\n+            defineVar(n, parent);\n+        }\n+        break;\n+}\n     }\n \n     /** Handle bleeding functions and function parameters. */",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}