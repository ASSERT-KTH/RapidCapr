{
    "patch": "    private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\n    switch (n.getType()) {\n      case Token.SCRIPT:\n      case Token.BLOCK:\n      case Token.FUNCTION:\n        return;\n\n      case Token.WHILE:\n      case Token.DO:\n      case Token.IF:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n        if (conditional) {\n          recordAllVars(gen, kill, n, false);\n          computeGenKill(n.getFirstChild(), gen, kill, true);\n        } else {\n          computeGenKill(n.getFirstChild(), gen, kill, false);\n          recordAllVars(gen, kill, n, true);\n        }\n        return;\n\n      case Token.FOR:\n        if (!NodeUtil.isForIn(n)) {\n          Node forCondition = NodeUtil.getConditionExpression(n);\n          computeGenKill(forCondition, gen, kill, true);\n          if (conditional) {\n            recordAllVars(gen, kill, forCondition, false);\n          }\n          // First child node is init, getNext() gives condition, getNext() gives increment\n          computeGenKill(n.getFirstChild().getNext(), gen, kill, conditional);\n        } else {\n          Node lhs = n.getFirstChild();\n          // Add both values of the IN node into the kill set\n          addToSetIfLocal(lhs, kill);\n          addToSetIfLocal(lhs.getNext().detach(), kill);\n          recordAllVars(gen, kill, lhs.getNext(), false);\n          computeGenKill(lhs.getNext().getNext(), gen, kill, conditional);\n        }\n        return;\n\n      case Token.VAR:\n        for (Node curr = n.getFirstChild(); curr != null; curr = curr.getNext()) {\n          if (curr.hasChildren()) {\n            Node varInitializer = curr.getFirstChild();\n            computeGenKill(varInitializer, gen, kill, conditional);\n            addToSetIfLocal(curr, gen);\n            if (!conditional) {\n              addToSetIfLocal(curr, kill);\n            }\n          }\n        }\n        return;\n\n      case Token.AND:\n      case Token.OR:\n        computeGenKill(n.getFirstChild(), gen, kill, true);\n        computeGenKill(n.getLastChild(), gen, kill, true);\n        if (!conditional) {\n          Node firstChild = n.getFirstChild();\n          Node lastChild = n.getLastChild();\n\n          BitSet firstChildKill = createBitSet();\n          firstChildKill.or(gen);\n\n          BitSet lastChildKill = createBitSet();\n          lastChildKill.or(gen);\n\n          computeGenKill(firstChild, firstChildKill, createBitSet(), false);\n          computeGenKill(lastChild, lastChildKill, createBitSet(), false);\n\n          gen.or(firstChildKill);\n          gen.or(lastChildKill);\n        }\n        return;\n\n      case Token.HOOK:\n        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n        Node trueExpression = NodeUtil.getSecondChild(n);\n        computeGenKill(trueExpression, gen, kill, true);\n        Node falseExpression = NodeUtil.getLastChild(n);\n        computeGenKill(falseExpression, gen, kill, true);\n\n        if (!conditional) {\n          BitSet trueGen = createBitSet();\n          trueGen.or(kill);\n\n          BitSet falseGen = createBitSet();\n          falseGen.or(kill);\n\n          computeGenKill(trueExpression, trueGen, createBitSet(), false);\n          computeGenKill(falseExpression, falseGen, createBitSet(), false);\n\n          gen.or(trueGen);\n          gen.or(falseGen);\n        }\n        return;\n\n      case Token.NAME:\n        if (!isArgumentsName(n)) {\n          addToSetIfLocal(n, gen);\n        }\n        return;\n\n      default:\n        // All assignments that assign to a local variable or have a local variable on the right\n        // need to be added to the gen set\n        if (NodeUtil.isAssignmentOp(n)\n            && (NodeUtil.isName(n.getFirstChild()) || NodeUtil.isName(n.getLastChild()))) {\n          Node lhs = n.getFirstChild();\n          Node rhs = n.getLastChild();\n          if (NodeUtil.isName(rhs) && !lhs.getString().equals(rhs.getString())) {\n            addToSetIfLocal(rhs, gen);\n          }\n          addToSetIfLocal(lhs, gen);\n          if (!conditional) {\n            addToSetIfLocal(lhs, kill);\n          }\n          computeGenKill(rhs, gen, kill, conditional);\n        } else if (NodeUtil.isCall(n)) {\n          boolean recordArgs = false;\n          Node callee = n.getFirstChild();\n          String functionName = null;\n          if (callerFunctions != null && callee.getType() == Token.NAME) {\n            functionName = callee.getString();\n            if (callerFunctions.contains(functionName)) {\n              recordArgs = true;\n            }\n          }\n          for (Node callChild = callee.getNext(); callChild != null; callChild = callChild.getNext()) {\n            if (recordArgs) {\n              addToSetIfLocal(callChild, gen);\n            }\n            computeGenKill(callChild, gen, kill, conditional);\n          }\n        } else {\n          for (Node curr = n.getFirstChild(); curr != null; curr = curr.getNext()) {\n            computeGenKill(curr, gen, kill, conditional);\n          }\n        }\n        return;\n    }\n  }\n\n  private void recordAllVars(BitSet gen, BitSet kill, Node n, boolean searchChildren) {\n    if (NodeUtil.isLoopStructure(n)) {\n      if (searchChildren) {\n        computeGenKill(n.getFirstChild(), gen, kill, false);\n      }\n      // Loops locally kill all variables that are assigned in the loop body\n      addToKillSetIfLocal(kill, n);\n    } else {\n      // Blocks only kill variables declared in the block\n      Node end = n.getNext();\n      for (Node curr = n.getFirstChild(); curr != end; curr = curr.getNext()) {\n        addToKillSetIfLocal(kill, curr);\n      }\n    }\n  }\n\n  private void addToKillSetIfLocal(BitSet kill, Node n) {\n    if (NodeUtil.isVarDeclaration(n) || NodeUtil.isFunctionDeclaration(n)\n        || NodeUtil.isFunctionExpression(n)) {\n      Node name = NodeUtil.isVarDeclaration(n) ? n.getFirstChild() : n;\n      if (NodeUtil.isName(name)) {\n        String varName = name.getString();\n        Symbol sym = getSymbol(varName);\n        if (sym != null && sym.isLocal()) {\n          int index = sym.getIndex();\n          if (index >= 0) {\n            kill.set(index, true);\n          }\n        }\n      }\n    }\n  }\n\n  private void addToSetIfLocal(Node n, BitSet set) {\n    if (NodeUtil.isName(n)) {\n      String varName = n.getString();\n      Symbol sym = getSymbol(varName);\n      if (sym != null && sym.isLocal()) {\n        int index = sym.getIndex();\n        if (index >= 0) {\n          set.set(index, true);\n        }\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\nindex 7999db40..053499bf 100644\n--- a/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n+++ b/src/com/google/javascript/jscomp/LiveVariablesAnalysis.java\n@@ -175,9 +175,7 @@ class LiveVariablesAnalysis extends\n    * @param conditional {@code true} if any assignments encountered are\n    *        conditionally executed. These assignments might not kill a variable.\n    */\n-  private void computeGenKill(Node n, BitSet gen, BitSet kill,\n-      boolean conditional) {\n-\n+    private void computeGenKill(Node n, BitSet gen, BitSet kill, boolean conditional) {\n     switch (n.getType()) {\n       case Token.SCRIPT:\n       case Token.BLOCK:\n@@ -187,34 +185,43 @@ class LiveVariablesAnalysis extends\n       case Token.WHILE:\n       case Token.DO:\n       case Token.IF:\n-        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n-            conditional);\n+        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n+        if (conditional) {\n+          recordAllVars(gen, kill, n, false);\n+          computeGenKill(n.getFirstChild(), gen, kill, true);\n+        } else {\n+          computeGenKill(n.getFirstChild(), gen, kill, false);\n+          recordAllVars(gen, kill, n, true);\n+        }\n         return;\n \n       case Token.FOR:\n         if (!NodeUtil.isForIn(n)) {\n-          computeGenKill(NodeUtil.getConditionExpression(n), gen, kill,\n-              conditional);\n+          Node forCondition = NodeUtil.getConditionExpression(n);\n+          computeGenKill(forCondition, gen, kill, true);\n+          if (conditional) {\n+            recordAllVars(gen, kill, forCondition, false);\n+          }\n+          // First child node is init, getNext() gives condition, getNext() gives increment\n+          computeGenKill(n.getFirstChild().getNext(), gen, kill, conditional);\n         } else {\n-          // for(x in y) {...}\n           Node lhs = n.getFirstChild();\n-          Node rhs = lhs.getNext();\n-          if (NodeUtil.isVar(lhs)) {\n-            // for(var x in y) {...}\n-            lhs = lhs.getLastChild();\n-          }\n-            addToSetIfLocal(lhs, kill);\n-            addToSetIfLocal(lhs, gen);\n-          computeGenKill(rhs, gen, kill, conditional);\n+          // Add both values of the IN node into the kill set\n+          addToSetIfLocal(lhs, kill);\n+          addToSetIfLocal(lhs.getNext().detach(), kill);\n+          recordAllVars(gen, kill, lhs.getNext(), false);\n+          computeGenKill(lhs.getNext().getNext(), gen, kill, conditional);\n         }\n         return;\n \n       case Token.VAR:\n-        for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-          if (c.hasChildren()) {\n-            computeGenKill(c.getFirstChild(), gen, kill, conditional);\n+        for (Node curr = n.getFirstChild(); curr != null; curr = curr.getNext()) {\n+          if (curr.hasChildren()) {\n+            Node varInitializer = curr.getFirstChild();\n+            computeGenKill(varInitializer, gen, kill, conditional);\n+            addToSetIfLocal(curr, gen);\n             if (!conditional) {\n-              addToSetIfLocal(c, kill);\n+              addToSetIfLocal(curr, kill);\n             }\n           }\n         }\n@@ -222,46 +229,140 @@ class LiveVariablesAnalysis extends\n \n       case Token.AND:\n       case Token.OR:\n-        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n-        // May short circuit.\n+        computeGenKill(n.getFirstChild(), gen, kill, true);\n         computeGenKill(n.getLastChild(), gen, kill, true);\n+        if (!conditional) {\n+          Node firstChild = n.getFirstChild();\n+          Node lastChild = n.getLastChild();\n+\n+          BitSet firstChildKill = createBitSet();\n+          firstChildKill.or(gen);\n+\n+          BitSet lastChildKill = createBitSet();\n+          lastChildKill.or(gen);\n+\n+          computeGenKill(firstChild, firstChildKill, createBitSet(), false);\n+          computeGenKill(lastChild, lastChildKill, createBitSet(), false);\n+\n+          gen.or(firstChildKill);\n+          gen.or(lastChildKill);\n+        }\n         return;\n \n       case Token.HOOK:\n-        computeGenKill(n.getFirstChild(), gen, kill, conditional);\n-        // Assume both sides are conditional.\n-        computeGenKill(n.getFirstChild().getNext(), gen, kill, true);\n-        computeGenKill(n.getLastChild(), gen, kill, true);\n+        computeGenKill(NodeUtil.getConditionExpression(n), gen, kill, true);\n+        Node trueExpression = NodeUtil.getSecondChild(n);\n+        computeGenKill(trueExpression, gen, kill, true);\n+        Node falseExpression = NodeUtil.getLastChild(n);\n+        computeGenKill(falseExpression, gen, kill, true);\n+\n+        if (!conditional) {\n+          BitSet trueGen = createBitSet();\n+          trueGen.or(kill);\n+\n+          BitSet falseGen = createBitSet();\n+          falseGen.or(kill);\n+\n+          computeGenKill(trueExpression, trueGen, createBitSet(), false);\n+          computeGenKill(falseExpression, falseGen, createBitSet(), false);\n+\n+          gen.or(trueGen);\n+          gen.or(falseGen);\n+        }\n         return;\n \n       case Token.NAME:\n-        if (isArgumentsName(n)) {\n-          markAllParametersEscaped();\n-        } else {\n+        if (!isArgumentsName(n)) {\n           addToSetIfLocal(n, gen);\n         }\n         return;\n \n       default:\n-        if (NodeUtil.isAssignmentOp(n) && NodeUtil.isName(n.getFirstChild())) {\n+        // All assignments that assign to a local variable or have a local variable on the right\n+        // need to be added to the gen set\n+        if (NodeUtil.isAssignmentOp(n)\n+            && (NodeUtil.isName(n.getFirstChild()) || NodeUtil.isName(n.getLastChild()))) {\n           Node lhs = n.getFirstChild();\n+          Node rhs = n.getLastChild();\n+          if (NodeUtil.isName(rhs) && !lhs.getString().equals(rhs.getString())) {\n+            addToSetIfLocal(rhs, gen);\n+          }\n+          addToSetIfLocal(lhs, gen);\n           if (!conditional) {\n             addToSetIfLocal(lhs, kill);\n           }\n-          if (!NodeUtil.isAssign(n)) {\n-            // assignments such as a += 1 reads a.\n-            addToSetIfLocal(lhs, gen);\n+          computeGenKill(rhs, gen, kill, conditional);\n+        } else if (NodeUtil.isCall(n)) {\n+          boolean recordArgs = false;\n+          Node callee = n.getFirstChild();\n+          String functionName = null;\n+          if (callerFunctions != null && callee.getType() == Token.NAME) {\n+            functionName = callee.getString();\n+            if (callerFunctions.contains(functionName)) {\n+              recordArgs = true;\n+            }\n+          }\n+          for (Node callChild = callee.getNext(); callChild != null; callChild = callChild.getNext()) {\n+            if (recordArgs) {\n+              addToSetIfLocal(callChild, gen);\n+            }\n+            computeGenKill(callChild, gen, kill, conditional);\n           }\n-          computeGenKill(lhs.getNext(), gen, kill, conditional);\n         } else {\n-          for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n-            computeGenKill(c, gen, kill, conditional);\n+          for (Node curr = n.getFirstChild(); curr != null; curr = curr.getNext()) {\n+            computeGenKill(curr, gen, kill, conditional);\n           }\n         }\n         return;\n     }\n   }\n \n+  private void recordAllVars(BitSet gen, BitSet kill, Node n, boolean searchChildren) {\n+    if (NodeUtil.isLoopStructure(n)) {\n+      if (searchChildren) {\n+        computeGenKill(n.getFirstChild(), gen, kill, false);\n+      }\n+      // Loops locally kill all variables that are assigned in the loop body\n+      addToKillSetIfLocal(kill, n);\n+    } else {\n+      // Blocks only kill variables declared in the block\n+      Node end = n.getNext();\n+      for (Node curr = n.getFirstChild(); curr != end; curr = curr.getNext()) {\n+        addToKillSetIfLocal(kill, curr);\n+      }\n+    }\n+  }\n+\n+  private void addToKillSetIfLocal(BitSet kill, Node n) {\n+    if (NodeUtil.isVarDeclaration(n) || NodeUtil.isFunctionDeclaration(n)\n+        || NodeUtil.isFunctionExpression(n)) {\n+      Node name = NodeUtil.isVarDeclaration(n) ? n.getFirstChild() : n;\n+      if (NodeUtil.isName(name)) {\n+        String varName = name.getString();\n+        Symbol sym = getSymbol(varName);\n+        if (sym != null && sym.isLocal()) {\n+          int index = sym.getIndex();\n+          if (index >= 0) {\n+            kill.set(index, true);\n+          }\n+        }\n+      }\n+    }\n+  }\n+\n+  private void addToSetIfLocal(Node n, BitSet set) {\n+    if (NodeUtil.isName(n)) {\n+      String varName = n.getString();\n+      Symbol sym = getSymbol(varName);\n+      if (sym != null && sym.isLocal()) {\n+        int index = sym.getIndex();\n+        if (index >= 0) {\n+          set.set(index, true);\n+        }\n+      }\n+    }\n+  }\n+\n   private void addToSetIfLocal(Node node, BitSet set) {\n     Preconditions.checkState(NodeUtil.isName(node));\n     String name = node.getString();",
    "result_reason": "error: method addToSetIfLocal(Node,BitSet) is already defined in class LiveVariablesAnalysis",
    "test_result": "ERROR"
}