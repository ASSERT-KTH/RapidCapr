{
    "patch": "private boolean isDirective(Node n) {\n  if (n == null) {\n    return false;\n  }\n\n  int nType = n.getType();\n  return nType == Token.EXPR_RESULT &&\n      n.getFirstChild().isString() &&\n      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n}\n\n@Override\nNode processBlock(Block blockNode) {\n  return processGeneric(blockNode);\n}\n\n@Override\nNode processBreakStatement(BreakStatement statementNode) {\n  Node node = IRFactory.createNode(Token.BREAK);\n  if (statementNode.getBreakLabel() != null) {\n    Node labelName = transform(statementNode.getBreakLabel());\n    labelName.setType(Token.LABEL_NAME);\n    node.addChildToBack(labelName);\n  }\n  return node;\n}\n\n@Override\nNode processCatchClause(CatchClause clauseNode) {\n  AstNode catchVar = clauseNode.getVarName();\n  Node node = IRFactory.createNode(Token.CATCH, transform(catchVar));\n  if (clauseNode.getCatchCondition() != null) {\n    errorReporter.error(\n        \"Catch clauses are not supported\",\n        sourceName,\n        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n  }\n  node.addChildToBack(transformBlock(clauseNode.getBody()));\n  return node;\n}\n\n@Override\nNode processConditionalExpression(ConditionalExpression exprNode) {\n  return IRFactory.createNode(\n      Token.HOOK,\n      transform(exprNode.getTestExpression()),\n      transform(exprNode.getTrueExpression()),\n      transform(exprNode.getFalseExpression()));\n}\n\n@Override\nNode processContinueStatement(ContinueStatement statementNode) {\n  Node node = IRFactory.createNode(Token.CONTINUE);\n  if (statementNode.getLabel() != null) {\n    Node labelName = transform(statementNode.getLabel());\n    labelName.setType(Token.LABEL_NAME);\n    node.addChildToBack(labelName);\n  }\n  return node;\n}\n\n@Override\nNode processDoLoop(DoLoop loopNode) {\n  return IRFactory.createNode(\n      Token.DO,\n      transformBlock(loopNode.getBody()),\n      transform(loopNode.getCondition()));\n}\n\n@Override\nNode processElementGet(ElementGet getNode) {\n  return IRFactory.createNode(\n      Token.GETELEM,\n      transform(getNode.getTarget()),\n      transform(getNode.getElement()));\n}\n\n@Override\nNode processEmptyExpression(EmptyExpression exprNode) {\n  Node node = IRFactory.createNode(Token.EMPTY);\n  return node;\n}\n\n@Override\nNode processExpressionStatement(ExpressionStatement statementNode) {\n  Node node = IRFactory.createNode(transformTokenType(statementNode.getType()));\n  node.addChildToBack(transform(statementNode.getExpression()));\n  return node;\n}\n\n@Override\nNode processForInLoop(ForInLoop loopNode) {\n  Node lhsNode = transform(loopNode.getIterator());\n  Node rhsNode = transform(loopNode.getIteratedObject());\n  Node bodyNode = transformBlock(loopNode.getBody());\n  Node node = IRFactory.createNode(Token.FOR_OF, lhsNode, rhsNode, bodyNode);\n  // mark the for/in loop as being defined to be a statement\n  node.putProp(Node.FOR_IN_DEF_PROP, Boolean.TRUE);\n  return node; \n}\n\n@Override\nNode processForLoop(ForLoop loopNode) {\n  Node init = loopNode.getInitializer() != null ? transform(loopNode.getInitializer()) : null;\n  Node cond = loopNode.getCondition() != null ? transform(loopNode.getCondition()) : null;\n  Node incr = loopNode.getIncrement() != null ? transform(loopNode.getIncrement()) : null;\n  Node body = transformBlock(loopNode.getBody());\n  return IRFactory.createNode(Token.FOR, init, cond, incr, body);\n}\n\n@Override\nNode processFunctionCall(FunctionCall callNode) {\n  Node target = transform(callNode.getTarget());\n  List<AstNode> args = callNode.getArguments();\n  Node[] children = new Node[args.size() + 1];\n  children[0] = target;\n  int i = 1;\n  for (AstNode arg : args) {\n    children[i++] = transform(arg);\n  }\n  return IRFactory.createNode(Token.CALL, children);\n}\n\n@Override\nNode processFunctionNode(FunctionNode functionNode) {\n  // If this is the function node of an arrow function, it will already have\n  // been marked as a param list, since arrow functions don't have a separate\n  // parameter list.\n  boolean isParamList = functionNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n  List<AstNode> memberNodes = new ArrayList<>();\n  int parameterCount = functionNode.getParamCount();\n\n  if (functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION) {\n    // add the parameters from the assigned node as MEMBER_NAME nodes\n    parameterCount = functionNode.getAssignedArgsCount();\n    for (int i = 0; i < parameterCount; ++i) {\n      AstNode paramNode = functionNode.getFunctionParameters().getParam(i);\n      String paramName = functionNode.getAssignedArgName(i);\n      if (paramName != null) {\n        Node memberName =\n            IRFactory.createString(Token.MEMBER_NAME, paramName).copyInformationFrom(paramNode);\n        memberNodes.add(memberName);\n\n        // Check if it's a destructuring param.\n        if (paramNode.getType() == Token.ARRAYLIT || paramNode.getType() == Token.OBJECTLIT) {\n          destructuringParams.put(paramNode, memberName);\n        }\n      } else {\n        memberNodes.add(transform(paramNode));\n      }\n    }\n  } else {\n    for (int i = 0; i < parameterCount; ++i) {\n      AstNode paramNode = functionNode.getParamOrVarName(i);\n      Node node;\n      if (paramNode instanceof Name) {\n        node = IRFactory.createString(Token.NAME, ((Name) paramNode).getIdentifier());\n      } else {\n        node = transform(paramNode);\n        // Check if it's a destructuring param.\n        if (paramNode.getType() == Token.ARRAYLIT || paramNode.getType() == Token.OBJECTLIT) {\n          destructuringParams.put(paramNode, node);\n        }\n      }\n      if (isParamList) {\n        node.setIsParam(true);\n      }\n      memberNodes.add(node);\n    }\n  }\n\n  Node parameters = IRFactory.createNode(Token.PARAM_LIST, memberNodes.toArray(new Node[0]));\n\n  Node body = transform(functionNode.getBody());\n  Node functionName = null;\n  int functionType = functionNode.getFunctionType();\n  if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n    functionName = IRFactory.createName(functionNode.getName());\n  }\n\n  Node function = IRFactory.createNode(Token.FUNCTION, functionName, parameters, body);\n  function.setIsArrowFunction(functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION);\n\n  List<AstNode> arrayComprehensionNodes = new ArrayList<>();\n  for (Scope scope = functionNode.getScope(); scope != null; scope = scope.getParentScope()) {\n    if (scope instanceof FunctionNode) {\n      arrayComprehensionNodes.addAll(((FunctionNode) scope).getArrayComprehensionNodes());\n    }\n  }\n  function.putProp(Node.PRAGMA_ARRAY_COMP, arrayComprehensionNodes.toArray(new Node[0]));\n\n  if (functionNode.getSourceName() != null) {\n    function.setStaticSourceFile(functionNode.getSourceName());\n  }\n  return function;\n}\n\n@Override\nNode processIfStatement(IfStatement statementNode) {\n  Node condition = transform(statementNode.getCondition());\n  Node thenPart = transform(statementNode.getThenPart());\n  Node elsePart = statementNode.getElsePart() != null ? transform(statementNode.getElsePart()) : null;\n  return IRFactory.createNode(Token.IF, condition, thenPart, elsePart);\n}\n\n@Override\nNode processInfixExpression(InfixExpression expressionNode) {\n  int type = expressionNode.getType();\n  if (type == Token.AND || type == Token.OR) {\n    return processLogicalExpression(expressionNode);\n  }\n  Node left = transform(expressionNode.getLeft());\n  Node right = transform(expressionNode.getRight());\n  return IRFactory.createNode(transformTokenType(type), left, right);\n}\n\n@Override\nNode processKeywordLiteral(KeywordLiteral literalNode) {\n  int type = literalNode.getType();\n  switch (type) {\n    case Token.NULL:\n    case Token.TRUE:\n    case Token.FALSE:\n    case Token.THIS:\n      return IRFactory.createNode(transformTokenType(type));\n    default:\n      throw new RuntimeException(\"Unhandled keyword literal type: \" + type);\n  }\n}\n\n@Override\nNode processName(Name nameNode) {\n  String identifier = nameNode.getIdentifier();\n  boolean isFromExterns = nameNode.getLineno() <= 0;\n  if (isDirective(nameNode.getParent()) && !isFromExterns) {\n    return IRFactory.createString(Token.STRING, identifier);\n  }\n\n  Node name = IRFactory.createName(identifier);\n  if (isFromExterns) {\n    // Tokens that come from the externs file are automatically considered\n    // constants: they can't be assigned to, and they're never renamed or\n    // minified.  Other names can also be marked as constants, which makes\n    // sense if, for example, you have a variable that is only assigned to\n    // once, near its declaration, and is never assigned to again.\n    name.putProp(Node.IS_CONSTANT_NAME, Boolean.TRUE);\n  }\n  return name;\n}\n\n@Override\nNode processNewExpression(NewExpression callNode) {\n  Node target = transform(callNode.getTarget());\n  List<AstNode> args = callNode.getArguments();\n  Node[] children = new Node[args.size() + 1];\n  children[0] = target;\n  int i = 1;\n  for (AstNode arg : args) {\n    children[i++] = transform(arg);\n  }\n  return IRFactory.createNode(Token.NEW, children);\n}\n\n@Override\nNode processNumber(NumberLiteral numberNode) {\n  String value = numberNode.getValue();\n  return IRFactory.createNumber(value);\n}\n\n@Override\nNode processObjectLiteral(ObjectLiteral literalNode) {\n  List<ObjectProperty> properties = literalNode.getElements();\n  Node[] children = new Node[properties.size() * 2];\n  int i = 0;\n  for (ObjectProperty prop : properties) {\n    AstNode keyNode = prop.getLeft();\n    Node valueNode = transform(prop.getRight());\n    Node key;\n    if (keyNode instanceof StringLiteral) {\n      key = IRFactory.createString(Token.STRING, ((StringLiteral) keyNode).getValue());\n    } else if (keyNode instanceof Name) {\n      key = IRFactory.createString(Token.STRING, ((Name) keyNode).getIdentifier());\n    } else if (keyNode instanceof NumberLiteral) {\n      key = IRFactory.createNumber(((NumberLiteral) keyNode).getValue());\n    } else {\n      key = transform(keyNode);\n    }\n    children[i++] = key;\n    children[i++] = valueNode;\n  }\n  return IRFactory.createNode(Token.OBJECTLIT, children);\n}\n\n@Override\nNode processParenthesizedExpression(ParenthesizedExpression expressionNode) {\n  return transform(expressionNode.getExpression());\n}\n\n@Override\nNode processRegExpLiteral(RegExpLiteral regExpNode) {\n  return IRFactory.createRegexp(regExpNode.getValue(), regExpNode.getFlags());\n}\n\n@Override\nNode processReturnStatement(ReturnStatement statementNode) {\n  return IRFactory.createNode(\n      Token.RETURN, statementNode.getReturnValue() != null ? transform(statementNode.getReturnValue()) : null);\n}\n\n@Override\nNode processString(StringLiteral stringNode) {\n  return IRFactory.createString(Token.STRING, stringNode.getValue());\n}\n\n@Override\nNode processSwitchCase(SwitchCase switchCaseNode) {\n  // A switch case is made up of two nodes. The first is a `case`\n  // or `default` node with no children, and the second is a\n  // `block` node that contains the body of the case.\n  List<Node> children = new ArrayList<>();\n  Node test = transform(switchCaseNode.getExpression());\n  Node caseNode = IRFactory.createNode(Token.CASE, test);\n\n  // if the test value is null the case is default\n  if (test == null) {\n    caseNode.setType(Token.DEFAULT);\n  }\n  children.add(caseNode);\n  Node body = transform(switchCaseNode.getStatements());\n  children.add(body);\n  return IRFactory.createNode(Token.BLOCK, children.toArray(new Node[0]));\n}\n\n@Override\nNode processSwitchStatement(SwitchStatement statementNode) {\n  Node expr = transform(statementNode.getExpression());\n  Node block = transform(statementNode.getCases());\n  return IRFactory.createNode(Token.SWITCH, expr, block);\n}\n\nNode transform(AstNode node) {\n  return node == null ? null : node.accept(this);\n}\n\nprivate Node transformBlock(AstNode node) {\n  if (node == null) {\n    return null;\n  }\n  if (node.getType() == Token.BLOCK) {\n    // A simple optimization: if the node is already a block,\n    // don't create a new block.\n    return transform(node);\n  } else {\n    return IRFactory.createBlock(transform(node));\n  }\n}\n\nprivate Token transformTokenType(int tokenType) {\n  switch (tokenType) {\n    case Token.ADD:\n      return Token.ADD;\n    case Token.AND:\n      return Token.AND;\n    case Token.ASSIGN:\n      return Token.ASSIGN;\n    case Token.BITAND:\n      return Token.BITAND;\n    case Token.BITOR:\n      return Token.BITOR;\n    case Token.BITXOR:\n      return Token.BITXOR;\n    case Token.COLON:\n      return Token.COLON;\n    case Token.COMMA:\n      return Token.COMMA;\n    case Token.DEC:\n      return Token.DEC;\n    case Token.DIV:\n      return Token.DIV;\n    case Token.DOT:\n      return Token.DOT;\n    case Token.EQ:\n      return Token.EQ;\n    case Token.GE:\n      return Token.GE;\n    case Token.GT:\n      return Token.GT;\n    case Token.IN:\n      return Token.IN;\n    case Token.INSTANCEOF:\n      return Token.INSTANCEOF;\n    case Token.LB:\n      return Token.LB;\n    case Token.LC:\n      return Token.LC;\n    case Token.LE:\n      return Token.LE;\n    case Token.LSH:\n      return Token.LSH;\n    case Token.LT:\n      return Token.LT;\n    case Token.MOD:\n      return Token.MOD;\n    case Token.MUL:\n      return Token.MUL;\n    case Token.NAME:\n      return Token.NAME;\n    case Token.NE:\n      return Token.NE;\n    case Token.NEW:\n      return Token.NEW;\n    case Token.NOT:\n      return Token.NOT;\n    case Token.NULL:\n      return Token.NULL;\n    case Token.NU",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..6ab566d1 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,422 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+private boolean isDirective(Node n) {\n+  if (n == null) {\n+    return false;\n+  }\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  int nType = n.getType();\n+  return nType == Token.EXPR_RESULT &&\n+      n.getFirstChild().isString() &&\n+      ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+}\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+@Override\n+Node processBlock(Block blockNode) {\n+  return processGeneric(blockNode);\n+}\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+@Override\n+Node processBreakStatement(BreakStatement statementNode) {\n+  Node node = IRFactory.createNode(Token.BREAK);\n+  if (statementNode.getBreakLabel() != null) {\n+    Node labelName = transform(statementNode.getBreakLabel());\n+    labelName.setType(Token.LABEL_NAME);\n+    node.addChildToBack(labelName);\n+  }\n+  return node;\n+}\n+\n+@Override\n+Node processCatchClause(CatchClause clauseNode) {\n+  AstNode catchVar = clauseNode.getVarName();\n+  Node node = IRFactory.createNode(Token.CATCH, transform(catchVar));\n+  if (clauseNode.getCatchCondition() != null) {\n+    errorReporter.error(\n+        \"Catch clauses are not supported\",\n+        sourceName,\n+        clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  }\n+  node.addChildToBack(transformBlock(clauseNode.getBody()));\n+  return node;\n+}\n+\n+@Override\n+Node processConditionalExpression(ConditionalExpression exprNode) {\n+  return IRFactory.createNode(\n+      Token.HOOK,\n+      transform(exprNode.getTestExpression()),\n+      transform(exprNode.getTrueExpression()),\n+      transform(exprNode.getFalseExpression()));\n+}\n+\n+@Override\n+Node processContinueStatement(ContinueStatement statementNode) {\n+  Node node = IRFactory.createNode(Token.CONTINUE);\n+  if (statementNode.getLabel() != null) {\n+    Node labelName = transform(statementNode.getLabel());\n+    labelName.setType(Token.LABEL_NAME);\n+    node.addChildToBack(labelName);\n+  }\n+  return node;\n+}\n+\n+@Override\n+Node processDoLoop(DoLoop loopNode) {\n+  return IRFactory.createNode(\n+      Token.DO,\n+      transformBlock(loopNode.getBody()),\n+      transform(loopNode.getCondition()));\n+}\n+\n+@Override\n+Node processElementGet(ElementGet getNode) {\n+  return IRFactory.createNode(\n+      Token.GETELEM,\n+      transform(getNode.getTarget()),\n+      transform(getNode.getElement()));\n+}\n+\n+@Override\n+Node processEmptyExpression(EmptyExpression exprNode) {\n+  Node node = IRFactory.createNode(Token.EMPTY);\n+  return node;\n+}\n+\n+@Override\n+Node processExpressionStatement(ExpressionStatement statementNode) {\n+  Node node = IRFactory.createNode(transformTokenType(statementNode.getType()));\n+  node.addChildToBack(transform(statementNode.getExpression()));\n+  return node;\n+}\n+\n+@Override\n+Node processForInLoop(ForInLoop loopNode) {\n+  Node lhsNode = transform(loopNode.getIterator());\n+  Node rhsNode = transform(loopNode.getIteratedObject());\n+  Node bodyNode = transformBlock(loopNode.getBody());\n+  Node node = IRFactory.createNode(Token.FOR_OF, lhsNode, rhsNode, bodyNode);\n+  // mark the for/in loop as being defined to be a statement\n+  node.putProp(Node.FOR_IN_DEF_PROP, Boolean.TRUE);\n+  return node; \n+}\n+\n+@Override\n+Node processForLoop(ForLoop loopNode) {\n+  Node init = loopNode.getInitializer() != null ? transform(loopNode.getInitializer()) : null;\n+  Node cond = loopNode.getCondition() != null ? transform(loopNode.getCondition()) : null;\n+  Node incr = loopNode.getIncrement() != null ? transform(loopNode.getIncrement()) : null;\n+  Node body = transformBlock(loopNode.getBody());\n+  return IRFactory.createNode(Token.FOR, init, cond, incr, body);\n+}\n+\n+@Override\n+Node processFunctionCall(FunctionCall callNode) {\n+  Node target = transform(callNode.getTarget());\n+  List<AstNode> args = callNode.getArguments();\n+  Node[] children = new Node[args.size() + 1];\n+  children[0] = target;\n+  int i = 1;\n+  for (AstNode arg : args) {\n+    children[i++] = transform(arg);\n+  }\n+  return IRFactory.createNode(Token.CALL, children);\n+}\n+\n+@Override\n+Node processFunctionNode(FunctionNode functionNode) {\n+  // If this is the function node of an arrow function, it will already have\n+  // been marked as a param list, since arrow functions don't have a separate\n+  // parameter list.\n+  boolean isParamList = functionNode.getFunctionType() == FunctionNode.FUNCTION_STATEMENT;\n+  List<AstNode> memberNodes = new ArrayList<>();\n+  int parameterCount = functionNode.getParamCount();\n+\n+  if (functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION) {\n+    // add the parameters from the assigned node as MEMBER_NAME nodes\n+    parameterCount = functionNode.getAssignedArgsCount();\n+    for (int i = 0; i < parameterCount; ++i) {\n+      AstNode paramNode = functionNode.getFunctionParameters().getParam(i);\n+      String paramName = functionNode.getAssignedArgName(i);\n+      if (paramName != null) {\n+        Node memberName =\n+            IRFactory.createString(Token.MEMBER_NAME, paramName).copyInformationFrom(paramNode);\n+        memberNodes.add(memberName);\n+\n+        // Check if it's a destructuring param.\n+        if (paramNode.getType() == Token.ARRAYLIT || paramNode.getType() == Token.OBJECTLIT) {\n+          destructuringParams.put(paramNode, memberName);\n+        }\n+      } else {\n+        memberNodes.add(transform(paramNode));\n       }\n-      return node;\n     }\n-\n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  } else {\n+    for (int i = 0; i < parameterCount; ++i) {\n+      AstNode paramNode = functionNode.getParamOrVarName(i);\n+      Node node;\n+      if (paramNode instanceof Name) {\n+        node = IRFactory.createString(Token.NAME, ((Name) paramNode).getIdentifier());\n+      } else {\n+        node = transform(paramNode);\n+        // Check if it's a destructuring param.\n+        if (paramNode.getType() == Token.ARRAYLIT || paramNode.getType() == Token.OBJECTLIT) {\n+          destructuringParams.put(paramNode, node);\n+        }\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+      if (isParamList) {\n+        node.setIsParam(true);\n+      }\n+      memberNodes.add(node);\n     }\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+  Node parameters = IRFactory.createNode(Token.PARAM_LIST, memberNodes.toArray(new Node[0]));\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+  Node body = transform(functionNode.getBody());\n+  Node functionName = null;\n+  int functionType = functionNode.getFunctionType();\n+  if (functionType != FunctionNode.FUNCTION_EXPRESSION) {\n+    functionName = IRFactory.createName(functionNode.getName());\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n+  Node function = IRFactory.createNode(Token.FUNCTION, functionName, parameters, body);\n+  function.setIsArrowFunction(functionNode.getFunctionType() == FunctionNode.ARROW_FUNCTION);\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  List<AstNode> arrayComprehensionNodes = new ArrayList<>();\n+  for (Scope scope = functionNode.getScope(); scope != null; scope = scope.getParentScope()) {\n+    if (scope instanceof FunctionNode) {\n+      arrayComprehensionNodes.addAll(((FunctionNode) scope).getArrayComprehensionNodes());\n     }\n+  }\n+  function.putProp(Node.PRAGMA_ARRAY_COMP, arrayComprehensionNodes.toArray(new Node[0]));\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n+  if (functionNode.getSourceName() != null) {\n+    function.setStaticSourceFile(functionNode.getSourceName());\n+  }\n+  return function;\n+}\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n-    }\n+@Override\n+Node processIfStatement(IfStatement statementNode) {\n+  Node condition = transform(statementNode.getCondition());\n+  Node thenPart = transform(statementNode.getThenPart());\n+  Node elsePart = statementNode.getElsePart() != null ? transform(statementNode.getElsePart()) : null;\n+  return IRFactory.createNode(Token.IF, condition, thenPart, elsePart);\n+}\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+@Override\n+Node processInfixExpression(InfixExpression expressionNode) {\n+  int type = expressionNode.getType();\n+  if (type == Token.AND || type == Token.OR) {\n+    return processLogicalExpression(expressionNode);\n+  }\n+  Node left = transform(expressionNode.getLeft());\n+  Node right = transform(expressionNode.getRight());\n+  return IRFactory.createNode(transformTokenType(type), left, right);\n+}\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+@Override\n+Node processKeywordLiteral(KeywordLiteral literalNode) {\n+  int type = literalNode.getType();\n+  switch (type) {\n+    case Token.NULL:\n+    case Token.TRUE:\n+    case Token.FALSE:\n+    case Token.THIS:\n+      return IRFactory.createNode(transformTokenType(type));\n+    default:\n+      throw new RuntimeException(\"Unhandled keyword literal type: \" + type);\n+  }\n+}\n+\n+@Override\n+Node processName(Name nameNode) {\n+  String identifier = nameNode.getIdentifier();\n+  boolean isFromExterns = nameNode.getLineno() <= 0;\n+  if (isDirective(nameNode.getParent()) && !isFromExterns) {\n+    return IRFactory.createString(Token.STRING, identifier);\n+  }\n+\n+  Node name = IRFactory.createName(identifier);\n+  if (isFromExterns) {\n+    // Tokens that come from the externs file are automatically considered\n+    // constants: they can't be assigned to, and they're never renamed or\n+    // minified.  Other names can also be marked as constants, which makes\n+    // sense if, for example, you have a variable that is only assigned to\n+    // once, near its declaration, and is never assigned to again.\n+    name.putProp(Node.IS_CONSTANT_NAME, Boolean.TRUE);\n+  }\n+  return name;\n+}\n+\n+@Override\n+Node processNewExpression(NewExpression callNode) {\n+  Node target = transform(callNode.getTarget());\n+  List<AstNode> args = callNode.getArguments();\n+  Node[] children = new Node[args.size() + 1];\n+  children[0] = target;\n+  int i = 1;\n+  for (AstNode arg : args) {\n+    children[i++] = transform(arg);\n+  }\n+  return IRFactory.createNode(Token.NEW, children);\n+}\n+\n+@Override\n+Node processNumber(NumberLiteral numberNode) {\n+  String value = numberNode.getValue();\n+  return IRFactory.createNumber(value);\n+}\n+\n+@Override\n+Node processObjectLiteral(ObjectLiteral literalNode) {\n+  List<ObjectProperty> properties = literalNode.getElements();\n+  Node[] children = new Node[properties.size() * 2];\n+  int i = 0;\n+  for (ObjectProperty prop : properties) {\n+    AstNode keyNode = prop.getLeft();\n+    Node valueNode = transform(prop.getRight());\n+    Node key;\n+    if (keyNode instanceof StringLiteral) {\n+      key = IRFactory.createString(Token.STRING, ((StringLiteral) keyNode).getValue());\n+    } else if (keyNode instanceof Name) {\n+      key = IRFactory.createString(Token.STRING, ((Name) keyNode).getIdentifier());\n+    } else if (keyNode instanceof NumberLiteral) {\n+      key = IRFactory.createNumber(((NumberLiteral) keyNode).getValue());\n+    } else {\n+      key = transform(keyNode);\n     }\n+    children[i++] = key;\n+    children[i++] = valueNode;\n+  }\n+  return IRFactory.createNode(Token.OBJECTLIT, children);\n+}\n+\n+@Override\n+Node processParenthesizedExpression(ParenthesizedExpression expressionNode) {\n+  return transform(expressionNode.getExpression());\n+}\n+\n+@Override\n+Node processRegExpLiteral(RegExpLiteral regExpNode) {\n+  return IRFactory.createRegexp(regExpNode.getValue(), regExpNode.getFlags());\n+}\n+\n+@Override\n+Node processReturnStatement(ReturnStatement statementNode) {\n+  return IRFactory.createNode(\n+      Token.RETURN, statementNode.getReturnValue() != null ? transform(statementNode.getReturnValue()) : null);\n+}\n+\n+@Override\n+Node processString(StringLiteral stringNode) {\n+  return IRFactory.createString(Token.STRING, stringNode.getValue());\n+}\n+\n+@Override\n+Node processSwitchCase(SwitchCase switchCaseNode) {\n+  // A switch case is made up of two nodes. The first is a `case`\n+  // or `default` node with no children, and the second is a\n+  // `block` node that contains the body of the case.\n+  List<Node> children = new ArrayList<>();\n+  Node test = transform(switchCaseNode.getExpression());\n+  Node caseNode = IRFactory.createNode(Token.CASE, test);\n+\n+  // if the test value is null the case is default\n+  if (test == null) {\n+    caseNode.setType(Token.DEFAULT);\n+  }\n+  children.add(caseNode);\n+  Node body = transform(switchCaseNode.getStatements());\n+  children.add(body);\n+  return IRFactory.createNode(Token.BLOCK, children.toArray(new Node[0]));\n+}\n+\n+@Override\n+Node processSwitchStatement(SwitchStatement statementNode) {\n+  Node expr = transform(statementNode.getExpression());\n+  Node block = transform(statementNode.getCases());\n+  return IRFactory.createNode(Token.SWITCH, expr, block);\n+}\n+\n+Node transform(AstNode node) {\n+  return node == null ? null : node.accept(this);\n+}\n+\n+private Node transformBlock(AstNode node) {\n+  if (node == null) {\n+    return null;\n+  }\n+  if (node.getType() == Token.BLOCK) {\n+    // A simple optimization: if the node is already a block,\n+    // don't create a new block.\n+    return transform(node);\n+  } else {\n+    return IRFactory.createBlock(transform(node));\n+  }\n+}\n+\n+private Token transformTokenType(int tokenType) {\n+  switch (tokenType) {\n+    case Token.ADD:\n+      return Token.ADD;\n+    case Token.AND:\n+      return Token.AND;\n+    case Token.ASSIGN:\n+      return Token.ASSIGN;\n+    case Token.BITAND:\n+      return Token.BITAND;\n+    case Token.BITOR:\n+      return Token.BITOR;\n+    case Token.BITXOR:\n+      return Token.BITXOR;\n+    case Token.COLON:\n+      return Token.COLON;\n+    case Token.COMMA:\n+      return Token.COMMA;\n+    case Token.DEC:\n+      return Token.DEC;\n+    case Token.DIV:\n+      return Token.DIV;\n+    case Token.DOT:\n+      return Token.DOT;\n+    case Token.EQ:\n+      return Token.EQ;\n+    case Token.GE:\n+      return Token.GE;\n+    case Token.GT:\n+      return Token.GT;\n+    case Token.IN:\n+      return Token.IN;\n+    case Token.INSTANCEOF:\n+      return Token.INSTANCEOF;\n+    case Token.LB:\n+      return Token.LB;\n+    case Token.LC:\n+      return Token.LC;\n+    case Token.LE:\n+      return Token.LE;\n+    case Token.LSH:\n+      return Token.LSH;\n+    case Token.LT:\n+      return Token.LT;\n+    case Token.MOD:\n+      return Token.MOD;\n+    case Token.MUL:\n+      return Token.MUL;\n+    case Token.NAME:\n+      return Token.NAME;\n+    case Token.NE:\n+      return Token.NE;\n+    case Token.NEW:\n+      return Token.NEW;\n+    case Token.NOT:\n+      return Token.NOT;\n+    case Token.NULL:\n+      return Token.NULL;\n+    case Token.NU\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}