{
    "patch": "import jdk.nashorn.api.tree.*;\n\nclass InOperatorTransformer extends TreeTranslator<Void, Context> {\n\n    @Override\n    public Void visitForLoop(ForLoopTree node, Context rhsContext) {\n        ExpressionTree condition = node.getCondition();\n        StatementTree statement = node.getStatement();\n\n        if (condition.getKind() == Kind.BINARY) {\n            BinaryTree binaryTree = (BinaryTree) condition;\n            \n            if (binaryTree.getKind() == Kind.LOGICAL_AND) {\n                ExpressionTree lhs = binaryTree.getLeftOperand();\n                ExpressionTree rhs = binaryTree.getRightOperand();\n\n                if (lhs.getKind() == Kind.EQUAL_TO && isNumericLiteral(lhs, rhsContext)) {\n                    LiteralTree literalTree = (LiteralTree) lhs.getRightOperand();\n                    int literalValue = (int) literalTree.getValue();\n\n                    if (rhs.getKind() == Kind.IN) {\n                        InOperatorTree inOperator = (InOperatorTree) rhs;\n                        ExpressionTree arrayExpr = inOperator.getExpression();\n                        if (arrayExpr.getKind() == Kind.IDENTIFIER) {\n                            IdentifierTree identifier = (IdentifierTree) arrayExpr;\n                            if (isArray(identifier, rhsContext)) {\n                                Name varName = identifier.getName();\n                                List<ExpressionTree> elements = getArrayElements(identifier, rhsContext);\n\n                                if (literalValue < elements.size() && elements.get(literalValue) != null) {\n                                    context.addNewForLoop(node);\n                                    context.addTransformedNodes(node);\n\n                                    VariableTree variableTree = makeNewForLoopVariable(elements.get(literalValue));\n                                    ExpressionTree newCondition = createNewCondition(binaryTree, variableTree.getName(), rhsContext);\n\n                                    ForLoopTree newForLoopTree = makeNewForLoop(variableTree, newCondition, statement);\n                                    context.addTransformedNodes(newForLoopTree);\n\n                                    return null;\n                                }\n                            }\n                        }\n                    }\n                }\n            }\n        }\n\n        super.visitForLoop(node, rhsContext);\n        return null;\n    }\n\n    private boolean isNumericLiteral(ExpressionTree expressionTree, Context rhsContext) {\n        return expressionTree.getKind() == Kind.STRICT_EQUAL_TO && \n        \t\tgetExpTrueValue(expressionTree.getLeftOperand(), rhsContext) != null &&\n        \t\tgetExpTrueValue(expressionTree.getRightOperand(), rhsContext) instanceof Integer;\n    }\n\n    private boolean isArray(IdentifierTree identifier, Context rhsContext) {\n        Symbol symbol = identifier.getSymbol();\n        return symbol.getKind() == ElementKind.VARIABLE && symbol.asVariable().getType().isArray();\n    }\n\n    private List<ExpressionTree> getArrayElements(IdentifierTree identifier, Context rhsContext) {\n        Symbol symbol = identifier.getSymbol();\n        return symbol.asVariable().getInitializer().getElements();\n    }\n\n    private VariableTree makeNewForLoopVariable(ExpressionTree init) {\n        return maker().Var(maker().Modifiers(0), names().fromString(\"a\"), null, init);\n    }\n\n    private ExpressionTree createNewCondition(BinaryTree originalCondition, String varName, Context rhsContext) {\n        ExpressionTree right = originalCondition.getRightOperand();\n        if (right.getKind() == Kind.PARENTHESIZED) {\n            ParenthesizedTree parenthesizedTree = (ParenthesizedTree) right;\n            BinaryTree newRightTree = maker().LogicalAnd(\n                                            parenthesizedTree.getExpression(),\n                                            maker().Ident(names().fromString(varName))\n                                         );\n            return maker().Binary(originalCondition.getLeftOperand().accept(this, rhsContext), newRightTree, Kind.LOGICAL_AND);\n        } else {\n            BinaryTree newRightTree = maker().LogicalAnd(\n                                            right,\n                                            maker().Ident(names().fromString(varName))\n                                         );\n            return maker().Binary(originalCondition.getLeftOperand().accept(this, rhsContext), newRightTree, Kind.LOGICAL_AND);\n        }\n    }\n\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 54eb5cf8..6267f6c9 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -104,7 +104,7 @@ class CodeGenerator {\n     add(n, Context.OTHER);\n   }\n \n-  void add(Node n, Context context) {\n+\n     if (!cc.continueProcessing()) {\n       return;\n     }",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}