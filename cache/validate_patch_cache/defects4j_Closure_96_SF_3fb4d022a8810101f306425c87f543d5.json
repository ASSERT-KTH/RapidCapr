{
    "patch": "    List<Node> parameterList = functionType.getParameters();\n    int numParams = parameterList.size();\n    int numArgs = call.getChildCount() - 1;\n    int minArgs = functionType.getMinArguments();\n    int maxArgs = functionType.getMaxArguments();\n\n    int varArgsIndex = -1;\n    if (numParams > 0) {\n      Node lastParameter = parameterList.get(numParams - 1);\n      if (ASTUtil.isVarArgsParameter(lastParameter)) {\n        varArgsIndex = numParams - 1;\n        if (numArgs < numParams - 1 && !lastParameter.isOptionalArg()) {\n          report(t, call, WRONG_ARGUMENT_COUNT,\n              validator.getFunctionName(call),\n              String.valueOf(numArgs),\n              String.valueOf(numParams - 1),\n              \"\");\n          return;\n        }\n      }\n    }\n\n    // Check the arguments against each parameter.\n    int ordinal = 0;\n    Node parameter = null;\n    Node argument = null;\n    int expectedVarArgLength = -1;\n    boolean isError = false;\n    while (arguments.hasNext() && !isError) {\n      // If there are no parameters left in the list, then the while loop\n      // above implies that this must be a var_args function.\n      if (parameters.hasNext()) {\n        parameter = parameters.next();\n        if (ASTUtil.isVarArgsParameter(parameter)) {\n          expectedVarArgLength = numArgs - ordinal;\n          ordinal++;\n        }\n      }\n\n      argument = arguments.next();\n      ordinal++;\n      JSType argumentType = getJSType(argument);\n\n      if (expectedVarArgLength != -1 && ordinal > numParams) {\n        if (ASTUtil.isOptionalArg(parameter)) {\n          break;\n        } else if (expectedVarArgLength == 0 && !argumentType.isUnknownType()) {\n          report(t, argument,\n              WRONG_ARGUMENT_FOR_JSDEVVAR_ARGS_FUNCTION,\n              validator.getFunctionName(call),\n              \"Empty array literal is expected as a parameter for this var_args function\");\n          isError = true;\n          break;\n        }\n      }\n\n      JSType parameterType = null;\n      if (parameter != null) {\n        parameterType = getJSType(parameter);\n        if (ASTUtil.isOptionalArg(parameter)) {\n          if (argument.equals(parameter.getFirstChild())) {\n            continue;\n          }\n          parameterType = parameterType.restrictByNotNullOrUndefined();\n        }\n      } else {\n        parameterType = functionType.getReturnType();\n      }\n\n      validator.expectArgumentMatchesParameter(t, argument, argumentType,\n          parameterType, call, ordinal);\n\n      if (isError) {\n        break;\n      }\n    }\n\n    // Special case: missing a varargs parameter.\n    if (arguments.hasNext() &&\n        parameters.hasNext() &&\n        ASTUtil.isVarArgsParameter(parameters.next())) {\n      report(t, call, MISSING_VAR_ARGS_TYPE,\n          validator.getFunctionName(call), \"\");\n      return;\n    }\n\n    if (!isError && arguments.hasNext() && varArgsIndex != -1) {\n      report(t, call, WRONG_NUMBER_OF_ARGUMENTS,\n          validator.getFunctionName(call), \"\");\n      return;\n    }\n\n    // Special case: if we've advanced through all arguments and parameters\n    // and still have varargs, then we need to do another check.\n    if (!isError && expectedVarArgLength != -1 &&\n        ordinal > numParams + 1 &&\n        expectedVarArgLength != argumentsLeft.length()) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n          validator.getFunctionName(call),\n          String.valueOf(numArgs),\n          String.valueOf(numParams - 1),\n          \"or exactly \" + expectedVarArgLength + \" argument(s) for var_args function\");\n      return;\n    }\n\n    // Check if we have the required number of arguments.\n    if (!isError && (minArgs > numArgs || maxArgs < numArgs)) {\n      report(t, call, WRONG_ARGUMENT_COUNT,\n          validator.getFunctionName(call),\n          String.valueOf(numArgs),\n          String.valueOf(minArgs),\n          maxArgs != Integer.MAX_VALUE ?\n              \"and no more than \" + maxArgs + \" argument(s)\" : \"\");\n      return;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeCheck.java b/src/com/google/javascript/jscomp/TypeCheck.java\nindex 8077e0d8..30f160cc 100644\n--- a/src/com/google/javascript/jscomp/TypeCheck.java\n+++ b/src/com/google/javascript/jscomp/TypeCheck.java\n@@ -1396,38 +1396,120 @@ public class TypeCheck implements NodeTraversal.Callback, CompilerPass {\n   /**\n    * Visits the parameters of a CALL or a NEW node.\n    */\n-  private void visitParameterList(NodeTraversal t, Node call,\n-      FunctionType functionType) {\n-    Iterator<Node> arguments = call.children().iterator();\n-    arguments.next(); // skip the function name\n+    List<Node> parameterList = functionType.getParameters();\n+    int numParams = parameterList.size();\n+    int numArgs = call.getChildCount() - 1;\n+    int minArgs = functionType.getMinArguments();\n+    int maxArgs = functionType.getMaxArguments();\n \n-    Iterator<Node> parameters = functionType.getParameters().iterator();\n+    int varArgsIndex = -1;\n+    if (numParams > 0) {\n+      Node lastParameter = parameterList.get(numParams - 1);\n+      if (ASTUtil.isVarArgsParameter(lastParameter)) {\n+        varArgsIndex = numParams - 1;\n+        if (numArgs < numParams - 1 && !lastParameter.isOptionalArg()) {\n+          report(t, call, WRONG_ARGUMENT_COUNT,\n+              validator.getFunctionName(call),\n+              String.valueOf(numArgs),\n+              String.valueOf(numParams - 1),\n+              \"\");\n+          return;\n+        }\n+      }\n+    }\n+\n+    // Check the arguments against each parameter.\n     int ordinal = 0;\n     Node parameter = null;\n     Node argument = null;\n-    while (arguments.hasNext() &&\n-           parameters.hasNext()) {\n+    int expectedVarArgLength = -1;\n+    boolean isError = false;\n+    while (arguments.hasNext() && !isError) {\n       // If there are no parameters left in the list, then the while loop\n       // above implies that this must be a var_args function.\n+      if (parameters.hasNext()) {\n         parameter = parameters.next();\n+        if (ASTUtil.isVarArgsParameter(parameter)) {\n+          expectedVarArgLength = numArgs - ordinal;\n+          ordinal++;\n+        }\n+      }\n+\n       argument = arguments.next();\n       ordinal++;\n+      JSType argumentType = getJSType(argument);\n+\n+      if (expectedVarArgLength != -1 && ordinal > numParams) {\n+        if (ASTUtil.isOptionalArg(parameter)) {\n+          break;\n+        } else if (expectedVarArgLength == 0 && !argumentType.isUnknownType()) {\n+          report(t, argument,\n+              WRONG_ARGUMENT_FOR_JSDEVVAR_ARGS_FUNCTION,\n+              validator.getFunctionName(call),\n+              \"Empty array literal is expected as a parameter for this var_args function\");\n+          isError = true;\n+          break;\n+        }\n+      }\n+\n+      JSType parameterType = null;\n+      if (parameter != null) {\n+        parameterType = getJSType(parameter);\n+        if (ASTUtil.isOptionalArg(parameter)) {\n+          if (argument.equals(parameter.getFirstChild())) {\n+            continue;\n+          }\n+          parameterType = parameterType.restrictByNotNullOrUndefined();\n+        }\n+      } else {\n+        parameterType = functionType.getReturnType();\n+      }\n \n-      validator.expectArgumentMatchesParameter(t, argument,\n-          getJSType(argument), getJSType(parameter), call, ordinal);\n+      validator.expectArgumentMatchesParameter(t, argument, argumentType,\n+          parameterType, call, ordinal);\n+\n+      if (isError) {\n+        break;\n+      }\n     }\n \n-    int numArgs = call.getChildCount() - 1;\n-    int minArgs = functionType.getMinArguments();\n-    int maxArgs = functionType.getMaxArguments();\n-    if (minArgs > numArgs || maxArgs < numArgs) {\n+    // Special case: missing a varargs parameter.\n+    if (arguments.hasNext() &&\n+        parameters.hasNext() &&\n+        ASTUtil.isVarArgsParameter(parameters.next())) {\n+      report(t, call, MISSING_VAR_ARGS_TYPE,\n+          validator.getFunctionName(call), \"\");\n+      return;\n+    }\n+\n+    if (!isError && arguments.hasNext() && varArgsIndex != -1) {\n+      report(t, call, WRONG_NUMBER_OF_ARGUMENTS,\n+          validator.getFunctionName(call), \"\");\n+      return;\n+    }\n+\n+    // Special case: if we've advanced through all arguments and parameters\n+    // and still have varargs, then we need to do another check.\n+    if (!isError && expectedVarArgLength != -1 &&\n+        ordinal > numParams + 1 &&\n+        expectedVarArgLength != argumentsLeft.length()) {\n       report(t, call, WRONG_ARGUMENT_COUNT,\n-              validator.getReadableJSTypeName(call.getFirstChild(), false),\n-              String.valueOf(numArgs), String.valueOf(minArgs),\n-              maxArgs != Integer.MAX_VALUE ?\n-              \" and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+          validator.getFunctionName(call),\n+          String.valueOf(numArgs),\n+          String.valueOf(numParams - 1),\n+          \"or exactly \" + expectedVarArgLength + \" argument(s) for var_args function\");\n+      return;\n     }\n-  }\n+\n+    // Check if we have the required number of arguments.\n+    if (!isError && (minArgs > numArgs || maxArgs < numArgs)) {\n+      report(t, call, WRONG_ARGUMENT_COUNT,\n+          validator.getFunctionName(call),\n+          String.valueOf(numArgs),\n+          String.valueOf(minArgs),\n+          maxArgs != Integer.MAX_VALUE ?\n+              \"and no more than \" + maxArgs + \" argument(s)\" : \"\");\n+      return;\n \n   /**\n    * Visits a RETURN node.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}