{
    "patch": "      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP\n          && n.getNext() == null && assign.getParent() != null\n          && !NodeUtil.isAssignmentOp(assign.getParent()) && !NodeUtil.isForIn(assign.getParent())) {\n        Node grandParent = assign.getParent().getParent();\n        if (grandParent != null && (NodeUtil.isExprCall(grandParent) || NodeUtil.isNew(grandParent))) {\n          grandParent = grandParent.getParent();\n        }\n        boolean isChainedProperty = grandParent != null && grandParent.getType() == Token.GETPROP;\n        if (isChainedProperty) {\n          Node child = n.getFirstChild().getFirstChild().getNext();\n          if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) {\n            return true;\n          }\n        }\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\nindex 30b19e0b..e1695134 100644\n--- a/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n+++ b/src/com/google/javascript/jscomp/AnalyzePrototypeProperties.java\n@@ -311,28 +311,22 @@ class AnalyzePrototypeProperties implements CompilerPass {\n            n.getParent().getType() == Token.NAME);\n     }\n \n-    private boolean isPrototypePropertyAssign(Node assign) {\n-      Node n = assign.getFirstChild();\n-      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign)\n-          && n.getType() == Token.GETPROP\n-          ) {\n-        // We want to exclude the assignment itself from the usage list\n-        boolean isChainedProperty =\n-            n.getFirstChild().getType() == Token.GETPROP;\n-\n+      if (n != null && NodeUtil.isVarOrSimpleAssignLhs(n, assign) && n.getType() == Token.GETPROP\n+          && n.getNext() == null && assign.getParent() != null\n+          && !NodeUtil.isAssignmentOp(assign.getParent()) && !NodeUtil.isForIn(assign.getParent())) {\n+        Node grandParent = assign.getParent().getParent();\n+        if (grandParent != null && (NodeUtil.isExprCall(grandParent) || NodeUtil.isNew(grandParent))) {\n+          grandParent = grandParent.getParent();\n+        }\n+        boolean isChainedProperty = grandParent != null && grandParent.getType() == Token.GETPROP;\n         if (isChainedProperty) {\n           Node child = n.getFirstChild().getFirstChild().getNext();\n-\n-          if (child.getType() == Token.STRING &&\n-              child.getString().equals(\"prototype\")) {\n+          if (child.getType() == Token.STRING && child.getString().equals(\"prototype\")) {\n             return true;\n           }\n         }\n       }\n \n-      return false;\n-    }\n-\n     /**\n      * Processes a NAME node to see if it's a global function declaration.\n      * If it is, record it and return true. Otherwise, return false.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}