{
    "patch": "private RealMatrix squareRoot(RealMatrix m) { \n    final int n = m.getRowDimension();\n    final int maxEigenSize = 100000; // maximum size for exact eigen decomposition\n    if (n > maxEigenSize) {          \n        return matrixSqrtHigham(m);\n    } else {\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        final RealMatrix eigenSqrt = dec.getSquareRoot();\n        return eigenSqrt;\n    }\n}\n\nprivate RealMatrix matrixSqrtHigham(RealMatrix A) {\n    final int n = A.getRowDimension();\n    final double normA = A.getNorm();\n    final RealMatrix X = A.scalarMultiply(1.0 / normA);\n    final RealMatrix I = MatrixUtils.createRealIdentityMatrix(n);\n\n    RealMatrix Y = X.add(I);\n    RealMatrix Z = X.subtract(I);\n\n    RealMatrix cY = Y.multiply(Z);\n    RealMatrix Y3 = Y.multiply(Y).multiply(Y);\n    RealMatrix A2 = A.scalarMultiply(0.25 / normA / normA);\n    RealMatrix A3 = A2.multiply(A).scalarMultiply(0.5 / normA / normA);\n\n    RealMatrix S = I.add(A2).add(A3);\n    RealMatrix D = I.subtract(A2).add(A3);\n\n    final int maxIters = 50;\n    double tol = 10 * FastMath.sqrt(n) * Precision.EPSILON;\n    RealMatrix Xn = X;\n    for (int i = 0; i < maxIters; i++) {\n        RealMatrix W = Xn.multiply(Y)\n            .add(S.scalarMultiply(0.5))\n            .multiply(matrixInverse(Xn.multiply(Z).add(D.scalarMultiply(0.5))));\n        Xn = Y.multiply(W).add(Z.multiply(matrixInverse(W))).subtract(cY).scalarMultiply(0.5);\n\n        if (Xn.subtract(X).getNorm() < tol) {\n            return Xn.scalarMultiply(normA);\n        }\n\n        X = Xn;\n        Y = X.add(I);\n        Z = X.subtract(I);\n    }\n    throw new RuntimeException(\"Failed to converge.\");\n}\n\nprivate RealMatrix matrixInverse(RealMatrix A) {\n    final int n = A.getRowDimension();\n    final RealMatrix I = MatrixUtils.createRealIdentityMatrix(n);\n    final LUDecomposition lu = new LUDecomposition(A);\n    final RealMatrix inverse = lu.getSolver().getInverse();\n    return inverse;\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..5fef7898b 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,60 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) { \n+    final int n = m.getRowDimension();\n+    final int maxEigenSize = 100000; // maximum size for exact eigen decomposition\n+    if (n > maxEigenSize) {          \n+        return matrixSqrtHigham(m);\n+    } else {\n+        final EigenDecomposition dec = new EigenDecomposition(m);\n+        final RealMatrix eigenSqrt = dec.getSquareRoot();\n+        return eigenSqrt;\n     }\n }\n+\n+private RealMatrix matrixSqrtHigham(RealMatrix A) {\n+    final int n = A.getRowDimension();\n+    final double normA = A.getNorm();\n+    final RealMatrix X = A.scalarMultiply(1.0 / normA);\n+    final RealMatrix I = MatrixUtils.createRealIdentityMatrix(n);\n+\n+    RealMatrix Y = X.add(I);\n+    RealMatrix Z = X.subtract(I);\n+\n+    RealMatrix cY = Y.multiply(Z);\n+    RealMatrix Y3 = Y.multiply(Y).multiply(Y);\n+    RealMatrix A2 = A.scalarMultiply(0.25 / normA / normA);\n+    RealMatrix A3 = A2.multiply(A).scalarMultiply(0.5 / normA / normA);\n+\n+    RealMatrix S = I.add(A2).add(A3);\n+    RealMatrix D = I.subtract(A2).add(A3);\n+\n+    final int maxIters = 50;\n+    double tol = 10 * FastMath.sqrt(n) * Precision.EPSILON;\n+    RealMatrix Xn = X;\n+    for (int i = 0; i < maxIters; i++) {\n+        RealMatrix W = Xn.multiply(Y)\n+            .add(S.scalarMultiply(0.5))\n+            .multiply(matrixInverse(Xn.multiply(Z).add(D.scalarMultiply(0.5))));\n+        Xn = Y.multiply(W).add(Z.multiply(matrixInverse(W))).subtract(cY).scalarMultiply(0.5);\n+\n+        if (Xn.subtract(X).getNorm() < tol) {\n+            return Xn.scalarMultiply(normA);\n+        }\n+\n+        X = Xn;\n+        Y = X.add(I);\n+        Z = X.subtract(I);\n+    }\n+    throw new RuntimeException(\"Failed to converge.\");\n+}\n+\n+private RealMatrix matrixInverse(RealMatrix A) {\n+    final int n = A.getRowDimension();\n+    final RealMatrix I = MatrixUtils.createRealIdentityMatrix(n);\n+    final LUDecomposition lu = new LUDecomposition(A);\n+    final RealMatrix inverse = lu.getSolver().getInverse();\n+    return inverse;\n+}\n+}",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}