{
    "patch": "for (int i = 0; i < count; i++) {\n    SavedField savedField = savedFields[i];\n    if (savedField.iField.getType() == DateTimeFieldType.year()) {\n        int savedValue = savedField.iValue;\n        int newValue = savedField.iField.getRangeDurationType().getField(iChrono).set(this, savedField.iField.getRangeDurationType().getField(iChrono).getMinimumValue(), savedValue);\n        if (dateParsing && savedValue != newValue) {\n            if (savedValue == 1 && newValue == -1) {\n                // This is fine - a year of 1 is the same as -1.\n            } else if (savedValue == -1 && newValue == 1) {\n                // No good - -1 is not the same as 1.\n                throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.toString(savedValue), Integer.toString(newValue));\n            } else {\n                // Could be before Christ... but more likely a parsing error.\n                throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.toString(savedValue), null, null);\n            }\n        }\n        savedField.iValue = newValue;\n    }\n    millis = savedField.set(millis, resetFields);\n    if (savedField.iValue < 0 && savedField.iField.getType().equals(DateTimeFieldType.weekyear())) {\n        // Values like '-0045' have been parsed, which are useless.\n        throw new IllegalFieldValueException(savedField.iField.getType(), Integer.toString(savedField.iValue), null, null);\n    }\n    if (savedField.iValue < 0 && savedField.iField.getType().equals(DateTimeFieldType.yearOfEra())) {\n        if (Chronology.isJulian(iChrono)) {\n            // Assume a missing 'A.D.' means Julian, and a negative year\n            // means BC, unless a previous field has already provided an era.\n            if (iEra < 0) {\n                savedField.iValue = 1 - savedField.iValue;\n                setEra(-1);\n            }\n        } else {\n            // Cannot have a negative year-of-era\n            throw new IllegalFieldValueException(savedField.iField.getType(), Integer.toString(savedField.iValue), null, null);\n        }\n    }\n    if (savedField.iValue <= 0 && savedField.iField.getType().equals(DateTimeFieldType.monthOfYear()) && !dateParsing) {\n        dateParsing = true;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..137547a1 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,46 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+for (int i = 0; i < count; i++) {\n+    SavedField savedField = savedFields[i];\n+    if (savedField.iField.getType() == DateTimeFieldType.year()) {\n+        int savedValue = savedField.iValue;\n+        int newValue = savedField.iField.getRangeDurationType().getField(iChrono).set(this, savedField.iField.getRangeDurationType().getField(iChrono).getMinimumValue(), savedValue);\n+        if (dateParsing && savedValue != newValue) {\n+            if (savedValue == 1 && newValue == -1) {\n+                // This is fine - a year of 1 is the same as -1.\n+            } else if (savedValue == -1 && newValue == 1) {\n+                // No good - -1 is not the same as 1.\n+                throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.toString(savedValue), Integer.toString(newValue));\n+            } else {\n+                // Could be before Christ... but more likely a parsing error.\n+                throw new IllegalFieldValueException(DateTimeFieldType.year(), Integer.toString(savedValue), null, null);\n+            }\n+        }\n+        savedField.iValue = newValue;\n+    }\n+    millis = savedField.set(millis, resetFields);\n+    if (savedField.iValue < 0 && savedField.iField.getType().equals(DateTimeFieldType.weekyear())) {\n+        // Values like '-0045' have been parsed, which are useless.\n+        throw new IllegalFieldValueException(savedField.iField.getType(), Integer.toString(savedField.iValue), null, null);\n+    }\n+    if (savedField.iValue < 0 && savedField.iField.getType().equals(DateTimeFieldType.yearOfEra())) {\n+        if (Chronology.isJulian(iChrono)) {\n+            // Assume a missing 'A.D.' means Julian, and a negative year\n+            // means BC, unless a previous field has already provided an era.\n+            if (iEra < 0) {\n+                savedField.iValue = 1 - savedField.iValue;\n+                setEra(-1);\n+            }\n+        } else {\n+            // Cannot have a negative year-of-era\n+            throw new IllegalFieldValueException(savedField.iField.getType(), Integer.toString(savedField.iValue), null, null);\n+        }\n+    }\n+    if (savedField.iValue <= 0 && savedField.iField.getType().equals(DateTimeFieldType.monthOfYear()) && !dateParsing) {\n+        dateParsing = true;\n+    }\n+}\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}