{
    "patch": "      // Don't traverse functions that are declared with a lends annotation.\n      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n      if (jsDoc != null && jsDoc.hasLendsName()) {\n        return false;\n      }\n\n      // Don't traverse functions that are constructors or have the @this\n      // or @override annotation.\n      jsDoc = getFunctionJsDocInfo(n);\n      if (jsDoc != null &&\n          (jsDoc.isConstructor() ||\n           jsDoc.isInterface() ||\n           jsDoc.hasThisType() ||\n           jsDoc.isOverride())) {\n        return false;\n      }\n      \n      if (n.getParent() != null && \n            n.getParent().getType() == Token.LB &&\n            n.getParent().getParent() != null && \n            n.getParent().getParent().getType() == Token.ASSIGN && \n            n.getParent().getFirstChild().equals(n) &&\n            n.getNext() == null) {\n        return false;\n      }\n\n      // Don't traverse functions unless they would normally\n      // be able to have a @this annotation associated with them. e.g.,\n      // var a = function() { }; // or\n      // function a() {} // or\n      // a.x = function() {}; // or\n      // var a = {x: function() {}};\n      int pType = parent.getType();\n      if (!(pType == Token.BLOCK ||\n            pType == Token.SCRIPT ||\n            pType == Token.NAME ||\n            pType == Token.ASSIGN ||\n            \n            // object literal keys\n            pType == Token.STRING ||\n            pType == Token.NUMBER ||\n            \n            // don't skip if parent is a call or new target\n            pType == Token.CALL ||\n            pType == Token.NEW && parent.getFirstChild() == n)) {\n        \n        if (pType == Token.DOT) {\n          Node owner = parent.getFirstChild();\n          int ownerType = owner.getType();\n          if (ownerType != Token.NAME &&\n              ownerType != Token.THIS &&\n              ownerType != Token.GETPROP &&\n              ownerType != Token.GETELEM) {\n            return false;\n          }\n          if (ownerType == Token.NAME && !owner.getString().equals(\"exports\")) {\n            return false;\n          }\n        } else if (pType == Token.COMMA &&\n                   (parent.getFirstChild().getNext() == n ||\n                    parent.getLastChild() == n)) {\n          return false;\n        } else {\n          return false;\n        }\n      }\n\n      // Don't traverse functions that are getting lent to a prototype.\n      Node grandParent = parent.getParent();\n      if (grandParent != null && grandParent.getType() == Token.EXPR_RESULT) {\n        Node target = grandParent.getFirstChild();\n        if (NodeUtil.isGet(target) &&\n            target.getLastChild().getString().equals(\"prototype\")) {\n          Node grandParentExpr = grandParent.getParent();\n          int grandParentType = grandParentExpr.getType();\n          if (grandParentExpr != null &&\n              (grandParentType == Token.ASSIGN ||\n               grandParentType == Token.VAR)) {\n            Node lhs = grandParentExpr.getFirstChild();\n            boolean lhsIsNameOrThis = NodeUtil.isName(lhs) ||\n                                      lhs.getType() == Token.THIS;\n            if (NodeUtil.isGet(lhs) && lhsIsNameOrThis) {\n              String baseName = lhs.getFirstChild().getQualifiedName();\n              if (baseName.equals(\"Object\") || baseName.equals(\"Function\")) {\n                return false;\n              }\n            } else if (lhsIsNameOrThis &&\n                       !grandParentExpr.hasChildren()) {\n              return false;\n            }\n          }\n        }\n      }\n\n      // Don't traverse functions that are part of an object literal\n      // unless they are property getters or setters.\n      if (pType == Token.OBJECTLIT &&\n          ((NodeUtil.getObjectLitKeyType(parent, n, compiler) !=\n              Token.GETTER_DEF) &&\n           (NodeUtil.getObjectLitKeyType(parent, n, compiler) !=\n              Token.SETTER_DEF))) {\n        return false;\n      }\n\n      return true;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..1044a0be 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,111 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      // Don't traverse functions that are declared with a lends annotation.\n+      JSDocInfo jsDoc = NodeUtil.getBestJSDocInfo(n);\n+      if (jsDoc != null && jsDoc.hasLendsName()) {\n+        return false;\n+      }\n+\n+      // Don't traverse functions that are constructors or have the @this\n+      // or @override annotation.\n+      jsDoc = getFunctionJsDocInfo(n);\n+      if (jsDoc != null &&\n+          (jsDoc.isConstructor() ||\n+           jsDoc.isInterface() ||\n+           jsDoc.hasThisType() ||\n+           jsDoc.isOverride())) {\n+        return false;\n+      }\n+      \n+      if (n.getParent() != null && \n+            n.getParent().getType() == Token.LB &&\n+            n.getParent().getParent() != null && \n+            n.getParent().getParent().getType() == Token.ASSIGN && \n+            n.getParent().getFirstChild().equals(n) &&\n+            n.getNext() == null) {\n+        return false;\n+      }\n+\n+      // Don't traverse functions unless they would normally\n+      // be able to have a @this annotation associated with them. e.g.,\n+      // var a = function() { }; // or\n+      // function a() {} // or\n+      // a.x = function() {}; // or\n+      // var a = {x: function() {}};\n+      int pType = parent.getType();\n+      if (!(pType == Token.BLOCK ||\n+            pType == Token.SCRIPT ||\n+            pType == Token.NAME ||\n+            pType == Token.ASSIGN ||\n+            \n+            // object literal keys\n+            pType == Token.STRING ||\n+            pType == Token.NUMBER ||\n+            \n+            // don't skip if parent is a call or new target\n+            pType == Token.CALL ||\n+            pType == Token.NEW && parent.getFirstChild() == n)) {\n+        \n+        if (pType == Token.DOT) {\n+          Node owner = parent.getFirstChild();\n+          int ownerType = owner.getType();\n+          if (ownerType != Token.NAME &&\n+              ownerType != Token.THIS &&\n+              ownerType != Token.GETPROP &&\n+              ownerType != Token.GETELEM) {\n+            return false;\n+          }\n+          if (ownerType == Token.NAME && !owner.getString().equals(\"exports\")) {\n+            return false;\n+          }\n+        } else if (pType == Token.COMMA &&\n+                   (parent.getFirstChild().getNext() == n ||\n+                    parent.getLastChild() == n)) {\n+          return false;\n+        } else {\n+          return false;\n+        }\n+      }\n+\n+      // Don't traverse functions that are getting lent to a prototype.\n+      Node grandParent = parent.getParent();\n+      if (grandParent != null && grandParent.getType() == Token.EXPR_RESULT) {\n+        Node target = grandParent.getFirstChild();\n+        if (NodeUtil.isGet(target) &&\n+            target.getLastChild().getString().equals(\"prototype\")) {\n+          Node grandParentExpr = grandParent.getParent();\n+          int grandParentType = grandParentExpr.getType();\n+          if (grandParentExpr != null &&\n+              (grandParentType == Token.ASSIGN ||\n+               grandParentType == Token.VAR)) {\n+            Node lhs = grandParentExpr.getFirstChild();\n+            boolean lhsIsNameOrThis = NodeUtil.isName(lhs) ||\n+                                      lhs.getType() == Token.THIS;\n+            if (NodeUtil.isGet(lhs) && lhsIsNameOrThis) {\n+              String baseName = lhs.getFirstChild().getQualifiedName();\n+              if (baseName.equals(\"Object\") || baseName.equals(\"Function\")) {\n+                return false;\n+              }\n+            } else if (lhsIsNameOrThis &&\n+                       !grandParentExpr.hasChildren()) {\n+              return false;\n+            }\n+          }\n+        }\n+      }\n+\n+      // Don't traverse functions that are part of an object literal\n+      // unless they are property getters or setters.\n+      if (pType == Token.OBJECTLIT &&\n+          ((NodeUtil.getObjectLitKeyType(parent, n, compiler) !=\n+              Token.GETTER_DEF) &&\n+           (NodeUtil.getObjectLitKeyType(parent, n, compiler) !=\n+              Token.SETTER_DEF))) {\n+        return false;\n+      }\n+\n+      return true;\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: variable jsDoc is already defined in method shouldTraverse(NodeTraversal,Node,Node)",
    "test_result": "ERROR"
}