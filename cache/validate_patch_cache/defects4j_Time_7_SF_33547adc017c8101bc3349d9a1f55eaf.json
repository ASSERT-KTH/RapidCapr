{
    "patch": "    public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n        int length = text.length() - position;\n        if (iMaxLengthEstimate != 0 && length > iMaxLengthEstimate) {\n            return position + iMaxLengthEstimate + 1;\n        }\n\n        int[] values = bucket.getParsedFields();\n        int savedPos = position;\n        boolean afterSeparator = false;\n\n        if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n            // handle case where field is required\n            if (length == 0) {\n                return ~position;\n            }\n            // lenient parsing\n            // if sep is required and found, must interpret next digit as belonging to field\n            if (iFieldPrintZeroText != null && iFieldPrintZeroText.length() > 0) {\n                if (text.charAt(position) == iFieldPrintZeroText.charAt(0)) {\n                    afterSeparator = true;\n                    savedPos = position + 1;\n                    length--;\n                    if (length == 0) {\n                        return ~savedPos;\n                    }\n                } else {\n                    return ~position;\n                }\n            }\n        } else if (length == 0) {\n            return ~position;\n        } else {\n            if (iFieldPrintZeroText != null && iFieldPrintZeroText.length() > 0) {\n                if (text.charAt(position) == iFieldPrintZeroText.charAt(0)) {\n                    afterSeparator = true;\n                    savedPos = position + 1;\n                    length--;\n                    if (length == 0) {\n                        values[iFieldType] = 0;\n                        return savedPos;\n                    }\n                }\n            }\n        }\n\n        int endPos;\n        if (iParseWithRealMonth) {\n            endPos = parseMonthBucketWithMonthText(bucket, text, savedPos);\n        } else {\n            endPos = super.parseInto(bucket, text, savedPos);\n        }\n\n        if (endPos < 0) {\n            return endPos;\n        }\n\n        int parsedValue = bucket.getParsedField(iFieldType);\n\n        if (iFieldStrictParse && parsedValue == 0) {\n            // require a parsed value\n            if ((endPos - savedPos) > 0 && text.charAt(savedPos) != text.charAt(endPos - 1)) {\n                return ~savedPos;\n            }\n        }\n\n        if (iFieldStrictParse && endPos - savedPos != iMaxParsedDigits) {\n            return ~savedPos;\n        }\n\n        if (iSigned) {\n            boolean negative = text.charAt(savedPos) == '-';\n            if (negative) {\n                if (parsedValue == Integer.MIN_VALUE) {\n                    // Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE!\n                    parsedValue = Integer.MAX_VALUE;\n                } else {\n                    parsedValue = -parsedValue;\n                }\n            } else if (iRejectSignedValues && text.charAt(savedPos) == '+') {\n                return ~savedPos;\n            }\n        }\n\n        values[iFieldType] = parsedValue;\n\n        return endPos;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a2..ad5873f3 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -697,34 +697,92 @@ public class DateTimeFormatter {\n      * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    public int parseInto(ReadWritableInstant instant, String text, int position) {\n-        DateTimeParser parser = requireParser();\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"Instant must not be null\");\n+    public int parseInto(DateTimeParserBucket bucket, String text, int position) {\n+        int length = text.length() - position;\n+        if (iMaxLengthEstimate != 0 && length > iMaxLengthEstimate) {\n+            return position + iMaxLengthEstimate + 1;\n         }\n-        \n-        long instantMillis = instant.getMillis();\n-        Chronology chrono = instant.getChronology();\n-        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n-        chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n-        \n-        DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n-        int newPos = parser.parseInto(bucket, text, position);\n-        instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n-            int parsedOffset = bucket.getOffsetInteger();\n-            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n-            chrono = chrono.withZone(parsedZone);\n-        } else if (bucket.getZone() != null) {\n-            chrono = chrono.withZone(bucket.getZone());\n+\n+        int[] values = bucket.getParsedFields();\n+        int savedPos = position;\n+        boolean afterSeparator = false;\n+\n+        if (iPrintZeroSetting == PRINT_ZERO_ALWAYS) {\n+            // handle case where field is required\n+            if (length == 0) {\n+                return ~position;\n+            }\n+            // lenient parsing\n+            // if sep is required and found, must interpret next digit as belonging to field\n+            if (iFieldPrintZeroText != null && iFieldPrintZeroText.length() > 0) {\n+                if (text.charAt(position) == iFieldPrintZeroText.charAt(0)) {\n+                    afterSeparator = true;\n+                    savedPos = position + 1;\n+                    length--;\n+                    if (length == 0) {\n+                        return ~savedPos;\n+                    }\n+                } else {\n+                    return ~position;\n+                }\n+            }\n+        } else if (length == 0) {\n+            return ~position;\n+        } else {\n+            if (iFieldPrintZeroText != null && iFieldPrintZeroText.length() > 0) {\n+                if (text.charAt(position) == iFieldPrintZeroText.charAt(0)) {\n+                    afterSeparator = true;\n+                    savedPos = position + 1;\n+                    length--;\n+                    if (length == 0) {\n+                        values[iFieldType] = 0;\n+                        return savedPos;\n+                    }\n+                }\n+            }\n         }\n-        instant.setChronology(chrono);\n-        if (iZone != null) {\n-            instant.setZone(iZone);\n+\n+        int endPos;\n+        if (iParseWithRealMonth) {\n+            endPos = parseMonthBucketWithMonthText(bucket, text, savedPos);\n+        } else {\n+            endPos = super.parseInto(bucket, text, savedPos);\n         }\n-        return newPos;\n+\n+        if (endPos < 0) {\n+            return endPos;\n+        }\n+\n+        int parsedValue = bucket.getParsedField(iFieldType);\n+\n+        if (iFieldStrictParse && parsedValue == 0) {\n+            // require a parsed value\n+            if ((endPos - savedPos) > 0 && text.charAt(savedPos) != text.charAt(endPos - 1)) {\n+                return ~savedPos;\n+            }\n+        }\n+\n+        if (iFieldStrictParse && endPos - savedPos != iMaxParsedDigits) {\n+            return ~savedPos;\n+        }\n+\n+        if (iSigned) {\n+            boolean negative = text.charAt(savedPos) == '-';\n+            if (negative) {\n+                if (parsedValue == Integer.MIN_VALUE) {\n+                    // Math.abs(Integer.MIN_VALUE) == Integer.MIN_VALUE!\n+                    parsedValue = Integer.MAX_VALUE;\n+                } else {\n+                    parsedValue = -parsedValue;\n+                }\n+            } else if (iRejectSignedValues && text.charAt(savedPos) == '+') {\n+                return ~savedPos;\n+            }\n+        }\n+\n+        values[iFieldType] = parsedValue;\n+\n+        return endPos;\n     }\n \n     /**",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}