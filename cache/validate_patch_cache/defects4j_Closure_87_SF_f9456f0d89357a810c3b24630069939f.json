{
    "patch": "private static boolean isExpressionNode(Node n) {\n  int type = n.getType();\n  return type == Token.CALL ||\n         type == Token.NAME ||\n         type == Token.ARRAYLIT ||\n         type == Token.OBJECTLIT ||\n         type == Token.REGEXP ||\n         type == Token.NUMBER ||\n         type == Token.STRING ||\n         type == Token.THIS ||\n         type == Token.TRUE ||\n         type == Token.FALSE ||\n         type == Token.NULL ||\n         type == Token.DEBUGGER ||\n         type == Token.VOID ||\n         type == Token.NOT ||\n         type == Token.BITNOT ||\n         NodeUtil.isUnaryOperator(type) ||\n         NodeUtil.isBinaryOperator(type);\n}\n\nprivate boolean isFoldableExpressBlock(Node n) {\n  if (n.getType() == Token.BLOCK) {\n    if (n.hasOneChild()) {\n      Node maybeExpr = n.getFirstChild();\n      if (maybeExpr.getType() == Token.RETURN\n          && maybeExpr.hasOneChild()) {\n        Node returnChild = maybeExpr.getFirstChild();\n\n        // Check if it's an expression node, except for a CALL to\n        // $super, since that can't be inlined.\n        if (isExpressionNode(returnChild)\n            && !(returnChild.getType() == Token.CALL\n                 && \"$super\".equals(\n                 returnChild.getFirstChild().getString()))) {\n          // Check if the RETURN is a direct child of the block.\n          // If it is then we can just inline it. Otherwise, we\n          // can still inline, but we need to be careful to wrap\n          // the expression in parens to not break other\n          // statements in the block.\n          return maybeExpr.getParent() == n;\n        }\n      } else if (isExpressionNode(maybeExpr)) {\n        // Check if it's an EXPR_RESULT node and return false.\n        // IE has a bug where event handlers behave differently\n        // when their return value is used vs. when their return\n        // value is in an EXPR_RESULT.\n        Node parent = maybeExpr.getParent();\n        if (parent != null && parent.getType() == Token.EXPR_RESULT) {\n          return false;\n        }\n        return true;\n      }\n    }\n  }\n  return false;\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex 9498fa6e..534f6303 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -516,26 +516,63 @@ public class PeepholeSubstituteAlternateSyntax\n    * @return Whether the node is a block with a single statement that is\n    *     an expression.\n    */\n-  private boolean isFoldableExpressBlock(Node n) {\n-    if (n.getType() == Token.BLOCK) {\n-      if (n.hasOneChild()) {\n-        Node maybeExpr = n.getFirstChild();\n-          // IE has a bug where event handlers behave differently when\n-          // their return value is used vs. when their return value is in\n-          // an EXPR_RESULT. It's pretty freaking weird. See:\n-          // http://code.google.com/p/closure-compiler/issues/detail?id=291\n-          // We try to detect this case, and not fold EXPR_RESULTs\n-          // into other expressions.\n-\n-            // We only have to worry about methods with an implicit 'this'\n-            // param, or this doesn't happen.\n-\n-          return NodeUtil.isExpressionNode(maybeExpr);\n+private static boolean isExpressionNode(Node n) {\n+  int type = n.getType();\n+  return type == Token.CALL ||\n+         type == Token.NAME ||\n+         type == Token.ARRAYLIT ||\n+         type == Token.OBJECTLIT ||\n+         type == Token.REGEXP ||\n+         type == Token.NUMBER ||\n+         type == Token.STRING ||\n+         type == Token.THIS ||\n+         type == Token.TRUE ||\n+         type == Token.FALSE ||\n+         type == Token.NULL ||\n+         type == Token.DEBUGGER ||\n+         type == Token.VOID ||\n+         type == Token.NOT ||\n+         type == Token.BITNOT ||\n+         NodeUtil.isUnaryOperator(type) ||\n+         NodeUtil.isBinaryOperator(type);\n+}\n+\n+private boolean isFoldableExpressBlock(Node n) {\n+  if (n.getType() == Token.BLOCK) {\n+    if (n.hasOneChild()) {\n+      Node maybeExpr = n.getFirstChild();\n+      if (maybeExpr.getType() == Token.RETURN\n+          && maybeExpr.hasOneChild()) {\n+        Node returnChild = maybeExpr.getFirstChild();\n+\n+        // Check if it's an expression node, except for a CALL to\n+        // $super, since that can't be inlined.\n+        if (isExpressionNode(returnChild)\n+            && !(returnChild.getType() == Token.CALL\n+                 && \"$super\".equals(\n+                 returnChild.getFirstChild().getString()))) {\n+          // Check if the RETURN is a direct child of the block.\n+          // If it is then we can just inline it. Otherwise, we\n+          // can still inline, but we need to be careful to wrap\n+          // the expression in parens to not break other\n+          // statements in the block.\n+          return maybeExpr.getParent() == n;\n+        }\n+      } else if (isExpressionNode(maybeExpr)) {\n+        // Check if it's an EXPR_RESULT node and return false.\n+        // IE has a bug where event handlers behave differently\n+        // when their return value is used vs. when their return\n+        // value is in an EXPR_RESULT.\n+        Node parent = maybeExpr.getParent();\n+        if (parent != null && parent.getType() == Token.EXPR_RESULT) {\n+          return false;\n+        }\n+        return true;\n       }\n     }\n-\n-    return false;\n   }\n+  return false;\n+}\n \n   /**\n    * @return The expression node.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}