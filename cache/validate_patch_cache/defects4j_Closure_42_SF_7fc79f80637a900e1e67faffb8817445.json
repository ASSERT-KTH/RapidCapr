{
    "patch": "public class TransformDispatcher extends TypeSafeDispatcher<Node> {\n\n    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n            ImmutableSet.of(\"use strict\", \"use asm\");\n\n    private final ErrorReporter errorReporter;\n    private final String sourceName;\n\n    public TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n        this.errorReporter = errorReporter;\n        this.sourceName = sourceName;\n    }\n\n    protected Node cast(AstNode n) {\n        return (Node) n;\n    }\n\n    private boolean isDirective(AstNode n) {\n        if (n == null) return false;\n\n        int nType = n.getType();\n        return nType == Token.EXPR_RESULT &&\n                cast(n).getFirstChild().isString() &&\n                ALLOWED_DIRECTIVES.contains(cast(n).getFirstChild().getString());\n    }\n\n    @Override\n    public Node processBlock(Block blockNode) {\n        return processGeneric(blockNode);\n    }\n\n    @Override\n    public Node processBreakStatement(BreakStatement statementNode) {\n        Node node = newNode(Token.BREAK);\n        if (statementNode.getBreakLabel() != null) {\n            Node labelName = transform(statementNode.getBreakLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    public Node processCatchClause(CatchClause clauseNode) {\n        AstNode catchVar = clauseNode.getVarName();\n        Node node = newNode(Token.CATCH, transform(catchVar));\n        if (clauseNode.getCatchCondition() != null) {\n            errorReporter.error(\n                    \"Catch clauses are not supported\",\n                    sourceName,\n                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n        }\n        node.addChildToBack(transformBlock(clauseNode.getBody()));\n        return node;\n    }\n\n    @Override\n    public Node processConditionalExpression(ConditionalExpression exprNode) {\n        return newNode(\n                Token.HOOK,\n                transform(exprNode.getTestExpression()),\n                transform(exprNode.getTrueExpression()),\n                transform(exprNode.getFalseExpression()));\n    }\n\n    @Override\n    public Node processContinueStatement(ContinueStatement statementNode) {\n        Node node = newNode(Token.CONTINUE);\n        if (statementNode.getLabel() != null) {\n            Node labelName = transform(statementNode.getLabel());\n            // Change the NAME to LABEL_NAME\n            labelName.setType(Token.LABEL_NAME);\n            node.addChildToBack(labelName);\n        }\n        return node;\n    }\n\n    @Override\n    public Node processDoLoop(DoLoop loopNode) {\n        return newNode(\n                Token.DO,\n                transformBlock(loopNode.getBody()),\n                transform(loopNode.getCondition()));\n    }\n\n    @Override\n    public Node processElementGet(ElementGet getNode) {\n        return newNode(\n                Token.GETELEM,\n                transform(getNode.getTarget()),\n                transform(getNode.getElement()));\n    }\n\n    @Override\n    public Node processEmptyExpression(EmptyExpression exprNode) {\n        return newNode(Token.EMPTY);\n    }\n\n    @Override\n    public Node processExpressionStatement(ExpressionStatement statementNode) {\n        Node node = newNode(transformTokenType(statementNode.getType()));\n        node.addChildToBack(transform(statementNode.getExpression()));\n        return node;\n    }\n\n    @Override\n    public Node processForInLoop(ForInLoop loopNode) {\n        AstNode iterNode = loopNode.getIterator();\n        AstNode objNode = loopNode.getIteratedObject();\n        Node lhs, rhs;\n        if (iterNode instanceof DestructuringForm) {\n            checkForViolation(Parser.Config.StrictMode.under((Node) iterNode), ((DestructuringForm) iterNode).getLeft());\n            lhs = transform(iterNode);\n            rhs = transform(objNode);\n        } else {\n            lhs = transform(iterNode);\n            rhs =\n                    newNode(\n                            Token.CALL,\n                            newNode(Token.NAME, IR.getPropCoded(REGEXP = IR.name(\"RegExp\"), \"prototype\")),\n                            transform(objNode));\n            rhs.putProp(Node.REGEXP_PROP, Boolean.TRUE);\n        }\n        Node forNode = newNode(Token.FOR, lhs, rhs, transformBlock(loopNode.getBody()));\n        return forNode;\n    }\n\n    @Override\n    public Node processForLoop(ForLoop loopNode) {\n        Node initial, condition, increment, body;\n\n        if (loopNode.getInitializer() != null) {\n            initial = transform(loopNode.getInitializer());\n        } else {\n            // equivalent of `var <ident>;` - create a dummy var declaration with no initializer\n            initial = newNode(Token.VAR);\n        }\n\n        if (loopNode.getCondition() != null) {\n            condition = transform(loopNode.getCondition());\n        } else {\n            // equivalent of `<loop>` - no condition needed\n            condition = newNode(Token.TRUE);\n        }\n\n        if (loopNode.getIncrement() != null) {\n            increment = transform(loopNode.getIncrement());\n        } else {\n            // equivalent of `++<ident>` - create an increment operation with no LHS (no-op)\n            increment = new Node(Token.EXPR_RESULT);\n            increment.addChildToBack(newNode(Token.INC, newNode(Token.NAME)));\n        }\n\n        body = transformBlock(loopNode.getBody());\n\n        return newNode(Token.FOR, initial, condition, increment, body);\n    }\n\n    @Override\n    public Node processFunctionCall(FunctionCall callNode) {\n        Node target = transform(callNode.getTarget());\n        Node callNodeResult = newNode(Token.CALL, target);\n        for (AstNode arg : callNode.getArguments()) {\n            Node transformedArg = transform(arg);\n            if (transformedArg == null) {\n                // If any argument is null, return null rather than erroring out\n                return null;\n            }\n            callNodeResult.addChildToBack(transformedArg);\n        }\n        return callNodeResult;\n    }\n\n    @Override\n    public Node processFunctionNode(FunctionNode functionNode) {\n        Node name = null;\n        if (functionNode.getFunctionName() != null) {\n            name = newNode(Token.NAME, functionNode.getName());\n        }\n        Node function = newNode(Token.FUNCTION, name, transform(functionNode.getParams()), transformBlock(functionNode.getBody()));\n        function.setIsArrowFunction(functionNode.isArrowFunction());\n        JSDocInfo info = functionNode.getJSDocInfo();\n        if (info != null) {\n            function.setJSDocInfo(NodeUtil.getBestJSDocInfo((Node) functionNode));\n        }\n        return function;\n    }\n\n    @Override\n    public Node processIfStatement(IfStatement statementNode) {\n        return newNode(\n                Token.IF,\n                transform(statementNode.getCondition()),\n                transform(statementNode.getThenPart()),\n                transform(statementNode.getElsePart()));\n    }\n\n    @Override\n    public Node processLabeledStatement(LabeledStatement statementNode) {\n        Node name = newNode(Token.LABEL_NAME, statementNode.getLabelName());\n        // Cast to Block so that the compiler knows we are passing a statement and not an expression\n        Node statement = transform((Block) statementNode.getStatement());\n        return newNode(Token.LABEL, name, statement);\n    }\n\n    @Override\n    public Node processName(Name nameNode) {\n        if (nameNode.getScope() == null) {\n            return IR.name(nameNode.getIdentifier());\n        }\n        Scope.Var var = nameNode.getScope().getVar(nameNode.getIdentifier());\n        if (var == null) {\n            // Create a dummy name node so that the error messages will have the correct name\n            // attached to them\n            return newNode(Token.NAME, nameNode.getIdentifier());\n        }\n        return IR.name(nameNode.getIdentifier(), var.getIndex());\n    }\n\n    @Override\n    public Node processNewExpression(NewExpression exprNode) {\n        Node target = transform(exprNode.getTarget());\n        Node callNodeResult = newNode(Token.NEW, target);\n        for (AstNode arg : exprNode.getArguments()) {\n            callNodeResult.addChildToBack(transform(arg));\n        }\n        return callNodeResult;\n    }\n\n    @Override\n    public Node processNumber(NumberLiteral numberNode) {\n        return newNode(Token.NUMBER, numberNode.getValue());\n    }\n\n    @Override\n    public Node processObjectLiteral(ObjectLiteral literalNode) {\n        Node objNode = newNode(Token.OBJECTLIT);\n        for (ObjectProperty prop : literalNode.getElements()) {\n            Node key = transform(prop.getLeft());\n            Node val = transform(prop.getRight());\n            // Copied from NodeFactory - ObjectProperty\n            int kidType = key.getType();\n            if (!(key instanceof StringLiteral) && kidType != Token.GETTER_DEF && kidType != Token.SETTER_DEF) {\n                key = IR.string(key.getString());\n            }\n            objNode.addChildToBack(newNode(prop.getType(), key, val));\n        }\n        return objNode;\n    }\n\n    @Override\n    public Node processParenthesizedExpression(ParenthesizedExpression parenNode) {\n        return newNode(Token.PARENTHESIS, transform(parenNode.getExpression()));\n    }\n\n    @Override\n    public Node processRegExpLiteral(RegExpLiteral regExpNode) {\n        Node regexNode = newNode(Token.REGEXP);\n        regexNode.putProp(Node.REGEXP_PROP, regExpNode.getValue());\n        regexNode.putProp(Node.LEFT, regExpNode.getFlags());\n        regexNode.putBooleanProp(Node.FOR, true);\n        regexNode.putBooleanProp(Node.COMPUTED_PROP, false);\n        return regexNode;\n    }\n\n    @Override\n    public Node processReturnStatement(ReturnStatement statementNode) {\n        Node node = newNode(Token.RETURN);\n        if (statementNode.getReturnValue() != null) {\n            node.addChildToBack(transform(statementNode.getReturnValue()));\n        }\n        return node;\n    }\n\n    @Override\n    public Node processString(StringLiteral stringNode) {\n        return newNode(Token.STRING, stringNode.getValue());\n    }\n\n    @Override\n    public Node processSwitchCase(SwitchCase switchCaseNode) {\n        Node switchCase = null;\n        if (switchCaseNode.getExpression() != null) {\n            switchCase = newNode(Token.CASE, transform(switchCaseNode.getExpression()));\n        } else {\n            switchCase = newNode(Token.DEFAULT);\n        }\n        switchCase.addChildToBack(transformBlock(switchCaseNode.getStatements()));\n        return switchCase;\n    }\n\n    @Override\n    public Node processSwitchStatement(SwitchStatement statementNode) {\n        return newNode(\n                Token.SWITCH,\n                transform(statementNode.getExpression()),\n                processGenericChildren(statementNode));\n    }\n\n    @Override\n    public Node processThrowStatement(ThrowStatement statementNode) {\n        Node node = newNode(Token.THROW);\n        node.addChildToBack(transform(statementNode.getExpression()));\n        return node;\n    }\n\n    @Override\n    public Node processTryStatement(TryStatement statementNode) {\n        Node tryBlock = transform(statementNode.getTryBlock());\n        Node catchBlock = null;\n        if (statementNode.getCatchBlock() != null) {\n            catchBlock = newNode(Token.CATCH, transform(statementNode.getCatchBlock().getCatchConditions()), transformBlock(statementNode.getCatchBlock().getBody()));\n        }\n        Node finallyBlock = null;\n        if (statementNode.getFinallyBlock() != null) {\n            finallyBlock = newNode(Token.FINALLY, transformBlock(statementNode.getFinallyBlock()));\n        }\n        return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n    }\n\n    @Override\n    public Node processUnaryExpression(UnaryExpression exprNode) {\n        Node childNode = transform(exprNode.getOperand());\n        if (childNode == null) {\n            return null;\n        }\n        return newNode(transformTokenType(exprNode.getType()), childNode);\n    }\n\n    @Override\n    public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n        Node node = newNode(transformTokenType(declarationNode.getType()));\n        for (VariableInitializer init : declarationNode.getVariables()) {\n            Node name = transform(init.getTarget());\n            Node value = null;\n            if (init.getInitializer() != null) {\n                value = transform(init.getInitializer());\n            }\n            node.addChildToBack(newNode(Token.NAME, name.getString()), value);\n        }\n        return node;\n    }\n\n    @Override\n    public Node processVariableInitializer(VariableInitializer initNode) {\n        throw new UnsupportedOperationException(\"This method should never be called directly.\");\n    }\n\n    @Override\n    public Node processWhileLoop(WhileLoop loopNode) {\n        return newNode(\n                Token.WHILE,\n                transform(loopNode.getCondition()),\n                transformBlock(loopNode.getBody()));\n    }\n\n    @Override\n    public Node processWithStatement(WithStatement statementNode) {\n        return newNode(Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement()));\n    }\n\n    @Override\n    protected Node visit(AstNode node) {\n        throw new UnsupportedOperationException(String.format(\"The %s node is not supported\", node.shortName()));\n    }\n\n    private Node transform(AstNode node) {\n        if (node == null) {\n            return null;\n        }\n\n        Node result = node.visit(this);\n        if (result == null) {\n            throw new IllegalStateException(\"transform returned null\");\n        }\n        result.copyInformationFrom(node);\n\n        if (isDirective(node)) {\n            result.putBooleanProp(Node.IS_DIRECTIVE, true);\n        }\n        return result;\n    }\n\n    private Node transformBlock(AstNode node) {\n        if (node == null) {\n            return null;\n        }\n        if (node instanceof Scope) {\n            Scope blockScope = (Scope) node;\n            checkForViolations(Parser.Config.StrictMode.under((Node) node), blockScope);\n        }\n        Node result = node.visit(this);\n        if (result == null) {\n            throw new IllegalStateException(\"transform returned null\");\n        }\n        result.copyInformationFrom(node);\n        return result;\n    }\n\n    private void checkForViolations(Parser.Config config, Scope scope) {\n        for (Var v : scope.getVars()) {\n            if (v.isConstant() && !(v.getParentNode() instanceof Scope && ((Scope) v.getParentNode()).isModuleScope())) {\n                if (!v.isDeclaredTypeSet() || !v.getDeclaredTypeExpression().isEquivalentTo(new StringLiteral(\"string\", v.getLineno(), v.getCharno()))) {\n                    errorReporter.error(\n                            \"Constants must have type annotations that match their value types.\",\n                            sourceName, v.getLineno(), \"\", 0);\n                }\n            }\n        }\n        // recursively check child scopes\n        for (Scope child : scope.getChildren()) {\n            checkForViolations(config, child);\n        }\n    }\n\n    private void checkForViolation(Parser.Config config, Node destructAssign) {\n        Node[] lValues;\n        if (TreeUtil.isDestructuring(destructAssign)) {\n            lValues = TreeUtil.findLhsNodesInNode(destructAssign);\n        } else {\n            lValues = new Node[]{destructAssign};\n        }\n        for (Node n : lValues) {\n            if (n.getType() == Token.NAME &",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..4f3ff65b 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,432 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class TransformDispatcher extends TypeSafeDispatcher<Node> {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+    private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+            ImmutableSet.of(\"use strict\", \"use asm\");\n+\n+    private final ErrorReporter errorReporter;\n+    private final String sourceName;\n+\n+    public TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+        this.errorReporter = errorReporter;\n+        this.sourceName = sourceName;\n+    }\n+\n+    protected Node cast(AstNode n) {\n+        return (Node) n;\n+    }\n+\n+    private boolean isDirective(AstNode n) {\n+        if (n == null) return false;\n+\n+        int nType = n.getType();\n+        return nType == Token.EXPR_RESULT &&\n+                cast(n).getFirstChild().isString() &&\n+                ALLOWED_DIRECTIVES.contains(cast(n).getFirstChild().getString());\n     }\n \n     @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    public Node processBlock(Block blockNode) {\n+        return processGeneric(blockNode);\n     }\n \n     @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node processBreakStatement(BreakStatement statementNode) {\n+        Node node = newNode(Token.BREAK);\n+        if (statementNode.getBreakLabel() != null) {\n+            Node labelName = transform(statementNode.getBreakLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    public Node processCatchClause(CatchClause clauseNode) {\n+        AstNode catchVar = clauseNode.getVarName();\n+        Node node = newNode(Token.CATCH, transform(catchVar));\n+        if (clauseNode.getCatchCondition() != null) {\n+            errorReporter.error(\n+                    \"Catch clauses are not supported\",\n+                    sourceName,\n+                    clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+        }\n+        node.addChildToBack(transformBlock(clauseNode.getBody()));\n+        return node;\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+    public Node processConditionalExpression(ConditionalExpression exprNode) {\n+        return newNode(\n+                Token.HOOK,\n+                transform(exprNode.getTestExpression()),\n+                transform(exprNode.getTrueExpression()),\n+                transform(exprNode.getFalseExpression()));\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node processContinueStatement(ContinueStatement statementNode) {\n+        Node node = newNode(Token.CONTINUE);\n+        if (statementNode.getLabel() != null) {\n+            Node labelName = transform(statementNode.getLabel());\n+            // Change the NAME to LABEL_NAME\n+            labelName.setType(Token.LABEL_NAME);\n+            node.addChildToBack(labelName);\n+        }\n+        return node;\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node processDoLoop(DoLoop loopNode) {\n+        return newNode(\n+                Token.DO,\n+                transformBlock(loopNode.getBody()),\n+                transform(loopNode.getCondition()));\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node processElementGet(ElementGet getNode) {\n+        return newNode(\n+                Token.GETELEM,\n+                transform(getNode.getTarget()),\n+                transform(getNode.getElement()));\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node processEmptyExpression(EmptyExpression exprNode) {\n+        return newNode(Token.EMPTY);\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node processExpressionStatement(ExpressionStatement statementNode) {\n+        Node node = newNode(transformTokenType(statementNode.getType()));\n+        node.addChildToBack(transform(statementNode.getExpression()));\n+        return node;\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node processForInLoop(ForInLoop loopNode) {\n+        AstNode iterNode = loopNode.getIterator();\n+        AstNode objNode = loopNode.getIteratedObject();\n+        Node lhs, rhs;\n+        if (iterNode instanceof DestructuringForm) {\n+            checkForViolation(Parser.Config.StrictMode.under((Node) iterNode), ((DestructuringForm) iterNode).getLeft());\n+            lhs = transform(iterNode);\n+            rhs = transform(objNode);\n+        } else {\n+            lhs = transform(iterNode);\n+            rhs =\n+                    newNode(\n+                            Token.CALL,\n+                            newNode(Token.NAME, IR.getPropCoded(REGEXP = IR.name(\"RegExp\"), \"prototype\")),\n+                            transform(objNode));\n+            rhs.putProp(Node.REGEXP_PROP, Boolean.TRUE);\n+        }\n+        Node forNode = newNode(Token.FOR, lhs, rhs, transformBlock(loopNode.getBody()));\n+        return forNode;\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    @Override\n+    public Node processForLoop(ForLoop loopNode) {\n+        Node initial, condition, increment, body;\n+\n+        if (loopNode.getInitializer() != null) {\n+            initial = transform(loopNode.getInitializer());\n+        } else {\n+            // equivalent of `var <ident>;` - create a dummy var declaration with no initializer\n+            initial = newNode(Token.VAR);\n+        }\n+\n+        if (loopNode.getCondition() != null) {\n+            condition = transform(loopNode.getCondition());\n+        } else {\n+            // equivalent of `<loop>` - no condition needed\n+            condition = newNode(Token.TRUE);\n+        }\n+\n+        if (loopNode.getIncrement() != null) {\n+            increment = transform(loopNode.getIncrement());\n+        } else {\n+            // equivalent of `++<ident>` - create an increment operation with no LHS (no-op)\n+            increment = new Node(Token.EXPR_RESULT);\n+            increment.addChildToBack(newNode(Token.INC, newNode(Token.NAME)));\n+        }\n+\n+        body = transformBlock(loopNode.getBody());\n+\n+        return newNode(Token.FOR, initial, condition, increment, body);\n+    }\n+\n+    @Override\n+    public Node processFunctionCall(FunctionCall callNode) {\n+        Node target = transform(callNode.getTarget());\n+        Node callNodeResult = newNode(Token.CALL, target);\n+        for (AstNode arg : callNode.getArguments()) {\n+            Node transformedArg = transform(arg);\n+            if (transformedArg == null) {\n+                // If any argument is null, return null rather than erroring out\n+                return null;\n+            }\n+            callNodeResult.addChildToBack(transformedArg);\n+        }\n+        return callNodeResult;\n+    }\n+\n+    @Override\n+    public Node processFunctionNode(FunctionNode functionNode) {\n+        Node name = null;\n+        if (functionNode.getFunctionName() != null) {\n+            name = newNode(Token.NAME, functionNode.getName());\n+        }\n+        Node function = newNode(Token.FUNCTION, name, transform(functionNode.getParams()), transformBlock(functionNode.getBody()));\n+        function.setIsArrowFunction(functionNode.isArrowFunction());\n+        JSDocInfo info = functionNode.getJSDocInfo();\n+        if (info != null) {\n+            function.setJSDocInfo(NodeUtil.getBestJSDocInfo((Node) functionNode));\n+        }\n+        return function;\n+    }\n+\n+    @Override\n+    public Node processIfStatement(IfStatement statementNode) {\n+        return newNode(\n+                Token.IF,\n+                transform(statementNode.getCondition()),\n+                transform(statementNode.getThenPart()),\n+                transform(statementNode.getElsePart()));\n+    }\n+\n+    @Override\n+    public Node processLabeledStatement(LabeledStatement statementNode) {\n+        Node name = newNode(Token.LABEL_NAME, statementNode.getLabelName());\n+        // Cast to Block so that the compiler knows we are passing a statement and not an expression\n+        Node statement = transform((Block) statementNode.getStatement());\n+        return newNode(Token.LABEL, name, statement);\n+    }\n+\n+    @Override\n+    public Node processName(Name nameNode) {\n+        if (nameNode.getScope() == null) {\n+            return IR.name(nameNode.getIdentifier());\n+        }\n+        Scope.Var var = nameNode.getScope().getVar(nameNode.getIdentifier());\n+        if (var == null) {\n+            // Create a dummy name node so that the error messages will have the correct name\n+            // attached to them\n+            return newNode(Token.NAME, nameNode.getIdentifier());\n+        }\n+        return IR.name(nameNode.getIdentifier(), var.getIndex());\n+    }\n+\n+    @Override\n+    public Node processNewExpression(NewExpression exprNode) {\n+        Node target = transform(exprNode.getTarget());\n+        Node callNodeResult = newNode(Token.NEW, target);\n+        for (AstNode arg : exprNode.getArguments()) {\n+            callNodeResult.addChildToBack(transform(arg));\n+        }\n+        return callNodeResult;\n+    }\n+\n+    @Override\n+    public Node processNumber(NumberLiteral numberNode) {\n+        return newNode(Token.NUMBER, numberNode.getValue());\n     }\n \n+    @Override\n+    public Node processObjectLiteral(ObjectLiteral literalNode) {\n+        Node objNode = newNode(Token.OBJECTLIT);\n+        for (ObjectProperty prop : literalNode.getElements()) {\n+            Node key = transform(prop.getLeft());\n+            Node val = transform(prop.getRight());\n+            // Copied from NodeFactory - ObjectProperty\n+            int kidType = key.getType();\n+            if (!(key instanceof StringLiteral) && kidType != Token.GETTER_DEF && kidType != Token.SETTER_DEF) {\n+                key = IR.string(key.getString());\n+            }\n+            objNode.addChildToBack(newNode(prop.getType(), key, val));\n+        }\n+        return objNode;\n+    }\n+\n+    @Override\n+    public Node processParenthesizedExpression(ParenthesizedExpression parenNode) {\n+        return newNode(Token.PARENTHESIS, transform(parenNode.getExpression()));\n+    }\n+\n+    @Override\n+    public Node processRegExpLiteral(RegExpLiteral regExpNode) {\n+        Node regexNode = newNode(Token.REGEXP);\n+        regexNode.putProp(Node.REGEXP_PROP, regExpNode.getValue());\n+        regexNode.putProp(Node.LEFT, regExpNode.getFlags());\n+        regexNode.putBooleanProp(Node.FOR, true);\n+        regexNode.putBooleanProp(Node.COMPUTED_PROP, false);\n+        return regexNode;\n+    }\n+\n+    @Override\n+    public Node processReturnStatement(ReturnStatement statementNode) {\n+        Node node = newNode(Token.RETURN);\n+        if (statementNode.getReturnValue() != null) {\n+            node.addChildToBack(transform(statementNode.getReturnValue()));\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    public Node processString(StringLiteral stringNode) {\n+        return newNode(Token.STRING, stringNode.getValue());\n+    }\n+\n+    @Override\n+    public Node processSwitchCase(SwitchCase switchCaseNode) {\n+        Node switchCase = null;\n+        if (switchCaseNode.getExpression() != null) {\n+            switchCase = newNode(Token.CASE, transform(switchCaseNode.getExpression()));\n+        } else {\n+            switchCase = newNode(Token.DEFAULT);\n+        }\n+        switchCase.addChildToBack(transformBlock(switchCaseNode.getStatements()));\n+        return switchCase;\n+    }\n+\n+    @Override\n+    public Node processSwitchStatement(SwitchStatement statementNode) {\n+        return newNode(\n+                Token.SWITCH,\n+                transform(statementNode.getExpression()),\n+                processGenericChildren(statementNode));\n+    }\n+\n+    @Override\n+    public Node processThrowStatement(ThrowStatement statementNode) {\n+        Node node = newNode(Token.THROW);\n+        node.addChildToBack(transform(statementNode.getExpression()));\n+        return node;\n+    }\n+\n+    @Override\n+    public Node processTryStatement(TryStatement statementNode) {\n+        Node tryBlock = transform(statementNode.getTryBlock());\n+        Node catchBlock = null;\n+        if (statementNode.getCatchBlock() != null) {\n+            catchBlock = newNode(Token.CATCH, transform(statementNode.getCatchBlock().getCatchConditions()), transformBlock(statementNode.getCatchBlock().getBody()));\n+        }\n+        Node finallyBlock = null;\n+        if (statementNode.getFinallyBlock() != null) {\n+            finallyBlock = newNode(Token.FINALLY, transformBlock(statementNode.getFinallyBlock()));\n+        }\n+        return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+    }\n+\n+    @Override\n+    public Node processUnaryExpression(UnaryExpression exprNode) {\n+        Node childNode = transform(exprNode.getOperand());\n+        if (childNode == null) {\n+            return null;\n+        }\n+        return newNode(transformTokenType(exprNode.getType()), childNode);\n+    }\n+\n+    @Override\n+    public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n+        Node node = newNode(transformTokenType(declarationNode.getType()));\n+        for (VariableInitializer init : declarationNode.getVariables()) {\n+            Node name = transform(init.getTarget());\n+            Node value = null;\n+            if (init.getInitializer() != null) {\n+                value = transform(init.getInitializer());\n+            }\n+            node.addChildToBack(newNode(Token.NAME, name.getString()), value);\n+        }\n+        return node;\n+    }\n+\n+    @Override\n+    public Node processVariableInitializer(VariableInitializer initNode) {\n+        throw new UnsupportedOperationException(\"This method should never be called directly.\");\n+    }\n+\n+    @Override\n+    public Node processWhileLoop(WhileLoop loopNode) {\n+        return newNode(\n+                Token.WHILE,\n+                transform(loopNode.getCondition()),\n+                transformBlock(loopNode.getBody()));\n+    }\n+\n+    @Override\n+    public Node processWithStatement(WithStatement statementNode) {\n+        return newNode(Token.WITH, transform(statementNode.getExpression()), transformBlock(statementNode.getStatement()));\n+    }\n+\n+    @Override\n+    protected Node visit(AstNode node) {\n+        throw new UnsupportedOperationException(String.format(\"The %s node is not supported\", node.shortName()));\n+    }\n+\n+    private Node transform(AstNode node) {\n+        if (node == null) {\n+            return null;\n+        }\n+\n+        Node result = node.visit(this);\n+        if (result == null) {\n+            throw new IllegalStateException(\"transform returned null\");\n+        }\n+        result.copyInformationFrom(node);\n+\n+        if (isDirective(node)) {\n+            result.putBooleanProp(Node.IS_DIRECTIVE, true);\n+        }\n+        return result;\n+    }\n+\n+    private Node transformBlock(AstNode node) {\n+        if (node == null) {\n+            return null;\n+        }\n+        if (node instanceof Scope) {\n+            Scope blockScope = (Scope) node;\n+            checkForViolations(Parser.Config.StrictMode.under((Node) node), blockScope);\n+        }\n+        Node result = node.visit(this);\n+        if (result == null) {\n+            throw new IllegalStateException(\"transform returned null\");\n+        }\n+        result.copyInformationFrom(node);\n+        return result;\n+    }\n+\n+    private void checkForViolations(Parser.Config config, Scope scope) {\n+        for (Var v : scope.getVars()) {\n+            if (v.isConstant() && !(v.getParentNode() instanceof Scope && ((Scope) v.getParentNode()).isModuleScope())) {\n+                if (!v.isDeclaredTypeSet() || !v.getDeclaredTypeExpression().isEquivalentTo(new StringLiteral(\"string\", v.getLineno(), v.getCharno()))) {\n+                    errorReporter.error(\n+                            \"Constants must have type annotations that match their value types.\",\n+                            sourceName, v.getLineno(), \"\", 0);\n+                }\n+            }\n+        }\n+        // recursively check child scopes\n+        for (Scope child : scope.getChildren()) {\n+            checkForViolations(config, child);\n+        }\n+    }\n+\n+    private void checkForViolation(Parser.Config config, Node destructAssign) {\n+        Node[] lValues;\n+        if (TreeUtil.isDestructuring(destructAssign)) {\n+            lValues = TreeUtil.findLhsNodesInNode(destructAssign);\n+        } else {\n+            lValues = new Node[]{destructAssign};\n+        }\n+        for (Node n : lValues) {\n+            if (n.getType() == Token.NAME &\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}