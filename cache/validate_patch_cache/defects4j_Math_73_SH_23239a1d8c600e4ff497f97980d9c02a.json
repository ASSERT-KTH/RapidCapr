{
    "patch": "        final int maximalIterationCount = 100;\n        double x0 = min;\n        double x1 = initial;\n        double x2 = max;\n        double f0 = f.value(x0);\n        double f1 = f.value(x1);\n        double f2 = f.value(x2);\n\n        double previousDx = Double.MAX_VALUE;\n        double delta = 0d;\n\n        for (int i = 0; i < maximalIterationCount; ++i) {\n            double dx = x2 - x1;\n            double denominator = (f2 - f1) - delta * (f1 - f0);\n            double dInv = 1d / denominator;\n            double interpolant;\n\n            if (Double.isInfinite(denominator)) {\n                // linear interpolation\n                interpolant = x1 - f1 * dx / (f2 - f1);\n            } else {\n                // inverse quadratic interpolation\n                interpolant = x1 - (f1 / denominator) * dx;\n            }\n\n            double oldDelta = delta;\n            delta = 2 * (x1 - x0) * (f1 - f2) / ((x2 - x1) * (f0 - f1) - (x1 - x0) * (f1 - f2));\n            if (!Double.isFinite(delta) || Math.abs(delta) >= Math.abs(oldDelta)) {\n                // bisection fallback\n                delta = dx > 0 ? dx / 2 : -dx / 2;\n                interpolant = x1 + delta;\n            } else {\n                interpolant = x1 + delta;\n                if ((interpolant - x1) / dx > 0.5) {\n                    // bisection fallback\n                    delta = dx > 0 ? dx / 2 : -dx / 2;\n                    interpolant = x1 + delta;\n                }\n            }\n\n            double fInterpolant = f.value(interpolant);\n            if (fInterpolant == 0d) {\n                setResult(interpolant, i);\n                return result;\n            }\n\n            if (fInterpolant * f1 < 0) {\n                x0 = x1;\n                f0 = f1;\n                x2 = interpolant;\n                f2 = fInterpolant;\n                delta = oldDelta;\n            } else if (fInterpolant * f2 < 0) {\n                x1 = interpolant;\n                f1 = fInterpolant;\n                x0 = x2;\n                f0 = f2;\n                delta = oldDelta;\n            } else {\n                setResult(interpolant, i);\n                return result;\n            }\n\n            if (Math.abs(f0) < Math.abs(f1)) {\n                // swap so that f0 is the best approximation\n                double temp = x0;\n                x0 = x1;\n                x1 = temp;\n                temp = f0;\n                f0 = f1;\n                f1 = temp;\n            }\n\n            previousDx = dx;\n            if (Math.abs(f1) <= functionValueAccuracy ||\n                    (result != null && Math.abs(dx) <= absoluteAccuracy)) {\n                setResult(x1, i);\n                return result;\n            }\n        }\n\n        throw new MaxIterationsExceededException(maximalIterationCount);",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..77faca0d2 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,88 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        final int maximalIterationCount = 100;\n+        double x0 = min;\n+        double x1 = initial;\n+        double x2 = max;\n+        double f0 = f.value(x0);\n+        double f1 = f.value(x1);\n+        double f2 = f.value(x2);\n+\n+        double previousDx = Double.MAX_VALUE;\n+        double delta = 0d;\n+\n+        for (int i = 0; i < maximalIterationCount; ++i) {\n+            double dx = x2 - x1;\n+            double denominator = (f2 - f1) - delta * (f1 - f0);\n+            double dInv = 1d / denominator;\n+            double interpolant;\n+\n+            if (Double.isInfinite(denominator)) {\n+                // linear interpolation\n+                interpolant = x1 - f1 * dx / (f2 - f1);\n+            } else {\n+                // inverse quadratic interpolation\n+                interpolant = x1 - (f1 / denominator) * dx;\n+            }\n+\n+            double oldDelta = delta;\n+            delta = 2 * (x1 - x0) * (f1 - f2) / ((x2 - x1) * (f0 - f1) - (x1 - x0) * (f1 - f2));\n+            if (!Double.isFinite(delta) || Math.abs(delta) >= Math.abs(oldDelta)) {\n+                // bisection fallback\n+                delta = dx > 0 ? dx / 2 : -dx / 2;\n+                interpolant = x1 + delta;\n+            } else {\n+                interpolant = x1 + delta;\n+                if ((interpolant - x1) / dx > 0.5) {\n+                    // bisection fallback\n+                    delta = dx > 0 ? dx / 2 : -dx / 2;\n+                    interpolant = x1 + delta;\n+                }\n+            }\n+\n+            double fInterpolant = f.value(interpolant);\n+            if (fInterpolant == 0d) {\n+                setResult(interpolant, i);\n+                return result;\n+            }\n+\n+            if (fInterpolant * f1 < 0) {\n+                x0 = x1;\n+                f0 = f1;\n+                x2 = interpolant;\n+                f2 = fInterpolant;\n+                delta = oldDelta;\n+            } else if (fInterpolant * f2 < 0) {\n+                x1 = interpolant;\n+                f1 = fInterpolant;\n+                x0 = x2;\n+                f0 = f2;\n+                delta = oldDelta;\n+            } else {\n+                setResult(interpolant, i);\n+                return result;\n+            }\n+\n+            if (Math.abs(f0) < Math.abs(f1)) {\n+                // swap so that f0 is the best approximation\n+                double temp = x0;\n+                x0 = x1;\n+                x1 = temp;\n+                temp = f0;\n+                f0 = f1;\n+                f1 = temp;\n+            }\n+\n+            previousDx = dx;\n+            if (Math.abs(f1) <= functionValueAccuracy ||\n+                    (result != null && Math.abs(dx) <= absoluteAccuracy)) {\n+                setResult(x1, i);\n+                return result;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(maximalIterationCount);\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: incomparable types: double and <null>",
    "test_result": "ERROR"
}