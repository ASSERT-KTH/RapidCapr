{
    "patch": "import org.apache.commons.math3.exception.DerivativeException;\nimport org.apache.commons.math3.exception.IntegratorException;\nimport org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\nimport org.apache.commons.math3.ode.events.CombinedEventsManager;\nimport org.apache.commons.math3.ode.events.EventHandler;\nimport org.apache.commons.math3.ode.events.EventState;\nimport org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;\nimport org.apache.commons.math3.ode.sampling.DummyStepInterpolator;\nimport org.apache.commons.math3.ode.sampling.StepHandler;\nimport org.apache.commons.math3.ode.sampling.StepInterpolator;\nimport org.apache.commons.math3.ode.sampling.StepNormalizer;\nimport org.apache.commons.math3.util.FastMath;\n\npublic class IntegrationUtility {\n\n    private static final double SAFETY = 0.9;\n    private static final double MIN_REDUCTION = 0.2;\n    private static final double MAX_GROWTH = 10.0;\n\n    private double[] vecAbsoluteTolerance;\n\n    private double   scalAbsoluteTolerance;\n\n    private double   scalRelativeTolerance;\n\n    private double[] vecRelativeTolerance;\n\n    private final EventHandler[] handlers;\n\n    private final CombinedEventsManager manager;\n\n    private final int maxEvaluations;\n\n    private final AbstractIntegrator prototype;\n\n    private final AbstractIntegrator integrator;\n\n    public IntegrationUtility(final EventHandler[]  eventHandlers,\n                              final int              maximalEvaluations,\n                              final AbstractIntegrator prototype) {\n        this(eventHandlers, maximalEvaluations, prototype, 1.0e-6, 1.0e-6, null);\n    }\n\n    public IntegrationUtility(final EventHandler[]    eventHandlers,\n                              final int                maximalEvaluations,\n                              final AbstractIntegrator prototype,\n                              final double             scalAbsoluteTolerance,\n                              final double             scalRelativeTolerance,\n                              final double[]           vecAbsoluteTolerance) {\n        this.handlers                 = eventHandlers.clone();\n        this.manager                  = new CombinedEventsManager(handlers);\n        this.maxEvaluations           = maximalEvaluations;\n        this.prototype                = prototype;\n        this.integrator               = prototype.copy();\n        this.vecAbsoluteTolerance     = vecAbsoluteTolerance == null ? null : vecAbsoluteTolerance.clone();\n        this.scalAbsoluteTolerance    = scalAbsoluteTolerance;\n        this.scalRelativeTolerance    = scalRelativeTolerance;\n        this.vecRelativeTolerance     = null;\n    }\n\n    public void setRelativeTolerance(final double relTolerance) {\n        this.vecRelativeTolerance = null;\n        this.scalRelativeTolerance = relTolerance;\n    }\n\n    public void setRelativeTolerance(final double[] vecRelTolerance) {\n        if (vecRelTolerance == null) {\n            this.vecRelativeTolerance = null;\n        } else {\n            this.vecRelativeTolerance = vecRelTolerance.clone();\n        }\n        this.scalRelativeTolerance = Double.NaN;\n    }\n\n    public void integrate(final FirstOrderDifferentialEquations equations,\n                          final double t0, final double[] y0,\n                          final double t, final double[] y)\n    throws DerivativeException, IntegratorException {\n        int i = integrator.integrate(equations, t0, y0, t, y);\n        double [][] yDot = integrator.getEvaluations();\n        setEventY(equations, integrator, i, yDot, y);\n    }\n\n    private void setEventY(final FirstOrderDifferentialEquations equations,\n                            final AbstractIntegrator integrator,\n                            final int i, final double[][] yDot, final double[] y)\n            throws IntegratorException, DerivativeException {\n        if (i >= 0) {\n            // the integration was a success\n            for (EventHandler handler : handlers) {\n                EventState ese = ((AbstractEventHandler) handler).getEventState();\n                if (ese.isOccurred()) {\n                    // an event has occurred before the end of the integration interval\n                    final double    eventTime = ese.getEventTime();\n                    final double[]  eventY    = new double[y.length];\n                    integrator.setInterpolatedTime(eventTime);\n                    integrator.getInterpolatedState(eventY);\n                    ese.stepAccepted(eventTime, eventY);\n                    final int nb = equations.getDimension();\n                    double[] y1 = new double[nb];\n                    equations.computeDerivatives(eventTime, eventY, y1);\n                    double[] yDot1 = new double[nb];\n                    for (int j = 0; j < nb; ++j) {\n                        yDot1[j] = y1[j];\n                    }\n                    ese.reset(eventTime, y1);\n                    for (int j = 0; j < ese.getEventsHandlers().size(); ++j) {\n                        EventHandler eh = ese.getEventsHandlers().get(j);\n                        ((AbstractEventHandler) eh).getEventState().reset(eventTime, y1);                     }\n                    equations.computeDerivatives(eventTime, eventY, yDot[j]);\n                }\n            }\n        } else {\n            // an integration failure occurred before the end of the integration interval\n            double h = integrator.getCurrentStepStart();\n            final double[] yMidDots = new double[equations.getDimension()];\n            double[] y1 = new double[y.length];\n            double[] yTmp = (double[]) y.clone();\n            for (int k = 0; k < y1.length; ++k) {\n                y1[k] = y[k];\n                for (int l = 0; l < integrator.getStages(); ++l) {\n                    y1[k]      += h * integrator.getA(l) * yDot[l][k];\n                    yMidDots[k] = integrator.getB(l) * yDot[l][k];\n                }\n            }\n            final double[] yDot1 = new double[y.length];\n            equations.computeDerivatives(integrator.getCurrentSignedStepsize(), y1, yDot1);\n            if (h > 0) {\n                for (int k = 0; k < y1.length; ++k) {\n                    yTmp[k] += h * yMidDots[k];\n                }\n            } else {\n                for (int k = 0; k < y1.length; ++k) {\n                    yTmp[k] -= h * yMidDots[k];\n                }\n            }\n            equations.computeDerivatives(integrator.getCurrentSignedStepsize(), yTmp, yDot1);\n            throw new IntegratorException(\"maximal number of iterations reached\" +\n                                          \"consider increasing the maximal number of iterations\");\n        }\n    }\n\n    private abstract class AbstractEventHandler implements EventHandler {\n        private final EventState state;\n\n        public AbstractEventHandler() {\n            state = new EventState();\n        }\n\n        protected EventState getEventState() {\n            return state;\n        }\n\n        @Override\n        public final double g(final double t, final double[] y) throws DerivativeException {\n            return state.evaluateStep(t, y);\n        }\n\n        @Override\n        public final int eventOccurred(final double t, final double[] y, final boolean increasing)\n        throws DerivativeException {\n            return state.stepAccepted(t, y) ? 1 : -1;\n        }\n\n        @Override\n        public final EventHandler.Action eventAction(final double t, final double[] y, final boolean increasing)\n        throws DerivativeException {\n            return state.currentState() == EventState.State.FAILED ?\n                   EventHandler.Action.STOP :\n                   (state.stop() ? EventHandler.Action.STOP : EventHandler.Action.RESET_STATE);\n        }\n\n        @Override\n        public abstract void init(final double t0, final double[] y0, final double t);\n    }\n\n    private class GlueEventHandler extends AbstractEventHandler {\n        @Override\n        public void init(final double t0, final double[] y0, final double t) {\n            for (EventHandler eventHandler : handlers) {\n                eventHandler.init(t0, y0, t);\n            }\n        }\n    }\n\n    private static class DummyStepHandler implements StepHandler {\n        @Override\n        public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n            // do nothing\n        }\n\n        @Override\n        public void init(final double t0, final double[] y0, final double t) {\n            // do nothing\n        }\n\n        @Override\n        public void reset() {\n            // do nothing\n        }\n    }\n\n\n    private interface AbstractIntegrator extends ODEIntegrator {\n        void setInterpolatedTime(final double time);\n        void setInterpolatedState(final double[] state);\n        double getCurrentStepStart();\n        int getStages();\n        double getA(int i);\n        double getB(int i);\n    }\n\n    private static class DormandPrince54IntegratorWrapper implements AbstractIntegrator {\n\n        private final DormandPrince54Integrator impl;\n        private StepNormalizer normalizer;\n\n        DormandPrince54IntegratorWrapper(final double minStep,\n                                         final double maxStep,\n                                         final double[] vecAbsoluteTolerance,\n                                         final double scalarAbsoluteTolerance,\n                                         final double[] vecRelativeTolerance,\n                                         final double scalarRelativeTolerance) {\n            impl = new DormandPrince54Integrator(minStep, maxStep, vecAbsoluteTolerance,\n                                                 scalarAbsoluteTolerance, vecRelativeTolerance,\n                                                 scalarRelativeTolerance);\n        }\n\n        @Override\n        public void addEventHandler(final EventHandler eventHandler, final double maxCheckInterval,\n                                     final double convergence, final int maxIterationCount) {\n            impl.addEventHandler(eventHandler, maxCheckInterval, convergence, maxIterationCount);\n        }\n\n        @Override\n        public void addEquations(final FirstOrderDifferentialEquations ode, final double[] y0, final double finalTime) {\n            impl.addEquations(ode, y0, finalTime);\n        }\n\n        @Override\n        public void addStepHandler(final StepHandler handler) {\n            impl.addStepHandler(handler);\n            normalizer = new StepNormalizer(1.0, handler);\n            impl.addStepHandler(normalizer);\n        }\n\n        @Override\n        public AbstractIntegrator copy() {\n            return new DormandPrince54IntegratorWrapper(impl.getMinStep(), impl.getMaxStep(),\n                                                        impl.getVecAbsoluteTolerance(),\n                                                        impl.getScalarsAbsoluteTolerance(),\n                                                        impl.getVecRelativeTolerance(),\n                                                        impl.getScalarRelativeTolerance());\n        }\n\n        @Override\n        public int getEvaluations() {\n            return impl.getEvaluations();\n        }\n\n        @Override\n        public double integrate(final FirstOrderDifferentialEquations ode, final double t0, final double[] y0,\n                                final double t, final double[] y) throws DerivativeException, IntegratorException {\n            normalizer.reset();\n            impl.addEventHandler(manager, Double.POSITIVE_INFINITY, 1.0e-12 * (t - t0), maxEvaluations);\n            return impl.integrate(ode, t0, y0, t, y);\n        }\n\n        @Override\n        public boolean isLastStep() {\n            return impl.isLastStep();\n        }\n\n        @Override\n        public double getCurrentSignedStepsize() {\n            return impl.getCurrentSignedStepsize();\n        }\n\n        @Override\n        public void setInterpolatedTime(final double time) {\n            impl.setInterpolatedTime(time);\n        }\n\n        @Override\n        public void setInterpolatedState(final double[] state) {\n            impl.setInterpolatedState(state);\n        }\n\n        @Override\n        public double getCurrentStepStart() {\n            return impl.getCurrentStepStart();\n        }\n\n        @Override\n        public int getStages() {\n            return 7;\n        }\n\n        @Override\n        public double getA(int i) {\n            switch (i) {\n                case 0:\n                    return 0;\n                case 1:\n                    return 1.0 / 5.0;\n                case 2:\n                    return 3.0 / 10.0;\n                case 3:\n                    return 4.0 / 5.0;\n                case 4:\n                    retur",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\nindex 6f3e88358..db045788c 100644\n--- a/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n+++ b/src/main/java/org/apache/commons/math/ode/nonstiff/EmbeddedRungeKuttaIntegrator.java\n@@ -189,174 +189,317 @@ public abstract class EmbeddedRungeKuttaIntegrator\n \n   /** {@inheritDoc} */\n   @Override\n-  public double integrate(final FirstOrderDifferentialEquations equations,\n+import org.apache.commons.math3.exception.DerivativeException;\n+import org.apache.commons.math3.exception.IntegratorException;\n+import org.apache.commons.math3.ode.FirstOrderDifferentialEquations;\n+import org.apache.commons.math3.ode.events.CombinedEventsManager;\n+import org.apache.commons.math3.ode.events.EventHandler;\n+import org.apache.commons.math3.ode.events.EventState;\n+import org.apache.commons.math3.ode.sampling.AbstractStepInterpolator;\n+import org.apache.commons.math3.ode.sampling.DummyStepInterpolator;\n+import org.apache.commons.math3.ode.sampling.StepHandler;\n+import org.apache.commons.math3.ode.sampling.StepInterpolator;\n+import org.apache.commons.math3.ode.sampling.StepNormalizer;\n+import org.apache.commons.math3.util.FastMath;\n+\n+public class IntegrationUtility {\n+\n+    private static final double SAFETY = 0.9;\n+    private static final double MIN_REDUCTION = 0.2;\n+    private static final double MAX_GROWTH = 10.0;\n+\n+    private double[] vecAbsoluteTolerance;\n+\n+    private double   scalAbsoluteTolerance;\n+\n+    private double   scalRelativeTolerance;\n+\n+    private double[] vecRelativeTolerance;\n+\n+    private final EventHandler[] handlers;\n+\n+    private final CombinedEventsManager manager;\n+\n+    private final int maxEvaluations;\n+\n+    private final AbstractIntegrator prototype;\n+\n+    private final AbstractIntegrator integrator;\n+\n+    public IntegrationUtility(final EventHandler[]  eventHandlers,\n+                              final int              maximalEvaluations,\n+                              final AbstractIntegrator prototype) {\n+        this(eventHandlers, maximalEvaluations, prototype, 1.0e-6, 1.0e-6, null);\n+    }\n+\n+    public IntegrationUtility(final EventHandler[]    eventHandlers,\n+                              final int                maximalEvaluations,\n+                              final AbstractIntegrator prototype,\n+                              final double             scalAbsoluteTolerance,\n+                              final double             scalRelativeTolerance,\n+                              final double[]           vecAbsoluteTolerance) {\n+        this.handlers                 = eventHandlers.clone();\n+        this.manager                  = new CombinedEventsManager(handlers);\n+        this.maxEvaluations           = maximalEvaluations;\n+        this.prototype                = prototype;\n+        this.integrator               = prototype.copy();\n+        this.vecAbsoluteTolerance     = vecAbsoluteTolerance == null ? null : vecAbsoluteTolerance.clone();\n+        this.scalAbsoluteTolerance    = scalAbsoluteTolerance;\n+        this.scalRelativeTolerance    = scalRelativeTolerance;\n+        this.vecRelativeTolerance     = null;\n+    }\n+\n+    public void setRelativeTolerance(final double relTolerance) {\n+        this.vecRelativeTolerance = null;\n+        this.scalRelativeTolerance = relTolerance;\n+    }\n+\n+    public void setRelativeTolerance(final double[] vecRelTolerance) {\n+        if (vecRelTolerance == null) {\n+            this.vecRelativeTolerance = null;\n+        } else {\n+            this.vecRelativeTolerance = vecRelTolerance.clone();\n+        }\n+        this.scalRelativeTolerance = Double.NaN;\n+    }\n+\n+    public void integrate(final FirstOrderDifferentialEquations equations,\n                           final double t0, final double[] y0,\n                           final double t, final double[] y)\n-  throws DerivativeException, IntegratorException {\n+    throws DerivativeException, IntegratorException {\n+        int i = integrator.integrate(equations, t0, y0, t, y);\n+        double [][] yDot = integrator.getEvaluations();\n+        setEventY(equations, integrator, i, yDot, y);\n+    }\n \n-    sanityChecks(equations, t0, y0, t, y);\n-    setEquations(equations);\n-    resetEvaluations();\n-    final boolean forward = t > t0;\n+    private void setEventY(final FirstOrderDifferentialEquations equations,\n+                            final AbstractIntegrator integrator,\n+                            final int i, final double[][] yDot, final double[] y)\n+            throws IntegratorException, DerivativeException {\n+        if (i >= 0) {\n+            // the integration was a success\n+            for (EventHandler handler : handlers) {\n+                EventState ese = ((AbstractEventHandler) handler).getEventState();\n+                if (ese.isOccurred()) {\n+                    // an event has occurred before the end of the integration interval\n+                    final double    eventTime = ese.getEventTime();\n+                    final double[]  eventY    = new double[y.length];\n+                    integrator.setInterpolatedTime(eventTime);\n+                    integrator.getInterpolatedState(eventY);\n+                    ese.stepAccepted(eventTime, eventY);\n+                    final int nb = equations.getDimension();\n+                    double[] y1 = new double[nb];\n+                    equations.computeDerivatives(eventTime, eventY, y1);\n+                    double[] yDot1 = new double[nb];\n+                    for (int j = 0; j < nb; ++j) {\n+                        yDot1[j] = y1[j];\n+                    }\n+                    ese.reset(eventTime, y1);\n+                    for (int j = 0; j < ese.getEventsHandlers().size(); ++j) {\n+                        EventHandler eh = ese.getEventsHandlers().get(j);\n+                        ((AbstractEventHandler) eh).getEventState().reset(eventTime, y1);                     }\n+                    equations.computeDerivatives(eventTime, eventY, yDot[j]);\n+                }\n+            }\n+        } else {\n+            // an integration failure occurred before the end of the integration interval\n+            double h = integrator.getCurrentStepStart();\n+            final double[] yMidDots = new double[equations.getDimension()];\n+            double[] y1 = new double[y.length];\n+            double[] yTmp = (double[]) y.clone();\n+            for (int k = 0; k < y1.length; ++k) {\n+                y1[k] = y[k];\n+                for (int l = 0; l < integrator.getStages(); ++l) {\n+                    y1[k]      += h * integrator.getA(l) * yDot[l][k];\n+                    yMidDots[k] = integrator.getB(l) * yDot[l][k];\n+                }\n+            }\n+            final double[] yDot1 = new double[y.length];\n+            equations.computeDerivatives(integrator.getCurrentSignedStepsize(), y1, yDot1);\n+            if (h > 0) {\n+                for (int k = 0; k < y1.length; ++k) {\n+                    yTmp[k] += h * yMidDots[k];\n+                }\n+            } else {\n+                for (int k = 0; k < y1.length; ++k) {\n+                    yTmp[k] -= h * yMidDots[k];\n+                }\n+            }\n+            equations.computeDerivatives(integrator.getCurrentSignedStepsize(), yTmp, yDot1);\n+            throw new IntegratorException(\"maximal number of iterations reached\" +\n+                                          \"consider increasing the maximal number of iterations\");\n+        }\n+    }\n \n-    // create some internal working arrays\n-    final int stages = c.length + 1;\n-    if (y != y0) {\n-      System.arraycopy(y0, 0, y, 0, y0.length);\n+    private abstract class AbstractEventHandler implements EventHandler {\n+        private final EventState state;\n+\n+        public AbstractEventHandler() {\n+            state = new EventState();\n+        }\n+\n+        protected EventState getEventState() {\n+            return state;\n+        }\n+\n+        @Override\n+        public final double g(final double t, final double[] y) throws DerivativeException {\n+            return state.evaluateStep(t, y);\n+        }\n+\n+        @Override\n+        public final int eventOccurred(final double t, final double[] y, final boolean increasing)\n+        throws DerivativeException {\n+            return state.stepAccepted(t, y) ? 1 : -1;\n+        }\n+\n+        @Override\n+        public final EventHandler.Action eventAction(final double t, final double[] y, final boolean increasing)\n+        throws DerivativeException {\n+            return state.currentState() == EventState.State.FAILED ?\n+                   EventHandler.Action.STOP :\n+                   (state.stop() ? EventHandler.Action.STOP : EventHandler.Action.RESET_STATE);\n+        }\n+\n+        @Override\n+        public abstract void init(final double t0, final double[] y0, final double t);\n     }\n-    final double[][] yDotK = new double[stages][y0.length];\n-    final double[] yTmp = new double[y0.length];\n-\n-    // set up an interpolator sharing the integrator arrays\n-    AbstractStepInterpolator interpolator;\n-    if (requiresDenseOutput() || (! eventsHandlersManager.isEmpty())) {\n-      final RungeKuttaStepInterpolator rki = (RungeKuttaStepInterpolator) prototype.copy();\n-      rki.reinitialize(this, yTmp, yDotK, forward);\n-      interpolator = rki;\n-    } else {\n-      interpolator = new DummyStepInterpolator(yTmp, forward);\n+\n+    private class GlueEventHandler extends AbstractEventHandler {\n+        @Override\n+        public void init(final double t0, final double[] y0, final double t) {\n+            for (EventHandler eventHandler : handlers) {\n+                eventHandler.init(t0, y0, t);\n+            }\n+        }\n     }\n-    interpolator.storeTime(t0);\n-\n-    // set up integration control objects\n-    stepStart         = t0;\n-    double  hNew      = 0;\n-    boolean firstTime = true;\n-    for (StepHandler handler : stepHandlers) {\n-        handler.reset();\n+\n+    private static class DummyStepHandler implements StepHandler {\n+        @Override\n+        public void handleStep(final StepInterpolator interpolator, final boolean isLast) {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void init(final double t0, final double[] y0, final double t) {\n+            // do nothing\n+        }\n+\n+        @Override\n+        public void reset() {\n+            // do nothing\n+        }\n     }\n-    CombinedEventsManager manager = addEndTimeChecker(t0, t, eventsHandlersManager);\n-    boolean lastStep = false;\n \n-    // main integration loop\n-    while (!lastStep) {\n \n-      interpolator.shift();\n+    private interface AbstractIntegrator extends ODEIntegrator {\n+        void setInterpolatedTime(final double time);\n+        void setInterpolatedState(final double[] state);\n+        double getCurrentStepStart();\n+        int getStages();\n+        double getA(int i);\n+        double getB(int i);\n+    }\n \n-      double error = 0;\n-      for (boolean loop = true; loop;) {\n+    private static class DormandPrince54IntegratorWrapper implements AbstractIntegrator {\n \n-        if (firstTime || !fsal) {\n-          // first stage\n-          computeDerivatives(stepStart, y, yDotK[0]);\n+        private final DormandPrince54Integrator impl;\n+        private StepNormalizer normalizer;\n+\n+        DormandPrince54IntegratorWrapper(final double minStep,\n+                                         final double maxStep,\n+                                         final double[] vecAbsoluteTolerance,\n+                                         final double scalarAbsoluteTolerance,\n+                                         final double[] vecRelativeTolerance,\n+                                         final double scalarRelativeTolerance) {\n+            impl = new DormandPrince54Integrator(minStep, maxStep, vecAbsoluteTolerance,\n+                                                 scalarAbsoluteTolerance, vecRelativeTolerance,\n+                                                 scalarRelativeTolerance);\n         }\n \n-        if (firstTime) {\n-          final double[] scale;\n-          if (vecAbsoluteTolerance == null) {\n-              scale = new double[y0.length];\n-              java.util.Arrays.fill(scale, scalAbsoluteTolerance);\n-            } else {\n-              scale = vecAbsoluteTolerance;\n-            }\n-          hNew = initializeStep(equations, forward, getOrder(), scale,\n-                                stepStart, y, yDotK[0], yTmp, yDotK[1]);\n-          firstTime = false;\n+        @Override\n+        public void addEventHandler(final EventHandler eventHandler, final double maxCheckInterval,\n+                                     final double convergence, final int maxIterationCount) {\n+            impl.addEventHandler(eventHandler, maxCheckInterval, convergence, maxIterationCount);\n         }\n \n-        stepSize = hNew;\n+        @Override\n+        public void addEquations(final FirstOrderDifferentialEquations ode, final double[] y0, final double finalTime) {\n+            impl.addEquations(ode, y0, finalTime);\n+        }\n \n-        // next stages\n-        for (int k = 1; k < stages; ++k) {\n+        @Override\n+        public void addStepHandler(final StepHandler handler) {\n+            impl.addStepHandler(handler);\n+            normalizer = new StepNormalizer(1.0, handler);\n+            impl.addStepHandler(normalizer);\n+        }\n \n-          for (int j = 0; j < y0.length; ++j) {\n-            double sum = a[k-1][0] * yDotK[0][j];\n-            for (int l = 1; l < k; ++l) {\n-              sum += a[k-1][l] * yDotK[l][j];\n-            }\n-            yTmp[j] = y[j] + stepSize * sum;\n-          }\n+        @Override\n+        public AbstractIntegrator copy() {\n+            return new DormandPrince54IntegratorWrapper(impl.getMinStep(), impl.getMaxStep(),\n+                                                        impl.getVecAbsoluteTolerance(),\n+                                                        impl.getScalarsAbsoluteTolerance(),\n+                                                        impl.getVecRelativeTolerance(),\n+                                                        impl.getScalarRelativeTolerance());\n+        }\n \n-          computeDerivatives(stepStart + c[k-1] * stepSize, yTmp, yDotK[k]);\n+        @Override\n+        public int getEvaluations() {\n+            return impl.getEvaluations();\n+        }\n \n+        @Override\n+        public double integrate(final FirstOrderDifferentialEquations ode, final double t0, final double[] y0,\n+                                final double t, final double[] y) throws DerivativeException, IntegratorException {\n+            normalizer.reset();\n+            impl.addEventHandler(manager, Double.POSITIVE_INFINITY, 1.0e-12 * (t - t0), maxEvaluations);\n+            return impl.integrate(ode, t0, y0, t, y);\n         }\n \n-        // estimate the state at the end of the step\n-        for (int j = 0; j < y0.length; ++j) {\n-          double sum    = b[0] * yDotK[0][j];\n-          for (int l = 1; l < stages; ++l) {\n-            sum    += b[l] * yDotK[l][j];\n-          }\n-          yTmp[j] = y[j] + stepSize * sum;\n+        @Override\n+        public boolean isLastStep() {\n+            return impl.isLastStep();\n         }\n \n-        // estimate the error at the end of the step\n-        error = estimateError(yDotK, y, yTmp, stepSize);\n-        if (error <= 1.0) {\n-\n-          // discrete events handling\n-          interpolator.storeTime(stepStart + stepSize);\n-          if (manager.evaluateStep(interpolator)) {\n-              final double dt = manager.getEventTime() - stepStart;\n-              if (Math.abs(dt) <= Math.ulp(stepStart)) {\n-                  // rejecting the step would lead to a too small next step, we accept it\n-                  loop = false;\n-              } else {\n-                  // reject the step to match exactly the next switch time\n-                  hNew = dt;\n-              }\n-          } else {\n-            // accept the step\n-            loop = false;\n-          }\n+        @Override\n+        public double getCurrentSignedStepsize() {\n+            return impl.getCurrentSignedStepsize();\n+        }\n \n-        } else {\n-          // reject the step and attempt to reduce error by stepsize control\n-          final double factor =\n-              Math.min(maxGrowth,\n-                       Math.max(minReduction, safety * Math.pow(error, exp)));\n-          hNew = filterStep(stepSize * factor, forward, false);\n+        @Override\n+        public void setInterpolatedTime(final double time) {\n+            impl.setInterpolatedTime(time);\n         }\n \n-      }\n-\n-      // the step has been accepted\n-      final double nextStep = stepStart + stepSize;\n-      System.arraycopy(yTmp, 0, y, 0, y0.length);\n-      manager.stepAccepted(nextStep, y);\n-      lastStep = manager.stop();\n-\n-      // provide the step data to the step handler\n-      interpolator.storeTime(nextStep);\n-      for (StepHandler handler : stepHandlers) {\n-          handler.handleStep(interpolator, lastStep);\n-      }\n-      stepStart = nextStep;\n-\n-      if (fsal) {\n-        // save the last evaluation for the next step\n-        System.arraycopy(yDotK[stages - 1], 0, yDotK[0], 0, y0.length);\n-      }\n-\n-      if (manager.reset(stepStart, y) && ! lastStep) {\n-        // some event handler has triggered changes that\n-        // invalidate the derivatives, we need to recompute them\n-        computeDerivatives(stepStart, y, yDotK[0]);\n-      }\n-\n-      if (! lastStep) {\n-        // in some rare cases we may get here with stepSize = 0, for example\n-        // when an event occurs at integration start, reducing the first step\n-        // to zero; we have to reset the step to some safe non zero value\n-          stepSize = filterStep(stepSize, forward, true);\n-\n-        // stepsize control for next step\n-        final double factor = Math.min(maxGrowth,\n-                                       Math.max(minReduction,\n-                                                safety * Math.pow(error, exp)));\n-        final double  scaledH    = stepSize * factor;\n-        final double  nextT      = stepStart + scaledH;\n-        final boolean nextIsLast = forward ? (nextT >= t) : (nextT <= t);\n-        hNew = filterStep(scaledH, forward, nextIsLast);\n-      }\n+        @Override\n+        public void setInterpolatedState(final double[] state) {\n+            impl.setInterpolatedState(state);\n+        }\n \n-    }\n+        @Override\n+        public double getCurrentStepStart() {\n+            return impl.getCurrentStepStart();\n+        }\n \n-    final double stopTime = stepStart;\n-    resetInternalState();\n-    return stopTime;\n+        @Override\n+        public int getStages() {\n+            return 7;\n+        }\n \n-  }\n+        @Override\n+        public double getA(int i) {\n+            switch (i) {\n+                case 0:\n+                    return 0;\n+                case 1:\n+                    return 1.0 / 5.0;\n+                case 2:\n+                    return 3.0 / 10.0;\n+                case 3:\n+                    return 4.0 / 5.0;\n+                case 4:\n+                    retur\n \n   /** Get the minimal reduction factor for stepsize control.\n    * @return minimal reduction factor",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}