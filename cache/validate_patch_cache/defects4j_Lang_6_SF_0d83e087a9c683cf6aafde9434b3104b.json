{
    "patch": "BUG DESCRIPTION:\nThe issue is with the `translate` method. When an input string has a surrogate pair, `translate` method is not able to escape it properly, which results in `StringIndexOutOfBoundsException` when using `escapeCsv` method.\n\nCODE FIX:\n```\nTo fix the issue, we can modify the `translate` method to check if the character is a surrogate, and if so, convert it to Unicode escape sequence. This can be done by checking if the character is between 0xD800 and 0xDFFF range and writing its Unicode escape sequence using `write` method.\n\nHere is the modified `translate` method:\n\npublic final void translate(CharSequence input, Writer out) throws IOException {\n    if (out == null) {\n        throw new IllegalArgumentException(\"The Writer must not be null\");\n    }\n    if (input == null) {\n        return;\n    }\n    int pos = 0;\n    int len = input.length();\n    while (pos < len) {\n        int consumed = translate(input, pos, out);\n        if (consumed == 0) {\n            char c = input.charAt(pos);\n            if (Character.isHighSurrogate(c) && pos + 1 < len && Character.isLowSurrogate(input.charAt(pos + 1))) {\n                // write Unicode escape sequence for surrogate pair\n                out.write(\"\\\\u\" + String.format(\"%04x\", Character.toCodePoint(c, input.charAt(pos + 1))));\n                pos += 2;\n            } else {\n                out.write(c);\n                pos++;\n            }\n            continue;\n        }\n        for (int pt = 0; pt < consumed; pt++) {\n            pos += Character.charCount(Character.codePointAt(input, pos));\n        }\n    }\n}\n\nWith this fix, the `translate` method will escape surrogate pairs by writing their Unicode escape sequences instead of writing them directly, which will prevent the `StringIndexOutOfBoundsException`.",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\nindex 4d010eaf..4b4a73d5 100644\n--- a/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n+++ b/src/main/java/org/apache/commons/lang3/text/translate/CharSequenceTranslator.java\n@@ -72,30 +72,45 @@ public abstract class CharSequenceTranslator {\n      * @param out Writer to translate the text to\n      * @throws IOException if and only if the Writer produces an IOException\n      */\n-    public final void translate(CharSequence input, Writer out) throws IOException {\n-        if (out == null) {\n-            throw new IllegalArgumentException(\"The Writer must not be null\");\n-        }\n-        if (input == null) {\n-            return;\n-        }\n-        int pos = 0;\n-        int len = input.length();\n-        while (pos < len) {\n-            int consumed = translate(input, pos, out);\n-            if (consumed == 0) {\n-                char[] c = Character.toChars(Character.codePointAt(input, pos));\n+BUG DESCRIPTION:\n+The issue is with the `translate` method. When an input string has a surrogate pair, `translate` method is not able to escape it properly, which results in `StringIndexOutOfBoundsException` when using `escapeCsv` method.\n+\n+CODE FIX:\n+```\n+To fix the issue, we can modify the `translate` method to check if the character is a surrogate, and if so, convert it to Unicode escape sequence. This can be done by checking if the character is between 0xD800 and 0xDFFF range and writing its Unicode escape sequence using `write` method.\n+\n+Here is the modified `translate` method:\n+\n+public final void translate(CharSequence input, Writer out) throws IOException {\n+    if (out == null) {\n+        throw new IllegalArgumentException(\"The Writer must not be null\");\n+    }\n+    if (input == null) {\n+        return;\n+    }\n+    int pos = 0;\n+    int len = input.length();\n+    while (pos < len) {\n+        int consumed = translate(input, pos, out);\n+        if (consumed == 0) {\n+            char c = input.charAt(pos);\n+            if (Character.isHighSurrogate(c) && pos + 1 < len && Character.isLowSurrogate(input.charAt(pos + 1))) {\n+                // write Unicode escape sequence for surrogate pair\n+                out.write(\"\\\\u\" + String.format(\"%04x\", Character.toCodePoint(c, input.charAt(pos + 1))));\n+                pos += 2;\n+            } else {\n                 out.write(c);\n-                pos+= c.length;\n-                continue;\n-            }\n-//          // contract with translators is that they have to understand codepoints \n-//          // and they just took care of a surrogate pair\n-            for (int pt = 0; pt < consumed; pt++) {\n-                pos += Character.charCount(Character.codePointAt(input, pos));\n+                pos++;\n             }\n+            continue;\n+        }\n+        for (int pt = 0; pt < consumed; pt++) {\n+            pos += Character.charCount(Character.codePointAt(input, pos));\n         }\n     }\n+}\n+\n+With this fix, the `translate` method will escape surrogate pairs by writing their Unicode escape sequences instead of writing them directly, which will prevent the `StringIndexOutOfBoundsException`.\n \n     /**\n      * Helper method to create a merger of this translator with another set of ",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}