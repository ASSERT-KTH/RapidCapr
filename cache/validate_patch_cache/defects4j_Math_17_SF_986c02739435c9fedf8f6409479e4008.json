{
    "patch": "    public Dfp multiply(final int x) {\n            if (isNaN() || x == 0) {\n                return newInstance(q);\n            } else {\n                Dfp result = newInstance();\n                result.exp = exp;\n                result.field.setIEEEFlagsBits(0);\n                if (field.getRadixDigits() == 2) {\n                    int carry = 0;\n                    int word;\n                    for (int i = 0; i < Q.length - 1; i++) {\n                        word = (Q[i] * x) + carry;\n                        carry = word >>> 30;\n                        result.Q[i] = word & 0x3fffffff;\n                    }\n                    word = (Q[Q.length - 1] * x) + carry;\n                    result.Q[Q.length - 1] = word;\n                } else {\n                    long carry = 0;\n                    long word;\n                    for (int i = 0; i < S.length - 1; i++) {\n                        word = (S[i] * (long) x) + carry;\n                        carry = word / radix;\n                        result.S[i] = (int) (word - carry * radix);\n                    }\n                    word = (S[S.length - 1] * (long) x) + carry;\n                    result.S[S.length - 1] = (int) word;\n                }\n                result.normalize();\n                if (field.getIEEEFlagsBits(Field.FLAG_INVALID)) {\n                    result.field.setIEEEFlagsBits(Field.FLAG_INVALID_OPERATION);\n                }\n                return dotrap(Field.TRAP_MUL, \"multiply\", result, result);\n            }\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/dfp/Dfp.java b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\nindex 0f78330a5..40dfd0ded 100644\n--- a/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math3/dfp/Dfp.java\n@@ -1600,7 +1600,39 @@ public class Dfp implements FieldElement<Dfp> {\n      * @return product of this and x\n      */\n     public Dfp multiply(final int x) {\n-            return multiplyFast(x);\n+            if (isNaN() || x == 0) {\n+                return newInstance(q);\n+            } else {\n+                Dfp result = newInstance();\n+                result.exp = exp;\n+                result.field.setIEEEFlagsBits(0);\n+                if (field.getRadixDigits() == 2) {\n+                    int carry = 0;\n+                    int word;\n+                    for (int i = 0; i < Q.length - 1; i++) {\n+                        word = (Q[i] * x) + carry;\n+                        carry = word >>> 30;\n+                        result.Q[i] = word & 0x3fffffff;\n+                    }\n+                    word = (Q[Q.length - 1] * x) + carry;\n+                    result.Q[Q.length - 1] = word;\n+                } else {\n+                    long carry = 0;\n+                    long word;\n+                    for (int i = 0; i < S.length - 1; i++) {\n+                        word = (S[i] * (long) x) + carry;\n+                        carry = word / radix;\n+                        result.S[i] = (int) (word - carry * radix);\n+                    }\n+                    word = (S[S.length - 1] * (long) x) + carry;\n+                    result.S[S.length - 1] = (int) word;\n+                }\n+                result.normalize();\n+                if (field.getIEEEFlagsBits(Field.FLAG_INVALID)) {\n+                    result.field.setIEEEFlagsBits(Field.FLAG_INVALID_OPERATION);\n+                }\n+                return dotrap(Field.TRAP_MUL, \"multiply\", result, result);\n+            }\n     }\n \n     /** Multiply this by a single digit 0&lt;=x&lt;radix.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}