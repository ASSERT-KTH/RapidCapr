{
    "patch": "        return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);\n\n      // Arithmetic operators are only valid if both children are numbers.\n      case Token.ADD:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n      case Token.MOD:\n        Node first = val.getFirstChild();\n        Node last = val.getLastChild();\n        if (first == null || last == null) {\n          return false;\n        }\n        boolean left = isValidDefineValue(first, defines);\n        boolean right = isValidDefineValue(last, defines);\n        if (left && right) {\n          return NodeUtil.isLiteral(first) && NodeUtil.isLiteral(last);\n        }\n        return false;\n\n      // Comparison operators are only valid if both children are numbers or strings.\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n        Node firstOperand = val.getFirstChild();\n        Node secondOperand = firstOperand.getNext();\n        if (firstOperand == null || secondOperand == null) {\n          return false;\n        }\n        boolean leftOperandIsValid = isValidDefineValue(firstOperand, defines);\n        boolean rightOperandIsValid = isValidDefineValue(secondOperand, defines);\n        if (!leftOperandIsValid || !rightOperandIsValid) {\n          return false;\n        }\n        return NodeUtil.isLiteral(firstOperand) && NodeUtil.isLiteral(secondOperand);\n\n      // Unary operators are valid if the child is valid.\n      case Token.NOT:\n      case Token.NEG:\n        return isValidDefineValue(val.getFirstChild(), defines);\n\n      // Names are valid if and only if they are defines themselves.\n      case Token.NAME:\n      case Token.GETPROP:\n        if (val.isQualifiedName()) {\n          return defines.contains(val.getQualifiedName());\n        }\n    }\n    return false;\n  }\n  ```\n4. ```java\n  static boolean isValidDefineValue(Node val, Set<String> defines) {\n    switch (val.getType()) {\n      case Token.STRING:\n      case Token.NUMBER:\n      case Token.TRUE:\n      case Token.FALSE:\n        return true;\n      case Token.BITAND:\n      case Token.BITNOT:\n      case Token.BITOR:\n      case Token.BITXOR:\n        return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);\n      case Token.ADD:\n      case Token.SUB:\n      case Token.MUL:\n      case Token.DIV:\n      case Token.MOD:\n      case Token.LSH:\n      case Token.RSH:\n      case Token.URSH:\n      case Token.LT:\n      case Token.LE:\n      case Token.GT:\n      case Token.GE:\n      case Token.EQ:\n      case Token.NE:\n        Node left = val.getFirstChild();\n        Node right = val.getLastChild();\n        if (left == null || right == null) {\n          return false;\n        }\n        boolean leftVal = isValidDefineValue(left, defines);\n        boolean rightVal = isValidDefineValue(right, defines);\n        // Check for arithmetic operations.\n        if (val.getType() == Token.ADD || val.getType() == Token.SUB || val.getType() == Token.MUL ||\n            val.getType() == Token.DIV || val.getType() == Token.MOD) {\n          return leftVal && rightVal && NodeUtil.isNumericResult(left, right);\n        }\n        // Check for bitwise operations.\n        else if (val.getType() == Token.BITAND || val.getType() == Token.BITOR || val.getType() == Token.BITXOR ||\n                 val.getType() == Token.LSH || val.getType() == Token.RSH || val.getType() == Token.URSH) {\n          return leftVal && rightVal && NodeUtil.isBitwiseable(left, right);\n        }\n        // Check for comparison operations.\n        else if (val.getType() == Token.EQ || val.getType() == Token.NE || val.getType() == Token.LT ||\n                 val.getType() == Token.LE || val.getType() == Token.GT || val.getType() == Token.GE) {\n          return leftVal && rightVal && NodeUtil.isComparable(left, right);\n        }\n        return false;\n\n      // Unary operators are valid if the child is valid.",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/NodeUtil.java b/src/com/google/javascript/jscomp/NodeUtil.java\nindex a31b17a2..dac445a3 100644\n--- a/src/com/google/javascript/jscomp/NodeUtil.java\n+++ b/src/com/google/javascript/jscomp/NodeUtil.java\n@@ -317,21 +317,49 @@ public final class NodeUtil {\n    * @param val The value being assigned.\n    * @param defines The list of names of existing defines.\n    */\n-  static boolean isValidDefineValue(Node val, Set<String> defines) {\n-    switch (val.getType()) {\n-      case Token.STRING:\n-      case Token.NUMBER:\n-      case Token.TRUE:\n-      case Token.FALSE:\n-        return true;\n+        return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);\n \n-      // Binary operators are only valid if both children are valid.\n-      case Token.BITAND:\n-      case Token.BITNOT:\n-      case Token.BITOR:\n-      case Token.BITXOR:\n+      // Arithmetic operators are only valid if both children are numbers.\n+      case Token.ADD:\n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.DIV:\n+      case Token.MOD:\n+        Node first = val.getFirstChild();\n+        Node last = val.getLastChild();\n+        if (first == null || last == null) {\n+          return false;\n+        }\n+        boolean left = isValidDefineValue(first, defines);\n+        boolean right = isValidDefineValue(last, defines);\n+        if (left && right) {\n+          return NodeUtil.isLiteral(first) && NodeUtil.isLiteral(last);\n+        }\n+        return false;\n+\n+      // Comparison operators are only valid if both children are numbers or strings.\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.LT:\n+      case Token.LE:\n+      case Token.GT:\n+      case Token.GE:\n+      case Token.EQ:\n+      case Token.NE:\n+        Node firstOperand = val.getFirstChild();\n+        Node secondOperand = firstOperand.getNext();\n+        if (firstOperand == null || secondOperand == null) {\n+          return false;\n+        }\n+        boolean leftOperandIsValid = isValidDefineValue(firstOperand, defines);\n+        boolean rightOperandIsValid = isValidDefineValue(secondOperand, defines);\n+        if (!leftOperandIsValid || !rightOperandIsValid) {\n+          return false;\n+        }\n+        return NodeUtil.isLiteral(firstOperand) && NodeUtil.isLiteral(secondOperand);\n \n-      // Uniary operators are valid if the child is valid.\n+      // Unary operators are valid if the child is valid.\n       case Token.NOT:\n       case Token.NEG:\n         return isValidDefineValue(val.getFirstChild(), defines);\n@@ -345,6 +373,59 @@ public final class NodeUtil {\n     }\n     return false;\n   }\n+  ```\n+4. ```java\n+  static boolean isValidDefineValue(Node val, Set<String> defines) {\n+    switch (val.getType()) {\n+      case Token.STRING:\n+      case Token.NUMBER:\n+      case Token.TRUE:\n+      case Token.FALSE:\n+        return true;\n+      case Token.BITAND:\n+      case Token.BITNOT:\n+      case Token.BITOR:\n+      case Token.BITXOR:\n+        return isValidDefineValue(val.getFirstChild(), defines) && isValidDefineValue(val.getLastChild(), defines);\n+      case Token.ADD:\n+      case Token.SUB:\n+      case Token.MUL:\n+      case Token.DIV:\n+      case Token.MOD:\n+      case Token.LSH:\n+      case Token.RSH:\n+      case Token.URSH:\n+      case Token.LT:\n+      case Token.LE:\n+      case Token.GT:\n+      case Token.GE:\n+      case Token.EQ:\n+      case Token.NE:\n+        Node left = val.getFirstChild();\n+        Node right = val.getLastChild();\n+        if (left == null || right == null) {\n+          return false;\n+        }\n+        boolean leftVal = isValidDefineValue(left, defines);\n+        boolean rightVal = isValidDefineValue(right, defines);\n+        // Check for arithmetic operations.\n+        if (val.getType() == Token.ADD || val.getType() == Token.SUB || val.getType() == Token.MUL ||\n+            val.getType() == Token.DIV || val.getType() == Token.MOD) {\n+          return leftVal && rightVal && NodeUtil.isNumericResult(left, right);\n+        }\n+        // Check for bitwise operations.\n+        else if (val.getType() == Token.BITAND || val.getType() == Token.BITOR || val.getType() == Token.BITXOR ||\n+                 val.getType() == Token.LSH || val.getType() == Token.RSH || val.getType() == Token.URSH) {\n+          return leftVal && rightVal && NodeUtil.isBitwiseable(left, right);\n+        }\n+        // Check for comparison operations.\n+        else if (val.getType() == Token.EQ || val.getType() == Token.NE || val.getType() == Token.LT ||\n+                 val.getType() == Token.LE || val.getType() == Token.GT || val.getType() == Token.GE) {\n+          return leftVal && rightVal && NodeUtil.isComparable(left, right);\n+        }\n+        return false;\n+\n+      // Unary operators are valid if the child is valid.\n \n   /**\n    * Returns whether this a BLOCK node with no children.",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}