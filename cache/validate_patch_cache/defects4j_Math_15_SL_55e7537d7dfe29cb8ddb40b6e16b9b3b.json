{
    "patch": "        if (Math.abs(y) >= TWO_POWER_52 || Math.abs(y - Math.rint(y)) > 0.00001) {",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/util/FastMath.java b/src/main/java/org/apache/commons/math3/util/FastMath.java\nindex d57132592..9994d4090 100644\n--- a/src/main/java/org/apache/commons/math3/util/FastMath.java\n+++ b/src/main/java/org/apache/commons/math3/util/FastMath.java\n@@ -305,165 +305,165 @@ public class FastMath {\n     private static final long HEX_40000000 = 0x40000000L; // 1073741824L\n \n     /** Mask used to clear low order 30 bits */\n-    private static final long MASK_30BITS = -1L - (HEX_40000000 -1); // 0xFFFFFFFFC0000000L;\n-\n-    /** 2^52 - double numbers this large must be integral (no fraction) or NaN or Infinite */\n-    private static final double TWO_POWER_52 = 4503599627370496.0;\n-    /** 2^53 - double numbers this large must be even. */\n-\n-    /** Constant: {@value}. */\n-    private static final double F_1_3 = 1d / 3d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_5 = 1d / 5d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_7 = 1d / 7d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_9 = 1d / 9d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_11 = 1d / 11d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_13 = 1d / 13d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_15 = 1d / 15d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_17 = 1d / 17d;\n-    /** Constant: {@value}. */\n-    private static final double F_3_4 = 3d / 4d;\n-    /** Constant: {@value}. */\n-    private static final double F_15_16 = 15d / 16d;\n-    /** Constant: {@value}. */\n-    private static final double F_13_14 = 13d / 14d;\n-    /** Constant: {@value}. */\n-    private static final double F_11_12 = 11d / 12d;\n-    /** Constant: {@value}. */\n-    private static final double F_9_10 = 9d / 10d;\n-    /** Constant: {@value}. */\n-    private static final double F_7_8 = 7d / 8d;\n-    /** Constant: {@value}. */\n-    private static final double F_5_6 = 5d / 6d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_2 = 1d / 2d;\n-    /** Constant: {@value}. */\n-    private static final double F_1_4 = 1d / 4d;\n+    public static double pow(double x, double y) {\n+        final double lns[] = new double[2];\n \n-    /**\n-     * Private Constructor\n-     */\n-    private FastMath() {}\n+        if (y == 0.0) {\n+            return 1.0;\n+        }\n \n-    // Generic helper methods\n+        if (x != x) { // X is NaN\n+            return x;\n+        }\n \n-    /**\n-     * Get the high order bits from the mantissa.\n-     * Equivalent to adding and subtracting HEX_40000 but also works for very large numbers\n-     *\n-     * @param d the value to split\n-     * @return the high order part of the mantissa\n-     */\n-    private static double doubleHighPart(double d) {\n-        if (d > -Precision.SAFE_MIN && d < Precision.SAFE_MIN){\n-            return d; // These are un-normalised - don't try to convert\n+\n+        if (x == 0) {\n+            long bits = Double.doubleToLongBits(x);\n+            if ((bits & 0x8000000000000000L) != 0) {\n+                // -zero\n+                long yi = (long) y;\n+\n+                if (y < 0 && y == yi && (yi & 1) == 1) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n+\n+                if (y > 0 && y == yi && (yi & 1) == 1) {\n+                    return -0.0;\n+                }\n+            }\n+\n+            if (y < 0) {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+            if (y > 0) {\n+                return 0.0;\n+            }\n+\n+            return Double.NaN;\n         }\n-        long xl = Double.doubleToLongBits(d);\n-        xl = xl & MASK_30BITS; // Drop low order bits\n-        return Double.longBitsToDouble(xl);\n-    }\n \n-    /** Compute the square root of a number.\n-     * <p><b>Note:</b> this implementation currently delegates to {@link Math#sqrt}\n-     * @param a number on which evaluation is done\n-     * @return square root of a\n-     */\n-    public static double sqrt(final double a) {\n-        return Math.sqrt(a);\n-    }\n+        if (x == Double.POSITIVE_INFINITY) {\n+            if (y != y) { // y is NaN\n+                return y;\n+            }\n+            if (y < 0.0) {\n+                return 0.0;\n+            } else {\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n \n-    /** Compute the hyperbolic cosine of a number.\n-     * @param x number on which evaluation is done\n-     * @return hyperbolic cosine of x\n-     */\n-    public static double cosh(double x) {\n-      if (x != x) {\n-          return x;\n-      }\n+        if (y == Double.POSITIVE_INFINITY) {\n+            if (x * x == 1.0) {\n+                return Double.NaN;\n+            }\n \n-      // cosh[z] = (exp(z) + exp(-z))/2\n+            if (x * x > 1.0) {\n+                return Double.POSITIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n \n-      // for numbers with magnitude 20 or so,\n-      // exp(-z) can be ignored in comparison with exp(z)\n+        if (x == Double.NEGATIVE_INFINITY) {\n+            if (y != y) { // y is NaN\n+                return y;\n+            }\n \n-      if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n-              // Avoid overflow (MATH-905).\n-              final double t = exp(0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n-              return 0.5 * exp(x);\n-          }\n-      } else if (x < -20) {\n-          if (x <= -LOG_MAX_VALUE) {\n-              // Avoid overflow (MATH-905).\n-              final double t = exp(-0.5 * x);\n-              return (0.5 * t) * t;\n-          } else {\n-              return 0.5 * exp(-x);\n-          }\n-      }\n+            if (y < 0) {\n+                long yi = (long) y;\n+                if (y == yi && (yi & 1) == 1) {\n+                    return -0.0;\n+                }\n \n-      final double hiPrec[] = new double[2];\n-      if (x < 0.0) {\n-          x = -x;\n-      }\n-      exp(x, 0.0, hiPrec);\n-\n-      double ya = hiPrec[0] + hiPrec[1];\n-      double yb = -(ya - hiPrec[0] - hiPrec[1]);\n-\n-      double temp = ya * HEX_40000000;\n-      double yaa = ya + temp - temp;\n-      double yab = ya - yaa;\n-\n-      // recip = 1/y\n-      double recip = 1.0/ya;\n-      temp = recip * HEX_40000000;\n-      double recipa = recip + temp - temp;\n-      double recipb = recip - recipa;\n-\n-      // Correct for rounding in division\n-      recipb += (1.0 - yaa*recipa - yaa*recipb - yab*recipa - yab*recipb) * recip;\n-      // Account for yb\n-      recipb += -yb * recip * recip;\n-\n-      // y = y + 1/y\n-      temp = ya + recipa;\n-      yb += -(temp - ya - recipa);\n-      ya = temp;\n-      temp = ya + recipb;\n-      yb += -(temp - ya - recipb);\n-      ya = temp;\n-\n-      double result = ya + yb;\n-      result *= 0.5;\n-      return result;\n-    }\n+                return 0.0;\n+            }\n \n-    /** Compute the hyperbolic sine of a number.\n-     * @param x number on which evaluation is done\n-     * @return hyperbolic sine of x\n-     */\n-    public static double sinh(double x) {\n-      boolean negate = false;\n-      if (x != x) {\n-          return x;\n-      }\n+            if (y > 0)  {\n+                long yi = (long) y;\n+                if (y == yi && (yi & 1) == 1) {\n+                    return Double.NEGATIVE_INFINITY;\n+                }\n+\n+                return Double.POSITIVE_INFINITY;\n+            }\n+        }\n+\n+        if (y == Double.NEGATIVE_INFINITY) {\n+\n+            if (x * x == 1.0) {\n+                return Double.NaN;\n+            }\n \n-      // sinh[z] = (exp(z) - exp(-z) / 2\n+            if (x * x < 1.0) {\n+                return Double.POSITIVE_INFINITY;\n+            } else {\n+                return 0.0;\n+            }\n+        }\n \n-      // for values of z larger than about 20,\n-      // exp(-z) can be ignored in comparison with exp(z)\n+        /* Handle special case x<0 */\n+        if (x < 0) {\n+            // y is an even integer in this case\n+        if (Math.abs(y) >= TWO_POWER_52 || Math.abs(y - Math.rint(y)) > 0.00001) {\n+                return pow(-x, y);\n+            }\n \n-      if (x > 20) {\n-          if (x >= LOG_MAX_VALUE) {\n+            if (y == (long) y) {\n+                // If y is an integer\n+                return ((long)y & 1) == 0 ? pow(-x, y) : -pow(-x, y);\n+            } else {\n+                return Double.NaN;\n+            }\n+        }\n+\n+        /* Split y into ya and yb such that y = ya+yb */\n+        double ya;\n+        double yb;\n+        if (y < 8e298 && y > -8e298) {\n+            double tmp1 = y * HEX_40000000;\n+            ya = y + tmp1 - tmp1;\n+            yb = y - ya;\n+        } else {\n+            double tmp1 = y * 9.31322574615478515625E-10;\n+            double tmp2 = tmp1 * 9.31322574615478515625E-10;\n+            ya = (tmp1 + tmp2 - tmp1) * HEX_40000000 * HEX_40000000;\n+            yb = y - ya;\n+        }\n+\n+        /* Compute ln(x) */\n+        final double lores = log(x, lns);\n+        if (Double.isInfinite(lores)){ // don't allow this to be converted to NaN\n+            return lores;\n+        }\n+\n+        double lna = lns[0];\n+        double lnb = lns[1];\n+\n+        /* resplit lns */\n+        double tmp1 = lna * HEX_40000000;\n+        double tmp2 = lna + tmp1 - tmp1;\n+        lnb += lna - tmp2;\n+        lna = tmp2;\n+\n+        // y*ln(x) = (aa+ab)\n+        final double aa = lna * ya;\n+        final double ab = lna * yb + lnb * ya + lnb * yb;\n+\n+        lna = aa+ab;\n+        lnb = -(lna - aa - ab);\n+\n+        double z = 1.0 / 120.0;\n+        z = z * lnb + (1.0 / 24.0);\n+        z = z * lnb + (1.0 / 6.0);\n+        z = z * lnb + 0.5;\n+        z = z * lnb + 1.0;\n+        z = z * lnb;\n+\n+        final double result = exp(lna, z, null);\n+        //result = result + result * z;\n+        return result;\n+    }\n               // Avoid overflow (MATH-905).\n               final double t = exp(0.5 * x);\n               return (0.5 * t) * t;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}