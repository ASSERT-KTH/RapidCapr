{
    "patch": "private void guessAOmega() {\n    double sx2 = 0, sy2 = 0, sxy = 0, sxz = 0, syz = 0;\n    double x0 = observations[0].getX(), y0 = observations[0].getY();\n    double f2Integral = 0, fPrime2Integral = 0;\n\n    for (int i = 1; i < observations.length; ++i) {\n        double xi = observations[i].getX(), yi = observations[i].getY();\n        double dx = xi - x0, dy = yi - y0;\n\n        double f2IntegralStep = dx / 3 * (y0 * y0 + y0 * yi + yi * yi);\n        double fPrime2IntegralStep = dy * dy / dx;\n\n        double x = xi - x0;\n        f2Integral += f2IntegralStep;\n        fPrime2Integral += fPrime2IntegralStep;\n\n        sx2 += x * x;\n        sy2 += f2Integral * f2Integral;\n        sxy += x * f2Integral;\n        sxz += x * fPrime2Integral;\n        syz += f2Integral * fPrime2Integral;\n\n        x0 = xi;\n        y0 = yi;\n    }\n    double d1 = sy2 * sxz - sxy * syz;\n    double d2 = sxy * sxz - sx2 * syz;\n    double d3 = sx2 * sy2 - sxy * sxy;\n\n    if ((d2 < 0) || ((d1 / d2) < 0) || ((d2 / d3) < 0)) {\n        final int last = observations.length - 1;\n        final double xRange = observations[last].getX() - observations[0].getX();\n        if (xRange == 0) {\n            throw new ZeroException();\n        }\n        omega = 2 * Math.PI / xRange;\n\n        double yMin = Double.POSITIVE_INFINITY;\n        double yMax = Double.NEGATIVE_INFINITY;\n        for (int i = 1; i < observations.length; ++i) {\n            final double y = observations[i].getY();\n            if (y < yMin) {\n                yMin = y;\n            }\n            if (y > yMax) {\n                yMax = y;\n            }\n        }\n        a = 0.5 * (yMax - yMin);\n    } else {\n        a = Math.sqrt(d1 / d2);\n        omega = Math.sqrt(d2 / d3);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex 1da2c454e..df6e9149a 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -254,79 +254,60 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n          * @throws MathIllegalStateException when the guessing procedure cannot\n          * produce sensible results.\n          */\n-        private void guessAOmega() {\n-            // initialize the sums for the linear model between the two integrals\n-            double sx2 = 0;\n-            double sy2 = 0;\n-            double sxy = 0;\n-            double sxz = 0;\n-            double syz = 0;\n+private void guessAOmega() {\n+    double sx2 = 0, sy2 = 0, sxy = 0, sxz = 0, syz = 0;\n+    double x0 = observations[0].getX(), y0 = observations[0].getY();\n+    double f2Integral = 0, fPrime2Integral = 0;\n \n-            double currentX = observations[0].getX();\n-            double currentY = observations[0].getY();\n-            double f2Integral = 0;\n-            double fPrime2Integral = 0;\n-            final double startX = currentX;\n-            for (int i = 1; i < observations.length; ++i) {\n-                // one step forward\n-                final double previousX = currentX;\n-                final double previousY = currentY;\n-                currentX = observations[i].getX();\n-                currentY = observations[i].getY();\n+    for (int i = 1; i < observations.length; ++i) {\n+        double xi = observations[i].getX(), yi = observations[i].getY();\n+        double dx = xi - x0, dy = yi - y0;\n \n-                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n-                // considering a linear model for f (and therefore constant f')\n-                final double dx = currentX - previousX;\n-                final double dy = currentY - previousY;\n-                final double f2StepIntegral =\n-                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n-                final double fPrime2StepIntegral = dy * dy / dx;\n+        double f2IntegralStep = dx / 3 * (y0 * y0 + y0 * yi + yi * yi);\n+        double fPrime2IntegralStep = dy * dy / dx;\n \n-                final double x = currentX - startX;\n-                f2Integral += f2StepIntegral;\n-                fPrime2Integral += fPrime2StepIntegral;\n+        double x = xi - x0;\n+        f2Integral += f2IntegralStep;\n+        fPrime2Integral += fPrime2IntegralStep;\n \n-                sx2 += x * x;\n-                sy2 += f2Integral * f2Integral;\n-                sxy += x * f2Integral;\n-                sxz += x * fPrime2Integral;\n-                syz += f2Integral * fPrime2Integral;\n-            }\n+        sx2 += x * x;\n+        sy2 += f2Integral * f2Integral;\n+        sxy += x * f2Integral;\n+        sxz += x * fPrime2Integral;\n+        syz += f2Integral * fPrime2Integral;\n \n-            // compute the amplitude and pulsation coefficients\n-            double c1 = sy2 * sxz - sxy * syz;\n-            double c2 = sxy * sxz - sx2 * syz;\n-            double c3 = sx2 * sy2 - sxy * sxy;\n-            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n-                final int last = observations.length - 1;\n-                // Range of the observations, assuming that the\n-                // observations are sorted.\n-                final double xRange = observations[last].getX() - observations[0].getX();\n-                if (xRange == 0) {\n-                    throw new ZeroException();\n-                }\n-                omega = 2 * Math.PI / xRange;\n+        x0 = xi;\n+        y0 = yi;\n+    }\n+    double d1 = sy2 * sxz - sxy * syz;\n+    double d2 = sxy * sxz - sx2 * syz;\n+    double d3 = sx2 * sy2 - sxy * sxy;\n \n-                double yMin = Double.POSITIVE_INFINITY;\n-                double yMax = Double.NEGATIVE_INFINITY;\n-                for (int i = 1; i < observations.length; ++i) {\n-                    final double y = observations[i].getY();\n-                    if (y < yMin) {\n-                        yMin = y;\n-                    }\n-                    if (y > yMax) {\n-                        yMax = y;\n-                    }\n-                }\n-                a = 0.5 * (yMax - yMin);\n-            } else {\n-                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n-                    // procedure cannot produce sensible results.\n+    if ((d2 < 0) || ((d1 / d2) < 0) || ((d2 / d3) < 0)) {\n+        final int last = observations.length - 1;\n+        final double xRange = observations[last].getX() - observations[0].getX();\n+        if (xRange == 0) {\n+            throw new ZeroException();\n+        }\n+        omega = 2 * Math.PI / xRange;\n \n-                a = FastMath.sqrt(c1 / c2);\n-                omega = FastMath.sqrt(c2 / c3);\n+        double yMin = Double.POSITIVE_INFINITY;\n+        double yMax = Double.NEGATIVE_INFINITY;\n+        for (int i = 1; i < observations.length; ++i) {\n+            final double y = observations[i].getY();\n+            if (y < yMin) {\n+                yMin = y;\n+            }\n+            if (y > yMax) {\n+                yMax = y;\n             }\n         }\n+        a = 0.5 * (yMax - yMin);\n+    } else {\n+        a = Math.sqrt(d1 / d2);\n+        omega = Math.sqrt(d2 / d3);\n+    }\n+}\n \n         /**\n          * Estimate a first guess of the phase.",
    "result_reason": "junit.framework.AssertionFailedError: expected:<0.2> but was:<0.01567075651453813>",
    "test_result": "FAIL"
}