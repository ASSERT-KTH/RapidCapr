{
    "patch": "class TransformDispatcher implements IRFactory.TypeSafeDispatcher {\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n  private final Set<String> allowedDirectives;\n\n  TransformDispatcher(ErrorReporter reporter, String sourceName) {\n    this.errorReporter = reporter;\n    this.sourceName = sourceName;\n    this.allowedDirectives = ImmutableSet.of(\n        \"use strict\",\n        \"use asm\",\n        \"use strict class\");\n    }\n\n  @Override\n  public Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(Token.EXPR_RESULT);\n    node.addChildToBack(transform(statementNode.getExpression()));\n    if (isDirective(statementNode.getExpression())) {\n      node.putBooleanProp(Node.DIRECTIVE_PROP, true);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processBlock(Block blockNode) {\n    return processGenericBlock(blockNode);\n  }\n\n  @Override\n  public Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\",\n          sourceName,\n          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  public Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  public Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n  }\n\n  @Override\n  public Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n  }\n\n  @Override\n  public Node processEmptyExpression(EmptyExpression exprNode) {\n    return newNode(Token.EMPTY);\n  }\n\n  @Override\n  public Node processForInLoop(ForInLoop loopNode) {\n    Node lhs;\n    if (loopNode.getIterator() instanceof DestructuringForm) {\n      checkForViolation(\n          Parser.Config.StrictMode.under((Node) loopNode),\n          ((DestructuringForm) loopNode.getIterator()).getLeft());\n      lhs = transform(loopNode.getIterator());\n    } else {\n      AstNode nameNode = loopNode.getIterator();\n      if (nameNode.getType() == Token.LET) {\n        nameNode.setType(Token.NAME);\n      }\n      Node varNode = newNode(Token.VAR, transform(nameNode));\n      lhs = newNode(Token.NAME, nameNode.getString());\n      varNode.putProp(Node.IS_LOOKUP_VAR, Node.TRUE);\n      varNode.putProp(Node.IS_BLOCK_SCOPED_VAR, Node.TRUE);\n      varNode.addChildToFront(lhs);\n      varNode.addChildToBack(newNode(Node.EMPTY));\n      lhs = varNode;\n    }\n    Node obj = transform(loopNode.getIteratedObject());\n    Node forNode = newNode(Token.FOR, lhs, obj, transformBlock(loopNode.getBody()));\n    return forNode;\n  }\n\n  @Override\n  public Node processForLoop(ForLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getInitializer()),\n        transform(loopNode.getCondition()),\n        transform(loopNode.getIncrement()),\n        transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processFunctionCall(FunctionCall callNode) {\n    Node n = newNode(Token.CALL, transform(callNode.getTarget()));\n    if (callNode.getArguments().size() > 0) {\n      List<AstNode> argNodes = callNode.getArguments();\n      for (AstNode argNode : argNodes) {\n        Node arg = transform(argNode);\n        if (argNode.isSpreadable()) {\n          arg.putBooleanProp(Node.SPREADS, true);\n        }\n        n.addChildToBack(arg);\n      }\n    }\n    return n;\n  }\n\n  @Override\n  public Node processFunctionNode(FunctionNode functionNode) {\n    checkForFunctionRedefinition(functionNode);\n    return newNode(Token.FUNCTION, IR.name(functionNode.getName()), transform(functionNode.getParams()), transform(functionNode.getBody()));\n  }\n\n  @Override\n  public Node processIfStatement(IfStatement statementNode) {\n    if (statementNode.getElsePart() != null) {\n      return newNode(\n          Token.IF,\n          transform(statementNode.getCondition()),\n          transform(statementNode.getThenPart()),\n          transform(statementNode.getElsePart()));\n    } else {\n      return newNode(\n          Token.IF,\n          transform(statementNode.getCondition()),\n          transform(statementNode.getThenPart()));\n    }\n  }\n\n  @Override\n  public Node processLabeledStatement(LabeledStatement statementNode) {\n    Node node = newNode(Token.LABEL);\n    node.addChildToBack(transform(statementNode.getStatement()));\n    node.addChildToBack(IR.labelName(statementNode.getLabelName()));\n    return node;\n  }\n\n  @Override\n  public Node processLetNode(LetNode letNode) {\n    Scope scope = letNode.getScope();\n    if (!scope.isDeclaredLocally(letNode.getIdentifier())) {\n      Symbol symbol = scope.getSymbol(letNode.getIdentifier());\n      Node stringBuilder = newQuotedString(symbol.getName());\n      stringBuilder.addChildToBack(transform(letNode.getInitialValue()));\n      stringBuilder.putProp(Node.MUST_GEN_SYMBOL, true);\n      letNode.setInitialValue(null);\n      letNode.setIdentifier(Symbol.createPrivateName());\n      return newNode(Token.EXPR_RESULT, createAssignment(Token.ASSIGN, IR.name(letNode.getIdentifier()), stringBuilder));\n    }\n    Node node = IR.let(IR.name(letNode.getIdentifier()), transform(letNode.getInitialValue()));\n    node.setLineno(letNode.getLineno());\n    node.setCharno(letNode.getCharno());\n    return node;\n  }\n\n  @Override\n  public Node processName(Name nameNode) {\n    int type = transformTokenType(Token.NAME);\n    if (TokenStream.isJSKeyword(nameNode.getIdentifier())) {\n      type = Token.STRING;\n    }\n    Node n = IR.name(nameNode.getIdentifier());\n    n.setType(type);\n    n.setScope(nameNode.getScope());\n    n.putProp(Node.IS_CONSTANT_NAME, nameNode.getIdentifier().equals(\"Infinity\") || nameNode.getIdentifier().equals(\"NaN\"));\n    return n;\n  }\n\n  @Override\n  public Node processNewExpression(NewExpression callNode) {\n    return newNode(Token.NEW, transform(callNode.getTarget()));\n  }\n\n  @Override\n  public Node processNumberLiteral(NumberLiteral numberNode) {\n    return newNode(Token.NUMBER, numberNode.getNumber());\n  }\n\n  @Override\n  public Node processObjectLiteral(ObjectLiteral objectNode) {\n    Node result = newNode(Token.OBJECTLIT);\n    for (ObjectProperty propNode : objectNode.getElements()) {\n      switch (propNode.getType()) {\n        case ObjectProperty.TYPE_NORMAL:\n          AstNode left = propNode.getLeft();\n          int memberType = Token.OBJECTLIT;\n          if (propNode.isGetter()) {\n            memberType = Token.GETTER_DEF;\n          } else if (propNode.isSetter()) {\n            memberType = Token.SETTER_DEF;\n          }\n\n          AstNode right = propNode.getRight();\n          if (left.getType() == Token.STRING) {\n            left = processStringProperty(left.getString());\n            if (!propNode.isQuoted()) {\n              left.setQuotedString();\n            }\n          }\n\n          if (memberType == Token.OBJECTLIT) {\n            result.addChildToBack(\n                newNode(Token.COLON, transform(left), transform(right)));\n          } else {\n            result.addChildToBack(\n                newNode(memberType, transform(left), transform(right)));\n          }\n          break;\n        case ObjectProperty.TYPE_GETTER:\n          result.addChildToBack(newNode(Token.GETTER_DEF, transform(propNode.getLeft()), transform(propNode.getRight())));\n          break;\n        case ObjectProperty.TYPE_SETTER:\n          result.addChildToBack(newNode(Token.SETTER_DEF, transform(propNode.getLeft()), transform(propNode.getRight())));\n          break;\n      }\n    }\n    return result;\n  }\n\n  @Override\n  public Node processRegExpLiteral(RegExpLiteral literalNode) {\n    return new IRFactory.regexNode(literalNode);\n  }\n\n  @Override\n  public Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = newNode(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      node.addChildToBack(transform(statementNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processStringLiteral(StringLiteral stringNode) {\n    return newString(stringNode.getValue());\n  }\n\n  @Override\n  public Node processSwitchCase(SwitchCase caseNode) {\n    return newNode(\n        Token.CASE, transform(caseNode.getExpression()), transform(caseNode.getStatements()));\n  }\n\n  @Override\n  public Node processSwitchStatement(SwitchStatement statementNode) {\n    return newNode(Token.SWITCH, transform(statementNode.getExpression()), transformSwitchCases(statementNode.getCases(), statementNode.getDefault()));\n  }\n\n  @Override\n  public Node processThrowStatement(ThrowStatement statementNode) {\n    return newNode(Token.THROW, transform(statementNode.getExpression()));\n  }\n\n  @Override\n  public Node processTryStatement(TryStatement statementNode) {\n    Node tryNode = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n    if (statementNode.getCatchBlock() != null) {\n      tryNode.addChildToBack(transform(statementNode.getCatchBlock()));\n    }\n    if (statementNode.getFinallyBlock() != null) {\n      tryNode.addChildToBack(transform(statementNode.getFinallyBlock()));\n    }\n    return tryNode;\n  }\n\n  @Override\n  public Node processUnaryExpression(UnaryExpression exprNode) {\n    if (exprNode.getOperator().equals(UnaryExpression.Operator.TYPEOF)) {\n      Node operandNode = transform(exprNode.getOperand());\n      return newNode(Token.TYPEOF, operandNode);\n    }\n    return newNode(Token.NOT, transform(exprNode.getOperand()));\n  }\n\n  @Override\n  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n    int declType = declarationNode.getType();\n    boolean constant = Token.CONST == declType;\n\n    Node firstChild = null;\n    for (VariableInitializer initializer : declarationNode.getVariables()) {\n      Node child = processVariableDeclarator(initializer, declType, constant);\n      if (firstChild == null) {\n        firstChild = child;\n      }\n    }\n    return newNode(declType, firstChild);\n  }\n\n  private Node processVariableDeclarator(\n      VariableInitializer initializerNode, int type, boolean constant) {\n    AstNode targetNode = initializerNode.getTarget();\n    Node variableNode;\n    if (targetNode instanceof DestructuringForm) {\n      variableNode = transform(targetNode);\n    } else {\n      AstNode nameNode = targetNode;\n      if (nameNode.getType() == Token.LET) {\n        nameNode.setType(Token.NAME);\n      }\n      variableNode = IR.name(nameNode.getString());\n      if (!constant) {\n        variableNode.putProp(Node.IS_SINGLETON_VAR, true);\n      }\n      variableNode.setJSDocInfo(targetNode.getJSDocInfo());\n      variableNode.putProp(Node.IS_MUTATED_VAR, initializerNode.getInitializer() != null);\n      variableNode.setLineno(targetNode.getLineno());\n      variableNode.setCharno(targetNode.getCharno());\n    }\n    Node initNode = createAssignment(Token.ASSIGN, variableNode, transform(initializerNode.getInitializer()));\n    return initNode;\n  }\n\n  @Override\n  public Node processWhileLoop(WhileLoop loopNode) {\n    return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n  }\n\n  @Override\n  public Node processWithStatement(WithStatement statementNode) {\n    return newNode(Token.WITH, transform(statementNode.getExpression()), transform(statementNode.getStatement()));\n  }\n\n  private Node transformSwitchCases(List<SwitchCase> cases, AstNode defaultNode) {\n    Node casesNode = newNode(Token.CASEBLOCK);\n    for (SwitchCase caseNode : cases) {\n      casesNode.addChildToBack(transform(caseNode));\n    }\n    if (defaultNode != null) {\n      casesNode.addChildToBack(newNode(Token.DEFAULT, transform(defaultNode.getStatements())));\n    }\n    return casesNode;\n  }\n\n  private Node processGenericBlock(Block blockNode) {\n    Node node = newNode(Token.BLOCK);\n    for (Node child : transformBlock(blockNode)) {\n      node.addChildToBack(child);\n    }\n    return node;\n  }\n\n  private boolean isDirective(AstNode n) {\n    if (n == null || !(n instanceof ExpressionStatement)) {\n      return false;\n    }\n    AstNode expr = ((ExpressionStatement) n).getExpression();\n    if (!(expr instanceof StringLiteral)) {\n      return false;\n    }\n    String str = ((StringLiteral) expr).getValue();\n    return allowedDirectives.contains(str);\n  }\n\n  private Node processStringProperty(String key) {\n    Node n = IR.string(key);\n    n.setQuotedString();\n    return n;\n  }\n\n  private Node checkForViolation(Parser.Config currentConfig, AstNode node) {\n    // Skip ES6-only \"let\" declarations\n    if (!(node instanceof LetNode)) {\n      CheckSideEffectFreeTraversal violationCheck = new CheckSideEffectFreeTraversal();\n      violationCheck.setCompilerOptions(currentConfig.getCompilerOptions());\n      node.visit(violationCheck);\n      if (violationCheck.foundReference) {\n        errorReporter.warning(\n            \"destructuring diagonal assignment not supported\",\n            sourceName,\n            node.getLineno(),\n            \"\",\n            0);\n      }\n    }\n    return transform(node);\n  }\n\n  private static Node newNode(int nodeType, Node... children) {\n    Node newNode = new Node(nodeType);\n    for (Node child : children) {\n      newNode.addChildToBack(child);\n    }\n    return newNode;\n  }\n\n  private static Node newNode(int nodeType, AstNode... astNodes) {",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..653386c7 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,430 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher implements IRFactory.TypeSafeDispatcher {\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+  private final Set<String> allowedDirectives;\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  TransformDispatcher(ErrorReporter reporter, String sourceName) {\n+    this.errorReporter = reporter;\n+    this.sourceName = sourceName;\n+    this.allowedDirectives = ImmutableSet.of(\n+        \"use strict\",\n+        \"use asm\",\n+        \"use strict class\");\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  @Override\n+  public Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(Token.EXPR_RESULT);\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    if (isDirective(statementNode.getExpression())) {\n+      node.putBooleanProp(Node.DIRECTIVE_PROP, true);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+  @Override\n+  public Node processBlock(Block blockNode) {\n+    return processGenericBlock(blockNode);\n+  }\n+\n+  @Override\n+  public Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  @Override\n+  public Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\",\n+          sourceName,\n+          clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  public Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO, transformBlock(loopNode.getBody()), transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  public Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM, transform(getNode.getTarget()), transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  public Node processEmptyExpression(EmptyExpression exprNode) {\n+    return newNode(Token.EMPTY);\n+  }\n+\n+  @Override\n+  public Node processForInLoop(ForInLoop loopNode) {\n+    Node lhs;\n+    if (loopNode.getIterator() instanceof DestructuringForm) {\n+      checkForViolation(\n+          Parser.Config.StrictMode.under((Node) loopNode),\n+          ((DestructuringForm) loopNode.getIterator()).getLeft());\n+      lhs = transform(loopNode.getIterator());\n+    } else {\n+      AstNode nameNode = loopNode.getIterator();\n+      if (nameNode.getType() == Token.LET) {\n+        nameNode.setType(Token.NAME);\n+      }\n+      Node varNode = newNode(Token.VAR, transform(nameNode));\n+      lhs = newNode(Token.NAME, nameNode.getString());\n+      varNode.putProp(Node.IS_LOOKUP_VAR, Node.TRUE);\n+      varNode.putProp(Node.IS_BLOCK_SCOPED_VAR, Node.TRUE);\n+      varNode.addChildToFront(lhs);\n+      varNode.addChildToBack(newNode(Node.EMPTY));\n+      lhs = varNode;\n+    }\n+    Node obj = transform(loopNode.getIteratedObject());\n+    Node forNode = newNode(Token.FOR, lhs, obj, transformBlock(loopNode.getBody()));\n+    return forNode;\n+  }\n+\n+  @Override\n+  public Node processForLoop(ForLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getInitializer()),\n+        transform(loopNode.getCondition()),\n+        transform(loopNode.getIncrement()),\n+        transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processFunctionCall(FunctionCall callNode) {\n+    Node n = newNode(Token.CALL, transform(callNode.getTarget()));\n+    if (callNode.getArguments().size() > 0) {\n+      List<AstNode> argNodes = callNode.getArguments();\n+      for (AstNode argNode : argNodes) {\n+        Node arg = transform(argNode);\n+        if (argNode.isSpreadable()) {\n+          arg.putBooleanProp(Node.SPREADS, true);\n+        }\n+        n.addChildToBack(arg);\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n+    return n;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+  @Override\n+  public Node processFunctionNode(FunctionNode functionNode) {\n+    checkForFunctionRedefinition(functionNode);\n+    return newNode(Token.FUNCTION, IR.name(functionNode.getName()), transform(functionNode.getParams()), transform(functionNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processIfStatement(IfStatement statementNode) {\n+    if (statementNode.getElsePart() != null) {\n+      return newNode(\n+          Token.IF,\n+          transform(statementNode.getCondition()),\n+          transform(statementNode.getThenPart()),\n+          transform(statementNode.getElsePart()));\n+    } else {\n       return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+          Token.IF,\n+          transform(statementNode.getCondition()),\n+          transform(statementNode.getThenPart()));\n     }\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  @Override\n+  public Node processLabeledStatement(LabeledStatement statementNode) {\n+    Node node = newNode(Token.LABEL);\n+    node.addChildToBack(transform(statementNode.getStatement()));\n+    node.addChildToBack(IR.labelName(statementNode.getLabelName()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processLetNode(LetNode letNode) {\n+    Scope scope = letNode.getScope();\n+    if (!scope.isDeclaredLocally(letNode.getIdentifier())) {\n+      Symbol symbol = scope.getSymbol(letNode.getIdentifier());\n+      Node stringBuilder = newQuotedString(symbol.getName());\n+      stringBuilder.addChildToBack(transform(letNode.getInitialValue()));\n+      stringBuilder.putProp(Node.MUST_GEN_SYMBOL, true);\n+      letNode.setInitialValue(null);\n+      letNode.setIdentifier(Symbol.createPrivateName());\n+      return newNode(Token.EXPR_RESULT, createAssignment(Token.ASSIGN, IR.name(letNode.getIdentifier()), stringBuilder));\n+    }\n+    Node node = IR.let(IR.name(letNode.getIdentifier()), transform(letNode.getInitialValue()));\n+    node.setLineno(letNode.getLineno());\n+    node.setCharno(letNode.getCharno());\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processName(Name nameNode) {\n+    int type = transformTokenType(Token.NAME);\n+    if (TokenStream.isJSKeyword(nameNode.getIdentifier())) {\n+      type = Token.STRING;\n+    }\n+    Node n = IR.name(nameNode.getIdentifier());\n+    n.setType(type);\n+    n.setScope(nameNode.getScope());\n+    n.putProp(Node.IS_CONSTANT_NAME, nameNode.getIdentifier().equals(\"Infinity\") || nameNode.getIdentifier().equals(\"NaN\"));\n+    return n;\n+  }\n+\n+  @Override\n+  public Node processNewExpression(NewExpression callNode) {\n+    return newNode(Token.NEW, transform(callNode.getTarget()));\n+  }\n+\n+  @Override\n+  public Node processNumberLiteral(NumberLiteral numberNode) {\n+    return newNode(Token.NUMBER, numberNode.getNumber());\n+  }\n+\n+  @Override\n+  public Node processObjectLiteral(ObjectLiteral objectNode) {\n+    Node result = newNode(Token.OBJECTLIT);\n+    for (ObjectProperty propNode : objectNode.getElements()) {\n+      switch (propNode.getType()) {\n+        case ObjectProperty.TYPE_NORMAL:\n+          AstNode left = propNode.getLeft();\n+          int memberType = Token.OBJECTLIT;\n+          if (propNode.isGetter()) {\n+            memberType = Token.GETTER_DEF;\n+          } else if (propNode.isSetter()) {\n+            memberType = Token.SETTER_DEF;\n+          }\n+\n+          AstNode right = propNode.getRight();\n+          if (left.getType() == Token.STRING) {\n+            left = processStringProperty(left.getString());\n+            if (!propNode.isQuoted()) {\n+              left.setQuotedString();\n+            }\n+          }\n+\n+          if (memberType == Token.OBJECTLIT) {\n+            result.addChildToBack(\n+                newNode(Token.COLON, transform(left), transform(right)));\n+          } else {\n+            result.addChildToBack(\n+                newNode(memberType, transform(left), transform(right)));\n+          }\n+          break;\n+        case ObjectProperty.TYPE_GETTER:\n+          result.addChildToBack(newNode(Token.GETTER_DEF, transform(propNode.getLeft()), transform(propNode.getRight())));\n+          break;\n+        case ObjectProperty.TYPE_SETTER:\n+          result.addChildToBack(newNode(Token.SETTER_DEF, transform(propNode.getLeft()), transform(propNode.getRight())));\n+          break;\n       }\n-      return node;\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+  @Override\n+  public Node processRegExpLiteral(RegExpLiteral literalNode) {\n+    return new IRFactory.regexNode(literalNode);\n+  }\n+\n+  @Override\n+  public Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(statementNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  @Override\n+  public Node processStringLiteral(StringLiteral stringNode) {\n+    return newString(stringNode.getValue());\n+  }\n+\n+  @Override\n+  public Node processSwitchCase(SwitchCase caseNode) {\n+    return newNode(\n+        Token.CASE, transform(caseNode.getExpression()), transform(caseNode.getStatements()));\n+  }\n+\n+  @Override\n+  public Node processSwitchStatement(SwitchStatement statementNode) {\n+    return newNode(Token.SWITCH, transform(statementNode.getExpression()), transformSwitchCases(statementNode.getCases(), statementNode.getDefault()));\n+  }\n+\n+  @Override\n+  public Node processThrowStatement(ThrowStatement statementNode) {\n+    return newNode(Token.THROW, transform(statementNode.getExpression()));\n+  }\n+\n+  @Override\n+  public Node processTryStatement(TryStatement statementNode) {\n+    Node tryNode = newNode(Token.TRY, transformBlock(statementNode.getTryBlock()));\n+    if (statementNode.getCatchBlock() != null) {\n+      tryNode.addChildToBack(transform(statementNode.getCatchBlock()));\n     }\n+    if (statementNode.getFinallyBlock() != null) {\n+      tryNode.addChildToBack(transform(statementNode.getFinallyBlock()));\n+    }\n+    return tryNode;\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node processUnaryExpression(UnaryExpression exprNode) {\n+    if (exprNode.getOperator().equals(UnaryExpression.Operator.TYPEOF)) {\n+      Node operandNode = transform(exprNode.getOperand());\n+      return newNode(Token.TYPEOF, operandNode);\n     }\n+    return newNode(Token.NOT, transform(exprNode.getOperand()));\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n+    int declType = declarationNode.getType();\n+    boolean constant = Token.CONST == declType;\n+\n+    Node firstChild = null;\n+    for (VariableInitializer initializer : declarationNode.getVariables()) {\n+      Node child = processVariableDeclarator(initializer, declType, constant);\n+      if (firstChild == null) {\n+        firstChild = child;\n+      }\n     }\n+    return newNode(declType, firstChild);\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  private Node processVariableDeclarator(\n+      VariableInitializer initializerNode, int type, boolean constant) {\n+    AstNode targetNode = initializerNode.getTarget();\n+    Node variableNode;\n+    if (targetNode instanceof DestructuringForm) {\n+      variableNode = transform(targetNode);\n+    } else {\n+      AstNode nameNode = targetNode;\n+      if (nameNode.getType() == Token.LET) {\n+        nameNode.setType(Token.NAME);\n+      }\n+      variableNode = IR.name(nameNode.getString());\n+      if (!constant) {\n+        variableNode.putProp(Node.IS_SINGLETON_VAR, true);\n+      }\n+      variableNode.setJSDocInfo(targetNode.getJSDocInfo());\n+      variableNode.putProp(Node.IS_MUTATED_VAR, initializerNode.getInitializer() != null);\n+      variableNode.setLineno(targetNode.getLineno());\n+      variableNode.setCharno(targetNode.getCharno());\n+    }\n+    Node initNode = createAssignment(Token.ASSIGN, variableNode, transform(initializerNode.getInitializer()));\n+    return initNode;\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  public Node processWhileLoop(WhileLoop loopNode) {\n+    return newNode(Token.WHILE, transform(loopNode.getCondition()), transformBlock(loopNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processWithStatement(WithStatement statementNode) {\n+    return newNode(Token.WITH, transform(statementNode.getExpression()), transform(statementNode.getStatement()));\n+  }\n+\n+  private Node transformSwitchCases(List<SwitchCase> cases, AstNode defaultNode) {\n+    Node casesNode = newNode(Token.CASEBLOCK);\n+    for (SwitchCase caseNode : cases) {\n+      casesNode.addChildToBack(transform(caseNode));\n+    }\n+    if (defaultNode != null) {\n+      casesNode.addChildToBack(newNode(Token.DEFAULT, transform(defaultNode.getStatements())));\n+    }\n+    return casesNode;\n+  }\n+\n+  private Node processGenericBlock(Block blockNode) {\n+    Node node = newNode(Token.BLOCK);\n+    for (Node child : transformBlock(blockNode)) {\n+      node.addChildToBack(child);\n+    }\n+    return node;\n+  }\n+\n+  private boolean isDirective(AstNode n) {\n+    if (n == null || !(n instanceof ExpressionStatement)) {\n+      return false;\n+    }\n+    AstNode expr = ((ExpressionStatement) n).getExpression();\n+    if (!(expr instanceof StringLiteral)) {\n+      return false;\n     }\n+    String str = ((StringLiteral) expr).getValue();\n+    return allowedDirectives.contains(str);\n+  }\n+\n+  private Node processStringProperty(String key) {\n+    Node n = IR.string(key);\n+    n.setQuotedString();\n+    return n;\n+  }\n+\n+  private Node checkForViolation(Parser.Config currentConfig, AstNode node) {\n+    // Skip ES6-only \"let\" declarations\n+    if (!(node instanceof LetNode)) {\n+      CheckSideEffectFreeTraversal violationCheck = new CheckSideEffectFreeTraversal();\n+      violationCheck.setCompilerOptions(currentConfig.getCompilerOptions());\n+      node.visit(violationCheck);\n+      if (violationCheck.foundReference) {\n+        errorReporter.warning(\n+            \"destructuring diagonal assignment not supported\",\n+            sourceName,\n+            node.getLineno(),\n+            \"\",\n+            0);\n+      }\n+    }\n+    return transform(node);\n+  }\n+\n+  private static Node newNode(int nodeType, Node... children) {\n+    Node newNode = new Node(nodeType);\n+    for (Node child : children) {\n+      newNode.addChildToBack(child);\n+    }\n+    return newNode;\n+  }\n+\n+  private static Node newNode(int nodeType, AstNode... astNodes) {\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}