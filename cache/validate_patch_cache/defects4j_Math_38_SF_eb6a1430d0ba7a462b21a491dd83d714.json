{
    "patch": "private void prelim(double[] lowerBound, double[] upperBound) {\n    printMethod();\n\n    final int n = currentBest.getDimension();\n    final int npt = numberOfInterpolationPoints;\n    final int ndim = bMatrix.getRowDimension();\n    \n    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n    final double recip = 1d / rhosq;\n    final int np = n + 1;\n\n    // Initialize XPT\n    for (int j = 0; j < n; j++) {\n        originShift.setEntry(j, currentBest.getEntry(j));\n        for (int k = 0; k < npt; k++) {\n            interpolationPoints.setEntry(k, j, 0d);\n        }\n    }\n\n    // Initialize BMAT, HQ, PQ and ZMAT\n    for (int i = 0; i < ndim; i++) {\n        for (int j = 0; j <= i; j++) {\n            bMatrix.setEntry(i, j, 0d);\n        }\n        for (int j = 0, mMax = npt - np; j < mMax; j++) {\n            zMatrix.setEntry(i, j, 0d);\n        }\n    }\n    for (int i = 0, max = n * np / 2; i < max; i++) {\n        modelSecondDerivativesValues.setEntry(i, 0d);\n    }\n    for (int i = 0; i < npt; i++) {\n        modelSecondDerivativesParameters.setEntry(i, 0d);\n\n        if (i < np) {\n            final double oneOverSqrtNp = 1.0 / Math.sqrt(np);\n            zMatrix.setEntry(i, i, oneOverSqrtNp);\n            interpolationPoints.setEntry(i, i, initialTrustRegionRadius);\n        } else {\n            int j = (i - np) / n;\n            int k = (i - np) % n;\n            interpolationPoints.setEntry(i, k, interpolationPoints.getEntry(j, k));\n        }\n    }\n\n    // Begin the initialization procedure.\n    int ipt = 0;\n    int jpt = 0;\n    double fbeg = 0;\n    try {\n        do {\n            final int nfm = getEvaluations();\n            final int nfx = nfm - n;\n            final int nfmm = nfm - 1;\n            final int nfxm = nfx - 1;\n            double stepa = 0;\n            double stepb = 0;\n            final boolean needToSetupBmat = (nfm <= 2 * n);\n\n            if (nfm <= 2 * n) {\n                if (nfm >= 1 && nfm <= n) {\n                    stepa = initialTrustRegionRadius;\n                    if (upperDifference.getEntry(nfmm) == 0) {\n                        stepa = -stepa;\n                    }\n                    interpolationPoints.setEntry(nfm, nfmm, stepa);\n                } else if (nfm > n) {\n                    stepa = interpolationPoints.getEntry(nfx, nfxm);\n                    stepb = -initialTrustRegionRadius;\n\n                    if (lowerDifference.getEntry(nfxm) == 0) {\n                        stepb = Math.min(2 * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                    }\n\n                    if (upperDifference.getEntry(nfxm) == 0) {\n                        stepb = Math.max(-2 * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                    }\n\n                    interpolationPoints.setEntry(nfm, nfxm, stepb);\n                }\n            } else {\n                final int tmp1 = (nfm - np) / n;\n                jpt = nfm - tmp1 * n - n;\n                ipt = jpt + tmp1;\n                if (ipt > n) {\n                    final int tmp2 = jpt;\n                    jpt = ipt - n;\n                    ipt = tmp2;\n                }\n\n                final int iptMinus1 = ipt;\n                final int jptMinus1 = jpt;\n\n                interpolationPoints.setEntry(nfm, ipt - 1, interpolationPoints.getEntry(iptMinus1 - 1, ipt - 1));\n                interpolationPoints.setEntry(nfm, jpt - 1, interpolationPoints.getEntry(jptMinus1 - 1, jpt - 1));\n            }\n            \n            // Calculate the next value of F\n            for (int j = 0; j < n; j++) {\n                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));\n                \n                if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                    currentBest.setEntry(j, lowerBound[j]);\n                } else if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                    currentBest.setEntry(j, upperBound[j]);\n                }\n            }\n\n            final double[] currentBestArray = currentBest.toArray();\n            final double f = isMinimize ? computeObjectiveValue(currentBestArray) : -computeObjectiveValue(currentBestArray);\n            fAtInterpolationPoints.setEntry(nfm, f);\n            if (nfm == 1) {\n                fbeg = f;\n                trustRegionCenterInterpolationPointIndex = 0;\n            } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                trustRegionCenterInterpolationPointIndex = nfm;\n            }\n\n            if (needToSetupBmat) {\n                if (nfm >= 2 && nfm <= n + 1) {\n                    gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n                    \n                    if (npt < nfm + n) {\n                        final double oneOverStepA = 1.0 / stepa;\n                        bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                        bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n\n                        final double halfRhosq = 0.5 * rhosq;\n                        bMatrix.setEntry(npt + nfmm, nfmm, -halfRhosq);\n\n                        throw new PathIsExploredException();\n                    }\n                    \n                    final int startPoint = nfmm - n;\n                    for (int k = startPoint; k < n; k++) {\n                        int j = k - startPoint;\n                        final double oneOverDelta = 1.0 / interpolationPoints.getEntry(nfm, j);\n                        final double beta = gradientAtTrustRegionCenter.getEntry(k) * oneOverDelta;\n                        \n                        for (int i = 0; i <= j; i++) {\n                            bMatrix.setEntry(i, j, bMatrix.getEntry(i, j) + beta * gradientAtTrustRegionCenter.getEntry(i) * oneOverDelta);\n                        }\n                        \n                        bMatrix.setEntry(nfm, j, -oneOverDelta);\n                        bMatrix.setEntry(npt + k, j, oneOverDelta);\n                    }\n                    \n                    final double halfRhosq = 0.5 * rhosq;\n                    final double oneOverStepA = 1.0 / stepa;\n                    final double oneOverStepB = 1.0 / stepb;\n                    final double eta = fbeg - fAtInterpolationPoints.getEntry(nfmm);\n                    final int startPointNpt = npt + nfmm - n;\n                    \n                    boolean setCIsZero = true;\n                    boolean setDIsZero = true;\n                    for (int k = startPointNpt; k < npt; k++) {\n                        if (interpolationPoints.getEntry(nfm, k) > 0.0) {\n                            final double gamma = halfRhosq / (rhosq + interpolationPoints.getEntry(nfm, k) * interpolationPoints.getEntry(nfm, k));\n                            final double oneOverInterpolationPoint = 1.0 / interpolationPoints.getEntry(nfm, k);\n                            zMatrix.setEntry(0, k - nfmm - 1, (eta - fAtInterpolationPoints.ge",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\nindex 592a2e894..6096a2f96 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/BOBYQAOptimizer.java\n@@ -1579,47 +1579,56 @@ public class BOBYQAOptimizer\n      * @param lowerBound Lower bounds.\n      * @param upperBound Upper bounds.\n      */\n-    private void prelim(double[] lowerBound,\n-                        double[] upperBound) {\n-        printMethod(); // XXX\n-\n-        final int n = currentBest.getDimension();\n-        final int npt = numberOfInterpolationPoints;\n-        final int ndim = bMatrix.getRowDimension();\n-\n-        final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n-        final double recip = 1d / rhosq;\n-        final int np = n + 1;\n-\n-        // Set XBASE to the initial vector of variables, and set the initial\n-        // elements of XPT, BMAT, HQ, PQ and ZMAT to zero.\n+private void prelim(double[] lowerBound, double[] upperBound) {\n+    printMethod();\n+\n+    final int n = currentBest.getDimension();\n+    final int npt = numberOfInterpolationPoints;\n+    final int ndim = bMatrix.getRowDimension();\n+    \n+    final double rhosq = initialTrustRegionRadius * initialTrustRegionRadius;\n+    final double recip = 1d / rhosq;\n+    final int np = n + 1;\n+\n+    // Initialize XPT\n+    for (int j = 0; j < n; j++) {\n+        originShift.setEntry(j, currentBest.getEntry(j));\n+        for (int k = 0; k < npt; k++) {\n+            interpolationPoints.setEntry(k, j, 0d);\n+        }\n+    }\n \n-        for (int j = 0; j < n; j++) {\n-            originShift.setEntry(j, currentBest.getEntry(j));\n-            for (int k = 0; k < npt; k++) {\n-                interpolationPoints.setEntry(k, j, ZERO);\n-            }\n-            for (int i = 0; i < ndim; i++) {\n-                bMatrix.setEntry(i, j, ZERO);\n-            }\n+    // Initialize BMAT, HQ, PQ and ZMAT\n+    for (int i = 0; i < ndim; i++) {\n+        for (int j = 0; j <= i; j++) {\n+            bMatrix.setEntry(i, j, 0d);\n         }\n-        for (int i = 0, max = n * np / 2; i < max; i++) {\n-            modelSecondDerivativesValues.setEntry(i, ZERO);\n+        for (int j = 0, mMax = npt - np; j < mMax; j++) {\n+            zMatrix.setEntry(i, j, 0d);\n         }\n-        for (int k = 0; k < npt; k++) {\n-            modelSecondDerivativesParameters.setEntry(k, ZERO);\n-            for (int j = 0, max = npt - np; j < max; j++) {\n-                zMatrix.setEntry(k, j, ZERO);\n-            }\n+    }\n+    for (int i = 0, max = n * np / 2; i < max; i++) {\n+        modelSecondDerivativesValues.setEntry(i, 0d);\n+    }\n+    for (int i = 0; i < npt; i++) {\n+        modelSecondDerivativesParameters.setEntry(i, 0d);\n+\n+        if (i < np) {\n+            final double oneOverSqrtNp = 1.0 / Math.sqrt(np);\n+            zMatrix.setEntry(i, i, oneOverSqrtNp);\n+            interpolationPoints.setEntry(i, i, initialTrustRegionRadius);\n+        } else {\n+            int j = (i - np) / n;\n+            int k = (i - np) % n;\n+            interpolationPoints.setEntry(i, k, interpolationPoints.getEntry(j, k));\n         }\n+    }\n \n-        // Begin the initialization procedure. NF becomes one more than the number\n-        // of function values so far. The coordinates of the displacement of the\n-        // next initial interpolation point from XBASE are set in XPT(NF+1,.).\n-\n-        int ipt = 0;\n-        int jpt = 0;\n-        double fbeg = Double.NaN;\n+    // Begin the initialization procedure.\n+    int ipt = 0;\n+    int jpt = 0;\n+    double fbeg = 0;\n+    try {\n         do {\n             final int nfm = getEvaluations();\n             final int nfx = nfm - n;\n@@ -1627,26 +1636,27 @@ public class BOBYQAOptimizer\n             final int nfxm = nfx - 1;\n             double stepa = 0;\n             double stepb = 0;\n+            final boolean needToSetupBmat = (nfm <= 2 * n);\n+\n             if (nfm <= 2 * n) {\n-                if (nfm >= 1 &&\n-                    nfm <= n) {\n+                if (nfm >= 1 && nfm <= n) {\n                     stepa = initialTrustRegionRadius;\n-                    if (upperDifference.getEntry(nfmm) == ZERO) {\n+                    if (upperDifference.getEntry(nfmm) == 0) {\n                         stepa = -stepa;\n-                        throw new PathIsExploredException(); // XXX\n                     }\n                     interpolationPoints.setEntry(nfm, nfmm, stepa);\n                 } else if (nfm > n) {\n                     stepa = interpolationPoints.getEntry(nfx, nfxm);\n                     stepb = -initialTrustRegionRadius;\n-                    if (lowerDifference.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.min(TWO * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n-                        throw new PathIsExploredException(); // XXX\n+\n+                    if (lowerDifference.getEntry(nfxm) == 0) {\n+                        stepb = Math.min(2 * initialTrustRegionRadius, upperDifference.getEntry(nfxm));\n                     }\n-                    if (upperDifference.getEntry(nfxm) == ZERO) {\n-                        stepb = Math.max(-TWO * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n-                        throw new PathIsExploredException(); // XXX\n+\n+                    if (upperDifference.getEntry(nfxm) == 0) {\n+                        stepb = Math.max(-2 * initialTrustRegionRadius, lowerDifference.getEntry(nfxm));\n                     }\n+\n                     interpolationPoints.setEntry(nfm, nfxm, stepb);\n                 }\n             } else {\n@@ -1657,102 +1667,78 @@ public class BOBYQAOptimizer\n                     final int tmp2 = jpt;\n                     jpt = ipt - n;\n                     ipt = tmp2;\n-                    throw new PathIsExploredException(); // XXX\n                 }\n+\n                 final int iptMinus1 = ipt;\n                 final int jptMinus1 = jpt;\n-                interpolationPoints.setEntry(nfm, iptMinus1, interpolationPoints.getEntry(ipt, iptMinus1));\n-                interpolationPoints.setEntry(nfm, jptMinus1, interpolationPoints.getEntry(jpt, jptMinus1));\n-            }\n-\n-            // Calculate the next value of F. The least function value so far and\n-            // its index are required.\n \n+                interpolationPoints.setEntry(nfm, ipt - 1, interpolationPoints.getEntry(iptMinus1 - 1, ipt - 1));\n+                interpolationPoints.setEntry(nfm, jpt - 1, interpolationPoints.getEntry(jptMinus1 - 1, jpt - 1));\n+            }\n+            \n+            // Calculate the next value of F\n             for (int j = 0; j < n; j++) {\n-                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j],\n-                                                          originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)),\n-                                                 upperBound[j]));\n+                currentBest.setEntry(j, Math.min(Math.max(lowerBound[j], originShift.getEntry(j) + interpolationPoints.getEntry(nfm, j)), upperBound[j]));\n+                \n                 if (interpolationPoints.getEntry(nfm, j) == lowerDifference.getEntry(j)) {\n                     currentBest.setEntry(j, lowerBound[j]);\n-                }\n-                if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n+                } else if (interpolationPoints.getEntry(nfm, j) == upperDifference.getEntry(j)) {\n                     currentBest.setEntry(j, upperBound[j]);\n                 }\n             }\n \n-            final double objectiveValue = computeObjectiveValue(currentBest.toArray());\n-            final double f = isMinimize ? objectiveValue : -objectiveValue;\n-            final int numEval = getEvaluations(); // nfm + 1\n+            final double[] currentBestArray = currentBest.toArray();\n+            final double f = isMinimize ? computeObjectiveValue(currentBestArray) : -computeObjectiveValue(currentBestArray);\n             fAtInterpolationPoints.setEntry(nfm, f);\n-\n-            if (numEval == 1) {\n+            if (nfm == 1) {\n                 fbeg = f;\n                 trustRegionCenterInterpolationPointIndex = 0;\n             } else if (f < fAtInterpolationPoints.getEntry(trustRegionCenterInterpolationPointIndex)) {\n                 trustRegionCenterInterpolationPointIndex = nfm;\n             }\n \n-            // Set the nonzero initial elements of BMAT and the quadratic model in the\n-            // cases when NF is at most 2*N+1. If NF exceeds N+1, then the positions\n-            // of the NF-th and (NF-N)-th interpolation points may be switched, in\n-            // order that the function value at the first of them contributes to the\n-            // off-diagonal second derivative terms of the initial quadratic model.\n-\n-            if (numEval <= 2 * n + 1) {\n-                if (numEval >= 2 &&\n-                    numEval <= n + 1) {\n+            if (needToSetupBmat) {\n+                if (nfm >= 2 && nfm <= n + 1) {\n                     gradientAtTrustRegionCenter.setEntry(nfmm, (f - fbeg) / stepa);\n-                    if (npt < numEval + n) {\n-                        final double oneOverStepA = ONE / stepa;\n+                    \n+                    if (npt < nfm + n) {\n+                        final double oneOverStepA = 1.0 / stepa;\n                         bMatrix.setEntry(0, nfmm, -oneOverStepA);\n                         bMatrix.setEntry(nfm, nfmm, oneOverStepA);\n-                        bMatrix.setEntry(npt + nfmm, nfmm, -HALF * rhosq);\n-                        throw new PathIsExploredException(); // XXX\n+\n+                        final double halfRhosq = 0.5 * rhosq;\n+                        bMatrix.setEntry(npt + nfmm, nfmm, -halfRhosq);\n+\n+                        throw new PathIsExploredException();\n                     }\n-                } else if (numEval >= n + 2) {\n-                    final int ih = nfx * (nfx + 1) / 2 - 1;\n-                    final double tmp = (f - fbeg) / stepb;\n-                    final double diff = stepb - stepa;\n-                    modelSecondDerivativesValues.setEntry(ih, TWO * (tmp - gradientAtTrustRegionCenter.getEntry(nfxm)) / diff);\n-                    gradientAtTrustRegionCenter.setEntry(nfxm, (gradientAtTrustRegionCenter.getEntry(nfxm) * stepb - tmp * stepa) / diff);\n-                    if (stepa * stepb < ZERO) {\n-                        if (f < fAtInterpolationPoints.getEntry(nfm - n)) {\n-                            fAtInterpolationPoints.setEntry(nfm, fAtInterpolationPoints.getEntry(nfm - n));\n-                            fAtInterpolationPoints.setEntry(nfm - n, f);\n-                            if (trustRegionCenterInterpolationPointIndex == nfm) {\n-                                trustRegionCenterInterpolationPointIndex = nfm - n;\n-                            }\n-                            interpolationPoints.setEntry(nfm - n, nfxm, stepb);\n-                            interpolationPoints.setEntry(nfm, nfxm, stepa);\n+                    \n+                    final int startPoint = nfmm - n;\n+                    for (int k = startPoint; k < n; k++) {\n+                        int j = k - startPoint;\n+                        final double oneOverDelta = 1.0 / interpolationPoints.getEntry(nfm, j);\n+                        final double beta = gradientAtTrustRegionCenter.getEntry(k) * oneOverDelta;\n+                        \n+                        for (int i = 0; i <= j; i++) {\n+                            bMatrix.setEntry(i, j, bMatrix.getEntry(i, j) + beta * gradientAtTrustRegionCenter.getEntry(i) * oneOverDelta);\n                         }\n+                        \n+                        bMatrix.setEntry(nfm, j, -oneOverDelta);\n+                        bMatrix.setEntry(npt + k, j, oneOverDelta);\n                     }\n-                    bMatrix.setEntry(0, nfxm, -(stepa + stepb) / (stepa * stepb));\n-                    bMatrix.setEntry(nfm, nfxm, -HALF / interpolationPoints.getEntry(nfm - n, nfxm));\n-                    bMatrix.setEntry(nfm - n, nfxm,\n-                                  -bMatrix.getEntry(0, nfxm) - bMatrix.getEntry(nfm, nfxm));\n-                    zMatrix.setEntry(0, nfxm, Math.sqrt(TWO) / (stepa * stepb));\n-                    zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) / rhosq);\n-                    // zMatrix.setEntry(nfm, nfxm, Math.sqrt(HALF) * recip); // XXX \"testAckley\" and \"testDiffPow\" fail.\n-                    zMatrix.setEntry(nfm - n, nfxm,\n-                                  -zMatrix.getEntry(0, nfxm) - zMatrix.getEntry(nfm, nfxm));\n-                }\n-\n-                // Set the off-diagonal second derivatives of the Lagrange functions and\n-                // the initial quadratic model.\n-\n-            } else {\n-                zMatrix.setEntry(0, nfxm, recip);\n-                zMatrix.setEntry(nfm, nfxm, recip);\n-                zMatrix.setEntry(ipt, nfxm, -recip);\n-                zMatrix.setEntry(jpt, nfxm, -recip);\n-\n-                final int ih = ipt * (ipt - 1) / 2 + jpt - 1;\n-                final double tmp = interpolationPoints.getEntry(nfm, ipt - 1) * interpolationPoints.getEntry(nfm, jpt - 1);\n-                modelSecondDerivativesValues.setEntry(ih, (fbeg - fAtInterpolationPoints.getEntry(ipt) - fAtInterpolationPoints.getEntry(jpt) + f) / tmp);\n-                throw new PathIsExploredException(); // XXX\n-            }\n-        } while (getEvaluations() < npt);\n-    } // prelim\n+                    \n+                    final double halfRhosq = 0.5 * rhosq;\n+                    final double oneOverStepA = 1.0 / stepa;\n+                    final double oneOverStepB = 1.0 / stepb;\n+                    final double eta = fbeg - fAtInterpolationPoints.getEntry(nfmm);\n+                    final int startPointNpt = npt + nfmm - n;\n+                    \n+                    boolean setCIsZero = true;\n+                    boolean setDIsZero = true;\n+                    for (int k = startPointNpt; k < npt; k++) {\n+                        if (interpolationPoints.getEntry(nfm, k) > 0.0) {\n+                            final double gamma = halfRhosq / (rhosq + interpolationPoints.getEntry(nfm, k) * interpolationPoints.getEntry(nfm, k));\n+                            final double oneOverInterpolationPoint = 1.0 / interpolationPoints.getEntry(nfm, k);\n+                            zMatrix.setEntry(0, k - nfmm - 1, (eta - fAtInterpolationPoints.ge\n \n \n     // ----------------------------------------------------------------------------------------",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}