{
    "patch": "import java.util.List;\n\nimport com.google.javascript.jscomp.CompilerInput;\nimport com.google.javascript.jscomp.Node;\nimport com.google.javascript.jscomp.SourceFile;\nimport com.google.javascript.rhino.Node.JSDocInfo;\nimport com.google.javascript.rhino.Node.Util;\nimport com.google.javascript.rhino.StaticSourceFile;\nimport com.google.javascript.rhino.Token;\n\n/**\n * A JavaScript file and its associated information.\n */\nclass InputFile extends SourceFile {\n  static final long serialVersionUID = 1L;\n\n  // Required by SourceFile to resolve dependencies.\n  JSModule module;\n\n  AntiochErrorReporter errorReporter;\n\n  private boolean isExtern;\n  private boolean isPreloaded;\n\n  private JSDocInfo fileOverviewJSDocInfo;\n  private boolean fileOverviewProcessed;\n\n  private Node ast;\n  private boolean astComputed;\n\n  private RelativizePrefixMode relativizePrefixMode;\n\n  //------------------------------------------------------------------------\n  // Constructors\n  //------------------------------------------------------------------------\n\n  InputFile(String filename, String code) {\n    this(filename, code, false);\n  }\n\n  InputFile(String filename, String code, boolean isExtern) {\n    super(filename, code);\n    this.isExtern = isExtern;\n    relativizePrefixMode = RelativizePrefixMode.PRESERVE;\n    if (isExtern && !Reports.externDebugEnabled()) {\n      trimContent();\n    }\n  }\n\n  //------------------------------------------------------------------------\n  // Public Methods\n  //------------------------------------------------------------------------\n\n  boolean isExtern() {\n    return isExtern;\n  }\n\n  void setPreloaded(boolean value) {\n    isPreloaded = value;\n  }\n\n  boolean isPreloaded() {\n    return isPreloaded;\n  }\n\n  // Lazily create file overview jsdoc.\n  @Override\n  public synchronized JSDocInfo getFileOverviewJSDocInfo() {\n    if (!fileOverviewProcessed) {\n      fileOverviewJSDocInfo = JSDocInfo.builderForFile().build();\n      String content = getContent();\n      int pos = 0;\n      while (pos < content.length()) {\n        // Fast-forward past whitespace and comments.\n        while (TokenStream.isWhitespace(content.charAt(pos)))\n          pos++;\n        if (TokenStream.startsWith(\"/**\", content, pos)) {\n          int endDocPos = TokenStream.findEndOfJSDocComment(content, pos);\n          if (endDocPos != -1) {\n            String docContent = content.substring(pos, endDocPos + 3);\n            fileOverviewJSDocInfo = JSDocInfo.builderForFile().parse(docContent).build();\n          }\n          break;\n        }\n        if (TokenStream.startsWith(\"//\", content, pos)) {\n          pos = content.indexOf('\\n', pos)+1;\n          continue;\n        }\n        // Bail.\n        break;\n      }\n\n      fileOverviewProcessed = true;\n    }\n    return fileOverviewJSDocInfo;\n  }\n\n  void setRelativizePrefixMode(RelativizePrefixMode relativizePrefixMode) {\n    this.relativizePrefixMode = relativizePrefixMode;\n  }\n\n  RelativizePrefixMode getRelativizePrefixMode() {\n    return relativizePrefixMode;\n  }\n\n  void resetAst() {\n    astComputed = false;\n  }\n\n  Node getAstRoot(Compiler compiler) {\n    if (!astComputed) {\n      parse(compiler);\n    }\n    return ast;\n  }\n\n  @Override\n  public StaticSourceFile getStaticSourceFile() {\n    return new StaticSourceFile(getName(), getContent());\n  }\n\n  //------------------------------------------------------------------------\n  // Private Methods\n  //------------------------------------------------------------------------\n\n  synchronized void parse(Compiler compiler) {\n    try {\n      astComputed = true;\n      antiochSetAstRoot(compiler, parseAst(compiler));\n      if (compiler.getOptions().useTypesForOptimization) {\n        Util.markInferredTypesOnAst(ast, compiler.getTypeRegistry(), null);\n      }\n      setErrorTree(null);\n    } catch (AntiochErrorReporter.ParsingError e) {\n      setErrorTree(e.getNode());\n    }\n  }\n\n  private void antiochSetAstRoot(Compiler compiler, Node ast) {\n    this.ast = ast;\n    checkState(this.ast.getParent() == null, ast);\n    this.ast.putProp(Node.SOURCEFILE_PROP, this);\n    if (this.ast.getStaticSourceFile() == null) {\n      this.ast.setStaticSourceFile(new StaticSourceFile(getName(), getContent()));\n    }\n  }\n\n  private void setErrorTree(Node n) {\n    Node script = ast.getParent();\n    if (script != null && script.getType() == Token.SCRIPT) {\n      if (n == null) {\n        n = new Node(Token.EMPTY);\n      } else {\n        errorReporter.report(n, ErrorLevel.ERROR, \"Parse error. Primary error at token\" +\n            (n.getLineno() > 0 ? \" at index \" + n.getCharno() + \" of line \" + n.getLineno() : \"\") +\n            \":\\n\" + errorReporter.getSourceLine(n) +\n            \"\\nParsing stopped here because the source contains an error.\\n\" +\n            \"The remaining portion of the source file was not parsed.\");\n      }\n      script.addChildrenToBack(n);\n    }\n  }\n\n  private Node parseAst(Compiler compiler) throws AntiochErrorReporter.ParsingError {\n    Node jsRoot = compiler.parseInputs(Lists.newArrayList(this));\n    \n    if (compiler.getOptions().inferTypes) {\n      // Synthesize function names where necessary, to facilitate better reports.\n      new FunctionNamingCallback(compiler).process(jsRoot);\n    }\n\n    // If this input file was loaded from a ZIP, some of the top-level\n    // statements may not represent the start of a statement stream (that\n    // is, come directly or indirectly from the top-level of their module).\n    // So fix that now. Note that we invoke this even when running with new\n    // type inference, not just the old type checker.\n    new StatementFusion().process(null, jsRoot);\n    return jsRoot;\n  }\n\n  //------------------------------------------------------------------------\n  // Node accessors/mutators\n  //------------------------------------------------------------------------\n\n  void setPrologue(Node n) {\n    ast.addChildrenToFront(n);\n  }\n\n  Node getPrologue() {\n    return ast.getFirstChild();\n  }\n\n  void setBody(Node n) {\n    ast.addChildToBack(n);\n  }\n\n  Node getBody() {\n    return ast.getLastChild();\n  }\n\n  SourcePosition getNodePosition(Node n) {\n    if (n.getLineno() == -1) {\n      throw new IllegalArgumentException(\"Node has no source position\");\n    }\n    SourcePosition p = new SourcePosition(getName(), getContent(), n.getLineno(),\n        n.getCharno(), -1);\n    return p;\n  }\n\n  Region getSourceRegion(int lineno) {\n    if (astComputed) {\n      SourcePosition sp = new SourcePosition(getName(), getContent(), lineno, -1, -1);\n      return new NodeRegion(compilerNode(), sp);\n    } else {\n      throw new UnsupportedOperationException(\"ast is not parse yet\");\n    }\n  }\n\n  private Node compilerNode() {\n    Node script = ast.getParent();\n    if (script != null && script.getType() == Token.SCRIPT) {\n      return script;\n    } else {\n      throw new IllegalStateException(\"getNodeParent: AST not yet generated\");\n    }\n  }\n\n  String getSourceName() {\n    return getName();\n  }\n\n  //------------------------------------------------------------------------\n  // Package-private helpers\n  //------------------------------------------------------------------------\n\n  @Override\n  Node getNodeForCodeInsertion(JSModule module) {\n    if (module == null) {\n      if (inputs.length == 0) {\n        throw new IllegalStateException(\"No inputs\");\n      }\n\n      return inputs[0].getAstRoot(this);\n    }\n\n    List<CompilerInput> inputs = module.getInputs();\n    if (inputs.size() > 0) {\n      return inputs.get(0).getAstRoot(this);\n    }\n\n    throw new IllegalStateException(\"Root module has no inputs\");\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..6a07dca6 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,290 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n+  public Region getSourceRegion(String sourceName, int lineNumber) {\n+    if (lineNumber < 1) {\n+      return null;\n+    }\n+    SourceFile input = getSourceFileByName(sourceName);\n+    if (input != null) {\n+      return input.getRegion(lineNumber);\n+    }\n+    return null;\n+  }\n \n-    checkFirstModule(modules);\n+  //------------------------------------------------------------------------\n+  // Package-private helpers\n+  //------------------------------------------------------------------------\n \n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n+  @Override\n+  Node getNodeForCodeInsertion(JSModule module) {\n+    if (module == null) {\n+      if (inputs.length == 0) {\n+        throw new IllegalStateException(\"No inputs\");\n+      }\n+\n+      return inputs[0].getAstRoot(this);\n+    }\n+\n+    List<CompilerInput> inputs = module.getInputs();\n+    if (inputs.size() > 0) {\n+      return inputs.get(0).getAstRoot(this);\n+    }\n+import java.util.List;\n+\n+import com.google.javascript.jscomp.CompilerInput;\n+import com.google.javascript.jscomp.Node;\n+import com.google.javascript.jscomp.SourceFile;\n+import com.google.javascript.rhino.Node.JSDocInfo;\n+import com.google.javascript.rhino.Node.Util;\n+import com.google.javascript.rhino.StaticSourceFile;\n+import com.google.javascript.rhino.Token;\n+\n+/**\n+ * A JavaScript file and its associated information.\n+ */\n+class InputFile extends SourceFile {\n+  static final long serialVersionUID = 1L;\n+\n+  // Required by SourceFile to resolve dependencies.\n+  JSModule module;\n+\n+  AntiochErrorReporter errorReporter;\n+\n+  private boolean isExtern;\n+  private boolean isPreloaded;\n+\n+  private JSDocInfo fileOverviewJSDocInfo;\n+  private boolean fileOverviewProcessed;\n+\n+  private Node ast;\n+  private boolean astComputed;\n+\n+  private RelativizePrefixMode relativizePrefixMode;\n+\n+  //------------------------------------------------------------------------\n+  // Constructors\n+  //------------------------------------------------------------------------\n+\n+  InputFile(String filename, String code) {\n+    this(filename, code, false);\n+  }\n+\n+  InputFile(String filename, String code, boolean isExtern) {\n+    super(filename, code);\n+    this.isExtern = isExtern;\n+    relativizePrefixMode = RelativizePrefixMode.PRESERVE;\n+    if (isExtern && !Reports.externDebugEnabled()) {\n+      trimContent();\n+    }\n+  }\n+\n+  //------------------------------------------------------------------------\n+  // Public Methods\n+  //------------------------------------------------------------------------\n+\n+  boolean isExtern() {\n+    return isExtern;\n+  }\n+\n+  void setPreloaded(boolean value) {\n+    isPreloaded = value;\n+  }\n+\n+  boolean isPreloaded() {\n+    return isPreloaded;\n+  }\n+\n+  // Lazily create file overview jsdoc.\n+  @Override\n+  public synchronized JSDocInfo getFileOverviewJSDocInfo() {\n+    if (!fileOverviewProcessed) {\n+      fileOverviewJSDocInfo = JSDocInfo.builderForFile().build();\n+      String content = getContent();\n+      int pos = 0;\n+      while (pos < content.length()) {\n+        // Fast-forward past whitespace and comments.\n+        while (TokenStream.isWhitespace(content.charAt(pos)))\n+          pos++;\n+        if (TokenStream.startsWith(\"/**\", content, pos)) {\n+          int endDocPos = TokenStream.findEndOfJSDocComment(content, pos);\n+          if (endDocPos != -1) {\n+            String docContent = content.substring(pos, endDocPos + 3);\n+            fileOverviewJSDocInfo = JSDocInfo.builderForFile().parse(docContent).build();\n+          }\n+          break;\n+        }\n+        if (TokenStream.startsWith(\"//\", content, pos)) {\n+          pos = content.indexOf('\\n', pos)+1;\n+          continue;\n+        }\n+        // Bail.\n+        break;\n+      }\n+\n+      fileOverviewProcessed = true;\n+    }\n+    return fileOverviewJSDocInfo;\n+  }\n+\n+  void setRelativizePrefixMode(RelativizePrefixMode relativizePrefixMode) {\n+    this.relativizePrefixMode = relativizePrefixMode;\n+  }\n+\n+  RelativizePrefixMode getRelativizePrefixMode() {\n+    return relativizePrefixMode;\n+  }\n+\n+  void resetAst() {\n+    astComputed = false;\n+  }\n+\n+  Node getAstRoot(Compiler compiler) {\n+    if (!astComputed) {\n+      parse(compiler);\n+    }\n+    return ast;\n+  }\n+\n+  @Override\n+  public StaticSourceFile getStaticSourceFile() {\n+    return new StaticSourceFile(getName(), getContent());\n+  }\n+\n+  //------------------------------------------------------------------------\n+  // Private Methods\n+  //------------------------------------------------------------------------\n+\n+  synchronized void parse(Compiler compiler) {\n     try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n+      astComputed = true;\n+      antiochSetAstRoot(compiler, parseAst(compiler));\n+      if (compiler.getOptions().useTypesForOptimization) {\n+        Util.markInferredTypesOnAst(ast, compiler.getTypeRegistry(), null);\n+      }\n+      setErrorTree(null);\n+    } catch (AntiochErrorReporter.ParsingError e) {\n+      setErrorTree(e.getNode());\n     }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n+  }\n \n-    initInputsByNameMap();\n+  private void antiochSetAstRoot(Compiler compiler, Node ast) {\n+    this.ast = ast;\n+    checkState(this.ast.getParent() == null, ast);\n+    this.ast.putProp(Node.SOURCEFILE_PROP, this);\n+    if (this.ast.getStaticSourceFile() == null) {\n+      this.ast.setStaticSourceFile(new StaticSourceFile(getName(), getContent()));\n+    }\n   }\n \n-  /**\n-   * Do any initialization that is dependent on the compiler options.\n-   */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n+  private void setErrorTree(Node n) {\n+    Node script = ast.getParent();\n+    if (script != null && script.getType() == Token.SCRIPT) {\n+      if (n == null) {\n+        n = new Node(Token.EMPTY);\n+      } else {\n+        errorReporter.report(n, ErrorLevel.ERROR, \"Parse error. Primary error at token\" +\n+            (n.getLineno() > 0 ? \" at index \" + n.getCharno() + \" of line \" + n.getLineno() : \"\") +\n+            \":\\n\" + errorReporter.getSourceLine(n) +\n+            \"\\nParsing stopped here because the source contains an error.\\n\" +\n+            \"The remaining portion of the source file was not parsed.\");\n+      }\n+      script.addChildrenToBack(n);\n+    }\n+  }\n+\n+  private Node parseAst(Compiler compiler) throws AntiochErrorReporter.ParsingError {\n+    Node jsRoot = compiler.parseInputs(Lists.newArrayList(this));\n+    \n+    if (compiler.getOptions().inferTypes) {\n+      // Synthesize function names where necessary, to facilitate better reports.\n+      new FunctionNamingCallback(compiler).process(jsRoot);\n+    }\n+\n+    // If this input file was loaded from a ZIP, some of the top-level\n+    // statements may not represent the start of a statement stream (that\n+    // is, come directly or indirectly from the top-level of their module).\n+    // So fix that now. Note that we invoke this even when running with new\n+    // type inference, not just the old type checker.\n+    new StatementFusion().process(null, jsRoot);\n+    return jsRoot;\n+  }\n+\n+  //------------------------------------------------------------------------\n+  // Node accessors/mutators\n+  //------------------------------------------------------------------------\n+\n+  void setPrologue(Node n) {\n+    ast.addChildrenToFront(n);\n+  }\n+\n+  Node getPrologue() {\n+    return ast.getFirstChild();\n+  }\n+\n+  void setBody(Node n) {\n+    ast.addChildToBack(n);\n+  }\n+\n+  Node getBody() {\n+    return ast.getLastChild();\n+  }\n+\n+  SourcePosition getNodePosition(Node n) {\n+    if (n.getLineno() == -1) {\n+      throw new IllegalArgumentException(\"Node has no source position\");\n+    }\n+    SourcePosition p = new SourcePosition(getName(), getContent(), n.getLineno(),\n+        n.getCharno(), -1);\n+    return p;\n+  }\n+\n+  Region getSourceRegion(int lineno) {\n+    if (astComputed) {\n+      SourcePosition sp = new SourcePosition(getName(), getContent(), lineno, -1, -1);\n+      return new NodeRegion(compilerNode(), sp);\n+    } else {\n+      throw new UnsupportedOperationException(\"ast is not parse yet\");\n     }\n   }\n \n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n+  private Node compilerNode() {\n+    Node script = ast.getParent();\n+    if (script != null && script.getType() == Token.SCRIPT) {\n+      return script;\n+    } else {\n+      throw new IllegalStateException(\"getNodeParent: AST not yet generated\");\n+    }\n+  }\n+\n+  String getSourceName() {\n+    return getName();\n+  }\n+\n+  //------------------------------------------------------------------------\n+  // Package-private helpers\n+  //------------------------------------------------------------------------\n+\n+  @Override\n+  Node getNodeForCodeInsertion(JSModule module) {\n+    if (module == null) {\n+      if (inputs.length == 0) {\n+        throw new IllegalStateException(\"No inputs\");\n+      }\n+\n+      return inputs[0].getAstRoot(this);\n+    }\n+\n+    List<CompilerInput> inputs = module.getInputs();\n+    if (inputs.size() > 0) {\n+      return inputs.get(0).getAstRoot(this);\n+    }\n+\n+    throw new IllegalStateException(\"Root module has no inputs\");\n+  }\n+}\n+    throw new IllegalStateException(\"Root module has no inputs\");\n+  }\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}