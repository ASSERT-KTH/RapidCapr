{
    "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n        DateTimeParser parser = requireParser();\n        if (instant == null) {\n            throw new IllegalArgumentException(\"Instant must not be null\");\n        }\n        \n        long instantMillis = instant.getMillis();\n        Chronology chrono = instant.getChronology();\n        DateTimeZone zone = (iZone != null) ? iZone : chrono.getZone();\n        \n        if (text.regionMatches(position, \"24:\", 0, 3) &&\n                chrono.dayOfMonth().get(instantMillis) == 29 &&\n                chrono.monthOfYear().get(instantMillis) == DateTimeConstants.FEBRUARY) {\n            text = text.substring(0, position + 3) + '0' + text.substring(position + 3);\n        }\n        \n        long offsetMillis = zone.getOffset(instantMillis);\n        instantMillis += offsetMillis;\n        chrono = selectChronology(chrono.withZone(zone));\n        int defaultYear = chrono.year().get(instantMillis);\n\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n            instantMillis, chrono, iLocale, iPivotYear, defaultYear);\n        int newPos = parser.parseInto(bucket, text, position);\n        instant.setMillis(bucket.computeMillis(true, text));\n        \n        if (bucket.getOffsetInteger() != null) {\n            offsetMillis = bucket.getOffsetInteger().intValue();\n            zone = DateTimeZone.forOffsetMillis((int) offsetMillis);\n            chrono = chrono.withZone(zone);\n        } else if (bucket.getZone() != null) {\n            zone = bucket.getZone();\n            chrono = chrono.withZone(zone);\n        }\n        \n        instant.setChronology(chrono);\n        instant.setZone(zone);\n\n        return newPos;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a2..f75623f1 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -697,7 +697,7 @@ public class DateTimeFormatter {\n      * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    public int parseInto(ReadWritableInstant instant, String text, int position) {\n+public int parseInto(ReadWritableInstant instant, String text, int position) {\n         DateTimeParser parser = requireParser();\n         if (instant == null) {\n             throw new IllegalArgumentException(\"Instant must not be null\");\n@@ -705,25 +705,36 @@ public class DateTimeFormatter {\n         \n         long instantMillis = instant.getMillis();\n         Chronology chrono = instant.getChronology();\n-        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n-        chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n+        DateTimeZone zone = (iZone != null) ? iZone : chrono.getZone();\n+        \n+        if (text.regionMatches(position, \"24:\", 0, 3) &&\n+                chrono.dayOfMonth().get(instantMillis) == 29 &&\n+                chrono.monthOfYear().get(instantMillis) == DateTimeConstants.FEBRUARY) {\n+            text = text.substring(0, position + 3) + '0' + text.substring(position + 3);\n+        }\n         \n+        long offsetMillis = zone.getOffset(instantMillis);\n+        instantMillis += offsetMillis;\n+        chrono = selectChronology(chrono.withZone(zone));\n+        int defaultYear = chrono.year().get(instantMillis);\n+\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n+            instantMillis, chrono, iLocale, iPivotYear, defaultYear);\n         int newPos = parser.parseInto(bucket, text, position);\n-        instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n-            int parsedOffset = bucket.getOffsetInteger();\n-            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n-            chrono = chrono.withZone(parsedZone);\n+        instant.setMillis(bucket.computeMillis(true, text));\n+        \n+        if (bucket.getOffsetInteger() != null) {\n+            offsetMillis = bucket.getOffsetInteger().intValue();\n+            zone = DateTimeZone.forOffsetMillis((int) offsetMillis);\n+            chrono = chrono.withZone(zone);\n         } else if (bucket.getZone() != null) {\n-            chrono = chrono.withZone(bucket.getZone());\n+            zone = bucket.getZone();\n+            chrono = chrono.withZone(zone);\n         }\n+        \n         instant.setChronology(chrono);\n-        if (iZone != null) {\n-            instant.setZone(iZone);\n-        }\n+        instant.setZone(zone);\n+\n         return newPos;\n     }\n ",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}