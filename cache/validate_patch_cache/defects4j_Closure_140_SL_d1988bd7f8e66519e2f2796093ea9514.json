{
    "patch": "import java.util.List;\n\npublic class ClosureCompiler extends AbstractCompiler {\n  private VariableMap topScope;\n\n  public ClosureCompiler() {\n    this(new DefaultCodingConvention());\n  }\n\n  //------------------------------------------------------------------------\n  // AbstractCompiler framework implementation\n  //------------------------------------------------------------------------\n\n  @Override\n  VariableMap getTopScope() {\n    if (topScope == null) {\n      topScope = new VariableMap();\n    }\n    return topScope;\n  }\n\n  @Override\n  JSModuleGraph getModuleGraph() {\n    if (externs != null) {\n      return GraphBuilder.buildGraph(compilerOptions.getWarningLevel());\n    } else {\n      return null;\n    }\n  }\n\n  @Override\n  Node parseInputs() {\n    // Generate an AST for the code.\n    Node root = new Node(Token.BLOCK);\n    if (inputs == null) {\n      return root;\n    }\n\n    for (CompilerInput input : inputs) {\n      Node scriptRoot = input.getAstRoot(this);\n      if (scriptRoot != null) {\n        root.addChildrenToBack(scriptRoot.removeChildren());\n      }\n    }\n\n    return root;\n  }\n\n  @Override\n  void prepareAst(Node root) {\n    if (externs != null) {\n      Node externAndJsRoot = root.getFirstChild();\n      if (externAndJsRoot == null) {\n        root.addChildToBack(externAndJsRoot = new Node(Token.BLOCK));\n      }\n      for (CompilerInput extern : externs) {\n        Node externRoot = extern.getAstRoot(this);\n        if (externRoot != null) {\n          externAndJsRoot.addChildToFront(externRoot);\n        }\n      }\n\n      if (compilerOptions.getDependencyOptions().isIncludeClosureDependencyPrimitives()) {\n        ClosureRewriteModule.rewrite(root, inputs, true);\n      }\n      if (noinjector) {\n        ProcessCommonJSModules.process(CommonJSModule.Type.NO_REQUIRE, root, null, null);\n      } else if (angularPass) {\n        ProcessCommonJSModules.process(CommonJSModule.Type.ANGULAR, root, null, null);\n      }\n\n    } else {\n      JSModuleGraph graph = getModuleGraph();\n      if (graph == null) {\n        return;\n      }\n\n      if (ClosureCheckModuleGraph.ERROR_REPORTER_ATTACHED_TO_PROCESSOR) {\n        CollectModuleMetadataProcessor.animate(graph);\n      }\n      Iterable<CompilerInput> moduleInputs;\n      ModuleLoader.LoaderCallback loaderCallback = null;\n      if (compilingTestCase) {\n        Set<CompilerInput> inputsSet = new HashSet<>(inputs);\n        // Hacky:  Create IntermediateCompilerPass and attach it to graph. Then scan all\n        //        inputs for references to IRFactory (which is a class from tools/parsing).\n        //        If any input references it, attach the compiler pass to that input's module.\n        //\n        graph.addCompilerPass(\n            new IntermediateCompilerPass(\n                compilerOptions,\n                new InternTable(),\n                this,\n                inputsSet,\n                /* externsInputs */ new ArrayList<>(),\n                (LevelBasedErrorManager) getErrorManager()));\n        for (CompilerInput input : inputs) {\n          if (input.getSourceFile().getCode().contains(\"IRFactory\")) {\n            for (JSModule module : graph.getAllModules()) {\n              if (module.getInput(input.getSourceFile().getName()) != null) {\n                module.getInput(input.getSourceFile().getName()).getModule().\n                    addPostprocess(new AstFactoryInsertionCallback(\n                        compilerOptions.getExtraAnnotationNames()));\n              }\n            }\n          }\n        }\n        moduleInputs = inputsSet;\n      } else {\n        final ImmutableSet<CompilerInput> inputsSet = ImmutableSet.copyOf(inputs);\n        loaderCallback =\n            new ModuleLoader.LoaderCallback() {\n              @Override\n              public CompilerInput loadModule(\n                  String filename, boolean isLibrary) throws IOException {\n                if (inputsSet.stream().anyMatch(input -> input.getName().equals(filename))) {\n                  for (CompilerInput input : inputsSet) {\n                    if (input.getName().equals(filename)) {\n                      return input;\n                    }\n                  }\n                  throw new AssertionError();\n                } else if (isLibrary) {\n                  return null;\n                } else {\n                  throw new FileNotFoundException(filename);\n                }\n              }\n            };\n        final ModuleLoader moduleLoader =\n            new ModuleLoader(\n                compilerOptions, this, loaderCallback, errorHandler);\n        moduleInputs =\n            Iterables.transform(\n                graph.getAllInputsInDepOrder(),\n                module -> moduleLoader.resolve(module, /* skipDeps */ false));\n      }\n\n      for (CompilerInput input : moduleInputs) {\n        Node moduleNode = input.getAstRoot(this);\n        checkState(moduleNode != null);  // inputs should already be compiled to ASTs\n        input.setJsModule(NodeUtil.getEnclosingScopeRoot(moduleNode));\n      }\n    }\n  }\n\n  @Override\n  void afterTreeCompiling(Node root) {\n    for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {\n      NodeUtil.markFunctionsDeleted(c, this);\n    }\n\n    runScriptPasses();\n\n    TranspileEs6SyntacticFeatures transpiler = null;\n    if (compilerOptions.needsTranspilationOf(FeatureSet.ES6_SYNTAX)) {\n      transpiler =\n          new TranspileEs6SyntacticFeatures(getTracer(), errorManager, getNodeToSourceMapper());\n    }\n    TranspileEs6TypedFeatures typedTranspiler = null;\n    if (compilerOptions.needsTranspilationOf(FeatureSet.ES6_TYPED)) {\n      typedTranspiler =\n          new TranspileEs6TypedFeatures(compilerOptions.getTranspileTypedFeaturesToEs6(), errorManager);\n    }\n    NodeTraversal.traverse(\n        this,\n        root,\n        new Es6SyntacticScopeCreator(compilerOptions, getUniqueNameIdSupplier()),\n        new TranspilationPass(\n            transpiler, typedTranspiler, getTracer(), errorManager, getNodeToSourceMapper()));\n  }\n\n  @Override\n  void afterParsing() {\n    if (getModuleGraph() != null) {\n      Set<JSModule> activeModules = getModuleGraph().manageDependencies(compilerOptions, inputs);\n      if (moduleResolutionMode == ModuleLoader.ResolutionMode.BROWSER) {\n        BrowserCallback browserCallback;\n        if (resolver != null) {\n          browserCallback = new BrowserCallback(resolver);\n        } else {\n          browserCallback = new BrowserCallback();\n        }\n        moduleLoader =\n            frontEnd.createBrowserLoader(\n                browserCallback,\n                moduleRoots,\n                this,\n                errorHandler,\n                getModuleGraph(),\n                compilerOptions.dependencyOptions.rootRelativePaths);\n      }\n      if (preprocessorSymbolTable != null) {\n        // That the symbol table is set indicates to the preprocessor that it should run.\n        ImmutableSet<CompilerInput> inputs = ImmutableSet.copyOf(this.inputs);\n        ImmutableSet<CompilerInput> externs = ImmutableSet.copyOf(this.externs);\n        if (compilingTestCase) {\n          inputs = ImmutableSet.copyOf(Iterables.filter(inputs, CompilerTestCase.TEST_EXTERNS_FILTER));\n          externs = ImmutableSet.copyOf(Iterables.filter(externs, CompilerTestCase.TEST_EXTERNS_FILTER));\n        }\n        CompilerInput[] inputArr = inputs.toArray(new CompilerInput[inputs.size()]);\n        CompilerInput[] externArr = externs.toArray(new CompilerInput[externs.size()]);\n\n        preprocessorSymbolTable.process(\n            inputArr,\n            externArr,\n            JsSourceType.JS,\n            getModuleGraph(),\n            activeModules,\n            this);\n        removeSyntheticVars(getRoot());\n      }\n    }\n    if (preprocessorSymbolTable != null) {\n      preprocessorSymbolTable.process(\n          inputs.stream()\n              .map(CompilerInput::getSourceFile)\n              .toArray(SourceFile[]::new),\n          externs.stream()\n              .map(CompilerInput::getSourceFile)\n              .toArray(SourceFile[]::new),\n          JsSourceType.JS);\n    }\n  }\n\n  @Override\n  void afterChecks(AbstractCompiler compiler) {\n    if (!compiler.hasHaltingErrors()) {\n      ImmutableList<CompilerPass> passes =\n          filters.convert(\n              ImmutableList.of(\n                  new CheckGlobalThis(compiler),\n                  new CheckMissingGetCssNameLevel(compiler),\n                  new CheckMissingReturn(compiler),\n                  new CheckPrimitiveAsObject(compiler),\n                  new CheckProvides(compiler),\n                  new CheckRequiresForConstructors(compiler, this),\n                  new CheckRestrictedKeywords(compiler),\n                  new CheckSoyNames(compiler),\n                  new CheckTypeImports(compiler),\n                  new CheckUndeclaredNames(compiler),\n                  new CheckUnreachableCode(compiler),\n                  new StrictWarningsCheck(compiler),\n                  new StrictModeCheck(compiler)));\n\n      NodeTraversal traverser = new NodeTraversal(compiler, passes);\n      Node root = compiler.getRoot();\n      traverser.traverse(root);\n    }\n    if (documentTitle != null) {\n      NodeTraversal.traverse(compiler, compiler.getRoot(), new DocumentTitleUpdater());\n    }\n\n    // Dig through the JSCompiler warnings and pull all of the ExternsValidationErrors out.\n    // Since this method is only called in DevMode, the approach of re-throwing\n    // the Errors is okay.\n    if (devMode) {\n      for (JSError error : ImmutableList.copyOf(getWarnings())) {\n        if (error instanceof ExternsValidationDetails.ExternsValidationErrors) {\n          throw (ExternsValidationDetails.ExternsValidationErrors) error;\n        }\n      }\n    }\n  }\n\n  @Override\n  public void beforePass(NodeTraversal t, CompilerPass pass) {\n    if (pass instanceof NameAnalyzer) {\n      ((NameAnalyzer) pass).injectScopedAliases(getAliasStrings());\n    }\n  }\n\n  private List<String> getAliasStrings() {\n    CodingConvention.ScopeAndRename[] renames = options.renamePrefixFunctions();\n    List<String> aliases = new ArrayList<>(renames.length * 2);\n    for (CodingConvention.ScopeAndRename rename : renames) {\n      String from =\n          rename.getScope() == null\n              ? rename.getOldName()\n              : rename.getScope() + '.' + rename.getOldName();\n      String to =\n          rename.getScope() == null\n              ? rename.getNewName()\n              : rename.getScope() + '.' + rename.getNewName();\n      aliases.add(from);\n      aliases.add(to);\n    }\n\n    return aliases;\n  }\n\n  @Override\n  void beforeCheckPass(NodeTraversal t, AbstractCompiler compiler) {\n    if (options.checkSymbols()) {\n      SymbolTable table = t.getScopeCreator().getSymbolTable();\n      TypeValidator validator = new TypeValidator(compiler, table);\n      Node root = compiler.getRoot();\n      NodeTraversal.traverse(compiler, root, validator);\n    }\n    if (options.checkTypes) {\n      TypeCheck tc = new TypeCheck(compiler);\n      NodeTraversal.traverse(compiler, root, tc);\n      tc.finishTypeCheck();\n    }\n    TypedScopeCreator scopeCreator =\n        options.checkTypes\n            ? new TypedScopeCreator(compiler, getRoot(), t.getScopeCreator().getAliasedLValueMap())\n            : new Es6SyntacticScopeCreator(compilerOptions, getUniqueNameIdSupplier());\n\n    t.getCompiler().pushChangeScope(getInputId(), getStaticSourceFile(getInputId()));\n    t.getCompiler().setChangeScopeRootNode(getRoot());\n    t.getCompiler().resetUniqueNameIdSupplier();\n    t.getCompiler().setUniqueNameIdSupplier(getUniqueNameIdSupplier());\n\n    t.setScopeCreator(scopeCreator);\n    t.getScopeCreator().injectAliases(getAliasStrings());\n    t.getScopeCreator().injectBuiltins(t.getCompiler().getTopScope());\n  }\n\n  @Override\n  void beforeHotSwap() {\n    // Build an object with the namespace contents of the entire program\n    for (Scope s : getTopScope().getChildren()) {\n      if (s.isBlockScope()) {\n        s.getAllSymbols().forEach(sym -> hotSwapGlobalNamespace.put(sym.getName(), sym));\n      }\n    }\n  }\n\n  @Override\n  @Nullable\n  DeclaredGlobalExterns onGetDeclaredGlobalExterns() {\n    ImmutableSet<DeclaredGlobalExterns> declaredGlobalExterns =\n        ImmutableSet.copyOf(Iterables.filter(inputs, DeclaredGlobalExterns.class));\n    if (declaredGlobalExterns.size() > 1) {\n      throw new IllegalStateException(\n          \"Internal Error: Multiple DeclaredGlobalExterns inputs: \" + declaredGlobalExterns);\n    } else if (declaredGlobalExterns.size() == 1) {\n      return Iterables.getOnlyElement(declaredGlobalExterns);\n    }\n    return null;\n  }\n\n  //------------------------------------------------------------------------\n  // Public API\n  //------------------------------------------------------------------------\n\n  /**\n   * Compiles a single JavaScript input string.\n   *\n   * @param source the JavaScript source\n   * @return A Result object containing the compiled AST and other data.\n   */\n  public Result compile(String source) {\n    return compile(SourceFile.fromCode(\"script.js\", source), (externs != null) ? externs : ImmutableList.of());\n  }\n\n  /**\n   * Compiles multiple JavaScript inputs provided as SourceFile objects.\n   *\n   * @return A Result object containing the compiled AST and other data.\n   */\n  public Result compile(Iterable<SourceFile> externs, Iterable<SourceFile> inputs) {\n    initializeMultipleInputs(externs, inputs);\n    return compileInternal();\n  }\n\n  /**\n   * Compiles a single JavaScript input file.\n   *\n   * @return A Result object containing the compiled AST and other data.\n   * @throws IOException if there was a problem reading the file\n   */\n  public Result compile(File extern, File input) throws IOException {\n    Iterable<SourceFile> externs = (extern != null) ? ImmutableList.of(SourceFile.fromFile(extern)) : ImmutableList.<SourceFile>of();\n    Iterable<SourceFile> inputs = ImmutableList.of(SourceFile.fromFile(input));\n    initializeMultipleInputs(externs, inputs);\n    return compileInternal();\n  }\n\n  /**\n   * Compiles a single JavaScript input file.\n   *\n   * @param path The path to the input file.\n   * @throws IOException if there was a problem reading the file\n   */\n  public Result compile(String path) throws IOException {\n    return compile(new File(path));\n  }\n\n  /**\n   * Compiles a single JavaScript input file.\n   *\n   * @param file The input file.\n   * @throws IOException if there was a problem reading the file\n   */\n  public Result compile(File file) throws IOException {\n    String fileName = file.getName();\n    SourceFile source =\n        SourceFile.fromFile(file, compilerOptions.inputCharset == null ? defaultCharset() : compilerOptions.inputCharset);\n    return compile(source, ImmutableList.copyOf(Iterables.concat(externs, preloadedInputs)),\n        fileName.endsWith(\"html.js\"), fileName.endsWith(\"css.js\"));\n  }\n\n  /**\n   * Compiles a single JavaScript input string.\n   *\n   * @param source the JavaScript source\n   * @param inputId a unique identifier for this source file, used in source maps\n   * @return A Result object containing the compiled AST and other data.\n   */\n  public Result compile(SourceFile source, String inputId) {\n    return compile(source, (externs != null) ? externs : ImmutableList.of(), inputId);\n  }\n\n  /**\n   * Compiles a single JavaScript input string.\n   *\n   * @param source the JavaScript source\n   * @param externs Any externs to use\n   * @return A Result object containing the compiled AST and other data.\n   */\n  public Result compile(SourceFile source, Iterable<SourceFile> externs) {\n    return compile(source, externs, Compiler.NULL_ERROR_HANDLER);\n  }\n\n  /**\n   * Compiles a single JavaScript input string.\n   *\n   * @param source the JavaScript source\n   * @param externs Any externs to use\n   * @param errorHandler error handler to use\n   * @return A Result object containing the compiled AST and other data.\n   */\n  public Result compile(SourceFile source, Iterable<SourceFile> externs, ErrorHandler errorHandler) {\n    initializeInputs(externs, ImmutableList.of(source));\n    this.errorHandler = errorHandler;\n    Result result = compileInternal();\n    errorHandler.generateReport();\n    return result;\n  }\n\n  /**\n   * Compiles a single JavaScript input string.\n   *\n   * @param source the JavaScript source\n   * @param externs Any externs to use\n   * @param cssInputs Any CSS inputs to use\n   * @return A Result object containing the compiled AST and other data.\n   */\n  public Result compile(SourceFile source, Iterable<SourceFile> externs, boolean isHtmlSource,\n      Iterable<SourceFile> cssInputs) {\n    initializeInputs(externs, ImmutableList.of(source));\n    this.cssInputs = ImmutableList.copyOf(cssInputs);\n    Result result = compileInternal();\n    for (SourceFile cssInput : cssInputs) {\n      checkNotNull(cssInput.getCode(), \"Code should not be null for CSS inputs. Check: %s\", cssInput.getName());\n      if (!parseTypedCss) {\n        GssParser parser = new GssParser(new SourceCode(null, cssInput.getCode()));\n        CssTree cssTree = parser.parse();\n        GssErrorManager errorManager = new GssErrorManager(parser);\n        if (errorManage",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/Compiler.java b/src/com/google/javascript/jscomp/Compiler.java\nindex d2524b4f..0cf8e225 100644\n--- a/src/com/google/javascript/jscomp/Compiler.java\n+++ b/src/com/google/javascript/jscomp/Compiler.java\n@@ -256,43 +256,499 @@ public class Compiler extends AbstractCompiler {\n   /**\n    * Initializes the instance state needed for a compile job.\n    */\n-  public void init(JSSourceFile[] externs, JSModule[] modules,\n-      CompilerOptions options) {\n-    initOptions(options);\n+  public Region getSourceRegion(String sourceName, int lineNumber) {\n+    if (lineNumber < 1) {\n+      return null;\n+    }\n+    SourceFile input = getSourceFileByName(sourceName);\n+    if (input != null) {\n+      return input.getRegion(lineNumber);\n+    }\n+    return null;\n+  }\n \n-    checkFirstModule(modules);\n+  //------------------------------------------------------------------------\n+  // Package-private helpers\n+  //------------------------------------------------------------------------\n \n-    this.externs = makeCompilerInput(externs, true);\n-    this.modules = modules;\n-    // Generate the module graph, and report any errors in the module\n-    // specification as errors.\n-    try {\n-      this.moduleGraph = new JSModuleGraph(modules);\n-    } catch (JSModuleGraph.ModuleDependenceException e) {\n-      // problems with the module format.  Report as an error.  The\n-      // message gives all details.\n-      report(JSError.make(MODULE_DEPENDENCY_ERROR,\n-          e.getModule().getName(), e.getDependentModule().getName()));\n-      return;\n+  @Override\n+  Node getNodeForCodeInsertion(JSModule module) {\n+    if (module == null) {\n+      if (inputs.length == 0) {\n+        throw new IllegalStateException(\"No inputs\");\n+      }\n+\n+      return inputs[0].getAstRoot(this);\n     }\n-    this.inputs = getAllInputsFromModules();\n-    initBasedOnOptions();\n \n-    initInputsByNameMap();\n+    List<CompilerInput> inputs = module.getInputs();\n+    if (inputs.size() > 0) {\n+      return inputs.get(0).getAstRoot(this);\n+    }\n+import java.util.List;\n+\n+public class ClosureCompiler extends AbstractCompiler {\n+  private VariableMap topScope;\n+\n+  public ClosureCompiler() {\n+    this(new DefaultCodingConvention());\n   }\n \n+  //------------------------------------------------------------------------\n+  // AbstractCompiler framework implementation\n+  //------------------------------------------------------------------------\n+\n+  @Override\n+  VariableMap getTopScope() {\n+    if (topScope == null) {\n+      topScope = new VariableMap();\n+    }\n+    return topScope;\n+  }\n+\n+  @Override\n+  JSModuleGraph getModuleGraph() {\n+    if (externs != null) {\n+      return GraphBuilder.buildGraph(compilerOptions.getWarningLevel());\n+    } else {\n+      return null;\n+    }\n+  }\n+\n+  @Override\n+  Node parseInputs() {\n+    // Generate an AST for the code.\n+    Node root = new Node(Token.BLOCK);\n+    if (inputs == null) {\n+      return root;\n+    }\n+\n+    for (CompilerInput input : inputs) {\n+      Node scriptRoot = input.getAstRoot(this);\n+      if (scriptRoot != null) {\n+        root.addChildrenToBack(scriptRoot.removeChildren());\n+      }\n+    }\n+\n+    return root;\n+  }\n+\n+  @Override\n+  void prepareAst(Node root) {\n+    if (externs != null) {\n+      Node externAndJsRoot = root.getFirstChild();\n+      if (externAndJsRoot == null) {\n+        root.addChildToBack(externAndJsRoot = new Node(Token.BLOCK));\n+      }\n+      for (CompilerInput extern : externs) {\n+        Node externRoot = extern.getAstRoot(this);\n+        if (externRoot != null) {\n+          externAndJsRoot.addChildToFront(externRoot);\n+        }\n+      }\n+\n+      if (compilerOptions.getDependencyOptions().isIncludeClosureDependencyPrimitives()) {\n+        ClosureRewriteModule.rewrite(root, inputs, true);\n+      }\n+      if (noinjector) {\n+        ProcessCommonJSModules.process(CommonJSModule.Type.NO_REQUIRE, root, null, null);\n+      } else if (angularPass) {\n+        ProcessCommonJSModules.process(CommonJSModule.Type.ANGULAR, root, null, null);\n+      }\n+\n+    } else {\n+      JSModuleGraph graph = getModuleGraph();\n+      if (graph == null) {\n+        return;\n+      }\n+\n+      if (ClosureCheckModuleGraph.ERROR_REPORTER_ATTACHED_TO_PROCESSOR) {\n+        CollectModuleMetadataProcessor.animate(graph);\n+      }\n+      Iterable<CompilerInput> moduleInputs;\n+      ModuleLoader.LoaderCallback loaderCallback = null;\n+      if (compilingTestCase) {\n+        Set<CompilerInput> inputsSet = new HashSet<>(inputs);\n+        // Hacky:  Create IntermediateCompilerPass and attach it to graph. Then scan all\n+        //        inputs for references to IRFactory (which is a class from tools/parsing).\n+        //        If any input references it, attach the compiler pass to that input's module.\n+        //\n+        graph.addCompilerPass(\n+            new IntermediateCompilerPass(\n+                compilerOptions,\n+                new InternTable(),\n+                this,\n+                inputsSet,\n+                /* externsInputs */ new ArrayList<>(),\n+                (LevelBasedErrorManager) getErrorManager()));\n+        for (CompilerInput input : inputs) {\n+          if (input.getSourceFile().getCode().contains(\"IRFactory\")) {\n+            for (JSModule module : graph.getAllModules()) {\n+              if (module.getInput(input.getSourceFile().getName()) != null) {\n+                module.getInput(input.getSourceFile().getName()).getModule().\n+                    addPostprocess(new AstFactoryInsertionCallback(\n+                        compilerOptions.getExtraAnnotationNames()));\n+              }\n+            }\n+          }\n+        }\n+        moduleInputs = inputsSet;\n+      } else {\n+        final ImmutableSet<CompilerInput> inputsSet = ImmutableSet.copyOf(inputs);\n+        loaderCallback =\n+            new ModuleLoader.LoaderCallback() {\n+              @Override\n+              public CompilerInput loadModule(\n+                  String filename, boolean isLibrary) throws IOException {\n+                if (inputsSet.stream().anyMatch(input -> input.getName().equals(filename))) {\n+                  for (CompilerInput input : inputsSet) {\n+                    if (input.getName().equals(filename)) {\n+                      return input;\n+                    }\n+                  }\n+                  throw new AssertionError();\n+                } else if (isLibrary) {\n+                  return null;\n+                } else {\n+                  throw new FileNotFoundException(filename);\n+                }\n+              }\n+            };\n+        final ModuleLoader moduleLoader =\n+            new ModuleLoader(\n+                compilerOptions, this, loaderCallback, errorHandler);\n+        moduleInputs =\n+            Iterables.transform(\n+                graph.getAllInputsInDepOrder(),\n+                module -> moduleLoader.resolve(module, /* skipDeps */ false));\n+      }\n+\n+      for (CompilerInput input : moduleInputs) {\n+        Node moduleNode = input.getAstRoot(this);\n+        checkState(moduleNode != null);  // inputs should already be compiled to ASTs\n+        input.setJsModule(NodeUtil.getEnclosingScopeRoot(moduleNode));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  void afterTreeCompiling(Node root) {\n+    for (Node c = root.getFirstChild(); c != null; c = c.getNext()) {\n+      NodeUtil.markFunctionsDeleted(c, this);\n+    }\n+\n+    runScriptPasses();\n+\n+    TranspileEs6SyntacticFeatures transpiler = null;\n+    if (compilerOptions.needsTranspilationOf(FeatureSet.ES6_SYNTAX)) {\n+      transpiler =\n+          new TranspileEs6SyntacticFeatures(getTracer(), errorManager, getNodeToSourceMapper());\n+    }\n+    TranspileEs6TypedFeatures typedTranspiler = null;\n+    if (compilerOptions.needsTranspilationOf(FeatureSet.ES6_TYPED)) {\n+      typedTranspiler =\n+          new TranspileEs6TypedFeatures(compilerOptions.getTranspileTypedFeaturesToEs6(), errorManager);\n+    }\n+    NodeTraversal.traverse(\n+        this,\n+        root,\n+        new Es6SyntacticScopeCreator(compilerOptions, getUniqueNameIdSupplier()),\n+        new TranspilationPass(\n+            transpiler, typedTranspiler, getTracer(), errorManager, getNodeToSourceMapper()));\n+  }\n+\n+  @Override\n+  void afterParsing() {\n+    if (getModuleGraph() != null) {\n+      Set<JSModule> activeModules = getModuleGraph().manageDependencies(compilerOptions, inputs);\n+      if (moduleResolutionMode == ModuleLoader.ResolutionMode.BROWSER) {\n+        BrowserCallback browserCallback;\n+        if (resolver != null) {\n+          browserCallback = new BrowserCallback(resolver);\n+        } else {\n+          browserCallback = new BrowserCallback();\n+        }\n+        moduleLoader =\n+            frontEnd.createBrowserLoader(\n+                browserCallback,\n+                moduleRoots,\n+                this,\n+                errorHandler,\n+                getModuleGraph(),\n+                compilerOptions.dependencyOptions.rootRelativePaths);\n+      }\n+      if (preprocessorSymbolTable != null) {\n+        // That the symbol table is set indicates to the preprocessor that it should run.\n+        ImmutableSet<CompilerInput> inputs = ImmutableSet.copyOf(this.inputs);\n+        ImmutableSet<CompilerInput> externs = ImmutableSet.copyOf(this.externs);\n+        if (compilingTestCase) {\n+          inputs = ImmutableSet.copyOf(Iterables.filter(inputs, CompilerTestCase.TEST_EXTERNS_FILTER));\n+          externs = ImmutableSet.copyOf(Iterables.filter(externs, CompilerTestCase.TEST_EXTERNS_FILTER));\n+        }\n+        CompilerInput[] inputArr = inputs.toArray(new CompilerInput[inputs.size()]);\n+        CompilerInput[] externArr = externs.toArray(new CompilerInput[externs.size()]);\n+\n+        preprocessorSymbolTable.process(\n+            inputArr,\n+            externArr,\n+            JsSourceType.JS,\n+            getModuleGraph(),\n+            activeModules,\n+            this);\n+        removeSyntheticVars(getRoot());\n+      }\n+    }\n+    if (preprocessorSymbolTable != null) {\n+      preprocessorSymbolTable.process(\n+          inputs.stream()\n+              .map(CompilerInput::getSourceFile)\n+              .toArray(SourceFile[]::new),\n+          externs.stream()\n+              .map(CompilerInput::getSourceFile)\n+              .toArray(SourceFile[]::new),\n+          JsSourceType.JS);\n+    }\n+  }\n+\n+  @Override\n+  void afterChecks(AbstractCompiler compiler) {\n+    if (!compiler.hasHaltingErrors()) {\n+      ImmutableList<CompilerPass> passes =\n+          filters.convert(\n+              ImmutableList.of(\n+                  new CheckGlobalThis(compiler),\n+                  new CheckMissingGetCssNameLevel(compiler),\n+                  new CheckMissingReturn(compiler),\n+                  new CheckPrimitiveAsObject(compiler),\n+                  new CheckProvides(compiler),\n+                  new CheckRequiresForConstructors(compiler, this),\n+                  new CheckRestrictedKeywords(compiler),\n+                  new CheckSoyNames(compiler),\n+                  new CheckTypeImports(compiler),\n+                  new CheckUndeclaredNames(compiler),\n+                  new CheckUnreachableCode(compiler),\n+                  new StrictWarningsCheck(compiler),\n+                  new StrictModeCheck(compiler)));\n+\n+      NodeTraversal traverser = new NodeTraversal(compiler, passes);\n+      Node root = compiler.getRoot();\n+      traverser.traverse(root);\n+    }\n+    if (documentTitle != null) {\n+      NodeTraversal.traverse(compiler, compiler.getRoot(), new DocumentTitleUpdater());\n+    }\n+\n+    // Dig through the JSCompiler warnings and pull all of the ExternsValidationErrors out.\n+    // Since this method is only called in DevMode, the approach of re-throwing\n+    // the Errors is okay.\n+    if (devMode) {\n+      for (JSError error : ImmutableList.copyOf(getWarnings())) {\n+        if (error instanceof ExternsValidationDetails.ExternsValidationErrors) {\n+          throw (ExternsValidationDetails.ExternsValidationErrors) error;\n+        }\n+      }\n+    }\n+  }\n+\n+  @Override\n+  public void beforePass(NodeTraversal t, CompilerPass pass) {\n+    if (pass instanceof NameAnalyzer) {\n+      ((NameAnalyzer) pass).injectScopedAliases(getAliasStrings());\n+    }\n+  }\n+\n+  private List<String> getAliasStrings() {\n+    CodingConvention.ScopeAndRename[] renames = options.renamePrefixFunctions();\n+    List<String> aliases = new ArrayList<>(renames.length * 2);\n+    for (CodingConvention.ScopeAndRename rename : renames) {\n+      String from =\n+          rename.getScope() == null\n+              ? rename.getOldName()\n+              : rename.getScope() + '.' + rename.getOldName();\n+      String to =\n+          rename.getScope() == null\n+              ? rename.getNewName()\n+              : rename.getScope() + '.' + rename.getNewName();\n+      aliases.add(from);\n+      aliases.add(to);\n+    }\n+\n+    return aliases;\n+  }\n+\n+  @Override\n+  void beforeCheckPass(NodeTraversal t, AbstractCompiler compiler) {\n+    if (options.checkSymbols()) {\n+      SymbolTable table = t.getScopeCreator().getSymbolTable();\n+      TypeValidator validator = new TypeValidator(compiler, table);\n+      Node root = compiler.getRoot();\n+      NodeTraversal.traverse(compiler, root, validator);\n+    }\n+    if (options.checkTypes) {\n+      TypeCheck tc = new TypeCheck(compiler);\n+      NodeTraversal.traverse(compiler, root, tc);\n+      tc.finishTypeCheck();\n+    }\n+    TypedScopeCreator scopeCreator =\n+        options.checkTypes\n+            ? new TypedScopeCreator(compiler, getRoot(), t.getScopeCreator().getAliasedLValueMap())\n+            : new Es6SyntacticScopeCreator(compilerOptions, getUniqueNameIdSupplier());\n+\n+    t.getCompiler().pushChangeScope(getInputId(), getStaticSourceFile(getInputId()));\n+    t.getCompiler().setChangeScopeRootNode(getRoot());\n+    t.getCompiler().resetUniqueNameIdSupplier();\n+    t.getCompiler().setUniqueNameIdSupplier(getUniqueNameIdSupplier());\n+\n+    t.setScopeCreator(scopeCreator);\n+    t.getScopeCreator().injectAliases(getAliasStrings());\n+    t.getScopeCreator().injectBuiltins(t.getCompiler().getTopScope());\n+  }\n+\n+  @Override\n+  void beforeHotSwap() {\n+    // Build an object with the namespace contents of the entire program\n+    for (Scope s : getTopScope().getChildren()) {\n+      if (s.isBlockScope()) {\n+        s.getAllSymbols().forEach(sym -> hotSwapGlobalNamespace.put(sym.getName(), sym));\n+      }\n+    }\n+  }\n+\n+  @Override\n+  @Nullable\n+  DeclaredGlobalExterns onGetDeclaredGlobalExterns() {\n+    ImmutableSet<DeclaredGlobalExterns> declaredGlobalExterns =\n+        ImmutableSet.copyOf(Iterables.filter(inputs, DeclaredGlobalExterns.class));\n+    if (declaredGlobalExterns.size() > 1) {\n+      throw new IllegalStateException(\n+          \"Internal Error: Multiple DeclaredGlobalExterns inputs: \" + declaredGlobalExterns);\n+    } else if (declaredGlobalExterns.size() == 1) {\n+      return Iterables.getOnlyElement(declaredGlobalExterns);\n+    }\n+    return null;\n+  }\n+\n+  //------------------------------------------------------------------------\n+  // Public API\n+  //------------------------------------------------------------------------\n+\n   /**\n-   * Do any initialization that is dependent on the compiler options.\n+   * Compiles a single JavaScript input string.\n+   *\n+   * @param source the JavaScript source\n+   * @return A Result object containing the compiled AST and other data.\n    */\n-  private void initBasedOnOptions() {\n-    // Create the source map if necessary.\n-    if (options.sourceMapOutputPath != null) {\n-      sourceMap = new SourceMap();\n-    }\n+  public Result compile(String source) {\n+    return compile(SourceFile.fromCode(\"script.js\", source), (externs != null) ? externs : ImmutableList.of());\n+  }\n+\n+  /**\n+   * Compiles multiple JavaScript inputs provided as SourceFile objects.\n+   *\n+   * @return A Result object containing the compiled AST and other data.\n+   */\n+  public Result compile(Iterable<SourceFile> externs, Iterable<SourceFile> inputs) {\n+    initializeMultipleInputs(externs, inputs);\n+    return compileInternal();\n+  }\n+\n+  /**\n+   * Compiles a single JavaScript input file.\n+   *\n+   * @return A Result object containing the compiled AST and other data.\n+   * @throws IOException if there was a problem reading the file\n+   */\n+  public Result compile(File extern, File input) throws IOException {\n+    Iterable<SourceFile> externs = (extern != null) ? ImmutableList.of(SourceFile.fromFile(extern)) : ImmutableList.<SourceFile>of();\n+    Iterable<SourceFile> inputs = ImmutableList.of(SourceFile.fromFile(input));\n+    initializeMultipleInputs(externs, inputs);\n+    return compileInternal();\n+  }\n+\n+  /**\n+   * Compiles a single JavaScript input file.\n+   *\n+   * @param path The path to the input file.\n+   * @throws IOException if there was a problem reading the file\n+   */\n+  public Result compile(String path) throws IOException {\n+    return compile(new File(path));\n+  }\n+\n+  /**\n+   * Compiles a single JavaScript input file.\n+   *\n+   * @param file The input file.\n+   * @throws IOException if there was a problem reading the file\n+   */\n+  public Result compile(File file) throws IOException {\n+    String fileName = file.getName();\n+    SourceFile source =\n+        SourceFile.fromFile(file, compilerOptions.inputCharset == null ? defaultCharset() : compilerOptions.inputCharset);\n+    return compile(source, ImmutableList.copyOf(Iterables.concat(externs, preloadedInputs)),\n+        fileName.endsWith(\"html.js\"), fileName.endsWith(\"css.js\"));\n+  }\n+\n+  /**\n+   * Compiles a single JavaScript input string.\n+   *\n+   * @param source the JavaScript source\n+   * @param inputId a unique identifier for this source file, used in source maps\n+   * @return A Result object containing the compiled AST and other data.\n+   */\n+  public Result compile(SourceFile source, String inputId) {\n+    return compile(source, (externs != null) ? externs : ImmutableList.of(), inputId);\n+  }\n+\n+  /**\n+   * Compiles a single JavaScript input string.\n+   *\n+   * @param source the JavaScript source\n+   * @param externs Any externs to use\n+   * @return A Result object containing the compiled AST and other data.\n+   */\n+  public Result compile(SourceFile source, Iterable<SourceFile> externs) {\n+    return compile(source, externs, Compiler.NULL_ERROR_HANDLER);\n+  }\n+\n+  /**\n+   * Compiles a single JavaScript input string.\n+   *\n+   * @param source the JavaScript source\n+   * @param externs Any externs to use\n+   * @param errorHandler error handler to use\n+   * @return A Result object containing the compiled AST and other data.\n+   */\n+  public Result compile(SourceFile source, Iterable<SourceFile> externs, ErrorHandler errorHandler) {\n+    initializeInputs(externs, ImmutableList.of(source));\n+    this.errorHandler = errorHandler;\n+    Result result = compileInternal();\n+    errorHandler.generateReport();\n+    return result;\n   }\n \n-  private CompilerInput[] makeCompilerInput(\n-      JSSourceFile[] files, boolean isExtern) {\n+  /**\n+   * Compiles a single JavaScript input string.\n+   *\n+   * @param source the JavaScript source\n+   * @param externs Any externs to use\n+   * @param cssInputs Any CSS inputs to use\n+   * @return A Result object containing the compiled AST and other data.\n+   */\n+  public Result compile(SourceFile source, Iterable<SourceFile> externs, boolean isHtmlSource,\n+      Iterable<SourceFile> cssInputs) {\n+    initializeInputs(externs, ImmutableList.of(source));\n+    this.cssInputs = ImmutableList.copyOf(cssInputs);\n+    Result result = compileInternal();\n+    for (SourceFile cssInput : cssInputs) {\n+      checkNotNull(cssInput.getCode(), \"Code should not be null for CSS inputs. Check: %s\", cssInput.getName());\n+      if (!parseTypedCss) {\n+        GssParser parser = new GssParser(new SourceCode(null, cssInput.getCode()));\n+        CssTree cssTree = parser.parse();\n+        GssErrorManager errorManager = new GssErrorManager(parser);\n+        if (errorManage\n+    throw new IllegalStateException(\"Root module has no inputs\");\n+  }\n     CompilerInput [] inputs = new CompilerInput[files.length];\n     for (int i = 0; i < files.length; ++i) {\n       inputs[i] = new CompilerInput(files[i], isExtern);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}