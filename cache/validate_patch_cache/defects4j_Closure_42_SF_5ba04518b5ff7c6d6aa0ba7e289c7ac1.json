{
    "patch": "public class IRFactory extends Parser {\n  \n  private static final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\n    \"use strict\" // only directive currently supported in JS\n    // add more as needed\n  );\n\n  private final ErrorReporter errorReporter;\n\n  IRFactory(ErrorReporter errorReporter, String sourceName) {\n    super(new CompilerEnvirons(), errorReporter);\n    this.errorReporter = errorReporter;\n    CompilerEnvirons env = getCompilerEnvirons();\n    env.initFromOptions(ImmutableList.of(\"-languageIn\", \"ECMASCRIPT6\", \"-languageOut\", \"ECMASCRIPT6\", \"-strictMode\", \"true\"));\n    // Do not tolerate errors.\n    env.setRecoverFromErrors(false);\n    env.setGenerateDebugInfo(true);\n    new Parser().setCompilerEnvirons(env);\n    setSourceName(sourceName);\n  }\n\n  @Override\n  Node parse(Reader reader, String sourceName) throws IOException {\n    return super.parse(reader, sourceName);\n  }\n\n  private interface TransformDispatcher<T extends Node> {\n    Node process(T node);\n  }\n\n  private class IRTransformDispatcher implements TypeSafeDispatcher, JSDocInfoAwareTransformer {\n    @Override\n    public Node transform(NodeTraversal t, Node n) {\n      Node result = null;\n      switch (n.getToken()) {\n        // Traverse function body\n        case FUNCTION:\n        case ARROW_FUNCTION:\n          Node body = n.getLastChild();\n          if (body.isBlock()) {\n            result = transform(body);\n          } else {\n            Node newBlock = newNode(Token.BLOCK);\n            body.replaceWith(newBlock);\n            newBlock.addChildToBack(body);\n            result = transform(body);\n          }\n          break;\n\n        // Skip property declarations\n        case MEMBER_VARIABLE_DEF:\n          // Handles ES6 class instance (non-static) field declarations\n          result = newNode(Token.EMPTY).srcrefTree(n);\n          break;\n\n        default:\n          // Continue traversal as normal\n          result = process(n);\n          break;\n      }\n      setJSDocInfo(result, getJSDocInfo(n));\n      return result;\n    }\n\n    // Convenience method to handle Directive, ExpressionStatement, and EmptyExpression nodes\n    private Node processGeneric(Node n) {\n      if (isDirective(n)) {\n        return new Node(Token.EMPTY);\n      } else if (n.isExprResult()) {\n        return transform(n.getFirstChild());\n      } else {\n        return n;\n      }\n    }\n  \n    private boolean isDirective(Node n) {\n      if (n == null) return false;\n\n      int nType = n.getToken();\n      return nType == Token.EXPR_RESULT &&\n          n.getFirstChild().isString() &&\n          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n    }\n  \n    private final TransformDispatcher<Node> dispatcher = new TransformDispatcher<Node>() {\n      @Override\n      public Node process(Node n) {\n        switch (n.getToken()) {\n          case SCRIPT:\n          case BLOCK:\n            Node newBlock = newNode(n.getToken());\n            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n              newBlock.addChildToBack(transform(c));\n            }\n            return newBlock;\n\n          case FUNCTION:\n          case ARROW_FUNCTION:\n            return newNode(n.getToken(), n.getFirstChild(), transformBlock(n.getLastChild()));\n\n          case RETURN:\n            return new Node(Token.RETURN, transform(n.getFirstChild()));\n\n          case NAME:\n          case STRING:\n          case NUMBER:\n          case REGEXP:\n          case TEMPLATELIT_STRING:\n            return n;\n\n          case CAST:\n            checkState(n.getChildCount() == 1);\n            return transform(n.getFirstChild());\n\n          case EXPR_RESULT:\n            return transform(n.getFirstChild());\n\n          case CLASS:\n            Node name = null;\n            for (Node member = n.getFirstChild(); member != null; member = member.getNext()) {\n              if (member.isStaticMember() || member.isMemberFunctionDef()) {\n                continue;\n              } else if (member.isMemberVariableDef()) {\n                Node newMember = newNode(Token.MEMBER_VARIABLE_DEF);\n                newMember.addChildrenToBack(transform(member.getFirstChild()), transform(member.getSecondChild()));\n                if (member.getBooleanProp(Node.COMPUTED_PROP_GETTER) || member.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {\n                  newMember.setComputedPropGetter(member.getBooleanProp(Node.COMPUTED_PROP_GETTER))\n                      .setComputedPropSetter(member.getBooleanProp(Node.COMPUTED_PROP_SETTER))\n                      .putBooleanProp(Node.COMPUTED_PROP, true);\n                  newMember.setProp(Node.ACCESS_MODIFIER, member.getProp(Node.ACCESS_MODIFIER));\n                }\n                if (member.isOptionalArg()) {\n                  newMember.putBooleanProp(Node.OPT_ES6_TYPED, true);\n                  newMember.putProp(Node.OPT_DUMMY, NodeUtil.emptyFunction());\n                }\n                if (member.getJSDocInfo() != null) {\n                  newMember.setJSDocInfo(member.getJSDocInfo());\n                }\n                if (name != null) {\n                  newMember.putProp(Node.CLASS_NAME, name);\n                  newMember.setStaticMember(false);\n                }\n                return new MemberDefinitionTransformDispatcher().process(newMember);\n              } else {\n                checkState(member.isClassMembers());\n                if (member.isStatic()) {\n                  continue;\n                }\n                Node memberClone = member.cloneNode();\n                memberClone.setStaticMember(true);\n                Node newMember = newNode(Token.EXPR_RESULT, memberClone);\n                if (name != null) {\n                  newMember.putProp(Node.CLASS_NAME, name);\n                }\n                if (newMember.getBooleanProp(Node.COMPUTED_PROP_GETTER) || newMember.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {\n                  newMember.setBooleanProp(Node.COMPUTED_PROP, true);\n                }\n                newMember.setLineno(member.getLineno()).setCharno(member.getCharno());\n                return transform(newMember);\n              }\n            }\n            return n;\n\n          case CLASS_MEMBERS:\n            Node newMembers = newNode(Token.CLASS_MEMBERS);\n            for (Node member = n.getFirstChild(); member != null; member = member.getNext()) {\n              newMembers.addChildToBack(transform(member));\n            }\n            return newMembers;\n\n          case GETPROP:\n          case GETELEM:\n          case IMPORT:\n            return new Node(Token.EMPTY);\n\n          case HOOK:\n            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getSecondChild()), transform(n.getLastChild()));\n\n          case AND:\n          case OR:\n          case COALESCE:\n          case ASSIGN:\n          case ASSIGN_BITOR:\n          case ASSIGN_BITXOR:\n          case ASSIGN_BITAND:\n          case ASSIGN_LSH:\n          case ASSIGN_RSH:\n          case ASSIGN_URSH:\n          case ASSIGN_ADD:\n          case ASSIGN_SUB:\n          case ASSIGN_MUL:\n          case ASSIGN_DIV:\n          case ASSIGN_MOD:\n            return newNode(n.getToken(),\n                transform(n.getFirstChild()),\n                transform(n.getLastChild()));\n\n          case CALL:\n            Node callee = transform(n.getFirstChild());\n            if (callee.getString().equals(\"goog.inherits\")) {\n              return new Node(Token.EMPTY);\n            }\n            Node call = new Node(Token.CALL, callee);\n            for (Node arg = n.getSecondChild(); arg != null; arg = arg.getNext()) {\n              call.addChildToBack(transform(arg));\n            }\n            return call;\n\n          case NEW:\n            Node constructor = transform(n.getFirstChild());\n            Node newInstance = new Node(Token.NEW, constructor);\n            for (Node arg = n.getSecondChild(); arg != null; arg = arg.getNext()) {\n              newInstance.addChildToBack(transform(arg));\n            }\n            return newInstance;\n\n          case DELPROP:\n            return new Node(Token.EMPTY);\n\n          case STRING_KEY:\n          case NUMBER_ELEMENT:\n            return n;\n\n          case ARRAYLIT:\n          case OBJECTLIT:\n          case CLASS_MEMBERS_DECL:\n          case COMPUTED_PROP:\n            return processGeneric(n);\n\n          case TEMPLATELIT:\n            return newNode(n.getToken());\n\n          case SUPER:\n            return new Node(Token.EMPTY);\n\n          case TEMPLATELIT_SUB:\n            return processGeneric(n).detach();\n\n          case LET:\n            n.setType(Token.VAR);\n            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n              child.setType(Token.NAME);\n            }\n            return n;\n\n          case VAR:\n            for (Node child : children(n)) {\n              if (child.hasChildren()) {\n                child.getLastChild().replaceWith(transform(child.getLastChild()));\n              }\n            }\n            return n;\n\n          case THROW:\n            return newNode(Token.THROW, transform(n.getFirstChild()));\n\n          case TRY:\n            Node tryBlock = transform(n.getFirstChild());\n            Node catchBlock = n.getSecondChild();\n            Node finallyBlock = n.getLastChild();\n            if (finallyBlock != null) {\n              finallyBlock = transform(finallyBlock);\n            }\n            if (catchBlock != null) {\n              Node catchVarName = catchBlock.getFirstChild();\n              if (catchVarName.getType() == Token.LET) {\n                catchVarName.setType(Token.NAME);\n                for (Node child = catchVarName.getFirstChild(); child != null; child = child.getNext()) {\n                  child.setType(Token.NAME);\n                }\n              }\n              catchBlock = transform(catchBlock);\n            }\n            return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n\n          case THROW_NEW:\n            Node errorName = transform(n.getFirstChild());\n            // ThrowSite translates properly to a call in ES6\n            Node newError = new Node(Token.NEW, errorName);\n            newError.copyInformationFromForTree(n);\n            return process(new Node(Token.THROW, newError).srcref(n));\n\n          case CONDITIONAL:\n            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getSecondChild()), transform(n.getLastChild()));\n\n          case SWITCH:\n            Node newSwitch = new Node(Token.SWITCH, transform(n.getFirstChild()));\n            for (Node child = n.getSecondChild(); child != null; child = child.getNext()) {\n              if (child.isCase()) {\n                Node newCase = new Node(Token.CASE, transform(child.getFirstChild()));\n                newSwitch.addChildToBack(newCase);\n                for (Node grandchild = child.getSecondChild(); grandchild != null; grandchild = grandchild.getNext()) {\n                  newCase.addChildToBack(transform(grandchild));\n                }\n              } else if (child.getToken() == Token.DEFAULT_CASE) {\n                Node newDefault = new Node(Token.DEFAULT_CASE);\n                for (Node grandchild = child.getFirstChild(); grandchild != null; grandchild = grandchild.getNext()) {\n                  newDefault.addChildToBack(transform(grandchild));\n                }\n                newSwitch.addChildToBack(newDefault);\n              } else {\n                throw new IllegalStateException(\"Switch child not switch case or default case: \" + child);\n              }\n            }\n            return newSwitch;\n\n          case CASE:\n          case DEFAULT_CASE:\n            throw new IllegalStateException(\"Case node not in switch: \" + n);\n\n          case WHILE:\n            return newNode(Token.WHILE, transform(n.getFirstChild()), transformBlock(n.getLastChild()));\n\n          case DO:\n            return processDoLoop(n);\n\n          case FOR:\n            Node forKid = n.getFirstChild();\n            Node init = null;\n            Node cond = null;\n            Node incr = null;\n            if (forKid != null) {\n              init = transform(forKid);\n              forKid = forKid.getNext();\n            }\n            if (forKid != null) {\n              cond = transform(forKid);\n              forKid = forKid.getNext();\n            }\n            if (forKid != null) {\n              incr = transform(forKid);\n              forKid = forKid.getNext();\n            }\n            Node body = transform(forKid);\n            return new Node(Token.FOR, init, cond, incr, body);\n\n          case FOR_IN:\n            Node lhs = transform(n.getFirstChild());\n            Node obj = transform(n.getSecondChild());\n            Node body2 = transform(n.getLastChild());\n\n            if (lhs.getType() == Token.VAR) {\n              lhs.setType(Token.LET);\n              for (Node c = lhs.getFirstChild(); c != null; c = c.getNext()) {\n                c.setType(Token.LET);\n              }\n            }\n            return newNode(Token.FOR_OF, lhs, obj, body2);\n\n          case BREAK:\n            return processBreakStatement(n);\n\n          case CONTINUE:\n            return processContinueStatement(n);\n\n          case EMPTY:\n            return processGeneric(n);\n\n          case DEBUGGER:\n            return n;\n\n          case DOT:\n            return n;\n\n          case LABEL:\n            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getLastChild()));\n\n          case LSH:\n          case RSH:\n          case URSH:\n          case AND_EQ:\n          case OR_EQ:\n          case XOR_EQ:\n          case ADD_EQ:\n          case SUB_EQ:\n          case MUL_EQ:\n          case DIV_EQ:\n          case MOD_EQ:\n            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getLastChild()));\n\n          case GT:\n          case LT:\n          case GE:\n          case LE:\n          case EQ:\n          case NE:\n          case SHEQ:\n          case SHNE:\n          case INSTANCEOF:\n          case IN:\n          case OR:\n          case AND:\n          case BITOR:\n          case BITAND:\n          case BITXOR:\n          case ADD:\n          case SUB:\n          case MUL:\n          case DIV:\n          case MOD:\n            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getLastChild()));\n\n          case NOT:\n          case NEG:\n          case POS:\n          case BITNOT:\n          case TypeOf:\n          case VOID:\n          case DEC:\n          case INC:\n            return newNode(n.getToken(), transform(n.getFirstChild()));\n\n          case ARRAY_PATTERN:\n            return newNode(Token.ARRAY_PATTERN, transformArrayPattern(n));\n\n          case OBJECT_PATTERN:\n            return newNode(Token.OBJECT_PATTERN, transformObjectPattern(n));\n\n          case REST:\n            return newNode(Token.REST, transform(n.getFirstChild()));\n\n          case COMPUTED_PROP: {\n            Node propName = transform(n.getFirstChild());\n            Node value = transform(n.getSecondChild());\n            return new Node(Token.COMPUTED_PROP, propName, value);\n          }\n          case COMPUTED_GETPROP: {\n            Node base1 = transform(n.getFirstChild());\n            Node propName1 = transform(n.getLastChild());\n            return new Node(Token.GETELEM, base1, propName1);\n          }\n          case COMPUTED_SETPROP: {\n            Node base2 = transform(n.getFirstChild());\n            Node propName2 = transform(n.getSecondChild());\n            Node value1 = transform(n.getLastChild());\n            return new Node(Token.SETELEM, base2, propName2, value1);\n          }\n          case OBJECTLIT_PROP:\n            if (NodeUtil.isObjectLiteralGetOrSetKey(n)) {\n              return new Node(Token.GETTER_DEF, n.removeFirstChild(), transformFunctionBody(n.getFirstChild()));\n            } else if (NodeUtil.isObjectLiteralSetterKey(n)) {\n              return new Node(Token.SETTER_DEF, n.removeFirstChild(), n.getFirstChild(), transformFunctionBody(n.getLastChild()));\n            } else {\n              return ne",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..cc88660d 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,106 +473,450 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n-\n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+public class IRFactory extends Parser {\n+  \n+  private static final Set<String> ALLOWED_DIRECTIVES = ImmutableSet.of(\n+    \"use strict\" // only directive currently supported in JS\n+    // add more as needed\n+  );\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+  private final ErrorReporter errorReporter;\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n-    }\n+  IRFactory(ErrorReporter errorReporter, String sourceName) {\n+    super(new CompilerEnvirons(), errorReporter);\n+    this.errorReporter = errorReporter;\n+    CompilerEnvirons env = getCompilerEnvirons();\n+    env.initFromOptions(ImmutableList.of(\"-languageIn\", \"ECMASCRIPT6\", \"-languageOut\", \"ECMASCRIPT6\", \"-strictMode\", \"true\"));\n+    // Do not tolerate errors.\n+    env.setRecoverFromErrors(false);\n+    env.setGenerateDebugInfo(true);\n+    new Parser().setCompilerEnvirons(env);\n+    setSourceName(sourceName);\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n+  @Override\n+  Node parse(Reader reader, String sourceName) throws IOException {\n+    return super.parse(reader, sourceName);\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+  private interface TransformDispatcher<T extends Node> {\n+    Node process(T node);\n+  }\n \n+  private class IRTransformDispatcher implements TypeSafeDispatcher, JSDocInfoAwareTransformer {\n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    public Node transform(NodeTraversal t, Node n) {\n+      Node result = null;\n+      switch (n.getToken()) {\n+        // Traverse function body\n+        case FUNCTION:\n+        case ARROW_FUNCTION:\n+          Node body = n.getLastChild();\n+          if (body.isBlock()) {\n+            result = transform(body);\n+          } else {\n+            Node newBlock = newNode(Token.BLOCK);\n+            body.replaceWith(newBlock);\n+            newBlock.addChildToBack(body);\n+            result = transform(body);\n+          }\n+          break;\n+\n+        // Skip property declarations\n+        case MEMBER_VARIABLE_DEF:\n+          // Handles ES6 class instance (non-static) field declarations\n+          result = newNode(Token.EMPTY).srcrefTree(n);\n+          break;\n+\n+        default:\n+          // Continue traversal as normal\n+          result = process(n);\n+          break;\n       }\n-      return node;\n+      setJSDocInfo(result, getJSDocInfo(n));\n+      return result;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n-    }\n-\n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n-    }\n-\n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n-    }\n-\n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    // Convenience method to handle Directive, ExpressionStatement, and EmptyExpression nodes\n+    private Node processGeneric(Node n) {\n+      if (isDirective(n)) {\n+        return new Node(Token.EMPTY);\n+      } else if (n.isExprResult()) {\n+        return transform(n.getFirstChild());\n+      } else {\n+        return n;\n+      }\n     }\n+  \n+    private boolean isDirective(Node n) {\n+      if (n == null) return false;\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n-\n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+      int nType = n.getToken();\n+      return nType == Token.EXPR_RESULT &&\n+          n.getFirstChild().isString() &&\n+          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n     }\n+  \n+    private final TransformDispatcher<Node> dispatcher = new TransformDispatcher<Node>() {\n+      @Override\n+      public Node process(Node n) {\n+        switch (n.getToken()) {\n+          case SCRIPT:\n+          case BLOCK:\n+            Node newBlock = newNode(n.getToken());\n+            for (Node c = n.getFirstChild(); c != null; c = c.getNext()) {\n+              newBlock.addChildToBack(transform(c));\n+            }\n+            return newBlock;\n+\n+          case FUNCTION:\n+          case ARROW_FUNCTION:\n+            return newNode(n.getToken(), n.getFirstChild(), transformBlock(n.getLastChild()));\n+\n+          case RETURN:\n+            return new Node(Token.RETURN, transform(n.getFirstChild()));\n+\n+          case NAME:\n+          case STRING:\n+          case NUMBER:\n+          case REGEXP:\n+          case TEMPLATELIT_STRING:\n+            return n;\n+\n+          case CAST:\n+            checkState(n.getChildCount() == 1);\n+            return transform(n.getFirstChild());\n+\n+          case EXPR_RESULT:\n+            return transform(n.getFirstChild());\n+\n+          case CLASS:\n+            Node name = null;\n+            for (Node member = n.getFirstChild(); member != null; member = member.getNext()) {\n+              if (member.isStaticMember() || member.isMemberFunctionDef()) {\n+                continue;\n+              } else if (member.isMemberVariableDef()) {\n+                Node newMember = newNode(Token.MEMBER_VARIABLE_DEF);\n+                newMember.addChildrenToBack(transform(member.getFirstChild()), transform(member.getSecondChild()));\n+                if (member.getBooleanProp(Node.COMPUTED_PROP_GETTER) || member.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {\n+                  newMember.setComputedPropGetter(member.getBooleanProp(Node.COMPUTED_PROP_GETTER))\n+                      .setComputedPropSetter(member.getBooleanProp(Node.COMPUTED_PROP_SETTER))\n+                      .putBooleanProp(Node.COMPUTED_PROP, true);\n+                  newMember.setProp(Node.ACCESS_MODIFIER, member.getProp(Node.ACCESS_MODIFIER));\n+                }\n+                if (member.isOptionalArg()) {\n+                  newMember.putBooleanProp(Node.OPT_ES6_TYPED, true);\n+                  newMember.putProp(Node.OPT_DUMMY, NodeUtil.emptyFunction());\n+                }\n+                if (member.getJSDocInfo() != null) {\n+                  newMember.setJSDocInfo(member.getJSDocInfo());\n+                }\n+                if (name != null) {\n+                  newMember.putProp(Node.CLASS_NAME, name);\n+                  newMember.setStaticMember(false);\n+                }\n+                return new MemberDefinitionTransformDispatcher().process(newMember);\n+              } else {\n+                checkState(member.isClassMembers());\n+                if (member.isStatic()) {\n+                  continue;\n+                }\n+                Node memberClone = member.cloneNode();\n+                memberClone.setStaticMember(true);\n+                Node newMember = newNode(Token.EXPR_RESULT, memberClone);\n+                if (name != null) {\n+                  newMember.putProp(Node.CLASS_NAME, name);\n+                }\n+                if (newMember.getBooleanProp(Node.COMPUTED_PROP_GETTER) || newMember.getBooleanProp(Node.COMPUTED_PROP_SETTER)) {\n+                  newMember.setBooleanProp(Node.COMPUTED_PROP, true);\n+                }\n+                newMember.setLineno(member.getLineno()).setCharno(member.getCharno());\n+                return transform(newMember);\n+              }\n+            }\n+            return n;\n+\n+          case CLASS_MEMBERS:\n+            Node newMembers = newNode(Token.CLASS_MEMBERS);\n+            for (Node member = n.getFirstChild(); member != null; member = member.getNext()) {\n+              newMembers.addChildToBack(transform(member));\n+            }\n+            return newMembers;\n+\n+          case GETPROP:\n+          case GETELEM:\n+          case IMPORT:\n+            return new Node(Token.EMPTY);\n+\n+          case HOOK:\n+            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getSecondChild()), transform(n.getLastChild()));\n+\n+          case AND:\n+          case OR:\n+          case COALESCE:\n+          case ASSIGN:\n+          case ASSIGN_BITOR:\n+          case ASSIGN_BITXOR:\n+          case ASSIGN_BITAND:\n+          case ASSIGN_LSH:\n+          case ASSIGN_RSH:\n+          case ASSIGN_URSH:\n+          case ASSIGN_ADD:\n+          case ASSIGN_SUB:\n+          case ASSIGN_MUL:\n+          case ASSIGN_DIV:\n+          case ASSIGN_MOD:\n+            return newNode(n.getToken(),\n+                transform(n.getFirstChild()),\n+                transform(n.getLastChild()));\n+\n+          case CALL:\n+            Node callee = transform(n.getFirstChild());\n+            if (callee.getString().equals(\"goog.inherits\")) {\n+              return new Node(Token.EMPTY);\n+            }\n+            Node call = new Node(Token.CALL, callee);\n+            for (Node arg = n.getSecondChild(); arg != null; arg = arg.getNext()) {\n+              call.addChildToBack(transform(arg));\n+            }\n+            return call;\n+\n+          case NEW:\n+            Node constructor = transform(n.getFirstChild());\n+            Node newInstance = new Node(Token.NEW, constructor);\n+            for (Node arg = n.getSecondChild(); arg != null; arg = arg.getNext()) {\n+              newInstance.addChildToBack(transform(arg));\n+            }\n+            return newInstance;\n+\n+          case DELPROP:\n+            return new Node(Token.EMPTY);\n+\n+          case STRING_KEY:\n+          case NUMBER_ELEMENT:\n+            return n;\n+\n+          case ARRAYLIT:\n+          case OBJECTLIT:\n+          case CLASS_MEMBERS_DECL:\n+          case COMPUTED_PROP:\n+            return processGeneric(n);\n+\n+          case TEMPLATELIT:\n+            return newNode(n.getToken());\n+\n+          case SUPER:\n+            return new Node(Token.EMPTY);\n+\n+          case TEMPLATELIT_SUB:\n+            return processGeneric(n).detach();\n+\n+          case LET:\n+            n.setType(Token.VAR);\n+            for (Node child = n.getFirstChild(); child != null; child = child.getNext()) {\n+              child.setType(Token.NAME);\n+            }\n+            return n;\n+\n+          case VAR:\n+            for (Node child : children(n)) {\n+              if (child.hasChildren()) {\n+                child.getLastChild().replaceWith(transform(child.getLastChild()));\n+              }\n+            }\n+            return n;\n+\n+          case THROW:\n+            return newNode(Token.THROW, transform(n.getFirstChild()));\n+\n+          case TRY:\n+            Node tryBlock = transform(n.getFirstChild());\n+            Node catchBlock = n.getSecondChild();\n+            Node finallyBlock = n.getLastChild();\n+            if (finallyBlock != null) {\n+              finallyBlock = transform(finallyBlock);\n+            }\n+            if (catchBlock != null) {\n+              Node catchVarName = catchBlock.getFirstChild();\n+              if (catchVarName.getType() == Token.LET) {\n+                catchVarName.setType(Token.NAME);\n+                for (Node child = catchVarName.getFirstChild(); child != null; child = child.getNext()) {\n+                  child.setType(Token.NAME);\n+                }\n+              }\n+              catchBlock = transform(catchBlock);\n+            }\n+            return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+\n+          case THROW_NEW:\n+            Node errorName = transform(n.getFirstChild());\n+            // ThrowSite translates properly to a call in ES6\n+            Node newError = new Node(Token.NEW, errorName);\n+            newError.copyInformationFromForTree(n);\n+            return process(new Node(Token.THROW, newError).srcref(n));\n+\n+          case CONDITIONAL:\n+            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getSecondChild()), transform(n.getLastChild()));\n+\n+          case SWITCH:\n+            Node newSwitch = new Node(Token.SWITCH, transform(n.getFirstChild()));\n+            for (Node child = n.getSecondChild(); child != null; child = child.getNext()) {\n+              if (child.isCase()) {\n+                Node newCase = new Node(Token.CASE, transform(child.getFirstChild()));\n+                newSwitch.addChildToBack(newCase);\n+                for (Node grandchild = child.getSecondChild(); grandchild != null; grandchild = grandchild.getNext()) {\n+                  newCase.addChildToBack(transform(grandchild));\n+                }\n+              } else if (child.getToken() == Token.DEFAULT_CASE) {\n+                Node newDefault = new Node(Token.DEFAULT_CASE);\n+                for (Node grandchild = child.getFirstChild(); grandchild != null; grandchild = grandchild.getNext()) {\n+                  newDefault.addChildToBack(transform(grandchild));\n+                }\n+                newSwitch.addChildToBack(newDefault);\n+              } else {\n+                throw new IllegalStateException(\"Switch child not switch case or default case: \" + child);\n+              }\n+            }\n+            return newSwitch;\n+\n+          case CASE:\n+          case DEFAULT_CASE:\n+            throw new IllegalStateException(\"Case node not in switch: \" + n);\n+\n+          case WHILE:\n+            return newNode(Token.WHILE, transform(n.getFirstChild()), transformBlock(n.getLastChild()));\n+\n+          case DO:\n+            return processDoLoop(n);\n+\n+          case FOR:\n+            Node forKid = n.getFirstChild();\n+            Node init = null;\n+            Node cond = null;\n+            Node incr = null;\n+            if (forKid != null) {\n+              init = transform(forKid);\n+              forKid = forKid.getNext();\n+            }\n+            if (forKid != null) {\n+              cond = transform(forKid);\n+              forKid = forKid.getNext();\n+            }\n+            if (forKid != null) {\n+              incr = transform(forKid);\n+              forKid = forKid.getNext();\n+            }\n+            Node body = transform(forKid);\n+            return new Node(Token.FOR, init, cond, incr, body);\n+\n+          case FOR_IN:\n+            Node lhs = transform(n.getFirstChild());\n+            Node obj = transform(n.getSecondChild());\n+            Node body2 = transform(n.getLastChild());\n+\n+            if (lhs.getType() == Token.VAR) {\n+              lhs.setType(Token.LET);\n+              for (Node c = lhs.getFirstChild(); c != null; c = c.getNext()) {\n+                c.setType(Token.LET);\n+              }\n+            }\n+            return newNode(Token.FOR_OF, lhs, obj, body2);\n+\n+          case BREAK:\n+            return processBreakStatement(n);\n+\n+          case CONTINUE:\n+            return processContinueStatement(n);\n+\n+          case EMPTY:\n+            return processGeneric(n);\n+\n+          case DEBUGGER:\n+            return n;\n+\n+          case DOT:\n+            return n;\n+\n+          case LABEL:\n+            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getLastChild()));\n+\n+          case LSH:\n+          case RSH:\n+          case URSH:\n+          case AND_EQ:\n+          case OR_EQ:\n+          case XOR_EQ:\n+          case ADD_EQ:\n+          case SUB_EQ:\n+          case MUL_EQ:\n+          case DIV_EQ:\n+          case MOD_EQ:\n+            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getLastChild()));\n+\n+          case GT:\n+          case LT:\n+          case GE:\n+          case LE:\n+          case EQ:\n+          case NE:\n+          case SHEQ:\n+          case SHNE:\n+          case INSTANCEOF:\n+          case IN:\n+          case OR:\n+          case AND:\n+          case BITOR:\n+          case BITAND:\n+          case BITXOR:\n+          case ADD:\n+          case SUB:\n+          case MUL:\n+          case DIV:\n+          case MOD:\n+            return newNode(n.getToken(), transform(n.getFirstChild()), transform(n.getLastChild()));\n+\n+          case NOT:\n+          case NEG:\n+          case POS:\n+          case BITNOT:\n+          case TypeOf:\n+          case VOID:\n+          case DEC:\n+          case INC:\n+            return newNode(n.getToken(), transform(n.getFirstChild()));\n+\n+          case ARRAY_PATTERN:\n+            return newNode(Token.ARRAY_PATTERN, transformArrayPattern(n));\n+\n+          case OBJECT_PATTERN:\n+            return newNode(Token.OBJECT_PATTERN, transformObjectPattern(n));\n+\n+          case REST:\n+            return newNode(Token.REST, transform(n.getFirstChild()));\n+\n+          case COMPUTED_PROP: {\n+            Node propName = transform(n.getFirstChild());\n+            Node value = transform(n.getSecondChild());\n+            return new Node(Token.COMPUTED_PROP, propName, value);\n+          }\n+          case COMPUTED_GETPROP: {\n+            Node base1 = transform(n.getFirstChild());\n+            Node propName1 = transform(n.getLastChild());\n+            return new Node(Token.GETELEM, base1, propName1);\n+          }\n+          case COMPUTED_SETPROP: {\n+            Node base2 = transform(n.getFirstChild());\n+            Node propName2 = transform(n.getSecondChild());\n+            Node value1 = transform(n.getLastChild());\n+            return new Node(Token.SETELEM, base2, propName2, value1);\n+          }\n+          case OBJECTLIT_PROP:\n+            if (NodeUtil.isObjectLiteralGetOrSetKey(n)) {\n+              return new Node(Token.GETTER_DEF, n.removeFirstChild(), transformFunctionBody(n.getFirstChild()));\n+            } else if (NodeUtil.isObjectLiteralSetterKey(n)) {\n+              return new Node(Token.SETTER_DEF, n.removeFirstChild(), n.getFirstChild(), transformFunctionBody(n.getLastChild()));\n+            } else {\n+              return ne\n \n     @Override\n     Node processForLoop(ForLoop loopNode) {",
    "result_reason": "error: ';' expected",
    "test_result": "ERROR"
}