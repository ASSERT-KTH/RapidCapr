{
    "patch": "public String fixCode(String code) {\n    try {\n        CompilationUnit cu = StaticJavaParser.parse(code);\n        List<ForStmt> forStmts = cu.findAll(ForStmt.class);\n        for (ForStmt forStmt : forStmts) {\n            Expression iterableExp = forStmt.getIterable().get();\n            if (iterableExp.isMethodCallExpr() && ((MethodCallExpr) iterableExp).getNameAsString().equals(\"entrySet\")) {\n                MethodCallExpr entrySetExp = iterableExp.asMethodCallExpr();\n                NameExpr mapExp = entrySetExp.getScope().get().asNameExpr();\n                String mapName = mapExp.getNameAsString();\n                String newName = \"entrySetOf\" + mapName.substring(0, 1).toUpperCase() + mapName.substring(1);\n                VariableDeclarationExpr entrySetVar = new VariableDeclarationExpr(\n                        new VariableDeclarator(new TypeExpr(new ClassOrInterfaceType(null, \"Set\"), \n                                new NodeList<>(new ClassOrInterfaceType(null, \"Map.Entry\"))), newName,\n                                new MethodCallExpr(mapExp, \"entrySet\")));\n\n                NodeList<Expression> args = new NodeList<>(new NameExpr(newName));\n                MethodCallExpr newIterExp = new MethodCallExpr(new MethodCallExpr(new NameExpr(\"Arrays\"), \n                                    \"asList\", args), \"iterator\");\n                forStmt.setIterable(newIterExp);\n\n                NodeList<Expression> updArgs = new NodeList<>(new MethodCallExpr(new NameExpr(\"entry\"), \"getKey\"),\n                        new MethodCallExpr(new NameExpr(\"entry\"), \"getValue\"));\n                ExpressionStmt updExp = new ExpressionStmt(\n                        new MethodCallExpr(new NameExpr(forStmt.getBody().getStatements().get(0).asMethodCallExpr().getScope().get().toString()), \n                                forStmt.getBody().getStatements().get(0).asMethodCallExpr().getNameAsString(),\n                                updArgs));\n                forStmt.getBody().setStatements(new NodeList<>(updExp));\n                cu.findAll(ImportDeclaration.class).stream()\n                .filter(i -> \"java.util.Arrays\".equals(i.getNameAsString())).findFirst()\n                .ifPresent(i ->i.setName(\"java.util.List\"));\n            }\n        }\n        return cu.toString();\n    } catch (Exception e) {\n        return \"PARSE_ERROR\";\n    }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CodeGenerator.java b/src/com/google/javascript/jscomp/CodeGenerator.java\nindex 54eb5cf8..7cc94ec7 100644\n--- a/src/com/google/javascript/jscomp/CodeGenerator.java\n+++ b/src/com/google/javascript/jscomp/CodeGenerator.java\n@@ -104,7 +104,44 @@ class CodeGenerator {\n     add(n, Context.OTHER);\n   }\n \n-  void add(Node n, Context context) {\n+public String fixCode(String code) {\n+    try {\n+        CompilationUnit cu = StaticJavaParser.parse(code);\n+        List<ForStmt> forStmts = cu.findAll(ForStmt.class);\n+        for (ForStmt forStmt : forStmts) {\n+            Expression iterableExp = forStmt.getIterable().get();\n+            if (iterableExp.isMethodCallExpr() && ((MethodCallExpr) iterableExp).getNameAsString().equals(\"entrySet\")) {\n+                MethodCallExpr entrySetExp = iterableExp.asMethodCallExpr();\n+                NameExpr mapExp = entrySetExp.getScope().get().asNameExpr();\n+                String mapName = mapExp.getNameAsString();\n+                String newName = \"entrySetOf\" + mapName.substring(0, 1).toUpperCase() + mapName.substring(1);\n+                VariableDeclarationExpr entrySetVar = new VariableDeclarationExpr(\n+                        new VariableDeclarator(new TypeExpr(new ClassOrInterfaceType(null, \"Set\"), \n+                                new NodeList<>(new ClassOrInterfaceType(null, \"Map.Entry\"))), newName,\n+                                new MethodCallExpr(mapExp, \"entrySet\")));\n+\n+                NodeList<Expression> args = new NodeList<>(new NameExpr(newName));\n+                MethodCallExpr newIterExp = new MethodCallExpr(new MethodCallExpr(new NameExpr(\"Arrays\"), \n+                                    \"asList\", args), \"iterator\");\n+                forStmt.setIterable(newIterExp);\n+\n+                NodeList<Expression> updArgs = new NodeList<>(new MethodCallExpr(new NameExpr(\"entry\"), \"getKey\"),\n+                        new MethodCallExpr(new NameExpr(\"entry\"), \"getValue\"));\n+                ExpressionStmt updExp = new ExpressionStmt(\n+                        new MethodCallExpr(new NameExpr(forStmt.getBody().getStatements().get(0).asMethodCallExpr().getScope().get().toString()), \n+                                forStmt.getBody().getStatements().get(0).asMethodCallExpr().getNameAsString(),\n+                                updArgs));\n+                forStmt.getBody().setStatements(new NodeList<>(updExp));\n+                cu.findAll(ImportDeclaration.class).stream()\n+                .filter(i -> \"java.util.Arrays\".equals(i.getNameAsString())).findFirst()\n+                .ifPresent(i ->i.setName(\"java.util.List\"));\n+            }\n+        }\n+        return cu.toString();\n+    } catch (Exception e) {\n+        return \"PARSE_ERROR\";\n+    }\n+}\n     if (!cc.continueProcessing()) {\n       return;\n     }",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}