{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    // Adjusted value is before the true instant, so try later\n    // transitions until the offset changes to the expected value\n    if ((offsetLocal - offsetAdjusted) < 0) {\n        // If we just return offsetAdjusted then the time is set to the\n        // transition time before the transition. We need to ensure that\n        // the time is on or after the transition.\n        long nextTransitionAdj = nextTransition(instantAdjusted);\n        long nextTransitionLocal = nextTransition(instantLocal - offsetAdjusted);\n\n        // If there is a transition later than the current one, and it matches the\n        // expected local offset, return the current offset\n        if (nextTransitionAdj != nextTransitionLocal) {\n            final int newOffsetAdj = (nextTransitionAdj == Long.MAX_VALUE) ?\n                    getOffset(instantAdjusted) : getOffset(nextTransitionAdj - 1);\n            if (offsetLocal == newOffsetAdj) {\n                return offsetLocal;\n            } else {\n                return getOffset(nextTransitionAdj);\n            }\n        }\n\n        // Next transition found has MAX_VALUE instant, return last offset\n        if (nextTransitionAdj == Long.MAX_VALUE) {\n            return getOffset(instantAdjusted);\n        }\n\n        // Next transition is before MIN_VALUE instant, return next offset\n        if (nextTransitionAdj < Long.MIN_VALUE + 86400000L) {\n            long nextTransitionAdjusted = nextTransition(nextTransitionLocal - 86400000L);\n            return getOffset(nextTransitionAdjusted - (nextTransitionLocal - 86400000L));\n        }\n    }\n    // Adjusted value is after the true instant, so try earlier\n    // transitions until the offset changes to the expected value\n    else {\n        long prevTransitionAdj = previousTransition(instantAdjusted);\n        long prevTransitionLocal = previousTransition(instantLocal - offsetLocal);\n\n        // If there is a transition earlier than the current one, and it matches the\n        // expected local offset, return the current offset\n        if (prevTransitionAdj != prevTransitionLocal) {\n            final int newOffsetAdj = (prevTransitionAdj == Long.MIN_VALUE) ?\n                    getOffset(instantAdjusted) : getOffset(prevTransitionAdj);\n            if (offsetLocal == newOffsetAdj) {\n                return offsetLocal;\n            } else {\n                return getOffset(prevTransitionAdj);\n            }\n        }\n    }\n}\nreturn offsetAdjusted;",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..42f02113 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,59 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    // Adjusted value is before the true instant, so try later\n+    // transitions until the offset changes to the expected value\n+    if ((offsetLocal - offsetAdjusted) < 0) {\n+        // If we just return offsetAdjusted then the time is set to the\n+        // transition time before the transition. We need to ensure that\n+        // the time is on or after the transition.\n+        long nextTransitionAdj = nextTransition(instantAdjusted);\n+        long nextTransitionLocal = nextTransition(instantLocal - offsetAdjusted);\n+\n+        // If there is a transition later than the current one, and it matches the\n+        // expected local offset, return the current offset\n+        if (nextTransitionAdj != nextTransitionLocal) {\n+            final int newOffsetAdj = (nextTransitionAdj == Long.MAX_VALUE) ?\n+                    getOffset(instantAdjusted) : getOffset(nextTransitionAdj - 1);\n+            if (offsetLocal == newOffsetAdj) {\n+                return offsetLocal;\n+            } else {\n+                return getOffset(nextTransitionAdj);\n+            }\n+        }\n+\n+        // Next transition found has MAX_VALUE instant, return last offset\n+        if (nextTransitionAdj == Long.MAX_VALUE) {\n+            return getOffset(instantAdjusted);\n+        }\n+\n+        // Next transition is before MIN_VALUE instant, return next offset\n+        if (nextTransitionAdj < Long.MIN_VALUE + 86400000L) {\n+            long nextTransitionAdjusted = nextTransition(nextTransitionLocal - 86400000L);\n+            return getOffset(nextTransitionAdjusted - (nextTransitionLocal - 86400000L));\n+        }\n+    }\n+    // Adjusted value is after the true instant, so try earlier\n+    // transitions until the offset changes to the expected value\n+    else {\n+        long prevTransitionAdj = previousTransition(instantAdjusted);\n+        long prevTransitionLocal = previousTransition(instantLocal - offsetLocal);\n+\n+        // If there is a transition earlier than the current one, and it matches the\n+        // expected local offset, return the current offset\n+        if (prevTransitionAdj != prevTransitionLocal) {\n+            final int newOffsetAdj = (prevTransitionAdj == Long.MIN_VALUE) ?\n+                    getOffset(instantAdjusted) : getOffset(prevTransitionAdj);\n+            if (offsetLocal == newOffsetAdj) {\n+                return offsetLocal;\n+            } else {\n+                return getOffset(prevTransitionAdj);\n+            }\n+        }\n+    }\n+}\n+return offsetAdjusted;\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.ComparisonFailure: expected:<...10-28T02:30:00.000+0[4]:00> but was:<...10-28T02:30:00.000+0[3]:00>",
    "test_result": "FAIL"
}