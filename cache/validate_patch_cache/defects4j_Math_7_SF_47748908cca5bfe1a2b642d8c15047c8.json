{
    "patch": "public void doEvents(final double t, final double[] y, final double tEnd) throws MathException {\n\n    // set up an interpolator sharing the integrator integrator\n    final FirstOrderDifferentialEquations ode = compoundODE.getPrimary();\n\n    final FixedStepHandler handler = new FixedStepHandler() {\n\n        private boolean signChanged;\n        private double   previousT;\n        private double   lastT;\n\n        public void handleStep(final double t, final double[] y, final double[] yDot, final boolean isLast) {\n            if (!occuringEvents.isEmpty()) {\n                try {\n                    if (previousT * (t - tEnd) >= 0) {\n                        // we have reached the end of integration interval without event\n                        isLastStep = true;\n                        lastT      = tEnd;\n                        return;\n                    }\n                    // evaluate events at step endpoints\n                    signChanged = EventHandler.evaluateStep(eventsStates, y, t, eventsActions);\n                    if (signChanged) {\n                        // theoretical event within the interval\n                        lastT = t;\n                    }\n                    // handle the chronologically first event\n                    while (!occuringEvents.isEmpty() &&\n                            (currentEvent = occuringEvents.first()).getEventTime() <= t) {\n                        // the event is now current\n                        final EventState eventState = occuringEvents.pollFirst();\n                        // restrict the interpolator to the first part of the step, up to the event\n                        final double eventT = eventState.getEventTime();\n                        interpolator.setSoftPreviousTime(previousT);\n                        interpolator.setSoftCurrentTime(eventT);\n                        if (eventT >= tEnd) {\n                            // the event occurs exactly at step end\n                            isLastStep = true;\n                            interpolator.setInterpolatedTime(eventT);\n                            final double[] eventY = interpolator.getInterpolatedState().clone();\n                            eventState.stepAccepted(eventT, eventY);\n                            final boolean stop = eventState.stop();\n                            isLastStep = isLastStep || stop;\n                            for (final StepHandler handler : stepHandlers) {\n                                handler.handleStep(interpolator, isLastStep);\n                            }\n                            return;\n                        }\n                        // get state at event time\n                        interpolator.setInterpolatedTime(eventT);\n                        final double[] eventY = interpolator.getInterpolatedState().clone();\n                        eventState.stepAccepted(eventT, eventY);\n                        final boolean stop = eventState.stop();\n                        isLastStep = isLastStep || stop;\n                        for (final StepHandler handler : stepHandlers) {\n                            handler.handleStep(interpolator, isLastStep);\n                        }\n                        // update events occurrence time with the new state\n                        if (!refreshOccurred) {\n                            EventHandler.recomputeDerivatives(eventsStates, y, yDot, interpolator.getInterpolatedDerivatives(), true, eventsActions);\n                        }\n                        // redetect events\n                        EventHandler.detectEvents(eventsStates, signChanged, interpolator, eventsActions, tEnd - t);\n                    }\n                    previousT = t;\n                    if (isLast) {\n                        // last step, adjust for events at step end\n                        if (lastT >= 0) {\n                            isLastStep = false;\n                            interpolator.setSoftPreviousTime(previousT);\n                            interpolator.setSoftCurrentTime(lastT);\n                            lastT = -1;\n                            double[] eventY;\n                            if (occuringEvents.isEmpty()) {\n                                // we have already done all events processing\n                                interpolator.setInterpolatedTime(tEnd);\n                                eventY = interpolator.getInterpolatedState().clone();\n                            } else {\n                                // handle last occurring event\n                                currentEvent = occuringEvents.pollFirst();\n                                final double eventT = currentEvent.getEventTime();\n                                interpolator.setInterpolatedTime(eventT);\n                                eventY = interpolator.getInterpolatedState().clone();\n                                currentEvent.stepAccepted(eventT, eventY);\n                                isLastStep = currentEvent.stop();\n                                for (final StepHandler handler : stepHandlers) {\n                                    handler.handleStep(interpolator, isLastStep);\n                                }\n                                // update events occurrence time with the new state\n                                EventHandler.recomputeDerivatives(eventsStates, y, yDot, interpolator.getInterpolatedDerivatives(), true, eventsActions);\n                            }\n                            interpolator.setInterpolatedTime(tEnd);\n                            for (final StepHandler handler : stepHandlers) {\n                                handler.handleStep(interpolator, true);\n                            }\n                            // recover events occurrence time\n                            for (final EventState state : eventsStates) {\n                                state.stepAccepted(tEnd, eventY);\n                            }\n                        } else {\n                            // no event at end of step\n                            interpolator.setInterpolatedTime(tEnd);\n                            isLastStep = true;\n                            for (final StepHandler handler : stepHandlers) {\n                                handler.handleStep(interpolator, isLastStep);\n                            }\n                        }\n                    }\n                } catch (final DerivativeException | IntegratorException e) {\n                    throw new MathException(e);\n                }\n            }\n        }\n\n    };\n\n    isLastStep = false;\n    interpolator = new DummyStepInterpolator();\n    interpolator.setInterpolatedTime(y, t);\n    interpolator.setInterpolatedTimeDerivatives(compoundODE.computeDerivatives(t, y));\n    ode.computeDerivatives(t, y, interpolator.getInterpolatedDerivatives());\n    final double[] y1 = interpolator.getInterpolatedState().clone();\n    for (final EventState state : eventsStates) {\n        state.reinitializeBegin(t, y, y1);\n    }\n    occuringEvents = new TreeSet<>(EVENT_TIME_COMPARATOR);\n    EventHandler.detectEvents(eventsStates, false, interpolator, eventsActions, tEnd - t);\n    for (final EventState state : eventsStates) {\n        if (state.isOccursOnADifferentiableEvent()) {\n            // add only events that have not already occurred (i.e. if an event\n            // already occurred, current event time expression is already at 0.0)\n            final double eventTime = state.getEventTime();\n            if (eventTime < tEnd && eventTime > t) {\n                occuringEvents.add(state);\n            }\n        }\n    }\n    if (occuringEvents.isEmpty()) {\n        integrator.integrate(ode, t, y, tEnd, y);\n        interpolator.setSoftPreviousTime(t);\n        interpolator.setSoftCurrentTime(tEnd);\n        for (final StepHandler stepHandler : stepHandlers) {\n            stepHandler.handleStep(interpolator, true);\n        }\n        return;\n    }\n    integrator.addStepHandler(handler);\n    integrator.integrate(ode, t, y, tEnd, y1);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\nindex f24f87c39..ba58f00d7 100644\n--- a/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n+++ b/src/main/java/org/apache/commons/math3/ode/AbstractIntegrator.java\n@@ -313,43 +313,155 @@ public abstract class AbstractIntegrator implements FirstOrderIntegrator {\n             SortedSet<EventState> occuringEvents = new TreeSet<EventState>(new Comparator<EventState>() {\n \n                 /** {@inheritDoc} */\n-                public int compare(EventState es0, EventState es1) {\n-                    return orderingSign * Double.compare(es0.getEventTime(), es1.getEventTime());\n-                }\n-\n-            });\n+public void doEvents(final double t, final double[] y, final double tEnd) throws MathException {\n \n-            for (final EventState state : eventsStates) {\n-                if (state.evaluateStep(interpolator)) {\n-                    // the event occurs during the current step\n-                    occuringEvents.add(state);\n-                }\n-            }\n+    // set up an interpolator sharing the integrator integrator\n+    final FirstOrderDifferentialEquations ode = compoundODE.getPrimary();\n \n-            while (!occuringEvents.isEmpty()) {\n+    final FixedStepHandler handler = new FixedStepHandler() {\n \n-                // handle the chronologically first event\n-                final Iterator<EventState> iterator = occuringEvents.iterator();\n-                final EventState currentEvent = iterator.next();\n-                iterator.remove();\n+        private boolean signChanged;\n+        private double   previousT;\n+        private double   lastT;\n \n-                // restrict the interpolator to the first part of the step, up to the event\n-                final double eventT = currentEvent.getEventTime();\n-                interpolator.setSoftPreviousTime(previousT);\n-                interpolator.setSoftCurrentTime(eventT);\n-\n-                // get state at event time\n-                interpolator.setInterpolatedTime(eventT);\n-                final double[] eventY = interpolator.getInterpolatedState().clone();\n+        public void handleStep(final double t, final double[] y, final double[] yDot, final boolean isLast) {\n+            if (!occuringEvents.isEmpty()) {\n+                try {\n+                    if (previousT * (t - tEnd) >= 0) {\n+                        // we have reached the end of integration interval without event\n+                        isLastStep = true;\n+                        lastT      = tEnd;\n+                        return;\n+                    }\n+                    // evaluate events at step endpoints\n+                    signChanged = EventHandler.evaluateStep(eventsStates, y, t, eventsActions);\n+                    if (signChanged) {\n+                        // theoretical event within the interval\n+                        lastT = t;\n+                    }\n+                    // handle the chronologically first event\n+                    while (!occuringEvents.isEmpty() &&\n+                            (currentEvent = occuringEvents.first()).getEventTime() <= t) {\n+                        // the event is now current\n+                        final EventState eventState = occuringEvents.pollFirst();\n+                        // restrict the interpolator to the first part of the step, up to the event\n+                        final double eventT = eventState.getEventTime();\n+                        interpolator.setSoftPreviousTime(previousT);\n+                        interpolator.setSoftCurrentTime(eventT);\n+                        if (eventT >= tEnd) {\n+                            // the event occurs exactly at step end\n+                            isLastStep = true;\n+                            interpolator.setInterpolatedTime(eventT);\n+                            final double[] eventY = interpolator.getInterpolatedState().clone();\n+                            eventState.stepAccepted(eventT, eventY);\n+                            final boolean stop = eventState.stop();\n+                            isLastStep = isLastStep || stop;\n+                            for (final StepHandler handler : stepHandlers) {\n+                                handler.handleStep(interpolator, isLastStep);\n+                            }\n+                            return;\n+                        }\n+                        // get state at event time\n+                        interpolator.setInterpolatedTime(eventT);\n+                        final double[] eventY = interpolator.getInterpolatedState().clone();\n+                        eventState.stepAccepted(eventT, eventY);\n+                        final boolean stop = eventState.stop();\n+                        isLastStep = isLastStep || stop;\n+                        for (final StepHandler handler : stepHandlers) {\n+                            handler.handleStep(interpolator, isLastStep);\n+                        }\n+                        // update events occurrence time with the new state\n+                        if (!refreshOccurred) {\n+                            EventHandler.recomputeDerivatives(eventsStates, y, yDot, interpolator.getInterpolatedDerivatives(), true, eventsActions);\n+                        }\n+                        // redetect events\n+                        EventHandler.detectEvents(eventsStates, signChanged, interpolator, eventsActions, tEnd - t);\n+                    }\n+                    previousT = t;\n+                    if (isLast) {\n+                        // last step, adjust for events at step end\n+                        if (lastT >= 0) {\n+                            isLastStep = false;\n+                            interpolator.setSoftPreviousTime(previousT);\n+                            interpolator.setSoftCurrentTime(lastT);\n+                            lastT = -1;\n+                            double[] eventY;\n+                            if (occuringEvents.isEmpty()) {\n+                                // we have already done all events processing\n+                                interpolator.setInterpolatedTime(tEnd);\n+                                eventY = interpolator.getInterpolatedState().clone();\n+                            } else {\n+                                // handle last occurring event\n+                                currentEvent = occuringEvents.pollFirst();\n+                                final double eventT = currentEvent.getEventTime();\n+                                interpolator.setInterpolatedTime(eventT);\n+                                eventY = interpolator.getInterpolatedState().clone();\n+                                currentEvent.stepAccepted(eventT, eventY);\n+                                isLastStep = currentEvent.stop();\n+                                for (final StepHandler handler : stepHandlers) {\n+                                    handler.handleStep(interpolator, isLastStep);\n+                                }\n+                                // update events occurrence time with the new state\n+                                EventHandler.recomputeDerivatives(eventsStates, y, yDot, interpolator.getInterpolatedDerivatives(), true, eventsActions);\n+                            }\n+                            interpolator.setInterpolatedTime(tEnd);\n+                            for (final StepHandler handler : stepHandlers) {\n+                                handler.handleStep(interpolator, true);\n+                            }\n+                            // recover events occurrence time\n+                            for (final EventState state : eventsStates) {\n+                                state.stepAccepted(tEnd, eventY);\n+                            }\n+                        } else {\n+                            // no event at end of step\n+                            interpolator.setInterpolatedTime(tEnd);\n+                            isLastStep = true;\n+                            for (final StepHandler handler : stepHandlers) {\n+                                handler.handleStep(interpolator, isLastStep);\n+                            }\n+                        }\n+                    }\n+                } catch (final DerivativeException | IntegratorException e) {\n+                    throw new MathException(e);\n+                }\n+            }\n+        }\n \n-                // advance all event states to current time\n-                currentEvent.stepAccepted(eventT, eventY);\n-                isLastStep = currentEvent.stop();\n+    };\n \n-                // handle the first part of the step, up to the event\n-                for (final StepHandler handler : stepHandlers) {\n-                    handler.handleStep(interpolator, isLastStep);\n-                }\n+    isLastStep = false;\n+    interpolator = new DummyStepInterpolator();\n+    interpolator.setInterpolatedTime(y, t);\n+    interpolator.setInterpolatedTimeDerivatives(compoundODE.computeDerivatives(t, y));\n+    ode.computeDerivatives(t, y, interpolator.getInterpolatedDerivatives());\n+    final double[] y1 = interpolator.getInterpolatedState().clone();\n+    for (final EventState state : eventsStates) {\n+        state.reinitializeBegin(t, y, y1);\n+    }\n+    occuringEvents = new TreeSet<>(EVENT_TIME_COMPARATOR);\n+    EventHandler.detectEvents(eventsStates, false, interpolator, eventsActions, tEnd - t);\n+    for (final EventState state : eventsStates) {\n+        if (state.isOccursOnADifferentiableEvent()) {\n+            // add only events that have not already occurred (i.e. if an event\n+            // already occurred, current event time expression is already at 0.0)\n+            final double eventTime = state.getEventTime();\n+            if (eventTime < tEnd && eventTime > t) {\n+                occuringEvents.add(state);\n+            }\n+        }\n+    }\n+    if (occuringEvents.isEmpty()) {\n+        integrator.integrate(ode, t, y, tEnd, y);\n+        interpolator.setSoftPreviousTime(t);\n+        interpolator.setSoftCurrentTime(tEnd);\n+        for (final StepHandler stepHandler : stepHandlers) {\n+            stepHandler.handleStep(interpolator, true);\n+        }\n+        return;\n+    }\n+    integrator.addStepHandler(handler);\n+    integrator.integrate(ode, t, y, tEnd, y1);\n+}\n \n                 if (isLastStep) {\n                     // the event asked to stop integration",
    "result_reason": "error: multi-catch statement is not supported in -source 1.5",
    "test_result": "ERROR"
}