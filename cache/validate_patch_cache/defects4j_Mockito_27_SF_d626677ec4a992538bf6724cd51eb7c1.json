{
    "patch": "public <T> void resetMock(T mock) {\n    if (!(mock instanceof Factory)) {\n        return;\n    }\n\n    // Check if mock is already reset and skip initialization if true\n    MockAccess access = Mockito.mockingDetails(mock).getMockHandler().getMockitoMockHandler().getInvocationContainer();\n    if (access instanceof MockMethodInterceptor) {\n        return;\n    }\n\n    // If mock is not already reset, initialize the mock with a new interceptor\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n    if (oldMockHandler == null) {\n        return;\n    }\n\n    // Apply the new filter to the mock object\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, new MockSettingsImpl());\n    try {\n        ((Factory) mock).setCallback(0, newFilter);\n    } catch (IllegalArgumentException e) {\n        // This can occur if the mock object is a proxy for a primitive or final class\n        return;\n    }\n\n    // Workaround for the issue of hash code changes not being propagated when the mock object is part of a collection\n    if (mock instanceof Collection) {\n        for (Object element : (Collection<?>) mock) {\n            if (element != null) {\n                element.hashCode();\n            }\n        }\n    }\n\n    // Force the mock object to recalculate its hash code\n    try {\n        mock.hashCode();\n    } catch (UnsupportedOperationException e) {\n        // Do nothing: some mock objects may not support this operation\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..a70753235 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,50 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+public <T> void resetMock(T mock) {\n+    if (!(mock instanceof Factory)) {\n+        return;\n+    }\n+\n+    // Check if mock is already reset and skip initialization if true\n+    MockAccess access = Mockito.mockingDetails(mock).getMockHandler().getMockitoMockHandler().getInvocationContainer();\n+    if (access instanceof MockMethodInterceptor) {\n+        return;\n+    }\n+\n+    // If mock is not already reset, initialize the mock with a new interceptor\n+    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n+    if (oldMockHandler == null) {\n+        return;\n+    }\n+\n+    // Apply the new filter to the mock object\n+    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n+    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, new MockSettingsImpl());\n+    try {\n+        ((Factory) mock).setCallback(0, newFilter);\n+    } catch (IllegalArgumentException e) {\n+        // This can occur if the mock object is a proxy for a primitive or final class\n+        return;\n+    }\n+\n+    // Workaround for the issue of hash code changes not being propagated when the mock object is part of a collection\n+    if (mock instanceof Collection) {\n+        for (Object element : (Collection<?>) mock) {\n+            if (element != null) {\n+                element.hashCode();\n+            }\n+        }\n+    }\n+\n+    // Force the mock object to recalculate its hash code\n+    try {\n+        mock.hashCode();\n+    } catch (UnsupportedOperationException e) {\n+        // Do nothing: some mock objects may not support this operation\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}