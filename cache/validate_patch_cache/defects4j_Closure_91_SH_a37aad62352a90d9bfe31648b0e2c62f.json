{
    "patch": "      Node functionNode = n;\n\n      // Check if function is getting lent to a prototype.\n      boolean isAssignedToPrototype = false;\n      if (parent.getType() == Token.ASSIGN) {\n        Node lhs = parent.getFirstChild();\n        if (NodeUtil.isGet(lhs)) {\n          isAssignedToPrototype =\n              lhs.getType() == Token.GETPROP &&\n              lhs.getLastChild().getString().equals(\"prototype\");\n        }\n      }\n\n      // Traverse top-level functions.\n      if (!isAssignedToPrototype &&\n          (parent.getType() == Token.SCRIPT ||\n           parent.getType() == Token.BLOCK)) {\n        List<UseSite> useSites = useMap.get(functionNode);\n        if (useSites != null) {\n          for (UseSite useSite : useSites) {\n            Node callTargetNode = useSite.node;\n            if (callTargetNode != null && callTargetNode.getParent() != null) {\n              Node callParentNode = callTargetNode.getParent();\n              if (callParentNode.getType() == Token.NEW) {\n                FunctionType functionType = registry.getFunctionType(functionNode);\n                ObjectType inferredType = inference.getObjectType(callTargetNode);\n                if (!inferredType.isUnknown() && functionType != null) {\n                  inferredType = inferredType.autobox();\n                  JSType constructorReturnType =\n                      functionType.getTypeOfThis().getConstructor(inferredType);\n                  if (!constructorReturnType.isUnknown()) {\n                    traverseNewExpression(callTargetNode, constructorReturnType);\n                  }\n                }\n              } else if (NodeUtil.isCall(callParentNode)) {\n                Node argNode = callTargetNode.getNext();\n                if (argNode != null) {\n                  FunctionType functionType = registry.getFunctionType(functionNode);\n                  if (functionType != null) {\n                    JSType calleeType =\n                        functionType.getTypeOfThis().dereference().getNormalizedReference();\n                    if (calleeType instanceof FunctionType) {\n                      FunctionType fType = (FunctionType) calleeType;\n                      ObjectType inferredType = inference.getObjectType(argNode);\n                      if (!inferredType.isUnknown()) {\n                        inferredType = inferredType.autobox();\n                        JSType callReturnType = fType.getTypeOfThis().getReturnType(inferredType);\n                        if (!callReturnType.isUnknown()) {\n                          callReturnType = registry.expandType(callReturnType);\n                          traverseWithExpression(callReturnType, argNode);\n                        }\n                      }\n                    } else {\n                      traverseUnknownExpression(argNode);\n                    }\n                  } else {\n                    traverseUnknownExpression(argNode);\n                  }\n                }\n              } else {\n                traverseUnknownExpression(callTargetNode);\n              }\n            }\n          }\n        }\n      }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CheckGlobalThis.java b/src/com/google/javascript/jscomp/CheckGlobalThis.java\nindex fa598d2e..7efe3911 100644\n--- a/src/com/google/javascript/jscomp/CheckGlobalThis.java\n+++ b/src/com/google/javascript/jscomp/CheckGlobalThis.java\n@@ -112,6 +112,72 @@ final class CheckGlobalThis implements Callback {\n       }\n \n       // Don't traverse functions that are getting lent to a prototype.\n+      Node functionNode = n;\n+\n+      // Check if function is getting lent to a prototype.\n+      boolean isAssignedToPrototype = false;\n+      if (parent.getType() == Token.ASSIGN) {\n+        Node lhs = parent.getFirstChild();\n+        if (NodeUtil.isGet(lhs)) {\n+          isAssignedToPrototype =\n+              lhs.getType() == Token.GETPROP &&\n+              lhs.getLastChild().getString().equals(\"prototype\");\n+        }\n+      }\n+\n+      // Traverse top-level functions.\n+      if (!isAssignedToPrototype &&\n+          (parent.getType() == Token.SCRIPT ||\n+           parent.getType() == Token.BLOCK)) {\n+        List<UseSite> useSites = useMap.get(functionNode);\n+        if (useSites != null) {\n+          for (UseSite useSite : useSites) {\n+            Node callTargetNode = useSite.node;\n+            if (callTargetNode != null && callTargetNode.getParent() != null) {\n+              Node callParentNode = callTargetNode.getParent();\n+              if (callParentNode.getType() == Token.NEW) {\n+                FunctionType functionType = registry.getFunctionType(functionNode);\n+                ObjectType inferredType = inference.getObjectType(callTargetNode);\n+                if (!inferredType.isUnknown() && functionType != null) {\n+                  inferredType = inferredType.autobox();\n+                  JSType constructorReturnType =\n+                      functionType.getTypeOfThis().getConstructor(inferredType);\n+                  if (!constructorReturnType.isUnknown()) {\n+                    traverseNewExpression(callTargetNode, constructorReturnType);\n+                  }\n+                }\n+              } else if (NodeUtil.isCall(callParentNode)) {\n+                Node argNode = callTargetNode.getNext();\n+                if (argNode != null) {\n+                  FunctionType functionType = registry.getFunctionType(functionNode);\n+                  if (functionType != null) {\n+                    JSType calleeType =\n+                        functionType.getTypeOfThis().dereference().getNormalizedReference();\n+                    if (calleeType instanceof FunctionType) {\n+                      FunctionType fType = (FunctionType) calleeType;\n+                      ObjectType inferredType = inference.getObjectType(argNode);\n+                      if (!inferredType.isUnknown()) {\n+                        inferredType = inferredType.autobox();\n+                        JSType callReturnType = fType.getTypeOfThis().getReturnType(inferredType);\n+                        if (!callReturnType.isUnknown()) {\n+                          callReturnType = registry.expandType(callReturnType);\n+                          traverseWithExpression(callReturnType, argNode);\n+                        }\n+                      }\n+                    } else {\n+                      traverseUnknownExpression(argNode);\n+                    }\n+                  } else {\n+                    traverseUnknownExpression(argNode);\n+                  }\n+                }\n+              } else {\n+                traverseUnknownExpression(callTargetNode);\n+              }\n+            }\n+          }\n+        }\n+      }\n     }\n \n     if (parent != null && parent.getType() == Token.ASSIGN) {",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}