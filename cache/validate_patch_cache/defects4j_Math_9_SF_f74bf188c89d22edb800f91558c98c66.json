{
    "patch": "public Line revert() {\n    final Line reverted = new Line(zero, direction.negate());\n    double[] bounds = getBounds();\n    revertToBounds(bounds, reverted);\n    return reverted;\n}\n\nprivate void revertToBounds(double[] bounds, final Line reverted) {\n    if (bounds[2] != bounds[3]) { // slope is finite\n        Line l = reverted.boundaryIntersects(bounds);\n        if (l != null) {\n            reverted.setDirection(l.getDirection());\n        }\n    } else { // vertical line\n        double x = bounds[0];\n        double y1 = bounds[1];\n        double y2 = bounds[1] + bounds[3];\n        Point p1 = new Point(x, y1);\n        Point p2 = new Point(x, y2);\n        Line l = new Line(p1, p2);\n        reverted.setDirection(l.direction);\n    }\n}\n\nprivate double[] getBounds() {\n    double x = zero.getX();\n    double y = zero.getY();\n    double dy = direction.getY();\n    double dx = direction.getX();\n    double minY = Math.min(y, y + dy);\n    double maxY = Math.max(y, y + dy);\n    double minX = Math.min(x, x + dx);\n    double maxX = Math.max(x, x + dx);\n    return new double[] {minX, minY, maxX, maxY};\n}\n\nprivate Line boundaryIntersects(double[] bounds) {\n    Point p1 = new Point(bounds[0], bounds[1]);\n    Point p2 = new Point(bounds[0], bounds[1] + bounds[3]);\n    Point p3 = new Point(bounds[0] + bounds[2], bounds[1] + bounds[3]);\n    Point p4 = new Point(bounds[0] + bounds[2], bounds[1]);\n    Line[] lines = new Line[] {new Line(p1, p2), new Line(p2, p3), new Line(p3, p4), new Line(p4, p1)};\n\n    for (Line l : lines) {\n        if (this.intersect(l)) {\n            return l;\n        }\n    }\n    return null;\n}\n\nprivate boolean intersect(Line line) {\n    Point p1 = zero;\n    Point p2 = p1.add(direction);\n    Point p3 = line.zero;\n    Point p4 = p3.add(line.direction);\n\n    double d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);\n    if (d == 0) {\n        return false;\n    }\n\n    double xi = ((p3.x - p4.x) * (p1.x * p2.y - p1.y * p2.x) - (p1.x - p2.x) * (p3.x * p4.y - p3.y * p4.x))\n            / d;\n    double yi = ((p3.y - p4.y) * (p1.x * p2.y - p1.y * p2.x) - (p1.y - p2.y) * (p3.x * p4.y - p3.y * p4.x))\n            / d;\n\n    return (xi > Math.min(p1.x, p2.x) && xi < Math.max(p1.x, p2.x))\n            && (xi > Math.min(p3.x, p4.x) && xi < Math.max(p3.x, p4.x))\n            && (yi > Math.min(p1.y, p2.y) && yi < Math.max(p1.y, p2.y))\n            && (yi > Math.min(p3.y, p4.y) && yi < Math.max(p3.y, p4.y));\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\nindex 674c4aada..b971477b5 100644\n--- a/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n+++ b/src/main/java/org/apache/commons/math3/geometry/euclidean/threed/Line.java\n@@ -83,10 +83,78 @@ public class Line implements Embedding<Euclidean3D, Euclidean1D> {\n     /** Get a line with reversed direction.\n      * @return a new instance, with reversed direction\n      */\n-    public Line revert() {\n-        final Line reverted = new Line(zero, zero.subtract(direction));\n-        return reverted;\n+public Line revert() {\n+    final Line reverted = new Line(zero, direction.negate());\n+    double[] bounds = getBounds();\n+    revertToBounds(bounds, reverted);\n+    return reverted;\n+}\n+\n+private void revertToBounds(double[] bounds, final Line reverted) {\n+    if (bounds[2] != bounds[3]) { // slope is finite\n+        Line l = reverted.boundaryIntersects(bounds);\n+        if (l != null) {\n+            reverted.setDirection(l.getDirection());\n+        }\n+    } else { // vertical line\n+        double x = bounds[0];\n+        double y1 = bounds[1];\n+        double y2 = bounds[1] + bounds[3];\n+        Point p1 = new Point(x, y1);\n+        Point p2 = new Point(x, y2);\n+        Line l = new Line(p1, p2);\n+        reverted.setDirection(l.direction);\n     }\n+}\n+\n+private double[] getBounds() {\n+    double x = zero.getX();\n+    double y = zero.getY();\n+    double dy = direction.getY();\n+    double dx = direction.getX();\n+    double minY = Math.min(y, y + dy);\n+    double maxY = Math.max(y, y + dy);\n+    double minX = Math.min(x, x + dx);\n+    double maxX = Math.max(x, x + dx);\n+    return new double[] {minX, minY, maxX, maxY};\n+}\n+\n+private Line boundaryIntersects(double[] bounds) {\n+    Point p1 = new Point(bounds[0], bounds[1]);\n+    Point p2 = new Point(bounds[0], bounds[1] + bounds[3]);\n+    Point p3 = new Point(bounds[0] + bounds[2], bounds[1] + bounds[3]);\n+    Point p4 = new Point(bounds[0] + bounds[2], bounds[1]);\n+    Line[] lines = new Line[] {new Line(p1, p2), new Line(p2, p3), new Line(p3, p4), new Line(p4, p1)};\n+\n+    for (Line l : lines) {\n+        if (this.intersect(l)) {\n+            return l;\n+        }\n+    }\n+    return null;\n+}\n+\n+private boolean intersect(Line line) {\n+    Point p1 = zero;\n+    Point p2 = p1.add(direction);\n+    Point p3 = line.zero;\n+    Point p4 = p3.add(line.direction);\n+\n+    double d = (p1.x - p2.x) * (p3.y - p4.y) - (p1.y - p2.y) * (p3.x - p4.x);\n+    if (d == 0) {\n+        return false;\n+    }\n+\n+    double xi = ((p3.x - p4.x) * (p1.x * p2.y - p1.y * p2.x) - (p1.x - p2.x) * (p3.x * p4.y - p3.y * p4.x))\n+            / d;\n+    double yi = ((p3.y - p4.y) * (p1.x * p2.y - p1.y * p2.x) - (p1.y - p2.y) * (p3.x * p4.y - p3.y * p4.x))\n+            / d;\n+\n+    return (xi > Math.min(p1.x, p2.x) && xi < Math.max(p1.x, p2.x))\n+            && (xi > Math.min(p3.x, p4.x) && xi < Math.max(p3.x, p4.x))\n+            && (yi > Math.min(p1.y, p2.y) && yi < Math.max(p1.y, p2.y))\n+            && (yi > Math.min(p3.y, p4.y) && yi < Math.max(p3.y, p4.y));\n+}\n \n     /** Get the normalized direction vector.\n      * @return normalized direction vector",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}