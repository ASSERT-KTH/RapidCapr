{
    "patch": "import org.apache.commons.math3.util.FastMath;\nimport org.apache.commons.math3.util.MathUtils;\n\npublic class RegularizedGamma {\n\n    private static final double DEFAULT_EPSILON = 1e-9;\n\n    private RegularizedGamma() {}\n\n    public static double logGamma(double x) {\n        double ret;\n        double[] cof = {76.18009172947146, -86.50532032941677,\n                        24.01409824083091, -1.231739572450155,\n                        0.1208650973866179e-2, -0.5395239384953e-5};\n        double y = x;\n        double tmp = x + 5.5;\n        tmp -= (x + 0.5) * FastMath.log(tmp);\n        double ser = 1.000000000190015;\n        for (int i = 0; i < 6; ++i) {\n            y += 1;\n            ser += cof[i] / y;\n        }\n        ret = -tmp + FastMath.log(2.5066282746310005 * ser / x);\n        return ret;\n    }\n\n    public static double gamma(double x) {\n        return FastMath.exp(logGamma(x));\n    }\n\n    /**\n     * Regularized gamma function Q(a, x) = 1 / \u0393(a) \u222bx\u221e t^(a-1) exp(-t) dt.\n     *\n     * @param a   a\n     * @param x   x\n     * @param eps maximum absolute error.\n     * @param maxIter maximum number of iterations.\n     * @return regularized gamma function.\n     * @throws IllegalStateException if convergence is not achieved.\n     */\n    public static double regularizedGammaQ(double a, double x, double eps, int maxIter) {\n        double ret;\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 1.0;\n        } else if (x < a + 1.0) {\n            double rGam = 1.0 / gamma(a);\n            ContinuedFraction cf = new ContinuedFraction() {\n\n                @Override\n                protected double getA(int n, double x) {\n                    return 2.0 * n + 1.0 - a + x;\n                }\n\n                @Override\n                protected double getB(int n, double x) {\n                    return n * (a - n);\n                }\n            };\n            ret = 1.0 - rGam * cf.evaluate(x / (a + 1.0 - x), eps, maxIter);\n        } else { // x >= a + 1.0\n            double igf = regularizedGammaP(a, x, eps, maxIter);\n            ret = (igf < FastMath.exp(-x) / DEFAULT_EPSILON) ? 1.0 : igf / FastMath.exp(logGamma(a) + FastMath.log(x) - x);\n        }\n        if (Double.isInfinite(ret) || Double.isNaN(ret)) {\n            throw new IllegalStateException(\"Numerical convergence failed: gamma\");\n        }\n        return ret;\n    }\n\n    /**\n     * Regularized gamma function P(a, x) = 1 / \u0393(a) \u222b0x t^(a-1) exp(-t) dt.\n     *\n     * @param a   parameter a.\n     * @param x   parameter x.\n     * @param eps maximum absolute error.\n     * @param maxIter maximum number of iterations.\n     * @return regularized gamma function.\n     * @throws IllegalStateException if convergence is not achieved.\n     */\n    public static double regularizedGammaP(double a, double x, double eps, int maxIter) {\n        double ret;\n        if (Double.isNaN(a) || Double.isNaN(x) || a <= 0.0 || x < 0.0) {\n            ret = Double.NaN;\n        } else if (x == 0.0) {\n            ret = 0.0;\n        } else if (x < a + 1.0) {\n            double rGam = 1.0 / gamma(a);\n            ContinuedFraction cf = new ContinuedFraction() {\n\n                @Override\n                protected double getA(int n, double x) {\n                    return n + 1.0 - a;\n                }\n\n                @Override\n                protected double getB(int n, double x) {\n                    return x;\n                }\n            };\n            ret = rGam * cf.evaluate(x / (a + 1.0), eps, maxIter);\n        } else { // x >= a + 1.0\n            double gc = Gamma.gamma(a, x, eps, maxIter);\n            ret = gc / gamma(a);\n        }\n        if (Double.isInfinite(ret) || Double.isNaN(ret)) {\n            throw new IllegalStateException(\"Numerical convergence failed: gamma\");\n        }\n        return ret;\n    }\n\n    /**\n     * Regularized gamma function Q(a, x) = 1 / \u0393(a) \u222bx\u221e t^(a-1) exp(-t) dt.\n     *\n     * @param a parameter a.\n     * @param x parameter x.\n     * @return Regularized gamma function Q(a, x) = 1 / \u0393(a) \u222bx\u221e t^(a-1) exp(-t) dt.\n     * @throws IllegalStateException if convergence is not achieved.\n     */\n    public static double regularizedGammaQ(double a, double x) {\n        return regularizedGammaQ(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n\n    /**\n     * Regularized gamma function P(a, x) = 1 / \u0393(a) \u222b0x t^(a-1) exp(-t) dt.\n     *\n     * @param a parameter a.\n     * @param x parameter x.\n     * @return Regularized gamma function P(a, x) = 1 / \u0393(a) \u222b0x t^(a-1) exp(-t) dt.\n     * @throws IllegalStateException if convergence is not achieved.\n     */\n    public static double regularizedGammaP(double a, double x) {\n        return regularizedGammaP(a, x, DEFAULT_EPSILON, Integer.MAX_VALUE);\n    }\n\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..bade3b581 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,7 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}