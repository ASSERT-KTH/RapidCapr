{
    "patch": "    // Count the total number of parameters\n    int paramCount = 0;\n    Node c = argList.getFirstChild();\n    while(c != null) {\n      paramCount++;\n      c = c.getNext();\n    }\n\n    if (!modifyCallers) {\n      // Strip unreferenced args off the end of the function declaration.\n      int newParamCount = 0;\n      Node lastArg;\n      while ((lastArg = argList.getLastChild()) != null) {\n        Var var = fnScope.getVar(lastArg.getString());\n        if (!referenced.contains(var)) {\n          argList.removeChild(lastArg);\n          newParamCount++;\n        } else {\n          break;\n        }\n      }\n\n      // if a param has been removed, artificially increase the arity to avoid\n      // breaking user code that relies on \"length\".\n      if (newParamCount > 0 && compiler.getOptions().isClosurePass()) {\n        Node nameNode = NodeUtil.getNameNode(function);\n        if (nameNode != null) {\n          Node lValue = nameNode.getFirstChild();\n          String name = lValue.getString();\n\n          Var var = fnScope.getVar(name);\n          if (var != null) {\n            Node defaultValue = null;\n            if (compiler.getOptions().preservesDetailedSourceInfo()) {\n              defaultValue = NodeUtil.getBestLValueClone(lValue);\n              defaultValue.removeChildren();\n              defaultValue.setSourceFileName(\n                  function.getSourceFileName());\n              defaultValue.setLineno(lValue.getLineno());\n              defaultValue.setCharno(lValue.getCharno());\n              defaultValue.setLength(name.length());\n            } else {\n              defaultValue = IR.name(name);\n            }\n\n            for (int i = 0; i < newParamCount; i++) {\n              Node newParam = IR.param(\"$jscomp$unused\" + unusedIndex++);\n              newParam.setJSDocInfo(lastArg.getJSDocInfo());\n              lastArg.getParent().replaceChild(\n                  lastArg, IR.assign(IR.cloneNode(defaultValue), lastArg));\n              lastArg = newParam;\n            }\n            Node newBlock = IR.block(IR.returnNode(function.getLastChild()));\n            Node newFn = IR.function(IR.name(\"\"), IR.paramList(), newBlock);\n            NodeUtil.addFeatureToScript(compiler, Feature.LAZY_BLOCK);\n            Node lazyBlock = NodeUtil.getEnclosingLazyBlock(function);\n            if (lazyBlock == null) {\n              function.getParent().replaceChild(function, newFn);\n            } else {\n              lazyBlock.getParent().replaceChild(lazyBlock, newFn);\n            }\n            compiler.reportCodeChange();\n            return;\n          }\n        }\n      }\n\n      if (newParamCount != 0 && compiler.getOptions().removeUnusedParams()) {\n        // There are some unreferenced args that have been removed.\n        // Need to adjust the number of parameters in the function signature\n        while (newParamCount > 0 && paramCount > 1) {\n          Node n = argList.getLastChild();\n          argList.removeChild(n);\n          newParamCount--;\n          paramCount--;\n        }\n        compiler.reportCodeChange();",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..ac58386f 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,83 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+    // Count the total number of parameters\n+    int paramCount = 0;\n+    Node c = argList.getFirstChild();\n+    while(c != null) {\n+      paramCount++;\n+      c = c.getNext();\n+    }\n+\n+    if (!modifyCallers) {\n+      // Strip unreferenced args off the end of the function declaration.\n+      int newParamCount = 0;\n+      Node lastArg;\n+      while ((lastArg = argList.getLastChild()) != null) {\n+        Var var = fnScope.getVar(lastArg.getString());\n+        if (!referenced.contains(var)) {\n+          argList.removeChild(lastArg);\n+          newParamCount++;\n+        } else {\n+          break;\n+        }\n+      }\n+\n+      // if a param has been removed, artificially increase the arity to avoid\n+      // breaking user code that relies on \"length\".\n+      if (newParamCount > 0 && compiler.getOptions().isClosurePass()) {\n+        Node nameNode = NodeUtil.getNameNode(function);\n+        if (nameNode != null) {\n+          Node lValue = nameNode.getFirstChild();\n+          String name = lValue.getString();\n+\n+          Var var = fnScope.getVar(name);\n+          if (var != null) {\n+            Node defaultValue = null;\n+            if (compiler.getOptions().preservesDetailedSourceInfo()) {\n+              defaultValue = NodeUtil.getBestLValueClone(lValue);\n+              defaultValue.removeChildren();\n+              defaultValue.setSourceFileName(\n+                  function.getSourceFileName());\n+              defaultValue.setLineno(lValue.getLineno());\n+              defaultValue.setCharno(lValue.getCharno());\n+              defaultValue.setLength(name.length());\n+            } else {\n+              defaultValue = IR.name(name);\n+            }\n+\n+            for (int i = 0; i < newParamCount; i++) {\n+              Node newParam = IR.param(\"$jscomp$unused\" + unusedIndex++);\n+              newParam.setJSDocInfo(lastArg.getJSDocInfo());\n+              lastArg.getParent().replaceChild(\n+                  lastArg, IR.assign(IR.cloneNode(defaultValue), lastArg));\n+              lastArg = newParam;\n+            }\n+            Node newBlock = IR.block(IR.returnNode(function.getLastChild()));\n+            Node newFn = IR.function(IR.name(\"\"), IR.paramList(), newBlock);\n+            NodeUtil.addFeatureToScript(compiler, Feature.LAZY_BLOCK);\n+            Node lazyBlock = NodeUtil.getEnclosingLazyBlock(function);\n+            if (lazyBlock == null) {\n+              function.getParent().replaceChild(function, newFn);\n+            } else {\n+              lazyBlock.getParent().replaceChild(lazyBlock, newFn);\n+            }\n+            compiler.reportCodeChange();\n+            return;\n+          }\n+        }\n+      }\n+\n+      if (newParamCount != 0 && compiler.getOptions().removeUnusedParams()) {\n+        // There are some unreferenced args that have been removed.\n+        // Need to adjust the number of parameters in the function signature\n+        while (newParamCount > 0 && paramCount > 1) {\n+          Node n = argList.getLastChild();\n+          argList.removeChild(n);\n+          newParamCount--;\n+          paramCount--;\n+        }\n+        compiler.reportCodeChange();\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}