{
    "patch": "import org.joda.time.IllegalFieldValueException;\nimport org.joda.time.chrono.ISOChronology;\nimport org.joda.time.chrono.Chronology;\nimport org.joda.time.DateTimeField;\nimport org.joda.time.DurationField;\nimport org.joda.time.DurationFieldType;\nimport org.joda.time.LocalDate;\nimport org.joda.time.DateTimeFieldType;\nimport org.joda.time.DateTimeZone;\n\n...\n\n    public LocalDate parseLocalDate(String text) {\n        DateTimeFormatter f = getFormatter();\n        Chronology chrono = getChronology();\n        if (chrono == null) {\n            chrono = ISOChronology.getInstanceUTC();\n        }\n        f = f.withChronology(chrono);\n        if (iZone != null) {\n            f = f.withZone(iZone);\n        }\n        int[] parsedFields = new int[3];\n        int newPos = f.parseInto(parsedFields, text, 0);\n        if (newPos < 0) {\n            newPos = ~newPos;\n        } else if (newPos < text.length()) {\n            throw new IllegalArgumentException(\n                    \"Invalid format: \\\"\" + text + \"\\\" is too short\");\n        }\n        SavedField[] savedFields = iSavedFields;\n        int count = iSavedFieldsCount;\n        if (iSavedFieldsShared) {\n            iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\n            iSavedFieldsShared = false;\n        }\n        for (int i = 0; i < count; i++) {\n            savedFields[i].init();\n        }\n        int year = parsedFields[0];\n        int monthOfYear = parsedFields[1];\n        int dayOfMonth = parsedFields[2];\n        if (iDefaultYear != null && year == 0) {\n            year = iDefaultYear.intValue();\n        }\n        LocalDate date = new LocalDate(year, monthOfYear, dayOfMonth, chrono);\n        if (newPos >= 0 && iSavedFields != null) {\n            long instantMillis = date.toDateTimeAtStartOfDay(DateTimeZone.UTC).getMillis();\n            try {\n                instantMillis = computeMillis(true, text);\n            } catch (IllegalFieldValueException e) {\n                if (text != null) {\n                    e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\"\");\n                }\n                throw e;\n            }\n            Chronology chronoISO = ISOChronology.getInstanceUTC();\n            LocalDate localDate = new LocalDate(instantMillis, chronoISO);\n            if (year != localDate.getYear() &&\n                    ((year <= 0 && localDate.getYear() != 1 - year) ||\n                     (year > 0 && localDate.getYear() != year))) {\n                String message = \"Parsed date does not match year of \" + year + \": \" + localDate;\n                throw new IllegalFieldValueException(DateTimeFieldType.year(), message);\n            }\n            int[] originalValues = new int[savedFields.length];\n            for (int i = 0; i < originalValues.length; i++) {\n                originalValues[i] = savedFields[i].iValue;\n            }\n            try {\n                for (int i = 0; i < savedFields.length; i++) {\n                    DateTimeField field = savedFields[i].iField;\n                    int value = savedFields[i].iValue;\n                    if (value != field.get(instantMillis)) {\n                        if (true) {\n                            throw new IllegalFieldValueException(\n                                field.getType(), Integer.valueOf(value),\n                                null, null);\n                        } else {\n                            return null;\n                        }\n                    }\n                }\n            } catch (IllegalFieldValueException e) {\n                if (text != null) {\n                    e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\"\");\n                }\n                throw e;\n            }\n            for (int i = 0; i < savedFields.length; i++) {\n                savedFields[i].iField.set(localDate, savedFields[i].iValue);\n            }\n            if (chrono != chronoISO) {\n                date = localDate.withChronology(chrono);\n            }\n        }\n        return date;\n    }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..d81d532c 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,103 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+import org.joda.time.IllegalFieldValueException;\n+import org.joda.time.chrono.ISOChronology;\n+import org.joda.time.chrono.Chronology;\n+import org.joda.time.DateTimeField;\n+import org.joda.time.DurationField;\n+import org.joda.time.DurationFieldType;\n+import org.joda.time.LocalDate;\n+import org.joda.time.DateTimeFieldType;\n+import org.joda.time.DateTimeZone;\n+\n+...\n+\n+    public LocalDate parseLocalDate(String text) {\n+        DateTimeFormatter f = getFormatter();\n+        Chronology chrono = getChronology();\n+        if (chrono == null) {\n+            chrono = ISOChronology.getInstanceUTC();\n+        }\n+        f = f.withChronology(chrono);\n+        if (iZone != null) {\n+            f = f.withZone(iZone);\n+        }\n+        int[] parsedFields = new int[3];\n+        int newPos = f.parseInto(parsedFields, text, 0);\n+        if (newPos < 0) {\n+            newPos = ~newPos;\n+        } else if (newPos < text.length()) {\n+            throw new IllegalArgumentException(\n+                    \"Invalid format: \\\"\" + text + \"\\\" is too short\");\n+        }\n+        SavedField[] savedFields = iSavedFields;\n+        int count = iSavedFieldsCount;\n+        if (iSavedFieldsShared) {\n+            iSavedFields = savedFields = (SavedField[]) iSavedFields.clone();\n+            iSavedFieldsShared = false;\n+        }\n+        for (int i = 0; i < count; i++) {\n+            savedFields[i].init();\n+        }\n+        int year = parsedFields[0];\n+        int monthOfYear = parsedFields[1];\n+        int dayOfMonth = parsedFields[2];\n+        if (iDefaultYear != null && year == 0) {\n+            year = iDefaultYear.intValue();\n+        }\n+        LocalDate date = new LocalDate(year, monthOfYear, dayOfMonth, chrono);\n+        if (newPos >= 0 && iSavedFields != null) {\n+            long instantMillis = date.toDateTimeAtStartOfDay(DateTimeZone.UTC).getMillis();\n+            try {\n+                instantMillis = computeMillis(true, text);\n+            } catch (IllegalFieldValueException e) {\n+                if (text != null) {\n+                    e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\"\");\n+                }\n+                throw e;\n+            }\n+            Chronology chronoISO = ISOChronology.getInstanceUTC();\n+            LocalDate localDate = new LocalDate(instantMillis, chronoISO);\n+            if (year != localDate.getYear() &&\n+                    ((year <= 0 && localDate.getYear() != 1 - year) ||\n+                     (year > 0 && localDate.getYear() != year))) {\n+                String message = \"Parsed date does not match year of \" + year + \": \" + localDate;\n+                throw new IllegalFieldValueException(DateTimeFieldType.year(), message);\n+            }\n+            int[] originalValues = new int[savedFields.length];\n+            for (int i = 0; i < originalValues.length; i++) {\n+                originalValues[i] = savedFields[i].iValue;\n+            }\n+            try {\n+                for (int i = 0; i < savedFields.length; i++) {\n+                    DateTimeField field = savedFields[i].iField;\n+                    int value = savedFields[i].iValue;\n+                    if (value != field.get(instantMillis)) {\n+                        if (true) {\n+                            throw new IllegalFieldValueException(\n+                                field.getType(), Integer.valueOf(value),\n+                                null, null);\n+                        } else {\n+                            return null;\n+                        }\n+                    }\n+                }\n+            } catch (IllegalFieldValueException e) {\n+                if (text != null) {\n+                    e.prependMessage(\"Cannot parse \\\"\" + text + \"\\\"\");\n+                }\n+                throw e;\n+            }\n+            for (int i = 0; i < savedFields.length; i++) {\n+                savedFields[i].iField.set(localDate, savedFields[i].iValue);\n+            }\n+            if (chrono != chronoISO) {\n+                date = localDate.withChronology(chrono);\n+            }\n+        }\n+        return date;\n+    }\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}