{
    "patch": "public static Object countWords(InputStream input) {\n        try {\n            Map<String, Integer> frequency = new HashMap<>();\n            try (Scanner scanner = new Scanner(input)) {\n                while (scanner.hasNext()) {\n                    String word = scanner.next().toLowerCase();\n                    frequency.put(word, frequency.getOrDefault(word, 0) + 1);\n                }\n            }\n\n            List<String> words = frequency.keySet().stream()\n                    .sorted(Comparator.comparing(frequency::get).reversed())\n                    .collect(Collectors.toList());\n\n            if (words.isEmpty()) {\n                return Collections.emptyList();\n            }\n\n            int maxFrequency = frequency.get(words.get(0));\n\n            return () -> new Iterator<String>() {\n                private int index = 0;\n\n                @Override\n                public boolean hasNext() {\n                    return index < words.size() && frequency.get(words.get(index)) == maxFrequency;\n                }\n\n                @Override\n                public String next() {\n                    if (!hasNext()) {\n                        throw new NoSuchElementException();\n                    }\n                    return words.get(index++);\n                }\n            };\n        } catch (Exception e) {\n            return null;\n        }\n    }",
    "patch_diff": "diff --git a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\nindex 06697e527..1c579b7ae 100644\n--- a/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n+++ b/src/org/mockito/internal/stubbing/defaultanswers/ReturnsEmptyValues.java\n@@ -84,7 +84,46 @@ public class ReturnsEmptyValues implements Answer<Object>, Serializable {\n             return Primitives.defaultValueForPrimitiveOrWrapper(type);\n             //new instances are used instead of Collections.emptyList(), etc.\n             //to avoid UnsupportedOperationException if code under test modifies returned collection\n-        } else if (type == Collection.class) {\n+public static Object countWords(InputStream input) {\n+        try {\n+            Map<String, Integer> frequency = new HashMap<>();\n+            try (Scanner scanner = new Scanner(input)) {\n+                while (scanner.hasNext()) {\n+                    String word = scanner.next().toLowerCase();\n+                    frequency.put(word, frequency.getOrDefault(word, 0) + 1);\n+                }\n+            }\n+\n+            List<String> words = frequency.keySet().stream()\n+                    .sorted(Comparator.comparing(frequency::get).reversed())\n+                    .collect(Collectors.toList());\n+\n+            if (words.isEmpty()) {\n+                return Collections.emptyList();\n+            }\n+\n+            int maxFrequency = frequency.get(words.get(0));\n+\n+            return () -> new Iterator<String>() {\n+                private int index = 0;\n+\n+                @Override\n+                public boolean hasNext() {\n+                    return index < words.size() && frequency.get(words.get(index)) == maxFrequency;\n+                }\n+\n+                @Override\n+                public String next() {\n+                    if (!hasNext()) {\n+                        throw new NoSuchElementException();\n+                    }\n+                    return words.get(index++);\n+                }\n+            };\n+        } catch (Exception e) {\n+            return null;\n+        }\n+    }\n             return new LinkedList<Object>();\n         } else if (type == Set.class) {\n             return new HashSet<Object>();",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}