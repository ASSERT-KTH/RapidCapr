{
    "patch": "if (isInfinite()) {\n    if (lessThan(getZero())) {\n        return Double.NEGATIVE_INFINITY;\n    } else {\n        return Double.POSITIVE_INFINITY;\n    }\n}\nif (isNaN()) {\n    return Double.NaN;\n}\n\nDfp y = this;\nboolean negate = false;\ny = y.negate();\nnegate = true;\n\n/* Find the exponent, first estimate by integer log10, then adjust.\nShould be faster than doing a natural logarithm.  */\nint exponent = (int) (y.log10() * 3.32);\nif (exponent < 0) {\n    exponent--;\n}\n\nDfp tempDfp = DfpMath.pow(getTwo(), exponent);\nwhile (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n    tempDfp = tempDfp.multiply(2);\n    exponent++;\n}\nexponent--;\n\n/* We have the exponent, now work on the mantissa */\n\ny = y.divide(DfpMath.pow(getTwo(), exponent));\nif (exponent > -1023) {\n    y = y.subtract(getOne());\n}\n\nif (exponent < -1074) {\n    return 0;\n}\n\nif (exponent > 1023) {\n    return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n}\n\ny = y.multiply(newInstance(4503599627370496l)).rint();\nString str = y.toString();\nstr = str.substring(0, str.length() - 1);\nlong mantissa = Long.parseLong(str);\n\nif (mantissa == 4503599627370496L) {\n    // Handle special case where we round up to next power of two\n    mantissa = 0;\n    exponent++;\n}\n\n/* Its going to be subnormal, so make adjustments */\nif (exponent <= -1023) {\n    exponent--;\n}\n\nwhile (exponent < -1023) {\n    exponent++;\n    mantissa >>>= 1;\n}\n\nlong bits = mantissa | ((exponent + 1023L) << 52);\ndouble x = Double.longBitsToDouble(bits);\n\nif (negate) {\n    x = -x;\n}\n\nreturn x;",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/dfp/Dfp.java b/src/main/java/org/apache/commons/math/dfp/Dfp.java\nindex 73f1ea3e8..73f43a360 100644\n--- a/src/main/java/org/apache/commons/math/dfp/Dfp.java\n+++ b/src/main/java/org/apache/commons/math/dfp/Dfp.java\n@@ -253,88 +253,80 @@ public class Dfp implements FieldElement<Dfp> {\n      * @param field field to which this instance belongs\n      * @param x value to convert to an instance\n      */\n-    protected Dfp(final DfpField field, double x) {\n+if (isInfinite()) {\n+    if (lessThan(getZero())) {\n+        return Double.NEGATIVE_INFINITY;\n+    } else {\n+        return Double.POSITIVE_INFINITY;\n+    }\n+}\n+if (isNaN()) {\n+    return Double.NaN;\n+}\n \n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n-        this.field = field;\n+Dfp y = this;\n+boolean negate = false;\n+y = y.negate();\n+negate = true;\n \n-        long bits = Double.doubleToLongBits(x);\n-        long mantissa = bits & 0x000fffffffffffffL;\n-        int exponent = (int) ((bits & 0x7ff0000000000000L) >> 52) - 1023;\n+/* Find the exponent, first estimate by integer log10, then adjust.\n+Should be faster than doing a natural logarithm.  */\n+int exponent = (int) (y.log10() * 3.32);\n+if (exponent < 0) {\n+    exponent--;\n+}\n \n-        if (exponent == -1023) {\n-            // Zero or sub-normal\n-            if (x == 0) {\n-                // make sure 0 has the right sign\n-                return;\n-            }\n+Dfp tempDfp = DfpMath.pow(getTwo(), exponent);\n+while (tempDfp.lessThan(y) || tempDfp.equals(y)) {\n+    tempDfp = tempDfp.multiply(2);\n+    exponent++;\n+}\n+exponent--;\n \n-            exponent++;\n+/* We have the exponent, now work on the mantissa */\n \n-            // Normalize the subnormal number\n-            while ( (mantissa & 0x0010000000000000L) == 0) {\n-                exponent--;\n-                mantissa <<= 1;\n-            }\n-            mantissa &= 0x000fffffffffffffL;\n-        }\n+y = y.divide(DfpMath.pow(getTwo(), exponent));\n+if (exponent > -1023) {\n+    y = y.subtract(getOne());\n+}\n \n-        if (exponent == 1024) {\n-            // infinity or NAN\n-            if (x != x) {\n-                sign = (byte) 1;\n-                nans = QNAN;\n-            } else if (x < 0) {\n-                sign = (byte) -1;\n-                nans = INFINITE;\n-            } else {\n-                sign = (byte) 1;\n-                nans = INFINITE;\n-            }\n-            return;\n-        }\n+if (exponent < -1074) {\n+    return 0;\n+}\n \n-        Dfp xdfp = new Dfp(field, mantissa);\n-        xdfp = xdfp.divide(new Dfp(field, 4503599627370496l)).add(field.getOne());  // Divide by 2^52, then add one\n-        xdfp = xdfp.multiply(DfpMath.pow(field.getTwo(), exponent));\n+if (exponent > 1023) {\n+    return negate ? Double.NEGATIVE_INFINITY : Double.POSITIVE_INFINITY;\n+}\n \n-        if ((bits & 0x8000000000000000L) != 0) {\n-            xdfp = xdfp.negate();\n-        }\n+y = y.multiply(newInstance(4503599627370496l)).rint();\n+String str = y.toString();\n+str = str.substring(0, str.length() - 1);\n+long mantissa = Long.parseLong(str);\n \n-        System.arraycopy(xdfp.mant, 0, mant, 0, mant.length);\n-        sign = xdfp.sign;\n-        exp  = xdfp.exp;\n-        nans = xdfp.nans;\n+if (mantissa == 4503599627370496L) {\n+    // Handle special case where we round up to next power of two\n+    mantissa = 0;\n+    exponent++;\n+}\n \n-    }\n+/* Its going to be subnormal, so make adjustments */\n+if (exponent <= -1023) {\n+    exponent--;\n+}\n \n-    /** Copy constructor.\n-     * @param d instance to copy\n-     */\n-    public Dfp(final Dfp d) {\n-        mant  = d.mant.clone();\n-        sign  = d.sign;\n-        exp   = d.exp;\n-        nans  = d.nans;\n-        field = d.field;\n-    }\n+while (exponent < -1023) {\n+    exponent++;\n+    mantissa >>>= 1;\n+}\n \n-    /** Create an instance from a String representation.\n-     * @param field field to which this instance belongs\n-     * @param s string representation of the instance\n-     */\n-    protected Dfp(final DfpField field, final String s) {\n+long bits = mantissa | ((exponent + 1023L) << 52);\n+double x = Double.longBitsToDouble(bits);\n \n-        // initialize as if 0\n-        mant = new int[field.getRadixDigits()];\n-        sign = 1;\n-        exp = 0;\n-        nans = FINITE;\n+if (negate) {\n+    x = -x;\n+}\n+\n+return x;\n         this.field = field;\n \n         boolean decimalFound = false;",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}