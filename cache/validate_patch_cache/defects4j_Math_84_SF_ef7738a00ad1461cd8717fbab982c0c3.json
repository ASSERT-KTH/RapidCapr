{
    "patch": "protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n    final int numVertices = simplex.length;\n    final double[] xSmallest = simplex[0].getPointRef();\n    final double[] xLargest = simplex[numVertices - 1].getPointRef();\n    int numIterations = 0;\n    final int maxIterations = getMaxIterations();\n    while (numIterations < maxIterations) {\n        incrementIterationsCounter();\n        numIterations++;\n        final RealPointValuePair xR = evaluateNewSimplex(simplex, -1, comparator);\n        if (comparator.compare(xR, xSmallest) < 0) {\n            final RealPointValuePair xE = evaluateNewSimplex(simplex, gamma, comparator);\n            if (comparator.compare(xR, xE) < 0) {\n                // replace the worst point with the reflected point\n                simplex[numVertices - 1] = xR;\n            } else {\n                // replace the worst point with the expanded point\n                simplex[numVertices - 1] = xE;\n            }\n        } else {\n            final RealPointValuePair secondWorst = simplex[numVertices - 2];\n            if (comparator.compare(xR, secondWorst) < 0) {\n                // replace the worst point with the reflected point\n                simplex[numVertices - 1] = xR;\n            } else {\n                // Perform the contraction\n                RealPointValuePair xC;\n                if (comparator.compare(xR, xLargest) < 0) {\n                    xC = evaluateNewSimplex(simplex, rho, comparator);\n                    if (comparator.compare(xC, xLargest) >= 0) {\n                        shrink(comparator);\n                    } else {\n                        simplex[numVertices - 1] = xC;\n                    }\n                } else {\n                    xC = evaluateNewSimplex(simplex, rho, comparator);\n                    if (comparator.compare(xC, xR) < 0) {\n                        simplex[numVertices - 1] = xC;\n                    } else {\n                        shrink(comparator);\n                    }\n                }\n            }\n        }\n    }\n    throw new OptimizationException(\"Maximal number of iterations exceeded: \" + maxIterations);\n}\n\nprivate void shrink(final Comparator<RealPointValuePair> comparator) {\n    final RealPointValuePair[] current = simplex;\n    final RealPointValuePair best = current[0];\n    for (int i = 1; i < current.length; i++) {\n        final double[] x = current[i].getPoint();\n        for (int j = 0; j < x.length; j++) {\n            x[j] = best.getPoint()[j] + sigma * (x[j] - best.getPoint()[j]);\n        }\n        current[i] = new RealPointValuePair(x, Double.NaN);\n    }\n    evaluateSimplex(comparator);\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..cdb83463c 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,45 +58,67 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n+protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n         throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n-\n-        while (true) {\n-\n-            incrementIterationsCounter();\n-\n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n-\n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n-\n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n-\n-                return;\n-\n+    final int numVertices = simplex.length;\n+    final double[] xSmallest = simplex[0].getPointRef();\n+    final double[] xLargest = simplex[numVertices - 1].getPointRef();\n+    int numIterations = 0;\n+    final int maxIterations = getMaxIterations();\n+    while (numIterations < maxIterations) {\n+        incrementIterationsCounter();\n+        numIterations++;\n+        final RealPointValuePair xR = evaluateNewSimplex(simplex, -1, comparator);\n+        if (comparator.compare(xR, xSmallest) < 0) {\n+            final RealPointValuePair xE = evaluateNewSimplex(simplex, gamma, comparator);\n+            if (comparator.compare(xR, xE) < 0) {\n+                // replace the worst point with the reflected point\n+                simplex[numVertices - 1] = xR;\n+            } else {\n+                // replace the worst point with the expanded point\n+                simplex[numVertices - 1] = xE;\n             }\n-\n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n-\n-            // check convergence\n-                return;\n+        } else {\n+            final RealPointValuePair secondWorst = simplex[numVertices - 2];\n+            if (comparator.compare(xR, secondWorst) < 0) {\n+                // replace the worst point with the reflected point\n+                simplex[numVertices - 1] = xR;\n+            } else {\n+                // Perform the contraction\n+                RealPointValuePair xC;\n+                if (comparator.compare(xR, xLargest) < 0) {\n+                    xC = evaluateNewSimplex(simplex, rho, comparator);\n+                    if (comparator.compare(xC, xLargest) >= 0) {\n+                        shrink(comparator);\n+                    } else {\n+                        simplex[numVertices - 1] = xC;\n+                    }\n+                } else {\n+                    xC = evaluateNewSimplex(simplex, rho, comparator);\n+                    if (comparator.compare(xC, xR) < 0) {\n+                        simplex[numVertices - 1] = xC;\n+                    } else {\n+                        shrink(comparator);\n+                    }\n+                }\n             }\n-\n         }\n+    }\n+    throw new OptimizationException(\"Maximal number of iterations exceeded: \" + maxIterations);\n+}\n \n+private void shrink(final Comparator<RealPointValuePair> comparator) {\n+    final RealPointValuePair[] current = simplex;\n+    final RealPointValuePair best = current[0];\n+    for (int i = 1; i < current.length; i++) {\n+        final double[] x = current[i].getPoint();\n+        for (int j = 0; j < x.length; j++) {\n+            x[j] = best.getPoint()[j] + sigma * (x[j] - best.getPoint()[j]);\n+        }\n+        current[i] = new RealPointValuePair(x, Double.NaN);\n     }\n+    evaluateSimplex(comparator);\n+}\n \n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)",
    "result_reason": "error: method compare in interface Comparator<T> cannot be applied to given types;",
    "test_result": "ERROR"
}