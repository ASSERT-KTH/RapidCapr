{
    "patch": "import org.mockito.cglib.proxy.Factory;\nimport org.mockito.internal.creation.MockSettingsImpl;\nimport org.mockito.internal.handler.MockHandler;\nimport org.mockito.internal.handler.MockHandlerInterface;\nimport org.mockito.invocation.MethodInterceptor;\nimport org.mockito.invocation.MethodInvocation;\nimport org.mockito.junit.MockitoJUnitRunner;\nimport org.mockito.listeners.InvocationListener;\nimport org.mockito.listeners.MethodInvocationReport;\n\nimport java.lang.reflect.Method;\n\npublic class MyMockitoRunner extends MockitoJUnitRunner {\n    private InvocationListener invocationListener;\n\n    public MyMockitoRunner(Class<?> clazz) throws InitializationError {\n        super(clazz);\n        invocationListener = new InvocationListener() {\n            @Override\n            public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n                // do nothing\n            }\n        };\n    }\n\n    public <T> void resetMock(T mock) {\n        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n        for (int i = 0; i < ((Factory) mock).getCallbackCount(); i++) {\n            if (((Factory) mock).getCallback(i) instanceof InvocationHandlerAdapter) {\n                ((Factory) mock).setCallback(i, null);\n            }\n        }\n        ((Factory) mock).setCallbackType(MethodInterceptor.class);\n        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings()\n                .defaultAnswer(RETURNS_DEFAULTS));\n        ((Factory) mock).setCallback(0, newFilter);\n    }\n\n    private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n        // This gets the MockHandler and is deprecated, but could not find a suitable replacement in Mockito 3.x\n        return (MockHandlerInterface<T>) ((Factory) mock).getCallbacks()[0];\n    }\n\n    static class MethodInterceptorFilter implements MethodInterceptor {\n        private final MockHandler<Object> delegate;\n        private final MockHandler<T> newHandler;\n\n        public MethodInterceptorFilter(MockHandler<T> newHandler, MockSettingsImpl mockSettingsImpl) {\n            this.delegate = new MockHandler<Object>(mockSettingsImpl);\n            this.newHandler = newHandler;\n        }\n\n        @Override\n        public Object intercept(Object o, Method method, Object[] args, org.mockito.invocation.Invocation invocation) throws Throwable {\n            // Handle the invocation if it's a mock invocation, otherwise delegate to the next interceptor\n            if (invocation.getMockitoMethod().getMethod().getDeclaringClass().isAssignableFrom(Mockito.class)) {\n                return delegate.handle(invocation);\n            } else {\n                return newHandler.handle(invocation);\n          }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..2de920b46 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,71 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.cglib.proxy.Factory;\n+import org.mockito.internal.creation.MockSettingsImpl;\n+import org.mockito.internal.handler.MockHandler;\n+import org.mockito.internal.handler.MockHandlerInterface;\n+import org.mockito.invocation.MethodInterceptor;\n+import org.mockito.invocation.MethodInvocation;\n+import org.mockito.junit.MockitoJUnitRunner;\n+import org.mockito.listeners.InvocationListener;\n+import org.mockito.listeners.MethodInvocationReport;\n+\n+import java.lang.reflect.Method;\n+\n+public class MyMockitoRunner extends MockitoJUnitRunner {\n+    private InvocationListener invocationListener;\n+\n+    public MyMockitoRunner(Class<?> clazz) throws InitializationError {\n+        super(clazz);\n+        invocationListener = new InvocationListener() {\n+            @Override\n+            public void reportInvocation(MethodInvocationReport methodInvocationReport) {\n+                // do nothing\n+            }\n+        };\n+    }\n+\n+    public <T> void resetMock(T mock) {\n+        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n+        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n+        for (int i = 0; i < ((Factory) mock).getCallbackCount(); i++) {\n+            if (((Factory) mock).getCallback(i) instanceof InvocationHandlerAdapter) {\n+                ((Factory) mock).setCallback(i, null);\n+            }\n+        }\n+        ((Factory) mock).setCallbackType(MethodInterceptor.class);\n+        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings()\n+                .defaultAnswer(RETURNS_DEFAULTS));\n+        ((Factory) mock).setCallback(0, newFilter);\n+    }\n+\n+    private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n+        // This gets the MockHandler and is deprecated, but could not find a suitable replacement in Mockito 3.x\n+        return (MockHandlerInterface<T>) ((Factory) mock).getCallbacks()[0];\n+    }\n+\n+    static class MethodInterceptorFilter implements MethodInterceptor {\n+        private final MockHandler<Object> delegate;\n+        private final MockHandler<T> newHandler;\n+\n+        public MethodInterceptorFilter(MockHandler<T> newHandler, MockSettingsImpl mockSettingsImpl) {\n+            this.delegate = new MockHandler<Object>(mockSettingsImpl);\n+            this.newHandler = newHandler;\n+        }\n+\n+        @Override\n+        public Object intercept(Object o, Method method, Object[] args, org.mockito.invocation.Invocation invocation) throws Throwable {\n+            // Handle the invocation if it's a mock invocation, otherwise delegate to the next interceptor\n+            if (invocation.getMockitoMethod().getMethod().getDeclaringClass().isAssignableFrom(Mockito.class)) {\n+                return delegate.handle(invocation);\n+            } else {\n+                return newHandler.handle(invocation);\n+          }\n+        }\n+    }\n+}\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}