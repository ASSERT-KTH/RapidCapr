{
    "patch": "private void inlineAliases(GlobalNamespace namespace) {\n  // Invariant: All the names in the worklist meet condition (a).\n  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n  while (!workList.isEmpty()) {\n      Name name = workList.pop();\n      if (shouldInlineAlias(name)) {\n          // name meets conditions (b) and (c).\n          inlineAlias(namespace, name);\n      } else if (name.props != null) {\n          // All of name's children meet condition (a), so they can be\n          // added to the worklist.\n          workList.addAll(name.props);\n      }\n  }\n}\n\nprivate boolean shouldInlineAlias(Name name) {\n  // Condition (a) is that the name has no children.\n  if (name.props != null) {\n      return false;\n  }\n  // Condition (b) is that the name has exactly one global definition, no\n  // local definitions or aliasing gets.\n  if (name.globalSets != 1 || name.localSets != 0 || name.aliasingGets != 0) {\n      return false;\n  }\n  // Condition (c) is that the name is a simple stub.\n  return name.isSimpleStub();\n}\n\nprivate static void inlineAlias(GlobalNamespace globalNamespace, Name name) {\n  Ref decl = name.getDeclaration();\n  checkNotNull(decl);\n  // The following strengthens precondition assumptions up to this point.\n  if (decl.type != Ref.Type.SET_FROM_GLOBAL) {\n      return;\n  }\n  checkState(name.getRefs().size() == 1);\n\n  String propSuffix = name.getBaseName();\n  if (name.type == Name.Type.GETPROP) {\n      propSuffix = \".\" + propSuffix;\n  } else {\n      checkState(name.type == Name.Type.NAME);\n  }\n\n  // Parent is the object that obj.x appears on.\n  Node parent = decl.node.getParent();\n\n  // We'll replace '.' with '_' in the inlined code.\n  String propSuffixUnderbar = propSuffix.replace('.', '_');\n\n  // Replace all references to obj.x with temp.\n  Var temp = globalNamespace.getVar(propSuffixUnderbar);\n  if (temp == null) {\n      Node getpropNode = null;\n      if (name.type == Name.Type.NAME) {\n          // Replace:\n          //   var x = obj.y;\n          // with:\n          //   var y = obj.y;\n          getpropNode = IR.name(name.getBaseName());\n          parent.replaceChild(decl.node, getpropNode);\n      } else {\n          // Replace:\n          //   var x = obj.y;\n          // with:\n          //   var tmp = obj;\n          // Replace:\n          //   tmp.y;\n          // with:\n          //   tmp.y;\n          // We Mark TMP_VAR to be optimized later.\n          getpropNode = IR.name(\"tmp\").useSourceInfoFrom(decl.node);\n\n          Node objName = name.getFirstChild();\n          Node tmpVar = IR.var(getpropNode.cloneTree()).useSourceInfoFrom(decl.node);\n          parent.replaceChild(decl.node, tmpVar);\n          Node replacement = IR.getprop(getpropNode.cloneTree(), name.getLastChild()).useSourceInfoFrom(name);\n          replacement.putBooleanProp(Node.TMP_VAR, true);\n          parent.replaceChild(name, replacement);\n      }\n\n      temp = globalNamespace.addDeclaredVar(propSuffixUnderbar, getpropNode, null);\n  }\n  // Fix references to obj.x.\n  List<Ref> refs = ImmutableList.copyOf(name.getRefs());\n  for (Ref ref : refs) {\n      Node refNode = ref.node;\n\n      // Prevent the value from being written.\n      if (ref.type == Ref.Type.SET_FROM_GLOBAL) {\n          refNode.getParent().removeChild(refNode);\n          continue;\n      }\n\n      Node tempNode = IR.name(varName(temp)).useSourceInfoFrom(refNode);\n\n      // Replace obj.x with tmp.\n      parent.replaceChild(refNode, tempNode);\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/CollapseProperties.java b/src/com/google/javascript/jscomp/CollapseProperties.java\nindex ab2d2c7c..dab50e26 100644\n--- a/src/com/google/javascript/jscomp/CollapseProperties.java\n+++ b/src/com/google/javascript/jscomp/CollapseProperties.java\n@@ -169,7 +169,108 @@ class CollapseProperties implements CompilerPass {\n         continue;\n       }\n \n-      if (name.globalSets == 1 && name.localSets == 0 &&\n+private void inlineAliases(GlobalNamespace namespace) {\n+  // Invariant: All the names in the worklist meet condition (a).\n+  Deque<Name> workList = new ArrayDeque<Name>(namespace.getNameForest());\n+  while (!workList.isEmpty()) {\n+      Name name = workList.pop();\n+      if (shouldInlineAlias(name)) {\n+          // name meets conditions (b) and (c).\n+          inlineAlias(namespace, name);\n+      } else if (name.props != null) {\n+          // All of name's children meet condition (a), so they can be\n+          // added to the worklist.\n+          workList.addAll(name.props);\n+      }\n+  }\n+}\n+\n+private boolean shouldInlineAlias(Name name) {\n+  // Condition (a) is that the name has no children.\n+  if (name.props != null) {\n+      return false;\n+  }\n+  // Condition (b) is that the name has exactly one global definition, no\n+  // local definitions or aliasing gets.\n+  if (name.globalSets != 1 || name.localSets != 0 || name.aliasingGets != 0) {\n+      return false;\n+  }\n+  // Condition (c) is that the name is a simple stub.\n+  return name.isSimpleStub();\n+}\n+\n+private static void inlineAlias(GlobalNamespace globalNamespace, Name name) {\n+  Ref decl = name.getDeclaration();\n+  checkNotNull(decl);\n+  // The following strengthens precondition assumptions up to this point.\n+  if (decl.type != Ref.Type.SET_FROM_GLOBAL) {\n+      return;\n+  }\n+  checkState(name.getRefs().size() == 1);\n+\n+  String propSuffix = name.getBaseName();\n+  if (name.type == Name.Type.GETPROP) {\n+      propSuffix = \".\" + propSuffix;\n+  } else {\n+      checkState(name.type == Name.Type.NAME);\n+  }\n+\n+  // Parent is the object that obj.x appears on.\n+  Node parent = decl.node.getParent();\n+\n+  // We'll replace '.' with '_' in the inlined code.\n+  String propSuffixUnderbar = propSuffix.replace('.', '_');\n+\n+  // Replace all references to obj.x with temp.\n+  Var temp = globalNamespace.getVar(propSuffixUnderbar);\n+  if (temp == null) {\n+      Node getpropNode = null;\n+      if (name.type == Name.Type.NAME) {\n+          // Replace:\n+          //   var x = obj.y;\n+          // with:\n+          //   var y = obj.y;\n+          getpropNode = IR.name(name.getBaseName());\n+          parent.replaceChild(decl.node, getpropNode);\n+      } else {\n+          // Replace:\n+          //   var x = obj.y;\n+          // with:\n+          //   var tmp = obj;\n+          // Replace:\n+          //   tmp.y;\n+          // with:\n+          //   tmp.y;\n+          // We Mark TMP_VAR to be optimized later.\n+          getpropNode = IR.name(\"tmp\").useSourceInfoFrom(decl.node);\n+\n+          Node objName = name.getFirstChild();\n+          Node tmpVar = IR.var(getpropNode.cloneTree()).useSourceInfoFrom(decl.node);\n+          parent.replaceChild(decl.node, tmpVar);\n+          Node replacement = IR.getprop(getpropNode.cloneTree(), name.getLastChild()).useSourceInfoFrom(name);\n+          replacement.putBooleanProp(Node.TMP_VAR, true);\n+          parent.replaceChild(name, replacement);\n+      }\n+\n+      temp = globalNamespace.addDeclaredVar(propSuffixUnderbar, getpropNode, null);\n+  }\n+  // Fix references to obj.x.\n+  List<Ref> refs = ImmutableList.copyOf(name.getRefs());\n+  for (Ref ref : refs) {\n+      Node refNode = ref.node;\n+\n+      // Prevent the value from being written.\n+      if (ref.type == Ref.Type.SET_FROM_GLOBAL) {\n+          refNode.getParent().removeChild(refNode);\n+          continue;\n+      }\n+\n+      Node tempNode = IR.name(varName(temp)).useSourceInfoFrom(refNode);\n+\n+      // Replace obj.x with tmp.\n+      parent.replaceChild(refNode, tempNode);\n+  }\n+}\n           name.aliasingGets > 0) {\n         // {@code name} meets condition (b). Find all of its local aliases\n         // and try to inline them.",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}