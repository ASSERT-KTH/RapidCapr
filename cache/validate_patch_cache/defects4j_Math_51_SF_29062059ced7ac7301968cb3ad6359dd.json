{
    "patch": "        double a = getMin();\n        double b = getMax();\n        double fa = computeObjectiveValue(a);\n        double fb = computeObjectiveValue(b);\n\n        // If one of the bounds is the exact root, return it. Since these are\n        // not under-approximations or over-approximations, we can return them\n        // regardless of the allowed solutions.\n        if (fa == 0.0) {\n            return a;\n        }\n        if (fb == 0.0) {\n            return b;\n        }\n\n        // Verify bracketing.\n        verifyBracketing(a, b);\n\n        // Set up initial parameters for Brent's method.\n        double c = a;\n        double fc = fa;\n        double d = b - c;\n        double e = d;\n\n        double tol = getRelativeAccuracy();\n        double m = getAbsoluteAccuracy();\n\n        // Keep finding better approximations.\n        while (true) {\n            // Save previous values of a,b,c,fc to check for convergence.\n            double prev_a = a;\n            double prev_b = b;\n            double prev_c = c;\n            double prev_fc = fc;\n\n            // If f(a) and f(b) have the same sign, perform bisection.\n            if (fa * fb > 0) {\n                c = a;\n                fc = fa;\n                d = b - c;\n                e = d;\n            } else if (FastMath.abs(fc) < FastMath.abs(fb)) {\n                // Swap a and b to reverse direction of guess.\n                a = b;\n                b = c;\n                c = a;\n                fa = fb;\n                fb = fc;\n                fc = fa;\n            }\n\n            // Convergence check.\n            double tol1 = 2 * m * FastMath.abs(b) + 0.5 * tol;\n            double xm = 0.5 * (c - b);\n\n            if (FastMath.abs(xm) <= tol1\n                    || FastMath.abs(fc) <= getFunctionValueAccuracy()) {\n                return c;\n            }\n\n            // Use a combination of bisection and Brent's method to update the guess.\n            if (FastMath.abs(e) >= tol1 && FastMath.abs(fa) > FastMath.abs(fb)) {\n                double s = fb / fa;\n                double p, q, r;\n\n                if (FastMath.abs(prev_c - c) > 0) {\n                    // Use quadratic interpolation to get the guess of the new point.\n                    double[] coeffs = quadInterpolation(a, b, c, fa, fb, fc);\n                    p = coeffs[0];\n                    q = coeffs[1];\n                    r = coeffs[2];\n\n                    // The guess point must be within the current bracket.\n                    if (a <= p && p <= c && p <= b || b <= p && p <= c && p <= a) {\n                        e = d;\n                        d = c - p;\n                    } else {\n                        d = e = xm; // Fall back to bisection.\n                    }\n                } else {\n                    // If our previous step was a pure bisection step, we can only use the golden section.\n                    d = e = xm;\n                }\n\n                if (FastMath.abs(p) < FastMath.abs(0.5 * s * e)\n                        && p < s * (a - c)\n                        && p < s * (b - c)) {\n                    // Use the interpolation point.\n                    a = b;\n                    b = c;\n                    c = p;\n                    fa = fb;\n                    fb = fc;\n                    fc = computeObjectiveValue(c);\n                } else {\n                    // Use the golden section.\n                    a = b;\n                    b = (fc * fb > 0) ? a + getGolden() * (c - a) : c - getGolden() * (c - a);\n                    fa = fb;\n                    fb = computeObjectiveValue(b);\n                }\n            } else {\n                // Use the golden section.\n                a = b;\n                b = (fc * fb > 0) ? a + getGolden() * (c - a) : c - getGolden() * (c - a);\n                fa = fb;\n                fb = computeObjectiveValue(b);\n                e = d;\n                d = c - b;\n            }\n\n            // If we've stuck around for too long, throw an exception.\n            if (FastMath.abs(fc) < FastMath.abs(prev_fc)) {\n                double tmp_a = prev_a;\n                prev_a = prev_c;\n                prev_c = tmp_a;\n                double tmp_fa = fa;\n                fa = prev_fc;\n                prev_fc = tmp_fa;\n                double tmp_b = prev_b;\n                prev_b = prev_c;\n                prev_c = tmp_b;\n                double tmp_fb = fb;\n                fb = prev_fc;\n                prev_fc = tmp_fb;\n            }\n            double tol2 = FastMath.min(tol, 0.5 * FastMath.abs(c - b) / FastMath.max(FastMath.abs(c), 1));\n            if (FastMath.abs(fc - prev_fc) <= tol2 * FastMath.abs(prev_fc)) {\n                if (a < c && c < b) {\n                    if (fc > prev_fc) {\n                        a = prev_c;\n                        b = c;\n                    } else {\n                        a = c;\n                        b = prev_c;\n                    }\n                } else {\n                    if (fc > prev_fc) {\n                        b = prev_c;\n                    } else {\n                        a = prev_c;\n                    }\n                }\n            }\n        }\n    }\n\n    /**\n     * Calculates the coefficients for the quadratic interpolation formula given three distinct\n     * points.\n     *\n     * @param x1 the x-value of the first data point\n     * @param x2 the x-value of the second data point\n     * @param x3 the x-value of the third data point\n     * @param y1 the y-value of the first data point\n     * @param y2 the y-value of the second data point\n     * @param y3 the y-value of the third data point\n     * @return an array containing the coefficients (in ascending order) of the quadratic\n     *     polynomial for the interpolation formula.\n     */\n    private double[] quadInterpolation(double x1, double x2, double x3,\n                                        double y1, double y2, double y3) {\n        double denom = (x1 - x2) * (x1 - x3) * (x2 - x3);\n        double a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom;\n        double b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / denom;\n        double c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2\n                + x1 * x2 * (x1 - x2) * y3) / denom;\n        return new double[] {a, b, c};",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\nindex e258c68c6..9a082484c 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BaseSecantSolver.java\n@@ -125,127 +125,175 @@ public abstract class BaseSecantSolver\n     }\n \n     /** {@inheritDoc} */\n-    protected final double doSolve() {\n-        // Get initial solution\n-        double x0 = getMin();\n-        double x1 = getMax();\n-        double f0 = computeObjectiveValue(x0);\n-        double f1 = computeObjectiveValue(x1);\n+        double a = getMin();\n+        double b = getMax();\n+        double fa = computeObjectiveValue(a);\n+        double fb = computeObjectiveValue(b);\n \n         // If one of the bounds is the exact root, return it. Since these are\n         // not under-approximations or over-approximations, we can return them\n         // regardless of the allowed solutions.\n-        if (f0 == 0.0) {\n-            return x0;\n+        if (fa == 0.0) {\n+            return a;\n         }\n-        if (f1 == 0.0) {\n-            return x1;\n+        if (fb == 0.0) {\n+            return b;\n         }\n \n-        // Verify bracketing of initial solution.\n-        verifyBracketing(x0, x1);\n+        // Verify bracketing.\n+        verifyBracketing(a, b);\n \n-        // Get accuracies.\n-        final double ftol = getFunctionValueAccuracy();\n-        final double atol = getAbsoluteAccuracy();\n-        final double rtol = getRelativeAccuracy();\n+        // Set up initial parameters for Brent's method.\n+        double c = a;\n+        double fc = fa;\n+        double d = b - c;\n+        double e = d;\n \n-        // Keep track of inverted intervals, meaning that the left bound is\n-        // larger than the right bound.\n-        boolean inverted = false;\n+        double tol = getRelativeAccuracy();\n+        double m = getAbsoluteAccuracy();\n \n         // Keep finding better approximations.\n         while (true) {\n-            // Calculate the next approximation.\n-            final double x = x1 - ((f1 * (x1 - x0)) / (f1 - f0));\n-            final double fx = computeObjectiveValue(x);\n-\n-            // If the new approximation is the exact root, return it. Since\n-            // this is not an under-approximation or an over-approximation,\n-            // we can return it regardless of the allowed solutions.\n-            if (fx == 0.0) {\n-                return x;\n+            // Save previous values of a,b,c,fc to check for convergence.\n+            double prev_a = a;\n+            double prev_b = b;\n+            double prev_c = c;\n+            double prev_fc = fc;\n+\n+            // If f(a) and f(b) have the same sign, perform bisection.\n+            if (fa * fb > 0) {\n+                c = a;\n+                fc = fa;\n+                d = b - c;\n+                e = d;\n+            } else if (FastMath.abs(fc) < FastMath.abs(fb)) {\n+                // Swap a and b to reverse direction of guess.\n+                a = b;\n+                b = c;\n+                c = a;\n+                fa = fb;\n+                fb = fc;\n+                fc = fa;\n             }\n \n-            // Update the bounds with the new approximation.\n-            if (f1 * fx < 0) {\n-                // The value of x1 has switched to the other bound, thus inverting\n-                // the interval.\n-                x0 = x1;\n-                f0 = f1;\n-                inverted = !inverted;\n-            } else {\n-                switch (method) {\n-                case ILLINOIS:\n-                    f0 *= 0.5;\n-                    break;\n-                case PEGASUS:\n-                    f0 *= f1 / (f1 + fx);\n-                    break;\n-                        // Update formula cannot make any progress: Update the\n-                        // search interval.\n-                default:\n-                    // Should never happen.\n-                }\n+            // Convergence check.\n+            double tol1 = 2 * m * FastMath.abs(b) + 0.5 * tol;\n+            double xm = 0.5 * (c - b);\n+\n+            if (FastMath.abs(xm) <= tol1\n+                    || FastMath.abs(fc) <= getFunctionValueAccuracy()) {\n+                return c;\n             }\n-            // Update from [x0, x1] to [x0, x].\n-            x1 = x;\n-            f1 = fx;\n-\n-            // If the function value of the last approximation is too small,\n-            // given the function value accuracy, then we can't get closer to\n-            // the root than we already are.\n-            if (FastMath.abs(f1) <= ftol) {\n-                switch (allowed) {\n-                case ANY_SIDE:\n-                    return x1;\n-                case LEFT_SIDE:\n-                    if (inverted) {\n-                        return x1;\n-                    }\n-                    break;\n-                case RIGHT_SIDE:\n-                    if (!inverted) {\n-                        return x1;\n-                    }\n-                    break;\n-                case BELOW_SIDE:\n-                    if (f1 <= 0) {\n-                        return x1;\n-                    }\n-                    break;\n-                case ABOVE_SIDE:\n-                    if (f1 >= 0) {\n-                        return x1;\n+\n+            // Use a combination of bisection and Brent's method to update the guess.\n+            if (FastMath.abs(e) >= tol1 && FastMath.abs(fa) > FastMath.abs(fb)) {\n+                double s = fb / fa;\n+                double p, q, r;\n+\n+                if (FastMath.abs(prev_c - c) > 0) {\n+                    // Use quadratic interpolation to get the guess of the new point.\n+                    double[] coeffs = quadInterpolation(a, b, c, fa, fb, fc);\n+                    p = coeffs[0];\n+                    q = coeffs[1];\n+                    r = coeffs[2];\n+\n+                    // The guess point must be within the current bracket.\n+                    if (a <= p && p <= c && p <= b || b <= p && p <= c && p <= a) {\n+                        e = d;\n+                        d = c - p;\n+                    } else {\n+                        d = e = xm; // Fall back to bisection.\n                     }\n-                    break;\n-                default:\n-                    throw new MathInternalError();\n+                } else {\n+                    // If our previous step was a pure bisection step, we can only use the golden section.\n+                    d = e = xm;\n                 }\n+\n+                if (FastMath.abs(p) < FastMath.abs(0.5 * s * e)\n+                        && p < s * (a - c)\n+                        && p < s * (b - c)) {\n+                    // Use the interpolation point.\n+                    a = b;\n+                    b = c;\n+                    c = p;\n+                    fa = fb;\n+                    fb = fc;\n+                    fc = computeObjectiveValue(c);\n+                } else {\n+                    // Use the golden section.\n+                    a = b;\n+                    b = (fc * fb > 0) ? a + getGolden() * (c - a) : c - getGolden() * (c - a);\n+                    fa = fb;\n+                    fb = computeObjectiveValue(b);\n+                }\n+            } else {\n+                // Use the golden section.\n+                a = b;\n+                b = (fc * fb > 0) ? a + getGolden() * (c - a) : c - getGolden() * (c - a);\n+                fa = fb;\n+                fb = computeObjectiveValue(b);\n+                e = d;\n+                d = c - b;\n             }\n \n-            // If the current interval is within the given accuracies, we\n-            // are satisfied with the current approximation.\n-            if (FastMath.abs(x1 - x0) < FastMath.max(rtol * FastMath.abs(x1),\n-                                                     atol)) {\n-                switch (allowed) {\n-                case ANY_SIDE:\n-                    return x1;\n-                case LEFT_SIDE:\n-                    return inverted ? x1 : x0;\n-                case RIGHT_SIDE:\n-                    return inverted ? x0 : x1;\n-                case BELOW_SIDE:\n-                    return (f1 <= 0) ? x1 : x0;\n-                case ABOVE_SIDE:\n-                    return (f1 >= 0) ? x1 : x0;\n-                default:\n-                    throw new MathInternalError();\n+            // If we've stuck around for too long, throw an exception.\n+            if (FastMath.abs(fc) < FastMath.abs(prev_fc)) {\n+                double tmp_a = prev_a;\n+                prev_a = prev_c;\n+                prev_c = tmp_a;\n+                double tmp_fa = fa;\n+                fa = prev_fc;\n+                prev_fc = tmp_fa;\n+                double tmp_b = prev_b;\n+                prev_b = prev_c;\n+                prev_c = tmp_b;\n+                double tmp_fb = fb;\n+                fb = prev_fc;\n+                prev_fc = tmp_fb;\n+            }\n+            double tol2 = FastMath.min(tol, 0.5 * FastMath.abs(c - b) / FastMath.max(FastMath.abs(c), 1));\n+            if (FastMath.abs(fc - prev_fc) <= tol2 * FastMath.abs(prev_fc)) {\n+                if (a < c && c < b) {\n+                    if (fc > prev_fc) {\n+                        a = prev_c;\n+                        b = c;\n+                    } else {\n+                        a = c;\n+                        b = prev_c;\n+                    }\n+                } else {\n+                    if (fc > prev_fc) {\n+                        b = prev_c;\n+                    } else {\n+                        a = prev_c;\n+                    }\n                 }\n             }\n         }\n     }\n \n+    /**\n+     * Calculates the coefficients for the quadratic interpolation formula given three distinct\n+     * points.\n+     *\n+     * @param x1 the x-value of the first data point\n+     * @param x2 the x-value of the second data point\n+     * @param x3 the x-value of the third data point\n+     * @param y1 the y-value of the first data point\n+     * @param y2 the y-value of the second data point\n+     * @param y3 the y-value of the third data point\n+     * @return an array containing the coefficients (in ascending order) of the quadratic\n+     *     polynomial for the interpolation formula.\n+     */\n+    private double[] quadInterpolation(double x1, double x2, double x3,\n+                                        double y1, double y2, double y3) {\n+        double denom = (x1 - x2) * (x1 - x3) * (x2 - x3);\n+        double a = (x3 * (y2 - y1) + x2 * (y1 - y3) + x1 * (y3 - y2)) / denom;\n+        double b = (x3 * x3 * (y1 - y2) + x2 * x2 * (y3 - y1) + x1 * x1 * (y2 - y3)) / denom;\n+        double c = (x2 * x3 * (x2 - x3) * y1 + x3 * x1 * (x3 - x1) * y2\n+                + x1 * x2 * (x1 - x2) * y3) / denom;\n+        return new double[] {a, b, c};\n+\n     /** <em>Secant</em>-based root-finding methods. */\n     protected enum Method {\n ",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}