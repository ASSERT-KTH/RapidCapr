{
    "patch": "import org.apache.commons.math3.analysis.MultivariateFunction;\nimport org.apache.commons.math3.analysis.SimpleBounds;\nimport org.apache.commons.math3.optim.InitialGuess;\nimport org.apache.commons.math3.optim.MaxEval;\nimport org.apache.commons.math3.optim.PointValuePair;\nimport org.apache.commons.math3.optim.SimpleBounds;\nimport org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\nimport org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.LifecycleListener;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.RetryBehavior;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.TerminationException;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerUtils;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexSolver;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexTableau;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SingleObjectiveFunction;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.PointValuePairComparator;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.Simplex;\nimport org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexTableau;\nimport org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\nimport org.apache.commons.math3.optim.univariate.UnivariateOptimizer;\nimport org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\nimport org.apache.commons.math3.optim.univariate.search.BracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.ExpandableBracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.GoldenSectionBracketFinder;\nimport org.apache.commons.math3.optim.univariate.search.SearchInterval;\nimport org.apache.commons.math3.optim.univariate.search.UnivariateSearch;\nimport org.apache.commons.math3.optim.univariate.search.UnivariateSearch.Direction;\nimport org.apache.commons.math3.util.FastMath;\n\nimport java.util.Arrays;\nimport java.util.Comparator;\n\npublic class NelderMead implements MultivariateOptimizer {\n\n    private static final int DEFAULT_MAX_ITERATIONS = 200;\n    private static final double DEFAULT_ABSOLUTE_TOLERANCE = 1e-6;\n    private static final double DEFAULT_RELATIVE_TOLERANCE = 1e-6;\n    private static final double DEFAULT_SIMPLE_MAX = 1.0;\n    private static final double DEFAULT_SIMPLE_MIN = 0.5;\n\n    private final double rho;\n    private final double khi;\n    private final double gamma;\n    private final double sigma;\n    private final LifecycleListener lifecycleListener;\n\n    private int iterations;\n    private int maxIterations;\n    private double absoluteThreshold;\n    private double relativeThreshold;\n\n    public NelderMead() {\n        this(1.0, 2.0, 0.5, 0.5, DEFAULT_MAX_ITERATIONS, DEFAULT_ABSOLUTE_TOLERANCE, DEFAULT_RELATIVE_TOLERANCE);\n    }\n\n    public NelderMead(final double rho, final double khi, final double gamma, final double sigma,\n                      final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n        this.rho = rho;\n        this.khi = khi;\n        this.gamma = gamma;\n        this.sigma = sigma;\n        this.lifecycleListener = null;\n        setMaxIterations(maxIterations);\n        setAbsoluteThreshold(absoluteThreshold);\n        setRelativeThreshold(relativeThreshold);\n    }\n\n    /**\n     * Gets the reflection coefficient.\n     *\n     * @return the reflection coefficient.\n     */\n    public double getRho() {\n        return rho;\n    }\n\n    /**\n     * Gets the expansion coefficient.\n     *\n     * @return the expansion coefficient.\n     */\n    public double getKhi() {\n        return khi;\n    }\n\n    /**\n     * Gets the contraction coefficient.\n     *\n     * @return the contraction coefficient.\n     */\n    public double getGamma() {\n        return gamma;\n    }\n\n    /**\n     * Gets the shrink coefficient.\n     *\n     * @return the shrink coefficient.\n     */\n    public double getSigma() {\n        return sigma;\n    }\n\n    /**\n     * Gets the maximum number of iterations allowed.\n     *\n     * @return the maximum number of iterations allowed.\n     */\n    public int getMaxIterations() {\n        return maxIterations;\n    }\n\n    /**\n     * Sets the maximum number of iterations allowed.\n     *\n     * @param maxIterations the maximum number of iterations allowed.\n     */\n    public void setMaxIterations(final int maxIterations) {\n        this.maxIterations = maxIterations;\n    }\n\n    /**\n     * Gets the absolute threshold for relative difference.\n     *\n     * @return the absolute threshold for relative difference.\n     */\n    public double getAbsoluteThreshold() {\n        return absoluteThreshold;\n    }\n\n    /**\n     * Sets the absolute threshold for relative difference.\n     *\n     * @param absoluteThreshold the absolute threshold for relative difference.\n     */\n    public void setAbsoluteThreshold(final double absoluteThreshold) {\n        this.absoluteThreshold = absoluteThreshold;\n    }\n\n    /**\n     * Gets the relative threshold for difference.\n     *\n     * @return the relative threshold for difference.\n     */\n    public double getRelativeThreshold() {\n        return relativeThreshold;\n    }\n\n    /**\n     * Sets the relative threshold for difference.\n     *\n     * @param relativeThreshold the relative threshold for difference.\n     */\n    public void setRelativeThreshold(final double relativeThreshold) {\n        this.relativeThreshold = relativeThreshold;\n    }\n\n    /**\n     * Gets the lifecycle listener of the algorithm.\n     *\n     * @return the lifecycle listener of the algorithm.\n     */\n    public LifecycleListener getLifecycleListener() {\n        return lifecycleListener;\n    }\n\n    /**\n     * Set the Simple Bounds on the optimization variables.\n     *\n     * @param bounds array of SimpleBounds objects representing valid range of each variable\n     * @throws IllegalArgumentException if {@code bounds} is null or is of size zero or its elements\n     * are null or upper bound is less or equal to respective lower bound\n     * @since 3.1\n     */\n    @Override\n    public void setSimpleBounds(SimpleBounds bounds) {\n        throw new UnsupportedOperationException(\"NelderMead with bounds is not implemented\");\n    }\n\n    /**\n     * Find an optimum of an objective function.\n     *\n     * @param maxEval Maximum number of function evaluations.\n     * @param f      Objective function.\n     * @param goal   Optimization goal: either {@link GoalType#MINIMIZE}\n     *               or {@link GoalType#MAXIMIZE}.\n     * @param startPoint Start point.\n     * @return the point/value pair giving the optimal value of the objective function.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.\n     */\n    public PointValuePair optimize(final MaxEval maxEval, final MultivariateFunction f, final GoalType goal,\n                                    final double[] startPoint) {\n        return optimizeInternal(maxEval.getMaxeval(), new ObjectiveFunction(f), goal, new InitialGuess(startPoint));\n    }\n\n    /**\n     * Find an optimum of an objective function.\n     *\n     * @param maxEval Maximum number of function evaluations.\n     * @param f      Objective function.\n     * @param goal   Optimization goal: either {@link GoalType#MINIMIZE}\n     *               or {@link GoalType#MAXIMIZE}.\n     * @param startPoint Start point.\n     * @param lower Lower bounds.\n     * @param upper Upper bounds.\n     * @return the point/value pair giving the optimal value of the objective function.\n     * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.\n     * @throws IllegalArgumentException if the array lengths differ, or initial guess\n     * is not within the specified bounds\n     * @since 3.1\n     */\n    @Override\n    public PointValuePair optimize(final MaxEval maxEval, final MultivariateFunction f, final GoalType goal,\n                              final double[] startPoint, final double[] lower, final double[] upper) {\n        throw new UnsupportedOperationException(\"NelderMead with bounds is not implemented\");\n    }\n\n    /**\n     * Get the search interval for univariate search at the vertex.\n     *\n     * @param vertex the vertex.\n     * @param simplex the simplex.\n     * @return the search interval.\n     */\n    private SearchInterval[] getSearchInterval(final double[] vertex, final Simplex simplex) {\n        final int n = simplex.getDimension();\n        final SearchInterval[] interval = new SearchInterval[n];\n        for (int i = 0; i < n; i++) {\n            final double[] x = simplex.getPoint(i);\n            final double[] displacement = new double[n];\n            for (int j = 0; j < n; j++) {\n                displacement[j] = x[j] - vertex[j];\n            }\n            final double coef = computeCoefficients(displacement);\n            interval[i] = new SearchInterval(x[i], coef);\n        }\n        return interval;\n    }\n\n    /**\n     * Compute the coefficients of the univariate quadratic model.\n     *\n     * @param x the displacement between the point and the vertices.\n     * @return the coefficients of the univariate quadratic model.\n     */\n    private double computeCoefficients(final double[] x) {\n        double a = 0;\n        double b = 0;\n        double c = 0;\n        final int n = x.length;\n        for (int i = 0; i < n; i++) {\n            final double xi = x[i];\n            a += xi * xi;\n            b += xi;\n            c += 1.0;\n        }\n        a /= n;\n        b /= n;\n        return (sigma * a - b * b) / FastMath.sqrt(c);\n    }\n\n    /**\n     * Compare the function values at the simplex vertices.\n     * If recent past iterations\n     * show that the result of function evaluations are becoming similar,\n     * use the ordering of the vertices with respect to the best point (low to high).\n     *\n     * @param comparator Final comparison criterion for the sorted simplex.\n     * @param table Simplex table.\n     * @param recentAverage Difference Threshold.\n     * @param iteration Current Iteration.\n     * @return the best point in the simplex.\n     * @throws TooManyEvaluationsException\n     */\n    private PointValuePair findBest(final PointValuePairComparator comparator,\n                                     final AbstractSimplexTableau table,\n                                     final double recentAverage,\n                                     final int iteration)\n        throws TooManyEvaluationsException {\n        // Calculate the best and worst points\n        final PointValuePair[] points = table.getPoints();\n        PointValuePair best = points[0];\n        PointValuePair worst = points[points.length - 1];\n        double dist = 0;\n        // Check the past nTail average for similarity in function values.\n        if (table.getDimension() > 1 && iteration >= table.getDimension() + 1) {\n            int i = table.getDimension(), j = i - 1, k = j - 1;\n            // Check if past iterations show similarity in function values.\n            if (recentAverage > 0.d &&\n                (FastMath.abs(table.getEntry(i, j))\n                 <= getRelativeThreshold() * recentAverage ||\n                 FastMath.abs(table.getEntry(j, k))\n                 <= getRelativeThreshold() * recentAverage)) {\n                // If they are similar, reduce jitter. Otherwise maintain it.\n                dist = getJitter() * FastMath.max(FastMath.abs(points[0].getValue()), worst.getValue() -\n                                                   points[0].getValue());\n                if (getJitter() <= 0) {\n                    // If jitter is zero or less, check for possible convergence\n                    if (FastMath.max(table.getRowVector(0).getNorm(),\n                                      -table.getRowVector(0).getNorm()) <= getAbsoluteThreshold()) {\n                        return best;\n                    }\n                }\n                // apply the maximum function evaluations check\n                if (getMaxEvaluations() <= getEvaluations()) {\n                    evaluate(table.getPoint(0));\n                }\n            } else if (getJitter() > 0) {\n                dist = getJitter() * FastMath.max(FastMath.abs(points[0].getValue()), worst.getValue() -\n                                                   points[0].getValue());\n                // apply the maximum function evaluations check\n                if (getMaxEvaluations() <= getEvaluations()) {\n                    evaluate(table.getPoint(0));\n                }\n            }\n            // Update the recent past average with new function value ranges\n            updateAverage(table, recentAverage);\n        } else {\n            dist = getJitter();\n        }\n        // Expand the simplex if possible, trying to never exceed the {@link ExpansionFactor expFactor}.\n        final double factor = FastMath.min(getExpansionFactor(),\n                                            dist / (FastMath.max(getSimplexSize(table), 1)));\n        PointValuePair reflected = null;\n        final double[] xSmallest = points[0].getPoint();\n        final double[] xLargest = points[points.length - 1].getPoint();\n        final double[] xTrial = new double[xSmallest.length];\n        final double[] xReflected = new double[xSmallest.length];\n        for (int i = 0; i < xTrial.length; i++) {\n            xTrial[i] = xLargest[i] ",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\nindex 42a4d9dfd..ff510a8cc 100644\n--- a/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n+++ b/src/main/java/org/apache/commons/math/optimization/direct/MultiDirectional.java\n@@ -58,46 +58,341 @@ public class MultiDirectional extends DirectSearchOptimizer {\n \n     /** {@inheritDoc} */\n     @Override\n-    protected void iterateSimplex(final Comparator<RealPointValuePair> comparator)\n-        throws FunctionEvaluationException, OptimizationException, IllegalArgumentException {\n+import org.apache.commons.math3.analysis.MultivariateFunction;\n+import org.apache.commons.math3.analysis.SimpleBounds;\n+import org.apache.commons.math3.optim.InitialGuess;\n+import org.apache.commons.math3.optim.MaxEval;\n+import org.apache.commons.math3.optim.PointValuePair;\n+import org.apache.commons.math3.optim.SimpleBounds;\n+import org.apache.commons.math3.optim.nonlinear.scalar.GoalType;\n+import org.apache.commons.math3.optim.nonlinear.scalar.MultivariateOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.ObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.NelderMeadSimplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.LifecycleListener;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.RetryBehavior;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizer.TerminationException;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexOptimizerUtils;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexSolver;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SimplexTableau;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.SingleObjectiveFunction;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.PointValuePairComparator;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplex.Simplex;\n+import org.apache.commons.math3.optim.nonlinear.scalar.noderiv.AbstractSimplexTableau;\n+import org.apache.commons.math3.optim.univariate.UnivariateObjectiveFunction;\n+import org.apache.commons.math3.optim.univariate.UnivariateOptimizer;\n+import org.apache.commons.math3.optim.univariate.UnivariatePointValuePair;\n+import org.apache.commons.math3.optim.univariate.search.BracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.ExpandableBracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.GoldenSectionBracketFinder;\n+import org.apache.commons.math3.optim.univariate.search.SearchInterval;\n+import org.apache.commons.math3.optim.univariate.search.UnivariateSearch;\n+import org.apache.commons.math3.optim.univariate.search.UnivariateSearch.Direction;\n+import org.apache.commons.math3.util.FastMath;\n \n-        while (true) {\n+import java.util.Arrays;\n+import java.util.Comparator;\n \n-            incrementIterationsCounter();\n+public class NelderMead implements MultivariateOptimizer {\n \n-            // save the original vertex\n-            final RealPointValuePair[] original = simplex;\n-            final RealPointValuePair best = original[0];\n+    private static final int DEFAULT_MAX_ITERATIONS = 200;\n+    private static final double DEFAULT_ABSOLUTE_TOLERANCE = 1e-6;\n+    private static final double DEFAULT_RELATIVE_TOLERANCE = 1e-6;\n+    private static final double DEFAULT_SIMPLE_MAX = 1.0;\n+    private static final double DEFAULT_SIMPLE_MIN = 0.5;\n \n-            // perform a reflection step\n-            final RealPointValuePair reflected = evaluateNewSimplex(original, 1.0, comparator);\n-            if (comparator.compare(reflected, best) < 0) {\n+    private final double rho;\n+    private final double khi;\n+    private final double gamma;\n+    private final double sigma;\n+    private final LifecycleListener lifecycleListener;\n \n-                // compute the expanded simplex\n-                final RealPointValuePair[] reflectedSimplex = simplex;\n-                final RealPointValuePair expanded = evaluateNewSimplex(original, khi, comparator);\n-                if (comparator.compare(reflected, expanded) <= 0) {\n-                    // accept the reflected simplex\n-                    simplex = reflectedSimplex;\n-                }\n+    private int iterations;\n+    private int maxIterations;\n+    private double absoluteThreshold;\n+    private double relativeThreshold;\n \n-                return;\n+    public NelderMead() {\n+        this(1.0, 2.0, 0.5, 0.5, DEFAULT_MAX_ITERATIONS, DEFAULT_ABSOLUTE_TOLERANCE, DEFAULT_RELATIVE_TOLERANCE);\n+    }\n \n-            }\n+    public NelderMead(final double rho, final double khi, final double gamma, final double sigma,\n+                      final int maxIterations, final double absoluteThreshold, final double relativeThreshold) {\n+        this.rho = rho;\n+        this.khi = khi;\n+        this.gamma = gamma;\n+        this.sigma = sigma;\n+        this.lifecycleListener = null;\n+        setMaxIterations(maxIterations);\n+        setAbsoluteThreshold(absoluteThreshold);\n+        setRelativeThreshold(relativeThreshold);\n+    }\n \n-            // compute the contracted simplex\n-            final RealPointValuePair contracted = evaluateNewSimplex(original, gamma, comparator);\n-            if (comparator.compare(contracted, best) < 0) {\n-                // accept the contracted simplex\n+    /**\n+     * Gets the reflection coefficient.\n+     *\n+     * @return the reflection coefficient.\n+     */\n+    public double getRho() {\n+        return rho;\n+    }\n \n-            // check convergence\n-                return;\n-            }\n+    /**\n+     * Gets the expansion coefficient.\n+     *\n+     * @return the expansion coefficient.\n+     */\n+    public double getKhi() {\n+        return khi;\n+    }\n+\n+    /**\n+     * Gets the contraction coefficient.\n+     *\n+     * @return the contraction coefficient.\n+     */\n+    public double getGamma() {\n+        return gamma;\n+    }\n \n+    /**\n+     * Gets the shrink coefficient.\n+     *\n+     * @return the shrink coefficient.\n+     */\n+    public double getSigma() {\n+        return sigma;\n+    }\n+\n+    /**\n+     * Gets the maximum number of iterations allowed.\n+     *\n+     * @return the maximum number of iterations allowed.\n+     */\n+    public int getMaxIterations() {\n+        return maxIterations;\n+    }\n+\n+    /**\n+     * Sets the maximum number of iterations allowed.\n+     *\n+     * @param maxIterations the maximum number of iterations allowed.\n+     */\n+    public void setMaxIterations(final int maxIterations) {\n+        this.maxIterations = maxIterations;\n+    }\n+\n+    /**\n+     * Gets the absolute threshold for relative difference.\n+     *\n+     * @return the absolute threshold for relative difference.\n+     */\n+    public double getAbsoluteThreshold() {\n+        return absoluteThreshold;\n+    }\n+\n+    /**\n+     * Sets the absolute threshold for relative difference.\n+     *\n+     * @param absoluteThreshold the absolute threshold for relative difference.\n+     */\n+    public void setAbsoluteThreshold(final double absoluteThreshold) {\n+        this.absoluteThreshold = absoluteThreshold;\n+    }\n+\n+    /**\n+     * Gets the relative threshold for difference.\n+     *\n+     * @return the relative threshold for difference.\n+     */\n+    public double getRelativeThreshold() {\n+        return relativeThreshold;\n+    }\n+\n+    /**\n+     * Sets the relative threshold for difference.\n+     *\n+     * @param relativeThreshold the relative threshold for difference.\n+     */\n+    public void setRelativeThreshold(final double relativeThreshold) {\n+        this.relativeThreshold = relativeThreshold;\n+    }\n+\n+    /**\n+     * Gets the lifecycle listener of the algorithm.\n+     *\n+     * @return the lifecycle listener of the algorithm.\n+     */\n+    public LifecycleListener getLifecycleListener() {\n+        return lifecycleListener;\n+    }\n+\n+    /**\n+     * Set the Simple Bounds on the optimization variables.\n+     *\n+     * @param bounds array of SimpleBounds objects representing valid range of each variable\n+     * @throws IllegalArgumentException if {@code bounds} is null or is of size zero or its elements\n+     * are null or upper bound is less or equal to respective lower bound\n+     * @since 3.1\n+     */\n+    @Override\n+    public void setSimpleBounds(SimpleBounds bounds) {\n+        throw new UnsupportedOperationException(\"NelderMead with bounds is not implemented\");\n+    }\n+\n+    /**\n+     * Find an optimum of an objective function.\n+     *\n+     * @param maxEval Maximum number of function evaluations.\n+     * @param f      Objective function.\n+     * @param goal   Optimization goal: either {@link GoalType#MINIMIZE}\n+     *               or {@link GoalType#MAXIMIZE}.\n+     * @param startPoint Start point.\n+     * @return the point/value pair giving the optimal value of the objective function.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.\n+     */\n+    public PointValuePair optimize(final MaxEval maxEval, final MultivariateFunction f, final GoalType goal,\n+                                    final double[] startPoint) {\n+        return optimizeInternal(maxEval.getMaxeval(), new ObjectiveFunction(f), goal, new InitialGuess(startPoint));\n+    }\n+\n+    /**\n+     * Find an optimum of an objective function.\n+     *\n+     * @param maxEval Maximum number of function evaluations.\n+     * @param f      Objective function.\n+     * @param goal   Optimization goal: either {@link GoalType#MINIMIZE}\n+     *               or {@link GoalType#MAXIMIZE}.\n+     * @param startPoint Start point.\n+     * @param lower Lower bounds.\n+     * @param upper Upper bounds.\n+     * @return the point/value pair giving the optimal value of the objective function.\n+     * @throws TooManyEvaluationsException if the maximal number of evaluations is exceeded.\n+     * @throws IllegalArgumentException if the array lengths differ, or initial guess\n+     * is not within the specified bounds\n+     * @since 3.1\n+     */\n+    @Override\n+    public PointValuePair optimize(final MaxEval maxEval, final MultivariateFunction f, final GoalType goal,\n+                              final double[] startPoint, final double[] lower, final double[] upper) {\n+        throw new UnsupportedOperationException(\"NelderMead with bounds is not implemented\");\n+    }\n+\n+    /**\n+     * Get the search interval for univariate search at the vertex.\n+     *\n+     * @param vertex the vertex.\n+     * @param simplex the simplex.\n+     * @return the search interval.\n+     */\n+    private SearchInterval[] getSearchInterval(final double[] vertex, final Simplex simplex) {\n+        final int n = simplex.getDimension();\n+        final SearchInterval[] interval = new SearchInterval[n];\n+        for (int i = 0; i < n; i++) {\n+            final double[] x = simplex.getPoint(i);\n+            final double[] displacement = new double[n];\n+            for (int j = 0; j < n; j++) {\n+                displacement[j] = x[j] - vertex[j];\n+            }\n+            final double coef = computeCoefficients(displacement);\n+            interval[i] = new SearchInterval(x[i], coef);\n         }\n+        return interval;\n+    }\n \n+    /**\n+     * Compute the coefficients of the univariate quadratic model.\n+     *\n+     * @param x the displacement between the point and the vertices.\n+     * @return the coefficients of the univariate quadratic model.\n+     */\n+    private double computeCoefficients(final double[] x) {\n+        double a = 0;\n+        double b = 0;\n+        double c = 0;\n+        final int n = x.length;\n+        for (int i = 0; i < n; i++) {\n+            final double xi = x[i];\n+            a += xi * xi;\n+            b += xi;\n+            c += 1.0;\n+        }\n+        a /= n;\n+        b /= n;\n+        return (sigma * a - b * b) / FastMath.sqrt(c);\n     }\n \n+    /**\n+     * Compare the function values at the simplex vertices.\n+     * If recent past iterations\n+     * show that the result of function evaluations are becoming similar,\n+     * use the ordering of the vertices with respect to the best point (low to high).\n+     *\n+     * @param comparator Final comparison criterion for the sorted simplex.\n+     * @param table Simplex table.\n+     * @param recentAverage Difference Threshold.\n+     * @param iteration Current Iteration.\n+     * @return the best point in the simplex.\n+     * @throws TooManyEvaluationsException\n+     */\n+    private PointValuePair findBest(final PointValuePairComparator comparator,\n+                                     final AbstractSimplexTableau table,\n+                                     final double recentAverage,\n+                                     final int iteration)\n+        throws TooManyEvaluationsException {\n+        // Calculate the best and worst points\n+        final PointValuePair[] points = table.getPoints();\n+        PointValuePair best = points[0];\n+        PointValuePair worst = points[points.length - 1];\n+        double dist = 0;\n+        // Check the past nTail average for similarity in function values.\n+        if (table.getDimension() > 1 && iteration >= table.getDimension() + 1) {\n+            int i = table.getDimension(), j = i - 1, k = j - 1;\n+            // Check if past iterations show similarity in function values.\n+            if (recentAverage > 0.d &&\n+                (FastMath.abs(table.getEntry(i, j))\n+                 <= getRelativeThreshold() * recentAverage ||\n+                 FastMath.abs(table.getEntry(j, k))\n+                 <= getRelativeThreshold() * recentAverage)) {\n+                // If they are similar, reduce jitter. Otherwise maintain it.\n+                dist = getJitter() * FastMath.max(FastMath.abs(points[0].getValue()), worst.getValue() -\n+                                                   points[0].getValue());\n+                if (getJitter() <= 0) {\n+                    // If jitter is zero or less, check for possible convergence\n+                    if (FastMath.max(table.getRowVector(0).getNorm(),\n+                                      -table.getRowVector(0).getNorm()) <= getAbsoluteThreshold()) {\n+                        return best;\n+                    }\n+                }\n+                // apply the maximum function evaluations check\n+                if (getMaxEvaluations() <= getEvaluations()) {\n+                    evaluate(table.getPoint(0));\n+                }\n+            } else if (getJitter() > 0) {\n+                dist = getJitter() * FastMath.max(FastMath.abs(points[0].getValue()), worst.getValue() -\n+                                                   points[0].getValue());\n+                // apply the maximum function evaluations check\n+                if (getMaxEvaluations() <= getEvaluations()) {\n+                    evaluate(table.getPoint(0));\n+                }\n+            }\n+            // Update the recent past average with new function value ranges\n+            updateAverage(table, recentAverage);\n+        } else {\n+            dist = getJitter();\n+        }\n+        // Expand the simplex if possible, trying to never exceed the {@link ExpansionFactor expFactor}.\n+        final double factor = FastMath.min(getExpansionFactor(),\n+                                            dist / (FastMath.max(getSimplexSize(table), 1)));\n+        PointValuePair reflected = null;\n+        final double[] xSmallest = points[0].getPoint();\n+        final double[] xLargest = points[points.length - 1].getPoint();\n+        final double[] xTrial = new double[xSmallest.length];\n+        final double[] xReflected = new double[xSmallest.length];\n+        for (int i = 0; i < xTrial.length; i++) {\n+            xTrial[i] = xLargest[i] \n+\n     /** Compute and evaluate a new simplex.\n      * @param original original simplex (to be preserved)\n      * @param coeff linear coefficient",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}