{
    "patch": "private void readTypeVariables() {\n    Type[] bounds = typeVariable.getBounds();\n    if (bounds.length == 0) {\n        return;\n    }\n    for (Type bound : bounds) {\n        if (bound instanceof TypeVariable) {\n            // Ensure that type variable binding is recurisvely resolved\n            new TypeVariableReader((TypeVariable<?>) bound, typeVariableRegistry).readTypeVariables();\n        } else if (bound instanceof ParameterizedType) {\n            // Register the actual type arguments of the parameterized type recursively\n            ParameterizedType parameterizedType = (ParameterizedType) bound;\n            for (Type typeArg : parameterizedType.getActualTypeArguments()) {\n                if (typeArg instanceof TypeVariable) {\n                    new TypeVariableReader((TypeVariable<?>) typeArg, typeVariableRegistry).readTypeVariables();\n                } else {\n                    typeVariableRegistry.register(typeArg);\n                }\n            }\n        } else {\n            // For other types, register them directly as type variables\n            typeVariableRegistry.register(bound);\n        }\n    }\n    TypeVariable<?>[] typeParams = getTypeParametersFromActualTypeVariable(getActualTypeArgumentFor(typeVariable));\n    if (typeParams == null) {\n        return;\n    }\n    Type genericSuperClass = getClass().getGenericSuperclass();\n    if (genericSuperClass instanceof Class) {\n        return;\n    }\n    ParameterizedType parameterizedType = (ParameterizedType)genericSuperClass;\n    Type[] actualTypeArgs = parameterizedType.getActualTypeArguments();\n    Map<TypeVariable<?>, Type> typeArgMappings = new HashMap<>();\n    for (int i = 0; i < typeParams.length; i++) {\n        typeArgMappings.put(typeParams[i], actualTypeArgs[i]);\n    }\n    readTypeVariables(typeVariable, typeArgMappings);\n}\n\nprivate void readTypeVariables(TypeVariable<?> typeVariable, Map<TypeVariable<?>, Type> typeArgMappings) {\n    Type[] bounds = typeVariable.getBounds();\n    boolean typeVariableResolved = false;\n    for (Type bound : bounds) {\n        if (bound instanceof TypeVariable) {\n            TypeVariable<?> subTypeVariable = (TypeVariable<?>) bound;\n            Type resolvedType = typeArgMappings.get(subTypeVariable);\n            if (resolvedType instanceof TypeVariable) {\n                new TypeVariableReader((TypeVariable<?>) resolvedType, typeVariableRegistry).readTypeVariables();\n            } else {\n                typeVariableRegistry.register(resolvedType);\n            }\n            typeVariableResolved = true;\n        }\n    }\n    if (!typeVariableResolved) {\n        TypeVariable<?>[] typeParams = getTypeParametersFromActualTypeVariable(typeArgMappings.get(typeVariable));\n        if (typeParams != null) {\n            for (TypeVariable<?> typeParamTypeVariable : typeParams) {\n                Type resolvedType = typeArgMappings.get(typeParamTypeVariable);\n                if (resolvedType instanceof TypeVariable) {\n                    readTypeVariables((TypeVariable<?>) resolvedType, typeArgMappings);\n                } else {\n                    typeVariableRegistry.register(resolvedType);\n                }\n            }\n        }\n    }\n}",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\nindex 2d6c07b17..617c72dea 100644\n--- a/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n+++ b/src/org/mockito/internal/util/reflection/GenericMetadataSupport.java\n@@ -372,12 +372,77 @@ public abstract class GenericMetadataSupport {\n             registerTypeParametersOn(typeParameters);\n         }\n \n-        private void readTypeVariables() {\n-            for (Type type : typeVariable.getBounds()) {\n-                registerTypeVariablesOn(type);\n-            }\n-            registerTypeVariablesOn(getActualTypeArgumentFor(typeVariable));\n-        }\n+\n+private void readTypeVariables() {\n+    Type[] bounds = typeVariable.getBounds();\n+    if (bounds.length == 0) {\n+        return;\n+    }\n+    for (Type bound : bounds) {\n+        if (bound instanceof TypeVariable) {\n+            // Ensure that type variable binding is recurisvely resolved\n+            new TypeVariableReader((TypeVariable<?>) bound, typeVariableRegistry).readTypeVariables();\n+        } else if (bound instanceof ParameterizedType) {\n+            // Register the actual type arguments of the parameterized type recursively\n+            ParameterizedType parameterizedType = (ParameterizedType) bound;\n+            for (Type typeArg : parameterizedType.getActualTypeArguments()) {\n+                if (typeArg instanceof TypeVariable) {\n+                    new TypeVariableReader((TypeVariable<?>) typeArg, typeVariableRegistry).readTypeVariables();\n+                } else {\n+                    typeVariableRegistry.register(typeArg);\n+                }\n+            }\n+        } else {\n+            // For other types, register them directly as type variables\n+            typeVariableRegistry.register(bound);\n+        }\n+    }\n+    TypeVariable<?>[] typeParams = getTypeParametersFromActualTypeVariable(getActualTypeArgumentFor(typeVariable));\n+    if (typeParams == null) {\n+        return;\n+    }\n+    Type genericSuperClass = getClass().getGenericSuperclass();\n+    if (genericSuperClass instanceof Class) {\n+        return;\n+    }\n+    ParameterizedType parameterizedType = (ParameterizedType)genericSuperClass;\n+    Type[] actualTypeArgs = parameterizedType.getActualTypeArguments();\n+    Map<TypeVariable<?>, Type> typeArgMappings = new HashMap<>();\n+    for (int i = 0; i < typeParams.length; i++) {\n+        typeArgMappings.put(typeParams[i], actualTypeArgs[i]);\n+    }\n+    readTypeVariables(typeVariable, typeArgMappings);\n+}\n+\n+private void readTypeVariables(TypeVariable<?> typeVariable, Map<TypeVariable<?>, Type> typeArgMappings) {\n+    Type[] bounds = typeVariable.getBounds();\n+    boolean typeVariableResolved = false;\n+    for (Type bound : bounds) {\n+        if (bound instanceof TypeVariable) {\n+            TypeVariable<?> subTypeVariable = (TypeVariable<?>) bound;\n+            Type resolvedType = typeArgMappings.get(subTypeVariable);\n+            if (resolvedType instanceof TypeVariable) {\n+                new TypeVariableReader((TypeVariable<?>) resolvedType, typeVariableRegistry).readTypeVariables();\n+            } else {\n+                typeVariableRegistry.register(resolvedType);\n+            }\n+            typeVariableResolved = true;\n+        }\n+    }\n+    if (!typeVariableResolved) {\n+        TypeVariable<?>[] typeParams = getTypeParametersFromActualTypeVariable(typeArgMappings.get(typeVariable));\n+        if (typeParams != null) {\n+            for (TypeVariable<?> typeParamTypeVariable : typeParams) {\n+                Type resolvedType = typeArgMappings.get(typeParamTypeVariable);\n+                if (resolvedType instanceof TypeVariable) {\n+                    readTypeVariables((TypeVariable<?>) resolvedType, typeArgMappings);\n+                } else {\n+                    typeVariableRegistry.register(resolvedType);\n+                }\n+            }\n+        }\n+    }\n+}\n \n         @Override\n         public Class<?> rawType() {",
    "result_reason": "error: diamond operator is not supported in -source 1.5",
    "test_result": "ERROR"
}