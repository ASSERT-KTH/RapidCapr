{
    "patch": "          if (!callNode.hasOneChild()) {\n            return false;\n          }\n          Node firstChild = callNode.getFirstChild();\n          if (!firstChild.isName()) {\n            return false;\n          }\n\n          String methodName = firstChild.getString();\n          String prefix = convention.getSingletonGetterClassName(\n              methodName, callNode, compiler);\n          if (prefix == null) {\n            return false;\n          }\n          if (!NodeUtil.isImmutableValue(value, compiler) ||\n              NodeUtil.isMutationTarget(value)) {\n            return false;\n          }\n\n          // Retrieve all property assignments to the base object.\n          List<Reference> externalRefs = new ArrayList<Reference>();\n          if (!findAllReferencesToScope(value.getSecondChild(), externalRefs)) {\n            return false;\n          }\n\n          // Ensure all the referenced properties (ignoring any invalid\n          // property names) have unique string values.\n          boolean hasCollision = false;\n          for (Reference ref : externalRefs) {\n            Node n = ref.getNode();\n\n            // If the reference is on a NAME node, the name has to be the prefix.\n            if (ref.getSymbol().getScope().isGlobal()) {\n              String name = n.getString();\n              if (!name.startsWith(prefix) || name.substring(prefix.length()).contains(\"$\")) {\n                return false;\n              }\n            } else {\n              Preconditions.checkState(n.isStringKey(), n);\n              if (!n.getString().startsWith(prefix)) {\n                return false;\n              }\n            }\n\n            // Check for name collision in object literals.\n            Node parent = n.getParent();\n            if (parent.isObjectLit()) {\n              for (Node other : parent.children()) {\n                if (n == other) {\n                  break;\n                }\n                if (!other.isStringKey() ||\n                    !other.getString().startsWith(prefix) ||\n                    n.getString().equals(other.getString())) {\n                  continue;\n                }\n                if (NodeUtil.isImmutableValue(n.getParent()\n                        .getLastChild().getFirstChild(), compiler)) {\n                  return false;\n                }\n                hasCollision = true;\n              }\n            }\n          }\n          return !hasCollision;",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..476f8bde 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,71 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+          if (!callNode.hasOneChild()) {\n+            return false;\n+          }\n+          Node firstChild = callNode.getFirstChild();\n+          if (!firstChild.isName()) {\n+            return false;\n+          }\n+\n+          String methodName = firstChild.getString();\n+          String prefix = convention.getSingletonGetterClassName(\n+              methodName, callNode, compiler);\n+          if (prefix == null) {\n+            return false;\n+          }\n+          if (!NodeUtil.isImmutableValue(value, compiler) ||\n+              NodeUtil.isMutationTarget(value)) {\n+            return false;\n+          }\n+\n+          // Retrieve all property assignments to the base object.\n+          List<Reference> externalRefs = new ArrayList<Reference>();\n+          if (!findAllReferencesToScope(value.getSecondChild(), externalRefs)) {\n+            return false;\n+          }\n+\n+          // Ensure all the referenced properties (ignoring any invalid\n+          // property names) have unique string values.\n+          boolean hasCollision = false;\n+          for (Reference ref : externalRefs) {\n+            Node n = ref.getNode();\n+\n+            // If the reference is on a NAME node, the name has to be the prefix.\n+            if (ref.getSymbol().getScope().isGlobal()) {\n+              String name = n.getString();\n+              if (!name.startsWith(prefix) || name.substring(prefix.length()).contains(\"$\")) {\n+                return false;\n+              }\n+            } else {\n+              Preconditions.checkState(n.isStringKey(), n);\n+              if (!n.getString().startsWith(prefix)) {\n+                return false;\n+              }\n+            }\n+\n+            // Check for name collision in object literals.\n+            Node parent = n.getParent();\n+            if (parent.isObjectLit()) {\n+              for (Node other : parent.children()) {\n+                if (n == other) {\n+                  break;\n+                }\n+                if (!other.isStringKey() ||\n+                    !other.getString().startsWith(prefix) ||\n+                    n.getString().equals(other.getString())) {\n+                  continue;\n+                }\n+                if (NodeUtil.isImmutableValue(n.getParent()\n+                        .getLastChild().getFirstChild(), compiler)) {\n+                  return false;\n+                }\n+                hasCollision = true;\n+              }\n+            }\n+          }\n+          return !hasCollision;\n         }\n       }\n ",
    "result_reason": "error: method getSingletonGetterClassName in interface CodingConvention cannot be applied to given types;",
    "test_result": "ERROR"
}