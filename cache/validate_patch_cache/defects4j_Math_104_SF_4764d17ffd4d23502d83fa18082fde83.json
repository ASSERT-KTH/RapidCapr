{
    "patch": "import static org.apache.commons.math3.util.FastMath.abs;\nimport static org.apache.commons.math3.util.FastMath.exp;\nimport static org.apache.commons.math3.util.FastMath.log;\nimport static org.apache.commons.math3.util.FastMath.sqrt;\n\nimport org.apache.commons.math3.exception.TooManyIterationsException;\nimport org.apache.commons.math3.util.Pair;\n\npublic class RegularizedIncompleteGamma {\n\n    private static final double DEFAULT_EPSILON = 1e-15;\n    private static final int DEFAULT_MAX_ITERATIONS = 1000;\n\n    public static double regularizedGammaP(double a, double x) {\n        return regularizedGammaP(a, x, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n    }\n\n    /**\n     * Returns the regularized gamma function P(a, x).\n     *\n     * @param a parameter (must be positive)\n     * @param x integration bounds (must be non-negative)\n     * @param epsilon maximum absolute error allowed (must be positive)\n     * @param maxIterations maximum number of iterations allowed (must be positive)\n     * @return regularized gamma function P(a, x)\n     */\n    public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n        if (a <= 0.0) {\n            throw new IllegalArgumentException(\"Parameter a must be positive. Received: \" + a);\n        }\n        if (x < 0.0) {\n            throw new IllegalArgumentException(\"Parameter x must be non-negative. Received: \" + x);\n        }\n        if (epsilon <= 0.0) {\n            throw new IllegalArgumentException(\"Epsilon must be positive. Received: \" + epsilon);\n        }\n        if (maxIterations <= 0) {\n            throw new IllegalArgumentException(\"Maximum number of iterations must be positive. Received: \" + maxIterations);\n        }\n\n        // Series representation, continued fraction representation and minimum for switching method\n        final double halfLogTwoPi = 0.5 * log(2 * Math.PI);\n        final double small = 1e-50;\n        final double bigInv = Double.MAX_VALUE;\n        final double big = 1.0 / bigInv;\n\n        if (x < a + 1) {\n\n            // Use the series representation\n            double n = 0.0; // Current element index\n            double an = 1.0 / a; // Current element a_n\n            double sum = an; // Sum starts with first element\n            double last = sum; // Save previous sum value to compute error\n            while (abs(sum - last) > abs(sum) * epsilon) {\n                n += 1.0;\n                an *= x / (a + n);\n                sum += an;\n                last = sum;\n                if (n > maxIterations) {\n                    throw new TooManyIterationsException(maxIterations);\n                }\n            }\n            return exp(-x + a * log(x) - logGamma(a)) * sum;\n\n        } else {\n\n            // Use the continued fraction representation\n            double b0 = 0.0;\n            double b1 = small;\n            double d0 = 1.0;\n            double c0 = b1;\n            double c1 = big;\n            double an = x;\n            double deltaN = 1.0;\n            double deltaNp1 = x / a;\n            double cf = deltaNp1;\n            double n = 1.0;\n            double last = cf; // Save previous sum value to compute error\n            while (abs(cf - last) > abs(cf) * epsilon) {\n                last = cf;\n                double aN = n * (a - n);\n                b0 += (n == 1.0 ? 1.0 : 2.0) * deltaN;\n                deltaN = an * deltaNp1;\n                b1 += (n == 1.0 ? a : aN) * deltaN;\n                d0 += (n == 1.0 ? 0.0 : (n - 1.0) * (n - a)) * deltaNp1;\n                deltaNp1 = an * deltaNp1 + aN * deltaN;\n                if (abs(deltaNp1) > big) {\n                    b0 *= bigInv;\n                    b1 *= bigInv;\n                    d0 *= bigInv;\n                    deltaN *= bigInv;\n                    deltaNp1 *= bigInv;\n                }\n                double cN = b1 != 0.0 ? b0 / b1 : big;\n                c0 = (n == 1.0 ? cN : c1 * cN) + c0 * d0;\n                if (abs(c0) > big) {\n                    b0 *= bigInv;\n                    b1 *= bigInv;\n                    d0 *= bigInv;\n                    c0 *= bigInv;\n                    c1 *= bigInv;\n                }\n                cf = b1 != 0.0 ? 1.0 / b1 : big;\n                cf *= c0;\n                if (abs(cf) > big) {\n                    b0 *= bigInv;\n                    b1 *= bigInv;\n                    cf *= bigInv;\n                }\n                n += 1.0;\n                an = x + n - a;\n                if (n > maxIterations) {\n                    throw new TooManyIterationsException(maxIterations);\n                }\n            }\n            return 1.0 - exp(-x + a * log(x) - logGamma(a)) * cf;\n        }\n    }\n\n    /**\n     * Returns the logarithm of the gamma function.\n     *\n     * @param x the argument of the gamma function (must be positive)\n     * @return the logarithm of the gamma function\n     */\n    private static double logGamma(double x) {\n        if (x <= 0.0) {\n            throw new IllegalArgumentException(\"Argument must be positive. Received: \" + x);\n        }\n        if (x < 1e-5) {\n            return -log(x);\n        }\n\n        double d1 = -0.5772156649015329;\n        double di = 1.0 / 15.0;\n        double g = di;\n        x += 1.0;\n        double c = 0.0;\n        double s = 1.0;\n        double p = di;\n        boolean done = false;\n        for (int i = 1; !done; ++i) {\n            c = -c + 1.0;\n            s *= (x + c - 1) / (x + c);\n            di *= i / (x + c);\n            p += di;\n            if (abs(di / p) < 1e-15) {\n                done = true;\n            }\n            if (i % 5 == 0) {\n                g += p * s;\n                s = 1.0;\n                p = di;\n            }\n        }\n        return d1 + log(g * x);\n    }\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..1344c54be 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,164 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+import static org.apache.commons.math3.util.FastMath.abs;\n+import static org.apache.commons.math3.util.FastMath.exp;\n+import static org.apache.commons.math3.util.FastMath.log;\n+import static org.apache.commons.math3.util.FastMath.sqrt;\n+\n+import org.apache.commons.math3.exception.TooManyIterationsException;\n+import org.apache.commons.math3.util.Pair;\n+\n+public class RegularizedIncompleteGamma {\n+\n+    private static final double DEFAULT_EPSILON = 1e-15;\n+    private static final int DEFAULT_MAX_ITERATIONS = 1000;\n+\n+    public static double regularizedGammaP(double a, double x) {\n+        return regularizedGammaP(a, x, DEFAULT_EPSILON, DEFAULT_MAX_ITERATIONS);\n+    }\n+\n+    /**\n+     * Returns the regularized gamma function P(a, x).\n+     *\n+     * @param a parameter (must be positive)\n+     * @param x integration bounds (must be non-negative)\n+     * @param epsilon maximum absolute error allowed (must be positive)\n+     * @param maxIterations maximum number of iterations allowed (must be positive)\n+     * @return regularized gamma function P(a, x)\n+     */\n+    public static double regularizedGammaP(double a, double x, double epsilon, int maxIterations) {\n+        if (a <= 0.0) {\n+            throw new IllegalArgumentException(\"Parameter a must be positive. Received: \" + a);\n+        }\n+        if (x < 0.0) {\n+            throw new IllegalArgumentException(\"Parameter x must be non-negative. Received: \" + x);\n+        }\n+        if (epsilon <= 0.0) {\n+            throw new IllegalArgumentException(\"Epsilon must be positive. Received: \" + epsilon);\n+        }\n+        if (maxIterations <= 0) {\n+            throw new IllegalArgumentException(\"Maximum number of iterations must be positive. Received: \" + maxIterations);\n+        }\n+\n+        // Series representation, continued fraction representation and minimum for switching method\n+        final double halfLogTwoPi = 0.5 * log(2 * Math.PI);\n+        final double small = 1e-50;\n+        final double bigInv = Double.MAX_VALUE;\n+        final double big = 1.0 / bigInv;\n+\n+        if (x < a + 1) {\n+\n+            // Use the series representation\n+            double n = 0.0; // Current element index\n+            double an = 1.0 / a; // Current element a_n\n+            double sum = an; // Sum starts with first element\n+            double last = sum; // Save previous sum value to compute error\n+            while (abs(sum - last) > abs(sum) * epsilon) {\n+                n += 1.0;\n+                an *= x / (a + n);\n+                sum += an;\n+                last = sum;\n+                if (n > maxIterations) {\n+                    throw new TooManyIterationsException(maxIterations);\n+                }\n+            }\n+            return exp(-x + a * log(x) - logGamma(a)) * sum;\n+\n+        } else {\n+\n+            // Use the continued fraction representation\n+            double b0 = 0.0;\n+            double b1 = small;\n+            double d0 = 1.0;\n+            double c0 = b1;\n+            double c1 = big;\n+            double an = x;\n+            double deltaN = 1.0;\n+            double deltaNp1 = x / a;\n+            double cf = deltaNp1;\n+            double n = 1.0;\n+            double last = cf; // Save previous sum value to compute error\n+            while (abs(cf - last) > abs(cf) * epsilon) {\n+                last = cf;\n+                double aN = n * (a - n);\n+                b0 += (n == 1.0 ? 1.0 : 2.0) * deltaN;\n+                deltaN = an * deltaNp1;\n+                b1 += (n == 1.0 ? a : aN) * deltaN;\n+                d0 += (n == 1.0 ? 0.0 : (n - 1.0) * (n - a)) * deltaNp1;\n+                deltaNp1 = an * deltaNp1 + aN * deltaN;\n+                if (abs(deltaNp1) > big) {\n+                    b0 *= bigInv;\n+                    b1 *= bigInv;\n+                    d0 *= bigInv;\n+                    deltaN *= bigInv;\n+                    deltaNp1 *= bigInv;\n+                }\n+                double cN = b1 != 0.0 ? b0 / b1 : big;\n+                c0 = (n == 1.0 ? cN : c1 * cN) + c0 * d0;\n+                if (abs(c0) > big) {\n+                    b0 *= bigInv;\n+                    b1 *= bigInv;\n+                    d0 *= bigInv;\n+                    c0 *= bigInv;\n+                    c1 *= bigInv;\n+                }\n+                cf = b1 != 0.0 ? 1.0 / b1 : big;\n+                cf *= c0;\n+                if (abs(cf) > big) {\n+                    b0 *= bigInv;\n+                    b1 *= bigInv;\n+                    cf *= bigInv;\n+                }\n+                n += 1.0;\n+                an = x + n - a;\n+                if (n > maxIterations) {\n+                    throw new TooManyIterationsException(maxIterations);\n+                }\n+            }\n+            return 1.0 - exp(-x + a * log(x) - logGamma(a)) * cf;\n+        }\n+    }\n+\n+    /**\n+     * Returns the logarithm of the gamma function.\n+     *\n+     * @param x the argument of the gamma function (must be positive)\n+     * @return the logarithm of the gamma function\n+     */\n+    private static double logGamma(double x) {\n+        if (x <= 0.0) {\n+            throw new IllegalArgumentException(\"Argument must be positive. Received: \" + x);\n+        }\n+        if (x < 1e-5) {\n+            return -log(x);\n+        }\n+\n+        double d1 = -0.5772156649015329;\n+        double di = 1.0 / 15.0;\n+        double g = di;\n+        x += 1.0;\n+        double c = 0.0;\n+        double s = 1.0;\n+        double p = di;\n+        boolean done = false;\n+        for (int i = 1; !done; ++i) {\n+            c = -c + 1.0;\n+            s *= (x + c - 1) / (x + c);\n+            di *= i / (x + c);\n+            p += di;\n+            if (abs(di / p) < 1e-15) {\n+                done = true;\n+            }\n+            if (i % 5 == 0) {\n+                g += p * s;\n+                s = 1.0;\n+                p = di;\n+            }\n+        }\n+        return d1 + log(g * x);\n+    }\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}