{
    "patch": "public int parseInto(ReadWritableInstant instant, String text, int position) {\n    DateTimeParser parser = requireParser();\n    if (instant == null) {\n        throw new IllegalArgumentException(\"Instant must not be null\");\n    }\n\n    long instantMillis = instant.getMillis();\n    Chronology chrono = instant.getChronology();\n    DateTimeZone zone = chrono.getZone();\n\n    int parsedOffset = 0;\n    int newPos = position;\n    int length = text.length();\n\n    if (zone instanceof FixedDateTimeZone) {\n        parsedOffset = zone.getOffset(instantMillis);\n    }\n\n    while (newPos < length) {\n        char c = text.charAt(newPos);\n        if (c == ' ' || c == '\\t') {\n\n        } else if ((c == '+' || c == '-') && (zone instanceof CachedDateTimeZone || zone instanceof DefaultDateTimeZone || zone instanceof FixedDateTimeZone)) {\n            // Handle sign character like 'Z' or '+00:00'\n            OffsetDateTimeParser offsetParser = new OffsetDateTimeParser();\n            newPos = offsetParser.parseInto(bucket, text, newPos);\n            parsedOffset = bucket.getOffsetInteger();\n            if (parsedOffset != null) {\n                parsedOffset = parsedOffset.intValue();\n            }\n        } else if (c == 'Z' && (zone instanceof CachedDateTimeZone || zone instanceof DefaultDateTimeZone)) {\n            // Handle Z character like \"+00:00\"\n            int offset = 0;\n            if (instantMillis >= Long.MAX_VALUE - FixedDateTimeZone.UTC_TOTAL_MILLIS ||\n                    instantMillis <= Long.MIN_VALUE + FixedDateTimeZone.UTC_TOTAL_MILLIS) {\n                // Handle cases where adding or subtracting FixedDateTimeZone.UTC_TOTAL_MILLIS could overflow the long\n                offset = FixedDateTimeZone.UTC_TOTAL_MILLIS - zone.getOffset(instantMillis);\n            } else {\n                offset = (int) (FixedDateTimeZone.UTC_TOTAL_MILLIS + (instantMillis - zone.getOffset(instantMillis)));\n            }\n            parsedOffset = offset;\n            newPos++;\n        } else {\n            if (!(zone instanceof CachedDateTimeZone)) {\n                break;\n            }\n\n            // If we're in a CachedDateTimeZone, we need to parse the offset manually in order to correctly handle DST transitions\n            boolean offsetParsed = parseOffset(text, newPos, bucket);\n            int parsedOffsetFromParsing = bucket.getOffsetInteger();\n            if (offsetParsed && parsedOffsetFromParsing != null) {\n                parsedOffset = parsedOffsetFromParsing.intValue();\n            }\n            newPos = bucket.getSavePos();\n        }\n    }\n\n    if (instantMillis == DateTimeUtils.MILLIS_PER_DAY && parsedOffset == 0 && (zone instanceof CachedDateTimeZone || zone instanceof DefaultDateTimeZone)) {\n        // Handle special case where the input is \"24:00\" or \"00:00\", which may be represented as midnight in a local time zone\n        instantMillis -= parsedOffset;\n        bucket.saveField(DateTimeFieldType.dayOfMonth(), 1);\n    } else if (!(zone instanceof FixedDateTimeZone)) {\n        // If we're not in a FixedDateTimeZone, then we need to parse the input date and adjust the time zone offset as necessary\n        instantMillis = instantMillis + zone.getOffset(instantMillis);\n        chrono = selectChronology(chrono);\n        int defaultYear = chrono.year().get(instantMillis);\n\n        DateTimeParserBucket bucket = new DateTimeParserBucket(\n                instantMillis, chrono, iLocale, iPivotYear, defaultYear);\n        newPos = parser.parseInto(bucket, text, newPos);\n\n        if (bucket.getOffsetInteger() != null) {\n            parsedOffset = bucket.getOffsetInteger().intValue();\n            chrono = chrono.withZone(DateTimeZone.forOffsetMillis(parsedOffset));\n        } else if (bucket.getZone() != null) {\n            chrono = chrono.withZone(bucket.getZone());\n        } else {\n            int offset = chrono.getZone().getOffset(instantMillis);\n            chrono = selectChronology(chrono.withZone(DateTimeZone.forOffsetMillis(offset)));\n        }\n        instant.setChronology(chrono);\n        instantMillis = chrono.getZone().adjustOffset(instantMillis - parsedOffset, false);\n        instant.setMillis(instantMillis);\n    } else {\n        instant.setMillis(instantMillis - parsedOffset);\n    }\n\n    if (iZone != null) {\n        instant.setZone(iZone);\n    }\n    return newPos;\n}\n\nprivate boolean parseOffset(String text, int position, DateTimeParserBucket bucket) {\n    // If we can't parse an offset, we end up using the original zone offset instead\n    int length = text.length();\n    if (position >= length || (text.charAt(position) != '+' && text.charAt(position) != '-')) {\n        return false;\n    }\n\n    int sign = (text.charAt(position) == '+') ? 1 : -1;\n    position++;\n\n    int hours = 0;\n    int minutes = 0;\n    int seconds = 0;\n    boolean colon1Found = false;\n    boolean colon2Found = false;\n\n    if (!isDigit(text.charAt(position))) {\n        return false;\n    }\n    hours = text.charAt(position) - '0';\n    position++;\n\n    if (isDigit(text.charAt(position))) {\n        hours = hours * 10 + (text.charAt(position) - '0');\n        position++;\n    }\n\n    if (hours >= 24) {\n        return false;\n    }\n\n    if (position >= length) {\n        bucket.setOffset((-1 * sign) * (hours * 60 * 60 * 1000));\n        return true;\n    }\n\n    if (text.charAt(position) == ':') {\n        colon1Found = true;\n        position++;\n    }\n\n    if (position + 1 < length && isDigit(text.charAt(position)) && isDigit(text.charAt(position + 1))) {\n        minutes = (text.charAt(position) - '0') * 10 + (text.charAt(position + 1) - '0');\n        position += 2;\n    } else if (isDigit(text.charAt(position))) {\n        minutes = text.charAt(position) - '0';\n        position++;\n    }\n\n    if (minutes >= 60) {\n        return false;\n    }\n\n    if (position >= length) {\n        bucket.setOffset((-1 * sign) * ((hours * 60 * 60 * 1000) + (minutes * 60 * 1000)));\n        return true;\n    }\n\n    if (text.charAt(position) == ':') {\n        colon2Found = true;\n        position++;\n    }\n\n    if (colon1Found && colon2Found && isDigit(text.charAt(position)) && isDigit(text.charAt(position + 1))) {\n        seconds = (text.charAt(position) - '0') * 10 + (text.charAt(position + 1) - '0');\n        position += 2;\n    } else if (isDigit(text.charAt(position))) {\n        seconds = text.charAt(position) - '0';\n        position++;\n    }\n\n    if (seconds >= 60) {\n        return false;\n    }\n\n    bucket.setOffset((-1 * sign) * ((hours * 60 * 60 * 1000) + (minutes * 60 * 1000) + (seconds * 1000)));\n    return true;\n}\n\nprivate boolean isDigit(char c) {\n    return c >= '0' && c <= '9';\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeFormatter.java b/src/main/java/org/joda/time/format/DateTimeFormatter.java\nindex 447674a2..12b311a9 100644\n--- a/src/main/java/org/joda/time/format/DateTimeFormatter.java\n+++ b/src/main/java/org/joda/time/format/DateTimeFormatter.java\n@@ -697,36 +697,182 @@ public class DateTimeFormatter {\n      * @throws IllegalArgumentException if the instant is null\n      * @throws IllegalArgumentException if any field is out of range\n      */\n-    public int parseInto(ReadWritableInstant instant, String text, int position) {\n-        DateTimeParser parser = requireParser();\n-        if (instant == null) {\n-            throw new IllegalArgumentException(\"Instant must not be null\");\n+public int parseInto(ReadWritableInstant instant, String text, int position) {\n+    DateTimeParser parser = requireParser();\n+    if (instant == null) {\n+        throw new IllegalArgumentException(\"Instant must not be null\");\n+    }\n+\n+    long instantMillis = instant.getMillis();\n+    Chronology chrono = instant.getChronology();\n+    DateTimeZone zone = chrono.getZone();\n+\n+    int parsedOffset = 0;\n+    int newPos = position;\n+    int length = text.length();\n+\n+    if (zone instanceof FixedDateTimeZone) {\n+        parsedOffset = zone.getOffset(instantMillis);\n+    }\n+\n+    while (newPos < length) {\n+        char c = text.charAt(newPos);\n+        if (c == ' ' || c == '\\t') {\n+\n+        } else if ((c == '+' || c == '-') && (zone instanceof CachedDateTimeZone || zone instanceof DefaultDateTimeZone || zone instanceof FixedDateTimeZone)) {\n+            // Handle sign character like 'Z' or '+00:00'\n+            OffsetDateTimeParser offsetParser = new OffsetDateTimeParser();\n+            newPos = offsetParser.parseInto(bucket, text, newPos);\n+            parsedOffset = bucket.getOffsetInteger();\n+            if (parsedOffset != null) {\n+                parsedOffset = parsedOffset.intValue();\n+            }\n+        } else if (c == 'Z' && (zone instanceof CachedDateTimeZone || zone instanceof DefaultDateTimeZone)) {\n+            // Handle Z character like \"+00:00\"\n+            int offset = 0;\n+            if (instantMillis >= Long.MAX_VALUE - FixedDateTimeZone.UTC_TOTAL_MILLIS ||\n+                    instantMillis <= Long.MIN_VALUE + FixedDateTimeZone.UTC_TOTAL_MILLIS) {\n+                // Handle cases where adding or subtracting FixedDateTimeZone.UTC_TOTAL_MILLIS could overflow the long\n+                offset = FixedDateTimeZone.UTC_TOTAL_MILLIS - zone.getOffset(instantMillis);\n+            } else {\n+                offset = (int) (FixedDateTimeZone.UTC_TOTAL_MILLIS + (instantMillis - zone.getOffset(instantMillis)));\n+            }\n+            parsedOffset = offset;\n+            newPos++;\n+        } else {\n+            if (!(zone instanceof CachedDateTimeZone)) {\n+                break;\n+            }\n+\n+            // If we're in a CachedDateTimeZone, we need to parse the offset manually in order to correctly handle DST transitions\n+            boolean offsetParsed = parseOffset(text, newPos, bucket);\n+            int parsedOffsetFromParsing = bucket.getOffsetInteger();\n+            if (offsetParsed && parsedOffsetFromParsing != null) {\n+                parsedOffset = parsedOffsetFromParsing.intValue();\n+            }\n+            newPos = bucket.getSavePos();\n         }\n-        \n-        long instantMillis = instant.getMillis();\n-        Chronology chrono = instant.getChronology();\n-        long instantLocal = instantMillis + chrono.getZone().getOffset(instantMillis);\n+    }\n+\n+    if (instantMillis == DateTimeUtils.MILLIS_PER_DAY && parsedOffset == 0 && (zone instanceof CachedDateTimeZone || zone instanceof DefaultDateTimeZone)) {\n+        // Handle special case where the input is \"24:00\" or \"00:00\", which may be represented as midnight in a local time zone\n+        instantMillis -= parsedOffset;\n+        bucket.saveField(DateTimeFieldType.dayOfMonth(), 1);\n+    } else if (!(zone instanceof FixedDateTimeZone)) {\n+        // If we're not in a FixedDateTimeZone, then we need to parse the input date and adjust the time zone offset as necessary\n+        instantMillis = instantMillis + zone.getOffset(instantMillis);\n         chrono = selectChronology(chrono);\n-        int defaultYear = chrono.year().get(instantLocal);\n-        \n+        int defaultYear = chrono.year().get(instantMillis);\n+\n         DateTimeParserBucket bucket = new DateTimeParserBucket(\n-            instantLocal, chrono, iLocale, iPivotYear, defaultYear);\n-        int newPos = parser.parseInto(bucket, text, position);\n-        instant.setMillis(bucket.computeMillis(false, text));\n-        if (iOffsetParsed && bucket.getOffsetInteger() != null) {\n-            int parsedOffset = bucket.getOffsetInteger();\n-            DateTimeZone parsedZone = DateTimeZone.forOffsetMillis(parsedOffset);\n-            chrono = chrono.withZone(parsedZone);\n+                instantMillis, chrono, iLocale, iPivotYear, defaultYear);\n+        newPos = parser.parseInto(bucket, text, newPos);\n+\n+        if (bucket.getOffsetInteger() != null) {\n+            parsedOffset = bucket.getOffsetInteger().intValue();\n+            chrono = chrono.withZone(DateTimeZone.forOffsetMillis(parsedOffset));\n         } else if (bucket.getZone() != null) {\n             chrono = chrono.withZone(bucket.getZone());\n+        } else {\n+            int offset = chrono.getZone().getOffset(instantMillis);\n+            chrono = selectChronology(chrono.withZone(DateTimeZone.forOffsetMillis(offset)));\n         }\n         instant.setChronology(chrono);\n-        if (iZone != null) {\n-            instant.setZone(iZone);\n-        }\n-        return newPos;\n+        instantMillis = chrono.getZone().adjustOffset(instantMillis - parsedOffset, false);\n+        instant.setMillis(instantMillis);\n+    } else {\n+        instant.setMillis(instantMillis - parsedOffset);\n+    }\n+\n+    if (iZone != null) {\n+        instant.setZone(iZone);\n+    }\n+    return newPos;\n+}\n+\n+private boolean parseOffset(String text, int position, DateTimeParserBucket bucket) {\n+    // If we can't parse an offset, we end up using the original zone offset instead\n+    int length = text.length();\n+    if (position >= length || (text.charAt(position) != '+' && text.charAt(position) != '-')) {\n+        return false;\n     }\n \n+    int sign = (text.charAt(position) == '+') ? 1 : -1;\n+    position++;\n+\n+    int hours = 0;\n+    int minutes = 0;\n+    int seconds = 0;\n+    boolean colon1Found = false;\n+    boolean colon2Found = false;\n+\n+    if (!isDigit(text.charAt(position))) {\n+        return false;\n+    }\n+    hours = text.charAt(position) - '0';\n+    position++;\n+\n+    if (isDigit(text.charAt(position))) {\n+        hours = hours * 10 + (text.charAt(position) - '0');\n+        position++;\n+    }\n+\n+    if (hours >= 24) {\n+        return false;\n+    }\n+\n+    if (position >= length) {\n+        bucket.setOffset((-1 * sign) * (hours * 60 * 60 * 1000));\n+        return true;\n+    }\n+\n+    if (text.charAt(position) == ':') {\n+        colon1Found = true;\n+        position++;\n+    }\n+\n+    if (position + 1 < length && isDigit(text.charAt(position)) && isDigit(text.charAt(position + 1))) {\n+        minutes = (text.charAt(position) - '0') * 10 + (text.charAt(position + 1) - '0');\n+        position += 2;\n+    } else if (isDigit(text.charAt(position))) {\n+        minutes = text.charAt(position) - '0';\n+        position++;\n+    }\n+\n+    if (minutes >= 60) {\n+        return false;\n+    }\n+\n+    if (position >= length) {\n+        bucket.setOffset((-1 * sign) * ((hours * 60 * 60 * 1000) + (minutes * 60 * 1000)));\n+        return true;\n+    }\n+\n+    if (text.charAt(position) == ':') {\n+        colon2Found = true;\n+        position++;\n+    }\n+\n+    if (colon1Found && colon2Found && isDigit(text.charAt(position)) && isDigit(text.charAt(position + 1))) {\n+        seconds = (text.charAt(position) - '0') * 10 + (text.charAt(position + 1) - '0');\n+        position += 2;\n+    } else if (isDigit(text.charAt(position))) {\n+        seconds = text.charAt(position) - '0';\n+        position++;\n+    }\n+\n+    if (seconds >= 60) {\n+        return false;\n+    }\n+\n+    bucket.setOffset((-1 * sign) * ((hours * 60 * 60 * 1000) + (minutes * 60 * 1000) + (seconds * 1000)));\n+    return true;\n+}\n+\n+private boolean isDigit(char c) {\n+    return c >= '0' && c <= '9';\n+}\n+\n     /**\n      * Parses a datetime from the given text, returning the number of\n      * milliseconds since the epoch, 1970-01-01T00:00:00Z.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}