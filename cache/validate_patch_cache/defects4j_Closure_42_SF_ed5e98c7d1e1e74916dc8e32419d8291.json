{
    "patch": "class TransformDispatcher extends IRFactory.TransformVisitor {\n\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n  private static final Set<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\");\n\n  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  private boolean isDirective(AstNode n) {\n    if (!(n instanceof ExpressionStatement)) {\n      return false;\n    }\n\n    Expression expr = ((ExpressionStatement) n).getExpression();\n    if (!(expr instanceof StringLiteral)) {\n      return false;\n    }\n\n    String strValue = ((StringLiteral) expr).getValue();\n    if (strValue == null) {\n      return false;\n    }\n\n    return ALLOWED_DIRECTIVES.contains(strValue);\n  }\n\n  void process(Node node) {\n    // Let Node transform itself and all its children.\n    node = NodeTransformer.transform(this, node);\n  \n    // Detect directives at the beginning of scripts or functions\n    // and turn them into statements that can be transformed.\n    if (isDirective(node)) {\n      node.setType(Token.EXPR_RESULT);\n    }\n  }\n  \n  @Override\n  Node processArrayComprehension(ArrayComprehension node) {\n    Node result = newNode(Token.ARRAYLIT);\n    for (ArrayComprehensionLoop acl : node.getLoops()) {\n      AstNode iter = acl.getIterator();\n      AstNode iteratedObject = acl.getIteratedObject();\n\n      if (isDirective(iteratedObject)) {\n        errorReporter.error(\n            \"For-in statement may not have an initializer\",\n            sourceName,\n            iteratedObject.getLineno(), \"\", 0);\n      }\n\n      Node object = transform(iteratedObject);\n      Node init;\n      if (acl.isForEach()) {\n        // lhs is the VarDecl\n        init = newNode(Token.VAR);\n        init.addChildToBack(transform(iter));\n        // For each, don't add TARGETs.\n      } else {\n        // lhs is the target\n        init = transform(iter);\n      }\n\n      Node loop = newNode(Token.FOR);\n      if (acl.getLabel() != null) {\n        loop.addChildToBack(transform(acl.getLabel()));\n      }\n      loop.addChildToBack(init);\n      loop.addChildToBack(object);\n      loop.addChildToBack(transformBlock(acl.getBody()));\n      result.addChildToBack(loop.getFirstChild().getNext().detachFromParent());\n    }\n\n    if (node.getFilter() != null) {\n      Node filterFunc = newNode(Token.FUNCTION);\n      Node formals = newNode(Token.PARAM_LIST);\n      AstNode param = newName(\"_COMPRES_FILTER\");\n      formals.addChildToBack(transform(param));\n\n      filterFunc.addChildToBack(formals);\n\n      Block filterBlock = new Block();\n      // Add a return statement to the filter code to ensure that\n      // the filter function returns a value.\n      filterBlock.addChildToFront(\n          new ReturnStatement(-1, transform(node.getFilter())));\n\n      // transform the filterBlock in its own scope\n      filterFunc.addChildToBack(transform(filterBlock));\n\n      Node callNode = newNode(Token.CALL);\n      callNode.addChildToBack(filterFunc);\n\n      Node arrayComprNode = newNode(Token.ARRAY_COMP);\n      arrayComprNode.addChildToBack(result);\n      arrayComprNode.addChildToBack(Node.newString(Token.NAME, \"filter\"));\n      arrayComprNode.addChildToBack(callNode);\n\n      result = arrayComprNode;\n    }\n\n    return result;\n  }\n\n  @Override\n  Node processObjectComprehension(ObjectComprehension node) {\n    Node init = newNode(Token.OBJECTLIT);\n    if (node.getFilter() != null) {\n      errorReporter.error(\n          \"filters not supported for object comprehensions\",\n          sourceName,\n          node.getFilter().getLineno(), \"\", 0);\n    }\n    for (ObjectProperty op : node.getElements()) {\n      init.addChildToBack(transform(op));\n    }\n\n    AstNode iter = node.getIterator();\n    AstNode iteratedObject = node.getIteratedObject();\n\n    if (isDirective(iteratedObject)) {\n      errorReporter.error(\n          \"For-in statement may not have an initializer\",\n          sourceName,\n          iteratedObject.getLineno(), \"\", 0);\n    }\n\n    Node object = transform(iteratedObject);\n\n    Node loop = newNode(Token.FOR);\n    loop.addChildToBack(transform(iter));\n    loop.addChildToBack(object);\n    loop.addChildToBack(init);\n\n    Node arrayCompNode = newNode(Token.ARRAY_COMP);\n    arrayCompNode.addChildToBack(loop);\n\n    return arrayCompNode;\n  }\n\n  private static boolean isArrayAccess(AstNode n) {\n    return n instanceof ElementGet &&\n        ((ElementGet)n).getTarget() instanceof Name &&\n        ((Name) ((ElementGet)n).getTarget()).getIdentifier().equals(\"Array\");\n  }\n\n  private static boolean isArrayLengthAccess(AstNode n) {\n    return n instanceof PropertyGet &&\n        ((PropertyGet)n).getLeft() instanceof Name &&\n        ((Name) ((PropertyGet)n).getLeft()).getIdentifier().equals(\"Array\") &&\n        ((PropertyGet)n).getRight().getIdentifier().equals(\"length\");\n  }\n\n  @Override\n  Node processFunction(FunctionNode functionNode) {\n    if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION &&\n        functionNode.getBase() == null) {\n      // turn (function(){...})() into (function(){...}).call(this);\n      Block block = functionNode.getEnclosingFunction().getBody();\n      int index = NodeUtil.getEnclosingChangeScopeDepth(functionNode) -\n          NodeUtil.getEnclosingChangeScopeDepth(block);\n      Node callNode = NodeUtil.newCallNode(\n          transform(functionNode), block.getChangeMark(), index);\n      return callNode;\n    }\n\n    return super.processFunction(functionNode);\n  }\n\n  @Override\n  Node processInfixExpression(InfixExpression node) {\n    if (node.getType() == Token.GETPROP &&\n        isArrayAccess(node.getLeft())) {\n      Node arrayNode = newNode(Token.ARRAYLIT);\n      for (AstNode n = node.getRight(); n != null; n = n.getNext()) {\n        arrayNode.addChildToBack(transform(n));\n      }\n\n      return newNode(\n          Token.CALL,\n          newNode(\n              Token.GETELEM,\n              newNode(Token.NAME, \"Array\"),\n              newNode(\n                  Token.STRING,\n                  Integer.toString(arrayNode.getChildCount()))),\n          arrayNode);\n    } else if (node.getType() == Token.GETPROP &&\n        isArrayLengthAccess(node)) {\n      return newNode(\n          Token.GETPROP,\n          transform(node.getLeft()),\n          newNode(Token.STRING, \"length\"));\n    }\n\n    return super.processInfixExpression(node);\n  }\n\n  @Override\n  Node processName(Name name) {\n    String identifier = name.getIdentifier();\n    if (identifier.equals(\"undefined\")) {\n      return newNode(Token.VOID);\n    }\n\n    Node newNode = super.processName(name);\n    if (name.getParent() instanceof Scope && name.getParent() != newNode.getParent()) {\n      Scope scope = (Scope) name.getParent();\n      if (scope.getClosestHoistScope().getParentScope().hasSymbol(identifier)) {\n        newNode.setType(Token.THIS);\n        return newNode;\n      }\n    }\n\n    return newNode;\n  }\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..80e3d57d 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,228 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher extends IRFactory.TransformVisitor {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+  private static final Set<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\");\n+\n+  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n+\n+  private boolean isDirective(AstNode n) {\n+    if (!(n instanceof ExpressionStatement)) {\n+      return false;\n     }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+    Expression expr = ((ExpressionStatement) n).getExpression();\n+    if (!(expr instanceof StringLiteral)) {\n+      return false;\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    String strValue = ((StringLiteral) expr).getValue();\n+    if (strValue == null) {\n+      return false;\n     }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n+    return ALLOWED_DIRECTIVES.contains(strValue);\n+  }\n+\n+  void process(Node node) {\n+    // Let Node transform itself and all its children.\n+    node = NodeTransformer.transform(this, node);\n+  \n+    // Detect directives at the beginning of scripts or functions\n+    // and turn them into statements that can be transformed.\n+    if (isDirective(node)) {\n+      node.setType(Token.EXPR_RESULT);\n+    }\n+  }\n+  \n+  @Override\n+  Node processArrayComprehension(ArrayComprehension node) {\n+    Node result = newNode(Token.ARRAYLIT);\n+    for (ArrayComprehensionLoop acl : node.getLoops()) {\n+      AstNode iter = acl.getIterator();\n+      AstNode iteratedObject = acl.getIteratedObject();\n+\n+      if (isDirective(iteratedObject)) {\n         errorReporter.error(\n-            \"Catch clauses are not supported\",\n+            \"For-in statement may not have an initializer\",\n             sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+            iteratedObject.getLineno(), \"\", 0);\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n-    }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n-    }\n+      Node object = transform(iteratedObject);\n+      Node init;\n+      if (acl.isForEach()) {\n+        // lhs is the VarDecl\n+        init = newNode(Token.VAR);\n+        init.addChildToBack(transform(iter));\n+        // For each, don't add TARGETs.\n+      } else {\n+        // lhs is the target\n+        init = transform(iter);\n+      }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+      Node loop = newNode(Token.FOR);\n+      if (acl.getLabel() != null) {\n+        loop.addChildToBack(transform(acl.getLabel()));\n       }\n-      return node;\n+      loop.addChildToBack(init);\n+      loop.addChildToBack(object);\n+      loop.addChildToBack(transformBlock(acl.getBody()));\n+      result.addChildToBack(loop.getFirstChild().getNext().detachFromParent());\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    if (node.getFilter() != null) {\n+      Node filterFunc = newNode(Token.FUNCTION);\n+      Node formals = newNode(Token.PARAM_LIST);\n+      AstNode param = newName(\"_COMPRES_FILTER\");\n+      formals.addChildToBack(transform(param));\n+\n+      filterFunc.addChildToBack(formals);\n+\n+      Block filterBlock = new Block();\n+      // Add a return statement to the filter code to ensure that\n+      // the filter function returns a value.\n+      filterBlock.addChildToFront(\n+          new ReturnStatement(-1, transform(node.getFilter())));\n+\n+      // transform the filterBlock in its own scope\n+      filterFunc.addChildToBack(transform(filterBlock));\n+\n+      Node callNode = newNode(Token.CALL);\n+      callNode.addChildToBack(filterFunc);\n+\n+      Node arrayComprNode = newNode(Token.ARRAY_COMP);\n+      arrayComprNode.addChildToBack(result);\n+      arrayComprNode.addChildToBack(Node.newString(Token.NAME, \"filter\"));\n+      arrayComprNode.addChildToBack(callNode);\n+\n+      result = arrayComprNode;\n     }\n \n-    @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    return result;\n+  }\n+\n+  @Override\n+  Node processObjectComprehension(ObjectComprehension node) {\n+    Node init = newNode(Token.OBJECTLIT);\n+    if (node.getFilter() != null) {\n+      errorReporter.error(\n+          \"filters not supported for object comprehensions\",\n+          sourceName,\n+          node.getFilter().getLineno(), \"\", 0);\n+    }\n+    for (ObjectProperty op : node.getElements()) {\n+      init.addChildToBack(transform(op));\n     }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    AstNode iter = node.getIterator();\n+    AstNode iteratedObject = node.getIteratedObject();\n+\n+    if (isDirective(iteratedObject)) {\n+      errorReporter.error(\n+          \"For-in statement may not have an initializer\",\n+          sourceName,\n+          iteratedObject.getLineno(), \"\", 0);\n     }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    Node object = transform(iteratedObject);\n+\n+    Node loop = newNode(Token.FOR);\n+    loop.addChildToBack(transform(iter));\n+    loop.addChildToBack(object);\n+    loop.addChildToBack(init);\n+\n+    Node arrayCompNode = newNode(Token.ARRAY_COMP);\n+    arrayCompNode.addChildToBack(loop);\n+\n+    return arrayCompNode;\n+  }\n+\n+  private static boolean isArrayAccess(AstNode n) {\n+    return n instanceof ElementGet &&\n+        ((ElementGet)n).getTarget() instanceof Name &&\n+        ((Name) ((ElementGet)n).getTarget()).getIdentifier().equals(\"Array\");\n+  }\n+\n+  private static boolean isArrayLengthAccess(AstNode n) {\n+    return n instanceof PropertyGet &&\n+        ((PropertyGet)n).getLeft() instanceof Name &&\n+        ((Name) ((PropertyGet)n).getLeft()).getIdentifier().equals(\"Array\") &&\n+        ((PropertyGet)n).getRight().getIdentifier().equals(\"length\");\n+  }\n+\n+  @Override\n+  Node processFunction(FunctionNode functionNode) {\n+    if (functionNode.getFunctionType() == FunctionNode.FUNCTION_EXPRESSION &&\n+        functionNode.getBase() == null) {\n+      // turn (function(){...})() into (function(){...}).call(this);\n+      Block block = functionNode.getEnclosingFunction().getBody();\n+      int index = NodeUtil.getEnclosingChangeScopeDepth(functionNode) -\n+          NodeUtil.getEnclosingChangeScopeDepth(block);\n+      Node callNode = NodeUtil.newCallNode(\n+          transform(functionNode), block.getChangeMark(), index);\n+      return callNode;\n     }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    return super.processFunction(functionNode);\n+  }\n+\n+  @Override\n+  Node processInfixExpression(InfixExpression node) {\n+    if (node.getType() == Token.GETPROP &&\n+        isArrayAccess(node.getLeft())) {\n+      Node arrayNode = newNode(Token.ARRAYLIT);\n+      for (AstNode n = node.getRight(); n != null; n = n.getNext()) {\n+        arrayNode.addChildToBack(transform(n));\n+      }\n \n-        // Return the bare minimum to put the AST in a valid state.\n       return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+          Token.CALL,\n+          newNode(\n+              Token.GETELEM,\n+              newNode(Token.NAME, \"Array\"),\n+              newNode(\n+                  Token.STRING,\n+                  Integer.toString(arrayNode.getChildCount()))),\n+          arrayNode);\n+    } else if (node.getType() == Token.GETPROP &&\n+        isArrayLengthAccess(node)) {\n+      return newNode(\n+          Token.GETPROP,\n+          transform(node.getLeft()),\n+          newNode(Token.STRING, \"length\"));\n+    }\n+\n+    return super.processInfixExpression(node);\n+  }\n+\n+  @Override\n+  Node processName(Name name) {\n+    String identifier = name.getIdentifier();\n+    if (identifier.equals(\"undefined\")) {\n+      return newNode(Token.VOID);\n     }\n \n+    Node newNode = super.processName(name);\n+    if (name.getParent() instanceof Scope && name.getParent() != newNode.getParent()) {\n+      Scope scope = (Scope) name.getParent();\n+      if (scope.getClosestHoistScope().getParentScope().hasSymbol(identifier)) {\n+        newNode.setType(Token.THIS);\n+        return newNode;\n+      }\n+    }\n+\n+    return newNode;\n+  }\n+}\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: class IRFactory.TransformDispatcher is already defined in class IRFactory",
    "test_result": "ERROR"
}