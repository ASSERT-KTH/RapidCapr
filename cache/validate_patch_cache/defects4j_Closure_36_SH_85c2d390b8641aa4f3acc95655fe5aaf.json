{
    "patch": "      Node callParent = reference.getParent();\n      if (reference.isPropertyInitializedName()) {\n        // it's an object literal key value, so the value might be an external function\n        boolean isClassMember = value.getParent().isClassMembers();\n        if (isClassMember) {\n          return false;\n        }\n\n        // object literal key value is a call : treat like any other function caller\n        if (callParent != null && callParent.isCall()) {\n          if (!compiler.getCodingConvention().isCallToPolyfill(callParent)) {\n            return false;\n          }\n        }\n        Node object = callParent.getFirstChild();\n        if (object.getLastChild() == reference.getNode()) {\n          // call is being made as a method\n          if (!object.getFirstChild().isThis()) {\n            // methods can only be inlined if called from 'this'\n            return false;\n          }\n        }\n      } else {\n        boolean externOrName = NodeUtil.isExpressionResultUsed(reference);\n        if (externOrName && NodeUtil.isExpressionResultUsed(initialization)) {\n          // TODO we can inline if it's no-op.\n          return false;\n        }\n        if (value.hasChildren() && value.getFirstChild().isAssign()) {\n          // it's a chained assign, e.g. a=b=c;\n          return false;\n        }\n        Node block = reference.getBasicBlock();\n        if (block == null) {\n          // This isn't the best thing, let's continue to be conservative\n          return false;\n        }\n        if (value.isObjectLit()\n            && value.hasChildren()\n            && value.getFirstChild().isComputedProp()) {\n          // is an object literal a property that's computed with variable,\n          // meaning get or set might have side effects\n          if (reference.isLhsOfAssign() && !isSafeEnumKey(reference.getParent())) {\n            return false;\n          } else if (callParent != null && callParent.isCall()) {\n            // can't make this call inlineable\n            return false;\n          }\n        }\n      }\n\n      return canMoveAggressively(value)\n          || canMoveFromBlock(initialization, reference)\n          || canMoveFromConditional(initialization, reference)\n          || canMoveFromStatement(initialization, reference);\n    }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/InlineVariables.java b/src/com/google/javascript/jscomp/InlineVariables.java\nindex 0b4b3ded..114d247b 100644\n--- a/src/com/google/javascript/jscomp/InlineVariables.java\n+++ b/src/com/google/javascript/jscomp/InlineVariables.java\n@@ -572,6 +572,62 @@ class InlineVariables implements CompilerPass {\n \n           // issue 668: Don't inline singleton getter methods\n           // calls as this confused class removing logic.\n+      Node callParent = reference.getParent();\n+      if (reference.isPropertyInitializedName()) {\n+        // it's an object literal key value, so the value might be an external function\n+        boolean isClassMember = value.getParent().isClassMembers();\n+        if (isClassMember) {\n+          return false;\n+        }\n+\n+        // object literal key value is a call : treat like any other function caller\n+        if (callParent != null && callParent.isCall()) {\n+          if (!compiler.getCodingConvention().isCallToPolyfill(callParent)) {\n+            return false;\n+          }\n+        }\n+        Node object = callParent.getFirstChild();\n+        if (object.getLastChild() == reference.getNode()) {\n+          // call is being made as a method\n+          if (!object.getFirstChild().isThis()) {\n+            // methods can only be inlined if called from 'this'\n+            return false;\n+          }\n+        }\n+      } else {\n+        boolean externOrName = NodeUtil.isExpressionResultUsed(reference);\n+        if (externOrName && NodeUtil.isExpressionResultUsed(initialization)) {\n+          // TODO we can inline if it's no-op.\n+          return false;\n+        }\n+        if (value.hasChildren() && value.getFirstChild().isAssign()) {\n+          // it's a chained assign, e.g. a=b=c;\n+          return false;\n+        }\n+        Node block = reference.getBasicBlock();\n+        if (block == null) {\n+          // This isn't the best thing, let's continue to be conservative\n+          return false;\n+        }\n+        if (value.isObjectLit()\n+            && value.hasChildren()\n+            && value.getFirstChild().isComputedProp()) {\n+          // is an object literal a property that's computed with variable,\n+          // meaning get or set might have side effects\n+          if (reference.isLhsOfAssign() && !isSafeEnumKey(reference.getParent())) {\n+            return false;\n+          } else if (callParent != null && callParent.isCall()) {\n+            // can't make this call inlineable\n+            return false;\n+          }\n+        }\n+      }\n+\n+      return canMoveAggressively(value)\n+          || canMoveFromBlock(initialization, reference)\n+          || canMoveFromConditional(initialization, reference)\n+          || canMoveFromStatement(initialization, reference);\n+    }\n         }\n       }\n ",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}