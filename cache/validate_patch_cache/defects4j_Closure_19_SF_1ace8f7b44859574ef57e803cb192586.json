{
    "patch": "protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n    switch (node.getType()) {\n      case Token.NAME:\n        scope.inferSlotType(node.getString(), type);\n        break;\n\n      case Token.GETPROP:\n        String qualifiedName = node.getQualifiedName();\n        Preconditions.checkNotNull(qualifiedName);\n\n        JSType origType = node.getJSType();\n        origType = origType == null ? getNativeType(UNKNOWN_TYPE) : origType;\n        scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n        break;\n\n      case Token.THIS:\n        // Infer the type of \"this\" to be the current scope's \"this\" type, if it has one\n        JSType thisType = scope.getTypeOfThis();\n        if (thisType != null) {\n          scope.inferSlotType(\"this\", thisType);\n        }\n        break;\n\n      case Token.FUNCTION:\n        Node fnNameNode = node.getFirstChild();\n        if (fnNameNode != null && fnNameNode.getType() == Token.NAME) {\n          String fnName = fnNameNode.getString();\n          if (!fnName.isEmpty() && !fnName.equals(UNKNOWN_TYPE)) {\n            scope.inferSlotType(fnName, type);\n          }\n        }\n        break;\n\n      default:\n        throw new IllegalArgumentException(\"Invalid node type: \" + node.getType()\n            + \"\\n\" + node.toStringTree());",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\nindex 0345c855..55d087aa 100644\n--- a/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n+++ b/src/com/google/javascript/jscomp/type/ChainableReverseAbstractInterpreter.java\n@@ -154,7 +154,7 @@ public abstract class ChainableReverseAbstractInterpreter\n    * {@code node}. It must be possible to refine the type of the given node in\n    * the given scope, as determined by {@link #getTypeIfRefinable}.\n    */\n-  protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n+protected void declareNameInScope(FlowScope scope, Node node, JSType type) {\n     switch (node.getType()) {\n       case Token.NAME:\n         scope.inferSlotType(node.getString(), type);\n@@ -169,13 +169,27 @@ public abstract class ChainableReverseAbstractInterpreter\n         scope.inferQualifiedSlot(node, qualifiedName, origType, type);\n         break;\n \n-        // \"this\" references aren't currently modeled in the CFG.\n+      case Token.THIS:\n+        // Infer the type of \"this\" to be the current scope's \"this\" type, if it has one\n+        JSType thisType = scope.getTypeOfThis();\n+        if (thisType != null) {\n+          scope.inferSlotType(\"this\", thisType);\n+        }\n+        break;\n+\n+      case Token.FUNCTION:\n+        Node fnNameNode = node.getFirstChild();\n+        if (fnNameNode != null && fnNameNode.getType() == Token.NAME) {\n+          String fnName = fnNameNode.getString();\n+          if (!fnName.isEmpty() && !fnName.equals(UNKNOWN_TYPE)) {\n+            scope.inferSlotType(fnName, type);\n+          }\n+        }\n+        break;\n \n       default:\n-        throw new IllegalArgumentException(\"Node cannot be refined. \\n\" +\n-            node.toStringTree());\n-    }\n-  }\n+        throw new IllegalArgumentException(\"Invalid node type: \" + node.getType()\n+            + \"\\n\" + node.toStringTree());\n \n   /**\n    * @see #getRestrictedWithoutUndefined(JSType)",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}