{
    "patch": "              // check LHS makes sense to inline (may be a getter)\n              // and LHS does not affect mutable state\n              Node lhsValue = lhs.getFirstChild();\n              if (lhsValue != null &&\n                  !NodeUtil.isGet(lhs) &&\n                  !mayEffectMutableState(lhsValue)) {",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\nindex ae568e8e..31887bca 100644\n--- a/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n+++ b/src/com/google/javascript/jscomp/PeepholeSubstituteAlternateSyntax.java\n@@ -779,7 +779,12 @@ class PeepholeSubstituteAlternateSyntax\n               // evaluates LHS before cond]\n               // NOTE - there are some circumstances where we can\n               // proceed even if there are side effects...\n-              !mayEffectMutableState(lhs)) {\n+              // check LHS makes sense to inline (may be a getter)\n+              // and LHS does not affect mutable state\n+              Node lhsValue = lhs.getFirstChild();\n+              if (lhsValue != null &&\n+                  !NodeUtil.isGet(lhs) &&\n+                  !mayEffectMutableState(lhsValue)) {\n \n             n.removeChild(cond);\n             Node assignName = thenOp.removeFirstChild();",
    "result_reason": "error: ')' expected",
    "test_result": "ERROR"
}