{
    "patch": "public class IRFactory {\n\n  private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\");\n\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n\n  public IRFactory(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  private Node newNode(int type, @Nullable Node firstChild, @Nullable Node secondChild) {\n    Node node = new Node(type);\n    if (firstChild != null) {\n      node.addChildToBack(firstChild);\n    }\n    if (secondChild != null) {\n      node.addChildToBack(secondChild);\n    }\n    return node;\n  }\n\n  private Node newNode(int type, Node firstChild, Node secondChild, Node thirdChild) {\n    Node node = new Node(type);\n    node.addChildToBack(firstChild);\n    node.addChildToBack(secondChild);\n    node.addChildToBack(thirdChild);\n    return node;\n  }\n\n  private Node newNode(int type, Node firstChild, Node secondChild, Node thirdChild, Node fourthChild) {\n    Node node = new Node(type);\n    node.addChildToBack(firstChild);\n    node.addChildToBack(secondChild);\n    node.addChildToBack(thirdChild);\n    node.addChildToBack(fourthChild);\n    return node;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) {\n      return false;\n    }\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT && n.getFirstChild().isString()\n        && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  private Node transform(AstNode node) {\n    return node == null ? null : node.accept(new TransformDispatcher());\n  }\n\n  private Node transformBlock(Block blockNode) {\n    List<Node> statementNodes = transformStatements(blockNode.getStatements());\n    if (statementNodes.size() == 1) {\n      return statementNodes.get(0);\n    }\n    return newNode(Token.BLOCK, statementNodes.get(0), statementNodes.get(1));\n  }\n\n  private List<Node> transformStatements(List<AstNode> nodes) {\n    return transformNodes(nodes, true);\n  }\n\n  private List<Node> transformNodes(List<AstNode> nodes, boolean allowDirectives) {\n    List<Node> result = new ArrayList<>();\n    for (AstNode n : nodes) {\n      if (!allowDirectives && isDirective(n)) {\n        throw new RuntimeException(\"Directive node not allowed here\");\n      }\n      result.add(transform(n));\n    }\n    return result;\n  }\n\n  abstract class TypeSafeDispatcher implements NodeVisitor<Node> {\n    @Override\n    public Node visit(AstNode node) {\n      throw new RuntimeException(\"Unexpected node type: \" + node.getClass().getSimpleName());\n    }\n\n    @Override\n    public Node visit(Assignment node) {\n      return newNode(\n          Token.ASSIGN,\n          transform(node.getLeft()),\n          transform(node.getRight()));\n    }\n\n    @Override\n    public Node visit(Block node) {\n      return processBlock(node);\n    }\n\n    @Override\n    public Node visit(BreakStatement node) {\n      return processBreakStatement(node);\n    }\n\n    @Override\n    public Node visit(CatchClause node) {\n      return processCatchClause(node);\n    }\n\n    @Override\n    public Node visit(ConditionalExpression node) {\n      return processConditionalExpression(node);\n    }\n\n    @Override\n    public Node visit(ContinueStatement node) {\n      return processContinueStatement(node);\n    }\n\n    @Override\n    public Node visit(DoLoop node) {\n      return processDoLoop(node);\n    }\n\n    @Override\n    public Node visit(ElementGet node) {\n      return processElementGet(node);\n    }\n\n    @Override\n    public Node visit(EmptyExpression node) {\n      return processEmptyExpression(node);\n    }\n\n    public Node visit(ExpressionStatement node) {\n      return processExpressionStatement(node);\n    }\n\n    @Override\n    public Node visit(ForInLoop node) {\n      return processForInLoop(node);\n    }\n\n    @Override\n    public Node visit(ForLoop node) {\n      return processForLoop(node);\n    }\n\n    @Override\n    public Node visit(FunctionNode node) {\n      return processFunction(node);\n    }\n\n    @Override\n    public Node visit(IfStatement node) {\n      return processIfStatement(node);\n    }\n\n    @Override\n    public Node visit(InfixExpression node) {\n      return processInfixExpression(node);\n    }\n\n    @Override\n    public Node visit(LabeledStatement node) {\n      return processLabeledStatement(node);\n    }\n\n    @Override\n    public Node visit(Name node) {\n      return processName(node);\n    }\n\n    @Override\n    public Node visit(NewExpression node) {\n      return processNewExpression(node);\n    }\n\n    @Override\n    public Node visit(NumberLiteral node) {\n      return processNumberLiteral(node);\n    }\n\n    @Override\n    public Node visit(ObjectLiteral node) {\n      return processObjectLiteral(node);\n    }\n\n    @Override\n    public Node visit(ParenthesizedExpression node) {\n      return processParenthesizedExpression(node);\n    }\n\n    @Override\n    public Node visit(PropertyGet node) {\n      return processPropertyGet(node);\n    }\n\n    @Override\n    public Node visit(ReturnStatement node) {\n      return processReturnStatement(node);\n    }\n\n    @Override\n    public Node visit(StringLiteral node) {\n      return processStringLiteral(node);\n    }\n\n    @Override\n    public Node visit(SwitchCase node) {\n      return processSwitchCase(node);\n    }\n\n    @Override\n    public Node visit(SwitchStatement node) {\n      return processSwitchStatement(node);\n    }\n\n    @Override\n    public Node visit(ThrowStatement node) {\n      return processThrowStatement(node);\n    }\n\n    @Override\n    public Node visit(TryStatement node) {\n      return processTryStatement(node);\n    }\n\n    @Override\n    public Node visit(UnaryExpression node) {\n      return processUnaryExpression(node);\n    }\n\n    @Override\n    public Node visit(VariableDeclaration node) {\n      return processVariableDeclaration(node);\n    }\n\n    @Override\n    public Node visit(VariableInitializer node) {\n      return processVariableInitializer(node);\n    }\n\n    @Override\n    public Node visit(WhileLoop node) {\n      return processWhileLoop(node);\n    }\n\n    @Override\n    public Node visit(WithStatement node) {\n      return processWithStatement(node);\n    }\n  }\n\n  class TransformDispatcher extends TypeSafeDispatcher {\n    @Override\n    public Node visit(AstNode node) {\n      return null;\n    }\n\n    @Override\n    public Node visit(ArrayLiteral node) {\n      return processArrayLiteral(node);\n    }\n\n    @Override\n    public Node visit(FunctionCall node) {\n      return processFunctionCall(node);\n    }\n\n    @Override\n    public Node visit(ObjectProperty node) {\n      return processObjectProperty(node);\n    }\n\n    @Override\n    public Node visit(ThisLiteral node) {\n      return processThisLiteral(node);\n    }\n\n    @Override\n    public Node visit(XmlNode node) {\n      throw new UnsupportedOperationException(\"XML literals are not supported\");\n    }\n\n    @Override\n    public Node visit(XmlString node) {\n      throw new UnsupportedOperationException(\"XML literals are not supported\");\n    }\n\n    @Override\n    public Node visit(InfixExpression node) {\n      return processInfixExpression(node);\n    }\n\n    @Override\n    public Node visit(NumberLiteral node) {\n      return processNumberLiteral(node);\n    }\n\n    @Override\n    public Node visit(StringLiteral node) {\n      return processStringLiteral(node);\n    }\n\n    @Override\n    public Node visit(Name node) {\n      return processName(node);\n    }\n\n    @Override\n    public Node visit(RegExpLiteral node) {\n      return processRegExpLiteral(node);\n    }\n\n    // The remaining methods are inherited from TypeSafeDispatcher and should be implemented as necessary\n  }\n\n  private Node processFunction(FunctionNode functionNode) {\n    Node function = newNode(Token.FUNCTION, transform(functionNode.getName()));\n    Node params = newNode(Token.PARAM_LIST);\n    for (AstNode p : functionNode.getParams()) {\n      params.addChildToBack(transform(p));\n    }\n    Node body = transform(functionNode.getBody());\n    function.addChildToBack(params);\n    function.addChildToBack(body);\n    return function;\n  }\n\n  private Node processArrayLiteral(ArrayLiteral arrayLiteral) {\n    return newNode(\n        Token.ARRAYLIT,\n        transformNodes(arrayLiteral.getElements(), false).toArray(new Node[0]));\n  }\n\n  private Node processBlock(Block blockNode) {\n    List<Node> statementNodes = transformStatements(blockNode.getStatements());\n    if (statementNodes.size() == 1) {\n      return statementNodes.get(0);\n    }\n    return newNode(Token.BLOCK, statementNodes.get(0), statementNodes.get(1));\n  }\n\n  private Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  private Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\n          \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(),\n          \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  private Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  private Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  private Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  private Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  private Node processEmptyExpression(EmptyExpression exprNode) {\n    return newNode(Token.EMPTY);\n  }\n\n  private Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(transformTokenType(statementNode.getType()));\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  private Node processForInLoop(ForInLoop loopNode) {\n    return newNode(\n        Token.FOR,\n        transform(loopNode.getIterator()),\n        transform(loopNode.getIteratedObject()),\n        transform(loopNode.getBody()));\n  }\n\n  private Node processForLoop(ForLoop loopNode) {\n    Node init = transform(loopNode.getInitializer());\n    Node condition = transform(loopNode.getCondition());\n    Node increment = transform(loopNode.getIncrement());\n    Node body = transform(loopNode.getBody());\n    if (init.getType() == Token.EMPTY) {\n      init = null;\n    }\n    if (condition.getType() == Token.EMPTY) {\n      condition = null;\n    }\n    if (increment.getType() == Token.EMPTY) {\n      increment = null;\n    }\n    return newNode(Token.FOR, init, condition, increment, body);\n  }\n\n  private Node processFunctionCall(FunctionCall callNode) {\n    return newNode(\n        Token.CALL,\n        transform(callNode.getTarget()).setInferredType(ObjectType.AnyType),\n        transformNodes(callNode.getArguments(), false).toArray(new Node[0]));\n  }\n\n  private Node processInfixExpression(InfixExpression infixNode) {\n    return newNode(\n        transformTokenType(infixNode.getType()),\n        transform(infixNode.getLeft()),\n        transform(infixNode.getRight()));\n  }\n\n  private Node processLabeledStatement(LabeledStatement labeledNode) {\n    Node node = newNode(Token.LABEL, transform(labeledNode.getStatementLabel()));\n    node.addChildToBack(transform(labeledNode.getStatement()));\n    return node;\n  }\n\n  private Node processName(Name nameNode) {\n    Node node = new Node(Token.NAME, nameNode.getString());\n    Scope s = nameNode.getScope();\n    if (s != null && !s.isGlobal()) {\n      node.putProp(Node.SYMBOL, s.getSymbolTable().get(nameNode.getIdentifier()));\n      node.setScope(s);\n    }\n    return node;\n  }\n\n  private Node processNewExpression(NewExpression newNode) {\n    return newNode(\n        Token.NEW,\n        transform(newNode.getTarget()).setInferredType(ObjectType.AnyType),\n        transformNodes(newNode.getArguments(), false).toArray(new Node[0]));\n  }\n\n  private Node processNumberLiteral(NumberLiteral numberNode) {\n    return newNode(Token.NUMBER, numberNode.getNumber());\n  }\n\n  private Node processObjectLiteral(ObjectLiteral objectNode) {\n    return newNode(\n        Token.OBJECTLIT,\n        transformNodes(objectNode.getElements(), false).toArray(new Node[0]));\n  }\n\n  private Node processObjectProperty(ObjectProperty objectProp) {\n    Node key = transform(objectProp.getLeft());\n    Node value = transform(objectProp.getRight());\n    // An object property with a `getprop` key is a shorthand function.\n    if (key.getType() == Token.STRING) {\n      String functionName = key.getString();\n      Node fnNode = transform(objectProp.getRight());\n      Node fnNameNode = new Node(Token.STRING, functionName);\n      Node propNode = new Node(Token.GETPROP, transform(objectProp.getLeft()), fnNameNode);\n      Node assignNode = new Node(Token.ASSIGN, propNode, fnNode);\n      assignNode.putBooleanProp(Node.SYNTHETIC_PROP, true);\n      return assignNode;\n    } else {\n      return newNode(Token.GETELEM, transform(objectProp.getLeft()), value);\n    }\n  }\n\n  private Node processParenthesizedExpression(ParenthesizedExpression node) {\n    Node result = transform(node.getExpression());\n    result.setIsParenthesizedExpr(true);\n    return result;\n  }\n\n  private Node processPropertyGet(PropertyGet getPropNode) {\n    return newNode(\n        Token.GETPROP,\n        transform(getPropNode.getTarget()),\n        newNode(Token.STRING, getPropNode.getProperty()));\n  }\n\n  private Node processRegExpLiteral(RegExpLiteral regexpNode) {\n    return newNode(Token.REGEXP, regexpNode.getValue(), regexpNode.getFlags());\n  }\n\n  private Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = newNode(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      nod",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..dd342036 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,523 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+public class IRFactory {\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  private static final ImmutableSet<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\");\n+\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+\n+  public IRFactory(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n+\n+  private Node newNode(int type, @Nullable Node firstChild, @Nullable Node secondChild) {\n+    Node node = new Node(type);\n+    if (firstChild != null) {\n+      node.addChildToBack(firstChild);\n     }\n+    if (secondChild != null) {\n+      node.addChildToBack(secondChild);\n+    }\n+    return node;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n+  private Node newNode(int type, Node firstChild, Node secondChild, Node thirdChild) {\n+    Node node = new Node(type);\n+    node.addChildToBack(firstChild);\n+    node.addChildToBack(secondChild);\n+    node.addChildToBack(thirdChild);\n+    return node;\n+  }\n+\n+  private Node newNode(int type, Node firstChild, Node secondChild, Node thirdChild, Node fourthChild) {\n+    Node node = new Node(type);\n+    node.addChildToBack(firstChild);\n+    node.addChildToBack(secondChild);\n+    node.addChildToBack(thirdChild);\n+    node.addChildToBack(fourthChild);\n+    return node;\n+  }\n+\n+  private boolean isDirective(Node n) {\n+    if (n == null) {\n+      return false;\n     }\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT && n.getFirstChild().isString()\n+        && ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  private Node transform(AstNode node) {\n+    return node == null ? null : node.accept(new TransformDispatcher());\n+  }\n+\n+  private Node transformBlock(Block blockNode) {\n+    List<Node> statementNodes = transformStatements(blockNode.getStatements());\n+    if (statementNodes.size() == 1) {\n+      return statementNodes.get(0);\n+    }\n+    return newNode(Token.BLOCK, statementNodes.get(0), statementNodes.get(1));\n+  }\n+\n+  private List<Node> transformStatements(List<AstNode> nodes) {\n+    return transformNodes(nodes, true);\n+  }\n+\n+  private List<Node> transformNodes(List<AstNode> nodes, boolean allowDirectives) {\n+    List<Node> result = new ArrayList<>();\n+    for (AstNode n : nodes) {\n+      if (!allowDirectives && isDirective(n)) {\n+        throw new RuntimeException(\"Directive node not allowed here\");\n       }\n-      return node;\n+      result.add(transform(n));\n     }\n+    return result;\n+  }\n \n+  abstract class TypeSafeDispatcher implements NodeVisitor<Node> {\n     @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n-      }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n+    public Node visit(AstNode node) {\n+      throw new RuntimeException(\"Unexpected node type: \" + node.getClass().getSimpleName());\n     }\n \n     @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n+    public Node visit(Assignment node) {\n       return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+          Token.ASSIGN,\n+          transform(node.getLeft()),\n+          transform(node.getRight()));\n     }\n \n     @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n-      }\n-      return node;\n+    public Node visit(Block node) {\n+      return processBlock(node);\n     }\n \n     @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    public Node visit(BreakStatement node) {\n+      return processBreakStatement(node);\n     }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+    public Node visit(CatchClause node) {\n+      return processCatchClause(node);\n     }\n \n     @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+    public Node visit(ConditionalExpression node) {\n+      return processConditionalExpression(node);\n     }\n \n     @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+    public Node visit(ContinueStatement node) {\n+      return processContinueStatement(node);\n     }\n \n     @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+    public Node visit(DoLoop node) {\n+      return processDoLoop(node);\n+    }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+    @Override\n+    public Node visit(ElementGet node) {\n+      return processElementGet(node);\n+    }\n+\n+    @Override\n+    public Node visit(EmptyExpression node) {\n+      return processEmptyExpression(node);\n     }\n \n+    public Node visit(ExpressionStatement node) {\n+      return processExpressionStatement(node);\n+    }\n+\n+    @Override\n+    public Node visit(ForInLoop node) {\n+      return processForInLoop(node);\n+    }\n+\n+    @Override\n+    public Node visit(ForLoop node) {\n+      return processForLoop(node);\n+    }\n+\n+    @Override\n+    public Node visit(FunctionNode node) {\n+      return processFunction(node);\n+    }\n+\n+    @Override\n+    public Node visit(IfStatement node) {\n+      return processIfStatement(node);\n+    }\n+\n+    @Override\n+    public Node visit(InfixExpression node) {\n+      return processInfixExpression(node);\n+    }\n+\n+    @Override\n+    public Node visit(LabeledStatement node) {\n+      return processLabeledStatement(node);\n+    }\n+\n+    @Override\n+    public Node visit(Name node) {\n+      return processName(node);\n+    }\n+\n+    @Override\n+    public Node visit(NewExpression node) {\n+      return processNewExpression(node);\n+    }\n+\n+    @Override\n+    public Node visit(NumberLiteral node) {\n+      return processNumberLiteral(node);\n+    }\n+\n+    @Override\n+    public Node visit(ObjectLiteral node) {\n+      return processObjectLiteral(node);\n+    }\n+\n+    @Override\n+    public Node visit(ParenthesizedExpression node) {\n+      return processParenthesizedExpression(node);\n+    }\n+\n+    @Override\n+    public Node visit(PropertyGet node) {\n+      return processPropertyGet(node);\n+    }\n+\n+    @Override\n+    public Node visit(ReturnStatement node) {\n+      return processReturnStatement(node);\n+    }\n+\n+    @Override\n+    public Node visit(StringLiteral node) {\n+      return processStringLiteral(node);\n+    }\n+\n+    @Override\n+    public Node visit(SwitchCase node) {\n+      return processSwitchCase(node);\n+    }\n+\n+    @Override\n+    public Node visit(SwitchStatement node) {\n+      return processSwitchStatement(node);\n+    }\n+\n+    @Override\n+    public Node visit(ThrowStatement node) {\n+      return processThrowStatement(node);\n+    }\n+\n+    @Override\n+    public Node visit(TryStatement node) {\n+      return processTryStatement(node);\n+    }\n+\n+    @Override\n+    public Node visit(UnaryExpression node) {\n+      return processUnaryExpression(node);\n+    }\n+\n+    @Override\n+    public Node visit(VariableDeclaration node) {\n+      return processVariableDeclaration(node);\n+    }\n+\n+    @Override\n+    public Node visit(VariableInitializer node) {\n+      return processVariableInitializer(node);\n+    }\n+\n+    @Override\n+    public Node visit(WhileLoop node) {\n+      return processWhileLoop(node);\n+    }\n+\n+    @Override\n+    public Node visit(WithStatement node) {\n+      return processWithStatement(node);\n+    }\n+  }\n+\n+  class TransformDispatcher extends TypeSafeDispatcher {\n+    @Override\n+    public Node visit(AstNode node) {\n+      return null;\n+    }\n+\n+    @Override\n+    public Node visit(ArrayLiteral node) {\n+      return processArrayLiteral(node);\n+    }\n+\n+    @Override\n+    public Node visit(FunctionCall node) {\n+      return processFunctionCall(node);\n+    }\n+\n+    @Override\n+    public Node visit(ObjectProperty node) {\n+      return processObjectProperty(node);\n+    }\n+\n+    @Override\n+    public Node visit(ThisLiteral node) {\n+      return processThisLiteral(node);\n+    }\n+\n+    @Override\n+    public Node visit(XmlNode node) {\n+      throw new UnsupportedOperationException(\"XML literals are not supported\");\n+    }\n+\n+    @Override\n+    public Node visit(XmlString node) {\n+      throw new UnsupportedOperationException(\"XML literals are not supported\");\n+    }\n+\n+    @Override\n+    public Node visit(InfixExpression node) {\n+      return processInfixExpression(node);\n+    }\n+\n+    @Override\n+    public Node visit(NumberLiteral node) {\n+      return processNumberLiteral(node);\n+    }\n+\n+    @Override\n+    public Node visit(StringLiteral node) {\n+      return processStringLiteral(node);\n+    }\n+\n+    @Override\n+    public Node visit(Name node) {\n+      return processName(node);\n+    }\n+\n+    @Override\n+    public Node visit(RegExpLiteral node) {\n+      return processRegExpLiteral(node);\n+    }\n+\n+    // The remaining methods are inherited from TypeSafeDispatcher and should be implemented as necessary\n+  }\n+\n+  private Node processFunction(FunctionNode functionNode) {\n+    Node function = newNode(Token.FUNCTION, transform(functionNode.getName()));\n+    Node params = newNode(Token.PARAM_LIST);\n+    for (AstNode p : functionNode.getParams()) {\n+      params.addChildToBack(transform(p));\n+    }\n+    Node body = transform(functionNode.getBody());\n+    function.addChildToBack(params);\n+    function.addChildToBack(body);\n+    return function;\n+  }\n+\n+  private Node processArrayLiteral(ArrayLiteral arrayLiteral) {\n+    return newNode(\n+        Token.ARRAYLIT,\n+        transformNodes(arrayLiteral.getElements(), false).toArray(new Node[0]));\n+  }\n+\n+  private Node processBlock(Block blockNode) {\n+    List<Node> statementNodes = transformStatements(blockNode.getStatements());\n+    if (statementNodes.size() == 1) {\n+      return statementNodes.get(0);\n+    }\n+    return newNode(Token.BLOCK, statementNodes.get(0), statementNodes.get(1));\n+  }\n+\n+  private Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  private Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\n+          \"Catch clauses are not supported\", sourceName, clauseNode.getCatchCondition().getLineno(),\n+          \"\", 0);\n+    }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n+\n+  private Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  private Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  private Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  private Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  private Node processEmptyExpression(EmptyExpression exprNode) {\n+    return newNode(Token.EMPTY);\n+  }\n+\n+  private Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(transformTokenType(statementNode.getType()));\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  private Node processForInLoop(ForInLoop loopNode) {\n+    return newNode(\n+        Token.FOR,\n+        transform(loopNode.getIterator()),\n+        transform(loopNode.getIteratedObject()),\n+        transform(loopNode.getBody()));\n+  }\n+\n+  private Node processForLoop(ForLoop loopNode) {\n+    Node init = transform(loopNode.getInitializer());\n+    Node condition = transform(loopNode.getCondition());\n+    Node increment = transform(loopNode.getIncrement());\n+    Node body = transform(loopNode.getBody());\n+    if (init.getType() == Token.EMPTY) {\n+      init = null;\n+    }\n+    if (condition.getType() == Token.EMPTY) {\n+      condition = null;\n+    }\n+    if (increment.getType() == Token.EMPTY) {\n+      increment = null;\n+    }\n+    return newNode(Token.FOR, init, condition, increment, body);\n+  }\n+\n+  private Node processFunctionCall(FunctionCall callNode) {\n+    return newNode(\n+        Token.CALL,\n+        transform(callNode.getTarget()).setInferredType(ObjectType.AnyType),\n+        transformNodes(callNode.getArguments(), false).toArray(new Node[0]));\n+  }\n+\n+  private Node processInfixExpression(InfixExpression infixNode) {\n+    return newNode(\n+        transformTokenType(infixNode.getType()),\n+        transform(infixNode.getLeft()),\n+        transform(infixNode.getRight()));\n+  }\n+\n+  private Node processLabeledStatement(LabeledStatement labeledNode) {\n+    Node node = newNode(Token.LABEL, transform(labeledNode.getStatementLabel()));\n+    node.addChildToBack(transform(labeledNode.getStatement()));\n+    return node;\n+  }\n+\n+  private Node processName(Name nameNode) {\n+    Node node = new Node(Token.NAME, nameNode.getString());\n+    Scope s = nameNode.getScope();\n+    if (s != null && !s.isGlobal()) {\n+      node.putProp(Node.SYMBOL, s.getSymbolTable().get(nameNode.getIdentifier()));\n+      node.setScope(s);\n+    }\n+    return node;\n+  }\n+\n+  private Node processNewExpression(NewExpression newNode) {\n+    return newNode(\n+        Token.NEW,\n+        transform(newNode.getTarget()).setInferredType(ObjectType.AnyType),\n+        transformNodes(newNode.getArguments(), false).toArray(new Node[0]));\n+  }\n+\n+  private Node processNumberLiteral(NumberLiteral numberNode) {\n+    return newNode(Token.NUMBER, numberNode.getNumber());\n+  }\n+\n+  private Node processObjectLiteral(ObjectLiteral objectNode) {\n+    return newNode(\n+        Token.OBJECTLIT,\n+        transformNodes(objectNode.getElements(), false).toArray(new Node[0]));\n+  }\n+\n+  private Node processObjectProperty(ObjectProperty objectProp) {\n+    Node key = transform(objectProp.getLeft());\n+    Node value = transform(objectProp.getRight());\n+    // An object property with a `getprop` key is a shorthand function.\n+    if (key.getType() == Token.STRING) {\n+      String functionName = key.getString();\n+      Node fnNode = transform(objectProp.getRight());\n+      Node fnNameNode = new Node(Token.STRING, functionName);\n+      Node propNode = new Node(Token.GETPROP, transform(objectProp.getLeft()), fnNameNode);\n+      Node assignNode = new Node(Token.ASSIGN, propNode, fnNode);\n+      assignNode.putBooleanProp(Node.SYNTHETIC_PROP, true);\n+      return assignNode;\n+    } else {\n+      return newNode(Token.GETELEM, transform(objectProp.getLeft()), value);\n+    }\n+  }\n+\n+  private Node processParenthesizedExpression(ParenthesizedExpression node) {\n+    Node result = transform(node.getExpression());\n+    result.setIsParenthesizedExpr(true);\n+    return result;\n+  }\n+\n+  private Node processPropertyGet(PropertyGet getPropNode) {\n+    return newNode(\n+        Token.GETPROP,\n+        transform(getPropNode.getTarget()),\n+        newNode(Token.STRING, getPropNode.getProperty()));\n+  }\n+\n+  private Node processRegExpLiteral(RegExpLiteral regexpNode) {\n+    return newNode(Token.REGEXP, regexpNode.getValue(), regexpNode.getFlags());\n+  }\n+\n+  private Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      nod\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}