{
    "patch": "class TransformDispatcher implements IRFactory.TypeSafeDispatcher {\n  private final ErrorReporter errorReporter;\n  private final String sourceName;\n  private static final Set<String> ALLOWED_DIRECTIVES =\n      ImmutableSet.of(\"use strict\", \"use asm\");\n\n  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n    this.errorReporter = errorReporter;\n    this.sourceName = sourceName;\n  }\n\n  private boolean isDirective(Node n) {\n    if (n == null) return false;\n\n    int nType = n.getType();\n    return nType == Token.EXPR_RESULT &&\n           n.getFirstChild().isString() &&\n           ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n  }\n\n  private Node newNode(int type, Node... children) {\n    Node n = new Node(type);\n    for (Node c : children) {\n      if (c != null) {\n        n.addChildToBack(c);\n      }\n    }\n    n.setLineno(-1);\n    n.setCharno(-1);\n    return n;\n  }\n\n  private Node transformBlock(Node block) {\n    Node result = newNode(Token.BLOCK);\n    for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {\n      if (n.getType() == Token.SCRIPT) {\n        result.addChildrenToFront(transformBlock(n));\n      } else if (isDirective(n)) {\n        // Skip directive if it is unchanged.\n        if (transform(n.getFirstChild()).getString().equals(n.getFirstChild().getString())) {\n          result.addChildToBack(n.detachFromParent());\n        }\n      } else {\n        result.addChildToBack(transform(n));\n      }\n    }\n    return result;\n  }\n\n  @Override\n  public Node processArrayComprehension(ArrayComprehension node) {\n    throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n  }\n\n  @Override\n  public Node processAstRoot(AstRoot root) {\n    return transformBlock(root);\n  }\n\n  @Override\n  public Node processBinaryOperator(BinaryOperator node) {\n    return newNode(\n        Token.BITOR, transform(node.getLeft()), transform(node.getRight()));\n  }\n\n  @Override\n  public Node processBlock(Block blockNode) {\n    return transformBlock(blockNode);\n  }\n\n  @Override\n  public Node processBreakStatement(BreakStatement statementNode) {\n    Node node = newNode(Token.BREAK);\n    if (statementNode.getBreakLabel() != null) {\n      Node labelName = transform(statementNode.getBreakLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processCatchClause(CatchClause clauseNode) {\n    AstNode catchVar = clauseNode.getVarName();\n    Node node = newNode(Token.CATCH, transform(catchVar));\n    if (clauseNode.getCatchCondition() != null) {\n      errorReporter.error(\"Catch clauses are not supported\", sourceName,\n                           clauseNode.getCatchCondition().getLineno(), \"\", 0);\n    }\n    node.addChildToBack(transformBlock(clauseNode.getBody()));\n    return node;\n  }\n\n  @Override\n  public Node processConditionalExpression(ConditionalExpression exprNode) {\n    return newNode(\n        Token.HOOK,\n        transform(exprNode.getTestExpression()),\n        transform(exprNode.getTrueExpression()),\n        transform(exprNode.getFalseExpression()));\n  }\n\n  @Override\n  public Node processContinueStatement(ContinueStatement statementNode) {\n    Node node = newNode(Token.CONTINUE);\n    if (statementNode.getLabel() != null) {\n      Node labelName = transform(statementNode.getLabel());\n      // Change the NAME to LABEL_NAME\n      labelName.setType(Token.LABEL_NAME);\n      node.addChildToBack(labelName);\n    }\n    return node;\n  }\n\n  @Override\n  public Node processDoLoop(DoLoop loopNode) {\n    return newNode(\n        Token.DO,\n        transformBlock(loopNode.getBody()),\n        transform(loopNode.getCondition()));\n  }\n\n  @Override\n  public Node processElementGet(ElementGet getNode) {\n    return newNode(\n        Token.GETELEM,\n        transform(getNode.getTarget()),\n        transform(getNode.getElement()));\n  }\n\n  @Override\n  public Node processEmptyExpression(EmptyExpression exprNode) {\n    return newNode(Token.EMPTY);\n  }\n\n  @Override\n  public Node processExpressionStatement(ExpressionStatement statementNode) {\n    Node node = newNode(Token.EXPR_RESULT);\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  public Node processForInLoop(ForInLoop loopNode) {\n    Node left;\n\n    // If the left-hand side of the for..in is a destructuring pattern,\n    // declare a temporary variable as the loop variable and destructure\n    // the value each iteration.\n    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n      left = newNode(\n          Token.VAR,\n          createDestructuringLhs(\n              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n    } else {\n      left = transform(loopNode.getIterator());\n    }\n\n    return newNode(\n        Token.FOR,\n        newNode(Token.EMPTY),\n        newNode(Token.EMPTY),\n        newNode(\n            Token.BLOCK,\n            left,\n            newNode(\n                Token.FOR_IN,\n                transform(loopNode.getIteratedObject()),\n                newNode(Token.EMPTY),\n                transformBlock(loopNode.getBody()))));\n  }\n\n  @Override\n  public Node processForLoop(ForLoop loopNode) {\n    Node init = transform(loopNode.getInitializer());\n    Node cond = transform(loopNode.getCondition());\n    Node incr = transform(loopNode.getIncrement());\n    Node body = transform(loopNode.getBody());\n\n    // Convert traditional for loop to for..in loop if the initializer\n    // is a var declaration that declares exactly one variable and the\n    // condition is a non-null and non-array expression.\n    if (init.getType() == Token.VAR && init.getChildCount() == 1 &&\n        cond.getType() != Token.NULL &&\n        (!cond.isArrayLit() || cond.getChildCount() != 0)) {\n      AstNode var = init.getFirstChild();\n      if (var.getChildCount() == 1) {\n        Node lhs = transform(var.getFirstChild());\n        Node rhs = transform(cond);\n        Node varName = lhs.getFirstChild();\n        Node forInBody = newNode(Token.BLOCK, body);\n        // If the body of the for..in loop contains a break statement,\n        // wrap the body in a try..finally to ensure the loop variable\n        // is decremented when the loop is exited.\n        if (containsBreakStatement(body)) {\n          forInBody =\n              newNode(\n                  Token.BLOCK,\n                  newNode(\n                      Token.TRY,\n                      newNode(Token.EMPTY),\n                      newNode(\n                          Token.BLOCK,\n                          newNode(Token.FOR_OF, lhs, rhs, forInBody)),\n                      newNode(Token.EMPTY)));\n        } else {\n          forInBody = newNode(Token.BLOCK, newNode(Token.FOR_OF, lhs, rhs, forInBody));\n        }\n        Node tmpVarName = Node.newString(Token.NAME, \"$tmp\");\n        Node tmpVar = newNode(Token.VAR, tmpVarName.cloneTree());\n        Node assign =\n            newNode(\n                Token.VAR,\n                newNode(Token.NAME, varName.cloneTree()),\n                newNode(\n                    Token.INIT_NAME,\n                    tmpVarName.cloneTree(),\n                    newNode(Token.NAME, varName.cloneTree())));\n        return newNode(Token.BLOCK, tmpVar, assign, forInBody);\n      }\n    }\n\n    return newNode(Token.FOR, init, cond, incr, body);\n  }\n\n  @Override\n  public Node processFunctionCall(FunctionCall callNode) {\n    Node target = transform(callNode.getTarget());\n    Node args = newNode(Token.EMPTY);\n    for (AstNode a : callNode.getArguments()) {\n      args.addChildToBack(transform(a));\n    }\n    return newNode(Token.CALL, target, args);\n  }\n\n    @Override\n  public Node processFunctionNode(FunctionNode fnNode) {\n    Node parameters = newNode(Token.BLOCK);\n    for (Node p : transformFunctionParams(fnNode)) {\n      parameters.addChildToBack(p);\n    }\n    return newNode(\n        Token.FUNCTION,\n        newNode(Token.EMPTY),\n        parameters,\n        transformBlock(fnNode.getBody()));\n  }\n\n  @Override\n  public Node processIfStatement(IfStatement statementNode) {\n    return newNode(\n        Token.IF,\n        transform(statementNode.getCondition()),\n        transformBlock(statementNode.getThenPart()),\n        transform(statementNode.getElsePart()));\n  }\n\n  @Override\n  public Node processLabeledStatement(LabeledStatement statementNode) {\n    return newNode(Token.LABEL,\n                   transform(statementNode.getFirstChild()),\n                   transform(statementNode.getStatement()));\n  }\n\n  @Override\n  public Node processLetNode(LetNode letNode) {\n    throw new UnsupportedOperationException(\"Let blocks not supported\");\n  }\n\n  @Override\n  public Node processName(Name nameNode) {\n    return Node.newString(Token.NAME, nameNode.getIdentifier());\n  }\n\n  @Override\n  public Node processNewExpression(NewExpression callNode) {\n    Node target = transform(callNode.getTarget());\n    Node args = newNode(Token.EMPTY);\n    for (AstNode a : callNode.getArguments()) {\n      args.addChildToBack(transform(a));\n    }\n    return newNode(Token.NEW, target, args);\n  }\n\n  @Override\n  public Node processNumber(NumberLiteral numberNode) {\n    return Node.newNumber(numberNode.getNumber());\n  }\n\n  @Override\n  public Node processObjectLiteral(ObjectLiteral objectNode) {\n    Node obj = newNode(Token.OBJECTLIT);\n    for (ObjectProperty prop : objectNode.getElements()) {\n      if (prop.isGetter()) {\n        obj.addChildToBack(newNode(Token.GETTER_DEF, transform(prop.getLeft())));\n      } else if (prop.isSetter()) {\n        obj.addChildToBack(newNode(Token.SETTER_DEF, transform(prop.getLeft()), newNode(Token.EMPTY, transform(prop.getRight()))));\n      } else {\n        obj.addChildToBack(\n            newNode(Token.STRING_KEY, prop.getLeft().getString(), transform(prop.getRight())));\n      }\n    }\n    return obj;\n  }\n\n  @Override\n  public Node processRegExp(RhinoRegExp regexpNode) {\n    return Node.newString(Token.REGEXP, regexpNode.getValue());\n  }\n\n  @Override\n  public Node processReturnStatement(ReturnStatement statementNode) {\n    Node node = newNode(Token.RETURN);\n    if (statementNode.getReturnValue() != null) {\n      node.addChildToBack(transform(statementNode.getReturnValue()));\n    }\n    return node;\n  }\n\n  @Override\n  public Node processString(StringLiteral stringNode) {\n    return Node.newString(Token.STRING, stringNode.getValue());\n  }\n\n  @Override\n  public Node processSwitchCase(SwitchCase caseNode) {\n    if (caseNode.getExpression() == null) {\n      return newNode(Token.CASE, newNode(Token.NULL));\n    }\n    return newNode(Token.CASE, transform(caseNode.getExpression()));\n  }\n\n  @Override\n  public Node processSwitchStatement(SwitchStatement statementNode) {\n    Node result = newNode(\n        Token.SWITCH, transform(statementNode.getExpression()));\n\n    for (SwitchCase c : statementNode.getCases()) {\n      Node caseNode = transform(c);\n      for (AstNode stmt : c.getStatements()) {\n        caseNode.addChildToBack(transform(stmt));\n      }\n      result.addChildToBack(caseNode);\n    }\n\n    return result;\n  }\n\n  @Override\n  public Node processThrowStatement(ThrowStatement statementNode) {\n    Node node = newNode(Token.THROW);\n    node.addChildToBack(transform(statementNode.getExpression()));\n    return node;\n  }\n\n  @Override\n  public Node processTryStatement(TryStatement statementNode) {\n    Node tryBlock = transformBlock(statementNode.getTryBlock());\n    Node catchBlock = null;\n    if (statementNode.getCatchBlock() != null) {\n      CatchClause catchClause = statementNode.getCatchBlock().getFirstChild();\n      Node catchVar = transform(catchClause.getVarName());\n      catchBlock =\n          newNode(\n              Token.BLOCK, transformBlock(catchClause.getBody()), catchVar.cloneTree());\n    }\n    Node finallyBlock = null;\n    if (statementNode.getFinallyBlock() != null) {\n      finallyBlock = transformBlock(statementNode.getFinallyBlock());\n    }\n    return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n  }\n\n  @Override\n  public Node processUnaryOperator(UnaryOperator node) {\n    return newNode(Token.BITNOT, transform(node.getOperand()));\n  }\n\n  @Override\n  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n    Node var = newNode(Token.VAR);\n    for (VariableInitializer init : declarationNode.getVariables()) {\n      Node initializer = init.getInitializer() == null ? null : transform(init.getInitializer());\n      Node name = transform(init.getTarget());\n      if (name.getType() == Token.ARRAY_PATTERN) {\n        for (Node child : name.children()) {\n          var.addChildToBack(newNode(Token.VAR, child, newNode(Token.ARRAYLIT, initializer)));\n        }\n      } else if (name.getType() == Token.OBJECT_PATTERN) {\n        Node obj = newNode(Token.OBJECTLIT);\n        for (Node child : name.children()) {\n          obj.addChildToBack(newNode(Token.STRING_KEY, child.getString(), newNode(Token.EMPTY)));\n        }\n        var.addChildToBack(newNode(Token.VAR, obj, initializer));\n      } else {\n        var.addChildToBack(newNode(Token.VAR, name, initializer));\n      }\n    }\n    return var;\n  }\n\n  @Override\n  public Node processVariableInitializer(VariableInitializer initializerNode) {\n    throw new IllegalStateException(\"Unexpected visit to proces",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/parsing/IRFactory.java b/src/com/google/javascript/jscomp/parsing/IRFactory.java\nindex 1a95aa2f..b8c288ef 100644\n--- a/src/com/google/javascript/jscomp/parsing/IRFactory.java\n+++ b/src/com/google/javascript/jscomp/parsing/IRFactory.java\n@@ -473,107 +473,413 @@ class IRFactory {\n       }\n     }\n \n-    private boolean isDirective(Node n) {\n-      if (n == null) return false;\n+class TransformDispatcher implements IRFactory.TypeSafeDispatcher {\n+  private final ErrorReporter errorReporter;\n+  private final String sourceName;\n+  private static final Set<String> ALLOWED_DIRECTIVES =\n+      ImmutableSet.of(\"use strict\", \"use asm\");\n \n-      int nType = n.getType();\n-      return nType == Token.EXPR_RESULT &&\n-          n.getFirstChild().isString() &&\n-          ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n-    }\n+  TransformDispatcher(ErrorReporter errorReporter, String sourceName) {\n+    this.errorReporter = errorReporter;\n+    this.sourceName = sourceName;\n+  }\n \n-    @Override\n-    Node processBlock(Block blockNode) {\n-      return processGeneric(blockNode);\n-    }\n+  private boolean isDirective(Node n) {\n+    if (n == null) return false;\n \n-    @Override\n-    Node processBreakStatement(BreakStatement statementNode) {\n-      Node node = newNode(Token.BREAK);\n-      if (statementNode.getBreakLabel() != null) {\n-        Node labelName = transform(statementNode.getBreakLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+    int nType = n.getType();\n+    return nType == Token.EXPR_RESULT &&\n+           n.getFirstChild().isString() &&\n+           ALLOWED_DIRECTIVES.contains(n.getFirstChild().getString());\n+  }\n+\n+  private Node newNode(int type, Node... children) {\n+    Node n = new Node(type);\n+    for (Node c : children) {\n+      if (c != null) {\n+        n.addChildToBack(c);\n       }\n-      return node;\n     }\n+    n.setLineno(-1);\n+    n.setCharno(-1);\n+    return n;\n+  }\n \n-    @Override\n-    Node processCatchClause(CatchClause clauseNode) {\n-      AstNode catchVar = clauseNode.getVarName();\n-      Node node = newNode(Token.CATCH, transform(catchVar));\n-      if (clauseNode.getCatchCondition() != null) {\n-        errorReporter.error(\n-            \"Catch clauses are not supported\",\n-            sourceName,\n-            clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+  private Node transformBlock(Node block) {\n+    Node result = newNode(Token.BLOCK);\n+    for (Node n = block.getFirstChild(); n != null; n = n.getNext()) {\n+      if (n.getType() == Token.SCRIPT) {\n+        result.addChildrenToFront(transformBlock(n));\n+      } else if (isDirective(n)) {\n+        // Skip directive if it is unchanged.\n+        if (transform(n.getFirstChild()).getString().equals(n.getFirstChild().getString())) {\n+          result.addChildToBack(n.detachFromParent());\n+        }\n+      } else {\n+        result.addChildToBack(transform(n));\n       }\n-      node.addChildToBack(transformBlock(clauseNode.getBody()));\n-      return node;\n     }\n+    return result;\n+  }\n \n-    @Override\n-    Node processConditionalExpression(ConditionalExpression exprNode) {\n-      return newNode(\n-          Token.HOOK,\n-          transform(exprNode.getTestExpression()),\n-          transform(exprNode.getTrueExpression()),\n-          transform(exprNode.getFalseExpression()));\n+  @Override\n+  public Node processArrayComprehension(ArrayComprehension node) {\n+    throw new UnsupportedOperationException(\"Array comprehensions not supported\");\n+  }\n+\n+  @Override\n+  public Node processAstRoot(AstRoot root) {\n+    return transformBlock(root);\n+  }\n+\n+  @Override\n+  public Node processBinaryOperator(BinaryOperator node) {\n+    return newNode(\n+        Token.BITOR, transform(node.getLeft()), transform(node.getRight()));\n+  }\n+\n+  @Override\n+  public Node processBlock(Block blockNode) {\n+    return transformBlock(blockNode);\n+  }\n+\n+  @Override\n+  public Node processBreakStatement(BreakStatement statementNode) {\n+    Node node = newNode(Token.BREAK);\n+    if (statementNode.getBreakLabel() != null) {\n+      Node labelName = transform(statementNode.getBreakLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processContinueStatement(ContinueStatement statementNode) {\n-      Node node = newNode(Token.CONTINUE);\n-      if (statementNode.getLabel() != null) {\n-        Node labelName = transform(statementNode.getLabel());\n-        // Change the NAME to LABEL_NAME\n-        labelName.setType(Token.LABEL_NAME);\n-        node.addChildToBack(labelName);\n+  @Override\n+  public Node processCatchClause(CatchClause clauseNode) {\n+    AstNode catchVar = clauseNode.getVarName();\n+    Node node = newNode(Token.CATCH, transform(catchVar));\n+    if (clauseNode.getCatchCondition() != null) {\n+      errorReporter.error(\"Catch clauses are not supported\", sourceName,\n+                           clauseNode.getCatchCondition().getLineno(), \"\", 0);\n+    }\n+    node.addChildToBack(transformBlock(clauseNode.getBody()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processConditionalExpression(ConditionalExpression exprNode) {\n+    return newNode(\n+        Token.HOOK,\n+        transform(exprNode.getTestExpression()),\n+        transform(exprNode.getTrueExpression()),\n+        transform(exprNode.getFalseExpression()));\n+  }\n+\n+  @Override\n+  public Node processContinueStatement(ContinueStatement statementNode) {\n+    Node node = newNode(Token.CONTINUE);\n+    if (statementNode.getLabel() != null) {\n+      Node labelName = transform(statementNode.getLabel());\n+      // Change the NAME to LABEL_NAME\n+      labelName.setType(Token.LABEL_NAME);\n+      node.addChildToBack(labelName);\n+    }\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processDoLoop(DoLoop loopNode) {\n+    return newNode(\n+        Token.DO,\n+        transformBlock(loopNode.getBody()),\n+        transform(loopNode.getCondition()));\n+  }\n+\n+  @Override\n+  public Node processElementGet(ElementGet getNode) {\n+    return newNode(\n+        Token.GETELEM,\n+        transform(getNode.getTarget()),\n+        transform(getNode.getElement()));\n+  }\n+\n+  @Override\n+  public Node processEmptyExpression(EmptyExpression exprNode) {\n+    return newNode(Token.EMPTY);\n+  }\n+\n+  @Override\n+  public Node processExpressionStatement(ExpressionStatement statementNode) {\n+    Node node = newNode(Token.EXPR_RESULT);\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processForInLoop(ForInLoop loopNode) {\n+    Node left;\n+\n+    // If the left-hand side of the for..in is a destructuring pattern,\n+    // declare a temporary variable as the loop variable and destructure\n+    // the value each iteration.\n+    if (loopNode.getIterator().getType() == Token.ARRAY_PATTERN ||\n+        loopNode.getIterator().getType() == Token.OBJECT_PATTERN) {\n+      left = newNode(\n+          Token.VAR,\n+          createDestructuringLhs(\n+              loopNode.getIterator(), Token.NAME, Node.newString(Token.NAME, \"$tmp\")));\n+    } else {\n+      left = transform(loopNode.getIterator());\n+    }\n+\n+    return newNode(\n+        Token.FOR,\n+        newNode(Token.EMPTY),\n+        newNode(Token.EMPTY),\n+        newNode(\n+            Token.BLOCK,\n+            left,\n+            newNode(\n+                Token.FOR_IN,\n+                transform(loopNode.getIteratedObject()),\n+                newNode(Token.EMPTY),\n+                transformBlock(loopNode.getBody()))));\n+  }\n+\n+  @Override\n+  public Node processForLoop(ForLoop loopNode) {\n+    Node init = transform(loopNode.getInitializer());\n+    Node cond = transform(loopNode.getCondition());\n+    Node incr = transform(loopNode.getIncrement());\n+    Node body = transform(loopNode.getBody());\n+\n+    // Convert traditional for loop to for..in loop if the initializer\n+    // is a var declaration that declares exactly one variable and the\n+    // condition is a non-null and non-array expression.\n+    if (init.getType() == Token.VAR && init.getChildCount() == 1 &&\n+        cond.getType() != Token.NULL &&\n+        (!cond.isArrayLit() || cond.getChildCount() != 0)) {\n+      AstNode var = init.getFirstChild();\n+      if (var.getChildCount() == 1) {\n+        Node lhs = transform(var.getFirstChild());\n+        Node rhs = transform(cond);\n+        Node varName = lhs.getFirstChild();\n+        Node forInBody = newNode(Token.BLOCK, body);\n+        // If the body of the for..in loop contains a break statement,\n+        // wrap the body in a try..finally to ensure the loop variable\n+        // is decremented when the loop is exited.\n+        if (containsBreakStatement(body)) {\n+          forInBody =\n+              newNode(\n+                  Token.BLOCK,\n+                  newNode(\n+                      Token.TRY,\n+                      newNode(Token.EMPTY),\n+                      newNode(\n+                          Token.BLOCK,\n+                          newNode(Token.FOR_OF, lhs, rhs, forInBody)),\n+                      newNode(Token.EMPTY)));\n+        } else {\n+          forInBody = newNode(Token.BLOCK, newNode(Token.FOR_OF, lhs, rhs, forInBody));\n+        }\n+        Node tmpVarName = Node.newString(Token.NAME, \"$tmp\");\n+        Node tmpVar = newNode(Token.VAR, tmpVarName.cloneTree());\n+        Node assign =\n+            newNode(\n+                Token.VAR,\n+                newNode(Token.NAME, varName.cloneTree()),\n+                newNode(\n+                    Token.INIT_NAME,\n+                    tmpVarName.cloneTree(),\n+                    newNode(Token.NAME, varName.cloneTree())));\n+        return newNode(Token.BLOCK, tmpVar, assign, forInBody);\n       }\n-      return node;\n     }\n \n-    @Override\n-    Node processDoLoop(DoLoop loopNode) {\n-      return newNode(\n-          Token.DO,\n-          transformBlock(loopNode.getBody()),\n-          transform(loopNode.getCondition()));\n+    return newNode(Token.FOR, init, cond, incr, body);\n+  }\n+\n+  @Override\n+  public Node processFunctionCall(FunctionCall callNode) {\n+    Node target = transform(callNode.getTarget());\n+    Node args = newNode(Token.EMPTY);\n+    for (AstNode a : callNode.getArguments()) {\n+      args.addChildToBack(transform(a));\n     }\n+    return newNode(Token.CALL, target, args);\n+  }\n \n     @Override\n-    Node processElementGet(ElementGet getNode) {\n-      return newNode(\n-          Token.GETELEM,\n-          transform(getNode.getTarget()),\n-          transform(getNode.getElement()));\n+  public Node processFunctionNode(FunctionNode fnNode) {\n+    Node parameters = newNode(Token.BLOCK);\n+    for (Node p : transformFunctionParams(fnNode)) {\n+      parameters.addChildToBack(p);\n+    }\n+    return newNode(\n+        Token.FUNCTION,\n+        newNode(Token.EMPTY),\n+        parameters,\n+        transformBlock(fnNode.getBody()));\n+  }\n+\n+  @Override\n+  public Node processIfStatement(IfStatement statementNode) {\n+    return newNode(\n+        Token.IF,\n+        transform(statementNode.getCondition()),\n+        transformBlock(statementNode.getThenPart()),\n+        transform(statementNode.getElsePart()));\n+  }\n+\n+  @Override\n+  public Node processLabeledStatement(LabeledStatement statementNode) {\n+    return newNode(Token.LABEL,\n+                   transform(statementNode.getFirstChild()),\n+                   transform(statementNode.getStatement()));\n+  }\n+\n+  @Override\n+  public Node processLetNode(LetNode letNode) {\n+    throw new UnsupportedOperationException(\"Let blocks not supported\");\n+  }\n+\n+  @Override\n+  public Node processName(Name nameNode) {\n+    return Node.newString(Token.NAME, nameNode.getIdentifier());\n+  }\n+\n+  @Override\n+  public Node processNewExpression(NewExpression callNode) {\n+    Node target = transform(callNode.getTarget());\n+    Node args = newNode(Token.EMPTY);\n+    for (AstNode a : callNode.getArguments()) {\n+      args.addChildToBack(transform(a));\n     }\n+    return newNode(Token.NEW, target, args);\n+  }\n \n-    @Override\n-    Node processEmptyExpression(EmptyExpression exprNode) {\n-      Node node = newNode(Token.EMPTY);\n-      return node;\n+  @Override\n+  public Node processNumber(NumberLiteral numberNode) {\n+    return Node.newNumber(numberNode.getNumber());\n+  }\n+\n+  @Override\n+  public Node processObjectLiteral(ObjectLiteral objectNode) {\n+    Node obj = newNode(Token.OBJECTLIT);\n+    for (ObjectProperty prop : objectNode.getElements()) {\n+      if (prop.isGetter()) {\n+        obj.addChildToBack(newNode(Token.GETTER_DEF, transform(prop.getLeft())));\n+      } else if (prop.isSetter()) {\n+        obj.addChildToBack(newNode(Token.SETTER_DEF, transform(prop.getLeft()), newNode(Token.EMPTY, transform(prop.getRight()))));\n+      } else {\n+        obj.addChildToBack(\n+            newNode(Token.STRING_KEY, prop.getLeft().getString(), transform(prop.getRight())));\n+      }\n     }\n+    return obj;\n+  }\n \n-    @Override\n-    Node processExpressionStatement(ExpressionStatement statementNode) {\n-      Node node = newNode(transformTokenType(statementNode.getType()));\n-      node.addChildToBack(transform(statementNode.getExpression()));\n-      return node;\n+  @Override\n+  public Node processRegExp(RhinoRegExp regexpNode) {\n+    return Node.newString(Token.REGEXP, regexpNode.getValue());\n+  }\n+\n+  @Override\n+  public Node processReturnStatement(ReturnStatement statementNode) {\n+    Node node = newNode(Token.RETURN);\n+    if (statementNode.getReturnValue() != null) {\n+      node.addChildToBack(transform(statementNode.getReturnValue()));\n     }\n+    return node;\n+  }\n \n-    @Override\n-    Node processForInLoop(ForInLoop loopNode) {\n+  @Override\n+  public Node processString(StringLiteral stringNode) {\n+    return Node.newString(Token.STRING, stringNode.getValue());\n+  }\n \n-        // Return the bare minimum to put the AST in a valid state.\n-      return newNode(\n-          Token.FOR,\n-          transform(loopNode.getIterator()),\n-          transform(loopNode.getIteratedObject()),\n-          transformBlock(loopNode.getBody()));\n+  @Override\n+  public Node processSwitchCase(SwitchCase caseNode) {\n+    if (caseNode.getExpression() == null) {\n+      return newNode(Token.CASE, newNode(Token.NULL));\n+    }\n+    return newNode(Token.CASE, transform(caseNode.getExpression()));\n+  }\n+\n+  @Override\n+  public Node processSwitchStatement(SwitchStatement statementNode) {\n+    Node result = newNode(\n+        Token.SWITCH, transform(statementNode.getExpression()));\n+\n+    for (SwitchCase c : statementNode.getCases()) {\n+      Node caseNode = transform(c);\n+      for (AstNode stmt : c.getStatements()) {\n+        caseNode.addChildToBack(transform(stmt));\n+      }\n+      result.addChildToBack(caseNode);\n     }\n \n+    return result;\n+  }\n+\n+  @Override\n+  public Node processThrowStatement(ThrowStatement statementNode) {\n+    Node node = newNode(Token.THROW);\n+    node.addChildToBack(transform(statementNode.getExpression()));\n+    return node;\n+  }\n+\n+  @Override\n+  public Node processTryStatement(TryStatement statementNode) {\n+    Node tryBlock = transformBlock(statementNode.getTryBlock());\n+    Node catchBlock = null;\n+    if (statementNode.getCatchBlock() != null) {\n+      CatchClause catchClause = statementNode.getCatchBlock().getFirstChild();\n+      Node catchVar = transform(catchClause.getVarName());\n+      catchBlock =\n+          newNode(\n+              Token.BLOCK, transformBlock(catchClause.getBody()), catchVar.cloneTree());\n+    }\n+    Node finallyBlock = null;\n+    if (statementNode.getFinallyBlock() != null) {\n+      finallyBlock = transformBlock(statementNode.getFinallyBlock());\n+    }\n+    return newNode(Token.TRY, tryBlock, catchBlock, finallyBlock);\n+  }\n+\n+  @Override\n+  public Node processUnaryOperator(UnaryOperator node) {\n+    return newNode(Token.BITNOT, transform(node.getOperand()));\n+  }\n+\n+  @Override\n+  public Node processVariableDeclaration(VariableDeclaration declarationNode) {\n+    Node var = newNode(Token.VAR);\n+    for (VariableInitializer init : declarationNode.getVariables()) {\n+      Node initializer = init.getInitializer() == null ? null : transform(init.getInitializer());\n+      Node name = transform(init.getTarget());\n+      if (name.getType() == Token.ARRAY_PATTERN) {\n+        for (Node child : name.children()) {\n+          var.addChildToBack(newNode(Token.VAR, child, newNode(Token.ARRAYLIT, initializer)));\n+        }\n+      } else if (name.getType() == Token.OBJECT_PATTERN) {\n+        Node obj = newNode(Token.OBJECTLIT);\n+        for (Node child : name.children()) {\n+          obj.addChildToBack(newNode(Token.STRING_KEY, child.getString(), newNode(Token.EMPTY)));\n+        }\n+        var.addChildToBack(newNode(Token.VAR, obj, initializer));\n+      } else {\n+        var.addChildToBack(newNode(Token.VAR, name, initializer));\n+      }\n+    }\n+    return var;\n+  }\n+\n+  @Override\n+  public Node processVariableInitializer(VariableInitializer initializerNode) {\n+    throw new IllegalStateException(\"Unexpected visit to proces\n+\n     @Override\n     Node processForLoop(ForLoop loopNode) {\n       Node node = newNode(",
    "result_reason": "error: unclosed string literal",
    "test_result": "ERROR"
}