{
    "patch": "import org.mockito.cglib.proxy.Callback;\nimport org.mockito.cglib.proxy.Factory;\n\nimport java.lang.reflect.Method;\n\nimport static org.mockito.Mockito.CALLS_REAL_METHODS;\nimport static org.mockito.Mockito.withSettings;\n\npublic <T> void resetMock(T mock) {\n    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n\n    MockSettings mockSettings = withSettings().defaultAnswer(CALLS_REAL_METHODS).spiedInstance(mock);\n\n    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) mockSettings);\n\n    if (mock instanceof Factory) {\n        ((Factory) mock).setCallbacks(new Callback[]{newFilter});\n    }\n}\n\nprivate <T> MockHandlerInterface<T> getMockHandler(T mock) {\n    return (MockHandlerInterface<T>) org.mockito.internal.util.MockUtil.getMockHandler(mock);\n}\n\nprivate static class MethodInterceptorFilter implements callback {\n    private final MockHandler<?> mockHandler;\n    private final MethodInterceptor interceptor;\n\n    public MethodInterceptorFilter(MockHandler<?> mockHandler, MockSettingsImpl mockSettings) {\n        this.mockHandler = mockHandler;\n        this.interceptor = new MethodInterceptorAdapter(mockSettings, mockHandler);\n    }\n\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        if (mockHandler.isMockedInstance(obj)) {\n            return interceptor.intercept(obj, method, args, proxy);\n        }\n        return proxy.invokeSuper(obj, args);\n    }\n}\n\nprivate static class MethodInterceptorAdapter implements MethodInterceptor {\n    private final MockSettingsImpl mockSettings;\n    private final MockHandler<?> mockHandler;\n\n    public MethodInterceptorAdapter(MockSettingsImpl mockSettings, MockHandler<?> mockHandler) {\n        this.mockSettings = mockSettings;\n        this.mockHandler = mockHandler;\n    }\n\n    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n        Invocation invocation = new MockHandlerImpl.InvocationImpl(mockHandler.getMockSettings(), mockHandler, obj, method, args, mockHandler.getMockCreationSettings());\n        return mockSettings.getInvocationListeners().get(0).reportInvocation(invocation);\n    }\n}\n\nprivate static interface MockHandlerInterface<T> {\n    MockSettings getMockSettings();\n\n    Object handle(Invocation invocation) throws Throwable;\n\n    T getMock();\n\n    CreationSettings getMockCreationSettings();\n\n    void setAnswersForStubbing(Answers answer);\n\n    void setThrowableForVoidMethod(Throwable throwable);\n\n    boolean isTypeMocked(Class<?> type);\n\n    boolean isMockedInstance(Object object);\n\n    void validateMockitoUsage();\n\n    void verifyNoMoreInteractions();\n}\n\nprivate static class MockHandler<T> implements MockHandlerInterface<T> {\n    private final T mock;\n    private final MockSettings mockSettings;\n    private final CreationSettings mockCreationSettings;\n    private final MockCreationSettings creationSettings;\n    private final AnswerContainer defaultAnswerContainer;\n    private final boolean stubOnly;\n    private final int globalOrder;\n    private final boolean handlesInteractions;\n    private final VerifiableInteractionsMode verifiableInteractionsMode;\n    private final boolean extraInterfacesSupported;\n    private final ObjenesisRequiredState objenesisState;\n    private final ConcurrentHashMap<MockMethodKey, MockMethodInterceptor> interceptors = new ConcurrentHashMap<MockMethodKey, MockMethodInterceptor>();\n\n    public MockHandler(MockHandlerInterface<? super T> parent, T mock, MockSettings mockSettings, CreationSettings mockCreationSettings, MockCreationSettings creationSettings, AnswerContainer defaultAnswerContainer, boolean stubOnly, int globalOrder) {\n        this.mock = mock;\n        this.mockSettings = mockSettings;\n        this.mockCreationSettings = mockCreationSettings;\n        this.creationSettings = creationSettings;\n        this.defaultAnswerContainer = defaultAnswerContainer;\n        this.stubOnly = stubOnly;\n        this.handlesInteractions = !stubOnly || mockSettings.isSerializable();\n        this.globalOrder = globalOrder;\n        this.verifiableInteractionsMode = mockSettings.getVerifiableInteractionsMode();\n        this.extraInterfacesSupported = mockSettings.isExtraInterfacesEnabled();\n        this.objenesisState = mockCreationSettings.isUsingConstructor() ? ObjenesisRequiredState.STRICT : ObjenesisRequiredState.NO;\n        parent.handle(new RegisterMockInvocation(mock));\n    }\n\n    public MockHandler(MockHandler<?> parent) {\n        this(\n                parent,\n                parent.mock,\n                parent.mockSettings,\n                parent.mockCreationSettings,\n                parent.creationSettings,\n                parent.defaultAnswerContainer,\n                parent.stubOnly,\n                parent.globalOrder\n        );\n    }\n    \n    public MockSettings getMockSettings() {\n        return mockSettings;\n    }\n\n    public Object handle(Invocation invocation) throws Throwable {\n        return findMockMethodInterceptor(invocation).intercept(invocation);\n    }\n\n    public T getMock() {\n        return mock;\n    }\n\n    public CreationSettings getMockCreationSettings() {\n        return mockCreationSettings;\n    }\n\n    public void setAnswersForStubbing(Answers answer) {\n        defaultAnswerContainer.setAnswersForStubbing(answer);\n    }\n\n    public void setThrowableForVoidMethod(Throwable throwable) {\n        defaultAnswerContainer.setThrowableForVoidMethod(throwable);\n    }\n\n    public boolean isTypeMocked(Class<?> type) {\n        return mock.getClass().equals(type) || type.isAssignableFrom(mock.getClass());\n    }\n\n    public boolean isMockedInstance(Object object) {\n        return object == mock || mockSettings.isSerializable() && mock.equals(object);\n    }\n\n    public void validateMockitoUsage() {\n        mockitoSessionHandler.validateState();\n    }\n\n    public void verifyNoMoreInteractions() {\n        List<MockMethod> allInvocations = getAllMockMethodInterceptors();\n\n        allInvocations\n                .stream()\n                .forEach(MockMethod::verifyNoMoreInvocations);\n    }\n\n    private ArrayList<MockMethod> getAllMockMethodInterceptors() {\n        ArrayList<MockMethod> mockMethods = new ArrayList<>(interceptors.size());\n        for (MockMethodInterceptor mockMethod : interceptors.values()) {\n            mockMethods.add(mockMethod.getMockMethod());\n        }\n        return mockMethods;\n    }\n\n    private MockMethodInterceptor findMockMethodInterceptor(Invocation invocation) {\n        MockMethodKey mockMethodKey = new MockMethodKey(invocation.getMethod(), creationSettings.getInitiatedClass(), stubOnly, globalOrder, extraInterfacesSupported, objenesisState);\n        MockMethodInterceptor interceptor = interceptors.get(mockMethodKey);\n\n        if (interceptor != null) {\n            return interceptor;\n        } else {\n            synchronized (interceptors) {\n                interceptor = interceptors.get(mockMethodKey);\n                if (interceptor == null) {\n                    interceptor = createMockMethodInterceptor(invocation, mockMethodKey);\n                    interceptors.put(mockMethodKey, interceptor);\n                }\n            }\n            return interceptor;\n        }\n    }\n\n    private MockMethodInterceptor createMockMethodInterceptor(Invocation invocation, MockMethodKey mockMethodKey) {\n        if (handlesInteractions) {\n            VerifiableMethod mockMethod = new VerifiableMethod(mockMethodKey);\n            MockitoCore mockitoCore = new MockitoCore(mockitoSessionBuilder, mockitoSessionHandler);\n            InvocationContainerImpl invocationContainer = new InvocationContainerImpl((Object) mock, mockMethod);\n\n            return new MockMethodInterceptor(invocationContainer, defaultAnswerContainer.get(), invocationMatchersBinder, invocation, mockitoCore, findInteractionsMode(mockMethod));\n        } else {\n            return new StubOnlyMockMethodInterceptor();\n        }\n    }\n\n    private VerifiableInteractionsMode findInteractionsMode(VerifiableMethod mockMethod) {\n        return verifiableInteractionsMode.overrideGlobalSettings(mockMethod.getMockSettings());\n    }\n\n    private static class RegisterMockInvocation implements Invocation {\n        private final Object mock;\n\n        public RegisterMockInvocation(Object mock) {\n            this.mock = mock;\n        }\n\n        public Object getMock() {\n            return mock;\n        }\n\n        public Method getMethod() {\n            try {\n                return MockHandler.class.getMethod(\"handle\", Invocation.class);\n            } catch (NoSuchMethodException e) {\n                throw new RuntimeException(e);\n            }\n        }\n\n        public Object[] getArguments() {\n            return new Object[]{this};\n        }\n\n        public MockitoHint getMockitoHint() {\n            return null;\n        }\n\n        public void markVerified() {}\n    }\n}\n\nenum ObjenesisRequiredState {\n    STRICT,\n    NO\n}\n\ninterface AnswerContainer {\n\n    Answer<Object> get();\n\n    void setAnswersForStubbing(Answers answer);\n\n    void setThrowableForVoidMethod(Throwable throwable);\n}\n\nclass DefaultAnswerContainer implements AnswerContainer {\n\n    private final Answer<Object> defaultAnswer;\n\n    public DefaultAnswerContainer(Answer<Object> defaultAnswer) {\n        this.defaultAnswer = defaultAnswer;\n    }\n\n    public Answer<Object> get() {\n        return defaultAnswer;\n    }\n\n    public void setAnswersForStubbing(Answers answer) {}\n\n    public void setThrowableForVoidMethod(Throwable throwable) {}\n}\n\ninterface MockitoSessionBuilder {\n    MockitoSession startMocking();\n}\n\ninterface InvocationMatcher {\n\n    boolean matches(Invocation invocation);\n\n    int getLastInvocationSequenceNumber();\n\n}\n\ninterface MethodInterceptor {\n\n    Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;\n\n}\n\nclass InvocationContainerImpl implements MockMethodInterceptor.Filtering {\n\n    private final Object mock;\n    private final VerifiableMethod mockMethod;\n    private final List<Invocation> registeredInvocations;\n\n    public InvocationContainerImpl(Object mock, VerifiableMethod mockMethod) {\n        this.mock = mock;\n        this.mockMethod = mockMethod;\n        this.registeredInvocations = new ArrayList<Invocation>();\n    }\n\n    public Object intercept(Invocation invocation) throws Throwable {\n        registeredInvocations.add(invocation);\n        return mockMethod.getAnswerFor(invocation).answer(invocation);\n    }\n\n    public void validateFullyMocked() throws MockitoAssertionError {\n        Map<InvocationMatcher, List<Invocation>> groupedByMatchers = groupInvocationsByMatchers(registeredInvocations);\n        for (Map.Entry<InvocationMatcher, List<Invocation>> entry : groupedByMatchers.entrySet()) {\n            InvocationMatcher matcher = entry.getKey();\n            List<Invocation> invocations = entry.getValue();\n            if (!matcher.matches(invocations)) {\n                throw getInvalidUseOfMatchersAdditionalException(matcher, invocations);\n            }\n        }\n    }\n\n    public Map<InvocationMatcher, List<Invocation>> groupInvocationsByMatchers(List<Invocation> invocations) {\n        Map<InvocationMatcher, List<Invocation>> groupedByMatchers = new LinkedHashMap<InvocationMatcher, List<Invocation>>();\n        for (Invocation i : invocations) {\n            InvocationMatcher matcher = i.getMatchers().getMatchersProxy();\n            List<Invocation> matching = groupedByMatchers.get(matcher);\n            if (matching == null) {\n                matching = new LinkedList<Invocation>();\n                groupedByMatchers.put(matcher, matching);\n            }\n            matching.add(i);\n        }\n        return groupedByMatchers;\n    }\n\n    public MockControl getControl() {\n        return new MockControl(mockMethod.getMockSettings(), this);\n    }\n\n    public VerifiableMethod getMethod() {\n        return mockMethod;\n    }\n\n    public Object getMock() {\n        return mock;\n    }\n\n    public List<Invocation> getRegisteredInvocations() {\n        return registeredInvocations;\n    }\n\n    public void assertVerifiable() throws MockitoAssertionError {\n        AssertionErrors.assertVerifiable(this);\n    }\n\n    public String toString() {\n        return mock.getClass().getSimpleName() + \"-InvocationContainer:\" + mockMethod;\n    }\n}\n\nclass InvocationImpl implements Invocation, Locator {\n\n    private final Object mock;\n    private final Method method;\n    private final Object[] arguments;\n    private final CreationSettings creationSettings;\n    private final List<Matcher> matchers;\n    private final InvocationFactory invocationFactory;\n    private final MockHandlerImpl mockHandler;\n    private Integer sequenceNumber;\n    private final MockitoHint hint;\n\n    public InvocationImpl(final MockSettings mockSettings, final MockHandlerImpl mockHandler, final Object mock, final Method method, final Object[] arguments,\n                          final CreationSettings creationSettings) {\n        this(mockSettings,\n             mockHandler,\n             mock,\n             method,\n             arguments,\n             new LinkedMatchersExtractor().getMatchers(arguments),\n             creationSettings,\n             new ThreadSafeMockingProgress(),\n             new InvocationFactory(),\n             null //TODO\n        );\n    }\n\n    public InvocationImpl(final MockSettings mockSettings, final MockHandlerImpl mockHandler, final Object mock, final Method method, final Object[] arguments,\n                          final List<Matcher> matchers, final CreationSettings creationSettings, final MockingProgress mockitoState,\n                          final InvocationFactory invocationFactory, MockitoHint hint) {\n        this.mock = mock;\n        this.method = method;\n        this.arguments = arguments;\n        this.creationSettings = creationSettings;\n        this.matchers = matchers;\n        this.invocationFactory = invocationFactory;\n        this.mockHandler = mockHandler;\n        this.hint = hint;\n    }\n\n    public Object[] getArguments() {\n        return arguments;\n    }\n\n    public Method getMethod() {\n        return method;\n    }\n\n    public Object getMock() {\n        return mock;\n    }\n\n    public List<Matcher> getMatchers() {\n        return matchers;\n    }\n\n    public Invocation buildWithArguments(Object[] newArguments) {\n        return invocationFactory.createInvocation(mock, method, newArguments, creationSettings);\n    }\n\n    public InvocationMatcher getMatchersProxy() {\n        return new InvocationMatcher() {\n            public boolean matches(Invocation invocation) {\n                return matchersEqual(invocation.getMatchers(), getMatchers());\n            }\n\n            public int getLastInvocationSequenceNumber() {\n                return mockHandler.getLastInvocationSequenceNumber(InvocationImpl.this);\n            }\n        };\n    }\n\n    public boolean matchersEqual(List<Matcher> first, List<Matcher> second) {\n        if (first == null && second == null) {\n            return true;\n        }\n        if (first == null || second == null) {\n            return false;\n        }\n        if (first.size() != second.size()) {\n            return false;\n        }\n        for (int i = 0; i < first.size(); i++) {\n            if (!first.get(i).equals(second.get(i))) {\n                return false;\n            }\n        }\n        return true;\n    }\n\n    public String toString() {\n        return \"Invocation:\\n\" +\n               new InvocationMatcherPrinter(this).printMatchers() +\n               new LocationImpl().toString() +\n               \"\\n\";\n    }\n\n    public synchronized int getSequenceNumber() {\n        if (sequenceNumber == null) {\n            sequenceNumber = mockHandler.nextSequenceNumber();\n        }\n        return sequenceNumber;\n    }\n\n    public Object callRealMethod() throws Throwable {\n        try {\n            return getMethod().invoke(getMock(), getArguments());\n        } catch (Throwable throwable){\n            new ThrowableExceptionsAccessor(throwable).remove(MockitoException.class);\n            new ThrowableExceptionsAccessor(throwable).remove(InvocationTargetException.class);\n            throw throwable;\n        }\n    }\n\n    public MockitoHint getMockitoHint() {\n        return hint;\n    }\n}\n\nclass InvocationMatcherPrinter {\n\n    private final Invocation invocation;\n\n    public InvocationMatcherPrinter(Invocation invocation) {\n        this.invocation = invocation;\n    }\n\n    public String printMatchers() {\n        StringBuilder sb = new StringBuilder(\"Methods called on mock:\\n\");\n        sb.append(\"mock.\").append(invocation.getMethod().getName()).append(\"(\");\n\n        for (Matcher matcher : invocation.getMatchers()) {\n            sb.append(describing(matcher)).append(\", \");\n        }\n\n        if (!invocation.getMatchers().isEmpty()) {\n            sb.setLength(sb.length() - 2);\n        }\n\n        sb.append(\");\\n\");\n        return sb.toString();\n    }\n\n    private String describing(Matcher matcher) {\n        try {\n            return matcher.toString();\n        } catch (Exception e) {\n            return \"<toString() failure: \" + e + \">\";\n        }\n    }\n}\n\ninterface MockitoSessionHandler {\n\n    void validateState();\n}\n\nclass ThreadSafeMockingProgress extends StackableMockingProgress {\n\n    public ThreadSafeMockingProgress() {}\n\n    private ThreadLocal<OngoingStubbing> localOngoingStubbing = new InheritableThreadLocal<>(\n            ()->super.ongoingStubbing\n    );\n\n    public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n        localOngoingStubbing.set(ongoingStubbing);\n    }\n\n    public OngoingStubbing pullOngoingStubbing() {\n        OngoingStubbing ret = localOngoingStubbing.get();\n        localOngoingStubbing.remove();\n        return ret;\n    }\n}\n\ninterface MockingProgress {\n\n    void reportOngoingStubbing(OngoingStubbing ongoingStubbing);\n\n    void validateState();\n\n    /**\n     * Override with empty method by default. If it's a verification, MockitoState\n     * will verify the mocks and report the error message if verification failed\n     */\n    void verificationStarted(VerificationMode verify);\n\n    /**\n     * Override with empty method by default. If it's a verification, MockitoState\n     * will verify the mocks and report the error message if verification failed\n     */\n    void verificationFinished(VerificationMode verify);\n\n    OngoingStubbing pullOngoingStubbing();\n}\n\nabstract class StackableMockingProgress implements MockingProgress {\n\n    final Deque<OngoingStubbing> ongoingStubbingStack = new LinkedList<>();\n\n    OngoingStubbing ongoingStubbing;\n\n    public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n        ongoingStubbingStack.push(ongoingStubbing);\n        this.ongoingStubbing = ongoingStubbing;\n    }\n\n    public OngoingStubbing pullOngoingStubbing() {\n        return ongoingStubbingStack.pop();\n    }\n\n    /**\n     * Called *before* verification starts in order to enforce the verification mode.",
    "patch_diff": "diff --git a/src/org/mockito/internal/util/MockUtil.java b/src/org/mockito/internal/util/MockUtil.java\nindex 3c20596b0..13bd104e9 100644\n--- a/src/org/mockito/internal/util/MockUtil.java\n+++ b/src/org/mockito/internal/util/MockUtil.java\n@@ -59,12 +59,575 @@ public class MockUtil {\n         return mock;\n     }\n \n-    public <T> void resetMock(T mock) {\n-        MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n-        MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n-        MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) org.mockito.Mockito.withSettings().defaultAnswer(org.mockito.Mockito.RETURNS_DEFAULTS));\n-        ((Factory) mock).setCallback(0, newFilter);\n-    }\n+\n+import org.mockito.cglib.proxy.Callback;\n+import org.mockito.cglib.proxy.Factory;\n+\n+import java.lang.reflect.Method;\n+\n+import static org.mockito.Mockito.CALLS_REAL_METHODS;\n+import static org.mockito.Mockito.withSettings;\n+\n+public <T> void resetMock(T mock) {\n+    MockHandlerInterface<T> oldMockHandler = getMockHandler(mock);\n+\n+    MockSettings mockSettings = withSettings().defaultAnswer(CALLS_REAL_METHODS).spiedInstance(mock);\n+\n+    MockHandler<T> newMockHandler = new MockHandler<T>(oldMockHandler);\n+    MethodInterceptorFilter newFilter = new MethodInterceptorFilter(newMockHandler, (MockSettingsImpl) mockSettings);\n+\n+    if (mock instanceof Factory) {\n+        ((Factory) mock).setCallbacks(new Callback[]{newFilter});\n+    }\n+}\n+\n+private <T> MockHandlerInterface<T> getMockHandler(T mock) {\n+    return (MockHandlerInterface<T>) org.mockito.internal.util.MockUtil.getMockHandler(mock);\n+}\n+\n+private static class MethodInterceptorFilter implements callback {\n+    private final MockHandler<?> mockHandler;\n+    private final MethodInterceptor interceptor;\n+\n+    public MethodInterceptorFilter(MockHandler<?> mockHandler, MockSettingsImpl mockSettings) {\n+        this.mockHandler = mockHandler;\n+        this.interceptor = new MethodInterceptorAdapter(mockSettings, mockHandler);\n+    }\n+\n+    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+        if (mockHandler.isMockedInstance(obj)) {\n+            return interceptor.intercept(obj, method, args, proxy);\n+        }\n+        return proxy.invokeSuper(obj, args);\n+    }\n+}\n+\n+private static class MethodInterceptorAdapter implements MethodInterceptor {\n+    private final MockSettingsImpl mockSettings;\n+    private final MockHandler<?> mockHandler;\n+\n+    public MethodInterceptorAdapter(MockSettingsImpl mockSettings, MockHandler<?> mockHandler) {\n+        this.mockSettings = mockSettings;\n+        this.mockHandler = mockHandler;\n+    }\n+\n+    public Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable {\n+        Invocation invocation = new MockHandlerImpl.InvocationImpl(mockHandler.getMockSettings(), mockHandler, obj, method, args, mockHandler.getMockCreationSettings());\n+        return mockSettings.getInvocationListeners().get(0).reportInvocation(invocation);\n+    }\n+}\n+\n+private static interface MockHandlerInterface<T> {\n+    MockSettings getMockSettings();\n+\n+    Object handle(Invocation invocation) throws Throwable;\n+\n+    T getMock();\n+\n+    CreationSettings getMockCreationSettings();\n+\n+    void setAnswersForStubbing(Answers answer);\n+\n+    void setThrowableForVoidMethod(Throwable throwable);\n+\n+    boolean isTypeMocked(Class<?> type);\n+\n+    boolean isMockedInstance(Object object);\n+\n+    void validateMockitoUsage();\n+\n+    void verifyNoMoreInteractions();\n+}\n+\n+private static class MockHandler<T> implements MockHandlerInterface<T> {\n+    private final T mock;\n+    private final MockSettings mockSettings;\n+    private final CreationSettings mockCreationSettings;\n+    private final MockCreationSettings creationSettings;\n+    private final AnswerContainer defaultAnswerContainer;\n+    private final boolean stubOnly;\n+    private final int globalOrder;\n+    private final boolean handlesInteractions;\n+    private final VerifiableInteractionsMode verifiableInteractionsMode;\n+    private final boolean extraInterfacesSupported;\n+    private final ObjenesisRequiredState objenesisState;\n+    private final ConcurrentHashMap<MockMethodKey, MockMethodInterceptor> interceptors = new ConcurrentHashMap<MockMethodKey, MockMethodInterceptor>();\n+\n+    public MockHandler(MockHandlerInterface<? super T> parent, T mock, MockSettings mockSettings, CreationSettings mockCreationSettings, MockCreationSettings creationSettings, AnswerContainer defaultAnswerContainer, boolean stubOnly, int globalOrder) {\n+        this.mock = mock;\n+        this.mockSettings = mockSettings;\n+        this.mockCreationSettings = mockCreationSettings;\n+        this.creationSettings = creationSettings;\n+        this.defaultAnswerContainer = defaultAnswerContainer;\n+        this.stubOnly = stubOnly;\n+        this.handlesInteractions = !stubOnly || mockSettings.isSerializable();\n+        this.globalOrder = globalOrder;\n+        this.verifiableInteractionsMode = mockSettings.getVerifiableInteractionsMode();\n+        this.extraInterfacesSupported = mockSettings.isExtraInterfacesEnabled();\n+        this.objenesisState = mockCreationSettings.isUsingConstructor() ? ObjenesisRequiredState.STRICT : ObjenesisRequiredState.NO;\n+        parent.handle(new RegisterMockInvocation(mock));\n+    }\n+\n+    public MockHandler(MockHandler<?> parent) {\n+        this(\n+                parent,\n+                parent.mock,\n+                parent.mockSettings,\n+                parent.mockCreationSettings,\n+                parent.creationSettings,\n+                parent.defaultAnswerContainer,\n+                parent.stubOnly,\n+                parent.globalOrder\n+        );\n+    }\n+    \n+    public MockSettings getMockSettings() {\n+        return mockSettings;\n+    }\n+\n+    public Object handle(Invocation invocation) throws Throwable {\n+        return findMockMethodInterceptor(invocation).intercept(invocation);\n+    }\n+\n+    public T getMock() {\n+        return mock;\n+    }\n+\n+    public CreationSettings getMockCreationSettings() {\n+        return mockCreationSettings;\n+    }\n+\n+    public void setAnswersForStubbing(Answers answer) {\n+        defaultAnswerContainer.setAnswersForStubbing(answer);\n+    }\n+\n+    public void setThrowableForVoidMethod(Throwable throwable) {\n+        defaultAnswerContainer.setThrowableForVoidMethod(throwable);\n+    }\n+\n+    public boolean isTypeMocked(Class<?> type) {\n+        return mock.getClass().equals(type) || type.isAssignableFrom(mock.getClass());\n+    }\n+\n+    public boolean isMockedInstance(Object object) {\n+        return object == mock || mockSettings.isSerializable() && mock.equals(object);\n+    }\n+\n+    public void validateMockitoUsage() {\n+        mockitoSessionHandler.validateState();\n+    }\n+\n+    public void verifyNoMoreInteractions() {\n+        List<MockMethod> allInvocations = getAllMockMethodInterceptors();\n+\n+        allInvocations\n+                .stream()\n+                .forEach(MockMethod::verifyNoMoreInvocations);\n+    }\n+\n+    private ArrayList<MockMethod> getAllMockMethodInterceptors() {\n+        ArrayList<MockMethod> mockMethods = new ArrayList<>(interceptors.size());\n+        for (MockMethodInterceptor mockMethod : interceptors.values()) {\n+            mockMethods.add(mockMethod.getMockMethod());\n+        }\n+        return mockMethods;\n+    }\n+\n+    private MockMethodInterceptor findMockMethodInterceptor(Invocation invocation) {\n+        MockMethodKey mockMethodKey = new MockMethodKey(invocation.getMethod(), creationSettings.getInitiatedClass(), stubOnly, globalOrder, extraInterfacesSupported, objenesisState);\n+        MockMethodInterceptor interceptor = interceptors.get(mockMethodKey);\n+\n+        if (interceptor != null) {\n+            return interceptor;\n+        } else {\n+            synchronized (interceptors) {\n+                interceptor = interceptors.get(mockMethodKey);\n+                if (interceptor == null) {\n+                    interceptor = createMockMethodInterceptor(invocation, mockMethodKey);\n+                    interceptors.put(mockMethodKey, interceptor);\n+                }\n+            }\n+            return interceptor;\n+        }\n+    }\n+\n+    private MockMethodInterceptor createMockMethodInterceptor(Invocation invocation, MockMethodKey mockMethodKey) {\n+        if (handlesInteractions) {\n+            VerifiableMethod mockMethod = new VerifiableMethod(mockMethodKey);\n+            MockitoCore mockitoCore = new MockitoCore(mockitoSessionBuilder, mockitoSessionHandler);\n+            InvocationContainerImpl invocationContainer = new InvocationContainerImpl((Object) mock, mockMethod);\n+\n+            return new MockMethodInterceptor(invocationContainer, defaultAnswerContainer.get(), invocationMatchersBinder, invocation, mockitoCore, findInteractionsMode(mockMethod));\n+        } else {\n+            return new StubOnlyMockMethodInterceptor();\n+        }\n+    }\n+\n+    private VerifiableInteractionsMode findInteractionsMode(VerifiableMethod mockMethod) {\n+        return verifiableInteractionsMode.overrideGlobalSettings(mockMethod.getMockSettings());\n+    }\n+\n+    private static class RegisterMockInvocation implements Invocation {\n+        private final Object mock;\n+\n+        public RegisterMockInvocation(Object mock) {\n+            this.mock = mock;\n+        }\n+\n+        public Object getMock() {\n+            return mock;\n+        }\n+\n+        public Method getMethod() {\n+            try {\n+                return MockHandler.class.getMethod(\"handle\", Invocation.class);\n+            } catch (NoSuchMethodException e) {\n+                throw new RuntimeException(e);\n+            }\n+        }\n+\n+        public Object[] getArguments() {\n+            return new Object[]{this};\n+        }\n+\n+        public MockitoHint getMockitoHint() {\n+            return null;\n+        }\n+\n+        public void markVerified() {}\n+    }\n+}\n+\n+enum ObjenesisRequiredState {\n+    STRICT,\n+    NO\n+}\n+\n+interface AnswerContainer {\n+\n+    Answer<Object> get();\n+\n+    void setAnswersForStubbing(Answers answer);\n+\n+    void setThrowableForVoidMethod(Throwable throwable);\n+}\n+\n+class DefaultAnswerContainer implements AnswerContainer {\n+\n+    private final Answer<Object> defaultAnswer;\n+\n+    public DefaultAnswerContainer(Answer<Object> defaultAnswer) {\n+        this.defaultAnswer = defaultAnswer;\n+    }\n+\n+    public Answer<Object> get() {\n+        return defaultAnswer;\n+    }\n+\n+    public void setAnswersForStubbing(Answers answer) {}\n+\n+    public void setThrowableForVoidMethod(Throwable throwable) {}\n+}\n+\n+interface MockitoSessionBuilder {\n+    MockitoSession startMocking();\n+}\n+\n+interface InvocationMatcher {\n+\n+    boolean matches(Invocation invocation);\n+\n+    int getLastInvocationSequenceNumber();\n+\n+}\n+\n+interface MethodInterceptor {\n+\n+    Object intercept(Object obj, Method method, Object[] args, MethodProxy proxy) throws Throwable;\n+\n+}\n+\n+class InvocationContainerImpl implements MockMethodInterceptor.Filtering {\n+\n+    private final Object mock;\n+    private final VerifiableMethod mockMethod;\n+    private final List<Invocation> registeredInvocations;\n+\n+    public InvocationContainerImpl(Object mock, VerifiableMethod mockMethod) {\n+        this.mock = mock;\n+        this.mockMethod = mockMethod;\n+        this.registeredInvocations = new ArrayList<Invocation>();\n+    }\n+\n+    public Object intercept(Invocation invocation) throws Throwable {\n+        registeredInvocations.add(invocation);\n+        return mockMethod.getAnswerFor(invocation).answer(invocation);\n+    }\n+\n+    public void validateFullyMocked() throws MockitoAssertionError {\n+        Map<InvocationMatcher, List<Invocation>> groupedByMatchers = groupInvocationsByMatchers(registeredInvocations);\n+        for (Map.Entry<InvocationMatcher, List<Invocation>> entry : groupedByMatchers.entrySet()) {\n+            InvocationMatcher matcher = entry.getKey();\n+            List<Invocation> invocations = entry.getValue();\n+            if (!matcher.matches(invocations)) {\n+                throw getInvalidUseOfMatchersAdditionalException(matcher, invocations);\n+            }\n+        }\n+    }\n+\n+    public Map<InvocationMatcher, List<Invocation>> groupInvocationsByMatchers(List<Invocation> invocations) {\n+        Map<InvocationMatcher, List<Invocation>> groupedByMatchers = new LinkedHashMap<InvocationMatcher, List<Invocation>>();\n+        for (Invocation i : invocations) {\n+            InvocationMatcher matcher = i.getMatchers().getMatchersProxy();\n+            List<Invocation> matching = groupedByMatchers.get(matcher);\n+            if (matching == null) {\n+                matching = new LinkedList<Invocation>();\n+                groupedByMatchers.put(matcher, matching);\n+            }\n+            matching.add(i);\n+        }\n+        return groupedByMatchers;\n+    }\n+\n+    public MockControl getControl() {\n+        return new MockControl(mockMethod.getMockSettings(), this);\n+    }\n+\n+    public VerifiableMethod getMethod() {\n+        return mockMethod;\n+    }\n+\n+    public Object getMock() {\n+        return mock;\n+    }\n+\n+    public List<Invocation> getRegisteredInvocations() {\n+        return registeredInvocations;\n+    }\n+\n+    public void assertVerifiable() throws MockitoAssertionError {\n+        AssertionErrors.assertVerifiable(this);\n+    }\n+\n+    public String toString() {\n+        return mock.getClass().getSimpleName() + \"-InvocationContainer:\" + mockMethod;\n+    }\n+}\n+\n+class InvocationImpl implements Invocation, Locator {\n+\n+    private final Object mock;\n+    private final Method method;\n+    private final Object[] arguments;\n+    private final CreationSettings creationSettings;\n+    private final List<Matcher> matchers;\n+    private final InvocationFactory invocationFactory;\n+    private final MockHandlerImpl mockHandler;\n+    private Integer sequenceNumber;\n+    private final MockitoHint hint;\n+\n+    public InvocationImpl(final MockSettings mockSettings, final MockHandlerImpl mockHandler, final Object mock, final Method method, final Object[] arguments,\n+                          final CreationSettings creationSettings) {\n+        this(mockSettings,\n+             mockHandler,\n+             mock,\n+             method,\n+             arguments,\n+             new LinkedMatchersExtractor().getMatchers(arguments),\n+             creationSettings,\n+             new ThreadSafeMockingProgress(),\n+             new InvocationFactory(),\n+             null //TODO\n+        );\n+    }\n+\n+    public InvocationImpl(final MockSettings mockSettings, final MockHandlerImpl mockHandler, final Object mock, final Method method, final Object[] arguments,\n+                          final List<Matcher> matchers, final CreationSettings creationSettings, final MockingProgress mockitoState,\n+                          final InvocationFactory invocationFactory, MockitoHint hint) {\n+        this.mock = mock;\n+        this.method = method;\n+        this.arguments = arguments;\n+        this.creationSettings = creationSettings;\n+        this.matchers = matchers;\n+        this.invocationFactory = invocationFactory;\n+        this.mockHandler = mockHandler;\n+        this.hint = hint;\n+    }\n+\n+    public Object[] getArguments() {\n+        return arguments;\n+    }\n+\n+    public Method getMethod() {\n+        return method;\n+    }\n+\n+    public Object getMock() {\n+        return mock;\n+    }\n+\n+    public List<Matcher> getMatchers() {\n+        return matchers;\n+    }\n+\n+    public Invocation buildWithArguments(Object[] newArguments) {\n+        return invocationFactory.createInvocation(mock, method, newArguments, creationSettings);\n+    }\n+\n+    public InvocationMatcher getMatchersProxy() {\n+        return new InvocationMatcher() {\n+            public boolean matches(Invocation invocation) {\n+                return matchersEqual(invocation.getMatchers(), getMatchers());\n+            }\n+\n+            public int getLastInvocationSequenceNumber() {\n+                return mockHandler.getLastInvocationSequenceNumber(InvocationImpl.this);\n+            }\n+        };\n+    }\n+\n+    public boolean matchersEqual(List<Matcher> first, List<Matcher> second) {\n+        if (first == null && second == null) {\n+            return true;\n+        }\n+        if (first == null || second == null) {\n+            return false;\n+        }\n+        if (first.size() != second.size()) {\n+            return false;\n+        }\n+        for (int i = 0; i < first.size(); i++) {\n+            if (!first.get(i).equals(second.get(i))) {\n+                return false;\n+            }\n+        }\n+        return true;\n+    }\n+\n+    public String toString() {\n+        return \"Invocation:\\n\" +\n+               new InvocationMatcherPrinter(this).printMatchers() +\n+               new LocationImpl().toString() +\n+               \"\\n\";\n+    }\n+\n+    public synchronized int getSequenceNumber() {\n+        if (sequenceNumber == null) {\n+            sequenceNumber = mockHandler.nextSequenceNumber();\n+        }\n+        return sequenceNumber;\n+    }\n+\n+    public Object callRealMethod() throws Throwable {\n+        try {\n+            return getMethod().invoke(getMock(), getArguments());\n+        } catch (Throwable throwable){\n+            new ThrowableExceptionsAccessor(throwable).remove(MockitoException.class);\n+            new ThrowableExceptionsAccessor(throwable).remove(InvocationTargetException.class);\n+            throw throwable;\n+        }\n+    }\n+\n+    public MockitoHint getMockitoHint() {\n+        return hint;\n+    }\n+}\n+\n+class InvocationMatcherPrinter {\n+\n+    private final Invocation invocation;\n+\n+    public InvocationMatcherPrinter(Invocation invocation) {\n+        this.invocation = invocation;\n+    }\n+\n+    public String printMatchers() {\n+        StringBuilder sb = new StringBuilder(\"Methods called on mock:\\n\");\n+        sb.append(\"mock.\").append(invocation.getMethod().getName()).append(\"(\");\n+\n+        for (Matcher matcher : invocation.getMatchers()) {\n+            sb.append(describing(matcher)).append(\", \");\n+        }\n+\n+        if (!invocation.getMatchers().isEmpty()) {\n+            sb.setLength(sb.length() - 2);\n+        }\n+\n+        sb.append(\");\\n\");\n+        return sb.toString();\n+    }\n+\n+    private String describing(Matcher matcher) {\n+        try {\n+            return matcher.toString();\n+        } catch (Exception e) {\n+            return \"<toString() failure: \" + e + \">\";\n+        }\n+    }\n+}\n+\n+interface MockitoSessionHandler {\n+\n+    void validateState();\n+}\n+\n+class ThreadSafeMockingProgress extends StackableMockingProgress {\n+\n+    public ThreadSafeMockingProgress() {}\n+\n+    private ThreadLocal<OngoingStubbing> localOngoingStubbing = new InheritableThreadLocal<>(\n+            ()->super.ongoingStubbing\n+    );\n+\n+    public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n+        localOngoingStubbing.set(ongoingStubbing);\n+    }\n+\n+    public OngoingStubbing pullOngoingStubbing() {\n+        OngoingStubbing ret = localOngoingStubbing.get();\n+        localOngoingStubbing.remove();\n+        return ret;\n+    }\n+}\n+\n+interface MockingProgress {\n+\n+    void reportOngoingStubbing(OngoingStubbing ongoingStubbing);\n+\n+    void validateState();\n+\n+    /**\n+     * Override with empty method by default. If it's a verification, MockitoState\n+     * will verify the mocks and report the error message if verification failed\n+     */\n+    void verificationStarted(VerificationMode verify);\n+\n+    /**\n+     * Override with empty method by default. If it's a verification, MockitoState\n+     * will verify the mocks and report the error message if verification failed\n+     */\n+    void verificationFinished(VerificationMode verify);\n+\n+    OngoingStubbing pullOngoingStubbing();\n+}\n+\n+abstract class StackableMockingProgress implements MockingProgress {\n+\n+    final Deque<OngoingStubbing> ongoingStubbingStack = new LinkedList<>();\n+\n+    OngoingStubbing ongoingStubbing;\n+\n+    public void reportOngoingStubbing(OngoingStubbing ongoingStubbing) {\n+        ongoingStubbingStack.push(ongoingStubbing);\n+        this.ongoingStubbing = ongoingStubbing;\n+    }\n+\n+    public OngoingStubbing pullOngoingStubbing() {\n+        return ongoingStubbingStack.pop();\n+    }\n+\n+    /**\n+     * Called *before* verification starts in order to enforce the verification mode.\n \n     private <T> MethodInterceptorFilter newMethodInterceptorFilter(MockSettingsImpl settings) {\n         MockHandler<T> mockHandler = new MockHandler<T>(settings);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}