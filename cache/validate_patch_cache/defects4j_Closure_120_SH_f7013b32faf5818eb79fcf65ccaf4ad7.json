{
    "patch": " private void transform() {\n    if (collector != null && variables.size() == 1) {\n      // Attempt to do a simple inline according to the value at the\n      // declaration.  This will only succeed if the declaration is\n      // actually a simple assignment.  We need to check if the assignment\n      // is of a function in order to prevent inlining cases such as\n      // \"var f = function() { ... }; f()\" but not to prevent\n      // \"var f = x ? function() { return 1; } : function() { return 2 };\n      // f()\".  The difference between these assignments is that only the\n      // former ever has a call applied to it directly, while the latter\n      // is always invoked directly, without being called in a separate\n      // expression.\n      Reference ref = variables.get(0).getInitializedReference();\n      if (ref != null &&\n          ref.isExpression() &&\n          ref.getNode().isFunction() &&\n          !NodeUtil.isInvocationTarget(ref.getNode())) {\n        CollectorInlining inliner =\n            new CollectorInlining(\n                ref.getNode(), collector, references, nodeComments);\n        Node call = inliner.inlineVariables();\n        if (call != null) {\n          Node parent = getCallParentNode(call);\n          if (parent != null) {\n            NodeUtil.tryToOptimizeCall(call, parent, compiler);\n          }\n          replacementCallParent.addChildToFront(call);\n          compiler.reportChangeToEnclosingScope(call);\n          return;\n        }\n      }\n    }\n    replacementCallParent.addChildToFront(statement);\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\nindex cdacc5f7..592ad629 100644\n--- a/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n+++ b/src/com/google/javascript/jscomp/ReferenceCollectingCallback.java\n@@ -428,6 +428,40 @@ class ReferenceCollectingCallback implements ScopedCallback,\n       for (BasicBlock block = ref.getBasicBlock();\n            block != null; block = block.getParent()) {\n         if (block.isFunction) {\n+ private void transform() {\n+    if (collector != null && variables.size() == 1) {\n+      // Attempt to do a simple inline according to the value at the\n+      // declaration.  This will only succeed if the declaration is\n+      // actually a simple assignment.  We need to check if the assignment\n+      // is of a function in order to prevent inlining cases such as\n+      // \"var f = function() { ... }; f()\" but not to prevent\n+      // \"var f = x ? function() { return 1; } : function() { return 2 };\n+      // f()\".  The difference between these assignments is that only the\n+      // former ever has a call applied to it directly, while the latter\n+      // is always invoked directly, without being called in a separate\n+      // expression.\n+      Reference ref = variables.get(0).getInitializedReference();\n+      if (ref != null &&\n+          ref.isExpression() &&\n+          ref.getNode().isFunction() &&\n+          !NodeUtil.isInvocationTarget(ref.getNode())) {\n+        CollectorInlining inliner =\n+            new CollectorInlining(\n+                ref.getNode(), collector, references, nodeComments);\n+        Node call = inliner.inlineVariables();\n+        if (call != null) {\n+          Node parent = getCallParentNode(call);\n+          if (parent != null) {\n+            NodeUtil.tryToOptimizeCall(call, parent, compiler);\n+          }\n+          replacementCallParent.addChildToFront(call);\n+          compiler.reportChangeToEnclosingScope(call);\n+          return;\n+        }\n+      }\n+    }\n+    replacementCallParent.addChildToFront(statement);\n+  }\n           break;\n         } else if (block.isLoop) {\n           return false;",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}