{
    "patch": "                // we need to search forward to find any new transition\n                // there can only be one in the whole Time Zone\n                long nextLocal = nextTransition(instantLocal);\n                long nextAdjusted = nextTransition(instantAdjusted);\n                if (nextLocal == nextAdjusted) {\n                    // there is no next transition, return the adjusted offset\n                    return offsetAdjusted;\n                } else {\n                    // there is a transition, need to determine which side of the boundary we are\n                    int lastBefore = getOffset(nextAdjusted - 1);\n                    int firstAfter = getOffset(nextAdjusted);\n                    if (lastBefore == offsetLocal && lastBefore == offsetAdjusted && firstAfter == offsetAdjusted) {\n                        // We are exactly on the last before and first after boundary, freedom to choose.\n                        // This will tend to mean continuing with the same policy.\n                    } else if (lastBefore == offsetLocal) {\n                        // We are just before the boundary\n                        if (offsetLocal < firstAfter) {\n                            // new offset is valid, return it\n                            return offsetAdjusted;\n                        }\n                        // offsetAdjusted is invalid, we must continue with offsetLocal\n                    } else if (firstAfter == offsetAdjusted) {\n                        // We are just after the boundary\n                        if (offsetAdjusted > lastBefore) {\n                            // new offset is valid, return it\n                            return offsetAdjusted;\n                        }\n                        // offsetAdjusted is invalid, we must continue with offsetLocal\n                    } else {\n                        // We are way over the boundary\n                        // There must have been a change of offset\n                        // Midnight is always a valid time, so we can always search\n                        // for the next local midnight to see which side of the\n                        // boundary we are on.\n                        long nextLocalMidnight = nextDay(instantLocal);\n                        long nextAdjustedMidnight = nextDay(instantAdjusted);\n                        if (nextLocalMidnight == nextAdjustedMidnight) {\n                            // we were unable to find a transition point\n                            // we will presume that we are on the side with the later offset\n                            // as that effectively extends the daylight\n                            return offsetAdjusted;\n                        } else {\n                            // we were able to find a transition point\n                            if (offsetLocal < offsetAdjusted) {\n                                return offsetAdjusted;\n                            } else {\n                                return offsetLocal;\n                            }\n                        }\n                    }\n                }",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..88b82202 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,57 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+                // we need to search forward to find any new transition\n+                // there can only be one in the whole Time Zone\n+                long nextLocal = nextTransition(instantLocal);\n+                long nextAdjusted = nextTransition(instantAdjusted);\n+                if (nextLocal == nextAdjusted) {\n+                    // there is no next transition, return the adjusted offset\n+                    return offsetAdjusted;\n+                } else {\n+                    // there is a transition, need to determine which side of the boundary we are\n+                    int lastBefore = getOffset(nextAdjusted - 1);\n+                    int firstAfter = getOffset(nextAdjusted);\n+                    if (lastBefore == offsetLocal && lastBefore == offsetAdjusted && firstAfter == offsetAdjusted) {\n+                        // We are exactly on the last before and first after boundary, freedom to choose.\n+                        // This will tend to mean continuing with the same policy.\n+                    } else if (lastBefore == offsetLocal) {\n+                        // We are just before the boundary\n+                        if (offsetLocal < firstAfter) {\n+                            // new offset is valid, return it\n+                            return offsetAdjusted;\n+                        }\n+                        // offsetAdjusted is invalid, we must continue with offsetLocal\n+                    } else if (firstAfter == offsetAdjusted) {\n+                        // We are just after the boundary\n+                        if (offsetAdjusted > lastBefore) {\n+                            // new offset is valid, return it\n+                            return offsetAdjusted;\n+                        }\n+                        // offsetAdjusted is invalid, we must continue with offsetLocal\n+                    } else {\n+                        // We are way over the boundary\n+                        // There must have been a change of offset\n+                        // Midnight is always a valid time, so we can always search\n+                        // for the next local midnight to see which side of the\n+                        // boundary we are on.\n+                        long nextLocalMidnight = nextDay(instantLocal);\n+                        long nextAdjustedMidnight = nextDay(instantAdjusted);\n+                        if (nextLocalMidnight == nextAdjustedMidnight) {\n+                            // we were unable to find a transition point\n+                            // we will presume that we are on the side with the later offset\n+                            // as that effectively extends the daylight\n+                            return offsetAdjusted;\n+                        } else {\n+                            // we were able to find a transition point\n+                            if (offsetLocal < offsetAdjusted) {\n+                                return offsetAdjusted;\n+                            } else {\n+                                return offsetLocal;\n+                            }\n+                        }\n+                    }\n+                }\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}