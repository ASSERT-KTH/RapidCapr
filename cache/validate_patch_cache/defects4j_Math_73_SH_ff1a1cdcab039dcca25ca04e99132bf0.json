{
    "patch": "        // check if interval brackets the root\n        if (yMin * yMax > 0) {\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n        }\n\n        double x0 = min;\n        double x1 = initial;\n        double x2 = max;\n        double y0 = yMin;\n        double y1 = yInitial;\n        double y2 = yMax;\n\n        // begin Brent iteration\n        double d = 0;\n        double e = 0;\n        double tol = 0;\n        double m = 0;\n        double p = 0;\n        double q = 0;\n        double r = 0;\n        double s = 0;\n        double fm = 0;\n        double fn = 0;\n        double fMid = 0;\n\n        int iMax = getMaximalIterationCount();\n        while (getIterations() < iMax) {\n            if (y1 * y2 < 0) {\n                // switch to inverse quadratic interpolation\n                if (Math.abs(y0) < Math.abs(y2)) {\n                    // swap x0 and x2, y0 and y2\n                    double tmp1 = x0; x0 = x2; x2 = tmp1;\n                    double tmp2 = y0; y0 = y2; y2 = tmp2;\n                }\n                // update d and e\n                double tmp3 = (x2 - x1) / (y1 / y2 - 1);\n                e = d;\n                d = tmp3;\n            } else {\n                // switch to bisection\n                d = e = (x2 - x1) / 2;\n            }\n            // apply correction factor to d\n            tol = getRelativeAccuracy() * Math.max(Math.abs(x1), Math.abs(x2));\n            if (Math.abs(d) > tol) {\n                m = x1 + d;\n                if (m < x1 || m > x2) {\n                    d = x1 < 0 ? -x1 * getRelativeAccuracy() : x1 * getRelativeAccuracy();\n                    m = x1 + d;\n                }\n            } else {\n                // tolerance is too small: simply use bissection\n                m = x1 + d;\n                tol = 2 * tol;\n            }\n            fm = f.value(m);\n            incIterationsCounter();\n            // update bisection values\n            if (fm * y1 < 0) {\n                x2 = m;\n                y2 = fm;\n                e = x1 - x2;\n            } else {\n                if (fm * y2 < 0) {\n                    x1 = m;\n                    y1 = fm;\n                    e = x2 - x1;\n                } else {\n                    // zero function value\n                    setResult(m, 0);\n                    return result;\n                }\n            }\n            // prepare next Newton-Raphson step\n            if (Math.abs(e) > tol) {\n                p = (y1 - y2) / (x1 - x2);\n                q = (y1 - fm) / (x1 - m);\n                r = (y2 - fm) / (x2 - m);\n                s = q * r * (x1 - x2);\n                q = (q - r) * (x1 + m);\n                if (q < 0) {\n                    s = -s;\n                } else {\n                    q = -q;\n                }\n                r = e;\n                e = d;\n                // choose step according to signs of q and s\n                if (2 * q < 3 * s - Math.abs(tol * q) && q < Math.abs(0.5 * r * q)) {\n                    d = q / p;\n                } else {\n                    d = e;\n                    e = x1 < x2 ? x2 - x1 : x1 - x2;\n                }\n            } else {\n                // Newton-Raphson step too small: simply ignore\n                d = m - x1;\n                e = x2 - m;\n            }\n            // update interval\n            if (Math.abs(d) > tol) {\n                x1 = m + d;\n            } else {\n                x1 = m + tol * (d > 0 ? 1 : -1);\n            }\n            y1 = f.value(x1);\n            incIterationsCounter();\n            // keep the best result so far\n            if (Math.abs(y1) <= Math.abs(getFunctionValueAccuracy())) {\n                setResult(x1, y1);\n                return result;\n            }\n            if (y1 * fm < 0) {\n                x2 = m;\n                y2 = fm;\n                e = x1 - x2;\n            } else {\n                d = e;\n                e = x2 - x1;\n            }\n            // check convergence criteria\n            if (Math.abs(y2) > Math.abs(y1)) {\n                double tmp1 = y2; y2 = y1; y1 = tmp1;\n                double tmp2 = x2; x2 = x1; x1 = tmp2;\n            }\n            if (Math.abs(e) <= tol * Math.max(Math.abs(x1), Math.abs(x2))) {\n                break;\n            }\n        }\n\n        throw new MaxIterationsExceededException(iMax);\n    }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..5c245c884 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,138 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+        // check if interval brackets the root\n+        if (yMin * yMax > 0) {\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs.\");\n+        }\n+\n+        double x0 = min;\n+        double x1 = initial;\n+        double x2 = max;\n+        double y0 = yMin;\n+        double y1 = yInitial;\n+        double y2 = yMax;\n+\n+        // begin Brent iteration\n+        double d = 0;\n+        double e = 0;\n+        double tol = 0;\n+        double m = 0;\n+        double p = 0;\n+        double q = 0;\n+        double r = 0;\n+        double s = 0;\n+        double fm = 0;\n+        double fn = 0;\n+        double fMid = 0;\n+\n+        int iMax = getMaximalIterationCount();\n+        while (getIterations() < iMax) {\n+            if (y1 * y2 < 0) {\n+                // switch to inverse quadratic interpolation\n+                if (Math.abs(y0) < Math.abs(y2)) {\n+                    // swap x0 and x2, y0 and y2\n+                    double tmp1 = x0; x0 = x2; x2 = tmp1;\n+                    double tmp2 = y0; y0 = y2; y2 = tmp2;\n+                }\n+                // update d and e\n+                double tmp3 = (x2 - x1) / (y1 / y2 - 1);\n+                e = d;\n+                d = tmp3;\n+            } else {\n+                // switch to bisection\n+                d = e = (x2 - x1) / 2;\n+            }\n+            // apply correction factor to d\n+            tol = getRelativeAccuracy() * Math.max(Math.abs(x1), Math.abs(x2));\n+            if (Math.abs(d) > tol) {\n+                m = x1 + d;\n+                if (m < x1 || m > x2) {\n+                    d = x1 < 0 ? -x1 * getRelativeAccuracy() : x1 * getRelativeAccuracy();\n+                    m = x1 + d;\n+                }\n+            } else {\n+                // tolerance is too small: simply use bissection\n+                m = x1 + d;\n+                tol = 2 * tol;\n+            }\n+            fm = f.value(m);\n+            incIterationsCounter();\n+            // update bisection values\n+            if (fm * y1 < 0) {\n+                x2 = m;\n+                y2 = fm;\n+                e = x1 - x2;\n+            } else {\n+                if (fm * y2 < 0) {\n+                    x1 = m;\n+                    y1 = fm;\n+                    e = x2 - x1;\n+                } else {\n+                    // zero function value\n+                    setResult(m, 0);\n+                    return result;\n+                }\n+            }\n+            // prepare next Newton-Raphson step\n+            if (Math.abs(e) > tol) {\n+                p = (y1 - y2) / (x1 - x2);\n+                q = (y1 - fm) / (x1 - m);\n+                r = (y2 - fm) / (x2 - m);\n+                s = q * r * (x1 - x2);\n+                q = (q - r) * (x1 + m);\n+                if (q < 0) {\n+                    s = -s;\n+                } else {\n+                    q = -q;\n+                }\n+                r = e;\n+                e = d;\n+                // choose step according to signs of q and s\n+                if (2 * q < 3 * s - Math.abs(tol * q) && q < Math.abs(0.5 * r * q)) {\n+                    d = q / p;\n+                } else {\n+                    d = e;\n+                    e = x1 < x2 ? x2 - x1 : x1 - x2;\n+                }\n+            } else {\n+                // Newton-Raphson step too small: simply ignore\n+                d = m - x1;\n+                e = x2 - m;\n+            }\n+            // update interval\n+            if (Math.abs(d) > tol) {\n+                x1 = m + d;\n+            } else {\n+                x1 = m + tol * (d > 0 ? 1 : -1);\n+            }\n+            y1 = f.value(x1);\n+            incIterationsCounter();\n+            // keep the best result so far\n+            if (Math.abs(y1) <= Math.abs(getFunctionValueAccuracy())) {\n+                setResult(x1, y1);\n+                return result;\n+            }\n+            if (y1 * fm < 0) {\n+                x2 = m;\n+                y2 = fm;\n+                e = x1 - x2;\n+            } else {\n+                d = e;\n+                e = x2 - x1;\n+            }\n+            // check convergence criteria\n+            if (Math.abs(y2) > Math.abs(y1)) {\n+                double tmp1 = y2; y2 = y1; y1 = tmp1;\n+                double tmp2 = x2; x2 = x1; x1 = tmp2;\n+            }\n+            if (Math.abs(e) <= tol * Math.max(Math.abs(x1), Math.abs(x2))) {\n+                break;\n+            }\n+        }\n+\n+        throw new MaxIterationsExceededException(iMax);\n+    }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: illegal start of type",
    "test_result": "ERROR"
}