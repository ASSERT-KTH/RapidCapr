{
    "patch": "if (offsetLocal != offsetAdjusted) {\n    boolean dstTransitionSkipped = false;\n    boolean dstTransitionRepeated = false;\n    long prevTransitionLocal = previousTransition(instantLocal);\n    long nextTransitionLocal = nextTransition(instantLocal);\n    long prevTransitionAdjusted = previousTransition(instantAdjusted);\n    long nextTransitionAdjusted = nextTransition(instantAdjusted);\n    if (offsetLocal > offsetAdjusted) {\n        // gap in the local time, a DST transition was skipped\n        if (prevTransitionAdjusted > prevTransitionLocal) {\n            dstTransitionSkipped = true;\n        }\n    } else {\n        // overlap in the local time, a DST transition was repeated\n        if (nextTransitionAdjusted < nextTransitionLocal) {\n            dstTransitionRepeated = true;\n        }\n    }\n    if (dstTransitionSkipped) {\n        // the local time has skipped a DST transition, so use the earlier offset\n        return offsetLocal;\n    } else if (dstTransitionRepeated) {\n        // the local time has repeated a DST transition, so use the later offset\n        return offsetAdjusted;\n    } else {\n        // no DST transition was skipped or repeated\n\n        // if the offset-adjusted instant is outside the supported range, use the adjusted offset\n        if (instantAdjusted <= Long.MIN_VALUE + DateTimeConstants.MILLIS_PER_DAY || \n            instantAdjusted >= Long.MAX_VALUE - DateTimeConstants.MILLIS_PER_DAY) {\n            return offsetAdjusted; \n        }\n\n        // if the offset-adjusted instant is more than an hour before the local instant, use the local offset\n        if (instantLocal - prevTransitionLocal >= DateTimeConstants.MILLIS_PER_HOUR &&\n            instantLocal - prevTransitionAdjusted >= DateTimeConstants.MILLIS_PER_HOUR) {\n            return offsetLocal;\n        }\n\n        // if the offset-adjusted instant is more than an hour after the local instant, use the adjusted offset\n        if (nextTransitionLocal - instantLocal >= DateTimeConstants.MILLIS_PER_HOUR &&\n            nextTransitionAdjusted - instantLocal >= DateTimeConstants.MILLIS_PER_HOUR) {\n            return offsetAdjusted;\n        }\n\n        // otherwise, return the earlier offset\n        return offsetLocal;\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/DateTimeZone.java b/src/main/java/org/joda/time/DateTimeZone.java\nindex a320022c..d41ea0c0 100644\n--- a/src/main/java/org/joda/time/DateTimeZone.java\n+++ b/src/main/java/org/joda/time/DateTimeZone.java\n@@ -896,6 +896,55 @@ public abstract class DateTimeZone implements Serializable {\n                     return offsetLocal;\n                 }\n             }\n+if (offsetLocal != offsetAdjusted) {\n+    boolean dstTransitionSkipped = false;\n+    boolean dstTransitionRepeated = false;\n+    long prevTransitionLocal = previousTransition(instantLocal);\n+    long nextTransitionLocal = nextTransition(instantLocal);\n+    long prevTransitionAdjusted = previousTransition(instantAdjusted);\n+    long nextTransitionAdjusted = nextTransition(instantAdjusted);\n+    if (offsetLocal > offsetAdjusted) {\n+        // gap in the local time, a DST transition was skipped\n+        if (prevTransitionAdjusted > prevTransitionLocal) {\n+            dstTransitionSkipped = true;\n+        }\n+    } else {\n+        // overlap in the local time, a DST transition was repeated\n+        if (nextTransitionAdjusted < nextTransitionLocal) {\n+            dstTransitionRepeated = true;\n+        }\n+    }\n+    if (dstTransitionSkipped) {\n+        // the local time has skipped a DST transition, so use the earlier offset\n+        return offsetLocal;\n+    } else if (dstTransitionRepeated) {\n+        // the local time has repeated a DST transition, so use the later offset\n+        return offsetAdjusted;\n+    } else {\n+        // no DST transition was skipped or repeated\n+\n+        // if the offset-adjusted instant is outside the supported range, use the adjusted offset\n+        if (instantAdjusted <= Long.MIN_VALUE + DateTimeConstants.MILLIS_PER_DAY || \n+            instantAdjusted >= Long.MAX_VALUE - DateTimeConstants.MILLIS_PER_DAY) {\n+            return offsetAdjusted; \n+        }\n+\n+        // if the offset-adjusted instant is more than an hour before the local instant, use the local offset\n+        if (instantLocal - prevTransitionLocal >= DateTimeConstants.MILLIS_PER_HOUR &&\n+            instantLocal - prevTransitionAdjusted >= DateTimeConstants.MILLIS_PER_HOUR) {\n+            return offsetLocal;\n+        }\n+\n+        // if the offset-adjusted instant is more than an hour after the local instant, use the adjusted offset\n+        if (nextTransitionLocal - instantLocal >= DateTimeConstants.MILLIS_PER_HOUR &&\n+            nextTransitionAdjusted - instantLocal >= DateTimeConstants.MILLIS_PER_HOUR) {\n+            return offsetAdjusted;\n+        }\n+\n+        // otherwise, return the earlier offset\n+        return offsetLocal;\n+    }\n+}\n         }\n         return offsetAdjusted;\n     }",
    "result_reason": "junit.framework.AssertionFailedError: expected:<false> but was:<true>",
    "test_result": "FAIL"
}