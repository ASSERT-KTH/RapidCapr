{
    "patch": "Set<Node> usedArgs = new HashSet<>();\nNode function = fnScope.getRootNode();\n\nPreconditions.checkState(function.isFunction());\nif (NodeUtil.isGetOrSetKey(function.getParent())) {\n    // The parameters object literal setters can not be removed.\n    return;\n}\n\nNode argList = getFunctionArgList(function);\nboolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\nif (!modifyCallers) {\n    // Find the used arguments and add them to the usedArgs set\n    visitPreOrder(\n        function.getLastChild(),\n        new AbstractPostOrderCallback() {\n            @Override public void visit(NodeTraversal t, Node n, Node parent) {\n            if (n.isName() && parent.isParamList()) {\n                Var var = fnScope.getVar(n.getString());\n                if (referenced.contains(var)) {\n                    usedArgs.add(n);\n                }\n            }\n            }\n        });\n\n    boolean foundUnused = false;\n    // Remove unused arguments from the end up to where used parameters begin\n    for (Node n = argList.getLastChild(); n != null; n = argList.getLastChild()) {\n        Var var = fnScope.getVar(n.getString());\n        if (usedArgs.contains(n)) {\n            foundUnused = true;\n        } else if (foundUnused) {\n            argList.removeChild(n);\n            compiler.reportCodeChange();\n        }\n    }\n} else {\n    callSiteOptimizer.optimize(fnScope, referenced);\n}",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/RemoveUnusedVars.java b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\nindex dfad51bc..e48713d2 100644\n--- a/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n+++ b/src/com/google/javascript/jscomp/RemoveUnusedVars.java\n@@ -376,6 +376,46 @@ class RemoveUnusedVars\n     // is removing globals, then it's OK to remove unused function args.\n     //\n     // See http://code.google.com/p/closure-compiler/issues/detail?id=253\n+Set<Node> usedArgs = new HashSet<>();\n+Node function = fnScope.getRootNode();\n+\n+Preconditions.checkState(function.isFunction());\n+if (NodeUtil.isGetOrSetKey(function.getParent())) {\n+    // The parameters object literal setters can not be removed.\n+    return;\n+}\n+\n+Node argList = getFunctionArgList(function);\n+boolean modifyCallers = modifyCallSites && callSiteOptimizer.canModifyCallers(function);\n+if (!modifyCallers) {\n+    // Find the used arguments and add them to the usedArgs set\n+    visitPreOrder(\n+        function.getLastChild(),\n+        new AbstractPostOrderCallback() {\n+            @Override public void visit(NodeTraversal t, Node n, Node parent) {\n+            if (n.isName() && parent.isParamList()) {\n+                Var var = fnScope.getVar(n.getString());\n+                if (referenced.contains(var)) {\n+                    usedArgs.add(n);\n+                }\n+            }\n+            }\n+        });\n+\n+    boolean foundUnused = false;\n+    // Remove unused arguments from the end up to where used parameters begin\n+    for (Node n = argList.getLastChild(); n != null; n = argList.getLastChild()) {\n+        Var var = fnScope.getVar(n.getString());\n+        if (usedArgs.contains(n)) {\n+            foundUnused = true;\n+        } else if (foundUnused) {\n+            argList.removeChild(n);\n+            compiler.reportCodeChange();\n+        }\n+    }\n+} else {\n+    callSiteOptimizer.optimize(fnScope, referenced);\n+}\n \n     Node function = fnScope.getRootNode();\n ",
    "result_reason": "error: diamond operator is not supported in -source 1.6",
    "test_result": "ERROR"
}