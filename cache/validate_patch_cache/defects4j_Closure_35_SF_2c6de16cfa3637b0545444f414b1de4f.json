{
    "patch": "  /**\n   * Completes the record type if it has been partially declared or inferred. If the record type has\n   * allowAllProps, then implicitly typed properties are declared as well.\n   */\n  private void completeRecordType(\n      ObjectType type, ObjectType constraint, WarningReporter warnings) {\n    if (type == null || constraint == null) {\n      return;\n    }\n\n    boolean typeIsStrict = type.isTypeOf(UNKNOWN_TYPE, false);\n    ObjectType constraintObj = constraint.restrictByNotNullOrUndefined().autobox(); // add null/undefine types\n    if (!constraintObj.isRecordType()) {\n      // Can't expand a non-record type.\n      return;\n    }\n\n    ImmutableSet<String> implicitProps = constraintObj.getImplicitProps();\n    ObjectType objType = type.restrictByNotNullOrUndefined().autobox(); // add null/undefined types\n    if (objType == null) {\n      objType = ObjectType.builder(getNativeType(OBJECT_TYPE)).build(); // empty objects are types\n    }\n    List<String> inferredProps = new ArrayList<>();\n    for (String prop : constraintObj.getOwnPropertyNames()) {\n      JSType propType = constraintObj.getRequiredPropertyType(prop);\n      if (!objType.hasProperty(prop)) {\n        if (constraintObj.isExtendable()) {\n          // Add inferred property types to extended objects.\n          inferredProps.add(prop);\n        } else if (!typeIsStrict) {\n          // Add undeclared properties to strict objects as implicit typed properties.\n          JSType typeToInfer =\n              getNativeType(VOID_TYPE).getLeastSupertype(propType).autobox();\n          objType = objType.withProperty(prop, typeToInfer);\n          warnings.addWarning(\n              Report.makeError(\n                  n,\n                  TypeValidator.PARTIAL_NAMESPACE_WARNING,\n                  String.format(\n                      \"Can't determine the type of property %s in %s. Add a type annotation to the\"\n                          + \" record, replace the type '&#123;&#125;' with 'Object', or remove\"\n                          + \" 'partial' or 'undefined' from the type. See\"\n                          + \" go/closure-record-types for more.\",\n                      prop, type)));\n        } else {\n          // Non-strict record types do not infer undeclared properties.\n        }\n      }\n    }\n    if (!inferredProps.isEmpty()) {\n      for (String inferredProp : inferredProps) {\n        JSType propType = constraintObj.getRequiredPropertyType(inferredProp);\n        JSType typeToInfer =\n            getNativeType(VOID_TYPE).getLeastSupertype(propType).autobox();\n        objType.defineInferredProperty(inferredProp, typeToInfer, null);\n      }\n    }\n    if (constraintObj.isAllowAllProperties() && !typeIsStrict) {\n      for (String implicitProp : implicitProps) {\n        if (!objType.hasProperty(implicitProp)) {\n          objType =\n              objType\n                  .withProperty(implicitProp, getNativeType(UNKNOWN_TYPE))\n                  .withHiddenProtoProperty(implicitProp);\n        }\n      }\n    }\n  }",
    "patch_diff": "diff --git a/src/com/google/javascript/jscomp/TypeInference.java b/src/com/google/javascript/jscomp/TypeInference.java\nindex 13e10920..80192bdf 100644\n--- a/src/com/google/javascript/jscomp/TypeInference.java\n+++ b/src/com/google/javascript/jscomp/TypeInference.java\n@@ -1111,43 +1111,75 @@ class TypeInference\n    * then this code will type-check appropriately.\n    */\n   private void inferPropertyTypesToMatchConstraint(\n-      JSType type, JSType constraint) {\n+  /**\n+   * Completes the record type if it has been partially declared or inferred. If the record type has\n+   * allowAllProps, then implicitly typed properties are declared as well.\n+   */\n+  private void completeRecordType(\n+      ObjectType type, ObjectType constraint, WarningReporter warnings) {\n     if (type == null || constraint == null) {\n       return;\n     }\n \n-    ObjectType constraintObj =\n-        ObjectType.cast(constraint.restrictByNotNullOrUndefined());\n-    if (constraintObj != null && constraintObj.isRecordType()) {\n-      ObjectType objType = ObjectType.cast(type.restrictByNotNullOrUndefined());\n-      if (objType != null) {\n-        for (String prop : constraintObj.getOwnPropertyNames()) {\n-          JSType propType = constraintObj.getPropertyType(prop);\n-          if (!objType.isPropertyTypeDeclared(prop)) {\n-            JSType typeToInfer = propType;\n-            if (!objType.hasProperty(prop)) {\n-              typeToInfer =\n-                  getNativeType(VOID_TYPE).getLeastSupertype(propType);\n-            }\n-            objType.defineInferredProperty(prop, typeToInfer, null);\n-          }\n+    boolean typeIsStrict = type.isTypeOf(UNKNOWN_TYPE, false);\n+    ObjectType constraintObj = constraint.restrictByNotNullOrUndefined().autobox(); // add null/undefine types\n+    if (!constraintObj.isRecordType()) {\n+      // Can't expand a non-record type.\n+      return;\n+    }\n+\n+    ImmutableSet<String> implicitProps = constraintObj.getImplicitProps();\n+    ObjectType objType = type.restrictByNotNullOrUndefined().autobox(); // add null/undefined types\n+    if (objType == null) {\n+      objType = ObjectType.builder(getNativeType(OBJECT_TYPE)).build(); // empty objects are types\n+    }\n+    List<String> inferredProps = new ArrayList<>();\n+    for (String prop : constraintObj.getOwnPropertyNames()) {\n+      JSType propType = constraintObj.getRequiredPropertyType(prop);\n+      if (!objType.hasProperty(prop)) {\n+        if (constraintObj.isExtendable()) {\n+          // Add inferred property types to extended objects.\n+          inferredProps.add(prop);\n+        } else if (!typeIsStrict) {\n+          // Add undeclared properties to strict objects as implicit typed properties.\n+          JSType typeToInfer =\n+              getNativeType(VOID_TYPE).getLeastSupertype(propType).autobox();\n+          objType = objType.withProperty(prop, typeToInfer);\n+          warnings.addWarning(\n+              Report.makeError(\n+                  n,\n+                  TypeValidator.PARTIAL_NAMESPACE_WARNING,\n+                  String.format(\n+                      \"Can't determine the type of property %s in %s. Add a type annotation to the\"\n+                          + \" record, replace the type '&#123;&#125;' with 'Object', or remove\"\n+                          + \" 'partial' or 'undefined' from the type. See\"\n+                          + \" go/closure-record-types for more.\",\n+                      prop, type)));\n+        } else {\n+          // Non-strict record types do not infer undeclared properties.\n         }\n       }\n     }\n-  }\n-\n-  /**\n-   * If we access a property of a symbol, then that symbol is not\n-   * null or undefined.\n-   */\n-  private FlowScope dereferencePointer(Node n, FlowScope scope) {\n-    if (n.isQualifiedName()) {\n-      JSType type = getJSType(n);\n-      JSType narrowed = type.restrictByNotNullOrUndefined();\n-      if (type != narrowed) {\n-        scope = narrowScope(scope, n, narrowed);\n+    if (!inferredProps.isEmpty()) {\n+      for (String inferredProp : inferredProps) {\n+        JSType propType = constraintObj.getRequiredPropertyType(inferredProp);\n+        JSType typeToInfer =\n+            getNativeType(VOID_TYPE).getLeastSupertype(propType).autobox();\n+        objType.defineInferredProperty(inferredProp, typeToInfer, null);\n       }\n     }\n+    if (constraintObj.isAllowAllProperties() && !typeIsStrict) {\n+      for (String implicitProp : implicitProps) {\n+        if (!objType.hasProperty(implicitProp)) {\n+          objType =\n+              objType\n+                  .withProperty(implicitProp, getNativeType(UNKNOWN_TYPE))\n+                  .withHiddenProtoProperty(implicitProp);\n+        }\n+      }\n+    }\n+  }\n+    }\n     return scope;\n   }\n ",
    "result_reason": "error: modifier private not allowed here",
    "test_result": "ERROR"
}