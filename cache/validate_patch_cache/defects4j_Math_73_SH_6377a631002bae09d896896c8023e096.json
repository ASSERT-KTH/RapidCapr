{
    "patch": "// check if interval brackets root\n        if (yMin * yMax > 0) {\n            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs. Endpoints: [\" + min + \", \" + max + \"], Values: [\" + yMin + \", \" + yMax + \"]\");\n        }\n        \n        double x0 = initial;\n        double x1 = min;\n        double x2 = max;\n        double y1 = yMin;\n        double y2 = yMax;\n        double x3;\n        double y3;\n        double delta1;\n        double delta2;\n        double delta3;\n        double a;\n        double b;\n        double c;\n        double d;\n        double minTol = this.getAbsoluteAccuracy() + this.getRelativeAccuracy() * Math.max(Math.abs(x0), Math.abs(x2));\n        while (true) {\n            delta2 = y2 - y1;\n            delta3 = y1 - y3;\n            a = (x1 - x0) * delta2 - (x2 - x1) * delta3;\n            b = (x1 - x0) * (x1 - x0) * delta2 - (x2 - x1) * (x2 - x1) * delta3;\n            if (b == 0) {\n                // Avoid zero-division\n                x3 = x2 - delta2 * (x2 - x1);\n            } else {\n                x3 = x1 - delta2 * a / (b + b * Math.signum(b));\n            }\n\n            final double y0 = f.value(x0);\n            y1 = f.value(x1);\n            y2 = f.value(x2);\n            y3 = f.value(x3);\n\n            // has root been bracketed?\n            if (y1 * y3 < 0) {\n                x0 = x1;\n                x2 = x3;\n                y2 = y3;\n                delta1 = y1 - y0;\n                delta2 = y2 - y1;\n                delta3 = y3 - y2;\n                a = (x1 - x0) * delta2 - (x2 - x1) * delta1;\n                b = (x1 - x0) * (x1 - x0) * delta2 - (x2 - x1) * (x2 - x1) * delta1;\n                c = (x2 - x1) * delta3 - (x3 - x2) * delta2;\n                d = (x2 - x1) * (x2 - x1) * delta3 - (x3 - x2) * (x3 - x2) * delta2;\n                if (d == 0) {\n                    // Avoid zero-division\n                    x1 = x2 - delta2 * (x2 - x0) / (delta1 - delta2);\n                } else {\n                    final double idet = 1d / (b * c - a * d);\n                    x1 = x1 - (b * delta3 - c * delta2) * idet;\n                }\n                final double y1New = f.value(x1);\n                if (Math.abs(y1New) <= getFunctionValueAccuracy()) {\n                    setResult(x1, 0);\n                    return getResult();\n                }\n                if (getIterations() >= getMaximalIterationCount()) {\n                    throw new MaxIterationsExceededException(getMaximalIterationCount());\n                }\n                if (Math.abs(x1 - x0) < minTol || Math.abs(x2 - x1) < minTol) {\n                    throw new NoBracketingException(x1, x0, x2, y1New, y0, y2, true);\n                }\n                if (y1New * y3 < 0) {\n                    x0 = x1;\n                    x1 = x3;\n                    y1 = y3;\n                } else if (y1New * y2 < 0) {\n                    x2 = x3;\n                    y2 = y3;\n                } else {\n                    // the new point is not better than existing ones\n                    throw new NoBracketingException(x1, x0, x2, y1New, y0, y2, true);\n                }\n            } else if (Math.abs(y3) < Math.abs(y1)) {\n                x1 = x2;\n                x2 = x3;\n                y1 = y2;\n                y2 = y3;\n            } else if (Math.abs(y3) > Math.abs(y2)) {\n                x2 = x1;\n                x1 = x3;\n                y2 = y1;\n                y1 = y3;\n            } else {\n                x1 = x3;\n                y1 = y3;\n                x2 = (1 + goldenSection) * x1 - goldenSection * x0;\n                y2 = f.value(x2);\n            }",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\nindex 8142b5edb..bf5737be1 100644\n--- a/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n+++ b/src/main/java/org/apache/commons/math/analysis/solvers/BrentSolver.java\n@@ -133,6 +133,100 @@ public class BrentSolver extends UnivariateRealSolverImpl {\n             return solve(f, initial, yInitial, max, yMax, initial, yInitial);\n         }\n \n+// check if interval brackets root\n+        if (yMin * yMax > 0) {\n+            throw new IllegalArgumentException(\"Function values at endpoints do not have different signs. Endpoints: [\" + min + \", \" + max + \"], Values: [\" + yMin + \", \" + yMax + \"]\");\n+        }\n+        \n+        double x0 = initial;\n+        double x1 = min;\n+        double x2 = max;\n+        double y1 = yMin;\n+        double y2 = yMax;\n+        double x3;\n+        double y3;\n+        double delta1;\n+        double delta2;\n+        double delta3;\n+        double a;\n+        double b;\n+        double c;\n+        double d;\n+        double minTol = this.getAbsoluteAccuracy() + this.getRelativeAccuracy() * Math.max(Math.abs(x0), Math.abs(x2));\n+        while (true) {\n+            delta2 = y2 - y1;\n+            delta3 = y1 - y3;\n+            a = (x1 - x0) * delta2 - (x2 - x1) * delta3;\n+            b = (x1 - x0) * (x1 - x0) * delta2 - (x2 - x1) * (x2 - x1) * delta3;\n+            if (b == 0) {\n+                // Avoid zero-division\n+                x3 = x2 - delta2 * (x2 - x1);\n+            } else {\n+                x3 = x1 - delta2 * a / (b + b * Math.signum(b));\n+            }\n+\n+            final double y0 = f.value(x0);\n+            y1 = f.value(x1);\n+            y2 = f.value(x2);\n+            y3 = f.value(x3);\n+\n+            // has root been bracketed?\n+            if (y1 * y3 < 0) {\n+                x0 = x1;\n+                x2 = x3;\n+                y2 = y3;\n+                delta1 = y1 - y0;\n+                delta2 = y2 - y1;\n+                delta3 = y3 - y2;\n+                a = (x1 - x0) * delta2 - (x2 - x1) * delta1;\n+                b = (x1 - x0) * (x1 - x0) * delta2 - (x2 - x1) * (x2 - x1) * delta1;\n+                c = (x2 - x1) * delta3 - (x3 - x2) * delta2;\n+                d = (x2 - x1) * (x2 - x1) * delta3 - (x3 - x2) * (x3 - x2) * delta2;\n+                if (d == 0) {\n+                    // Avoid zero-division\n+                    x1 = x2 - delta2 * (x2 - x0) / (delta1 - delta2);\n+                } else {\n+                    final double idet = 1d / (b * c - a * d);\n+                    x1 = x1 - (b * delta3 - c * delta2) * idet;\n+                }\n+                final double y1New = f.value(x1);\n+                if (Math.abs(y1New) <= getFunctionValueAccuracy()) {\n+                    setResult(x1, 0);\n+                    return getResult();\n+                }\n+                if (getIterations() >= getMaximalIterationCount()) {\n+                    throw new MaxIterationsExceededException(getMaximalIterationCount());\n+                }\n+                if (Math.abs(x1 - x0) < minTol || Math.abs(x2 - x1) < minTol) {\n+                    throw new NoBracketingException(x1, x0, x2, y1New, y0, y2, true);\n+                }\n+                if (y1New * y3 < 0) {\n+                    x0 = x1;\n+                    x1 = x3;\n+                    y1 = y3;\n+                } else if (y1New * y2 < 0) {\n+                    x2 = x3;\n+                    y2 = y3;\n+                } else {\n+                    // the new point is not better than existing ones\n+                    throw new NoBracketingException(x1, x0, x2, y1New, y0, y2, true);\n+                }\n+            } else if (Math.abs(y3) < Math.abs(y1)) {\n+                x1 = x2;\n+                x2 = x3;\n+                y1 = y2;\n+                y2 = y3;\n+            } else if (Math.abs(y3) > Math.abs(y2)) {\n+                x2 = x1;\n+                x1 = x3;\n+                y2 = y1;\n+                y1 = y3;\n+            } else {\n+                x1 = x3;\n+                y1 = y3;\n+                x2 = (1 + goldenSection) * x1 - goldenSection * x0;\n+                y2 = f.value(x2);\n+            }\n \n         // full Brent algorithm starting with provided initial guess\n         return solve(f, min, yMin, max, yMax, initial, yInitial);",
    "result_reason": "error: illegal start of expression",
    "test_result": "ERROR"
}