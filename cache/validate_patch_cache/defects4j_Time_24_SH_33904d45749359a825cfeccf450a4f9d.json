{
    "patch": "        boolean retry = false;\n        IllegalFieldValueException cause = null;\n        try {\n            for (int i = 0; i < count; i++) {\n                millis = savedFields[i].set(millis, resetFields);\n            }\n        } catch (IllegalFieldValueException e) {\n            if (savedFields[iSavedFieldsProcessed].iField.getType().equals(e.getFieldType())) {\n                retry = true;\n                cause = e;\n            } else {\n                if (text != null) {\n                    e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                }\n                throw e;\n            }\n        }\n\n        if (retry) {\n            // retry parsing using the first failed field's base value\n            // the base value is computed by selecting the lowest value that is consistent with\n            // the parsed fields that occur before the failed field.\n            int i;\n            for (i = iSavedFieldsProcessed; i-- > 0; ) {\n                DurationField field = savedFields[i].iField.getDurationField();\n                if (field.equals(ChronoUnit.days().getDurationField())) {\n                    break; // yearOfEra not possible if a day is set\n                }\n                savedFields[i].iField.retain();\n                LocalDateTime fieldLower = LocalDateTime.ofEpochSecond(\n                        savedFields[i].iField.roundFloor(savedFields[i].iValue), 0, iChrono).atZone(iZone).toLocalDateTime();\n                try {\n                    savedFields[i].set(fieldLower.range(savedFields[i].iField.getBaseUnit()).getMinimum(), false);\n                    for (int j = i + 1; j < count; j++) {\n                        savedFields[j].set(savedFields[j].iField.getDurationField().getMinimumValue(savedFields[j].iValue), false);\n                    }\n                    millis = savedFields[count - 1].set(millis, resetFields);\n                    break;\n                } catch (IllegalFieldValueException ex) {\n                } finally {\n                    savedFields[i].iField.release();\n                }\n            }\n            if (i < 0) {\n                if (text != null) {\n                    cause.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n                }\n                throw cause;\n            }\n            iSavedFieldsProcessed = i + 1;\n            for (; iSavedFieldsProcessed < count; iSavedFieldsProcessed++) {\n                savedFields[iSavedFieldsProcessed].iField.release();\n            }\n            return computeMillis(resetFields, text);",
    "patch_diff": "diff --git a/src/main/java/org/joda/time/format/DateTimeParserBucket.java b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\nindex b985cefd..b393ea00 100644\n--- a/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n+++ b/src/main/java/org/joda/time/format/DateTimeParserBucket.java\n@@ -352,6 +352,60 @@ public class DateTimeParserBucket {\n             for (int i = 0; i < count; i++) {\n                 millis = savedFields[i].set(millis, resetFields);\n             }\n+        boolean retry = false;\n+        IllegalFieldValueException cause = null;\n+        try {\n+            for (int i = 0; i < count; i++) {\n+                millis = savedFields[i].set(millis, resetFields);\n+            }\n+        } catch (IllegalFieldValueException e) {\n+            if (savedFields[iSavedFieldsProcessed].iField.getType().equals(e.getFieldType())) {\n+                retry = true;\n+                cause = e;\n+            } else {\n+                if (text != null) {\n+                    e.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                }\n+                throw e;\n+            }\n+        }\n+\n+        if (retry) {\n+            // retry parsing using the first failed field's base value\n+            // the base value is computed by selecting the lowest value that is consistent with\n+            // the parsed fields that occur before the failed field.\n+            int i;\n+            for (i = iSavedFieldsProcessed; i-- > 0; ) {\n+                DurationField field = savedFields[i].iField.getDurationField();\n+                if (field.equals(ChronoUnit.days().getDurationField())) {\n+                    break; // yearOfEra not possible if a day is set\n+                }\n+                savedFields[i].iField.retain();\n+                LocalDateTime fieldLower = LocalDateTime.ofEpochSecond(\n+                        savedFields[i].iField.roundFloor(savedFields[i].iValue), 0, iChrono).atZone(iZone).toLocalDateTime();\n+                try {\n+                    savedFields[i].set(fieldLower.range(savedFields[i].iField.getBaseUnit()).getMinimum(), false);\n+                    for (int j = i + 1; j < count; j++) {\n+                        savedFields[j].set(savedFields[j].iField.getDurationField().getMinimumValue(savedFields[j].iValue), false);\n+                    }\n+                    millis = savedFields[count - 1].set(millis, resetFields);\n+                    break;\n+                } catch (IllegalFieldValueException ex) {\n+                } finally {\n+                    savedFields[i].iField.release();\n+                }\n+            }\n+            if (i < 0) {\n+                if (text != null) {\n+                    cause.prependMessage(\"Cannot parse \\\"\" + text + '\"');\n+                }\n+                throw cause;\n+            }\n+            iSavedFieldsProcessed = i + 1;\n+            for (; iSavedFieldsProcessed < count; iSavedFieldsProcessed++) {\n+                savedFields[iSavedFieldsProcessed].iField.release();\n+            }\n+            return computeMillis(resetFields, text);\n         } catch (IllegalFieldValueException e) {\n             if (text != null) {\n                 e.prependMessage(\"Cannot parse \\\"\" + text + '\"');",
    "result_reason": "error: 'catch' without 'try'",
    "test_result": "ERROR"
}