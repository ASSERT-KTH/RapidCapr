{
    "patch": "private RealMatrix squareRoot(RealMatrix m) {\n    int n = m.getRowDimension();\n\n    if (n > 1000) { // large matrix size, use specialized algorithm\n        return specializedSquareRoot(m);\n    } else {\n        final EigenDecomposition dec = new EigenDecomposition(m);\n        return dec.getSquareRoot();\n    }\n}\n\n// specialized algorithm for large matrices\nprivate RealMatrix specializedSquareRoot(RealMatrix m) {\n    final int n = m.getRowDimension();\n    final int maxBlockSize = 100; // or any other max block size that makes sense\n    final RealMatrix identity = MatrixUtils.createRealIdentityMatrix(n);\n    RealMatrix x = m;\n\n    // divide matrix into blocks of size <= maxBlockSize\n    for (int i = 0; i < n; i += maxBlockSize) {\n        int blockSize = Math.min(maxBlockSize, n - i);\n        RealMatrix block = m.getSubMatrix(i, i + blockSize - 1, i, i + blockSize - 1);\n        RealMatrix sqrt = sqrtHelper(block);\n        RealMatrix top = x.getSubMatrix(i, i + blockSize - 1, 0, n - 1);\n        RealMatrix left = top.transpose();\n        RealMatrix middle = sqrt.multiply(top).multiply(sqrt);\n        x.setSubMatrix(middle.getData(), i, 0);\n        x.setSubMatrix(middle.multiply(left).getData(), 0, i);\n    }\n\n    // perform eigen decomposition on final result to get the square root\n    final EigenDecomposition dec = new EigenDecomposition(x);\n    RealMatrix d = dec.getD();\n    RealMatrix v = dec.getV();\n\n    int mCols = v.getColumnDimension();\n    int mRows = d.getRowDimension();\n\n    for (int j = 0; j < mCols; j++) {\n        double dj = d.getEntry(j, j);\n        for (int i = 0; i < mRows; i++) {\n            double vij = v.getEntry(i, j);\n            double di = d.getEntry(i, i);\n            double dij = Math.sqrt(di * dj);\n            v.setEntry(i, j, vij * di / dij);\n        }\n    }\n\n    return v.multiply(v.transpose());\n}\n\n// helper function to compute the square root of a block matrix\nprivate RealMatrix sqrtHelper(RealMatrix m) {\n    final EigenDecomposition dec = new EigenDecomposition(m);\n    RealMatrix d = dec.getD();\n    RealMatrix v = dec.getV();\n\n    int n = d.getColumnDimension();\n    for (int j = 0; j < n; j++) {\n        double dj = d.getEntry(j, j);\n        for (int i = 0; i < n; i++) {\n            double vij = v.getEntry(i, j);\n            double di = d.getEntry(i, i);\n            double dij = Math.sqrt(di * dj);\n            v.setEntry(i, j, vij * di / dij);\n        }\n    }\n\n    return v.multiply(v.transpose());\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\nindex 99d86e92a..2972331bd 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/general/AbstractLeastSquaresOptimizer.java\n@@ -558,8 +558,74 @@ public abstract class AbstractLeastSquaresOptimizer\n      * @param m Symmetric, positive-definite (weight) matrix.\n      * @return the square-root of the weight matrix.\n      */\n-    private RealMatrix squareRoot(RealMatrix m) {\n-            final EigenDecomposition dec = new EigenDecomposition(m);\n-            return dec.getSquareRoot();\n+private RealMatrix squareRoot(RealMatrix m) {\n+    int n = m.getRowDimension();\n+\n+    if (n > 1000) { // large matrix size, use specialized algorithm\n+        return specializedSquareRoot(m);\n+    } else {\n+        final EigenDecomposition dec = new EigenDecomposition(m);\n+        return dec.getSquareRoot();\n     }\n }\n+\n+// specialized algorithm for large matrices\n+private RealMatrix specializedSquareRoot(RealMatrix m) {\n+    final int n = m.getRowDimension();\n+    final int maxBlockSize = 100; // or any other max block size that makes sense\n+    final RealMatrix identity = MatrixUtils.createRealIdentityMatrix(n);\n+    RealMatrix x = m;\n+\n+    // divide matrix into blocks of size <= maxBlockSize\n+    for (int i = 0; i < n; i += maxBlockSize) {\n+        int blockSize = Math.min(maxBlockSize, n - i);\n+        RealMatrix block = m.getSubMatrix(i, i + blockSize - 1, i, i + blockSize - 1);\n+        RealMatrix sqrt = sqrtHelper(block);\n+        RealMatrix top = x.getSubMatrix(i, i + blockSize - 1, 0, n - 1);\n+        RealMatrix left = top.transpose();\n+        RealMatrix middle = sqrt.multiply(top).multiply(sqrt);\n+        x.setSubMatrix(middle.getData(), i, 0);\n+        x.setSubMatrix(middle.multiply(left).getData(), 0, i);\n+    }\n+\n+    // perform eigen decomposition on final result to get the square root\n+    final EigenDecomposition dec = new EigenDecomposition(x);\n+    RealMatrix d = dec.getD();\n+    RealMatrix v = dec.getV();\n+\n+    int mCols = v.getColumnDimension();\n+    int mRows = d.getRowDimension();\n+\n+    for (int j = 0; j < mCols; j++) {\n+        double dj = d.getEntry(j, j);\n+        for (int i = 0; i < mRows; i++) {\n+            double vij = v.getEntry(i, j);\n+            double di = d.getEntry(i, i);\n+            double dij = Math.sqrt(di * dj);\n+            v.setEntry(i, j, vij * di / dij);\n+        }\n+    }\n+\n+    return v.multiply(v.transpose());\n+}\n+\n+// helper function to compute the square root of a block matrix\n+private RealMatrix sqrtHelper(RealMatrix m) {\n+    final EigenDecomposition dec = new EigenDecomposition(m);\n+    RealMatrix d = dec.getD();\n+    RealMatrix v = dec.getV();\n+\n+    int n = d.getColumnDimension();\n+    for (int j = 0; j < n; j++) {\n+        double dj = d.getEntry(j, j);\n+        for (int i = 0; i < n; i++) {\n+            double vij = v.getEntry(i, j);\n+            double di = d.getEntry(i, i);\n+            double dij = Math.sqrt(di * dj);\n+            v.setEntry(i, j, vij * di / dij);\n+        }\n+    }\n+\n+    return v.multiply(v.transpose());\n+}\n+}",
    "result_reason": "java.lang.OutOfMemoryError: Java heap space",
    "test_result": "FAIL"
}