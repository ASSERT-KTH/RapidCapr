{
    "patch": "public static double regularizedGammaP(double a, double x) {\n    final double epsilon = 10e-15; // set the value of epsilon\n\n    if (a <= 0.0) {\n        throw new IllegalArgumentException(\"a must be positive.\");\n    }\n\n    if (x < 0.0) {\n        throw new IllegalArgumentException(\"x must be non-negative.\");\n    }\n\n    if (x == 0.0) {\n        return 0.0;\n    } else if (x >= a + 1.0) {\n        // use the series representation of the incomplete gamma function\n        double sum = 1.0;\n        double term = 1.0;\n        int n = 1;\n        while (Math.abs(term) > epsilon) {\n            term *= (x / (a + n));\n            sum += term;\n            n++;\n        }\n        return 1.0 - Math.exp(-x + a * Math.log(x) - logGamma(a)) * sum;\n    } else {\n        // use the continued fraction representation of the incomplete gamma function\n        double cfResult = continuedFraction(a, x, epsilon);\n        return Math.exp(-x + a * Math.log(x) - logGamma(a)) * cfResult;\n    }\n}\n\n// calculates the logarithm of the gamma function\npublic static double logGamma(double x) {\n    double[] c = { 1.0 / 12.0, -1.0 / 360.0, 1.0 / 1260.0, -1.0 / 1680.0, 1.0 / 1188.0, -691.0 / 360360.0,\n        1.0 / 156.0, -3617.0 / 122400.0 };\n    double sum = c[7];\n    for (int i = 6; i >= 0; i--) {\n        sum *= x;\n        sum += c[i];\n    }\n    return Math.log(sum) - x + (x - 0.5) * Math.log(x) - MathUtil.LOG_TWO_PI;\n}\n\n// calculates the continued fraction representation of the incomplete gamma function\npublic static double continuedFraction(double a, double x, double epsilon) {\n    double f = 1.0;\n    double c = f;\n    double d = 0.0;\n    int i = 1;\n    while (true) {\n        double an = -i * (i - a) * x;\n        double bn = (i * 2.0 + 1.0 - a);\n        d = bn + an * d;\n        if (Math.abs(d) < epsilon) {\n            d = epsilon;\n        }\n        c = bn + an / c;\n        if (Math.abs(c) < epsilon) {\n            c = epsilon;\n        }\n        d = 1.0 / d;\n        double delta = c * d;\n        f *= delta;\n        i++;\n        if (Math.abs(delta - 1.0) < epsilon) {\n            break;\n        }\n    }\n    return f;\n}",
    "patch_diff": "diff --git a/src/java/org/apache/commons/math/special/Gamma.java b/src/java/org/apache/commons/math/special/Gamma.java\nindex 8c565cbff..a7f51d719 100644\n--- a/src/java/org/apache/commons/math/special/Gamma.java\n+++ b/src/java/org/apache/commons/math/special/Gamma.java\n@@ -28,7 +28,76 @@ import org.apache.commons.math.util.ContinuedFraction;\n  *\n  * @version $Revision$ $Date$\n  */\n-public class Gamma implements Serializable {\n+public static double regularizedGammaP(double a, double x) {\n+    final double epsilon = 10e-15; // set the value of epsilon\n+\n+    if (a <= 0.0) {\n+        throw new IllegalArgumentException(\"a must be positive.\");\n+    }\n+\n+    if (x < 0.0) {\n+        throw new IllegalArgumentException(\"x must be non-negative.\");\n+    }\n+\n+    if (x == 0.0) {\n+        return 0.0;\n+    } else if (x >= a + 1.0) {\n+        // use the series representation of the incomplete gamma function\n+        double sum = 1.0;\n+        double term = 1.0;\n+        int n = 1;\n+        while (Math.abs(term) > epsilon) {\n+            term *= (x / (a + n));\n+            sum += term;\n+            n++;\n+        }\n+        return 1.0 - Math.exp(-x + a * Math.log(x) - logGamma(a)) * sum;\n+    } else {\n+        // use the continued fraction representation of the incomplete gamma function\n+        double cfResult = continuedFraction(a, x, epsilon);\n+        return Math.exp(-x + a * Math.log(x) - logGamma(a)) * cfResult;\n+    }\n+}\n+\n+// calculates the logarithm of the gamma function\n+public static double logGamma(double x) {\n+    double[] c = { 1.0 / 12.0, -1.0 / 360.0, 1.0 / 1260.0, -1.0 / 1680.0, 1.0 / 1188.0, -691.0 / 360360.0,\n+        1.0 / 156.0, -3617.0 / 122400.0 };\n+    double sum = c[7];\n+    for (int i = 6; i >= 0; i--) {\n+        sum *= x;\n+        sum += c[i];\n+    }\n+    return Math.log(sum) - x + (x - 0.5) * Math.log(x) - MathUtil.LOG_TWO_PI;\n+}\n+\n+// calculates the continued fraction representation of the incomplete gamma function\n+public static double continuedFraction(double a, double x, double epsilon) {\n+    double f = 1.0;\n+    double c = f;\n+    double d = 0.0;\n+    int i = 1;\n+    while (true) {\n+        double an = -i * (i - a) * x;\n+        double bn = (i * 2.0 + 1.0 - a);\n+        d = bn + an * d;\n+        if (Math.abs(d) < epsilon) {\n+            d = epsilon;\n+        }\n+        c = bn + an / c;\n+        if (Math.abs(c) < epsilon) {\n+            c = epsilon;\n+        }\n+        d = 1.0 / d;\n+        double delta = c * d;\n+        f *= delta;\n+        i++;\n+        if (Math.abs(delta - 1.0) < epsilon) {\n+            break;\n+        }\n+    }\n+    return f;\n+}\n     \n     /** Serializable version identifier */\n     private static final long serialVersionUID = -6587513359895466954L;",
    "result_reason": "error: class, interface, or enum expected",
    "test_result": "ERROR"
}