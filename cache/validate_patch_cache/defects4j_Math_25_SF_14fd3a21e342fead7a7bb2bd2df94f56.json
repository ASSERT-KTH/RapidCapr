{
    "patch": "private void guessAOmega() {\n    final int len = observations.length;\n\n    // Compute the Jacobian and function values for the least-square fitting\n    final double[][] jacobian = new double[len][2];\n    final double[] y = new double[len];\n    double xStart = Double.NaN;\n    for (int i = 0; i < len; i++) {\n        final double x = observations[i].getX();\n        final double yValue = observations[i].getY();\n        y[i] = yValue;\n        if (i == 0) {\n            xStart = x;\n        } else {\n            final double x2 = (x - xStart) * omega;\n            jacobian[i][0] = FastMath.sin(x2);\n            jacobian[i][1] = FastMath.cos(x2);\n        }\n    }\n\n    // Solve the least-square fitting by QR decomposition\n    final QRDecomposition qr = new QRDecomposition(jacobian);\n    final RealVector QTy = qr.solve(new ArrayRealVector(y, false));\n\n    // Compute the amplitude and pulsation coefficients\n    a = FastMath.sqrt(QTy.getEntry(0) * QTy.getEntry(0) + QTy.getEntry(1) * QTy.getEntry(1));\n    omega = 2 * FastMath.atan(QTy.getEntry(1) / QTy.getEntry(0));\n    if (omega < 0) {\n        omega += 2 * FastMath.PI;\n    }\n\n    // Check if the fitting has converged\n    if (!qr.isFullRank()) {\n        throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n    }\n}",
    "patch_diff": "diff --git a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\nindex 1da2c454e..ac349eb1d 100644\n--- a/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n+++ b/src/main/java/org/apache/commons/math3/optimization/fitting/HarmonicFitter.java\n@@ -254,79 +254,42 @@ public class HarmonicFitter extends CurveFitter<HarmonicOscillator.Parametric> {\n          * @throws MathIllegalStateException when the guessing procedure cannot\n          * produce sensible results.\n          */\n-        private void guessAOmega() {\n-            // initialize the sums for the linear model between the two integrals\n-            double sx2 = 0;\n-            double sy2 = 0;\n-            double sxy = 0;\n-            double sxz = 0;\n-            double syz = 0;\n+private void guessAOmega() {\n+    final int len = observations.length;\n \n-            double currentX = observations[0].getX();\n-            double currentY = observations[0].getY();\n-            double f2Integral = 0;\n-            double fPrime2Integral = 0;\n-            final double startX = currentX;\n-            for (int i = 1; i < observations.length; ++i) {\n-                // one step forward\n-                final double previousX = currentX;\n-                final double previousY = currentY;\n-                currentX = observations[i].getX();\n-                currentY = observations[i].getY();\n-\n-                // update the integrals of f<sup>2</sup> and f'<sup>2</sup>\n-                // considering a linear model for f (and therefore constant f')\n-                final double dx = currentX - previousX;\n-                final double dy = currentY - previousY;\n-                final double f2StepIntegral =\n-                    dx * (previousY * previousY + previousY * currentY + currentY * currentY) / 3;\n-                final double fPrime2StepIntegral = dy * dy / dx;\n-\n-                final double x = currentX - startX;\n-                f2Integral += f2StepIntegral;\n-                fPrime2Integral += fPrime2StepIntegral;\n-\n-                sx2 += x * x;\n-                sy2 += f2Integral * f2Integral;\n-                sxy += x * f2Integral;\n-                sxz += x * fPrime2Integral;\n-                syz += f2Integral * fPrime2Integral;\n-            }\n+    // Compute the Jacobian and function values for the least-square fitting\n+    final double[][] jacobian = new double[len][2];\n+    final double[] y = new double[len];\n+    double xStart = Double.NaN;\n+    for (int i = 0; i < len; i++) {\n+        final double x = observations[i].getX();\n+        final double yValue = observations[i].getY();\n+        y[i] = yValue;\n+        if (i == 0) {\n+            xStart = x;\n+        } else {\n+            final double x2 = (x - xStart) * omega;\n+            jacobian[i][0] = FastMath.sin(x2);\n+            jacobian[i][1] = FastMath.cos(x2);\n+        }\n+    }\n \n-            // compute the amplitude and pulsation coefficients\n-            double c1 = sy2 * sxz - sxy * syz;\n-            double c2 = sxy * sxz - sx2 * syz;\n-            double c3 = sx2 * sy2 - sxy * sxy;\n-            if ((c1 / c2 < 0) || (c2 / c3 < 0)) {\n-                final int last = observations.length - 1;\n-                // Range of the observations, assuming that the\n-                // observations are sorted.\n-                final double xRange = observations[last].getX() - observations[0].getX();\n-                if (xRange == 0) {\n-                    throw new ZeroException();\n-                }\n-                omega = 2 * Math.PI / xRange;\n+    // Solve the least-square fitting by QR decomposition\n+    final QRDecomposition qr = new QRDecomposition(jacobian);\n+    final RealVector QTy = qr.solve(new ArrayRealVector(y, false));\n \n-                double yMin = Double.POSITIVE_INFINITY;\n-                double yMax = Double.NEGATIVE_INFINITY;\n-                for (int i = 1; i < observations.length; ++i) {\n-                    final double y = observations[i].getY();\n-                    if (y < yMin) {\n-                        yMin = y;\n-                    }\n-                    if (y > yMax) {\n-                        yMax = y;\n-                    }\n-                }\n-                a = 0.5 * (yMax - yMin);\n-            } else {\n-                    // In some ill-conditioned cases (cf. MATH-844), the guesser\n-                    // procedure cannot produce sensible results.\n+    // Compute the amplitude and pulsation coefficients\n+    a = FastMath.sqrt(QTy.getEntry(0) * QTy.getEntry(0) + QTy.getEntry(1) * QTy.getEntry(1));\n+    omega = 2 * FastMath.atan(QTy.getEntry(1) / QTy.getEntry(0));\n+    if (omega < 0) {\n+        omega += 2 * FastMath.PI;\n+    }\n \n-                a = FastMath.sqrt(c1 / c2);\n-                omega = FastMath.sqrt(c2 / c3);\n-            }\n-        }\n+    // Check if the fitting has converged\n+    if (!qr.isFullRank()) {\n+        throw new ConvergenceException(LocalizedFormats.UNABLE_TO_SOLVE_SINGULAR_PROBLEM);\n+    }\n+}\n \n         /**\n          * Estimate a first guess of the phase.",
    "result_reason": "error: cannot find symbol",
    "test_result": "ERROR"
}